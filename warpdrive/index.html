<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Drive Demo — CST Synced</title>
<style>
  :root {
    --bg:#0d1117; --panel:#161b22; --accent:#59d; --accent2:#9cf; --text:#e6edf3; --muted:#94a3b8;
    --ok:#16a34a; --warn:#eab308; --bad:#ef4444; --shadow: 0 10px 25px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1000px 800px at 20% -10%, #0a0f1a 0%, #0d1117 60%);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{display:flex;gap:16px;align-items:center;justify-content:space-between;padding:16px 24px;border-bottom:1px solid #222}
  header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.5px}
  .container{display:grid;grid-template-columns: 340px 1fr 380px;gap:16px;padding:16px}
  .panel{background:var(--panel);border:1px solid #222;border-radius:16px;box-shadow:var(--shadow);padding:16px}
  .panel h2{margin:0 0 10px 0;font-size:15px;font-weight:700;color:var(--accent2);text-transform:uppercase;letter-spacing:.08em}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:13px}
  select{width:100%;padding:10px;border-radius:10px;border:1px solid #2a3340;background:#0f1420;color:var(--text)}
  .row{display:flex;gap:12px}
  .row > *{flex:1}
  button{cursor:pointer;border:1px solid #2a3340;background:linear-gradient(180deg,#1b2333,#141b28);color:var(--text);padding:12px 14px;border-radius:12px;font-weight:700;box-shadow:var(--shadow)}
  button.primary{border-color:#2b4ea3;background:linear-gradient(180deg,#2b4ea3,#1b2f66)}
  button.ghost{background:transparent}
  .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:8px}
  .metric{background:#0f1420;border:1px solid #232a36;border-radius:12px;padding:10px;text-align:center}
  .metric .label{font-size:12px;color:var(--muted)}
  .metric .value{font-size:18px;font-weight:800;margin-top:4px}
  #log{height:260px;overflow:auto;background:#0a0f1a;border:1px dashed #2a3340;border-radius:10px;padding:10px;font-family:ui-monospace, Menlo, Consolas, monospace;font-size:12px}
  .grid-rows{display:grid;gap:16px}

  /* Map + overlays */
  .map{
    position:relative; z-index:0;
    height:380px;border-radius:12px;border:1px solid #232a36;background:
    radial-gradient(600px 300px at 20% 10%, rgba(88,122,255,.18), transparent 60%),
    linear-gradient(180deg,#0b0f19,#0a0e16)
  }
  #starCanvas{position:absolute; inset:0; width:100%; height:100%; display:block; border-radius:12px; z-index:0}

  .bigHeading {width:100%; text-align:center; font-size:calc(56px * 1.05); font-weight:900; letter-spacing:1px; color:#e8f0ff; text-shadow:0 6px 20px rgba(0,0,0,.6); margin:-2px 0 6px 0;}
  .headingOverlay{
    position:absolute; top:8px; left:50%; transform:translateX(-50%);
    font-weight:900; font-size:calc(26px * 1.05); letter-spacing:1px; color:#e6f0ff;
    text-shadow:0 2px 8px rgba(0,0,0,.55); background:rgba(10,14,22,.35);
    border:1px solid #223; padding:6px 12px; border-radius:12px; z-index:2;
  }

  /* Hazard + course overlays to the right of degrees */
  .hazardOverlay{
    position:absolute; top:8px; left:calc(50% + 230px); transform:translateX(-50%);
    font-weight:1000; font-size:calc(15px * 1.05);
    color:#cfe6ff; background:rgba(10,14,22,.55); border:1px solid #223; padding:8px 12px; border-radius:10px;
    white-space:nowrap; text-shadow:0 1px 8px rgba(0,0,0,.45); z-index:2;
  }
  .hazardOverlay.bad{ color:#ffdddd; border-color:rgba(239,68,68,.6); box-shadow:0 0 22px rgba(239,68,68,.33); }
  @keyframes blinkRed { 0%,49% { opacity:1 } 50%,100% { opacity:.25 } }
  .blink { animation: blinkRed .8s steps(2,end) infinite; }

  .courseOverlay{
    position:absolute; top:36px; left:calc(50% + 230px); transform:translateX(-50%);
    font-weight:800; font-size:14px; color:#e6f0ff;
    background:rgba(10,14,22,.55); border:1px solid #223; padding:6px 10px; border-radius:10px;
    white-space:nowrap; text-shadow:0 1px 8px rgba(0,0,0,.45); z-index:2;
  }

  /* Distance badges (under the hazard strip) */
  .distanceOverlay{
    position:absolute; top:72px; left:calc(50% + 230px); transform:translateX(-50%);
    display:flex; gap:10px; flex-wrap:wrap; z-index:2;
  }
  .distBadge{
    background:#0f1420; border:1px solid #2a3340; border-radius:999px; padding:6px 10px;
    font-size:13px; color:#d6e2ff; text-shadow:0 1px 6px rgba(0,0,0,.25);
  }

  .ops {display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  .lights {display:flex;gap:12px;flex-wrap:wrap}
  .light {display:flex;align-items:center;gap:8px;background:#0f1420;border:1px solid #232a36;border-radius:999px;padding:6px 10px}
  .dot {width:12px;height:12px;border-radius:50%}
  .dot.ok {background:var(--ok)} .dot.warn {background:var(--warn)} .dot.bad {background:var(--bad)}
  .name {font-size:12px;color:#cdd6e3}
  .route {font-size:12px;color:#94a3b8;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .route strong {color:#e6edf3}
  .kv {display:inline-flex;gap:6px;align-items:center}
  .kv label{font-size:12px;color:#94a3b8}
  .kv .val{font-size:12px;color:#e6edf3}
  .mode {display:flex;align-items:center;gap:8px;margin-top:8px}
  .mode .scale {width:100%}

  /* Directions list */
  .directions{margin-top:12px;border:1px dashed #2a3340;border-radius:12px;padding:10px;background:#0f1420}
  .directions h3{margin:0 0 6px 0;font-size:13px;color:#9fb7ff;letter-spacing:.06em;text-transform:uppercase}
  .directions ol{margin:0 0 0 18px;padding:0;color:#cfe1ff;font-size:13px}
  .directions li{margin:4px 0}

  footer{padding:12px 16px;color:var(--muted);font-size:12px;border-top:1px solid #222}

  #savedBox{height:260px; overflow-y:auto; background:#0a0f1a; border:1px dashed #2a3340; border-radius:10px; padding:10px; scrollbar-color:#2a3340 #0a0f1a; scrollbar-width:thin;}
  #savedBox::-webkit-scrollbar { width: 10px; } #savedBox::-webkit-scrollbar-track { background:#0a0f1a; } #savedBox::-webkit-scrollbar-thumb { background:#2a3340; border-radius:8px; } #savedBox::-webkit-scrollbar-thumb:hover { background:#3a4558; }

  @media (max-width: 1100px){
    .container{grid-template-columns:1fr}
    .map{height:320px}
    .hazardOverlay{ left:50%; top:44px }
    .courseOverlay{ left:50%; top:80px }
    .distanceOverlay{ left:50%; top:114px }
  }
</style>
</head>
<body>
  <header>
    <h1>Warp Drive Demonstrator · CST-Synced Equilibrium</h1>
    <div class="flex right">
      <span id="cstBadge" class="badge ok">CST Sync: <strong id="cstClock">--:--:--</strong></span>
      <span id="rhythmBadge" class="badge ok">Bio Rhythm: Stable</span>
    </div>
  </header>

  <main class="container">
    <!-- Left: Controls -->
    <section class="panel">
      <h2>Controls</h2>

      <label for="warp">Warp Factor (1–10)</label>
      <select id="warp">
        <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option><option value="4">Warp 4</option>
        <option value="5" selected>Warp 5</option><option value="6">Warp 6</option><option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option><option value="10">Warp 10</option>
      </select>

      <label for="targetSel" style="margin-top:10px">Target Name</label>
      <select id="targetSel"></select>

      <div class="row" style="margin-top:12px">
        <button id="engage" class="primary">Engage</button>
        <button id="stop">Stop</button>
        <button id="save">Save</button>
      </div>

      <div class="metrics">
        <div class="metric"><div class="label">Front (+E)</div><div id="frontE" class="value">0.00</div></div>
        <div class="metric"><div class="label">Mid (~0)</div><div id="midE" class="value">0.00</div></div>
        <div class="metric"><div class="label">Rear (−E)</div><div id="rearE" class="value">0.00</div></div>
      </div>

      <div style="margin-top:12px" class="row">
        <button id="reset" class="ghost">Reset</button>
        <button id="resetMetrics" class="ghost">Reset Metrics Only</button>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="testAlarm" class="ghost" title="Play alarm.mp3 for 3s">Test Alarm</button>
        <span id="persistBadge" class="badge">Not saved</span>
      </div>

      <div class="mode">
        <label for="timeScale">Time Scale:</label>
        <select id="timeScale" class="scale">
          <option value="1" selected>1× (real seconds)</option>
          <option value="10">10×</option>
          <option value="100">100×</option>
          <option value="1000">1,000×</option>
          <option value="1000000">1,000,000×</option>
        </select>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="printMission" title="Print current mission">Print Mission</button>
        <button id="printAbbr" class="ghost" title="Print abbreviation meanings">Print Abbreviation Mean</button>
      </div>

      <div class="directions">
        <h3>Directions</h3>
        <ol>
          <li>Click <strong>Reset</strong> Button</li>
          <li>Click <strong>Reset Metrics</strong> Button</li>
          <li>Select <strong>Warp Factor</strong></li>
          <li>Select <strong>Target Name</strong></li>
          <li>Select <strong>Time Scale</strong></li>
          <li>Click <strong>Engage</strong> Button</li>
          <li>Click <strong>Save</strong> Mission</li>
          <li>(Optional) <strong>Print Mission</strong> summary</li>
          <li>(Optional) <strong>Print Abbreviation Mean</strong></li>
        </ol>
      </div>
    </section>

    <!-- Center: Visualization / Map -->
    <section class="panel grid-rows">
      <div id="bigHeading" class="bigHeading">000°</div>
      <h2>Navigation Map (Concept)</h2>
      <div id="map" class="map">
        <div id="headingOverlay" class="headingOverlay">HEADING: 000°</div>

        <!-- Warning + course + distance overlays next to degrees -->
        <div id="hazardOverlay" class="hazardOverlay">SAFE</div>
        <div id="courseOverlay" class="courseOverlay">Course: —</div>
        <div id="distanceOverlay" class="distanceOverlay">
          <span class="distBadge" id="distLyBadge">Distance: — ly</span>
          <span class="distBadge" id="distMiBadge">Distance: — miles</span>
        </div>

        <canvas id="starCanvas"></canvas>
      </div>

      <div class="ops">
        <div class="lights">
          <div class="light" id="lightBubble"><span class="dot ok"></span><span class="name">Bubble</span></div>
          <div class="light" id="lightPower"><span class="dot ok"></span><span class="name">Power</span></div>
          <div class="light" id="lightVector"><span class="dot ok"></span><span class="name">Vector</span></div>
          <div class="light" id="lightNav"><span class="dot warn"></span><span class="name">Nav</span></div>
        </div>
        <div class="route">
          <span class="kv"><label>Departure:</label><strong id="depTxt">(unspecified)</strong></span>
          <span>· Earth</span>
          <span class="kv"><label>Arrival:</label><strong id="arrTxt">(unspecified)</strong></span>
          <span class="kv"><label>Travel Clock:</label><span class="val" id="travelClock">00:00:00.000</span></span>
          <span class="kv"><label>Speed of Light:</label><span class="val" id="solTxt">0.00 c</span></span>
          <span class="kv"><label>Parsec:</label><span class="val" id="pcTxt">0.000 pc/yr</span></span>
        </div>
      </div>

      <div class="row">
        <div class="metric"><div class="label">Bubble Velocity (eff.)</div><div id="vEff" class="value">0.00 c</div></div>
        <div class="metric"><div class="label">Pulse Rate</div><div id="pulse" class="value">0.0 MHz</div></div>
        <div class="metric"><div class="label">Loop η</div><div id="eta" class="value">0.000</div></div>
      </div>
    </section>

    <!-- Right: Status & Saved -->
    <aside class="panel grid-rows">
      <h2>Status & Log</h2>
      <div id="log"></div>
      <h2>Saved Missions</h2>
      <div id="savedBox"><div id="saved"></div></div>
    </aside>
  </main>
  <footer>
    Demo only. Timebase is locked to America/Chicago (CST/CDT). Selections persist via localStorage for GitHub Pages deployments.
  </footer>

  <!-- Sounds -->
  <audio id="arriveAudio" src="./warp/arrive.mp3" preload="auto"></audio>
  <audio id="warpAudio"   src="./warp/warp.mp3" preload="auto"></audio>
  <audio id="alarmAudio"  src="https://raw.githubusercontent.com/gabinoc67/interstellar-star-clock/main/warpdrive/alarm.mp3" preload="auto" crossOrigin="anonymous" loop></audio>

<script>
/* ===================== CLOCK (CST) ===================== */
const tz = 'America/Chicago';
const cstClockEl = document.getElementById('cstClock');
function fmtCSTClock(d){
  return new Intl.DateTimeFormat('en-US', { timeZone: tz, hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'}).format(d);
}
setInterval(()=>{
  const d = new Date();
  cstClockEl.textContent = fmtCSTClock(d) + (
    new Intl.DateTimeFormat('en-US',{timeZoneName:'short', timeZone:tz})
      .formatToParts(d).find(p=>p.type==='timeZoneName')?.value.replace('GMT','')||''
  );
}, 250);

/* ===================== HELPERS & STATE ===================== */
const $ = sel => document.querySelector(sel);
function pad(n, w){ return String(n).padStart(w,'0'); }
function monthName(d){ return new Intl.DateTimeFormat('en-US', { timeZone: tz, month:'long' }).format(d); }
function cstTimestampWithPico(d){
  const parts = new Intl.DateTimeFormat('en-US', { timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' }).formatToParts(d);
  const y = parts.find(p=>p.type==='year').value;
  const m = parseInt(parts.find(p=>p.type==='month').value,10);
  const day = parseInt(parts.find(p=>p.type==='day').value,10);
  const hh = parts.find(p=>p.type==='hour').value;
  const mm = parts.find(p=>p.type==='minute').value;
  const pico = pad(Math.floor((performance.now()%1)*1e12), 12);
  return `${monthName(d)} ${day}, ${y}, ${hh}:${mm}, ${pico}`;
}
function setStatus(text){ $("#log").textContent = text; }

/* ===================== ELEMENTS ===================== */
const warpSel = $("#warp"), targetSel = $("#targetSel");
const timeScaleSel = $("#timeScale");
const engageBtn = $("#engage"), stopBtn = $("#stop"), saveBtn = $("#save");
const resetBtn = $("#reset"), resetMetricsBtn = $("#resetMetrics"), testAlarmBtn = $("#testAlarm");
const printMissionBtn = $("#printMission"), printAbbrBtn = $("#printAbbr");

const frontE = $("#frontE"), midE = $("#midE"), rearE = $("#rearE");
const vEff = $("#vEff"), pulse = $("#pulse"), eta = $("#eta");
const savedEl = $("#saved"), persistBadge = $("#persistBadge"), rhythmBadge = $("#rhythmBadge");

const depTxt = $("#depTxt"), arrTxt = $("#arrTxt"), solTxt = $("#solTxt"), pcTxt  = $("#pcTxt"), travelClockEl = $("#travelClock");
const headingOverlay = $("#headingOverlay"), bigHeading = $("#bigHeading");
const hazardOverlay = $("#hazardOverlay"), courseOverlay = $("#courseOverlay");
const distLyBadge = $("#distLyBadge"), distMiBadge = $("#distMiBadge");

const lightBubble = document.querySelector('#lightBubble .dot');
const lightPower  = document.querySelector('#lightPower .dot');
const lightVector = document.querySelector('#lightVector .dot');
const lightNav    = document.querySelector('#lightNav .dot');

const arriveAudio = $("#arriveAudio"), warpAudio = $("#warpAudio"), alarmAudio = $("#alarmAudio");

/* ===================== AUDIO UNLOCK ===================== */
let audioUnlocked = false;
function unlockAudioOnce(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  [alarmAudio, warpAudio, arriveAudio].forEach(a=>{
    a.volume = 0.01;
    a.play().then(()=>{ a.pause(); a.currentTime = 0; a.volume = 1; }).catch(()=>{});
  });
}
document.addEventListener('click', unlockAudioOnce, { once:true });
document.addEventListener('pointerdown', unlockAudioOnce, { once:true });

/* ===================== DATA SOURCES ===================== */
const HAZARDS_URL   = 'https://gabinoc67.github.io/interstellar-star-clock/warpdrive/warp_targets_and_hazards.json';
const DISTANCES_URL = './warp/distances.json';
const TARGETS_URL   = './warp/targets.json';

/* === Fallbacks to match your JSON === */
const fallbackPlanets = ["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune"];
const fallbackMoons   = ["Moon","Europa","Ganymede","Callisto","Titan"];
const fallbackStars   = ["Sirius","Proxima Centauri","Alpha Centauri","Barnard's Star","Ross 128","Epsilon Eridani","Tau Ceti","Kapteyn's Star","Groombridge 34 (GX And)"];
const fallbackGalaxies = ["Andromeda Galaxy (M31)","Triangulum Galaxy (M33)","Large Magellanic Cloud (center)","Small Magellanic Cloud (center)"];

let distancesData = { targets:{} };
let catalog = { planets:[], moons:[], stars:[], galaxies:[] };
let raDecByName = {}; // name → {ra,dec}
let hazardsPack = null;

/* ====== global engine live state (read by chips script) ====== */
window.__engine_live_state = {
  v: 1.25, p: 2.5, f: 0.55, r: -0.55, hazard: 'none'
};
window.__engine_shutdown = false;

/* expose shutdown so chips can call it */
window.requestEngineShutdown = function(reason='too many critical readings'){
  if(window.__engine_shutdown) return;
  window.__engine_shutdown = true;

  stopTravelTicker();
  if(window.starfield) window.starfield.stop();

  // lights all red
  setDot(lightBubble,'bad'); setDot(lightPower,'bad'); setDot(lightVector,'bad'); setDot(lightNav,'bad');

  // banner + sound
  hazardOverlay.classList.add('bad','blink');
  hazardOverlay.textContent = 'ENGINE AUTO-SHUTDOWN';
  courseOverlay.textContent = 'Course: —';
  if(audioUnlocked){ alarmAudio.currentTime = 0; alarmAudio.play().catch(()=>{}); }

  setStatus('AUTO-SHUTDOWN: ' + reason);
};

/* ===================== TARGET CATALOG & UI ===================== */
function makeTargetsFlat(){
  const p = (catalog.planets||[]).map(o=>o.name).filter(Boolean);
  const m = (catalog.moons||[]).map(o=>o.name).filter(Boolean);
  const s = (catalog.stars||[]).map(o=>o.name).filter(Boolean);
  const g = (catalog.galaxies||[]).map(o=>o.name).filter(Boolean);
  return {
    Planets: p.length ? p : fallbackPlanets.slice(),
    Moons:   m.length ? m : fallbackMoons.slice(),
    Stars:   s.length ? s : fallbackStars.slice(),
    Galaxies:g.length ? g : fallbackGalaxies.slice()
  };
}
let allTargets = makeTargetsFlat();

function populateTargetOptgroups(selectedValue=""){
  const groups = allTargets;
  let html = `<option value="">(select target)</option>`;
  for(const label of ["Planets","Moons","Stars","Galaxies"]){
    const items = groups[label] || [];
    if(!items.length) continue;
    html += `<optgroup label="${label}">` +
      items.map(n=>`<option value="${n}" ${n===selectedValue?'selected':''}>${n}</option>`).join('') +
    `</optgroup>`;
  }
  targetSel.innerHTML = html;
}
function classifyTarget(name){
  if(!name) return 'custom';
  if( (catalog.planets||[]).some(o=>o.name===name) || fallbackPlanets.includes(name)) return 'planet';
  if( (catalog.moons||[]).some(o=>o.name===name)   || fallbackMoons.includes(name))   return 'moon';
  if( (catalog.stars||[]).some(o=>o.name===name)   || fallbackStars.includes(name))   return 'star';
  if( (catalog.galaxies||[]).some(o=>o.name===name)|| fallbackGalaxies.includes(name))return 'galaxy';
  return 'custom';
}

/* Load catalogs + hazards (no-cache to see updates) */
Promise.allSettled([
  fetch(TARGETS_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject()),
  fetch(DISTANCES_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject()),
  fetch(HAZARDS_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject())
]).then(results=>{
  const [catRes, distRes, hazRes] = results;
  if(catRes.status==='fulfilled' && catRes.value){
    const cat = catRes.value;
    catalog = {
      planets: Array.isArray(cat.planets)?cat.planets:[],
      moons: Array.isArray(cat.moons)?cat.moons:[],
      stars: Array.isArray(cat.stars)?cat.stars:[],
      galaxies: Array.isArray(cat.galaxies)?cat.galaxies:[]
    };
    raDecByName = {};
    (catalog.stars||[]).forEach(o=>{ if(o?.name) raDecByName[o.name] = { ra:o.ra_deg, dec:o.dec_deg }; });
    (catalog.galaxies||[]).forEach(o=>{ if(o?.name) raDecByName[o.name] = { ra:o.ra_deg, dec:o.dec_deg }; });
  }
  if(distRes.status==='fulfilled' && distRes.value) distancesData = distRes.value;
  if(hazRes.status==='fulfilled' && hazRes.value) { hazardsPack = hazRes.value; setStatus('Hazards online.'); }

  allTargets = makeTargetsFlat();
  populateTargetOptgroups("");
  updateMetricsStatic();      // steady & ready
  updatePreEngageStatus();    // lights baseline
  updateStarfieldHeading();
  renderSaves();
  updateDistanceBadges();
  setStatus('System initialized. Ready to engage.');

  // start starfield idle if you like; otherwise comment next line
  if(window.starfield) window.starfield.start();
  hazardLoop();
}).catch(()=>{
  allTargets = makeTargetsFlat(); // fallbacks
  populateTargetOptgroups("");
  setStatus('Loaded with fallbacks. (Targets/Hazards JSON not found)');
  updateDistanceBadges();
});

/* Keep clocks at 0 while selecting */
warpSel.addEventListener('change', ()=>{ updateMetricsStatic(); updateStarfieldHeading(); saveUI(); setStatus('Warp set.'); });
targetSel.addEventListener('change', ()=>{ updatePreEngageStatus(); updateStarfieldHeading(); updateDistanceBadges(); saveUI(); });

function getSelectedTarget(){ return (targetSel.value||'').trim(); }

/* ===================== PHYSICS & METRICS ===================== */
const C_KM_S = 299792.458;
const KM_PER_LY = 9.4607304725808e12;
const MI_PER_KM = 0.621371;
const SECONDS_PER_YEAR = 31557600;

function computeVEffFromWarp(w){ return Math.min(0.2*w + 0.1*w*w/10, 10); }
function baseMetricsFromWarp(w){
  const v = computeVEffFromWarp(w);
  return { vEff: v, pulse: w*0.5, eta: 0.995 + w*0.0004, front: w*0.11, mid: 0, rear: -w*0.11 };
}
function vEffNumber(){ return parseFloat((vEff.textContent||'0').replace(' c',''))||0; }

/* ===== live light states from metrics (green/yellow/red) ===== */
function setDot(el, state){ el.classList.remove('ok','warn','bad'); el.classList.add(state); updateAlarm(); }
function setAllGreen(){ setDot(lightBubble,'ok'); setDot(lightPower,'ok'); setDot(lightVector,'ok'); setDot(lightNav,'ok'); }
function setLightStatesFromMetrics(v, p, f, r){
  const diff = Math.abs(f - Math.abs(r));
  const bubbleState = v < 1.5 ? 'ok' : v < 3 ? 'warn' : 'bad';
  const powerState  = p < 4   ? 'ok' : p < 6 ? 'warn' : 'bad';
  const vectorState = diff < 0.9 ? 'ok' : diff < 1.8 ? 'warn' : 'bad';
  setDot(lightBubble, bubbleState);
  setDot(lightPower,  powerState);
  setDot(lightVector, vectorState);
  // Nav handled in hazard monitor
}

/* ===================== LOOKUPS & CONVERSIONS ===================== */
function lookupDistance(targetName){
  if(!targetName) return null;
  const t = distancesData?.targets?.[targetName];
  if(!t) return null;
  return { distance: Number(t.distance), unit: t.unit };
}
function distanceToLyMi(targetName){
  const d = lookupDistance(targetName);
  if(!d) return null;
  let ly, mi;
  if(d.unit === 'ly'){
    ly = d.distance;
    mi = (d.distance * KM_PER_LY * MI_PER_KM);
  } else if(d.unit === 'km'){
    ly = d.distance / KM_PER_LY;
    mi = d.distance * MI_PER_KM;
  } else if(d.unit === 'au'){
    const KM_PER_AU = 149597870.7;
    ly = (d.distance * KM_PER_AU) / KM_PER_LY;
    mi = d.distance * KM_PER_AU * MI_PER_KM;
  } else if(d.unit === 'pc'){
    ly = d.distance * 3.26156;
    mi = ly * KM_PER_LY * MI_PER_KM;
  } else {
    return null;
  }
  return { ly, mi };
}
function updateDistanceBadges(){
  const tgt = getSelectedTarget();
  const conv = distanceToLyMi(tgt);
  if(!conv){
    distLyBadge.textContent = 'Distance: — ly';
    distMiBadge.textContent = 'Distance: — miles';
    return;
  }
  distLyBadge.textContent = `Distance: ${conv.ly.toLocaleString(undefined,{maximumFractionDigits:3})} ly`;
  distMiBadge.textContent = `Distance: ${conv.mi.toLocaleString(undefined,{maximumFractionDigits:0})} miles`;
}
function computeRealEtaSeconds(targetName){
  const d = lookupDistance(targetName);
  const v = Math.max(0.01, vEffNumber());
  if(!d){
    const cls = classifyTarget(targetName);
    const fallbackUnits = { moon:6, planet:12, star:60, galaxy:200, custom:20 };
    return (fallbackUnits[cls] || 20) / v;
  }
  if(d.unit === 'ly'){ return (d.distance / v) * SECONDS_PER_YEAR; }
  if(d.unit === 'km'){ return d.distance / (v * C_KM_S); }
  if(d.unit === 'pc'){ return ((d.distance*3.26156) / v) * SECONDS_PER_YEAR; }
  return 10;
}
function maxEtaSecondsAtCurrentWarp(){
  const v = Math.max(0.01, vEffNumber());
  let maxSec = 0;
  const tgs = distancesData?.targets || {};
  for(const k in tgs){
    const rec = tgs[k]; if(!rec) continue;
    let sec = 0;
    if(rec.unit === 'ly') sec = (Number(rec.distance) / v) * SECONDS_PER_YEAR;
    else if(rec.unit === 'km') sec = Number(rec.distance) / (v * C_KM_S);
    else if(rec.unit === 'pc') sec = (Number(rec.distance)*3.26156 / v) * SECONDS_PER_YEAR;
    if(sec > maxSec) maxSec = sec;
  }
  return Math.max(maxSec, 60);
}

/* ===================== LIGHTS & STATUS ===================== */
function anyBad(){ return [lightBubble, lightPower, lightVector, lightNav].some(el => el.classList.contains('bad')); }
function updateAlarm(){
  if(anyBad() && audioUnlocked){
    alarmAudio.play().catch(()=>{});
  } else {
    alarmAudio.pause();
    alarmAudio.currentTime = 0;
  }
}
function updatePreEngageStatus(){
  // Engine steady & ready at current warp, Nav warns if no target yet
  const w = Number(warpSel.value);
  const m = baseMetricsFromWarp(w);
  setLightStatesFromMetrics(m.vEff, m.pulse, m.front, m.rear);
  const t = getSelectedTarget();
  setDot(lightNav, t ? 'ok' : 'warn');
  arrTxt.textContent = t || '(unspecified)';
  travelClockEl.textContent = "00:00:00.000";
  rhythmBadge.className = 'badge ok';
  rhythmBadge.textContent = 'Bio Rhythm: CST-Locked';

  // publish to chips
  window.__engine_live_state = { v:m.vEff, p:m.pulse, f:m.front, r:m.rear, hazard: (window.__hazard_mode||'none') };
}

/* ===================== BEARING UTIL ===================== */
function bearingFromRaDec(raDeg, decDeg){
  const ra = raDeg * Math.PI/180, dec = decDeg * Math.PI/180;
  let deg = Math.atan2(Math.cos(dec)*Math.sin(ra), Math.cos(dec)*Math.cos(ra)) * 180/Math.PI;
  if(deg<0) deg+=360;
  return deg;
}
function angularSep(a,b){ return Math.abs(((a-b)%360+540)%360-180); }

/* ===================== STARFIELD ===================== */
(function initStarfield(){
  const map = document.getElementById('map');
  const cvs = document.getElementById('starCanvas');
  const ctx = cvs.getContext('2d', {alpha:false});

  function dims(){
    return { W: map.clientWidth || 800, H: map.clientHeight || 400, dpr: Math.max(1, Math.floor(window.devicePixelRatio||1)) };
  }
  function resize(){
    const {W,H,dpr} = dims();
    cvs.style.width  = W+'px';
    cvs.style.height = H+'px';
    cvs.width  = W * dpr;
    cvs.height = H * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  const STAR_COUNT = window.innerWidth < 600 ? 360 : 620;
  const stars = [];
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function makeStar(){
    const {W,H} = dims();
    return { x: rand(0, W), y: rand(0, H), z: rand(0.2, 1.0), r: rand(0.6, 1.6), tw: rand(0.5, 1.0) };
  }
  for(let i=0;i<STAR_COUNT;i++) stars.push(makeStar());

  let targetHeadingDeg = 0;
  let overrideHeadingDeg = null;
  let overrideUntil = 0;

  function updateHeadingFromTarget(){
    const name = getSelectedTarget();
    const rec = raDecByName[name||''] || null;
    if(rec && rec.ra!=null && rec.dec!=null){
      targetHeadingDeg = bearingFromRaDec(rec.ra, rec.dec);
    } else {
      const t = (name||'forward');
      let h=0; for(let i=0;i<t.length;i++){ h=(h*31 + t.charCodeAt(i))>>>0; }
      targetHeadingDeg = h % 360;
    }
  }
  updateHeadingFromTarget();

  window.starfield = {
    running:false, raf:null,
    start(){ if(this.running) return; this.running = true; cancelAnimationFrame(this.raf); this.raf = requestAnimationFrame(this.frame.bind(this)); },
    stop(){ this.running = false; cancelAnimationFrame(this.raf); },
    setHeading(){ updateHeadingFromTarget(); },
    setOverride(deg, ms){ overrideHeadingDeg = ((deg%360)+360)%360; overrideUntil = performance.now() + ms; },
    frame(){
      if(!this.running) return;
      const {W,H} = dims();
      ctx.fillStyle = '#060a12';
      ctx.fillRect(0,0,W,H);

      if(performance.now() > overrideUntil) overrideHeadingDeg = null;
      const headingDeg = (overrideHeadingDeg!=null) ? overrideHeadingDeg : targetHeadingDeg;
      window.currentHeadingDeg = headingDeg; // expose for hazard UI

      const rad = (headingDeg * Math.PI/180);
      const hvx = Math.cos(rad), hvy = Math.sin(rad);

      const w = Number(warpSel.value||1);
      const curv = Math.max(0, Math.min(90, ((w-1)/9)*90));
      const sizeFactor = 1 + (curv/45);
      const thickness = 0.6 + (curv/90)*1.2;

      const etaThis = computeRealEtaSeconds(getSelectedTarget());
      const etaMax  = maxEtaSecondsAtCurrentWarp();
      const longFrac = Math.max(0.0, Math.min(1.0, etaThis / etaMax));
      const baseTail = 8 + (w-1)*1.2;
      const tailLen  = baseTail * (0.25 + 1.75*longFrac);

      const t = performance.now()/1000;

      for(const s of stars){
        const alpha = 0.55 + 0.45 * Math.sin((t*600) * s.tw + (s.x+s.y)*0.002);
        const rBase = s.r*(0.6+0.8*s.z);
        const halfW = rBase * sizeFactor;
        const halfH = rBase * (0.7 + 0.3*s.z);

        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(Math.atan2(-hvy, -hvx));
        ctx.fillStyle = `rgba(210,225,255,${alpha})`;
        ctx.beginPath(); ctx.ellipse(0, 0, halfW, halfH, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();

        ctx.strokeStyle = `rgba(210,225,255,${alpha*0.9})`;
        ctx.lineWidth = thickness;
        ctx.beginPath(); ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x + tailLen * (-hvx), s.y + tailLen * (-hvy));
        ctx.stroke();
      }

      const dStr = String(Math.round(((headingDeg)%360+360)%360)).padStart(3,'0');
      headingOverlay.textContent = `HEADING: ${dStr}°`;
      bigHeading.textContent = `${dStr}°`;

      this.raf = requestAnimationFrame(this.frame.bind(this));
    }
  };
})();
function updateStarfieldHeading(){ if(window.starfield) window.starfield.setHeading(); }

/* ===================== TRAVEL TICKER & FLIGHT ===================== */
let travelTicker = null;
let travelClockMs = 0;
let travelStartRealMs = 0;
let travelAccumMs = 0;

function formatClock(ms){
  const h = Math.floor(ms/3600000);
  const m = Math.floor((ms%3600000)/60000);
  const s = Math.floor((ms%60000)/1000);
  const z = Math.floor(ms%1000);
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(z).padStart(3,'0')}`;
}
function startTravelTicker(){
  stopTravelTicker();
  travelStartRealMs = performance.now();

  travelTicker = setInterval(()=>{
    const now = performance.now();

    // ---- Metrics (depend on warp) ----
    const w = Number(warpSel.value);
    const base = baseMetricsFromWarp(w);
    const t = now/1000;
    const wobble = (amp)=> amp * Math.sin(t*2.1) * Math.cos(t*0.7);
    const vNow = Math.max(0, base.vEff + wobble(0.05*base.vEff + 0.03));
    const pNow = Math.max(0, base.pulse + wobble(0.06*base.pulse + 0.05));
    const eNow = Math.min(1.005, Math.max(0.990, base.eta + wobble(0.0015)));
    const fNow = base.front + wobble(0.03*base.front + 0.01);
    const mNow = 0 + wobble(0.01);
    const rNow = base.rear + wobble(0.03*(-base.rear) + 0.01);

    vEff.textContent = `${vNow.toFixed(2)} c`;
    pulse.textContent = `${pNow.toFixed(1)} MHz`;
    eta.textContent = eNow.toFixed(3);
    frontE.textContent = fNow.toFixed(2);
    midE.textContent = mNow.toFixed(2);
    rearE.textContent = rNow.toFixed(2);
    solTxt.textContent = `${vNow.toFixed(2)} c`;
    pcTxt.textContent  = `${(vNow/3.26156).toFixed(3)} pc/yr`;

    // update lights live from metrics
    setLightStatesFromMetrics(vNow, pNow, fNow, rNow);

    // publish to chips
    window.__engine_live_state = { v:vNow, p:pNow, f:fNow, r:rNow, hazard:(window.__hazard_mode||'none') };

    // ---- Clock ----
    const scale = Number(timeScaleSel.value || 1);
    travelClockMs = travelAccumMs + (now - travelStartRealMs) * scale;
    travelClockEl.textContent = formatClock(travelClockMs);

    // ---- Arrival check ----
    const flight = loadFlightState();
    if (flight && flight.active) {
      const etaMs = (flight.etaSec||0) * 1000;
      if (travelClockMs >= etaMs) arriveSequence();
    }
  }, 100);
}
function stopTravelTicker(){
  if(travelTicker){ clearInterval(travelTicker); travelTicker = null; }
  travelAccumMs = travelClockMs;
}

const FLIGHT_KEY = 'warp-demo:flight';
function saveFlightState(state){ localStorage.setItem(FLIGHT_KEY, JSON.stringify(state)); }
function loadFlightState(){ try { return JSON.parse(localStorage.getItem(FLIGHT_KEY))||null } catch(e){ return null } }
function clearFlightState(){ localStorage.removeItem(FLIGHT_KEY); }

/* ===================== METRICS DISPLAY ===================== */
function updateMetricsStatic(){
  const w = Number(warpSel.value || 5);
  const m = baseMetricsFromWarp(w);
  frontE.textContent = m.front.toFixed(2);
  midE.textContent   = m.mid.toFixed(2);
  rearE.textContent  = m.rear.toFixed(2);
  vEff.textContent   = `${m.vEff.toFixed(2)} c`;
  pulse.textContent  = `${m.pulse.toFixed(1)} MHz`;
  eta.textContent    = m.eta.toFixed(3);
  solTxt.textContent = `${m.vEff.toFixed(2)} c`;
  pcTxt.textContent  = `${(m.vEff/3.26156).toFixed(3)} pc/yr`;
  setLightStatesFromMetrics(m.vEff, m.pulse, m.front, m.rear);
  window.__engine_live_state = { v:m.vEff, p:m.pulse, f:m.front, r:m.rear, hazard:(window.__hazard_mode||'none') };
}
function zeroMetrics(){
  frontE.textContent="0.00"; midE.textContent="0.00"; rearE.textContent="0.00";
  vEff.textContent="0.00 c"; pulse.textContent="0.0 MHz"; eta.textContent="0.000";
  solTxt.textContent="0.00 c"; pcTxt.textContent="0.000 pc/yr";
  window.__engine_live_state = { v:0, p:0, f:0, r:0, hazard:(window.__hazard_mode||'none') };
}

/* ===================== SAVED MISSIONS ===================== */
const KEY = 'warp-demo:saves';
function loadSaves(){ try { return JSON.parse(localStorage.getItem(KEY))||[] } catch(e){ return [] } }
function saveSaves(arr){ localStorage.setItem(KEY, JSON.stringify(arr)); }
function renderSaves(){
  const arr = loadSaves();
  savedEl.innerHTML = arr.length? '' : '<span class="muted">No saved missions yet.</span>';
  arr.forEach((m,i)=>{
    const tag = document.createElement('div');
    tag.className='saved-tag';
    tag.textContent = `#${i+1} · ${m.when} CST · Warp ${m.warp} → ${m.target}`;
    tag.title = 'Click to load';
    tag.onclick = ()=>{
      warpSel.value = m.warp;
      populateTargetOptgroups(m.target);
      setStatus(`Loaded mission #${i+1}`);
      updatePreEngageStatus();
      updateStarfieldHeading();
      updateDistanceBadges();
      saveUI();
    };
    savedEl.appendChild(tag);
  });
  persistBadge.textContent = arr.length? 'Saved ✓' : 'Not saved';
}
saveBtn.onclick = ()=>{
  const arr = loadSaves();
  const m = {
    warp:   String(warpSel.value),
    target: getSelectedTarget() || '(unspecified)',
    when:   new Intl.DateTimeFormat('en-US', { timeZone: tz, dateStyle:'medium', timeStyle:'short' }).format(new Date())
  };
  arr.unshift(m);
  saveSaves(arr.slice(0,25));
  renderSaves();
  setStatus('Mission saved.');
};

/* ===================== UI PERSIST ===================== */
const UI_KEY = 'warp-demo:ui';
function saveUI(){
  const rec = { warp: warpSel.value, target: getSelectedTarget(), timeScale: timeScaleSel.value };
  localStorage.setItem(UI_KEY, JSON.stringify(rec));
}
function loadUI(){
  try {
    const rec = JSON.parse(localStorage.getItem(UI_KEY));
    if(!rec) return false;
    warpSel.value = rec.warp || '5';
    populateTargetOptgroups(rec.target || "");
    timeScaleSel.value = rec.timeScale || '1';
    updateMetricsStatic();
    updatePreEngageStatus();
    updateStarfieldHeading();
    return true;
  } catch(e){ return false; }
}

/* ===================== FLIGHT ACTIONS ===================== */
function currentState(){ return { warp: warpSel.value, target: (getSelectedTarget()||'(unspecified)') }; }

engageBtn.onclick = ()=>{
  if(window.__engine_shutdown){ setStatus('Cannot engage: engine is in AUTO-SHUTDOWN. Reset first.'); return; }
  unlockAudioOnce();
  const tgt = getSelectedTarget();
  if(!tgt){
    setDot(lightNav,'bad');
    setTimeout(()=>updatePreEngageStatus(), 1200);
    setStatus('Select a target before Engage.');
    return;
  }

  updateMetricsStatic();
  updateStarfieldHeading();
  if(window.starfield) window.starfield.start();

  const when = new Date();
  depTxt.textContent = cstTimestampWithPico(when);
  arrTxt.textContent = tgt;

  const etaSec = computeRealEtaSeconds(tgt);
  if (warpAudio){ warpAudio.currentTime = 0; warpAudio.play().catch(()=>{}); }
  setAllGreen();

  const record = { active:true, startMs: Date.now(), etaSec, timeScale: Number(timeScaleSel.value||1), warp: warpSel.value, target: tgt };
  saveFlightState(record);

  travelAccumMs = 0; travelClockMs = 0; travelStartRealMs = performance.now();
  startTravelTicker();
  updateDistanceBadges();

  setStatus(`ENGAGE → Warp ${record.warp} to ${record.target} · Scale ${record.timeScale}× · ETA ~ ${Math.round(etaSec)} s`);
};

stopBtn.onclick = ()=>{
  const r = loadFlightState();
  if(r && r.active){ r.active = false; saveFlightState(r); }
  stopTravelTicker();
  if(window.starfield) window.starfield.stop();
  setAllGreen();
  setDot(lightNav,'ok');

  window.__engine_shutdown = false;
  alarmAudio.pause(); alarmAudio.currentTime = 0;
  hazardOverlay.classList.remove('bad','blink');
  hazardOverlay.textContent = 'SAFE';
  courseOverlay.textContent = 'Course: —';
  setStatus('Mission stopped.');
};

resetBtn.onclick = ()=>{
  unlockAudioOnce();
  localStorage.removeItem(KEY);
  renderSaves();

  warpSel.value = "5";
  populateTargetOptgroups("");

  const r = loadFlightState();
  if(r && r.active){ r.active=false; saveFlightState(r); }
  clearFlightState();

  stopTravelTicker();
  if(window.starfield) window.starfield.stop();
  depTxt.textContent = "(unspecified)";
  arrTxt.textContent = "(unspecified)";
  updateMetricsStatic();
  updatePreEngageStatus();
  updateDistanceBadges();

  window.__engine_shutdown = false;
  alarmAudio.pause(); alarmAudio.currentTime = 0;
  hazardOverlay.classList.remove('bad','blink');
  hazardOverlay.textContent = 'SAFE';
  courseOverlay.textContent = 'Course: —';

  setStatus('Reset complete. Engine steady & ready.');
  localStorage.removeItem(UI_KEY);

  travelAccumMs = 0; travelClockMs = 0;
};

resetMetricsBtn.onclick = ()=>{ unlockAudioOnce(); zeroMetrics(); setStatus('Metrics reset to zero.'); };

timeScaleSel.addEventListener('change', ()=>{
  travelAccumMs = travelClockMs;
  travelStartRealMs = performance.now();

  const r = loadFlightState();
  if(r && r.active){
    r.timeScale = Number(timeScaleSel.value||1);
    saveFlightState(r);
    setStatus(`Time Scale set to ${r.timeScale}×`);
  }
  saveUI();
});

testAlarmBtn.onclick = ()=>{
  unlockAudioOnce();
  lightPower.classList.remove('ok','warn','bad'); lightPower.classList.add('bad');
  alarmAudio.currentTime = 0; alarmAudio.play().catch(()=>{});
  setTimeout(()=>{
    alarmAudio.pause(); alarmAudio.currentTime = 0;
    lightPower.classList.remove('ok','warn','bad'); lightPower.classList.add('ok');
  }, 3000);
};

/* ======== ARRIVAL SEQUENCE ======== */
function arriveSequence(){
  const r = loadFlightState();
  if(!r || !r.active) return;
  r.active = false; saveFlightState(r);
  stopTravelTicker();
  if(window.starfield) window.starfield.stop();
  if(arriveAudio){ arriveAudio.currentTime = 0; arriveAudio.play().catch(()=>{}); }
  setAllGreen(); setDot(lightNav,'ok');
  setStatus(`ARRIVED at ${r.target}. Travel complete.`);
  arrTxt.textContent = `${r.target} (arrived)`;
}

/* ===================== HAZARD MONITOR ===================== */
function hazardTypeLabel(raw){
  const s = String(raw||'').toLowerCase();
  if(s.includes('super')) return 'SUPERNOVA';
  if(s.includes('black')) return 'BLACK HOLE';
  if(s.includes('gamma')) return 'GAMMA RAY BURST';
  if(s.includes('radiation')) return 'RADIATION BURST';
  return (raw||'HAZARD').toString().toUpperCase();
}
const SAFE_DEFAULT = { 'SUPERNOVA':50, 'BLACK HOLE':0.1, 'GAMMA RAY BURST':2000, 'RADIATION BURST':100 };
function normalizeHazard(h){
  const name = h.hazard_name ?? h.name ?? h.target_name ?? 'Unnamed';
  const type = hazardTypeLabel(h.hazard_type ?? h.type ?? h.kind);
  const dly  = Number(h.hazard_distance_ly ?? h.distance_ly ?? h.dist_ly ?? h.distance) || NaN;
  const safe = Number(h.safe_distance_ly ?? h.safe_ly ?? SAFE_DEFAULT[type] ?? 25);
  const vec  = h.hazard_vector ?? h.vector ?? {};
  const ra   = (vec.ra_deg ?? vec.ra ?? null);
  const dec  = (vec.dec_deg ?? vec.dec ?? null);
  return { name, type, d: dly, safe, ra, dec };
}
function hazardLoop(){ evaluateHazards(); setInterval(evaluateHazards, 1000); }
function fmtDeg(n){ return String(Math.round(((n%360)+360)%360)).padStart(3,'0') + '°'; }
window.__hazard_mode = 'none';
function evaluateHazards(){
  if(!hazardsPack || !Array.isArray(hazardsPack.hazards)){
    window.__hazard_mode = 'none';
    hazardOverlay.classList.remove('bad','blink');
    hazardOverlay.textContent = 'SAFE';
    courseOverlay.textContent = 'Course: —';
    return;
  }
  const rows = hazardsPack.hazards.map(normalizeHazard).filter(x=>isFinite(x.d) && isFinite(x.safe));
  const heading = (typeof window.currentHeadingDeg==='number') ? window.currentHeadingDeg : 0;

  let hit = null; let mode = 'none';
  for(const r of rows){
    if(r.ra==null || r.dec==null) continue;
    const bearing = bearingFromRaDec(r.ra, r.dec);
    const sep = angularSep(heading, bearing);
    const withinCone = sep <= 18;
    const isInside = r.d <= r.safe;
    const near = r.d <= r.safe * 3.0;
    const watch = r.d <= r.safe * 8.0;
    if(withinCone && (isInside || near || watch)){
      const thisMode = isInside ? 'inside' : (near ? 'approach' : 'standby');
      if(!hit || sep < hit.sep){ hit = {r, bearing, sep}; mode = thisMode; }
    }
  }
  window.__hazard_mode = mode;

  if(hit){
    let away = heading; let label = '';
    if(mode==='standby'){
      hazardOverlay.classList.remove('bad','blink');
      label = `STANDBY: ${hit.r.type} — ${hit.r.name}`;
      setDot(lightNav, 'warn'); away = (hit.bearing + 30) % 360;
      if(audioUnlocked) { alarmAudio.pause(); alarmAudio.currentTime = 0; }
    } else if(mode==='approach'){
      hazardOverlay.classList.add('bad','blink');
      label = `⚠️ APPROACHING: ${hit.r.type} — ${hit.r.name}`;
      setDot(lightNav, 'bad'); away = (hit.bearing + 60) % 360;
      if(audioUnlocked) alarmAudio.play().catch(()=>{});
      if(window.starfield){ window.starfield.setOverride(away, 8000); }
    } else {
      hazardOverlay.classList.add('bad','blink');
      label = `🚨 INSIDE SAFE LIMIT: ${hit.r.type} — ${hit.r.name}`;
      setDot(lightNav, 'bad'); away = (hit.bearing + 150) % 360;
      if(audioUnlocked) alarmAudio.play().catch(()=>{});
      if(window.starfield){ window.starfield.setOverride(away, 14000); }
    }
    hazardOverlay.textContent = label;

    const cur = heading;
    let delta = Math.round(((away - cur + 540) % 360) - 180);
    const sign = delta>0 ? '+' : (delta<0 ? '−' : '±');
    const absd = Math.abs(delta);
    courseOverlay.textContent = `Course: ${fmtDeg(cur)} → ${fmtDeg(away)} (Δ ${sign}${String(absd).padStart(2,'0')}°)`;

  } else {
    hazardOverlay.classList.remove('bad','blink');
    hazardOverlay.textContent = 'SAFE';
    courseOverlay.textContent = 'Course: —';
    if(!anyBad() && audioUnlocked){ alarmAudio.pause(); alarmAudio.currentTime = 0; }
    setDot(lightNav,'ok');
  }

  const s = window.__engine_live_state || {};
  window.__engine_live_state = { v:s.v||0, p:s.p||0, f:s.f||0, r:s.r||0, hazard: window.__hazard_mode };
}

/* ===================== PRINT BUTTONS ===================== */
function getCsvUrl(){
  const el = document.getElementById('wdp-chips');
  return (el && el.dataset.wdpCsv) ? el.dataset.wdpCsv : new URL('navengreadings.csv', location.href).href;
}
function simpleCSV(text){
  const rows=[]; let cur=[], val="", q=false;
  for(let i=0;i<text.length;i++){
    const c=text[i], n=text[i+1];
    if(q){ if(c=='"'&&n=='"'){val+='"';i++;} else if(c=='"'){q=false;} else { val+=c; } }
    else { if(c=='"'){q=true;} else if(c==','){cur.push(val); val="";} else if(c=='\n'){cur.push(val); rows.push(cur); cur=[]; val="";} else if(c!='\r'){val+=c;} }
  }
  if(val.length||cur.length){cur.push(val);rows.push(cur);}
  const headers = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>String(x).trim()!=='')).map(r=>{ const o={}; headers.forEach((h,i)=>o[h]=r[i]??""); return o; });
}
printMissionBtn.onclick = ()=>{
  const w = String(warpSel.value);
  const tgt = getSelectedTarget() || '(unspecified)';
  const scale = String(timeScaleSel.value||'1');
  const nowStr = new Intl.DateTimeFormat('en-US',{ timeZone: tz, dateStyle:'medium', timeStyle:'short' }).format(new Date());
  const html = `
    <html><head><title>Mission Print</title>
    <style>body{font:14px/1.4 system-ui;padding:20px} h1{margin:0 0 8px} table{border-collapse:collapse} td{padding:6px 10px;border:1px solid #999}</style>
    </head><body>
      <h1>Warp Drive Mission</h1>
      <table>
        <tr><td><b>Printed</b></td><td>${nowStr} (${tz})</td></tr>
        <tr><td><b>Warp</b></td><td>${w}</td></tr>
        <tr><td><b>Target</b></td><td>${tgt}</td></tr>
        <tr><td><b>Time Scale</b></td><td>${scale}×</td></tr>
        <tr><td><b>Departure</b></td><td>${depTxt.textContent}</td></tr>
        <tr><td><b>Arrival</b></td><td>${arrTxt.textContent}</td></tr>
        <tr><td><b>Travel Clock</b></td><td>${travelClockEl.textContent}</td></tr>
        <tr><td><b>vEff</b></td><td>${vEff.textContent}</td></tr>
        <tr><td><b>Pulse</b></td><td>${pulse.textContent}</td></tr>
        <tr><td><b>η</b></td><td>${eta.textContent}</td></tr>
      </table>
      <script>window.print();<\/script>
    </body></html>`;
  const wdw = window.open('', '_blank'); if(wdw){ wdw.document.write(html); wdw.document.close(); }
};
printAbbrBtn.onclick = async ()=>{
  try{
    const res = await fetch(getCsvUrl(), {cache:'no-store'}); if(!res.ok) throw new Error(res.status);
    const rows = simpleCSV(await res.text());
    const norm = rows.map(r=>{ const o={}; for(const k in r){ o[k.trim()]=typeof r[k]==='string'?r[k].trim():r[k]; } return o; });
    const htmlRows = norm.map(o=>{
      const label = o['Label Name'] ?? o['Label'] ?? '';
      const abbr  = o['Abbreviation'] ?? o['Abbrev'] ?? '';
      const type  = (o['Display Type']??'').toString();
      const loc   = (o['Location']??'').toString();
      return `<tr><td>${abbr}</td><td>${label}</td><td>${type}</td><td>${loc}</td></tr>`;
    }).join('');
    const html = `
    <html><head><title>Abbreviations</title>
    <style>body{font:14px/1.4 system-ui;padding:20px} h1{margin:0 0 8px} table{border-collapse:collapse;width:100%} th,td{padding:6px 8px;border:1px solid #999;text-align:left} th{background:#f2f2f2}</style>
    </head><body>
      <h1>Abbreviation Mean</h1>
      <table>
        <thead><tr><th>Abbreviation</th><th>Label Name</th><th>Display Type</th><th>Location</th></tr></thead>
        <tbody>${htmlRows}</tbody>
      </table>
      <script>window.print();<\/script>
    </body></html>`;
    const wdw = window.open('', '_blank'); if(wdw){ wdw.document.write(html); wdw.document.close(); }
  }catch(e){ setStatus('Could not load CSV to print abbreviations.'); }
};
</script>
<!-- ===== CSV-driven chips directly under the footer line (layout + animations) ===== -->
<style>
  /* Full-width container: no wasted side margins */
  .wdp-wrap{
    width:100%;
    max-width:none;             /* remove previous 1600px clamp */
    margin:8px 0 16px;          /* no side auto-centering */
    padding:0 12px;
  }

  /* Main two-row grid layout (full width) */
  .wdp-sections{
    display:grid;
    gap:12px;
    grid-template-columns: 1fr 1fr 1fr;   /* Nav | Engine | Crew/Ship */
    grid-template-rows: auto auto;
    grid-template-areas:
      "nav engine crew"
      "nav engine ship";
  }

  /* Card placement */
  .wdp-card[data-loc="Navigation"] { grid-area: nav; }
  .wdp-card[data-loc="Engine"]     { grid-area: engine; }
  .wdp-card[data-loc="Crew"]       { grid-area: crew; }
  .wdp-card[data-loc="Ship"]       { grid-area: ship; }

  /* Card shell */
  .wdp-card{
    border:1px solid #223;
    border-radius:12px;
    padding:10px;
    background:#101521;
  }

  /* Titles */
  .wdp-title{
    display:flex;align-items:center;gap:8px;
    font-weight:800;
    font-size:clamp(13px,1.2vw,15px);
    text-transform:uppercase;letter-spacing:.08em;
    color:#9fb7ff;margin:0 0 8px;
  }

  /* Base grid for chips (Crew & Ship default) */
  .wdp-grid{
    display:grid;
    grid-template-columns:repeat(4,minmax(140px,1fr));
    gap:6px;
  }

  /* Navigation & Engine = 5 columns */
  .wdp-card[data-loc="Navigation"] .wdp-grid,
  .wdp-card[data-loc="Engine"]     .wdp-grid{
    grid-template-columns: repeat(5, minmax(0, 1fr));
  }

  /* Ultra-wide screens: use the space (Nav/Engine=6, Crew/Ship=5) */
  @media (min-width: 1800px){
    .wdp-card[data-loc="Navigation"] .wdp-grid,
    .wdp-card[data-loc="Engine"]     .wdp-grid{
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }
    .wdp-card[data-loc="Crew"] .wdp-grid,
    .wdp-card[data-loc="Ship"] .wdp-grid{
      grid-template-columns: repeat(5, minmax(0, 1fr));
    }
  }

  /* Responsive: 2 columns, then 1 column */
  @media (max-width:1200px){
    .wdp-sections{
      grid-template-columns: 1fr 1fr;
      grid-template-areas:
        "nav engine"
        "crew ship";
    }
  }
  @media (max-width:720px){
    .wdp-sections{
      grid-template-columns: 1fr;
      grid-template-areas:
        "nav"
        "engine"
        "crew"
        "ship";
    }
  }
  @media (max-width:1000px){
    .wdp-grid{grid-template-columns:repeat(2,minmax(140px,1fr))}
  }
  @media (max-width:520px){
    .wdp-grid{grid-template-columns:1fr}
  }

  /* Chip styles */
  .wdp-chip{
    display:flex;align-items:center;gap:8px;
    border:1px solid #2a3340;border-radius:9999px;
    padding:7px 10px;min-height:36px;background:#0f1420;
  }
  .wdp-dot{width:11px;height:11px;border-radius:50%;box-shadow:0 0 0 1px #334255 inset}
  .wdp-dot.ok{background:#16a34a}
  .wdp-dot.warn{background:#eab308}
  .wdp-dot.bad{background:#ef4444}
  @keyframes pulseWarn{0%,100%{transform:scale(1);opacity:.95}50%{transform:scale(1.25);opacity:.7}}
  @keyframes blinkBad{0%,49%{opacity:1}50%,100%{opacity:.25}}
  .wdp-dot.warn{animation:pulseWarn 1.2s ease-in-out infinite}
  .wdp-dot.bad{animation:blinkBad .8s steps(2,end) infinite}
  .wdp-abbr{font-weight:800;font-size:14.3px}
  .wdp-type{font-size:12px;color:#8ea0bd}
  .wdp-val{margin-left:auto;font-variant-numeric:tabular-nums;white-space:nowrap;font-size:13px;color:#e6edf3}
  @keyframes tick{0%{transform:translateY(0);opacity:1}40%{transform:translateY(-2px);opacity:.85}100%{transform:translateY(0);opacity:1}}
  .wdp-val.tick{animation:tick .35s ease}
  .wdp-empty{
    border:1px dashed #2a3340;border-radius:12px;padding:16px;
    text-align:center;color:#9fb7ff;font-size:13px;background:#0f1420;
  }
</style>

<div class="wdp-wrap" id="wdp-panel" aria-label="Warp Drive Demonstrator · CST-Synced Equilibrium">
  <div class="wdp-sections" id="wdp-sections"></div>
</div>

<script type="module" id="wdp-chips" data-wdp-csv="https://gabinoc67.github.io/interstellar-star-clock/warpdrive/navengreadings.csv">
const ORDER=["Navigation","Engine","Crew","Ship"];

const normalizeType=s=>String(s||"").trim().toLowerCase();
const truthy=v=>["yes","true","1","y"].includes(String(v||"").trim().toLowerCase());
const TZ="America/Chicago";
const fmtTime=new Intl.DateTimeFormat("en-US",{timeZone:TZ,hour12:false,hour:"2-digit",minute:"2-digit",second:"2-digit"});
const fmtDate=new Intl.DateTimeFormat("en-US",{timeZone:TZ});

function parseCSV(text){
  const rows=[];let cur=[],val="",q=false;
  for(let i=0;i<text.length;i++){
    const c=text[i],n=text[i+1];
    if(q){ if(c=='"'&&n=='"'){val+='"';i++;} else if(c=='"'){q=false;} else{val+=c;} }
    else { if(c=='"'){q=true;} else if(c==','){cur.push(val);val="";} else if(c=='\n'){cur.push(val);rows.push(cur);cur=[];val="";} else if(c!='\r'){val+=c;} }
  }
  if(val.length||cur.length){cur.push(val);rows.push(cur);}
  const headers=rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>String(x).trim()!=="")).map(r=>{const o={};headers.forEach((h,i)=>o[h]=r[i]??"");return o;});
}
function normalizeRows(rows){
  return rows.map(r=>{
    const o={}; for(const k in r){ o[k.trim()] = typeof r[k]==="string" ? r[k].trim() : r[k]; }
    if(o["Display Type"]) o["Display Type"] = normalizeType(o["Display Type"]);
    if(o["Display Type"]==="date ") o["Display Type"]="date";
    return o;
  });
}
function normKey(s){return String(s||"").toLowerCase().replace(/[\s_\-]+/g,"").replace(/[^a-z0-9]/g,"");}
function detectKey(keys,re){const pairs=keys.map(k=>[k,normKey(k)]);const hit=pairs.find(([k,n])=>re.test(n));return hit?hit[0]:null;}
function buildKeyMap(sample){
  const keys=Object.keys(sample||{});
  return{ label:detectKey(keys,/label(name)?$/)||"Label Name",
          abbr:detectKey(keys,/(abbr|abbrev|abbreviation)s?$/)||"Abbreviation",
          dtype:detectKey(keys,/(displaytype|display|type)$/)||"Display Type",
          circle:detectKey(keys,/(circle)$/)||"Circle",
          location:detectKey(keys,/(location|loc)$/)||"Location" };
}
function groupByLocation(rows,KM){
  const g={};
  rows.forEach(r=>{
    const loc=String(r[KM.location]||"").trim()||"Crew";
    (g[loc] ||= []).push(r);
  });
  Object.keys(g).forEach(k=>{
    g[k].sort((a,b)=>String(a[KM.abbr]||"").localeCompare(String(b[KM.abbr]||"")));
  });
  return g;
}
const seedOf=s=>Array.from(String(s||"")).reduce((a,c)=>a+c.charCodeAt(0),0);

function liveValue(typ,labelOrAbbr,t){
  const seed=seedOf(labelOrAbbr);
  const base=(seed%1000)/10;
  const wiggle=(Math.sin((seed+t)/7)+1)*0.5;
  const v=base*(0.9+0.2*wiggle);
  switch(typ){
    case"degrees":  return `${Math.floor((v*3.6+t)%360)}°`;
    case"time":     return fmtTime.format(new Date());
    case"numbers":  return Intl.NumberFormat().format(Math.round(v*100+(t%5)));
    case"watts":    { const degLike=Math.floor((v*3.6+t)%360); return `${Math.round(50+degLike*0.8)} W`; }
    case"miles":    return `${(v*1.3).toFixed(1)} mi`;
    case"frequency":return `${(v*7).toFixed(2)} Hz`;
    case"pressure": return `${(v*2.3).toFixed(2)} psi`;
    case"speed":    return `${(v*3.1).toFixed(2)} kn`;
    case"date":     return fmtDate.format(new Date());
    case"alarm":    return ((seed+t)%17<1) ? "ALARM" : "OK";
    case"calculation": return (v*42).toFixed(2);
    default: return "—";
  }
}

function circleClassForRow(row,engine){
  const { v=0, p=0, f=0, r=0, hazard='none' } = engine || {};
  const imbalance = Math.abs(f - Math.abs(r));
  const vStress = Math.min(1, v/6);
  const pStress = Math.min(1, p/8);
  const vecStress= Math.min(1, imbalance/2);
  const hazStress= (hazard==='inside')?1 : (hazard==='approach')?0.8 : (hazard==='standby')?0.3 : 0;
  let stress = (0.35*vStress + 0.25*pStress + 0.25*vecStress + 0.15*hazStress);
  const seed = seedOf(row.__abbr || row.__label || '');
  const jitter = ((seed%101)/100 - 0.5) * 0.20;
  stress = Math.max(0, Math.min(1, stress + jitter));
  if(stress < 0.35) return 'ok';
  if(stress < 0.60) return 'warn';
  return 'bad';
}

const host = document.getElementById("wdp-sections");
const csvSrc = document.getElementById("wdp-chips")?.dataset.wdpCsv || new URL("navengreadings.csv", location.href).href;

function render(groups,KM){
  host.innerHTML = "";
  const order = ORDER.filter(k=>groups[k]?.length);
  if(!order.length){
    const div=document.createElement("div"); div.className="wdp-empty"; div.textContent="No items found in CSV."; host.appendChild(div); return;
  }
  for(const loc of order){
    const card=document.createElement("section"); card.className="wdp-card"; card.dataset.loc=loc;
    const h=document.createElement("div"); h.className="wdp-title"; h.textContent=loc; card.appendChild(h);
    const grid=document.createElement("div"); grid.className="wdp-grid";

    groups[loc].forEach(row=>{
      const typ = normalizeType(row[KM.dtype]);
      const showCircle = truthy(row[KM.circle]);
      const abbr = String(row[KM.abbr] || row[KM.label] || "").trim();
      row.__abbr = abbr; row.__label = row[KM.label];

      const chip=document.createElement("div"); chip.className="wdp-chip";
      if(showCircle){ const dot=document.createElement("span"); dot.className="wdp-dot ok"; chip.appendChild(dot); chip._dot=dot; }
      const ab=document.createElement("span"); ab.className="wdp-abbr"; ab.textContent=abbr; chip.appendChild(ab);
      const ty=document.createElement("span"); ty.className="wdp-type"; ty.textContent=typ; chip.appendChild(ty);
      const val=document.createElement("span"); val.className="wdp-val"; chip.appendChild(val);

      chip._wdp={ row, valEl:val, abbr, typ, showCircle, prevText:"" };
      grid.appendChild(chip);
    });

    card.appendChild(grid); host.appendChild(card);
  }
}

(async function(){
  try{
    const res = await fetch(csvSrc, { cache:"no-store" });
    if(!res.ok) throw new Error(`CSV fetch failed: ${res.status}`);
    const rows0 = parseCSV(await res.text());
    const rows  = normalizeRows(rows0);
    const KM    = buildKeyMap(rows[0]||{});
    const groups= groupByLocation(rows, KM);
    render(groups, KM);

    const liveSet = new Set(["numbers","degrees","time","watts"]);
    let redSince=null, lastT=-1;

    function anim(){
      const t = Math.floor(performance.now()/1000);
      if(t !== lastT){
        lastT = t;
        const engine = window.__engine_live_state || {v:0,p:0,f:0,r:0,hazard:'none'};
        let redCount = 0;

        host.querySelectorAll(".wdp-chip").forEach(ch=>{
          const ref = ch._wdp; if(!ref) return;

          const vtxt = liveValue(ref.typ, ref.abbr, t);
          if(liveSet.has(ref.typ)){
            if(vtxt !== ref.prevText){
              ref.valEl.textContent = vtxt;
              ref.prevText = vtxt;
              ref.valEl.classList.remove('tick'); void ref.valEl.offsetWidth; ref.valEl.classList.add('tick');
            }
          } else if(!ref.valEl.textContent){
            ref.valEl.textContent = vtxt; ref.prevText = vtxt;
          }

          if(ref.showCircle && ch._dot){
            const cls = circleClassForRow(ref.row, engine);
            ch._dot.classList.remove('ok','warn','bad');
            ch._dot.classList.add(cls);
            if(cls==='bad') redCount++;
          }
        });

        const threshold = 20;
        if(redCount > threshold){
          if(redSince==null) redSince = performance.now();
          else if(performance.now() - redSince > 2000 && typeof window.requestEngineShutdown==='function'){
            window.requestEngineShutdown(`> ${threshold} critical sensor circles`);
            redSince = null;
          }
        } else redSince = null;
      }
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  }catch(e){
    console.error(e);
    const div=document.createElement("div"); div.className="wdp-empty"; div.textContent="Could not load CSV."; host.appendChild(div);
  }
})();
</script>

