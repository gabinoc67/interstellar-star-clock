<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Drive Demo — CST Synced</title>
<style>
  :root {
    --bg:#0d1117; --panel:#161b22; --accent:#59d; --accent2:#9cf; --text:#e6edf3; --muted:#94a3b8;
    --ok:#16a34a; --warn:#eab308; --bad:#ef4444; --shadow: 0 10px 25px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1000px 800px at 20% -10%, #0a0f1a 0%, #0d1117 60%);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{display:flex;gap:16px;align-items:center;justify-content:space-between;padding:16px 24px;border-bottom:1px solid #222}
  header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.5px}
  .container{display:grid;grid-template-columns: 340px 1fr 380px;gap:16px;padding:16px}
  .panel{background:var(--panel);border:1px solid #222;border-radius:16px;box-shadow:var(--shadow);padding:16px}
  .panel h2{margin:0 0 10px 0;font-size:15px;font-weight:700;color:var(--accent2);text-transform:uppercase;letter-spacing:.08em}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:13px}
  select,input[type="text"]{width:100%;padding:10px;border-radius:10px;border:1px solid #2a3340;background:#0f1420;color:var(--text)}
  .row{display:flex;gap:12px}
  .row > *{flex:1}
  button{cursor:pointer;border:1px solid #2a3340;background:linear-gradient(180deg,#1b2333,#141b28);color:var(--text);padding:12px 14px;border-radius:12px;font-weight:700;box-shadow:var(--shadow)}
  button.primary{border-color:#2b4ea3;background:linear-gradient(180deg,#2b4ea3,#1b2f66)}
  button.ghost{background:transparent}
  .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:8px}
  .metric{background:#0f1420;border:1px solid #232a36;border-radius:12px;padding:10px;text-align:center}
  .metric .label{font-size:12px;color:var(--muted)}
  .metric .value{font-size:18px;font-weight:800;margin-top:4px}
  #log{height:260px;overflow:auto;background:#0a0f1a;border:1px dashed #2a3340;border-radius:10px;padding:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}
  .grid-rows{display:grid;gap:16px}
  .map{position:relative;height:380px;border-radius:12px;border:1px solid #232a36;background:
       radial-gradient(600px 300px at 20% 10%, rgba(88,122,255,.18), transparent 60%),
       linear-gradient(180deg,#0b0f19,#0a0e16)}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #2a3340;background:#0f1420;color:var(--muted)}
  .badge.ok{color:#b7f7c1;border-color:#14532d;background:linear-gradient(180deg,#0c1b11,#0b1510)}
  .badge.warn{color:#fff0b4;border-color:#7a5c05;background:linear-gradient(180deg,#1b1709,#141004)}
  .badge.bad{color:#ffc4c4;border-color:#7a1f1f;background:linear-gradient(180deg,#1b0c0c,#140808)}
  .flex{display:flex;gap:10px;align-items:center}
  .right{justify-content:flex-end}
  footer{padding:12px 16px;color:var(--muted);font-size:12px;border-top:1px solid #222}
  .saved-tag{display:inline-block;background:#0f1420;border:1px solid #2a3340;border-radius:8px;padding:4px 8px;margin:4px;font-size:12px}
  #savedBox{height:260px; overflow-y:auto; background:#0a0f1a; border:1px dashed #2a3340; border-radius:10px; padding:10px; scrollbar-color:#2a3340 #0a0f1a; scrollbar-width:thin;}
  #savedBox::-webkit-scrollbar { width: 10px; } #savedBox::-webkit-scrollbar-track { background:#0a0f1a; } #savedBox::-webkit-scrollbar-thumb { background:#2a3340; border-radius:8px; } #savedBox::-webkit-scrollbar-thumb:hover { background:#3a4558; }

  /* Map overlays */
  #starCanvas{position:absolute; inset:0; width:100%; height:100%; display:block; border-radius:12px}
  .headingOverlay{position:absolute; top:8px; left:50%; transform:translateX(-50%); font-weight:900; font-size:26px; letter-spacing:1px; color:#e6f0ff; text-shadow:0 2px 8px rgba(0,0,0,.55); background:rgba(10,14,22,.35); border:1px solid #223; padding:6px 12px; border-radius:12px;}
  .hazardOverlay{position:absolute; top:8px; left:calc(50% + 190px); transform:translateX(-50%); font-weight:800; font-size:14px; letter-spacing:.5px; color:#b7f7c1; background:rgba(10,14,22,.45); border:1px solid #223; padding:6px 10px; border-radius:10px;}
  .hazardOverlay.bad{color:#ffcbcb; border-color:rgba(239,68,68,.5); box-shadow:0 0 22px rgba(239,68,68,.25);}
  @keyframes blinkRed { 0%,49% { opacity:1 } 50%,100% { opacity:.25 } }
  .blink{ animation: blinkRed 0.8s steps(2,end) infinite; }

  .bigHeading {width:100%; text-align:center; font-size:56px; font-weight:900; letter-spacing:1px; color:#e8f0ff; text-shadow:0 6px 20px rgba(0,0,0,.6); margin:-2px 0 6px 0;}

  .ops {display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  .lights {display:flex;gap:12px;flex-wrap:wrap}
  .light {display:flex;align-items:center;gap:8px;background:#0f1420;border:1px solid #232a36;border-radius:999px;padding:6px 10px}
  .dot {width:12px;height:12px;border-radius:50%}
  .dot.ok {background:var(--ok)} .dot.warn {background:var(--warn)} .dot.bad {background:var(--bad)}
  .name {font-size:12px;color:#cdd6e3}
  .route {font-size:12px;color:#94a3b8;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .route strong {color:#e6edf3}
  .kv {display:inline-flex;gap:6px;align-items:center}
  .kv label{font-size:12px;color:#94a3b8}
  .kv .val{font-size:12px;color:#e6edf3}
  .mode {display:flex;align-items:center;gap:8px;margin-top:8px}
  .mode .scale {width:100%}
  @media (max-width: 1100px){ .container{grid-template-columns:1fr} .map{height:320px}
    .hazardOverlay{left:50%; top:46px} /* stacks under heading on narrow screens */
  }
</style>
</head>
<body>
  <header>
    <h1>Warp Drive Demonstrator · CST-Synced Equilibrium</h1>
    <div class="flex right">
      <span id="cstBadge" class="badge ok">CST Sync: <strong id="cstClock">--:--:--</strong></span>
      <span id="rhythmBadge" class="badge ok">Bio Rhythm: Stable</span>
    </div>
  </header>
  <main class="container">
    <!-- Left: Controls -->
    <section class="panel">
      <h2>Controls</h2>
      <label for="warp">Warp Factor (1–10)</label>
      <select id="warp">
        <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option><option value="4">Warp 4</option>
        <option value="5" selected>Warp 5</option><option value="6">Warp 6</option><option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option><option value="10">Warp 10</option>
      </select>

      <div class="row">
        <div>
          <label for="class">Destination Class</label>
          <select id="class">
            <option value="planet" selected>Planet</option><option value="moon">Moon</option><option value="galaxy">Galaxy</option><option value="star">Star</option><option value="custom">Custom</option>
          </select>
        </div>
        <div>
          <label for="targetSel">Target Name</label>
          <select id="targetSel"></select>
          <input id="targetCustom" type="text" placeholder="Type custom target" style="display:none;margin-top:8px;" />
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="engage" class="primary">Engage</button>
        <button id="save">Save Mission</button>
      </div>

      <div class="metrics">
        <div class="metric"><div class="label">Front (+E)</div><div id="frontE" class="value">0.00</div></div>
        <div class="metric"><div class="label">Mid (~0)</div><div id="midE" class="value">0.00</div></div>
        <div class="metric"><div class="label">Rear (−E)</div><div id="rearE" class="value">0.00</div></div>
      </div>

      <div style="margin-top:12px" class="flex">
        <button id="reset" class="ghost">Reset</button>
        <span id="persistBadge" class="badge">Not saved</span>
      </div>

      <div style="margin-top:8px" class="flex">
        <button id="resetMetrics" class="ghost">Reset Metrics Only</button>
        <button id="testAlarm" class="ghost" title="Play alarm.mp3 for 3s">Test Alarm</button>
      </div>

      <div class="mode">
        <label for="timeScale">Time Scale:</label>
        <select id="timeScale" class="scale">
          <option value="1" selected>1× (real seconds)</option>
          <option value="10">10×</option>
          <option value="100">100×</option>
          <option value="1000">1,000×</option>
          <option value="1000000">1,000,000×</option>
        </select>
      </div>
    </section>

    <!-- Center: Visualization / Map -->
    <section class="panel grid-rows">
      <div id="bigHeading" class="bigHeading">000°</div>
      <h2>Navigation Map (Concept)</h2>
      <div id="map" class="map">
        <div id="headingOverlay" class="headingOverlay">HEADING: 000°</div>
        <!-- NEW: hazard ticker next to degrees -->
        <div id="hazardOverlay" class="hazardOverlay">SAFE</div>
        <canvas id="starCanvas"></canvas>
      </div>

      <div class="ops">
        <div class="lights">
          <div class="light" id="lightBubble"><span class="dot ok"></span><span class="name">Bubble</span></div>
          <div class="light" id="lightPower"><span class="dot ok"></span><span class="name">Power</span></div>
          <div class="light" id="lightVector"><span class="dot ok"></span><span class="name">Vector</span></div>
          <div class="light" id="lightNav"><span class="dot warn"></span><span class="name">Nav</span></div>
        </div>
        <div class="route">
          <span class="kv"><label>Departure:</label><strong id="depTxt">(unspecified)</strong></span>
          <span>· Earth</span>
          <span class="kv"><label>Arrival:</label><strong id="arrTxt">(unspecified)</strong></span>
          <span class="kv"><label>Travel Clock:</label><span class="val" id="travelClock">00:00:00.000</span></span>
          <span class="kv"><label>Speed of Light:</label><span class="val" id="solTxt">0.00 c</span></span>
          <span class="kv"><label>Parsec:</label><span class="val" id="pcTxt">0.000 pc/yr</span></span>
        </div>
      </div>

      <div class="row">
        <div class="metric"><div class="label">Bubble Velocity (eff.)</div><div id="vEff" class="value">0.00 c</div></div>
        <div class="metric"><div class="label">Pulse Rate</div><div id="pulse" class="value">0.0 MHz</div></div>
        <div class="metric"><div class="label">Loop η</div><div id="eta" class="value">0.000</div></div>
      </div>
    </section>

    <!-- Right: Status & Saved -->
    <aside class="panel grid-rows">
      <h2>Status & Log</h2>
      <div id="log"></div>
      <h2>Saved Missions</h2>
      <div id="savedBox"><div id="saved"></div></div>
    </aside>
  </main>

  <footer>
    Demo only. Timebase is locked to America/Chicago (CST/CDT). Selections persist via localStorage for GitHub Pages deployments.
  </footer>

  <!-- Sounds -->
  <audio id="arriveAudio" src="./warp/arrive.mp3" preload="auto"></audio>
  <audio id="warpAudio"   src="./warp/warp.mp3" preload="auto"></audio>
  <audio id="alarmAudio"  src="https://raw.githubusercontent.com/gabinoc67/interstellar-star-clock/main/warpdrive/alarm.mp3" preload="auto" crossOrigin="anonymous" loop></audio>
<script>
/* ===================== CLOCK (CST) ===================== */
const tz = 'America/Chicago';
const cstClockEl = document.getElementById('cstClock');
function fmtCSTClock(d){
  return new Intl.DateTimeFormat('en-US', { timeZone: tz, hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'}).format(d);
}
setInterval(()=>{
  const d = new Date();
  cstClockEl.textContent = fmtCSTClock(d) + (
    new Intl.DateTimeFormat('en-US',{timeZoneName:'short', timeZone:tz})
      .formatToParts(d).find(p=>p.type==='timeZoneName')?.value.replace('GMT','')||''
  );
}, 250);

/* ===================== HELPERS & STATE ===================== */
const $ = sel => document.querySelector(sel);
function pad(n, w){ return String(n).padStart(w,'0'); }
function monthName(d){ return new Intl.DateTimeFormat('en-US', { timeZone: tz, month:'long' }).format(d); }
function cstTimestampWithPico(d){
  const parts = new Intl.DateTimeFormat('en-US', { timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' }).formatToParts(d);
  const y = parts.find(p=>p.type==='year').value;
  const m = parseInt(parts.find(p=>p.type==='month').value,10);
  const day = parseInt(parts.find(p=>p.type==='day').value,10);
  const hh = parts.find(p=>p.type==='hour').value;
  const mm = parts.find(p=>p.type==='minute').value;
  const pico = pad(Math.floor((performance.now()%1)*1e12), 12);
  return `${monthName(d)} ${day}, ${y}, ${hh}:${mm}, ${pico}`;
}
function setStatus(text){ $("#log").textContent = text; }

/* ===================== ELEMENTS ===================== */
const warpSel = $("#warp"), classSel = $("#class");
const targetSel = $("#targetSel"), targetCustom = $("#targetCustom");
const timeScaleSel = $("#timeScale");
const engageBtn = $("#engage"), saveBtn = $("#save");
const resetBtn = $("#reset"), resetMetricsBtn = $("#resetMetrics"), testAlarmBtn = $("#testAlarm");

const frontE = $("#frontE"), midE = $("#midE"), rearE = $("#rearE");
const vEff = $("#vEff"), pulse = $("#pulse"), eta = $("#eta");
const savedEl = $("#saved"), persistBadge = $("#persistBadge"), rhythmBadge = $("#rhythmBadge");

const depTxt = $("#depTxt"), arrTxt = $("#arrTxt"), solTxt = $("#solTxt"), pcTxt  = $("#pcTxt"), travelClockEl = $("#travelClock");
const headingOverlay = $("#headingOverlay"), bigHeading = $("#bigHeading"), hazardOverlay = $("#hazardOverlay");

const lightBubble = document.querySelector('#lightBubble .dot');
const lightPower  = document.querySelector('#lightPower .dot');
const lightVector = document.querySelector('#lightVector .dot');
const lightNav    = document.querySelector('#lightNav .dot');

const arriveAudio = $("#arriveAudio"), warpAudio = $("#warpAudio"), alarmAudio = $("#alarmAudio");

/* ===================== AUDIO UNLOCK ===================== */
let audioUnlocked = false;
function unlockAudioOnce(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  [alarmAudio, warpAudio, arriveAudio].forEach(a=>{
    a.volume = 0.01;
    a.play().then(()=>{ a.pause(); a.currentTime = 0; a.volume = 1; }).catch(()=>{});
  });
}
document.addEventListener('click', unlockAudioOnce, { once:true });
document.addEventListener('pointerdown', unlockAudioOnce, { once:true }); // iOS/Safari

/* ===================== DATA SOURCES ===================== */
const HAZARDS_URL   = 'https://gabinoc67.github.io/interstellar-star-clock/warpdrive/warp_targets_and_hazards.json';
const DISTANCES_URL = './warp/distances.json';  // your existing file
const TARGETS_URL   = './warp/targets.json';    // your existing file

const fallbackPlanets = ["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune"];
const fallbackMoons   = ["Moon","Europa","Ganymede","Callisto","Titan"];
const fallbackGalaxies = [
  "Andromeda (M31)","Triangulum (M33)","Large Magellanic Cloud","Small Magellanic Cloud"
];
const fallbackStars   = [
  "Sirius A","Proxima Centauri","Alpha Centauri A","Barnard's Star","Tau Ceti","Epsilon Eridani"
];

let distancesData = { targets:{} };
let catalog = { planets:[], moons:[], stars:[], galaxies:[] };
let raDecByName = {}; // name → {ra,dec}
let hazardsPack = null;

function makeTargetsData(){
  const p = (catalog.planets||[]).map(o=>o.name).filter(Boolean);
  const m = (catalog.moons||[]).map(o=>o.name).filter(Boolean);
  const s = (catalog.stars||[]).map(o=>o.name).filter(Boolean);
  const g = (catalog.galaxies||[]).map(o=>o.name).filter(Boolean);
  return {
    planet: p.length ? p : fallbackPlanets.slice(),
    moon:   m.length ? m : fallbackMoons.slice(),
    star:   s.length ? s : fallbackStars.slice(),
    galaxy: g.length ? g : fallbackGalaxies.slice(),
    custom: []
  };
}
let targetsData = makeTargetsData();

/* Load catalogs + hazards */
Promise.allSettled([
  fetch(TARGETS_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject()),
  fetch(DISTANCES_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject()),
  fetch(HAZARDS_URL, {cache:'no-store'}).then(r=>r.ok?r.json():Promise.reject())
]).then(results=>{
  const [catRes, distRes, hazRes] = results;
  if(catRes.status==='fulfilled' && catRes.value){
    const cat = catRes.value;
    catalog = {
      planets: Array.isArray(cat.planets)?cat.planets:[],
      moons: Array.isArray(cat.moons)?cat.moons:[],
      stars: Array.isArray(cat.stars)?cat.stars:[],
      galaxies: Array.isArray(cat.galaxies)?cat.galaxies:[]
    };
    raDecByName = {};
    (catalog.stars||[]).forEach(o=>{ if(o?.name) raDecByName[o.name] = { ra:o.ra_deg, dec:o.dec_deg }; });
    (catalog.galaxies||[]).forEach(o=>{ if(o?.name) raDecByName[o.name] = { ra:o.ra_deg, dec:o.dec_deg }; });
  }
  if(distRes.status==='fulfilled' && distRes.value) distancesData = distRes.value;
  if(hazRes.status==='fulfilled' && hazRes.value) hazardsPack = hazRes.value;

  targetsData = makeTargetsData();
  const restored = loadUI();
  if(!restored){ populateTargetOptgroups(""); }
  updateMetricsStatic();
  updatePreEngageStatus();
  updateStarfieldHeading();
  renderSaves();
  restoreFlightIfAny();
  setStatus('System initialized. CST sync engaged.');

  // start starfield regardless so stars never "disappear"
  if(window.starfield) window.starfield.start();

  // kick off hazard monitor loop
  hazardLoop();
}).catch(()=>{
  targetsData = makeTargetsData(); // fallbacks
  const restored = loadUI();
  if(!restored){ populateTargetOptgroups(""); }
  setStatus('Loaded with fallbacks. (Targets/Hazards JSON not found)');
});

/* ===================== TARGET UI ===================== */
function populateTargetOptgroups(selectedValue = ""){
  const groups = ["planet","moon","galaxy","star"];
  let html = `<option value="">(select target)</option>`;
  for(const g of groups){
    const items = (targetsData[g]||[]);
    if(!items.length) continue;
    const label = g.charAt(0).toUpperCase()+g.slice(1)+"s";
    html += `<optgroup label="${label}" data-group="${g}">` +
      items.map(n=>`<option value="${n}" ${n===selectedValue?'selected':''}>${n}</option>`).join('') +
    `</optgroup>`;
  }
  targetSel.innerHTML = html;

  if(classSel.value==='custom'){
    targetSel.value = "";
    targetSel.style.display='none';
    targetCustom.style.display='block';
    targetCustom.value = "";
  }else{
    targetCustom.style.display='none';
    targetSel.style.display='block';
  }
  updatePreEngageStatus();
  updateStarfieldHeading();
}

classSel.addEventListener('change', ()=>{
  clearEngaged();
  if(classSel.value === 'custom'){
    targetSel.value = "";
    targetSel.style.display='none';
    targetCustom.style.display='block';
    targetCustom.value = "";
  } else {
    const list = (targetsData[classSel.value]||[]);
    const first = list.length ? list[0] : "";
    populateTargetOptgroups(first);
    targetSel.style.display='block';
    targetCustom.style.display='none';
    targetSel.value = first;
  }
  updatePreEngageStatus();
  updateStarfieldHeading();
  saveUI();
});
targetSel.addEventListener('change', ()=>{ clearEngaged(); updatePreEngageStatus(); updateStarfieldHeading(); saveUI(); });
targetCustom.addEventListener('input', ()=>{ clearEngaged(); updatePreEngageStatus(); updateStarfieldHeading(); saveUI(); });
function getSelectedTarget(){ return (classSel.value==='custom') ? targetCustom.value.trim() : (targetSel.value||'').trim(); }

/* ===================== PHYSICS & METRICS ===================== */
const C_KM_S = 299792.458;
const SECONDS_PER_YEAR = 31557600;
function computeVEffFromWarp(w){ return Math.min(0.2*w + 0.1*w*w/10, 10); }
function baseMetricsFromWarp(w){
  const v = computeVEffFromWarp(w);
  return { vEff: v, pulse: w*0.5, eta: 0.995 + w*0.0004, front: w*0.11, mid: 0, rear: -w*0.11 };
}
function vEffNumber(){ return parseFloat((vEff.textContent||'0').replace(' c',''))||0; }
function lookupDistance(targetName){
  if(!targetName) return null;
  const t = distancesData?.targets?.[targetName];
  if(!t) return null;
  return { distance: Number(t.distance), unit: t.unit };
}
function computeRealEtaSeconds(targetName){
  const d = lookupDistance(targetName);
  const v = Math.max(0.01, vEffNumber());
  if(!d){
    const fallbackUnits = { moon:6, planet:12, star:60, galaxy:200, custom:20 };
    const distUnits = fallbackUnits[classSel.value] ?? 20;
    return distUnits / v;
  }
  if(d.unit === 'ly'){ return (d.distance / v) * SECONDS_PER_YEAR; }
  if(d.unit === 'km'){ return d.distance / (v * C_KM_S); }
  return 10;
}
function maxEtaSecondsAtCurrentWarp(){
  const v = Math.max(0.01, vEffNumber());
  let maxSec = 0;
  const tgs = distancesData?.targets || {};
  for(const k in tgs){
    const rec = tgs[k]; if(!rec) continue;
    let sec = 0;
    if(rec.unit === 'ly') sec = (Number(rec.distance) / v) * SECONDS_PER_YEAR;
    else if(rec.unit === 'km') sec = Number(rec.distance) / (v * C_KM_S);
    if(sec > maxSec) maxSec = sec;
  }
  return Math.max(maxSec, 60);
}

/* ===================== LIGHTS & STATUS ===================== */
function anyBad(){ return [lightBubble, lightPower, lightVector, lightNav].some(el => el.classList.contains('bad')); }
function updateAlarm(){ if(anyBad() && audioUnlocked){ alarmAudio.play().catch(()=>{}); } else { alarmAudio.pause(); alarmAudio.currentTime = 0; } }
function setDot(el, state){ el.classList.remove('ok','warn','bad'); el.classList.add(state); updateAlarm(); }
function setAllGreen(){ setDot(lightBubble,'ok'); setDot(lightPower,'ok'); setDot(lightVector,'ok'); setDot(lightNav,'ok'); }
function updatePreEngageStatus(){
  setDot(lightBubble,'ok'); setDot(lightPower,'ok'); setDot(lightVector,'ok');
  const t = getSelectedTarget();
  setDot(lightNav, t ? 'ok' : 'warn');
  arrTxt.textContent = t || '(unspecified)';
  travelClockEl.textContent = "00:00:00.000";
  rhythmBadge.className = 'badge ok';
  rhythmBadge.textContent = 'Bio Rhythm: CST-Locked';
}

/* ===================== STARFIELD (stable draw, live heading) ===================== */
(function initStarfield(){
  const map = document.getElementById('map');
  const cvs = document.getElementById('starCanvas');
  const ctx = cvs.getContext('2d', {alpha:false});

  function dims(){
    return { W: map.clientWidth || 800, H: map.clientHeight || 400, dpr: Math.max(1, Math.floor(window.devicePixelRatio||1)) };
  }
  function resize(){
    const {W,H,dpr} = dims();
    cvs.style.width  = W+'px';
    cvs.style.height = H+'px';
    cvs.width  = W * dpr;
    cvs.height = H * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Persistent stars
  const STAR_COUNT = 600;
  const stars = [];
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function makeStar(){
    const {W,H} = dims();
    return { x: rand(0, W), y: rand(0, H), z: rand(0.2, 1.0), r: rand(0.6, 1.6), tw: rand(0.5, 1.0) };
  }
  for(let i=0;i<STAR_COUNT;i++) stars.push(makeStar());

  // Heading (derived from target RA/Dec), with optional override for evasive action
  let targetHeadingDeg = 0;
  let overrideHeadingDeg = null;
  let overrideUntil = 0;

  function computeBearingFromRaDec(raDeg, decDeg){
    const ra = raDeg * Math.PI/180, dec = decDeg * Math.PI/180;
    let deg = Math.atan2(Math.cos(dec)*Math.sin(ra), Math.cos(dec)*Math.cos(ra)) * 180/Math.PI;
    if(deg<0) deg+=360;
    return deg;
  }

  function updateHeadingFromTarget(){
    const name = getSelectedTarget();
    const rec = raDecByName[name||''] || null;
    if(rec && rec.ra!=null && rec.dec!=null){
      targetHeadingDeg = computeBearingFromRaDec(rec.ra, rec.dec);
    } else {
      // stable hash if no RA/Dec
      const t = (name||'forward');
      let h=0; for(let i=0;i<t.length;i++){ h=(h*31 + t.charCodeAt(i))>>>0; }
      targetHeadingDeg = h % 360;
    }
  }
  updateHeadingFromTarget();
  window.starfield = {
    running:false, raf:null,
    start(){ if(this.running) return; this.running = true; cancelAnimationFrame(this.raf); this.raf = requestAnimationFrame(this.frame.bind(this)); },
    stop(){ this.running = false; cancelAnimationFrame(this.raf); },
    setHeading(){ updateHeadingFromTarget(); },
    setOverride(deg, ms){ overrideHeadingDeg = ((deg%360)+360)%360; overrideUntil = performance.now() + ms; },
    frame(){
      if(!this.running) return;
      const {W,H} = dims();
      ctx.fillStyle = '#060a12';
      ctx.fillRect(0,0,W,H);

      // resolve heading (target vs override)
      if(performance.now() > overrideUntil) overrideHeadingDeg = null;
      const headingDeg = (overrideHeadingDeg!=null) ? overrideHeadingDeg : targetHeadingDeg;

      const rad = (headingDeg * Math.PI/180);
      const hvx = Math.cos(rad), hvy = Math.sin(rad);

      const w = Number(warpSel.value||1);
      const curv = Math.max(0, Math.min(90, ((w-1)/9)*90));
      const sizeFactor = 1 + (curv/45);
      const thickness = 0.6 + (curv/90)*1.2;

      const cf = currentFlight();
      const etaThis = cf && cf.active ? (cf.etaSec||0) : computeRealEtaSeconds(getSelectedTarget());
      const etaMax  = maxEtaSecondsAtCurrentWarp();
      const longFrac = Math.max(0.0, Math.min(1.0, etaThis / etaMax));
      const baseTail = 8 + (w-1)*1.2;
      const tailLen  = baseTail * (0.25 + 1.75*longFrac);

      const t = performance.now()/1000;

      for(const s of stars){
        const alpha = 0.55 + 0.45 * Math.sin((t*600) * s.tw + (s.x+s.y)*0.002);
        const rBase = s.r*(0.6+0.8*s.z);
        const halfW = rBase * sizeFactor;
        const halfH = rBase * (0.7 + 0.3*s.z);

        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(Math.atan2(-hvy, -hvx));
        ctx.fillStyle = `rgba(210,225,255,${alpha})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, halfW, halfH, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = `rgba(210,225,255,${alpha*0.9})`;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x + tailLen * (-hvx), s.y + tailLen * (-hvy));
        ctx.stroke();
      }

      const dStr = String(Math.round(((headingDeg)%360+360)%360)).padStart(3,'0');
      headingOverlay.textContent = `HEADING: ${dStr}°`;
      bigHeading.textContent = `${dStr}°`;

      this.raf = requestAnimationFrame(this.frame.bind(this));
    }
  };
})();

function updateStarfieldHeading(){
  if(window.starfield) window.starfield.setHeading();
}

/* ===================== TRAVEL TICKER & FLIGHT ===================== */
let travelTicker = null, travelClockMs = 0, lastTick = 0;
function formatClock(ms){
  const h = Math.floor(ms/3600000);
  const m = Math.floor((ms%3600000)/60000);
  const s = Math.floor((ms%60000)/1000);
  const z = Math.floor(ms%1000);
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(z).padStart(3,'0')}`;
}
function startTravelTicker(){
  stopTravelTicker();
  lastTick = performance.now();
  travelTicker = setInterval(()=>{
    const now = performance.now();
    const realDt = now - lastTick; lastTick = now;

    const w = Number(warpSel.value);
    const base = baseMetricsFromWarp(w);

    const t = now/1000;
    const wobble = (amp)=> amp * Math.sin(t*2.1) * Math.cos(t*0.7);
    const vNow = Math.max(0, base.vEff + wobble(0.05*base.vEff + 0.03));
    const pNow = Math.max(0, base.pulse + wobble(0.06*base.pulse + 0.05));
    const eNow = Math.min(1.005, Math.max(0.990, base.eta + wobble(0.0015)));

    const fNow = base.front + wobble(0.03*base.front + 0.01);
    const mNow = 0 + wobble(0.01);
    const rNow = base.rear + wobble(0.03*(-base.rear) + 0.01);

    vEff.textContent = `${vNow.toFixed(2)} c`;
    pulse.textContent = `${pNow.toFixed(1)} MHz`;
    eta.textContent = eNow.toFixed(3);
    frontE.textContent = fNow.toFixed(2);
    midE.textContent = mNow.toFixed(2);
    rearE.textContent = rNow.toFixed(2);

    solTxt.textContent = `${vNow.toFixed(2)} c`;
    pcTxt.textContent  = `${(vNow/3.26156).toFixed(3)} pc/yr`;

    const rate = 1/(1+vNow);
    const scale = Number(timeScaleSel.value || 1);
    travelClockMs += realDt * rate * scale;
    travelClockEl.textContent = formatClock(travelClockMs);
  }, 100);
}
function stopTravelTicker(){ if(travelTicker){ clearInterval(travelTicker); travelTicker = null; } }

const FLIGHT_KEY = 'warp-demo:flight';
function saveFlightState(state){ localStorage.setItem(FLIGHT_KEY, JSON.stringify(state)); }
function loadFlightState(){ try { return JSON.parse(localStorage.getItem(FLIGHT_KEY))||null } catch(e){ return null } }
function clearFlightState(){ localStorage.removeItem(FLIGHT_KEY); }

function startFlightRecord(){
  const tgt = getSelectedTarget();
  const now = Date.now();
  const etaSec = computeRealEtaSeconds(tgt);
  const scale = Number(timeScaleSel.value||1);
  const wp = (cls=>{
    if(cls==='moon'||cls==='planet') return [{p:0.01,label:'LEO'},{p:0.05,label:'Injection'},{p:0.50,label:'Mid-course'},{p:0.90,label:'Approach'},{p:0.98,label:'Orbit'}];
    if(cls==='star') return [{p:0.02,label:'Heliopause'},{p:0.10,label:'Cruise'},{p:0.50,label:'Midway'},{p:0.90,label:'Approach'}];
    if(cls==='galaxy') return [{p:0.02,label:'Galactic Exit'},{p:0.10,label:'IG Cruise'},{p:0.50,label:'IG Midway'},{p:0.95,label:'Galaxy Approach'}];
    return [{p:0.25,label:'Quarter'},{p:0.50,label:'Halfway'},{p:0.75,label:'3/4'}];
  })(classSel.value);

  const record = { active:true, startMs: now, etaSec, timeScale: scale, warp: warpSel.value, class: classSel.value, target: tgt, waypoints: wp, wpIndex: -1 };
  saveFlightState(record);
  return record;
}
function restoreFlightIfAny(){
  const r = loadFlightState();
  if(!r || !r.active) return;
  warpSel.value = r.warp;
  classSel.value = r.class;
  if(r.class==='custom'){
    populateTargetOptgroups("");
    targetCustom.value = r.target;
    targetSel.style.display='none';
    targetCustom.style.display='block';
  }else{
    populateTargetOptgroups(r.target);
    targetSel.style.display='block';
    targetCustom.style.display='none';
  }
  updateMetricsStatic();
  updateStarfieldHeading();
  depTxt.textContent = cstTimestampWithPico(new Date(r.startMs));
  arrTxt.textContent = r.target;
  if(window.starfield) window.starfield.start();
  setAllGreen();
  travelClockMs = 0;
  startTravelTicker();
  setStatus(`Resuming → Warp ${r.warp} to ${r.class}:${r.target} · Scale ${r.timeScale}×`);
}

/* ===================== METRICS DISPLAY ===================== */
function updateMetricsStatic(){
  const w = Number(warpSel.value);
  const m = baseMetricsFromWarp(w);
  frontE.textContent = m.front.toFixed(2);
  midE.textContent   = m.mid.toFixed(2);
  rearE.textContent  = m.rear.toFixed(2);
  vEff.textContent   = `${m.vEff.toFixed(2)} c`;
  pulse.textContent  = `${m.pulse.toFixed(1)} MHz`;
  eta.textContent    = m.eta.toFixed(3);
  solTxt.textContent = `${m.vEff.toFixed(2)} c`;
  pcTxt.textContent  = `${(m.vEff/3.26156).toFixed(3)} pc/yr`;
}
function zeroMetrics(){
  frontE.textContent="0.00"; midE.textContent="0.00"; rearE.textContent="0.00";
  vEff.textContent="0.00 c"; pulse.textContent="0.0 MHz"; eta.textContent="0.000";
  solTxt.textContent="0.00 c"; pcTxt.textContent="0.000 pc/yr";
}

/* ===================== SAVED MISSIONS ===================== */
const KEY = 'warp-demo:saves';
function loadSaves(){ try { return JSON.parse(localStorage.getItem(KEY))||[] } catch(e){ return [] } }
function saveSaves(arr){ localStorage.setItem(KEY, JSON.stringify(arr)); }
function renderSaves(){
  const arr = loadSaves();
  savedEl.innerHTML = arr.length? '' : '<span class="muted">No saved missions yet.</span>';
  arr.forEach((m,i)=>{
    const tag = document.createElement('div');
    tag.className='saved-tag';
    tag.textContent = `#${i+1} · ${m.when} CST · Warp ${m.warp} → ${m.class}:${m.target}`;
    tag.title = 'Click to load';
    tag.onclick = ()=>{
      warpSel.value = m.warp;
      classSel.value = m.class;
      if(m.class==='custom'){
        populateTargetOptgroups("");
        targetCustom.value = m.target;
        targetSel.style.display='none';
        targetCustom.style.display='block';
      }else{
        populateTargetOptgroups(m.target);
        targetSel.style.display='block';
        targetCustom.style.display='none';
      }
      setStatus(`Loaded mission #${i+1}`);
      clearEngaged();
      updatePreEngageStatus();
      updateStarfieldHeading();
      saveUI();
    };
    savedEl.appendChild(tag);
  });
  persistBadge.textContent = arr.length? 'Saved ✓' : 'Not saved';
}

/* Save current UI */
saveBtn.onclick = ()=>{
  const arr = loadSaves();
  const m = {
    warp:   String(warpSel.value),
    class:  String(classSel.value),
    target: getSelectedTarget() || '(unspecified)',
    when:   new Intl.DateTimeFormat('en-US', { timeZone: tz, dateStyle:'medium', timeStyle:'short' }).format(new Date())
  };
  arr.unshift(m);
  saveSaves(arr.slice(0,25));
  renderSaves();
  setStatus('Mission saved.');
};

/* ===================== UI PERSIST ===================== */
const UI_KEY = 'warp-demo:ui';
function saveUI(){
  const cls = classSel.value;
  const tgt = (cls === 'custom') ? targetCustom.value.trim() : (targetSel.value||'').trim();
  const rec = { warp: warpSel.value, class: cls, target: tgt, timeScale: timeScaleSel.value };
  localStorage.setItem(UI_KEY, JSON.stringify(rec));
}
function loadUI(){
  try {
    const rec = JSON.parse(localStorage.getItem(UI_KEY));
    if(!rec) return false;
    warpSel.value = rec.warp || '1';
    classSel.value = rec.class || 'planet';
    if(classSel.value === 'custom'){
      populateTargetOptgroups("");
      targetCustom.value = rec.target || '';
      targetSel.style.display='none';
      targetCustom.style.display='block';
    } else {
      populateTargetOptgroups(rec.target || "");
      targetSel.style.display='block';
      targetCustom.style.display='none';
    }
    timeScaleSel.value = rec.timeScale || '1';
    updateMetricsStatic();
    updateStarfieldHeading();
    updatePreEngageStatus();
    return true;
  } catch(e){ return false; }
}
warpSel.addEventListener('change', ()=>{ clearEngaged(); updateMetricsStatic(); updateStarfieldHeading(); saveUI(); });
timeScaleSel.addEventListener('change', ()=>{ const r = loadFlightState(); if(r && r.active){ r.timeScale = Number(timeScaleSel.value||1); saveFlightState(r); setStatus(`Time Scale set to ${r.timeScale}×`); } saveUI(); });

/* ===================== FLIGHT ACTIONS ===================== */
let engagedState = null;
function clearEngaged(){ engagedState = null; }
function currentState(){ return { warp: warpSel.value, class: classSel.value, target: (getSelectedTarget()||'(unspecified)') }; }
engageBtn.onclick = ()=>{
  unlockAudioOnce();
  const tgt = getSelectedTarget();
  if(!tgt){
    setDot(lightNav,'bad');
    setTimeout(()=>updatePreEngageStatus(), 1200);
    setStatus('Select a target before Engage.');
    return;
  }
  const prev = loadFlightState();
  if(prev && prev.active){ prev.active = false; saveFlightState(prev); }

  updateMetricsStatic();
  updateStarfieldHeading();
  if(window.starfield) window.starfield.start();

  engagedState = { ...currentState(), when: new Date() };
  depTxt.textContent = cstTimestampWithPico(engagedState.when);
  arrTxt.textContent = tgt;

  const etaSec = computeRealEtaSeconds(tgt);
  if (warpAudio){ warpAudio.currentTime = 0; warpAudio.play().catch(()=>{}); }
  setAllGreen();

  const record = startFlightRecord();
  travelClockMs = 0;
  startTravelTicker();

  setStatus(`ENGAGE → Warp ${record.warp} to ${record.class}:${record.target} · Scale ${record.timeScale}× · ETA ~ ${Math.round(etaSec)} s`);
};

resetBtn.onclick = ()=>{
  unlockAudioOnce();
  localStorage.removeItem(KEY);
  renderSaves();
  warpSel.value = "1";
  classSel.value = "planet";
  populateTargetOptgroups("");
  targetCustom.value = "";
  clearEngaged();

  const r = loadFlightState();
  if(r && r.active){ r.active=false; saveFlightState(r); }
  clearFlightState();

  stopTravelTicker();
  if(window.starfield) window.starfield.stop();
  depTxt.textContent = "(unspecified)";
  arrTxt.textContent = "(unspecified)";
  updateMetricsStatic();
  zeroMetrics();
  updatePreEngageStatus();
  setStatus('Reset complete.');
  localStorage.removeItem(UI_KEY);
};

resetMetricsBtn.onclick = ()=>{ unlockAudioOnce(); zeroMetrics(); setStatus('Metrics reset to zero.'); };
testAlarmBtn.onclick = ()=>{
  unlockAudioOnce();
  lightPower.classList.remove('ok','warn','bad'); lightPower.classList.add('bad');
  alarmAudio.currentTime = 0; alarmAudio.play().catch(()=>{});
  setTimeout(()=>{ alarmAudio.pause(); alarmAudio.currentTime = 0; lightPower.classList.remove('ok','warn','bad'); lightPower.classList.add('ok'); }, 3000);
};

/* ===================== HAZARD MONITOR (ticker + evasive course) ===================== */
function hazardLoop(){
  evaluateHazards(); // run once
  setInterval(evaluateHazards, 3000); // every 3s
}

function evaluateHazards(){
  if(!hazardsPack || !Array.isArray(hazardsPack.hazards)){ // not loaded
    hazardOverlay.classList.remove('bad','blink');
    hazardOverlay.textContent = 'SAFE';
    return;
  }
  const rows = hazardsPack.hazards.map(h=>({
    name: h.hazard_name,
    type: h.hazard_type,
    d: Number(h.hazard_distance_ly),
    safe: Number(h.safe_distance_ly),
    vec: h.hazard_vector || null
  })).filter(x=>isFinite(x.d) && isFinite(x.safe));

  const inside = rows.filter(r=> r.d <= r.safe);
  if(inside.length){
    const list = inside.map(r=>r.name).slice(0,2).join(', ') + (inside.length>2? '…':'');
    hazardOverlay.textContent = `⚠ HAZARD: ${list}`;
    hazardOverlay.classList.add('bad','blink');
    setDot(lightNav,'bad');
    if(audioUnlocked) alarmAudio.play().catch(()=>{});

    // Auto-evasive: yaw away 180° from first hazard vector if available; else 45° off current
    const h0 = inside[0];
    let evasiveDeg = null;
    if(h0.vec && h0.vec.ra_deg!=null && h0.vec.dec_deg!=null){
      evasiveDeg = (bearingFromRaDec(h0.vec.ra_deg, h0.vec.dec_deg) + 180) % 360;
    }
    if(window.starfield){
      const ms = 10000; // 10s evasive
      window.starfield.setOverride(evasiveDeg!=null ? evasiveDeg : ((Math.random()*360)|0), ms);
    }
  } else {
    const nearest = rows.slice().sort((a,b)=>(a.d/a.safe)-(b.d/b.safe))[0];
    hazardOverlay.classList.remove('bad','blink');
    hazardOverlay.textContent = nearest ? `SAFE · Nearest: ${nearest.name} (${(nearest.d/nearest.safe).toFixed(2)}×)` : 'SAFE';
    setDot(lightNav,'ok');
    if(!anyBad() && audioUnlocked){ alarmAudio.pause(); alarmAudio.currentTime = 0; }
  }
}

function bearingFromRaDec(raDeg, decDeg){
  const ra = raDeg * Math.PI/180, dec = decDeg * Math.PI/180;
  let deg = Math.atan2(Math.cos(dec)*Math.sin(ra), Math.cos(dec)*Math.cos(ra)) * 180/Math.PI;
  if(deg<0) deg+=360;
  return deg;
}
</script>
</body>
</html>
