<script>
/* ====== Constants / helpers ====== */
const AU_M=1.495978707e11, C_MPS=299792458, G=6.67430e-11, MU0=4*Math.PI*1e-7, SIGMA_SB=5.670374419e-8;
const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
const $=id=>document.getElementById(id);
let ac=null; 
function tone(kind="good"){ 
  if(!$("soundOn").checked) return; 
  if(!ac){try{ac=new (window.AudioContext||window.webkitAudioContext)();}catch{}}
  if(!ac) return; 
  const o=ac.createOscillator(), g=ac.createGain(); 
  o.type="sine"; o.frequency.value= kind==="good"?880:kind==="warn"?520:320;
  g.gain.value=.001; o.connect(g).connect(ac.destination); o.start();
  g.gain.exponentialRampToValueAtTime(.07, ac.currentTime+.02); 
  g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+.18); 
  o.stop(ac.currentTime+.2);
}
function setLight(el,level){ 
  const was=el.dataset.level||"good"; 
  if(was!==level){ 
    el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level); 
    tone(level==="good"?"good":level==="warn"?"warn":"bad"); 
  } 
}

/* ====== IST time, orbits ====== */
let tIST0=performance.now();
function IST_INPUT(){ return Number($("istDay0Years").value||45500000000); }
function DPY_INPUT(){ return Number($("baselineDaysPerYear").value||365.25); }
function IST_snapshot(){ 
  const dpy=DPY_INPUT(), spy=dpy*86400; 
  const elapsed=(performance.now()-tIST0)/1000/spy; 
  const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy; 
  return {istYears, istDays, dpy, spy}; 
}
function planetAgeYears(name,iy){ return Math.max(0, iy - (formationOffsetMyr[name]||0)*1e6); }
function trueAnomalyFrac(name,iy,dpy){ 
  const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name]; 
  if(!T) return 0; 
  const N=pd/T; return N-Math.floor(N); 
}
function orbitsFor(name,pd){ 
  const T=orbitalDays[name]; if(!T) return null; 
  const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T; 
  return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T}; 
}

/* ====== Engine dynamics & inputs ====== */
let simulationRunning=false, shipProgress=0, shipArrived=false;
let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null, lastFrameTime=performance.now();
const engineState={ t:0, temp:0, sag:0, containNeed:0.22, jitter:0 };
function stepEngineDynamics(dt, running){
  if(!running){ 
    engineState.temp=Math.max(0,engineState.temp-0.30*dt); 
    engineState.sag=Math.max(0,engineState.sag-0.25*dt); 
    engineState.jitter*=0.85; 
    engineState.containNeed=0.22+0.06*engineState.temp; 
    return; 
  }
  engineState.t+=dt; engineState.temp=Math.min(1,engineState.temp+0.06*dt);
  const baseSag=0.02+0.04*engineState.temp, ripple=0.01*Math.sin(0.7*engineState.t);
  engineState.sag=Math.max(0, baseSag + ripple);
  engineState.containNeed=0.22+0.06*engineState.temp;
  const biasMag=Math.hypot(Number($("lrBias").value||0)/100, Number($("udBias").value||0)/100);
  engineState.jitter = 0.01 + 0.03*biasMag + 0.01*Math.sin(3*engineState.t) + 0.006*(Math.random()-0.5);
  engineState.jitter = Math.max(0, Math.min(0.08, engineState.jitter));
}
function warpInputs(){ return { warp:Number($("warpSpeed").value||1), exp:Number($("warpExp").value||3), scale:Number($("warpScale").value||1) }; }
function engineInputs(){
  const reactorMW_in=Number($("reactorMW").value||5000);
  const front=Number($("frontPct").value||0)/100, rear=Number($("rearPct").value||0)/100;
  const lr=Number($("lrBias").value||0)/100, ud=Number($("udBias").value||0)/100;
  const mode=$("intakeMode").value;
  const reactorMW = reactorMW_in * (1 - engineState.sag);

  const vecDemand=Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  let coilsPct=Math.max(0.35, 0.55 - 0.25*vecDemand);
  let containPct=Math.max(engineState.containNeed, 0.20);
  let vanesPct=Math.min(0.35, 1 - coilsPct - containPct);
  const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; }

  $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`;
  $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`;
  $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`;

  let stability=1.0;
  if (containPct < engineState.containNeed) stability -= 0.40*(engineState.containNeed - containPct)/engineState.containNeed;
  const biasMag=Math.hypot(lr,ud); stability -= 0.30*Math.max(0, biasMag-0.3)/0.7;
  if (rear<front) stability -= 0.20*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability -= engineState.jitter;
  stability = Math.max(0, Math.min(1, stability));

  return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, stability, mode};
}

/* ====== Physics gating ====== */
let lastPhysics = { gf:0.5, vcap_c:0.6, gttMin:1, ecOK:true, horizon:false, beta:0 };
let calib = "off";
function setCalibration(kind){
  calib = kind;
  switch(kind){
    case "mars_opp": physicsCal.kGF=1.12; physicsCal.kCap=1.10; break;
    case "mars_conj": physicsCal.kGF=0.92; physicsCal.kCap=0.88; break;
    default: physicsCal.kGF=1.00; physicsCal.kCap=1.00; break;
  }
}
const physicsCal = { kGF:1.00, kCap:1.00 };

/* ====== ETA / distance ====== */
function computeETASeconds(v_mps_override=null){
  const { istYears, dpy } = IST_snapshot();
  const dest=$("destination").value;
  const { warp, exp, scale } = warpInputs();
  const eng=engineInputs();

  const r1=orbitAU.Earth, r2=orbitAU[dest];
  const thE0=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD0=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;

  const TE = orbitalDays.Earth * 86400;
  const TD = orbitalDays[dest] * 86400;
  const wE = TE ? (2*Math.PI/TE) : 0;
  const wD = TD ? (2*Math.PI/TD) : 0;

  const v_base = C_MPS * scale * Math.pow(Math.max(1, warp), exp);
  const { v_mps, gf, vcap_c, gttMin, ecOK, horizon, beta } = gatedSpeed(v_base, eng);
  lastPhysics = { gf, vcap_c, gttMin, ecOK, horizon, beta };

  const v = v_mps_override ?? v_mps;

  let t=0; const maxIter=8;
  for(let k=0;k<maxIter;k++){
    const thE=thE0 + wE*t, thD=thD0 + wD*t;
    const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD-thE));
    const tNew=(dAU*AU_M)/Math.max(v,1e-3);
    if(Math.abs(tNew-t)<0.05){ t=tNew; break; }
    t=tNew;
  }
  const dAU0=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD0-thE0));
  setLight($("lightNav"), isFinite(t)?(t<86400?"good":"warn"):"bad");
  return { eta:t, dAU:dAU0, v, thE:thE0, thD:thD0, r1, r2 };
}

/* ====== GR Mini + ∫|∇Φ|² ====== */
const grCanvas = $("grCanvas"), grx = grCanvas.getContext("2d");
const GR = { nx: 120, ny: 48, L: 900, sigma: 150, scalePhi: 1.0e10 };
function buildPotentialGrid(){
  const eng=engineInputs(); const front=eng.front, rear=eng.rear, lr=eng.lr, ud=eng.ud;
  const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma;
  const A_r = rear*1.2e14, A_f = front*1.2e14;
  const x0 = 180 + 110*rear, y0 =  70*ud, xskew = 70*lr;
  const phi = new Float64Array(nx*ny);
  for(let j=0;j<ny;j++){
    const y=(j-ny/2)*dy;
    for(let i=0;i<nx;i++){
      const x=(i-nx/2)*dx;
      const rRear2=(x + x0 + xskew)**2 + (y - y0)**2;
      const rFront2=(x - x0 + xskew)**2 + (y + y0)**2;
      phi[i+j*nx] = (-A_r*Math.exp(-rRear2/s2) + A_f*Math.exp(-rFront2/s2))/GR.scalePhi;
    }
  }
  return {phi, dx, dy, nx, ny};
}
function grad2(phi,i,j,nx,ny,dx,dy){ const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx]; const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx]; const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy}; }
function validateGR(){
  const {phi, dx, dy, nx, ny} = buildPotentialGrid();
  let gttMin=+1, phiMin=+1e99, phiMax=-1e99, Eint=0;
  for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; }
  const span=Math.max(1e-12, phiMax-phiMin);

  grCanvas.width=grCanvas.clientWidth; grCanvas.height=110; grx.clearRect(0,0,grCanvas.width,grCanvas.height);

  let rhoMin=+1e99, rhoMax=-1e99, horizons=0;

  for(let j=1;j<ny-1;j++){
    for(let i=1;i<nx-1;i++){
      const {g2} = grad2(phi,i,j,nx,ny,dx,dy);
      Eint += g2 * dx * dy;
      const ph=phi[i+j*nx];
      const rho_em = g2/(2*MU0*C_MPS*C_MPS); if(rho_em<rhoMin)rhoMin=rho_em; if(rho_em>rhoMax)rhoMax=rho_em;
      const gtt=1 + 2*ph/(C_MPS*C_MPS); if(gtt<gttMin)gttMin=gtt; if(gtt<=0)horizons++;

      if(j===Math.floor(ny/2)){
        const x=Math.floor((i/nx)*grCanvas.width), t=(ph - phiMin)/span; 
        const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t));
        grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,110);
      }
    }
  }

  $("gr_gtt").textContent = gttMin.toFixed(6);
  $("gr_rho").textContent = `${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}`;
  $("gr_ec").textContent  = `✅ NEC • ✅ WEC • ✅ SEC`;
  $("gr_hor").textContent = horizons>0 ? `⚠ ${horizons}` : "None";

  return { Eint, gttMin };
}
function gatedSpeed(v_base, eng){
  const { Eint, gttMin } = validateGR();

  const Escaled = Math.log10(1 + Math.max(0, Eint)/1e6);
  const gf_raw = 1/(1+Math.exp(-(Escaled-2.0)));
  let gf = Math.max(0.05, Math.min(1.0, gf_raw * physicsCal.kGF));

  const pMW = Math.max(0, eng.reactorMW);
  let vcap_c = Math.min(0.99, physicsCal.kCap * (0.10 + 0.45*(1 - Math.exp(-pMW/6000)) + 0.25*gf) * Math.max(0.35, eng.stability));

  if (gttMin <= 0.01){ vcap_c = Math.min(vcap_c, 0.15); setLight($("lightBubble"),"bad"); }
  else if (gttMin < 0.05){ vcap_c = Math.min(vcap_c, 0.35); setLight($("lightBubble"),"warn"); }
  else setLight($("lightBubble"),"good");

  const v_limited = Math.min(v_base * gf, vcap_c * C_MPS);
  const beta = Math.max(0, Math.min(0.99, v_limited / C_MPS));
  const ecOK=true, horizon=(gttMin<=0);

  $("constraints").textContent = `EC/Horizon: g_tt min ${gttMin.toFixed(5)} • gf ${gf.toFixed(2)} • cap ${(vcap_c).toFixed(2)} c`;
  return { v_mps: v_limited, gf, vcap_c, gttMin, ecOK, horizon, beta };
}
</script>
<script>
/* ====== Polar Map ====== */
const orbitCanvas=$("orbitCanvas"), octx=orbitCanvas.getContext("2d");
function drawOrbitView(){
  const dest=$("destination").value;
  const {eta, thE, thD, r1, r2}=computeETASeconds();
  const w=orbitCanvas.width=orbitCanvas.clientWidth, h=orbitCanvas.height=orbitCanvas.clientHeight, cx=w/2, cy=h/2, minDim=Math.min(w,h);

  const maxR = Math.max(r1, r2);
  const RmaxPx = Math.max(120, minDim*0.38);
  const scale = RmaxPx / Math.max(maxR, 0.01);

  octx.clearRect(0,0,w,h);

  octx.beginPath(); octx.arc(cx,cy,7,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.fill();
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun",cx-14,cy-12);

  const rE=r1*scale, rD=r2*scale;
  octx.beginPath(); octx.arc(cx,cy,rE,0,Math.PI*2); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();
  octx.beginPath(); octx.arc(cx,cy,rD,0,Math.PI*2); octx.strokeStyle="#ffffff"; octx.lineWidth=1.1; octx.stroke();

  const Ex=cx+rE*Math.cos(thE), Ey=cy+rE*Math.sin(thE);
  const Dx=cx+rD*Math.cos(thD), Dy=cy+rD*Math.sin(thD);
  octx.beginPath(); octx.arc(Ex,Ey,3.5,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.fill();
  octx.beginPath(); octx.arc(Dx,Dy,3.5,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.fill();

  const TD=orbitalDays[dest]*86400, dTh=(eta/TD)*Math.PI*2;
  const thArr=(thD+dTh)%(Math.PI*2);
  const Ax=cx+rD*Math.cos(thArr), Ay=cy+rD*Math.sin(thArr);
  octx.beginPath(); octx.arc(Ax,Ay,4.5,0,Math.PI*2); octx.fillStyle="#16a34a"; octx.fill();

  octx.fillStyle="#9fb4d9"; octx.fillText("Earth r="+r1.toFixed(2)+" AU", cx+rE+6, cy-2);
  octx.fillStyle="#9fd9b1"; octx.fillText(dest+" r="+r2.toFixed(2)+" AU", cx+rD+6, cy+12);

  const degNow=(thD*180/Math.PI+360)%360, degArr=(thArr*180/Math.PI+360)%360; 
  let d=degArr-degNow; if(d<0)d+=360;
  $("orbitLegend").textContent=`Now ${degNow.toFixed(1)}° → ETA ${degArr.toFixed(1)}° • Δ ${d.toFixed(1)}°`;
}

/* ====== NEW: Live Compass (Center Hub) ====== */
/* Points to the destination's predicted arrival position (intercept bearing). */
function drawCompass(){
  const cv=$("compassCanvas"); if(!cv) return;
  const ctx=cv.getContext("2d");
  const w=cv.width=cv.clientWidth, h=cv.height=cv.clientHeight, cx=w/2, cy=h/2;
  const R=Math.min(w,h)*0.42;

  // Compute bearing from Earth "now" to destination "at arrival"
  const dest=$("destination").value;
  const {eta, thE, thD, r1, r2}=computeETASeconds();
  const TD=orbitalDays[dest]*86400||1, thArr=(thD + (eta/TD)*2*Math.PI)%(2*Math.PI);

  // Positions in math coordinates (+y up)
  const Ex=r1*Math.cos(thE),  Ey=r1*Math.sin(thE);
  const Ax=r2*Math.cos(thArr),Ay=r2*Math.sin(thArr);

  const dx=Ax-Ex, dy=Ay-Ey;
  const L=Math.hypot(dx,dy)||1;
  const ux=dx/L,  uy=dy/L;

  // Canvas vector (y down), so flip y for drawing
  const endX=cx + ux*R*0.75;
  const endY=cy - uy*R*0.75;

  // Compass bearing (0=N, 90=E...)
  const bearingDeg = (Math.atan2(dx, dy)*180/Math.PI+360)%360;

  // Background
  ctx.clearRect(0,0,w,h);
  const glow=ctx.createRadialGradient(cx,cy,R*0.2, cx,cy,R*1.05);
  glow.addColorStop(0,"rgba(125,211,252,0.12)");
  glow.addColorStop(1,"rgba(80,140,210,0.05)");
  ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(cx,cy,R*1.05,0,Math.PI*2); ctx.fill();

  // Outer ring
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2);
  ctx.strokeStyle="#3a5a8f"; ctx.lineWidth=2; ctx.stroke();

  // Ticks (every 10°, major every 30°)
  ctx.save();
  ctx.translate(cx,cy);
  for(let d=0; d<360; d+=10){
    const a=(d-90)*Math.PI/180; // 0° at north (up)
    const r0=R*(d%30===0?0.80:0.86), r1=R*0.92;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*r0, Math.sin(a)*r0);
    ctx.lineTo(Math.cos(a)*r1, Math.sin(a)*r1);
    ctx.strokeStyle=d%30===0?"#9fb4d9":"#6b85b5";
    ctx.lineWidth=d%30===0?1.6:1; ctx.stroke();
  }
  // Labels N E S W
  ctx.fillStyle="#cfe2ff"; ctx.font="600 12px system-ui,Segoe UI,Roboto";
  const labels=[["N",0],["E",90],["S",180],["W",270]];
  labels.forEach(([t,deg])=>{
    const a=(deg-90)*Math.PI/180, rr=R*0.64;
    ctx.fillText(t, Math.cos(a)*rr-4, Math.sin(a)*rr+4);
  });
  ctx.restore();

  // Needle
  ctx.beginPath();
  ctx.moveTo(cx,cy);
  ctx.lineTo(endX,endY);
  ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=3; ctx.stroke();

  // Needle head
  const vx=endX-cx, vy=endY-cy, vL=Math.hypot(vx,vy)||1, uxN=vx/vL, uyN=vy/vL;
  ctx.beginPath();
  ctx.moveTo(endX, endY);
  ctx.lineTo(endX - uxN*10 - uyN*5, endY - uyN*10 + uxN*5);
  ctx.lineTo(endX - uxN*10 + uyN*5, endY - uyN*10 - uxN*5);
  ctx.closePath();
  ctx.fillStyle="#22d3ee"; ctx.fill();

  // Center cap
  ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2);
  ctx.fillStyle="#eaf2ff"; ctx.fill();

  // Legend
  $("compassLegend").textContent = `Bearing to ${dest} (arrival): ${bearingDeg.toFixed(1)}° • Warp ${(Number($("warpSpeed").value)||1)} • β ${(lastPhysics?.beta||0).toFixed(2)}`;
}

/* ====== Curve & vectors ====== */
const curveCanvas=$("curveCanvas"), ctx=curveCanvas.getContext("2d");
function drawCurve(){
  const w=curveCanvas.width=curveCanvas.clientWidth, h=curveCanvas.height=curveCanvas.clientHeight;
  const dest=$("destination").value;
  const arcHeight=Math.max(32, 60/Math.max(1, 1*(lastPhysics?.gf||0.5)));
  const startX=60, endX=w-60, baseY=h-46;

  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(startX,baseY,7,0,Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-20, baseY+18);
  ctx.beginPath(); ctx.arc(endX,baseY,6.5,0,Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(dest, endX-22, baseY+18);

  ctx.beginPath(); ctx.moveTo(startX,baseY);
  ctx.quadraticCurveTo((startX+endX)/2, baseY-arcHeight*3, endX, baseY);
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  const t=shipProgress, mx=(startX+endX)/2, ctrlY=baseY-arcHeight*3;
  const sx=(1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy=(1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;
  ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowColor=ctx.fillStyle; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;

  const arrow=(x,y,dx,dy,color)=>{ const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const ex=x+dx, ey=y+dy;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-6*ux+3*uy,ey-6*uy-3*ux); ctx.lineTo(ex-6*ux-3*uy,ey-6*uy+3*ux); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); };
  const f=$("frontPct").value/100, r=$("rearPct").value/100, lr=$("lrBias").value/100, ud=$("udBias").value/100; const k=Math.min(44, h*0.18);
  arrow(sx,sy, 0,-k*r,"#22c55e");
  arrow(sx,sy, 0, k*f,"#f97316");
  arrow(sx,sy, k*lr,0,"#8b5cf6");
  arrow(sx,sy, 0,-k*ud,"#38bdf8");

  $("curveLegend").textContent=`Rear ${Math.round(r*100)}% • Front ${Math.round(f*100)}% • LR ${Math.round(lr*100)}% • UD ${Math.round(ud*100)}% • β ${(lastPhysics?.beta||0).toFixed(2)}`;
}

/* ====== Clocks ====== */
const clocks=[
  { id:"C1", location:"Biometric", purpose:"Crew/Local", drift:0 },
  { id:"C2", location:"Warp Edge", purpose:"Phase Monitor", drift:3 },
  { id:"C3", location:"NavCore",   purpose:"Navigation", drift:0 },
  { id:"C4", location:"CST Earth", purpose:"Master Anchor", drift:0 },
  { id:"C5", location:"DriftEye",  purpose:"Diagnostics", drift:-6 }
];
function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function renderClockCards(arrISTstr, arrCSTms){
  const grid=$("clockGrid"); grid.innerHTML="";
  const base=Date.now(); let total=0;
  clocks.forEach(c=>{
    if(simulationRunning) c.drift += Math.random()*2 - 1;
    const local=base + c.drift; const d=c.drift.toFixed(2); total += Math.abs(c.drift);
    let status="good", label="✅ Synced"; if(Math.abs(c.drift)>5){status="warn"; label="⚠ Drift";} if(Math.abs(c.drift)>10){status="bad"; label="❌ Unsafe";}
    const card=document.createElement("div");
    card.className="clockCard";
    card.innerHTML=`
      <div class="clockHdr">
        <div class="clockTitle">${c.id} • ${c.location}</div>
        <div class="status ${status}">${label}</div>
      </div>
      <div class="kv">
        <div>Purpose</div><div>${c.purpose}</div>
        <div>CST</div><div>${fmtClock(base)}</div>
        <div>Local</div><div>${fmtClock(local)}</div>
        <div>Δ</div><div>${d} ms</div>
        <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
        <div>Arrival IST</div><div>${arrISTstr}</div>
      </div>`;
    grid.appendChild(card);
  });
  return total/clocks.length;
}

/* ====== Starfield ====== */
(function(){
  const cvs=$("starfieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const STAR_COUNT=180; const stars=new Array(STAR_COUNT).fill(0).map(seed);
  let raf=null, last=performance.now(), paused=false;

  function seed(){ return {x:(Math.random()*2-1)*W(), y:(Math.random()*2-1)*H(), z:Math.random(), tw:Math.random()*Math.PI*2}; }
  function recycle(s){ s.x=(Math.random()*2-1)*W(); s.y=-0.55*H(); s.z=Math.random(); s.tw=Math.random()*Math.PI*2; }

  function dopplerShift(base){
    const beta = Math.max(0, Math.min(0.99, lastPhysics?.beta||0));
    const z = Math.sqrt((1+beta)/(1-beta));
    const r = Math.max(0, Math.min(255, 200 / z));
    const g = Math.max(0, Math.min(255, 220 / Math.sqrt(z)));
    const b = Math.max(0, Math.min(255, 255));
    const a = 0.22 + 0.5*base;
    return {r,g,b,a};
  }

  function step(dt){
    const flow=26*(1+1.2*(lastPhysics?.beta||0));
    for(const s of stars){
      const v=flow*(1.4-0.9*s.z);
      s.x+=0; s.y+=1*v*dt; s.tw+=3.0*dt;
      if(s.y>0.60*H()) recycle(s);
    }
  }
  function draw(){
    ctx.clearRect(0,0,W(),H());
    const beta = lastPhysics?.beta||0;
    const streak=1+(beta*1.8);
    const cx=CX(), cy=CY();

    ctx.save(); ctx.translate(cx,cy);
    for(const s of stars){
      const sz=1+1.5*(1-s.z), a=0.35+0.55*Math.abs(Math.sin(s.tw));
      const col=dopplerShift(a);
      ctx.fillStyle=`rgba(${col.r|0},${col.g|0},${col.b|0},${col.a.toFixed(2)})`;
      ctx.fillRect(s.x,s.y,sz,sz);
      ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(s.x, s.y - streak*7*(1-s.z));
      ctx.strokeStyle=`rgba(${(col.r+30|0)},${(col.g+30|0)},${(col.b+30|0)},${(0.18+0.35*(1-s.z)).toFixed(2)})`;
      ctx.lineWidth=1; ctx.stroke();
    }
    ctx.restore();

    const g=ctx.createRadialGradient(cx,cy,32, cx,cy,52); g.addColorStop(0,"rgba(120,220,255,0.16)"); g.addColorStop(1,"rgba(80,180,255,0.03)");
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,52,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,40,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.2; ctx.stroke();
    ctx.save(); ctx.translate(cx,cy+3); ctx.beginPath(); ctx.moveTo(0,-16*0.9); ctx.lineTo(11*0.55,16*0.8); ctx.lineTo(-11*0.55,16*0.8); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill(); ctx.restore();

    $("starfieldLegend").textContent=`Visual β=${beta.toFixed(2)} • gf=${(lastPhysics?.gf||0).toFixed(2)} • cap=${(lastPhysics?.vcap_c||0).toFixed(2)}c`;
  }
  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.starfieldControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Debris + Shield integration ====== */
(function(){
  const cvs=$("debrisCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  let last=performance.now(), raf=null, paused=false;
  const bubble={ r:46 }; const debris=[]; const MAX_DEBRIS=24;

  function seed(){ 
    debris.length=0; 
    for(let i=0;i<MAX_DEBRIS;i++){ 
      const ang=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
      debris.push({
        x:CX()+R*Math.cos(ang), y:CY()+R*Math.sin(ang),
        vx:-(38+Math.random()*55)*Math.cos(ang),
        vy:-(38+Math.random()*55)*Math.sin(ang),
        q:(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7),
        alive:true
      }); 
    } 
  }
  seed();

  function alloc(){ 
    const e=engineInputs(); 
    const tot=e.reactorMW||5000; 
    const g=lastPhysics?.gf||0.5;
    let pre=Math.min(.50,.25+.08*g), skin=Math.min(.35,.20+.10*g), grid=Math.max(.10,1-pre-skin);
    return { MW:{pre:pre*tot, skin:skin*tot, grid:grid*tot}, frac:{pre,skin,grid} }; 
  }

  function step(dt){
    const {MW,frac}=alloc(); 
    const preF=6*Math.sqrt(MW.pre+1), skinB=4*Math.sqrt(MW.skin+1);
    for(const d of debris){ 
      if(!d.alive) continue; 
      const dx=d.x-CX(), dy=d.y-CY(), r=Math.hypot(dx,dy)+1e-6, nx=dx/r, ny=dy/r;

      if(ny<-0.2){ d.vx+=nx*preF*dt*0.08; d.vy+=ny*preF*dt*0.08; }
      if(r<bubble.r*1.5 && Math.abs(d.q)>0){ const kick=skinB*0.12*dt, tx=-ny, ty=nx; d.vx+=tx*kick*Math.sign(d.q); d.vy+=ty*kick*Math.sign(d.q); }
      if(r<bubble.r*1.06){ 
        const hitProb=Math.min(0.95,0.25+frac.grid*0.8); 
        const ang=Math.atan2(dy,dx);
        if(window.shieldBox && window.shieldBox.hit){ const intensity=Math.min(1, (Math.hypot(d.vx,d.vy)/110)); window.shieldBox.hit(ang,intensity); }
        if(Math.random()<hitProb) d.alive=false; 
      }
      d.x+=d.vx*dt; d.y+=d.vy*dt;
      if(!d.alive || d.x<-180 || d.x>W()+180 || d.y<-180 || d.y>H()+180){ 
        if(Math.random()<0.02){ 
          const a=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100; 
          d.x=CX()+R*Math.cos(a); d.y=CY()+R*Math.sin(a); d.vx=-(38+Math.random()*55)*Math.cos(a); d.vy=-(38+Math.random()*55)*Math.sin(a); d.q=(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7); d.alive=true; 
        } 
      }
    }

    const ahead=debris.filter(d=>d.alive && d.y<CY()-bubble.r*1.4 && Math.abs(d.x-CX())<bubble.r*1.1);
    const hold=ahead.length>6, adjust=!hold && ahead.length>3; 
    let msg=`Defense MW — Pre:${MW.pre.toFixed(0)} | Skin:${MW.skin.toFixed(0)} | Grid:${MW.grid.toFixed(0)} `;
    msg += hold? "• HOLD":"• "+(adjust?"ADJUST":"CLEAR"); 
    $("debrisLegend").textContent=msg; 
    if(hold) setLight($("lightNav"),"warn");
  }

  function draw(){
    const cx=CX(), cy=CY();
    const ctx=$("debrisCanvas").getContext("2d");
    ctx.clearRect(0,0,W(),H());
    ctx.beginPath(); ctx.arc(cx,cy,bubble.r,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.3; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy, bubble.r*2.2, -Math.PI*0.95, -Math.PI*0.05, false); ctx.closePath();
    ctx.fillStyle="rgba(252,211,77,.15)"; ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,bubble.r*1.15,0,Math.PI*2); ctx.strokeStyle="rgba(56,189,248,.18)"; ctx.lineWidth=8; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,3.3,0,Math.PI*2); ctx.fillStyle="#cfe2ff"; ctx.fill();
    for(const d of debris){ if(d.alive) { ctx.fillStyle=Math.abs(d.q)>0?"#fca5a5":"#e5e7eb"; ctx.beginPath(); ctx.arc(d.x,d.y,1.6,0,Math.PI*2); ctx.fill(); } }
  }

  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.debrisControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Shield Box ====== */
(function(){
  const cvs=$("shieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const SECT=12; const sectors=new Array(SECT).fill(1); let flashes=[]; 
  let paused=false, raf=null, last=performance.now();

  function warpScale(){ return 0.82 + 0.05*Math.max(1, Number($("warpSpeed").value)||1); }
  function bubbleRadius(){ return 36*Math.min(1.3, warpScale()); }
  function repair(dt){ for(let i=0;i<SECT;i++){ sectors[i]=Math.min(1, sectors[i]+0.08*dt); } flashes=flashes.filter(f=>{ f.t-=dt; return f.t>0; }); }

  function draw(){
    const cx=CX(), cy=CY(), R=bubbleRadius(); cvs.width=W(); cvs.height=H();
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const glow=ctx.createRadialGradient(cx,cy,R*.6, cx,cy,R+12);
    glow.addColorStop(0,`rgba(120,220,255,${0.1+0.12*sectors.reduce((a,b)=>a+b,0)/SECT})`);
    glow.addColorStop(1,"rgba(80,180,255,0.02)");
    ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(cx,cy,R+12,0,Math.PI*2); ctx.fill();

    for(let i=0;i<SECT;i++){
      const t0=(i/SECT)*Math.PI*2, t1=((i+1)/SECT)*Math.PI*2, s=sectors[i];
      ctx.beginPath(); ctx.arc(cx,cy,R, t0,t1);
      ctx.strokeStyle=s>0.66?"#7dd3fc":s>0.33?"#facc15":"#ef4444";
      ctx.lineWidth=2.2+2.2*s; ctx.stroke();
    }

    ctx.beginPath(); ctx.moveTo(cx, cy-R*0.65); ctx.lineTo(cx+9, cy+10); ctx.lineTo(cx-9, cy+10); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill();

    for(const f of flashes){
      const a=Math.max(0,Math.min(1,f.t/.25));
      ctx.beginPath(); ctx.arc(f.x,f.y, 5+9*(1-a), 0,Math.PI*2);
      ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.8; ctx.stroke();
    }

    $("shieldLegend").textContent=`Shield ${(sectors.reduce((a,b)=>a+b,0)/SECT*100).toFixed(0)}% • R ${R.toFixed(1)} • β ${(lastPhysics?.beta||0).toFixed(2)}`;
  }

  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; repair(dt); draw(); raf=requestAnimationFrame(loop); }
  function hit(theta,intensity){
    const rot=theta+Math.PI/2;
    let idx=Math.floor((((rot%(2*Math.PI))+2*Math.PI)%(2*Math.PI))/(2*Math.PI)*SECT);
    idx=Math.max(0,Math.min(SECT-1,idx));
    sectors[idx]=Math.max(0,sectors[idx]-0.35*Math.max(0.2,intensity));
    const R=bubbleRadius();
    flashes.push({x:CX()+R*Math.cos(theta), y:CY()+R*Math.sin(theta), t:.25});
  }
  window.shieldBox={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); }, hit };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Status / lifecycle ====== */
const flightLog=[];
function updateAllStatus(){
  const {eta,dAU,v}=computeETASeconds();
  const base=Date.now(), arrCST=base+eta*1000;

  const {istYears,spy}=IST_snapshot(); 
  const arrIST=istYears + eta/spy;
  const arrISTstr=`${(arrIST/1e9).toFixed(6)} Ga • ${Math.floor(arrIST).toLocaleString()} y`;

  const avg=renderClockCards(arrISTstr, arrCST);
  const warp=Number($("warpSpeed").value||1), dest=$("destination").value;
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";

  $("beacon").textContent=`🛰️ Warp ${warp} → ${dest} | ${dAU.toFixed(3)} AU | ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Drift ${avg.toFixed(2)} ms`;
  flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});

  // NEW: keep the compass live
  drawCompass();
}

const rootEl=document.documentElement, scaleEl=$("uiScale");
function applyScale(){
  const pct=Number(scaleEl.value||85);
  try{ localStorage.setItem('uiScalePct', String(pct)); }catch{}
  rootEl.style.setProperty('--ui-scale',(pct/100).toString());
  $("uiScaleVal").textContent=pct+"%";
  drawCurve(); drawOrbitView(); updateAllStatus(); drawCompass();
}

/* ====== Controls ====== */
function startAll(){ 
  if(simulationRunning) return; 
  simulationRunning=true; shipArrived=false; shipProgress=0; tone("good");

  lastFrameTime=performance.now(); 
  driftInterval=setInterval(updateAllStatus,700);
  beaconInterval=setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); },2000);
  orbitInterval=setInterval(()=>{ updateOrbitTable(); drawOrbitView(); },1200);
  animationFrame=requestAnimationFrame(animate);

  if(window.starfieldControl) window.starfieldControl.start();
  if(window.debrisControl) window.debrisControl.start();
  if(window.shieldBox) window.shieldBox.start();
}
function stopAll(){ 
  simulationRunning=false; 
  clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval); 
  cancelAnimationFrame(animationFrame);
  stepEngineDynamics(0.2,false); tone("warn");
  if(window.starfieldControl) window.starfieldControl.stop();
  if(window.debrisControl) window.debrisControl.stop();
  if(window.shieldBox) window.shieldBox.stop();
}
function resetAll(){ 
  stopAll(); shipProgress=0; shipArrived=false; clocks.forEach(c=>c.drift=0);
  tIST0=performance.now(); 
  engineState.t=0; engineState.temp=0; engineState.sag=0; engineState.containNeed=0.22; engineState.jitter=0;
  $("beacon").textContent="⏳ Waiting…"; 
  updateOrbitTable(); drawCurve(); drawOrbitView(); updateAllStatus(); drawCompass();
}
function exportLog(){ 
  const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"],
              ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
  const csv=rows.map(r=>r.join(",")).join("\n"); 
  const blob=new Blob([csv],{type:"text/csv"}); 
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click(); 
}
$("exportBtn").onclick=exportLog;
$("startBtn").onclick=startAll; $("stopBtn").onclick=stopAll; $("resetBtn").onclick=resetAll;

[
  "warpSpeed","warpExp","warpScale","destination","calibration",
  "istDay0Years","baselineDaysPerYear","reactorMW",
  "frontPct","rearPct","lrBias","udBias","intakeMode","soundOn","uiScale"
].forEach(id=>{
  const el=$(id); if(!el) return;
  el.addEventListener("input", ()=>{
    if(id==="uiScale") applyScale();
    if(id==="calibration") setCalibration(el.value);
    tIST0=performance.now();
    drawCurve(); drawOrbitView(); updateAllStatus(); drawCompass();
  });
});

/* ====== Ship motion (trajectory) ====== */
function animate(){ 
  if(!simulationRunning || shipArrived) return; 
  const now=performance.now(); const dt=(now-lastFrameTime)/1000; lastFrameTime=now;

  stepEngineDynamics(dt,true); 
  const {eta,v}=computeETASeconds();
  const speedGain = (v/C_MPS); 
  shipProgress += 0.00050*Math.pow(Math.max(1, Number($("warpSpeed").value)||1),0.82)*(0.6+0.8*speedGain);

  if(shipProgress>=1){ shipProgress=1; shipArrived=true; tone("good"); stopAll(); }

  drawCurve(); drawOrbitView(); drawCompass();
  animationFrame=requestAnimationFrame(animate); 
}

/* ====== Orbit table ====== */
function updateOrbitTable(){
  const {istYears,dpy}=IST_snapshot();
  const dest=$("destination").value;

  const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
  const eY=planetAgeYears("Earth",istYears), eD=eY*dpy;
  const eO=orbitsFor("Earth", eD)||{completed:0,frac:0,daysInto:0,yearLen:365.256};
  const pY=planetAgeYears(dest,istYears), pD=pY*dpy;
  const pO=orbitsFor(dest,pD)||{completed:0,frac:0,daysInto:0,yearLen:orbitalDays[dest]||0};

  const {eta,dAU,v}=computeETASeconds();
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";

  const card=(title,lines)=>`
    <div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
      <div style="font-weight:600;margin-bottom:4px">${title}</div>
      ${lines.map(t=>`<div class="stat">${t}</div>`).join("")}
    </div>`;
  $("orbit-rows").innerHTML = [
    card("Sun", [
      `${(sY/1e9).toFixed(6)} Ga`,
      `${Math.floor(sY).toLocaleString()} y`,
      `${Math.floor(sD).toLocaleString()} d`
    ]),
    card("Earth", [
      `Orbits: ${eO.completed.toLocaleString()}`,
      `Progress: <span class="pill">${(eO.frac*100).toFixed(1)}%</span>`,
      `Day ${Math.floor(eO.daysInto)} / ${Math.floor(eO.yearLen)}`
    ]),
    card(dest, [
      `Age: ${(pY/1e9).toFixed(6)} Ga`,
      `Orbits: ${pO.completed.toLocaleString()}`,
      `Day ${Math.floor(pO.daysInto)} / ${Math.floor(pO.yearLen)}`
    ]),
    card("Trip", [
      `Dist: ${dAU.toFixed(3)} AU`,
      `v: ${(v/C_MPS).toFixed(2)} c`,
      `ETA: ${etaStr}`
    ])
  ].join("");
}

/* ====== Split Hero — pairing, orientation, dragging ====== */
function moveEl(el, target){ if(el && target){ target.appendChild(el); } }
function setPair(pair){
  const paneTop=$("paneTop"), paneBottom=$("paneBottom");
  paneTop.innerHTML=""; paneBottom.innerHTML="";

  const curve=$("curveCanvas"), curveL=$("curveLegend");
  const star=$("starfieldCanvas"), starL=$("starfieldLegend");
  const shield=$("shieldCanvas"), shieldL=$("shieldLegend");

  if(pair==="traj-star"){
    moveEl(curve, paneTop); moveEl(curveL, paneTop);
    moveEl(star, paneBottom); moveEl(starL, paneBottom);
  }else if(pair==="traj-shield"){
    moveEl(curve, paneTop); moveEl(curveL, paneTop);
    moveEl(shield, paneBottom); moveEl(shieldL, paneBottom);
  }else{ // star-shield
    moveEl(star, paneTop); moveEl(starL, paneTop);
    moveEl(shield, paneBottom); moveEl(shieldL, paneBottom);
  }

  requestAnimationFrame(()=>{ window.dispatchEvent(new Event('resize')); drawCurve(); });
}

const splitHero = $("splitHero");
const splitVertBtn = $("splitVertBtn");
const splitHorzBtn = $("splitHorzBtn");

function setOrientation(mode){ // 'vertical' | 'horizontal'
  splitHero.classList.remove('vertical','horizontal');
  splitHero.classList.add(mode);
  splitVertBtn.classList.toggle('active', mode==='vertical');
  splitHorzBtn.classList.toggle('active', mode==='horizontal');
  requestAnimationFrame(()=>window.dispatchEvent(new Event('resize')));
}

(function pairButtonsInit(){
  const buttons=[...document.querySelectorAll('.heroPairBtn')];
  buttons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      buttons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      setPair(btn.dataset.pair);
    });
  });
})();

(function splitOrientationInit(){
  splitVertBtn.addEventListener('click', ()=>setOrientation('vertical'));
  splitHorzBtn.addEventListener('click', ()=>setOrientation('horizontal'));
})();

(function splitDragInit(){
  const hero=document.getElementById('splitHero');
  const handle=document.getElementById('splitHandle');
  let dragging=false;

  function setSplitFromPointer(clientX, clientY){
    const rect=hero.getBoundingClientRect();
    const isVertical = hero.classList.contains('vertical');
    let rel;
    if(isVertical){
      rel=(clientY-rect.top)/rect.height;
    }else{
      rel=(clientX-rect.left)/rect.width;
    }
    rel=Math.max(0, Math.min(1, rel));
    const pct=Math.max(20, Math.min(80, Math.round(rel*100))); // clamp 20–80%
    document.documentElement.style.setProperty('--hero-split', pct);
    window.dispatchEvent(new Event('resize'));
  }

  handle.addEventListener('mousedown', e=>{ dragging=true; e.preventDefault(); });
  window.addEventListener('mousemove', e=>{ if(!dragging) return; setSplitFromPointer(e.clientX,e.clientY); });
  window.addEventListener('mouseup', ()=>{ if(dragging){ dragging=false; window.dispatchEvent(new Event('resize')); } });

  handle.addEventListener('touchstart', e=>{ dragging=true; e.preventDefault(); }, {passive:false});
  window.addEventListener('touchmove', e=>{ if(!dragging) return; const t=e.touches[0]; setSplitFromPointer(t.clientX,t.clientY); }, {passive:false});
  window.addEventListener('touchend', ()=>{ if(dragging){ dragging=false; window.dispatchEvent(new Event('resize')); } });
})();

/* ====== NEW PANELS: Mode Alternator (display-only) ====== */
function updateModeAlternator(){
  const S = Number($("ma_S").value||0);
  const r = Number($("ma_r").value||0);
  const f = Number($("ma_f").value||0);
  const phi_ms = Number($("ma_phi").value||0);
  const tau_ms = Number($("ma_tau").value||60);
  const qi = $("ma_qi").checked;

  // Simple display model (normalized units)
  const eps_cas = 1.0;               // tiny in reality; normalized here
  const eps_sq  = 1.0;               // normalized amplitude scale
  const k_payback = qi ? 1.4 : 1.0;  // enforce overcompensation if guardrail ON

  const rho_cas = -eps_cas * S;
  const rho_neg = -eps_sq * r;
  const rho_pos = +k_payback * eps_sq * r;

  $("ma_S_lbl").textContent = S.toFixed(2);
  $("ma_r_lbl").textContent = r.toFixed(2);

  const legend = `Casimir-like offset: ${rho_cas.toFixed(2)} • Neg lobe: ${rho_neg.toFixed(2)} • Payback: +${rho_pos.toFixed(2)} • τ=${tau_ms} ms • ϕ=${phi_ms} ms • f=${f.toFixed(2)} Hz • QI ${qi?"ON":"OFF"}`;
  $("ma_legend").textContent = legend;
}

/* ====== NEW PANELS: Pulse Radiation (photon impulse) ====== */
function updatePulseRadiation(){
  const Ep   = Number($("pr_Ep").value||0);      // J
  const f    = Number($("pr_f").value||0);       // Hz
  const R    = Math.max(0, Math.min(1, Number($("pr_R").value||0)));    // 0..1
  const chi  = Math.max(0, Math.min(1, Number($("pr_chi").value||0)));  // 0..1
  const A    = Math.max(1e-6, Number($("pr_A").value||1));              // m^2
  const Ar   = Math.max(1e-6, Number($("pr_Ar").value||10));            // m^2
  const eps  = Math.max(0.01, Math.min(0.99, Number($("pr_eps").value||0.8))); // 0..1
  const m    = Math.max(1, Number($("pr_m").value||50000));             // kg
  const Tsp  = Math.max(0, Number($("pr_Tspace").value||3));            // K

  const Jgamma = chi * (1+R) * Ep / C_MPS;         // N·s per pulse
  const Favg   = Jgamma * f;                       // N
  const a      = Favg / m;                         // m/s^2
  const dV1h   = a * 3600;                         // m/s per hour
  const Pavg   = Ep * f;                           // W (beam power)
  const Iavg   = Pavg / A;                         // W/m^2 (aperture intensity)
  const Pabs   = chi * (1 - R) * Pavg;             // W absorbed (heating)
  const Teq4   = (Pabs / (SIGMA_SB * eps * Ar)) + Math.pow(Tsp,4);
  const Teq    = Math.pow(Math.max(0, Teq4), 0.25);

  $("pr_legend").innerHTML =
    `Per-pulse impulse J<sub>γ</sub>=${Jgamma.toExponential(3)} N·s • ` +
    `F<sub>avg</sub>=${Favg.toExponential(3)} N • ` +
    `a=${(a*1e3).toFixed(3)} mm/s² • Δv/hr=${dV1h.toFixed(3)} m/s<br>` +
    `P<sub>avg</sub>=${Pavg.toFixed(1)} W • I<sub>avg</sub>=${Iavg.toFixed(1)} W/m² • T<sub>rad,eq</sub>≈${Teq.toFixed(1)} K`;
}

/* ====== Init + resize ====== */
window.addEventListener('resize', ()=>{ drawCurve(); drawOrbitView(); updateAllStatus(); drawCompass(); });

window.onload=()=>{ 
  try{ const saved=localStorage.getItem('uiScalePct'); if(saved){ $("uiScale").value = saved; } }catch{}
  setCalibration($("calibration").value || "off");

  setPair('traj-star');       // default pair
  setOrientation('vertical'); // default orientation

  // Mode Alternator listeners
  ["ma_S","ma_r","ma_f","ma_phi","ma_tau","ma_qi"].forEach(id=>{
    const el=$(id); if(el) el.addEventListener("input", updateModeAlternator);
  });
  updateModeAlternator();

  // Pulse Radiation listeners
  ["pr_Ep","pr_f","pr_R","pr_chi","pr_A","pr_Ar","pr_eps","pr_m","pr_Tspace"].forEach(id=>{
    const el=$(id); if(el) el.addEventListener("input", updatePulseRadiation);
  });
  updatePulseRadiation();

  drawCurve(); drawOrbitView(); updateOrbitTable(); updateAllStatus(); applyScale(); drawCompass();
};
</script>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Warp Control — Triple Columns + Center Panel (v3.6.5 • physics-gated + compass)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#070b12; --panel:#0c1424; --glass:#0d1a31cc; --edge:#27406b;
    --text:#eaf2ff; --muted:#a7b9df; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
    --ui-scale:1; --fs:14px; --pad:8px;
    --gap: clamp(12px, 4vw, 36px);
    --hero-split: 55; /* % for split handle */
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:
      radial-gradient(1200px 800px at 10% -10%, #112240 0%, transparent 60%),
      radial-gradient(900px 900px at 120% -20%, #0b1b33 0%, transparent 50%),
      var(--bg);
    color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;font-size:var(--fs);
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  .viewportScale{transform:scale(var(--ui-scale));transform-origin:top left;width:calc(100%/var(--ui-scale))}
  .wrap{max-width:1400px;margin:0 auto;padding:var(--pad); display:grid; gap:var(--gap)}
  .glass{background:linear-gradient(180deg,#0b1528aa,#0b152880),radial-gradient(600px 200px at 20% -30%,#15305f55,transparent 60%);backdrop-filter:blur(6px)}
  .panel{border:1px solid var(--edge);border-radius:12px;padding:calc(var(--pad) - 1px);box-shadow:0 10px 24px rgba(0,0,0,.42)}
  h1,h2,h3{margin:.35rem 0}
  .grid{display:grid;gap:var(--gap)}

  /* Header */
  .hdrline{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .toggle{display:flex;align-items:center;gap:10px;color:#a7b9df;font-size:.9rem}
  .badge{border:1px solid #3b4f77;border-radius:999px;padding:2px 8px;color:#93c5fd;background:#0b1220}

  /* Triple columns (even spacing) */
  .tripleCols{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr; /* even widths */
    gap: var(--gap);
    align-items:start;
  }
  .col{ display:grid; gap: var(--gap); }

  /* Responsive collapse */
  @media (max-width:1200px){
    .tripleCols{ grid-template-columns: 1fr 1fr; }
    .col-center{ order: 3; }
  }
  @media (max-width:820px){
    .tripleCols{ grid-template-columns: 1fr; }
    .col-left{ order: 1; }
    .col-center{ order: 2; }
    .col-right{ order: 3; }
  }

  /* Form layout */
  .controls label,
  .grid label{display:flex;flex-direction:column;align-items:flex-start;gap:4px;margin:6px 0;color:var(--muted);font-size:.95rem}
  select,input[type="number"],input[type="text"]{width:100%;background:#0b1220;color:#eaf2ff;border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem}
  input[type="range"]{width:100%}

  button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:7px 9px;margin:3px;border-radius:8px;cursor:pointer}
  #startBtn{background:#00ccff;color:#00131a;border:none} #stopBtn{background:#64748b}
  #resetBtn{background:#fb923c;border:none} #exportBtn{background:#7c3aed;border:none}

  .lights{display:flex;gap:8px;flex-wrap:wrap}
  .light{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.85rem}
  .dot{width:9px;height:9px;border-radius:50%}
  .good .dot{background:var(--good)} .warn .dot{background:var(--warn)} .bad .dot{background:var(--bad)}

  .meter{display:flex;align-items:center;gap:8px;margin:4px 0}
  .bar{height:9px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}
  .fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}
  .stat{font-variant-numeric:tabular-nums;font-size:.86rem;color:var(--muted)}

  /* Canvas base */
  canvas{background:linear-gradient(180deg,#091323,#0a1322);border:1px solid #2b3a5a;border-radius:10px;max-width:100%;display:block}
  .pill{display:inline-block;padding:.1rem .4rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}
  .legend{color:var(--muted);font-size:.84rem;margin-top:6px}

  /* Heights (IDs preserved for logic) */
  #curveCanvas{width:100%;height:200px}
  #orbitCanvas{width:100%;height:280px}
  #debrisCanvas{width:100%;height:180px}
  #starfieldCanvas{width:100%;height:160px;background:radial-gradient(160px 105px at 50% 60%, #0a1322 0%, #08101d 65%, #060d18 100%)}
  #shieldCanvas{width:100%;height:160px}
  #grCanvas{width:100%;height:110px}
  /* NEW: Compass size */
  #compassCanvas{width:100%;height:160px}

  /* Center panel split */
  .heroControls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .heroControls button{
    background:#0b1220;border:1px solid #3a4e79;color:#cfe2ff;padding:6px 10px;border-radius:999px;cursor:pointer;font-size:.9rem
  }
  .heroControls button.active{background:#1b2a44;border-color:#5f7bb4}

  .splitHero{ display:grid; min-height: 420px; gap: 6px; }
  .splitHero.vertical{
    grid-template-rows: calc(var(--hero-split)*1%) 10px calc(100% - (var(--hero-split)*1%) - 10px);
  }
  .splitHero.horizontal{
    grid-template-columns: calc(var(--hero-split)*1%) 10px calc(100% - (var(--hero-split)*1%) - 10px);
    min-height: 320px;
  }
  .splitPane{ min-height:120px; }
  .splitHandle{
    border-radius:8px; background:linear-gradient(90deg,#2a3c61,#203253);
    border:1px solid #355180; position:relative; align-self:stretch; justify-self:stretch;
  }
  .splitHero.vertical .splitHandle{ height:10px; cursor:row-resize; }
  .splitHero.horizontal .splitHandle{ width:10px; cursor:col-resize; background:linear-gradient(180deg,#2a3c61,#203253); }
  .splitHero.vertical .splitHandle:after{
    content:""; position:absolute; inset:0; margin:auto; width:60px; height:2px; border-radius:2px; background:#6c8ac0;
  }
  .splitHero.horizontal .splitHandle:after{
    content:""; position:absolute; inset:0; margin:auto; width:2px; height:60px; border-radius:2px; background:#6c8ac0;
  }

  /* Clock Section */
  .clockSection{margin-top:6px}
  .clockHeader{display:flex;align-items:center;justify-content:space-between;margin:2px 0 6px}
  .clockGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap)}
  @media (max-width:1200px){ .clockGrid{grid-template-columns:repeat(3,1fr)} }
  @media (max-width:820px){ .clockGrid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:520px){ .clockGrid{grid-template-columns:1fr} }
  .clockCard{background:#0b1220;border:1px solid #304166;border-radius:12px;padding:8px;display:grid;gap:4px; align-content:start}
  .clockHdr{display:flex;justify-content:space-between;align-items:center}
  .clockTitle{font-weight:600}
  .status{font-size:.78rem;border:1px solid #36507d;border-radius:999px;padding:2px 6px}
  .status.good{color:#0f0;border-color:#256f2a} .status.warn{color:#222;background:#facc15} .status.bad{color:#fff;background:#ef4444}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:.84rem;color:#cfe2ff}
</style>
</head>
<body>
<div class="viewportScale">
  <div class="wrap">
    <!-- Header -->
    <div class="hdrline">
      <h1>🚀 Warp Control Center</h1>
      <div class="toggle">
        <label>UI Scale <input id="uiScale" type="range" min="70" max="140" step="1" value="85"> <span id="uiScaleVal" class="badge">85%</span></label>
        <label>Sound <input id="soundOn" type="checkbox" checked></label>
        <span class="badge">v3.6.5 • Center-Top Compass</span>
      </div>
    </div>

    <!-- THREE COLUMNS -->
    <section class="tripleCols">
      <!-- LEFT COLUMN: Flight Plan + Gravity Engine -->
      <div class="col col-left">
        <div class="panel glass">
          <h2>Flight Plan</h2>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:10px">
            <label>Warp Speed
              <select id="warpSpeed"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option></select>
            </label>
            <label>Destination
              <select id="destination"><option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option></select>
            </label>
            <label>Warp Law (n) <input id="warpExp" type="number" step="0.1" value="3"></label>
            <label>Speed Scale (×c) <input id="warpScale" type="number" step="0.1" value="1"></label>
            <label>IST Day 0 (yrs ago) <input id="istDay0Years" type="number" step="1" value="45500000000"></label>
            <label>Days / IST year <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25"></label>
            <label>Calibration
              <select id="calibration">
                <option value="off">Off</option>
                <option value="mars_opp">Mars – Opposition (fast window)</option>
                <option value="mars_conj">Mars – Conjunction (slow window)</option>
              </select>
            </label>
          </div>
          <div class="lights" style="margin-top:6px">
            <div class="light good" id="lightBubble"><span class="dot"></span>Bubble</div>
            <div class="light good" id="lightPower"><span class="dot"></span>Power</div>
            <div class="light good" id="lightVector"><span class="dot"></span>Vector</div>
            <div class="light good" id="lightNav"><span class="dot"></span>Nav</div>
          </div>
          <div style="margin-top:6px">
            <button id="startBtn">▶️ Start</button>
            <button id="stopBtn">⏸️ Stop</button>
            <button id="resetBtn">🔄 Engage Warp</button>
            <button id="exportBtn">📄 Export Log</button>
          </div>
          <div class="legend" id="beacon">⏳ Waiting…</div>
          <div class="legend" id="constraints">EC/Horizon: —</div>
        </div>

        <div class="panel glass">
          <h2>Gravity Vectoring Engine</h2>
          <div class="controls">
            <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
            <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
            <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
            <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
            <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
            <label>Intake Mode
              <select id="intakeMode">
                <option value="balanced">Balanced (±)</option>
                <option value="positive">Positive Gravity Capture</option>
                <option value="negative">Negative Gravity Capture</option>
              </select>
            </label>
          </div>
          <h3>Power Allocation</h3>
          <div class="meter"><span class="stat" style="width:120px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
          <div class="meter"><span class="stat" style="width:120px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
          <div class="meter"><span class="stat" style="width:120px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>
        </div>
      </div>

      <!-- CENTER COLUMN: Center Hub + Mode Alternator + Split panel -->
      <div class="col col-center">
        <!-- UPDATED CENTER-TOP PANEL WITH COMPASS -->
        <div class="panel glass" id="centerTopPanel">
          <h2>Center Hub</h2>
          <canvas id="compassCanvas"></canvas>
          <div class="legend" id="compassLegend">—</div>
        </div>

        <!-- Mode Alternator -->
        <div class="panel glass" id="modeAltPanel">
          <h2>Mode Alternator — Mirror • Squeeze • Guardrail</h2>
          <div class="grid" style="grid-template-columns:repeat(3,1fr);gap:10px">
            <label>Mirror Suppression S (0–1)
              <input type="range" id="ma_S" min="0" max="1" step="0.01" value="0.20"><span class="stat" id="ma_S_lbl"></span>
            </label>
            <label>Squeeze Depth r (0–1)
              <input type="range" id="ma_r" min="0" max="1" step="0.01" value="0.30"><span class="stat" id="ma_r_lbl"></span>
            </label>
            <label>Cadence (Hz) <input type="number" id="ma_f" value="2" step="0.1"></label>
            <label>Phase φ (ms) <input type="number" id="ma_phi" value="0" step="1"></label>
            <label>Window τ (ms) <input type="number" id="ma_tau" value="60" step="1"></label>
            <label>QI Guardrail <input type="checkbox" id="ma_qi" checked></label>
          </div>
          <div class="legend" id="ma_legend">—</div>
        </div>

        <div class="panel glass" id="heroPanel">
          <h2>Center Visuals (Split)</h2>
          <div class="heroControls">
            <button type="button" class="heroPairBtn active" data-pair="traj-star">Trajectory + Starfield</button>
            <button type="button" class="heroPairBtn" data-pair="traj-shield">Trajectory + Shield</button>
            <button type="button" class="heroPairBtn" data-pair="star-shield">Starfield + Shield</button>
            <span style="flex:1"></span>
            <button type="button" id="splitVertBtn" class="active">Vertical</button>
            <button type="button" id="splitHorzBtn">Horizontal</button>
          </div>

          <div class="splitHero vertical" id="splitHero">
            <div class="splitPane" id="paneTop"><!-- populated by JS --></div>
            <div class="splitHandle" id="splitHandle" title="Drag to resize"></div>
            <div class="splitPane" id="paneBottom"><!-- populated by JS --></div>
          </div>

          <!-- Keep originals to preserve IDs; JS moves these into panes -->
          <div style="display:none">
            <canvas id="curveCanvas"></canvas>
            <div class="legend" id="curveLegend">—</div>
            <canvas id="starfieldCanvas"></canvas>
            <div class="legend" id="starfieldLegend">—</div>
            <canvas id="shieldCanvas"></canvas>
            <div class="legend" id="shieldLegend">—</div>
          </div>
        </div>
      </div>

      <!-- RIGHT COLUMN: Orbit + GR Mini + Pulse Radiation + Debris -->
      <div class="col col-right">
        <div class="panel glass">
          <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
          <canvas id="orbitCanvas"></canvas>
          <div class="legend" id="orbitLegend">—</div>
        </div>

        <div class="panel glass">
          <h2>Einstein Tensor Mini</h2>
          <canvas id="grCanvas"></canvas>
          <div class="legend" id="grMini">G<sub>μν</sub> proxy • ρ<sub>em</sub> from |∇Φ|² (visual) • Auto-throttle if g<sub>tt</sub>≤0</div>
          <div class="legend">g<sub>tt</sub> min: <span id="gr_gtt">—</span> • ρ<sub>em</sub> min/max: <span id="gr_rho">—</span> • EC: <span id="gr_ec">—</span> • Horizons: <span id="gr_hor">—</span></div>
        </div>

        <div class="panel glass" id="pulseRadPanel">
          <h2>Pulse Radiation (Photon Impulse)</h2>
          <div class="grid" style="grid-template-columns:repeat(3,1fr);gap:10px">
            <label>Pulse Energy E<sub>p</sub> (J) <input id="pr_Ep" type="number" value="1000" step="10"></label>
            <label>Rep Rate f<sub>rep</sub> (Hz) <input id="pr_f" type="number" value="1" step="0.1"></label>
            <label>Reflectivity R (0–1) <input id="pr_R" type="number" value="0.9" step="0.01"></label>
            <label>Capture χ (0–1) <input id="pr_chi" type="number" value="0.9" step="0.01"></label>
            <label>Aperture Area A (m²) <input id="pr_A" type="number" value="1" step="0.1"></label>
            <label>Radiator Area A<sub>r</sub> (m²) <input id="pr_Ar" type="number" value="10" step="0.1"></label>
            <label>Emissivity ε (0–1) <input id="pr_eps" type="number" value="0.8" step="0.01"></label>
            <label>Ship Mass m (kg) <input id="pr_m" type="number" value="50000" step="100"></label>
            <label>Space T (K) <input id="pr_Tspace" type="number" value="3" step="1"></label>
          </div>
          <div class="legend" id="pr_legend">—</div>
        </div>

        <div class="panel glass">
          <h2>Debris Defense Field</h2>
          <canvas id="debrisCanvas"></canvas>
          <div class="legend" id="debrisLegend">—</div>
        </div>
      </div>
    </section>

    <!-- Full-width rows -->
    <section>
      <div class="panel glass">
        <h2>IST Orbital Tracker (Live)</h2>
        <div id="orbit-rows" class="grid" style="grid-template-columns:repeat(4,1fr);gap:var(--gap)"></div>
      </div>
    </section>

    <section class="clockSection">
      <div class="panel glass">
        <div class="clockHeader">
          <h2>Clock Sync (C1–C5) + Arrival CST/IST</h2>
          <span class="badge">Compact view</span>
        </div>
        <div class="clockGrid" id="clockGrid"></div>
      </div>
    </section>
  </div>
</div>

<!-- ==== Paste PART 1 <script> here ==== -->
<!-- ==== Paste PART 2 <script> here ==== -->

</body>
</html>
