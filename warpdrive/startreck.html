<script>
/* ========= LIVE MODE: engine always on =========
   - Panels update immediately on load.
   - Simulation runs continuously; Start/Stop buttons ramp speed.
   - Buttons/sliders change parameters in real time.
=================================================*/

/* ====== Constants / helpers ====== */
const AU_M=1.495978707e11, C_MPS=299792458, MU0=4*Math.PI*1e-7;
const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
const $=id=>document.getElementById(id);
let ac=null;
function tone(kind="good"){
  if(!$("soundOn")||!$("soundOn").checked) return;
  if(!ac){try{ac=new (window.AudioContext||window.webkitAudioContext)();}catch{}}
  if(!ac) return;
  const o=ac.createOscillator(), g=ac.createGain();
  o.type="sine"; o.frequency.value= kind==="good"?880:kind==="warn"?520:320;
  g.gain.value=.001; o.connect(g).connect(ac.destination); o.start();
  g.gain.exponentialRampToValueAtTime(.07, ac.currentTime+.02);
  g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+.18);
  o.stop(ac.currentTime+.2);
}
function setLight(el,level){
  if(!el) return;
  const was=el.dataset.level||"good";
  if(was!==level){
    el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level);
    tone(level==="good"?"good":level==="warn"?"warn":"bad");
  }
}

/* ====== IST time, orbits ====== */
let tIST0=performance.now();
function IST_INPUT(){ return Number(($("istDay0Years")?.value)||45500000000); }
function DPY_INPUT(){ return Number(($("baselineDaysPerYear")?.value)||365.25); }
function IST_snapshot(){
  const dpy=DPY_INPUT(), spy=dpy*86400;
  const elapsed=(performance.now()-tIST0)/1000/spy;
  const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy;
  return {istYears, istDays, dpy, spy};
}
function planetAgeYears(name,iy){ return Math.max(0, iy - (formationOffsetMyr[name]||0)*1e6); }
function trueAnomalyFrac(name,iy,dpy){
  const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name];
  if(!T) return 0; const N=pd/T; return N-Math.floor(N);
}
function orbitsFor(name,pd){
  const T=orbitalDays[name]; if(!T) return null;
  const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T;
  return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T};
}

/* ====== Engine dynamics & inputs (LIVE) ====== */
let shipProgress=0, shipArrived=false;
let animationFrame=null, lastFrameTime=performance.now();
const engineState={ t:0, temp:0.25, sag:0.03, containNeed:0.22, jitter:0.01 };

function stepEngineDynamics(dt){
  engineState.t+=dt;
  engineState.temp=Math.max(0,Math.min(1,engineState.temp+0.03*dt + 0.01*(Math.random()-0.5)));
  const baseSag=0.02+0.04*engineState.temp, ripple=0.006*Math.sin(0.9*engineState.t);
  engineState.sag=Math.max(0, baseSag + ripple + 0.004*(Math.random()-0.5));
  engineState.containNeed=0.22+0.06*engineState.temp;
  const lr=(Number($("lrBias")?.value)||0)/100, ud=(Number($("udBias")?.value)||0)/100;
  const biasMag=Math.hypot(lr,ud);
  engineState.jitter = 0.01 + 0.02*biasMag + 0.008*Math.sin(3*engineState.t) + 0.006*(Math.random()-0.5);
  engineState.jitter = Math.max(0, Math.min(0.08, engineState.jitter));
}

function warpInputs(){
  const w=Number(($("warpSpeed")?.value)||1), n=Number(($("warpExp")?.value)||3), s=Number(($("warpScale")?.value)||1);
  return { warp:w, exp:n, scale:s };
}
function engineInputs(){
  const reactorMW_in=Number(($("reactorMW")?.value)||5000);
  const front=Number(($("frontPct")?.value)||35)/100, rear=Number(($("rearPct")?.value)||65)/100;
  const lr=Number(($("lrBias")?.value)||0)/100, ud=Number(($("udBias")?.value)||0)/100;
  const mode=($("intakeMode")?.value)||"balanced";
  const reactorMW = reactorMW_in * (1 - engineState.sag);

  const vecDemand=Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  let coilsPct=Math.max(0.35, 0.55 - 0.25*vecDemand);
  let containPct=Math.max(engineState.containNeed, 0.20);
  let vanesPct=Math.min(0.35, 1 - coilsPct - containPct);
  const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; }

  if($("mCoils")){ $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`; }
  if($("mVanes")){ $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`; }
  if($("mContain")){ $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`; }

  let stability=1.0;
  if (containPct < engineState.containNeed) stability -= 0.40*(engineState.containNeed - containPct)/engineState.containNeed;
  const biasMag=Math.hypot(lr,ud); stability -= 0.30*Math.max(0, biasMag-0.3)/0.7;
  if (rear<front) stability -= 0.20*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability -= engineState.jitter;
  stability = Math.max(0, Math.min(1, stability));

  return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, stability, mode};
}

/* ====== Physics gating ====== */
let lastPhysics = { gf:0.5, vcap_c:0.6, gttMin:1, ecOK:true, horizon:false, beta:0 };
let calib="off";
const physicsCal = { kGF:1.00, kCap:1.00 };
function setCalibration(kind){
  calib=kind;
  switch(kind){
    case "mars_opp": physicsCal.kGF=1.12; physicsCal.kCap=1.10; break;
    case "mars_conj": physicsCal.kGF=0.92; physicsCal.kCap=0.88; break;
    default: physicsCal.kGF=1.00; physicsCal.kCap=1.00; break;
  }
}

/* ====== GR Mini + ∫|∇Φ|² (for gating) ====== */
const grCanvas = $("grCanvas"), grx = grCanvas?.getContext("2d");
const GR = { nx: 120, ny: 48, L: 900, sigma: 150, scalePhi: 1.0e10 };
function buildPotentialGrid(){
  const eng=engineInputs(); const {front,rear,lr,ud}=eng;
  const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma;
  const A_r = rear*1.2e14, A_f = front*1.2e14;
  const x0 = 180 + 110*rear, y0 =  70*ud, xskew = 70*lr;
  const phi = new Float64Array(nx*ny);
  for(let j=0;j<ny;j++){
    const y=(j-ny/2)*dy;
    for(let i=0;i<nx;i++){
      const x=(i-nx/2)*dx;
      const rRear2=(x + x0 + xskew)**2 + (y - y0)**2;
      const rFront2=(x - x0 + xskew)**2 + (y + y0)**2;
      phi[i+j*nx] = (-A_r*Math.exp(-rRear2/s2) + A_f*Math.exp(-rFront2/s2))/GR.scalePhi;
    }
  }
  return {phi, dx, dy, nx, ny};
}
function grad2(phi,i,j,nx,ny,dx,dy){
  const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx];
  const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx];
  const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy};
}
function validateGR(){
  const {phi, dx, dy, nx, ny} = buildPotentialGrid();
  let gttMin=+1, phiMin=+1e99, phiMax=-1e99, Eint=0;
  for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; }
  const span=Math.max(1e-12, phiMax-phiMin);
  if(grCanvas){ grCanvas.width=grCanvas.clientWidth; grCanvas.height=110; grx.clearRect(0,0,grCanvas.width,grCanvas.height); }
  let rhoMin=+1e99, rhoMax=-1e99, horizons=0;

  for(let j=1;j<ny-1;j++){
    for(let i=1;i<nx-1;i++){
      const {g2} = grad2(phi,i,j,nx,ny,dx,dy);
      Eint += g2 * dx * dy;
      const ph=phi[i+j*nx];
      const gtt=1 + 2*ph/(C_MPS*C_MPS); if(gtt<gttMin)gttMin=gtt; if(gtt<=0)horizons++;

      if(grCanvas && j===Math.floor(ny/2)){
        const x=Math.floor((i/nx)*grCanvas.width), t=(ph - phiMin)/span;
        const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t));
        grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,110);
      }
    }
  }
  if($("gr_gtt")) $("gr_gtt").textContent = gttMin.toFixed(6);
  if($("gr_rho")) $("gr_rho").textContent = `— / —`; // compact
  if($("gr_ec"))  $("gr_ec").textContent  = `✅ NEC • ✅ WEC • ✅ SEC`;
  if($("gr_hor")) $("gr_hor").textContent = horizons>0 ? `⚠ ${horizons}` : "None";
  return { Eint, gttMin };
}

/* ====== Speed gating & ETA ====== */
let lastPhysics={ gf:0.5, vcap_c:0.6, gttMin:1, ecOK:true, horizon:false, beta:0 };
function gatedSpeed(v_base, eng){
  const { Eint, gttMin } = validateGR();
  const Escaled = Math.log10(1 + Math.max(0, Eint)/1e6);
  const gf_raw = 1/(1+Math.exp(-(Escaled-2.0)));
  let gf = Math.max(0.05, Math.min(1.0, gf_raw * physicsCal.kGF));
  const pMW = Math.max(0, eng.reactorMW);
  let vcap_c = Math.min(0.99, physicsCal.kCap * (0.10 + 0.45*(1 - Math.exp(-pMW/6000)) + 0.25*gf) * Math.max(0.35, eng.stability));

  if (gttMin <= 0.01){ vcap_c = Math.min(vcap_c, 0.15); setLight($("lightBubble"),"bad"); }
  else if (gttMin < 0.05){ vcap_c = Math.min(vcap_c, 0.35); setLight($("lightBubble"),"warn"); }
  else setLight($("lightBubble"),"good");

  const v_limited = Math.min(v_base * gf, vcap_c * C_MPS);
  const beta = Math.max(0, Math.min(0.99, v_limited / C_MPS));
  if($("constraints")) $("constraints").textContent = `EC/Horizon: g_tt min ${gttMin.toFixed(5)} • gf ${gf.toFixed(2)} • cap ${(vcap_c).toFixed(2)} c`;
  return { v_mps: v_limited, gf, vcap_c, gttMin, ecOK:true, horizon:(gttMin<=0), beta };
}
function computeETASeconds(v_mps_override=null){
  const { istYears, dpy } = IST_snapshot();
  const dest=($("destination")?.value)||"Mars";
  const { warp, exp, scale } = warpInputs();
  const eng=engineInputs();

  const r1=orbitAU.Earth, r2=orbitAU[dest];
  const thE0=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD0=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;

  const TE = orbitalDays.Earth * 86400;
  const TD = orbitalDays[dest] * 86400;
  const wE = TE ? (2*Math.PI/TE) : 0;
  const wD = TD ? (2*Math.PI/TD) : 0;

  const v_base = C_MPS * scale * Math.pow(Math.max(1, warp), exp);
  const { v_mps, gf, vcap_c, gttMin, ecOK, horizon, beta } = gatedSpeed(v_base, eng);
  lastPhysics = { gf, vcap_c, gttMin, ecOK, horizon, beta };

  const v = v_mps_override ?? v_mps;

  let t=0; const maxIter=8;
  for(let k=0;k<maxIter;k++){
    const thE=thE0 + wE*t, thD=thD0 + wD*t;
    const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD-thE));
    const tNew=(dAU*AU_M)/Math.max(v,1e-3);
    if(Math.abs(tNew-t)<0.05){ t=tNew; break; }
    t=tNew;
  }
  const dAU0=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD0-thE0));
  setLight($("lightNav"), isFinite(t)?(t<86400?"good":"warn"):"bad");
  return { eta:t, dAU:dAU0, v, thE:thE0, thD:thD0, r1, r2 };
}

/* ====== Warp ramp controller (Start/Engage/Stop) ====== */
const warpRamp = { active:false, target:1, rate:0.8 };
function setWarpTarget(target, rate=0.8){
  warpRamp.active=true; warpRamp.target=Math.max(1, Number(target)||1); warpRamp.rate=rate;
}
function tickWarpRamp(dt){
  if(!warpRamp.active || !$("warpSpeed")) return;
  const current = Number($("warpSpeed").value||1);
  const dir = Math.sign(warpRamp.target - current);
  if(dir===0){ warpRamp.active=false; return; }
  const next = current + dir*warpRamp.rate*dt;
  const done = (dir>0? next>=warpRamp.target : next<=warpRamp.target);
  $("warpSpeed").value = String(done? warpRamp.target : next.toFixed(2));
}

/* ====== Global (used later by visuals & compass) ====== */
let compassDOMReady=false;
</script>
<script>
/* ====== Polar Map ====== */
const orbitCanvas=$("orbitCanvas"), octx=orbitCanvas?.getContext("2d");
function drawOrbitView(){
  if(!orbitCanvas) return;
  const dest=($("destination")?.value)||"Mars";
  const {eta, thE, thD, r1, r2}=computeETASeconds();
  const w=orbitCanvas.width=orbitCanvas.clientWidth, h=orbitCanvas.height=orbitCanvas.clientHeight, cx=w/2, cy=h/2, minDim=Math.min(w,h);

  const maxR = Math.max(r1, r2);
  const RmaxPx = Math.max(120, minDim*0.38);
  const scale = RmaxPx / Math.max(maxR, 0.01);

  octx.clearRect(0,0,w,h);
  octx.beginPath(); octx.arc(cx,cy,7,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.fill();
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun",cx-14,cy-12);

  const rE=r1*scale, rD=r2*scale;
  octx.beginPath(); octx.arc(cx,cy,rE,0,Math.PI*2); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();
  octx.beginPath(); octx.arc(cx,cy,rD,0,Math.PI*2); octx.strokeStyle="#ffffff"; octx.lineWidth=1.1; octx.stroke();

  const Ex=cx+rE*Math.cos(thE), Ey=cy+rE*Math.sin(thE);
  const Dx=cx+rD*Math.cos(thD), Dy=cy+rD*Math.sin(thD);
  octx.beginPath(); octx.arc(Ex,Ey,3.5,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.fill();
  octx.beginPath(); octx.arc(Dx,Dy,3.5,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.fill();

  const Td=orbitalDays[dest]*86400, dTh=(eta/Td)*Math.PI*2;
  const thArr=(thD+dTh)%(Math.PI*2);
  const Ax=cx+rD*Math.cos(thArr), Ay=cy+rD*Math.sin(thArr);
  octx.beginPath(); octx.arc(Ax,Ay,4.5,0,Math.PI*2); octx.fillStyle="#16a34a"; octx.fill();

  const degNow=(thD*180/Math.PI+360)%360, degArr=(thArr*180/Math.PI+360)%360; 
  let d=degArr-degNow; if(d<0)d+=360;
  if($("orbitLegend")) $("orbitLegend").textContent=`Now ${degNow.toFixed(1)}° → ETA ${degArr.toFixed(1)}° • Δ ${d.toFixed(1)}°`;
}

/* ====== Trajectory Curve & vectors ====== */
const curveCanvas=$("curveCanvas"), ctx=curveCanvas?.getContext("2d");
function drawCurve(){
  if(!curveCanvas) return;
  const w=curveCanvas.width=curveCanvas.clientWidth, h=curveCanvas.height=curveCanvas.clientHeight;
  const dest=($("destination")?.value)||"Mars";
  const arcHeight=Math.max(32, 60/Math.max(1, 1*(lastPhysics?.gf||0.5)));
  const startX=60, endX=w-60, baseY=h-46;

  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(startX,baseY,7,0,Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-20, baseY+18);
  ctx.beginPath(); ctx.arc(endX,baseY,6.5,0,Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(dest, endX-22, baseY+18);

  ctx.beginPath(); ctx.moveTo(startX,baseY);
  ctx.quadraticCurveTo((startX+endX)/2, baseY-arcHeight*3, endX, baseY);
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  const t=shipProgress, mx=(startX+endX)/2, ctrlY=baseY-arcHeight*3;
  const sx=(1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy=(1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;
  ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowColor=ctx.fillStyle; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;

  const arrow=(x,y,dx,dy,color)=>{ const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const ex=x+dx, ey=y+dy;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-6*ux+3*uy,ey-6*uy-3*ux); ctx.lineTo(ex-6*ux-3*uy,ey-6*uy+3*ux); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); };
  const f=(Number($("frontPct")?.value)||35)/100, r=(Number($("rearPct")?.value)||65)/100, lr=(Number($("lrBias")?.value)||0)/100, ud=(Number($("udBias")?.value)||0)/100; const k=Math.min(44, h*0.18);
  arrow(sx,sy, 0,-k*r,"#22c55e"); // rear expansion (up)
  arrow(sx,sy, 0, k*f,"#f97316"); // front contraction (down)
  arrow(sx,sy, k*lr,0,"#8b5cf6"); // left/right
  arrow(sx,sy, 0,-k*ud,"#38bdf8"); // up/down

  if($("curveLegend")) $("curveLegend").textContent=`Rear ${Math.round(r*100)}% • Front ${Math.round(f*100)}% • LR ${Math.round(lr*100)}% • UD ${Math.round(ud*100)}% • β ${(lastPhysics?.beta||0).toFixed(2)}`;
}

/* ====== Clocks ====== */
const clocks=[
  { id:"C1", location:"Biometric", purpose:"Crew/Local", drift:0 },
  { id:"C2", location:"Warp Edge", purpose:"Phase Monitor", drift:3 },
  { id:"C3", location:"NavCore",   purpose:"Navigation", drift:0 },
  { id:"C4", location:"CST Earth", purpose:"Master Anchor", drift:0 },
  { id:"C5", location:"DriftEye",  purpose:"Diagnostics", drift:-6 }
];
function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function renderClockCards(arrISTstr, arrCSTms){
  const grid=$("clockGrid"); if(!grid) return 0;
  grid.innerHTML="";
  const base=Date.now(); let total=0;
  clocks.forEach(c=>{
    c.drift += Math.random()*2 - 1;
    const local=base + c.drift; const d=c.drift.toFixed(2); total += Math.abs(c.drift);
    let status="good", label="✅ Synced"; if(Math.abs(c.drift)>5){status="warn"; label="⚠ Drift";} if(Math.abs(c.drift)>10){status="bad"; label="❌ Unsafe";}
    const card=document.createElement("div");
    card.className="clockCard";
    card.innerHTML=`
      <div class="clockHdr">
        <div class="clockTitle">${c.id} • ${c.location}</div>
        <div class="status ${status}">${label}</div>
      </div>
      <div class="kv">
        <div>Purpose</div><div>${c.purpose}</div>
        <div>CST</div><div>${fmtClock(base)}</div>
        <div>Local</div><div>${fmtClock(local)}</div>
        <div>Δ</div><div>${d} ms</div>
        <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
        <div>Arrival IST</div><div>${arrISTstr}</div>
      </div>`;
    grid.appendChild(card);
  });
  return total/clocks.length;
}

/* ====== Starfield ====== */
(function(){
  const cvs=$("starfieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const STAR_COUNT=180; const stars=new Array(STAR_COUNT).fill(0).map(()=>({x:(Math.random()*2-1)*W(), y:(Math.random()*2-1)*H(), z:Math.random(), tw:Math.random()*Math.PI*2}));
  let raf=null, last=performance.now();

  function recycle(s){ s.x=(Math.random()*2-1)*W(); s.y=-0.55*H(); s.z=Math.random(); s.tw=Math.random()*Math.PI*2; }
  function dopplerShift(base){
    const beta = Math.max(0, Math.min(0.99, lastPhysics?.beta||0));
    const z = Math.sqrt((1+beta)/(1-beta));
    const r = Math.max(0, Math.min(255, 200 / z));
    const g = Math.max(0, Math.min(255, 220 / Math.sqrt(z)));
    const b = Math.max(0, Math.min(255, 255));
    const a = 0.22 + 0.5*base; return {r,g,b,a};
  }
  function step(dt){
    const flow=26*(1+1.2*(lastPhysics?.beta||0));
    for(const s of stars){
      const v=flow*(1.4-0.9*s.z);
      s.y+=1*v*dt; s.tw+=3.0*dt;
      if(s.y>0.60*H()) recycle(s);
    }
  }
  function draw(){
    ctx.clearRect(0,0,W(),H());
    const beta = lastPhysics?.beta||0, streak=1+(beta*1.8);
    const cx=CX(), cy=CY();
    ctx.save(); ctx.translate(cx,cy);
    for(const s of stars){
      const sz=1+1.5*(1-s.z), a=0.35+0.55*Math.abs(Math.sin(s.tw));
      const col=dopplerShift(a);
      ctx.fillStyle=`rgba(${col.r|0},${col.g|0},${col.b|0},${col.a.toFixed(2)})`;
      ctx.fillRect(s.x,s.y,sz,sz);
      ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(s.x, s.y - streak*7*(1-s.z));
      ctx.strokeStyle=`rgba(${(col.r+30|0)},${(col.g+30|0)},${(col.b+30|0)},${(0.18+0.35*(1-s.z)).toFixed(2)})`;
      ctx.lineWidth=1; ctx.stroke();
    }
    ctx.restore();
    const g=ctx.createRadialGradient(cx,cy,32, cx,cy,52); g.addColorStop(0,"rgba(120,220,255,0.16)"); g.addColorStop(1,"rgba(80,180,255,0.03)");
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,52,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,40,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.2; ctx.stroke();
    ctx.save(); ctx.translate(cx,cy+3); ctx.beginPath(); ctx.moveTo(0,-16*0.9); ctx.lineTo(11*0.55,16*0.8); ctx.lineTo(-11*0.55,16*0.8); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill(); ctx.restore();
    if($("starfieldLegend")) $("starfieldLegend").textContent=`Visual β=${beta.toFixed(2)} • gf=${(lastPhysics?.gf||0).toFixed(2)} • cap=${(lastPhysics?.vcap_c||0).toFixed(2)}c`;
  }
  function loop(n){ const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  raf=requestAnimationFrame(loop);
})();

/* ====== Debris + Shield integration ====== */
(function(){
  const cvs=$("debrisCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  let last=performance.now(), raf=null;
  const bubble={ r:46 }; const debris=[]; const MAX_DEBRIS=24;

  function seed(){
    debris.length=0;
    for(let i=0;i<MAX_DEBRIS;i++){
      const ang=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
      debris.push({
        x:CX()+R*Math.cos(ang), y:CY()+R*Math.sin(ang),
        vx:-(38+Math.random()*55)*Math.cos(ang),
        vy:-(38+Math.random()*55)*Math.sin(ang),
        q:(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7),
        alive:true
      });
    }
  }
  seed();

  function alloc(){
    const e=engineInputs(); const tot=e.reactorMW||5000; const g=lastPhysics?.gf||0.5;
    let pre=Math.min(.50,.25+.08*g), skin=Math.min(.35,.20+.10*g), grid=Math.max(.10,1-pre-skin);
    return { MW:{pre:pre*tot, skin:skin*tot, grid:grid*tot}, frac:{pre,skin,grid} };
  }

  function step(dt){
    const {MW,frac}=alloc();
    const preF=6*Math.sqrt(MW.pre+1), skinB=4*Math.sqrt(MW.skin+1);
    for(const d of debris){
      if(!d.alive) continue;
      const dx=d.x-CX(), dy=d.y-CY(), r=Math.hypot(dx,dy)+1e-6, nx=dx/r, ny=dy/r;
      if(ny<-0.2){ d.vx+=nx*preF*dt*0.08; d.vy+=ny*preF*dt*0.08; }
      if(r<bubble.r*1.5 && Math.abs(d.q)>0){ const kick=skinB*0.12*dt, tx=-ny, ty=nx; d.vx+=tx*kick*Math.sign(d.q); d.vy+=ty*kick*Math.sign(d.q); }
      if(r<bubble.r*1.06){
        const hitProb=Math.min(0.95,0.25+frac.grid*0.8);
        const ang=Math.atan2(dy,dx);
        if(window.shieldBox && window.shieldBox.hit){ const intensity=Math.min(1, (Math.hypot(d.vx,d.vy)/110)); window.shieldBox.hit(ang,intensity); }
        if(Math.random()<hitProb) d.alive=false;
      }
      d.x+=d.vx*dt; d.y+=d.vy*dt;
      if(!d.alive || d.x<-180 || d.x>W()+180 || d.y<-180 || d.y>H()+180){
        if(Math.random()<0.02){
          const a=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
          d.x=CX()+R*Math.cos(a); d.y=CY()+R*Math.sin(a); d.vx=-(38+Math.random()*55)*Math.cos(a); d.vy=-(38+Math.random()*55)*Math.sin(a);
          d.q=(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7); d.alive=true;
        }
      }
    }
    const ahead=debris.filter(d=>d.alive && d.y<CY()-bubble.r*1.4 && Math.abs(d.x-CX())<bubble.r*1.1);
    const hold=ahead.length>6, adjust=!hold && ahead.length>3;
    let msg=`Defense MW — Pre:${MW.pre.toFixed(0)} | Skin:${MW.skin.toFixed(0)} | Grid:${MW.grid.toFixed(0)} `;
    msg += hold? "• HOLD":"• "+(adjust?"ADJUST":"CLEAR");
    if($("debrisLegend")) $("debrisLegend").textContent=msg;
    if(hold) setLight($("lightNav"),"warn");
  }

  function draw(){
    const cx=CX(), cy=CY();
    ctx.clearRect(0,0,W(),H());
    ctx.beginPath(); ctx.arc(cx,cy,bubble.r,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.3; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy, bubble.r*2.2, -Math.PI*0.95, -Math.PI*0.05, false); ctx.closePath();
    ctx.fillStyle="rgba(252,211,77,.15)"; ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,bubble.r*1.15,0,Math.PI*2); ctx.strokeStyle="rgba(56,189,248,.18)"; ctx.lineWidth=8; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,3.3,0,Math.PI*2); ctx.fillStyle="#cfe2ff"; ctx.fill();
    for(const d of debris){ if(d.alive){ ctx.fillStyle=Math.abs(d.q)>0?"#fca5a5":"#e5e7eb"; ctx.beginPath(); ctx.arc(d.x,d.y,1.6,0,Math.PI*2); ctx.fill(); } }
  }

  function loop(n){ const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  raf=requestAnimationFrame(loop);
})();

/* ====== Shield Box ====== */
(function(){
  const cvs=$("shieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const SECT=12; const sectors=new Array(SECT).fill(1); let flashes=[];
  let raf=null, last=performance.now();

  function warpScale(){ return 0.82 + 0.05*Math.max(1, Number(($("warpSpeed")?.value)||1)); }
  function bubbleRadius(){ return 36*Math.min(1.3, warpScale()); }
  function repair(dt){ for(let i=0;i<SECT;i++){ sectors[i]=Math.min(1, sectors[i]+0.08*dt); } flashes=flashes.filter(f=>{ f.t-=dt; return f.t>0; }); }

  function draw(){
    const cx=CX(), cy=CY(), R=bubbleRadius(); cvs.width=W(); cvs.height=H();
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const glow=ctx.createRadialGradient(cx,cy,R*.6, cx,cy,R+12);
    glow.addColorStop(0,`rgba(120,220,255,${0.1+0.12*sectors.reduce((a,b)=>a+b,0)/SECT})`);
    glow.addColorStop(1,"rgba(80,180,255,0.02)");
    ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(cx,cy,R+12,0,Math.PI*2); ctx.fill();

    for(let i=0;i<SECT;i++){
      const t0=(i/SECT)*Math.PI*2, t1=((i+1)/SECT)*Math.PI*2, s=sectors[i];
      ctx.beginPath(); ctx.arc(cx,cy,R, t0,t1);
      ctx.strokeStyle=s>0.66?"#7dd3fc":s>0.33?"#facc15":"#ef4444";
      ctx.lineWidth=2.2+2.2*s; ctx.stroke();
    }

    ctx.beginPath(); ctx.moveTo(cx, cy-R*0.65); ctx.lineTo(cx+9, cy+10); ctx.lineTo(cx-9, cy+10); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill();

    for(const f of flashes){
      const a=Math.max(0,Math.min(1,f.t/.25));
      ctx.beginPath(); ctx.arc(f.x,f.y, 5+9*(1-a), 0,Math.PI*2);
      ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.8; ctx.stroke();
    }
    if($("shieldLegend")) $("shieldLegend").textContent=`Shield ${(sectors.reduce((a,b)=>a+b,0)/SECT*100).toFixed(0)}% • R ${R.toFixed(1)} • β ${(lastPhysics?.beta||0).toFixed(2)}`;
  }

  function loop(n){ const dt=Math.min(0.05,(n-last)/1000); last=n; repair(dt); draw(); raf=requestAnimationFrame(loop); }
  function hit(theta,intensity){
    const rot=theta+Math.PI/2;
    let idx=Math.floor((((rot%(2*Math.PI))+2*Math.PI)%(2*Math.PI))/(2*Math.PI)*SECT);
    idx=Math.max(0,Math.min(SECT-1,idx));
    sectors[idx]=Math.max(0,sectors[idx]-0.35*Math.max(0.2,intensity));
    const R=bubbleRadius();
    flashes.push({x:CX()+R*Math.cos(theta), y:CY()+R*Math.sin(theta), t:.25});
  }
  window.shieldBox={ hit };
  raf=requestAnimationFrame(loop);
})();

/* ====== LIVE Compass (Center Hub) ====== */
let comp, compx;
function ensureCompass(){
  if(compassDOMReady) return;
  const hub=$("centerTopPanel");
  if(!hub) return;
  const wrap=document.createElement("div");
  wrap.style="margin-top:6px;display:grid;grid-template-columns:1fr;gap:6px";
  const canvas=document.createElement("canvas");
  canvas.id="compassCanvas"; canvas.style.width="100%"; canvas.style.height="140px";
  const legend=document.createElement("div");
  legend.className="legend"; legend.id="compassLegend"; legend.textContent="—";
  wrap.appendChild(canvas); wrap.appendChild(legend);
  hub.appendChild(wrap);
  comp=canvas; compx=comp.getContext("2d");
  compassDOMReady=true;
}
function drawCompass(){
  ensureCompass(); if(!comp||!compx) return;
  comp.width=comp.clientWidth; comp.height=comp.clientHeight;
  const w=comp.width, h=comp.height, cx=w/2, cy=h/2, R=Math.min(w,h)*0.38;
  compx.clearRect(0,0,w,h);

  // Heading = current Earth→Dest angle, with bias jitter visualization
  const { istYears, dpy } = IST_snapshot();
  const dest=($("destination")?.value)||"Mars";
  const thE=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;
  let heading = (thD - thE); // radians
  heading = ((heading % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);

  const eng=engineInputs();
  const biasYaw = eng.lr * 0.6; // small offset (rad)
  const jitter = engineState.jitter * (Math.random()-0.5);
  const hdg = heading + biasYaw + jitter;

  // Rose
  compx.beginPath(); compx.arc(cx,cy,R,0,Math.PI*2); compx.strokeStyle="#355180"; compx.lineWidth=1.2; compx.stroke();
  for(let i=0;i<16;i++){
    const a=(i/16)*Math.PI*2; const r0=R-8, r1=R;
    compx.beginPath(); compx.moveTo(cx+r0*Math.cos(a), cy+r0*Math.sin(a));
    compx.lineTo(cx+r1*Math.cos(a), cy+r1*Math.sin(a));
    compx.strokeStyle=i%4===0?"#7dd3fc":"#3a4e79"; compx.lineWidth=i%4===0?2:1; compx.stroke();
  }
  // Cardinal labels
  compx.fillStyle="#cfe2ff"; compx.font="12px system-ui";
  compx.fillText("N", cx-4, cy-R-6);
  compx.fillText("S", cx-4, cy+R+14);
  compx.fillText("E", cx+R+6, cy+4);
  compx.fillText("W", cx-R-14, cy+4);

  // Ship pointer (triangle) pointing at hdg
  const tipX=cx+R*0.9*Math.cos(hdg), tipY=cy+R*0.9*Math.sin(hdg);
  const leftX=cx+R*0.55*Math.cos(hdg+2.6), leftY=cy+R*0.55*Math.sin(hdg+2.6);
  const rightX=cx+R*0.55*Math.cos(hdg-2.6), rightY=cy+R*0.55*Math.sin(hdg-2.6);
  compx.beginPath(); compx.moveTo(tipX,tipY); compx.lineTo(leftX,leftY); compx.lineTo(rightX,rightY); compx.closePath();
  compx.fillStyle="#cfe2ff"; compx.fill();

  // Center donut showing beta and stability
  const beta=lastPhysics?.beta||0, stab=eng.stability;
  compx.beginPath(); compx.arc(cx,cy, R*0.30, 0, Math.PI*2);
  compx.strokeStyle="rgba(125,211,252,0.4)"; compx.lineWidth=10*beta+1.2; compx.stroke();

  // Drift arrows for LR bias
  const driftLen = R*0.25*Math.min(1, Math.abs(eng.lr)*1.5);
  compx.beginPath(); compx.moveTo(cx-driftLen, cy); compx.lineTo(cx+driftLen, cy);
  compx.strokeStyle= stab>0.6 ? "#22d3ee" : "#facc15"; compx.lineWidth=2; compx.stroke();

  const deg=((hdg*180/Math.PI)+360)%360;
  if($("compassLegend")){
    $("compassLegend").innerHTML = `Course to ${dest}: <span class="pill">${deg.toFixed(1)}°</span> • β ${(beta).toFixed(2)} • Stability ${stab.toFixed(2)}`;
  }
}
</script>
<script>
/* ====== Status / lifecycle (AUTO-LIVE) ====== */
const flightLog=[];
function updateAllStatus(){
  const {eta,dAU,v}=computeETASeconds();
  const base=Date.now(), arrCST=base+eta*1000;
  const {istYears,spy}=IST_snapshot();
  const arrIST=istYears + eta/spy;
  const arrISTstr=`${(arrIST/1e9).toFixed(6)} Ga • ${Math.floor(arrIST).toLocaleString()} y`;
  const avg=renderClockCards(arrISTstr, arrCST);
  const warp=Number(($("warpSpeed")?.value)||1), dest=($("destination")?.value)||"Mars";
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
  if($("beacon")) $("beacon").textContent=`🛰️ Warp ${warp} → ${dest} | ${dAU.toFixed(3)} AU | ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Drift ${avg.toFixed(2)} ms`;
  flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});
}

/* ====== Split Hero pairing/orientation ====== */
function moveEl(el, target){ if(el && target){ target.appendChild(el); } }
function setPair(pair){
  const paneTop=$("paneTop"), paneBottom=$("paneBottom");
  if(!paneTop||!paneBottom) return;
  paneTop.innerHTML=""; paneBottom.innerHTML="";
  const curve=$("curveCanvas"), curveL=$("curveLegend");
  const star=$("starfieldCanvas"), starL=$("starfieldLegend");
  const shield=$("shieldCanvas"), shieldL=$("shieldLegend");
  if(pair==="traj-star"){
    moveEl(curve, paneTop); moveEl(curveL, paneTop);
    moveEl(star, paneBottom); moveEl(starL, paneBottom);
  }else if(pair==="traj-shield"){
    moveEl(curve, paneTop); moveEl(curveL, paneTop);
    moveEl(shield, paneBottom); moveEl(shieldL, paneBottom);
  }else{
    moveEl(star, paneTop); moveEl(starL, paneTop);
    moveEl(shield, paneBottom); moveEl(shieldL, paneBottom);
  }
  requestAnimationFrame(()=>{ window.dispatchEvent(new Event('resize')); drawCurve(); });
}
function setOrientation(mode){
  const splitHero = $("splitHero"), splitVertBtn=$("splitVertBtn"), splitHorzBtn=$("splitHorzBtn");
  if(!splitHero) return;
  splitHero.classList.remove('vertical','horizontal');
  splitHero.classList.add(mode);
  if(splitVertBtn) splitVertBtn.classList.toggle('active', mode==='vertical');
  if(splitHorzBtn) splitHorzBtn.classList.toggle('active', mode==='horizontal');
  requestAnimationFrame(()=>window.dispatchEvent(new Event('resize')));
}
(function initSplitUI(){
  document.querySelectorAll('.heroPairBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('.heroPairBtn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active'); setPair(btn.dataset.pair);
    });
  });
  const handle=$("splitHandle"), hero=$("splitHero");
  if(handle && hero){
    let dragging=false;
    function setSplitFromPointer(clientX, clientY){
      const rect=hero.getBoundingClientRect();
      const isVertical = hero.classList.contains('vertical');
      let rel=isVertical ? (clientY-rect.top)/rect.height : (clientX-rect.left)/rect.width;
      rel=Math.max(0, Math.min(1, rel));
      const pct=Math.max(20, Math.min(80, Math.round(rel*100)));
      document.documentElement.style.setProperty('--hero-split', pct);
      window.dispatchEvent(new Event('resize'));
    }
    handle.addEventListener('mousedown', e=>{ dragging=true; e.preventDefault(); });
    window.addEventListener('mousemove', e=>{ if(dragging) setSplitFromPointer(e.clientX,e.clientY); });
    window.addEventListener('mouseup',   ()=>{ dragging=false; });
    handle.addEventListener('touchstart', e=>{ dragging=true; e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e=>{ if(!dragging) return; const t=e.touches[0]; setSplitFromPointer(t.clientX,t.clientY); }, {passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; });
  }
})();

/* ====== Orbit table ====== */
function updateOrbitTable(){
  const {istYears,dpy}=IST_snapshot();
  const dest=($("destination")?.value)||"Mars";
  const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
  const eY=planetAgeYears("Earth",istYears), eD=eY*dpy;
  const eO=orbitsFor("Earth", eD)||{completed:0,frac:0,daysInto:0,yearLen:365.256};
  const pY=planetAgeYears(dest,istYears), pD=pY*dpy;
  const pO=orbitsFor(dest,pD)||{completed:0,frac:0,daysInto:0,yearLen:orbitalDays[dest]||0};
  const {eta,dAU,v}=computeETASeconds();
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
  const card=(title,lines)=>`
    <div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
      <div style="font-weight:600;margin-bottom:4px">${title}</div>
      ${lines.map(t=>`<div class="stat">${t}</div>`).join("")}
    </div>`;
  const wrap=$("orbit-rows"); if(!wrap) return;
  wrap.innerHTML=[
    card("Sun", [ `${(sY/1e9).toFixed(6)} Ga`, `${Math.floor(sY).toLocaleString()} y`, `${Math.floor(sD).toLocaleString()} d` ]),
    card("Earth", [ `Orbits: ${eO.completed.toLocaleString()}`, `Progress: <span class="pill">${(eO.frac*100).toFixed(1)}%</span>`, `Day ${Math.floor(eO.daysInto)} / ${Math.floor(eO.yearLen)}` ]),
    card(dest, [ `Age: ${(pY/1e9).toFixed(6)} Ga`, `Orbits: ${pO.completed.toLocaleString()}`, `Day ${Math.floor(pO.daysInto)} / ${Math.floor(pO.yearLen)}` ]),
    card("Trip", [ `Dist: ${dAU.toFixed(3)} AU`, `v: ${(v/C_MPS).toFixed(2)} c`, `ETA: ${etaStr}` ])
  ].join("");
}

/* ====== LIVE bottom panels (Energy & Myth) ====== */
(function(){
  const drives = {
    NTR:        { name:"NTR",        vex: 9.81*900,         note:"LH₂ NTR ~900 s Isp" },
    NEP:        { name:"NEP (Ion)",  vex: 30000,            note:"Ion ~30 km/s" },
    Orion:      { name:"Orion",      vex: 25000,            note:"Pulse 20–30 km/s" },
    FusionPulse:{ name:"Fusion",     vex: 0.03*C_MPS,       note:"Fusion pulse ~0.03c (optimistic)" },
    Photon:     { name:"Photon",     vex: null,             note:"No propellant; thrust=P/c" }
  };
  const EFISS=8e13, EFUS=3.4e14, J_PER_TON_TNT=4.184e9;
  function fmtJ(x){ if(!isFinite(x))return"—"; const a=Math.abs(x);
    if(a<1e3) return x.toFixed(0)+" J"; if(a<1e6) return (x/1e3).toFixed(2)+" kJ";
    if(a<1e9) return (x/1e6).toFixed(2)+" MJ"; if(a<1e12) return (x/1e9).toFixed(2)+" GJ";
    if(a<1e15) return (x/1e12).toFixed(2)+" TJ"; return (x/1e15).toFixed(2)+" PJ"; }
  function kv(k,v){ return `<div>${k}</div><div>${v}</div>`; }
  function calcEnergy(live=false){
    if(live && typeof lastPhysics?.beta==="number" && $("energyBeta")){ $("energyBeta").value=(lastPhysics.beta||0).toFixed(2); }
    const m_t=Number(($("energyMassT")?.value)||1000), beta=Math.min(0.9,Math.max(0,Number(($("energyBeta")?.value)||0.10)));
    const m=m_t*1000, gamma=1/Math.sqrt(1-beta*beta), v=beta*C_MPS, EK=(gamma-1)*m*C_MPS*C_MPS;
    const mFiss=EK/EFISS, mFus=EK/EFUS, driveKey=($("energyDrive")?.value)||"FusionPulse"; const drive=drives[driveKey];
    let massRatio="—", vexDisp="—"; if(drive.vex){ const vex=drive.vex; massRatio=Math.exp((beta*C_MPS)/vex); vexDisp=vex>1e6?(vex/1e6).toFixed(2)+" Mm/s":(vex/1e3).toFixed(1)+" km/s"; }
    const out=$("energyOut"); if(!out) return;
    out.innerHTML=[ kv("β (v/c)", beta.toFixed(3)), kv("γ", gamma.toFixed(5)), kv("v", v.toLocaleString(undefined,{maximumFractionDigits:0})+" m/s"),
      kv("Kinetic Energy", fmtJ(EK)), kv("≈ TNT equivalent", (EK/J_PER_TON_TNT).toLocaleString(undefined,{maximumFractionDigits:2})+" t"),
      kv("Ideal Fission Fuel", (isFinite(mFiss)?mFiss:0).toLocaleString(undefined,{maximumFractionDigits:2})+" kg"),
      kv("Ideal Fusion Fuel", (isFinite(mFus)?mFus:0).toLocaleString(undefined,{maximumFractionDigits:2})+" kg"),
      kv("Drive", `${drive.name} <span class="chip">${drive.note}</span>`), kv("Exhaust v", vexDisp),
      kv("Mass Ratio (m₀/m₁)", (typeof massRatio==="number")?massRatio.toLocaleString(undefined,{maximumFractionDigits:2}):"—") ].join("");
  }
  window.addEventListener("load", ()=>{ calcEnergy(false); });
  if($("energyCalcBtn")) $("energyCalcBtn").addEventListener("click", ()=>calcEnergy(false));
  window.energyCalcLive = ()=>calcEnergy(true);

  const myths={ bell:{title:"“Bell” Anti-gravity",verdict:"No credible evidence",tag:'<span class="chip bad">Conflicts (no data)</span>',sim:"Visual-only UI effects."},
                shield:{title:"Gravity Shielding",verdict:"Not supported by GR",tag:'<span class="chip bad">Conflicts with GR</span>',sim:"You can shield radiation, not gravity."},
                exotic:{title:"Negative Energy Drive",verdict:"Requires exotic stress-energy",tag:'<span class="chip warn">Speculative / QI-limited</span>',sim:"UI pulses only."},
                framedrag:{title:"Frame-Drag Rotor",verdict:"Real effect (tiny)",tag:'<span class="chip ok">Observed</span>',sim:"Rotor visual; tiny in reality."}};
  function mythLiveCard(){
    const beta=(lastPhysics?.beta||0), gtt=(lastPhysics?.gttMin??1), cap=(lastPhysics?.vcap_c??0), eng=engineInputs(), mw=eng.reactorMW.toFixed(0);
    const status = gtt<=0.01 ? '<span class="chip bad">Horizon risk</span>' :
                   gtt<0.05   ? '<span class="chip warn">Bubble thin</span>' :
                                '<span class="chip ok">Nominal</span>';
    return `<div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px;grid-column:1/-1">
      <div style="font-weight:600;margin-bottom:4px">Live Physics Status</div>
      <div class="stat">β ${beta.toFixed(2)} • g<sub>tt</sub> ${gtt.toFixed(4)} • cap ${cap.toFixed(2)}c • Reactor ${mw} MW ${status}</div></div>`;
  }
  function renderMyths(){
    const chosen=new Set([...document.querySelectorAll('.mythToggle')].filter(x=>x.checked).map(x=>x.value));
    const out=[mythLiveCard()];
    for(const k of Object.keys(myths)){ if(!chosen.has(k)) continue; const m=myths[k];
      out.push(`<div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
        <div style="font-weight:600;margin-bottom:4px">${m.title}</div>
        <div class="stat">${m.tag}</div><div class="stat">Physics: ${m.verdict}</div><div class="stat">Simulator: ${m.sim}</div></div>`);}
    const tgt=$("mythOut"); if(tgt) tgt.innerHTML=out.join("");
  }
  document.querySelectorAll('.mythToggle').forEach(cb=>cb.addEventListener('change', renderMyths));
  window.renderMythLive=renderMyths;
})();

/* ====== Realistic subsystem summaries ====== */
function fmtPct(x){ return (100*x).toFixed(1)+"%"; }
function kv3(k,v){ return `<div>${k}</div><div>${v}</div>`; }
function updateWarpCorePanel(){
  const eng=engineInputs();
  const thermalMW = Math.max(0, eng.reactorMW * (0.12 + 0.08*engineState.temp));
  const scram = eng.reactorMW<500 ? "IDLE" : (engineState.temp>0.95 ? "SCRAM TRIP" : "RUN");
  const powerLight = scram==="SCRAM TRIP" ? "bad" : eng.reactorMW<1000 ? "warn" : "good";
  setLight($("lightPower"), powerLight);
  if(!$("coreOut")) return;
  $("coreOut").innerHTML=[
    kv3("Output", `${eng.reactorMW.toFixed(0)} MW`),
    kv3("Waste Heat", `${thermalMW.toFixed(0)} MW`),
    kv3("Containment Need", fmtPct(engineState.containNeed)),
    kv3("Core Temp Index", engineState.temp.toFixed(2)),
    kv3("Status", `<span class="chip ${scram==="RUN"?"ok":scram==="IDLE"?"warn":"bad"}">${scram}</span>`)
  ].join("");
}
function updateEPSPanel(){
  const eng=engineInputs();
  const coilsMW = eng.reactorMW * eng.coilsPct;
  const epsLoadMW = Math.max(0, eng.reactorMW - coilsMW);
  const cryoIndex = Math.min(1, 0.20 + 0.00006*eng.reactorMW + 0.15*(1-eng.stability));
  const TlineK = 4 + 8*cryoIndex;
  const lossFrac = Math.max(0.002, 0.002 + 0.01*cryoIndex + 0.02*(1-eng.stability));
  const lossesMW = eng.reactorMW * lossFrac;
  const superconducting = TlineK<10.5;
  const vectorLight = superconducting ? (eng.stability>0.6?"good":"warn") : "bad";
  setLight($("lightVector"), vectorLight);
  if(!$("epsOut")) return;
  $("epsOut").innerHTML=[
    kv3("Line Temp", `${TlineK.toFixed(1)} K`),
    kv3("Losses", `${lossesMW.toFixed(1)} MW (${fmtPct(lossFrac)})`),
    kv3("To Coils", `${coilsMW.toFixed(0)} MW`),
    kv3("Aux/House", `${epsLoadMW.toFixed(0)} MW`),
    kv3("Phase Stability", engineInputs().stability.toFixed(2)),
    kv3("State", superconducting?'<span class="chip ok">SC OK</span>':'<span class="chip warn">Quench Risk</span>')
  ].join("");
}
function updateNacellesPanel(){
  const eng=engineInputs();
  const coilField = 5 + 45*(eng.coilsPct);
  const vaneVec = 100*(Math.abs(eng.lr)+Math.abs(eng.ud));
  const phaseError = (engineState.jitter*100) + 10*Math.abs(eng.rear-eng.front);
  const balance = 1 - Math.min(1, (Math.abs(eng.lr)+Math.abs(eng.ud))/1.2);
  const coilHealth = eng.stability>0.7 ? "ok" : eng.stability>0.45 ? "warn" : "bad";
  if(!$("nacelleOut")) return;
  $("nacelleOut").innerHTML=[
    kv3("Coil Field (vis)", `${coilField.toFixed(1)} T`),
    kv3("Vane Vector Effort", `${vaneVec.toFixed(0)} %·unit`),
    kv3("Phase Error", `${phaseError.toFixed(2)}°`),
    kv3("Nacelle Balance", fmtPct(balance)),
    kv3("Coil Health", `<span class="chip ${coilHealth}">${coilHealth.toUpperCase()}</span>`)
  ].join("");
}
function updateBubblePanel(){
  const eng=engineInputs();
  const beta = lastPhysics?.beta||0;
  const gtt = lastPhysics?.gttMin??1;
  const cap = lastPhysics?.vcap_c??0;
  const compFront = 1 + 2.5*eng.front;
  const expRear   = 1 + 2.5*eng.rear;
  const asym = Math.abs(eng.rear - eng.front);
  const hullStress = Math.min(1, 0.25*asym + 2.0*engineState.jitter + 0.6*beta*(1-eng.stability));
  const shieldCoupling = Math.min(1, 0.30 + 0.6*(eng.containPct) + 0.1*(lastPhysics.gf||0));
  const gttMargin = Math.max(0, gtt - 0.01);
  const status = gtt<=0.01 ? "bad" : gtt<0.05 ? "warn" : "good";
  setLight($("lightBubble"), status);
  if(!$("bubbleOut")) return;
  $("bubbleOut").innerHTML=[
    kv3("β (v/c)", beta.toFixed(2)),
    kv3("g<sub>tt</sub> min", gtt.toFixed(5)),
    kv3("Cap", `${cap.toFixed(2)} c`),
    kv3("Front Compression", compFront.toFixed(2)),
    kv3("Rear Expansion", expRear.toFixed(2)),
    kv3("Hull Stress Index", hullStress.toFixed(2)),
    kv3("Shield Coupling", fmtPct(shieldCoupling)),
    kv3("g<sub>tt</sub> Margin", gttMargin.toFixed(5))
  ].join("");
}
function refreshRealisticSystems(){
  updateWarpCorePanel();
  updateEPSPanel();
  updateNacellesPanel();
  updateBubblePanel();
}

/* ====== AUTO LOOP ENGINE ALWAYS ON ====== */
function mainTick(){
  const now=performance.now(); const dt=Math.min(0.05,(now-lastFrameTime)/1000); lastFrameTime=now;
  stepEngineDynamics(dt);
  tickWarpRamp(dt);
  const {eta,v}=computeETASeconds(); // updates lastPhysics
  const speedGain=(v/C_MPS);
  shipProgress = Math.min(1, shipProgress + 0.00035*Math.pow(Math.max(1, Number(($("warpSpeed")?.value)||1)),0.82)*(0.6+0.8*speedGain));
  if(shipProgress>=1){ shipProgress=1; shipArrived=true; }
  drawCurve(); drawOrbitView(); updateAllStatus(); updateOrbitTable(); refreshRealisticSystems(); if(typeof window.energyCalcLive==="function") window.energyCalcLive(); if(typeof window.renderMythLive==="function") window.renderMythLive(); drawCompass();
  animationFrame=requestAnimationFrame(mainTick);
}

/* ====== Inputs cause immediate refresh ====== */
[
  "warpSpeed","warpExp","warpScale","destination","calibration",
  "istDay0Years","baselineDaysPerYear","reactorMW",
  "frontPct","rearPct","lrBias","udBias","intakeMode","soundOn"
].forEach(id=>{
  const el=$(id); if(!el) return;
  el.addEventListener("input", ()=>{
    if(id==="calibration") setCalibration(el.value);
    tIST0=performance.now();
    drawCurve(); drawOrbitView(); updateAllStatus(); updateOrbitTable(); refreshRealisticSystems(); if(typeof window.energyCalcLive==="function") window.energyCalcLive(); if(typeof window.renderMythLive==="function") window.renderMythLive(); drawCompass();
  });
});

/* ====== Resize keeps everything crisp ====== */
window.addEventListener('resize', ()=>{ drawCurve(); drawOrbitView(); updateAllStatus(); updateOrbitTable(); refreshRealisticSystems(); if(typeof window.energyCalcLive==="function") window.energyCalcLive(); if(typeof window.renderMythLive==="function") window.renderMythLive(); drawCompass(); });

/* ====== Initialize LIVE immediately ====== */
(function boot(){
  try{ const saved=localStorage.getItem('uiScalePct'); if(saved && document.documentElement){ document.documentElement.style.setProperty('--ui-scale',(Number(saved)/100).toString()); if($("uiScale")) $("uiScale").value=saved; } }catch{}
  setCalibration(($("calibration")?.value)||"off");
  setPair('traj-star'); setOrientation('vertical');
  drawCurve(); drawOrbitView(); updateOrbitTable(); updateAllStatus(); refreshRealisticSystems(); if(typeof window.energyCalcLive==="function") window.energyCalcLive(); if(typeof window.renderMythLive==="function") window.renderMythLive();
  ensureCompass(); drawCompass();
  if(animationFrame) cancelAnimationFrame(animationFrame);
  lastFrameTime=performance.now();
  animationFrame=requestAnimationFrame(mainTick);
})();

/* ====== Buttons: Start / Stop / Engage (ramp control) ====== */
if($("startBtn")) $("startBtn").addEventListener("click", ()=>{
  const target = Number(($("warpSpeed")?.value)||1);
  setWarpTarget(target, 0.6); tone("good");
});
if($("stopBtn"))  $("stopBtn").addEventListener("click", ()=>{
  setWarpTarget(1, 0.8); tone("warn");
});
if($("resetBtn")) $("resetBtn").addEventListener("click", ()=>{
  shipProgress=0; engineState.temp=0.25; engineState.sag=0.03; engineState.jitter=0.01; tIST0=performance.now();
  const target = Math.max(1, Number(($("warpSpeed")?.value)||1));
  setWarpTarget(target, 1.0); tone("good");
});
if($("exportBtn")) $("exportBtn").addEventListener("click", ()=>{
  const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"], ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
  const csv=rows.map(r=>r.join(",")).join("\n"); const blob=new Blob([csv],{type:"text/csv"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click();
});
</script>
</body>
</html>
