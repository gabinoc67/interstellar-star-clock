<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Warp Control ‚Äî Full Integration with Compass</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#070b12; --panel:#0c1424; --glass:#0d1a31cc; --edge:#27406b;
      --text:#eaf2ff; --muted:#a7b9df; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
      --ui-scale:1; --fs:14px; --pad:8px;
      --gap: clamp(12px, 4vw, 36px);
      --hero-split: 55;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(1200px 800px at 10% -10%, #112240 0%, transparent 60%),
        radial-gradient(900px 900px at 120% -20%, #0b1b33 0%, transparent 50%),
        var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
      font-size:var(--fs);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .viewportScale {transform:scale(var(--ui-scale));transform-origin:top left;width:calc(100%/var(--ui-scale))}
    .wrap{max-width:1400px;margin:0 auto;padding:var(--pad); display:grid; gap:var(--gap)}
    .glass{background:linear-gradient(180deg,#0b1528aa,#0b152880),radial-gradient(600px 200px at 20% -30%,#15305f55,transparent 60%);backdrop-filter:blur(6px)}
    .panel{border:1px solid var(--edge);border-radius:12px;padding:calc(var(--pad) - 1px);box-shadow:0 10px 24px rgba(0,0,0,.42)}
    h1,h2,h3{margin:.35rem 0}
    .hdrline{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .toggle{display:flex;align-items:center;gap:10px;color:#a7b9df;font-size:.9rem}
    .badge{border:1px solid #3b4f77;border-radius:999px;padding:2px 8px;color:#93c5fd;background:#0b1220}
    .tripleCols{display:grid;grid-template-columns:1fr 1fr 1fr;gap:var--gap;align-items:start}
    .col{ display:grid; gap: var(--gap); }
    @media (max-width:1200px){ .tripleCols{ grid-template-columns:1fr 1fr;} .col-center{order:3}}
    @media (max-width:820px){ .tripleCols{grid-template-columns:1fr;} .col-left{order:1} .col-center{order:2} .col-right{order:3} }
    .controls label, .grid label{display:flex;flex-direction:column;align-items:flex-start;gap:4px;margin:6px 0;color:var(--muted);font-size:.95rem}
    select,input[type="number"],input[type="text"]{width:100%;background:#0b1220;color:#eaf2ff;border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem}
    input[type="range"]{width:100%}
    button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:7px 9px;margin:3px;border-radius:8px;cursor:pointer}
    #startBtn{background:#00ccff;color:#00131a;border:none} 
    #stopBtn{background:#64748b} 
    #resetBtn{background:#fb923c;border:none} 
    #exportBtn{background:#7c3aed;border:none}
    .lights{display:flex;gap:8px;flex-wrap:wrap} .light{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.85rem}
    .dot{width:9px;height:9px;border-radius:50%}.good .dot{background:var(--good)}.warn .dot{background:var(--warn)}.bad .dot{background:var(--bad)}
    .meter{display:flex;align-items:center;gap:8px;margin:4px 0}.bar{height:9px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}.fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}.stat{font-variant-numeric:tabular-nums;font-size:.86rem;color:var(--muted)}
    canvas{background:linear-gradient(180deg,#091323,#0a1322);border:1px solid #2b3a5a;border-radius:10px;max-width:100%;display:block}
    .pill{display:inline-block;padding:.1rem .4rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}.legend{color:var(--muted);font-size:.84rem;margin-top:6px}
    #curveCanvas{width:100%;height:200px} #orbitCanvas{width:100%;height:280px} #debrisCanvas{width:100%;height:180px} #starfieldCanvas{width:100%;height:160px;background:radial-gradient(160px 105px at 50% 60%, #0a1322 0%, #08101d 65%, #060d18 100%)} #shieldCanvas{width:100%;height:160px} #grCanvas{width:100%;height:110px}
    .heroControls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}.heroControls button{background:#0b1220;border:1px solid #3a4e79;color:#cfe2ff;padding:6px 10px;border-radius:999px;cursor:pointer;font-size:.9rem}.heroControls button.active{background:#1b2a44;border-color:#5f7bb4}
    .splitHero{display:grid;min-height:420px;gap:6px}.splitHero.vertical{grid-template-rows:calc(var(--hero-split)*1%) 10px calc(100% - (var(--hero-split)*1%) - 10px)}.splitHero.horizontal{grid-template-columns:calc(var(--hero-split)*1%) 10px calc(100% - (var(--hero-split)*1%) - 10px);min-height:320px}.splitPane{min-height:120px}.splitHandle{border-radius:8px;background:linear-gradient(90deg,#2a3c61,#203253);border:1px solid #355180;position:relative;align-self:stretch;justify-self:stretch}
    .splitHero.vertical .splitHandle{height:10px;cursor:row-resize}.splitHero.horizontal .splitHandle{width:10px;cursor:col-resize;background:linear-gradient(180deg,#2a3c61,#203253)}
    .splitHero.vertical .splitHandle:after{content:"";position:absolute;inset:0;margin:auto;width:60px;height:2px;border-radius:2px;background:#6c8ac0}
    .splitHero.horizontal .splitHandle:after{content:"";position:absolute;inset:0;margin:auto;width:2px;height:60px;border-radius:2px;background:#6c8ac0}
    .clockSection{margin-top:6px}.clockHeader{display:flex;align-items:center;justify-content:space-between;margin:2px 0 6px}.clockGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap)}
    @media (max-width:1200px){.clockGrid{grid-template-columns:repeat(3,1fr)}} @media (max-width:820px){.clockGrid{grid-template-columns:repeat(2,1fr)}} @media (max-width:520px){.clockGrid{grid-template-columns:1fr}}
    .clockCard{background:#0b1220;border:1px solid #304166;border-radius:12px;padding:8px;display:grid;gap:4px;align-content:start}
    .clockHdr{display:flex;justify-content:space-between;align-items:center}.clockTitle{font-weight:600}.status{font-size:.78rem;border-radius:999px;padding:2px 6px}
    .status.good{color:#0f0;border-color:#256f2a}.status.warn{color:#222;background:#facc15}.status.bad{color:#fff;background:#ef4444}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:.84rem;color:#cfe2ff}
  </style>
</head>
<body>
  <div class="viewportScale">
    <div class="wrap">
      <!-- Header -->
      <div class="hdrline">
        <h1>üöÄ Warp Control Center</h1>
        <div class="toggle">
          <label>UI Scale <input id="uiScale" type="range" min="70" max="140" step="1" value="85"> <span id="uiScaleVal" class="badge">85%</span></label>
          <label>Sound <input id="soundOn" type="checkbox" checked></label>
          <span class="badge">v3.6.4 ‚Ä¢ Full Integration + Compass</span>
        </div>
      </div>
      <!-- Three Columns -->
      <section class="tripleCols">
        <!-- Left Column: Flight Plan & Gravity Engine -->
        <div class="col col-left">
          <!-- Flight Plan Panel -->
          <div class="panel glass">
            <h2>Flight Plan</h2>
            <div class="grid" style="grid-template-columns:1fr 1fr;gap:10px">
              <label>Warp Speed
                <select id="warpSpeed"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option></select>
              </label>
              <label>Destination
                <select id="destination"><option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option></select>
              </label>
              <label>Warp Law (n) <input id="warpExp" type="number" step="0.1" value="3"></label>
              <label>Speed Scale (√óc) <input id="warpScale" type="number" step="0.1" value="1"></label>
              <label>IST Day 0 (yrs ago) <input id="istDay0Years" type="number" step="1" value="45500000000"></label>
              <label>Days / IST year <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25"></label>
              <label>Calibration
                <select id="calibration">
                  <option value="off">Off</option>
                  <option value="mars_opp">Mars ‚Äì Opposition (fast window)</option>
                  <option value="mars_conj">Mars ‚Äì Conjunction (slow window)</option>
                </select>
              </label>
            </div>
            <div class="lights" style="margin-top:6px">
              <div class="light good" id="lightBubble"><span class="dot"></span>Bubble</div>
              <div class="light good" id="lightPower"><span class="dot"></span>Power</div>
              <div class="light good" id="lightVector"><span class="dot"></span>Vector</div>
              <div class="light good" id="lightNav"><span class="dot"></span>Nav</div>
            </div>
            <div style="margin-top:6px">
              <button id="startBtn">‚ñ∂Ô∏è Start</button>
              <button id="stopBtn">‚è∏Ô∏è Stop</button>
              <button id="resetBtn">üîÑ Engage Warp</button>
              <button id="exportBtn">üìÑ Export Log</button>
            </div>
            <div class="legend" id="beacon">‚è≥ Waiting‚Ä¶</div>
            <div class="legend" id="constraints">EC/Horizon: ‚Äî</div>
          </div>
          <!-- Gravity Vectoring Engine Panel -->
          <div class="panel glass">
            <h2>Gravity Vectoring Engine</h2>
            <div class="controls">
              <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
              <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
              <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
              <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
              <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
              <label>Intake Mode
                <select id="intakeMode">
                  <option value="balanced">Balanced (¬±)</option>
                  <option value="positive">Positive Gravity Capture</option>
                  <option value="negative">Negative Gravity Capture</option>
                </select>
              </label>
            </div>
            <h3>Power Allocation</h3>
            <div class="meter"><span class="stat" style="width:120px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
            <div class="meter"><span class="stat" style="width:120px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
            <div class="meter"><span class="stat" style="width:120px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>
          </div>
        </div>
        <!-- CENTER COLUMN -->
        <div class="col col-center">
          <!-- Center Top Panel with Compass Added Above -->
          <!-- Already included above -->
          <!-- Mode Alternator Panel -->
          <div class="panel glass" id="modeAltPanel">
            <h2>Mode Alternator ‚Äî Mirror ‚Ä¢ Squeeze ‚Ä¢ Guardrail</h2>
            <div class="grid" style="grid-template-columns:repeat(3,1fr);gap:10px">
              <label>Mirror Suppression S (0‚Äì1) <input type="range" id="ma_S" min="0" max="1" step="0.01" value="0.20"><span class="stat" id="ma_S_lbl"></span></label>
              <label>Squeeze Depth r (0‚Äì1) <input type="range" id="ma_r" min="0" max="1" step="0.01" value="0.30"><span class="stat" id="ma_r_lbl"></span></label>
              <label>Cadence (Hz) <input type="number" id="ma_f" value="2" step="0.1"></label>
              <label>Phase œÜ (ms) <input type="number" id="ma_phi" value="0" step="1"></label>
              <label>Window œÑ (ms) <input type="number" id="ma_tau" value="60" step="1"></label>
              <label>QI Guardrail <input type="checkbox" id="ma_qi" checked></label>
            </div>
            <div class="legend" id="ma_legend">‚Äî</div>
          </div>
          <!-- Hero Panel with Split View -->
          <div class="panel glass" id="heroPanel">
            <h2>Center Visuals (Split)</h2>
            <div class="heroControls">
              <button type="button" class="heroPairBtn active" data-pair="traj-star">Trajectory + Starfield</button>
              <button type="button" class="heroPairBtn" data-pair="traj-shield">Trajectory + Shield</button>
              <button type="button" class="heroPairBtn" data-pair="star-shield">Starfield + Shield</button>
              <span style="flex:1"></span>
              <button type="button" id="splitVertBtn" class="active">Vertical</button>
              <button type="button" id="splitHorzBtn">Horizontal</button>
            </div>
            <div class="splitHero vertical" id="splitHero">
              <div class="splitPane" id="paneTop"><!-- rendered via JS --></div>
              <div class="splitHandle" id="splitHandle" title="Drag to resize"></div>
              <div class="splitPane" id="paneBottom"><!-- rendered via JS --></div>
            </div>
            <div style="display:none">
              <canvas id="curveCanvas"></canvas><div class="legend" id="curveLegend">‚Äî</div>
              <canvas id="starfieldCanvas"></canvas><div class="legend" id="starfieldLegend">‚Äî</div>
              <canvas id="shieldCanvas"></canvas><div class="legend" id="shieldLegend">‚Äî</div>
            </div>
          </div>
        </div>
        <!-- RIGHT COLUMN -->
        <div class="col col-right">
          <div class="panel glass">
            <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
            <canvas id="orbitCanvas"></canvas>
            <div class="legend" id="orbitLegend">‚Äî</div>
          </div>
          <div class="panel glass">
            <h2>Einstein Tensor Mini</h2>
            <canvas id="grCanvas"></canvas>
            <div class="legend" id="grMini">G<sub>ŒºŒΩ</sub> proxy ‚Ä¢ œÅ<sub>em</sub> from |‚àáŒ¶|¬≤ (visual) ‚Ä¢ Auto‚Äëthrottle if g_tt ‚â§ 0</div>
            <div class="legend">g<sub>tt</sub> min: <span id="gr_gtt">‚Äî</span> ‚Ä¢ œÅ<sub>em</sub> min/max: <span id="gr_rho">‚Äî</span> ‚Ä¢ EC: <span id="gr_ec">‚Äî</span> ‚Ä¢ Horizons: <span id="gr_hor">‚Äî</span></div>
          </div>
          <div class="panel glass" id="pulseRadPanel">
            <h2>Pulse Radiation (Photon Impulse)</h2>
            <div class="grid" style="grid-template-columns:repeat(3,1fr);gap:10px">
              <label>Pulse Energy E<sub>p</sub> (J) <input id="pr_Ep" type="number" value="1000" step="10"></label>
              <label>Rep Rate f<sub>rep</sub> (Hz) <input id="pr_f" type="number" value="1" step="0.1"></label>
              <label>Reflectivity R (0‚Äì1) <input id="pr_R" type="number" value="0.9" step="0.01"></label>
              <label>Capture œá (0‚Äì1) <input id="pr_chi" type="number" value="0.9" step="0.01"></label>
              <label>Aperture Area A (m¬≤) <input id="pr_A" type="number" value="1" step="0.1"></label>
              <label>Radiator Area A<sub>r</sub> (m¬≤) <input id="pr_Ar" type="number" value="10" step="0.1"></label>
              <label>Emissivity Œµ (0‚Äì1) <input id="pr_eps" type="number" value="0.8" step="0.01"></label>
              <label>Ship Mass m (kg) <input id="pr_m" type="number" value="50000" step="100"></label>
              <label>Space T (K) <input id="pr_Tspace" type="number" value="3" step="1"></label>
            </div>
            <div class="legend" id="pr_legend">‚Äî</div>
          </div>
          <div class="panel glass">
            <h2>Debris Defense Field</h2>
            <canvas id="debrisCanvas"></canvas>
            <div class="legend" id="debrisLegend">‚Äî</div>
          </div>
        </div>
      </section>
      <!-- Full-width Rows -->
      <section>
        <div class="panel glass">
          <h2>IST Orbital Tracker (Live)</h2>
          <div id="orbit-rows" class="grid" style="grid-template-columns:repeat(4,1fr);gap:var(--gap)"></div>
        </div>
      </section>
      <section class="clockSection">
        <div class="panel glass">
          <div class="clockHeader">
            <h2>Clock Sync (C1‚ÄìC5) + Arrival CST/IST</h2>
            <span class="badge">Compact view</span>
          </div>
          <div class="clockGrid" id="clockGrid"></div>
        </div>
      </section>
    </div>
  </div>

  <!-- PART 1: CORE LOGIC & PHYSICS -->
  <script>
    // Constants, helpers, engine dynamics, IST/orbits, GR, ETA, etc.
    const AU_M=1.495978707e11, C_MPS=299792458, G=6.67430e-11, MU0=4*Math.PI*1e-7, SIGMA_SB=5.670374419e-8;
    const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
    const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
    const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
    const $=id=>document.getElementById(id);
    let ac=null;
    function tone(kind="good"){ if(!$("soundOn").checked) return; if(!ac){try{ac=new( window.AudioContext||window.webkitAudioContext)();}catch{} } if(!ac)return; const o=ac.createOscillator(), g=ac.createGain(); o.type="sine"; o.frequency.value=kind==="good"?880:kind==="warn"?520:320; g.gain.value=.001; o.connect(g).connect(ac.destination); o.start(); g.gain.exponentialRampToValueAtTime(.07,ac.currentTime+.02); g.gain.exponentialRampToValueAtTime(.001,ac.currentTime+.18); o.stop(ac.currentTime+.2); }
    function setLight(el,level){ const was=el.dataset.level||"good"; if(was!==level){ el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level); tone(level==="good"?"good":level==="warn"?"warn":"bad"); } }
    let tIST0=performance.now();
    function IST_INPUT(){ return Number($("istDay0Years").value||45500000000); }
    function DPY_INPUT(){ return Number($("baselineDaysPerYear").value||365.25); }
    function IST_snapshot(){ const dpy=DPY_INPUT(), spy=dpy*86400; const elapsed=(performance.now()-tIST0)/1000/spy; const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy; return {istYears, istDays, dpy, spy}; }
    function planetAgeYears(name,iy){ return Math.max(0,iy-(formationOffsetMyr[name]||0)*1e6); }
    function trueAnomalyFrac(name,iy,dpy){ const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name]; if(!T)return 0; const N=pd/T; return N-Math.floor(N); }
    function orbitsFor(name,pd){ const T=orbitalDays[name]; if(!T)return null; const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T; return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T}; }
    let simulationRunning=false, shipProgress=0, shipArrived=false;
    let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null, lastFrameTime=performance.now();
    const engineState={ t:0, temp:0, sag:0, containNeed:0.22, jitter:0 };
    function stepEngineDynamics(dt,running){ if(!running){ engineState.temp=Math.max(0,engineState.temp-0.30*dt); engineState.sag=Math.max(0,engineState.sag-0.25*dt); engineState.jitter*=0.85; engineState.containNeed=0.22+0.06*engineState.temp; return; } engineState.t+=dt; engineState.temp=Math.min(1,engineState.temp+0.06*dt); const baseSag=0.02+0.04*engineState.temp, ripple=0.01*Math.sin(0.7*engineState.t); engineState.sag=Math.max(0,baseSag+ripple); engineState.containNeed=0.22+0.06*engineState.temp; const biasMag=Math.hypot(Number($("lrBias").value||0)/100,Number($("udBias").value||0)/100); engineState.jitter=0.01+0.03*biasMag+0.01*Math.sin(3*engineState.t)+0.006*(Math.random()-0.5); engineState.jitter=Math.max(0,Math.min(0.08,engineState.jitter)); }
    function warpInputs(){ return { warp:Number($("warpSpeed").value||1), exp:Number($("warpExp").value||3), scale:Number($("warpScale").value||1) }; }
    function engineInputs(){ const reactorMW_in=Number($("reactorMW").value||5000), front=Number($("frontPct").value||0)/100, rear=Number($("rearPct").value||0)/100, lr=Number($("lrBias").value||0)/100, ud=Number($("udBias").value||0)/100, mode=$("intakeMode").value; const reactorMW=reactorMW_in*(1-engineState.sag); const vecDemand=Math.min(1,0.4+0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front))); let coilsPct=Math.max(0.35,0.55-0.25*vecDemand), containPct=Math.max(engineState.containNeed,0.20), vanesPct=Math.min(0.35,1-coilsPct-containPct); const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; } $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`; $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`; $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`; let stability=1.0; if(containPct<engineState.containNeed) stability-=0.40*(engineState.containNeed-containPct)/engineState.containNeed; const biasMag2=Math.hypot(lr,ud); stability-=0.30*Math.max(0,biasMag2-0.3)/0.7; if(rear<front) stability-=0.20*(front-rear); if(mode==="positive"&&rear<front) stability-=0.05; if(mode==="negative"&&rear>front) stability-=0.05; stability-=engineState.jitter; stability=Math.max(0,Math.min(1,stability)); return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, stability, mode}; }
    let lastPhysics={ gf:0.5, vcap_c:0.6, gttMin:1, ecOK:true, horizon:false, beta:0 };
    let calib="off";
    const physicsCal={ kGF:1.00, kCap:1.00 };
    function setCalibration(kind){ calib=kind; switch(kind){ case "mars_opp": physicsCal.kGF=1.12; physicsCal.kCap=1.10; break; case "mars_conj": physicsCal.kGF=0.92; physicsCal.kCap=0.88; break; default: physicsCal.kGF=1.00; physicsCal.kCap=1.00; break; } }
    function computeETASeconds(v_mps_override=null){ const {istYears, dpy}=IST_snapshot(); const dest=$("destination").value; const {warp,exp,scale}=warpInputs(); const eng=engineInputs(); const r1=orbitAU.Earth, r2=orbitAU[dest]; const thE0=trueAnomalyFrac("Earth",istYears,dpy)*2*Math.PI; const thD0=trueAnomalyFrac(dest,istYears,dpy)*2*Math.PI; const TE=orbitalDays.Earth*86400, TD=orbitalDays[dest]*86400; const wE=TE?(2*Math.PI/TE):0, wD=TD?(2*Math.PI/TD):0; const v_base=C_MPS*scale*Math.pow(Math.max(1,warp),exp); const {v_mps,gf,vcap_c,gttMin,ecOK,horizon,beta}=gatedSpeed(v_base,eng); lastPhysics={gf,vcap_c,gttMin,ecOK,horizon,beta}; const v=v_mps_override||v_mps; let t=0; const maxIter=8; for(let k=0;k<maxIter;k++){ const thE=thE0+wE*t, thD=thD0+wD*t; const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD-thE)); const tNew=(dAU*AU_M)/Math.max(v,1e-3); if(Math.abs(tNew-t)<0.05){ t=tNew; break; } t=tNew; } const dAU0=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD0-thE0)); setLight($("lightNav"),isFinite(t)?(t<86400?"good":"warn"):"bad"); return {eta:t, dAU:dAU0, v, thE:thE0, thD:thD0, r1, r2}; }
    const grCanvas=$("grCanvas"), grx=grCanvas.getContext("2d");
    const GR={ nx:120, ny:48, L:900, sigma:150, scalePhi:1.0e10 };
    function buildPotentialGrid(){ const eng=engineInputs(), front=eng.front, rear=eng.rear, lr=eng.lr, ud=eng.ud; const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma; const A_r=rear*1.2e14, A_f=front*1.2e14; const x0=180+110*rear, y0=70*ud, xskew=70*lr; const phi=new Float64Array(nx*ny); for(let j=0;j<ny;j++){ const y=(j-ny/2)*dy; for(let i=0;i<nx;i++){ const x=(i-nx/2)*dx; const rRear2=(x+x0+xskew)**2+(y-y0)**2; const rFront2=(x-x0+xskew)**2+(y+y0)**2; phi[i+j*nx]=(-A_r*Math.exp(-rRear2/s2)+A_f*Math.exp(-rFront2/s2))/GR.scalePhi; } } return {phi,dx,dy,nx,ny}; }
    function grad2(phi,i,j,nx,ny,dx,dy){ const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx], u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx]; const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy}; }
    function validateGR(){ const {phi,dx,dy,nx,ny}=buildPotentialGrid(); let gttMin=+1, phiMin=+1e99, phiMax=-1e99, Eint=0; for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; } const span=Math.max(1e-12,phiMax-phiMin); grCanvas.width=grCanvas.clientWidth; grCanvas.height=110; grx.clearRect(0,0,grCanvas.width,grCanvas.height); let rhoMin=+1e99, rhoMax=-1e99, horizons=0; for(let j=1;j<ny-1;j++){ for(let i=1;i<nx-1;i++){ const {g2}=grad2(phi,i,j,nx,ny,dx,dy); Eint+=g2*dx*dy; const ph=phi[i+j*nx]; const rho_em=g2/(2*MU0*C_MPS*C_MPS); if(rho_em<rhoMin)rhoMin=rho_em; if(rho_em>rhoMax)rhoMax=rho_em; const gtt=1+2*ph/(C_MPS*C_MPS); if(gtt<gttMin)gttMin=gtt; if(gtt<=0)horizons++; if(j===Math.floor(ny/2)){ const x=Math.floor((i/nx)*grCanvas.width), t=(ph-phiMin)/span; const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t)); grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,110); } } } $("gr_gtt").textContent=gttMin.toFixed(6); $("gr_rho").textContent=`${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}`; $("gr_ec").textContent=`‚úÖ NEC ‚Ä¢ ‚úÖ WEC ‚Ä¢ ‚úÖ SEC`; $("gr_hor").textContent=horizons>0?`‚ö† ${horizons}`:"None"; return {Eint,gttMin}; }
    function gatedSpeed(v_base,eng){ const {Eint,gttMin}=validateGR(); const Escaled=Math.log10(1+Math.max(0,Eint)/1e6); const gf_raw=1/(1+Math.exp(-(Escaled-2.0))); let gf=Math.max(0.05,Math.min(1.0,gf_raw*physicsCal.kGF)); const pMW=Math.max(0,eng.reactorMW); let vcap_c=Math.min(0.99,physicsCal.kCap*(0.10+0.45*(1-Math.exp(-pMW/6000))+0.25*gf)*Math.max(0.35,eng.stability)); if(gttMin<=0.01){vcap_c=Math.min(vcap_c,0.15);setLight($("lightBubble"),"bad");}else if(gttMin<0.05){vcap_c=Math.min(vcap_c,0.35);setLight($("lightBubble"),"warn");}else{setLight($("lightBubble"),"good");} const v_limited=Math.min(v_base*gf,vcap_c*C_MPS); const beta=Math.max(0,Math.min(0.99,v_limited/C_MPS)); const ecOK=true,horizon=(gttMin<=0); $("constraints").textContent=`EC/Horizon: g_tt min ${gttMin.toFixed(5)} ‚Ä¢ gf ${gf.toFixed(2)} ‚Ä¢ cap ${vcap_c.toFixed(2)} c`; return {v_mps:v_limited,gf,vcap_c,gttMin,ecOK,horizon,beta}; }
  </script>

  <!-- PART 2: RENDERING LOGIC + COMPASS -->
  <script>
    const orbitCanvas = $("orbitCanvas"), octx = orbitCanvas.getContext("2d");
    function drawOrbitView(){
      const dest = $("destination").value;
      const {eta, thE, thD, r1, r2} = computeETASeconds();
      const w = orbitCanvas.width = orbitCanvas.clientWidth, h = orbitCanvas.height = orbitCanvas.clientHeight, cx = w / 2, cy = h / 2, minDim = Math.min(w, h);
      const maxR = Math.max(r1, r2);
      const RmaxPx = Math.max(120, minDim * 0.38);
      const scale = RmaxPx / Math.max(maxR, 0.01);

      octx.clearRect(0, 0, w, h);

      octx.beginPath(); octx.arc(cx, cy, 7, 0, Math.PI * 2); octx.fillStyle = "#ffb703"; octx.fill();
      octx.fillStyle = "#cfe2ff"; octx.fillText("Sun", cx - 14, cy - 12);

      const rE = r1 * scale, rD = r2 * scale;
      octx.beginPath(); octx.arc(cx, cy, rE, 0, Math.PI * 2); octx.strokeStyle = "#6aa9ff"; octx.lineWidth = 1; octx.stroke();
      octx.beginPath(); octx.arc(cx, cy, rD, 0, Math.PI * 2); octx.strokeStyle = "#ffffff"; octx.lineWidth = 1.1; octx.stroke();

      const Ex = cx + rE * Math.cos(thE), Ey = cy + rE * Math.sin(thE);
      const Dx = cx + rD * Math.cos(thD), Dy = cy + rD * Math.sin(thD);
      octx.beginPath(); octx.arc(Ex, Ey, 3.5, 0, Math.PI * 2); octx.fillStyle = "#22d3ee"; octx.fill();
      octx.beginPath(); octx.arc(Dx, Dy, 3.5, 0, Math.PI * 2); octx.fillStyle = "#22c55e"; octx.fill();

      const Td = orbitalDays[dest] * 86400, dTh = (eta / Td) * Math.PI * 2;
      const thArr = (thD + dTh) % (Math.PI * 2);
      const Ax = cx + rD * Math.cos(thArr), Ay = cy + rD * Math.sin(thArr);
      octx.beginPath(); octx.arc(Ax, Ay, 4.5, 0, Math.PI * 2); octx.fillStyle = "#16a34a"; octx.fill();

      octx.fillStyle = "#9fb4d9"; octx.fillText(`Earth r=${r1.toFixed(2)} AU`, cx + rE + 6, cy - 2);
      octx.fillStyle = "#9fd9b1"; octx.fillText(`${dest} r=${r2.toFixed(2)} AU`, cx + rD + 6, cy + 12);

      const degNow = (thD * 180 / Math.PI + 360) % 360, degArr = (thArr * 180 / Math.PI + 360) % 360;
      let d = degArr - degNow; if (d < 0) d += 360;
      $("orbitLegend").textContent = `Now ${degNow.toFixed(1)}¬∞ ‚Üí ETA ${degArr.toFixed(1)}¬∞ ‚Ä¢ Œî ${d.toFixed(1)}¬∞`;
    }

    const curveCanvas = $("curveCanvas"), ctxCur = curveCanvas.getContext("2d");
    function drawCurve(){
      const w = curveCanvas.width = curveCanvas.clientWidth, h = curveCanvas.height = curveCanvas.clientHeight;
      const dest = $("destination").value;
      const arcHeight = Math.max(32, 60 / Math.max(1, lastPhysics?.gf || 0.5));
      const startX = 60, endX = w - 60, baseY = h - 46;

      ctxCur.clearRect(0, 0, w, h);
      ctxCur.beginPath(); ctxCur.arc(startX, baseY, 7, 0, Math.PI * 2); ctxCur.fillStyle = "#3b82f6"; ctxCur.fill();
      ctxCur.fillStyle = "#cfe2ff"; ctxCur.fillText("Earth", startX - 20, baseY + 18);
      ctxCur.beginPath(); ctxCur.arc(endX, baseY, 6.5, 0, Math.PI * 2); ctxCur.fillStyle = "#f59e0b"; ctxCur.fill();
      ctxCur.fillStyle = "#cfe2ff"; ctxCur.fillText(dest, endX - 22, baseY + 18);

      ctxCur.beginPath(); ctxCur.moveTo(startX, baseY);
      ctxCur.quadraticCurveTo((startX + endX) / 2, baseY - arcHeight * 3, endX, baseY);
      ctxCur.strokeStyle = "#ef4444"; ctxCur.lineWidth = 2; ctxCur.stroke();

      const t = shipProgress, mx = (startX + endX) / 2, ctrlY = baseY - arcHeight * 3;
      const sx = (1 - t) ** 2 * startX + 2 * (1 - t) * t * mx + t ** 2 * endX;
      const sy = (1 - t) ** 2 * baseY + 2 * (1 - t) * t * ctrlY + t ** 2 * baseY;
      ctxCur.beginPath(); ctxCur.arc(sx, sy, 6, 0, Math.PI * 2);
      ctxCur.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctxCur.shadowColor = ctxCur.fillStyle; ctxCur.shadowBlur = 8; ctxCur.fill(); ctxCur.shadowBlur = 0;

      const arrow=(x, y, dx, dy, color) => {
        const L = Math.hypot(dx, dy) || 1; const ux = dx / L, uy = dy / L; const ex = x + dx, ey = y + dy;
        ctxCur.beginPath(); ctxCur.moveTo(x, y); ctxCur.lineTo(ex, ey); ctxCur.strokeStyle = color; ctxCur.lineWidth = 2; ctxCur.stroke();
        ctxCur.beginPath(); ctxCur.moveTo(ex, ey); ctxCur.lineTo(ex - 6 * ux + 3 * uy, ey - 6 * uy - 3 * ux); ctxCur.lineTo(ex - 6 * ux - 3 * uy, ey - 6 * uy + 3 * ux); ctxCur.closePath(); ctxCur.fillStyle = color; ctxCur.fill();
      };
      const f = $("frontPct").value / 100, r = $("rearPct").value / 100, lr = $("lrBias").value / 100, ud = $("udBias").value / 100;
      const k = Math.min(44, h * 0.18);
      arrow(sx, sy, 0, -k * r, "#22c55e");
      arrow(sx, sy, 0, k * f, "#f97316");
      arrow(sx, sy, k * lr, 0, "#8b5cf6");
      arrow(sx, sy, 0, -k * ud, "#38bdf8");

      $("curveLegend").textContent = `Rear ${Math.round(r * 100)}% ‚Ä¢ Front ${Math.round(f * 100)}% ‚Ä¢ LR ${Math.round(lr * 100)}% ‚Ä¢ UD ${Math.round(ud * 100)}% ‚Ä¢ Œ≤ ${(lastPhysics?.beta || 0).toFixed(2)}`;
    }

    (function(){
      const cvs=$("starfieldCanvas"); if(!cvs) return; const ctx2=cvs.getContext("2d");
      const W2=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H2=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX2=()=>W2()/2, CY2=()=>H2()/2;
      const STAR_COUNT=180; const stars=new Array(STAR_COUNT).fill(0).map(_=>({x:(Math.random()*2-1)*W2(),y:(Math.random()*2-1)*H2(),z:Math.random(),tw:Math.random()*Math.PI*2}));
      let raf2=null, last2=performance.now(), paused2=false;
      function recycle(s){ s.x=(Math.random()*2-1)*W2(); s.y=-0.55*H2(); s.z=Math.random(); s.tw=Math.random()*Math.PI*2; }
      function dopplerShift(base){ const beta=lastPhysics?.beta||0; const z=Math.sqrt((1+beta)/(1-beta)); const r=Math.max(0,Math.min(255,200/z)), g=Math.max(0,Math.min(255,220/Math.sqrt(z))), b=255; const a=0.22+0.5*base; return {r,g,b,a}; }
      function step2(dt){ const flow=26*(1+1.2*(lastPhysics?.beta||0)); for(const s of stars){ const v=flow*(1.4-0.9*s.z); s.y+=v*dt; s.tw+=3.0*dt; if(s.y>0.60*H2()) recycle(s); } }
      function draw2(){
        ctx2.clearRect(0,0,W2(),H2()); const beta=lastPhysics?.beta||0, streak=1+(beta*1.8),cx=CX2(),cy=CY2(); ctx2.save(); ctx2.translate(cx,cy); for(const s of stars){ const sz=1+1.5*(1-s.z), a=0.35+0.55*Math.abs(Math.sin(s.tw)); const col=dopplerShift(a); ctx2.fillStyle=`rgba(${col.r|0},${col.g|0},${col.b|0},${col.a.toFixed(2)})`; ctx2.fillRect(s.x,s.y,sz,sz); ctx2.beginPath(); ctx2.moveTo(s.x,s.y); ctx2.lineTo(s.x, s.y - streak*7*(1-s.z)); ctx2.strokeStyle=`rgba(${(col.r+30|0)},${(col.g+30|0)},${(col.b+30|0)},${(0.18+0.35*(1-s.z)).toFixed(2)})`; ctx2.lineWidth=1; ctx2.stroke(); } ctx2.restore();
        const g2=ctx2.createRadialGradient(cx,cy,32, cx,cy,52); g2.addColorStop(0,"rgba(120,220,255,0.16)"); g2.addColorStop(1,"rgba(80,180,255,0.03)"); ctx2.fillStyle=g2; ctx2.beginPath(); ctx2.arc(cx,cy,52,0,Math.PI*2); ctx2.fill(); ctx2.beginPath(); ctx2.arc(cx,cy,40,0,Math.PI*2); ctx2.strokeStyle="#7dd3fc"; ctx2.lineWidth=1.2; ctx2.stroke(); ctx2.save(); ctx2.translate(cx,cy+3); ctx2.beginPath(); ctx2.moveTo(0,-16*0.9); ctx2.lineTo(11*0.55,16*0.8); ctx2.lineTo(-11*0.55,16*0.8); ctx2.closePath(); ctx2.fillStyle="#cfe2ff"; ctx2.fill(); ctx2.restore();
        $("starfieldLegend").textContent=`Visual Œ≤=${beta.toFixed(2)} ‚Ä¢ gf=${(lastPhysics?.gf||0).toFixed(2)} ‚Ä¢ cap=${(lastPhysics?.vcap_c||0).toFixed(2)}c`;
      }
      function loop2(n){ if(paused2)return; const dt=Math.min(0.05,(n-last2)/1000); last2=n; step2(dt); draw2(); raf2=requestAnimationFrame(loop2); }
      window.starfieldControl={ start(){ if(paused2){ paused2=false; last2=performance.now(); raf2=requestAnimationFrame(loop2);} }, stop(){ paused2=true; if(raf2) cancelAnimationFrame(raf2);} };
      paused2=false; last2=performance.now(); raf2=requestAnimationFrame(loop2);
    })();

    (function(){
      const cvs=$("debrisCanvas"); if(!cvs) return; const ctx3=cvs.getContext("2d");
      const W3=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H3=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX3=()=>W3()/2, CY3=()=>H3()/2;
      let last3=performance.now(), raf3=null, paused3=false;
      const bubble={r:46}, debris=[], MAX_DEBRIS=24;
      function seed(){ debris.length=0; for(let i=0;i<MAX_DEBRIS;i++){ const ang=Math.random()*Math.PI*2, R=Math.max(W3(),H3())*0.55+Math.random()*100; debris.push({ x:CX3()+R*Math.cos(ang), y:CY3()+R*Math.sin(ang), vx:-(38+Math.random()*55)*Math.cos(ang), vy:-(38+Math.random()*55)*Math.sin(ang), q:(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7), alive:true }); } }
      seed();
      function alloc(){ const e=engineInputs(), tot=e.reactorMW||5000, g=lastPhysics?.gf||0, pre=Math.min(.50,.25+.08*g), skin=Math.min(.35,.20+.10*g), grid=Math.max(.10,1-pre-skin); return { MW:{pre:pre*tot, skin:skin*tot, grid:grid*tot}, frac:{pre,skin,grid} }; }
      function step3(dt){ const {MW,frac}=alloc(), preF=6*Math.sqrt(MW.pre+1), skinB=4*Math.sqrt(MW.skin+1); for(const d of debris){ if(!d.alive)continue; const dx=d.x-CX3(), dy=d.y-CY3(), r=Math.hypot(dx,dy)+1e-6, nx=dx/r, ny=dy/r; if(ny<-0.2){ d.vx+=nx*preF*dt*0.08; d.vy+=ny*preF*dt*0.08; } if(r<bubble.r*1.5 && Math.abs(d.q)>0){ const kick=skinB*0.12*dt, tx=-ny, ty=nx; d.vx+=tx*kick*Math.sign(d.q); d.vy+=ty*kick*Math.sign(d.q); } if(r<bubble.r*1.06){ const hitProb=Math.min(0.95,0.25+frac.grid*0.8); const ang=Math.atan2(dy,dx); if(window.shieldBox && window.shieldBox.hit){ const intensity=Math.min(1,(Math.hypot(d.vx,d.vy)/110)); window.shieldBox.hit(ang,intensity); } if(Math.random()<hitProb) d.alive=false; } d.x+=d.vx*dt; d.y+=d.vy*dt; if(!d.alive || d.x<-180 || d.x>W3()+180 || d.y<-180 || d.y>H3()+180){ if(Math.random()<0.02){ const a=Math.random()*Math.PI*2, R=Math.max(W3(),H3())*0.55+Math.random()*100; d.x=CX3()+R*Math.cos(a); d.y=CY3()+R*Math.sin(a); d.vx=-(38+Math.random()*55)*Math.cos(a); d.vy=-(38+Math.random()*55)*Math.sin(a); d.q=(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7); d.alive=true; } } } const ahead=debris.filter(d=>d.alive && d.y<CY3()-bubble.r*1.4 && Math.abs(d.x-CX3())<bubble.r*1.1); const hold=ahead.length>6, adjust=!hold && ahead.length>3; let msg=`Defense MW ‚Äî Pre:${MW.pre.toFixed(0)} | Skin:${MW.skin.toFixed(0)} | Grid:${MW.grid.toFixed(0)} `; msg += hold?"‚Ä¢ HOLD":"‚Ä¢ "+(adjust?"ADJUST":"CLEAR"); $("debrisLegend").textContent=msg; if(hold) setLight($("lightNav"),"warn"); }
      function draw3(){ const cx=CX3(), cy=CY3(); ctx3.clearRect(0,0,W3(),H3()); ctx3.beginPath(); ctx3.arc(cx,cy,bubble.r,0,Math.PI*2); ctx3.strokeStyle="#7dd3fc"; ctx3.lineWidth=1.3; ctx3.stroke(); ctx3.beginPath(); ctx3.moveTo(cx,cy); ctx3.arc(cx,cy, bubble.r*2.2, -Math.PI*0.95, -Math.PI*0.05, false); ctx3.closePath(); ctx3.fillStyle="rgba(252,211,77,.15)"; ctx3.fill(); ctx3.beginPath(); ctx3.arc(cx,cy,bubble.r*1.15,0,Math.PI*2); ctx3.strokeStyle="rgba(56,189,248,.18)"; ctx3.lineWidth=8; ctx3.stroke(); ctx3.beginPath(); ctx3.arc(cx,cy,3.3,0,Math.PI*2); ctx3.fillStyle="#cfe2ff"; ctx3.fill(); for(const d of debris){ if(d.alive){ ctx3.fillStyle=Math.abs(d.q)>0?"#fca5a5":"#e5e7eb"; ctx3.beginPath(); ctx3.arc(d.x,d.y,1.6,0,Math.PI*2); ctx3.fill(); } } }
      function loop3(n){ if(paused3)return; const dt=Math.min(0.05,(n-last3)/1000); last3=n; step3(dt); draw3(); raf3=requestAnimationFrame(loop3); }
      window.debrisControl={ start(){ if(paused3){ paused3=false; last3=performance.now(); raf3=requestAnimationFrame(loop3);} }, stop(){ paused3=true; if(raf3) cancelAnimationFrame(raf3);} };
      paused3=false; last3=performance.now(); raf3=requestAnimationFrame(loop3);
    })();

    (function(){
      const cvs=$("shieldCanvas"); if(!cvs) return; const ctx4=cvs.getContext("2d");
      const W4=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H4=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX4=()=>W4()/2, CY4=()=>H4()/2;
      const SECT=12; const sectors=new Array(SECT).fill(1); let flashes=[];
      let paused4=false, raf4=null, last4=performance.now();
      function bubbleRadius(){ return 36*Math.min(1.3,0.82+0.05*Math.max(1,Number($("warpSpeed").value)||1)); }
      function repair(dt){ for(let i=0;i<SECT;i++){ sectors[i]=Math.min(1,sectors[i]+0.08*dt); } flashes=flashes.filter(f=>{ f.t-=dt; return f.t>0; }); }
      function draw4(){
        const cx=CX4(), cy=CY4(), R=bubbleRadius(); cvs.width=W4(); cvs.height=H4();
        ctx4.clearRect(0,0,cvs.width,cvs.height);
        const glow=ctx4.createRadialGradient(cx,cy,R*.6, cx,cy,R+12);
        glow.addColorStop(0,`rgba(120,220,255,${0.1+0.12*sectors.reduce((a,b)=>a+b,0)/SECT})`);
        glow.addColorStop(1,"rgba(80,180,255,0.02)");
        ctx4.fillStyle=glow; ctx4.beginPath(); ctx4.arc(cx,cy,R+12,0,Math.PI*2); ctx4.fill();
        for(let i=0;i<SECT;i++){
          const t0=(i/SECT)*Math.PI*2, t1=((i+1)/SECT)*Math.PI*2, s=sectors[i];
          ctx4.beginPath(); ctx4.arc(cx,cy,R,t0,t1);
          ctx4.strokeStyle=s>0.66?"#7dd3fc":s>0.33?"#facc15":"#ef4444";
          ctx4.lineWidth=2.2+2.2*s; ctx4.stroke();
        }
        ctx4.beginPath(); ctx4.moveTo(cx, cy-R*0.65); ctx4.lineTo(cx+9, cy+10); ctx4.lineTo(cx-9, cy+10); ctx4.closePath(); ctx4.fillStyle="#cfe2ff"; ctx4.fill();
        for(const f of flashes){
          const a=Math.max(0,Math.min(1,f.t/.25));
          ctx4.beginPath(); ctx4.arc(f.x,f.y, 5+9*(1-a), 0,Math.PI*2);
          ctx4.strokeStyle=`rgba(255,255,255,${a})`; ctx4.lineWidth=1.8; ctx4.stroke();
        }
        $("shieldLegend").textContent=`Shield ${(sectors.reduce((a,b)=>a+b,0)/SECT*100).toFixed(0)}% ‚Ä¢ R ${R.toFixed(1)} ‚Ä¢ Œ≤ ${(lastPhysics?.beta||0).toFixed(2)}`;
      }
      function hit(theta,intensity){
        const rot=theta+Math.PI/2;
        let idx=Math.floor((((rot%(2*Math.PI))+2*Math.PI)%(2*Math.PI))/(2*Math.PI)*SECT);
        idx=Math.max(0,Math.min(SECT-1,idx));
        sectors[idx]=Math.max(0,sectors[idx]-0.35*Math.max(0.2,intensity));
        const R=bubbleRadius();
        flashes.push({x:CX4()+R*Math.cos(theta), y:CY4()+R*Math.sin(theta), t:.25});
      }
      function loop4(n){ if(paused4)return; const dt=Math.min(0.05,(n-last4)/1000); last4=n; repair(dt); draw4(); raf4=requestAnimationFrame(loop4); }
      window.shieldBox={ start(){ if(paused4){ paused4=false; last4=performance.now(); raf4=requestAnimationFrame(loop4);} }, stop(){ paused4=true; if(raf4) cancelAnimationFrame(raf4);} , hit };
      paused4=false; last4=performance.now(); raf4=requestAnimationFrame(loop4);
    })();
  </script>

  <!-- PART 3: CONTROLS, ANIMATION & INIT -->
  <script>
    const clocks=[
      { id:"C1", location:"Biometric", purpose:"Crew/Local", drift:0 },
      { id:"C2", location:"Warp Edge", purpose:"Phase Monitor", drift:3 },
      { id:"C3", location:"NavCore",   purpose:"Navigation", drift:0 },
      { id:"C4", location:"CST Earth", purpose:"Master Anchor", drift:0 },
      { id:"C5", location:"DriftEye",  purpose:"Diagnostics", drift:-6 }
    ];
    function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
    function renderClockCards(arrISTstr, arrCSTms){
      const grid=$("clockGrid"); grid.innerHTML="";
      const base=Date.now(); let total=0;
      clocks.forEach(c=>{
        if(simulationRunning) c.drift += Math.random()*2 - 1;
        const local=base + c.drift, d=c.drift.toFixed(2); total += Math.abs(c.drift);
        let status="good", label="‚úÖ Synced"; 
        if(Math.abs(c.drift)>5){ status="warn"; label="‚ö† Drift"; }
        if(Math.abs(c.drift)>10){ status="bad"; label="‚ùå Unsafe"; }
        const card=document.createElement("div"); card.className="clockCard";
        card.innerHTML=`
          <div class="clockHdr">
            <div class="clockTitle">${c.id} ‚Ä¢ ${c.location}</div>
            <div class="status ${status}">${label}</div>
          </div>
          <div class="kv">
            <div>Purpose</div><div>${c.purpose}</div>
            <div>CST</div><div>${fmtClock(base)}</div>
            <div>Local</div><div>${fmtClock(local)}</div>
            <div>Œî</div><div>${d} ms</div>
            <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
            <div>Arrival IST</div><div>${arrISTstr}</div>
          </div>`;
        grid.appendChild(card);
      });
      return total/clocks.length;
    }

    function updateAllStatus(){
      const {eta, dAU, v} = computeETASeconds();
      const base = Date.now(), arrCST = base + eta * 1000;
      const {istYears, spy} = IST_snapshot();
      const arrIST = istYears + eta/spy;
      const arrISTstr = `${(arrIST/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(arrIST).toLocaleString()} y`;
      const avgDrift = renderClockCards(arrISTstr, arrCST);
      const warp = Number($("warpSpeed").value||1), dest = $("destination").value;
      const etaStr = eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
      $("beacon").textContent = `üõ∞Ô∏è Warp ${warp} ‚Üí ${dest} | ${dAU.toFixed(3)} AU | ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Drift ${avgDrift.toFixed(2)} ms`;
      flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});
    }

    const flightLog=[];
    const rootEl=document.documentElement, scaleEl=$("uiScale");
    function applyScale(){
      const pct=Number(scaleEl.value||85);
      try{ localStorage.setItem('uiScalePct',String(pct)); }catch{}
      rootEl.style.setProperty('--ui-scale',(pct/100).toString());
      $("uiScaleVal").textContent=pct+"%";
      drawCurve(); drawOrbitView(); updateAllStatus();
    }

    function startAll(){
      if(simulationRunning) return;
      simulationRunning=true; shipArrived=false; shipProgress=0; tone("good");
      lastFrameTime=performance.now();
      driftInterval=setInterval(updateAllStatus,700);
      beaconInterval=setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); },2000);
      orbitInterval=setInterval(()=>{ updateOrbitTable(); drawOrbitView(); },1200);
      animationFrame=requestAnimationFrame(animate);
      if(window.starfieldControl) window.starfieldControl.start();
      if(window.debrisControl) window.debrisControl.start();
      if(window.shieldBox) window.shieldBox.start();
    }

    function stopAll(){
      simulationRunning=false;
      clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval);
      cancelAnimationFrame(animationFrame);
      stepEngineDynamics(0.2,false); tone("warn");
      if(window.starfieldControl) window.starfieldControl.stop();
      if(window.debrisControl) window.debrisControl.stop();
      if(window.shieldBox) window.shieldBox.stop();
    }

    function resetAll(){
      stopAll();
      shipProgress=0; shipArrived=false; clocks.forEach(c=>c.drift=0);
      tIST0=performance.now();
      engineState.t=0; engineState.temp=0; engineState.sag=0; engineState.containNeed=0.22; engineState.jitter=0;
      $("beacon").textContent="‚è≥ Waiting‚Ä¶";
      updateOrbitTable(); drawCurve(); drawOrbitView(); updateAllStatus();
    }

    function exportLog(){
      const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"], ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
      const csv=rows.map(r=>r.join(",")).join("\n");
      const blob=new Blob([csv],{type:"text/csv"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click();
    }

    $("exportBtn").onclick=exportLog;
    $("startBtn").onclick=startAll;
    $("stopBtn").onclick=stopAll;
    $("resetBtn").onclick=resetAll;

    ["warpSpeed","warpExp","warpScale","destination","calibration","istDay0Years","baselineDaysPerYear","reactorMW","frontPct","rearPct","lrBias","udBias","intakeMode","soundOn","uiScale"].forEach(id=>{
      const el=$(id); if(!el) return;
      el.addEventListener("input",()=>{
        if(id==="uiScale") applyScale();
        if(id==="calibration") setCalibration(el.value);
        tIST0=performance.now();
        drawCurve(); drawOrbitView(); updateAllStatus();
      });
    });

    function animate(){
      if(!simulationRunning || shipArrived) return;
      const now=performance.now(), dt=(now-lastFrameTime)/1000; lastFrameTime=now;
      stepEngineDynamics(dt,true);
      const {eta,v}=computeETASeconds();
      const speedGain=(v/C_MPS);
      shipProgress += 0.00050*Math.pow(Math.max(1,Number($("warpSpeed").value)||1),0.82)*(0.6+0.8*speedGain);
      if(shipProgress>=1){ shipProgress=1; shipArrived=true; tone("good"); stopAll(); }
      drawCurve(); drawOrbitView();
      animationFrame=requestAnimationFrame(animate);
    }

    function updateOrbitTable(){
      const {istYears,dpy}=IST_snapshot();
      const dest=$("destination").value;
      const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
      const eY=planetAgeYears("Earth",istYears), eD=eY*dpy;
      const eO=orbitsFor("Earth",eD)||{completed:0,frac:0,daysInto:0,yearLen:365.256};
      const pY=planetAgeYears(dest,istYears), pD=pY*dpy;
      const pO=orbitsFor(dest,pD)||{completed:0,frac:0,daysInto:0,yearLen:orbitalDays[dest]||0};
      const {eta,dAU,v}=computeETASeconds();
      const etaStr=eta>=3600? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
      const card=(title,lines)=>`
        <div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
          <div style="font-weight:600;margin-bottom:4px">${title}</div>
          ${lines.map(t=>`<div class="stat">${t}</div>`).join("")}
        </div>`;
      $("orbit-rows").innerHTML=[
        card("Sun",[`${(sY/1e9).toFixed(6)} Ga`,`${Math.floor(sY).toLocaleString()} y`,`${Math.floor(sD).toLocaleString()} d`]),
        card("Earth",[`Orbits: ${eO.completed.toLocaleString()}`,`Progress: <span class="pill">${(eO.frac*100).toFixed(1)}%</span>`,`Day ${Math.floor(eO.daysInto)} / ${Math.floor(eO.yearLen)}`]),
        card(dest,[`Age: ${(pY/1e9).toFixed(6)} Ga`,`Orbits: ${pO.completed.toLocaleString()}`,`Day ${Math.floor(pO.daysInto)} / ${Math.floor(pO.yearLen)}`]),
        card("Trip",[`Dist: ${dAU.toFixed(3)} AU`,`v: ${(v/C_MPS).toFixed(2)} c`,`ETA: ${etaStr}`])
      ].join("");
    }

    function moveEl(el,target){ if(el&&target) target.appendChild(el); }
    function setPair(pair){
      const paneTop=$("paneTop"), paneBottom=$("paneBottom");
      paneTop.innerHTML=""; paneBottom.innerHTML="";
      const curve=$("curveCanvas"), cL=$("curveLegend");
      const star=$("starfieldCanvas"), sL=$("starfieldLegend");
      const shield=$("shieldCanvas"), shL=$("shieldLegend");
      if(pair==="traj-star"){
        moveEl(curve,paneTop); moveEl(cL,paneTop);
        moveEl(star,paneBottom); moveEl(sL,paneBottom);
      }else if(pair==="traj-shield"){
        moveEl(curve,paneTop); moveEl(cL,paneTop);
        moveEl(shield,paneBottom); moveEl(shL,paneBottom);
      }else{
        moveEl(star,paneTop); moveEl(sL,paneTop);
        moveEl(shield,paneBottom); moveEl(shL,paneBottom);
      }
      requestAnimationFrame(()=>{ window.dispatchEvent(new Event('resize')); drawCurve(); });
    }

    const splitHero=$("splitHero"), splitVertBtn=$("splitVertBtn"), splitHorzBtn=$("splitHorzBtn");
    function setOrientation(mode){
      splitHero.classList.remove('vertical','horizontal');
      splitHero.classList.add(mode);
      splitVertBtn.classList.toggle('active', mode==='vertical');
      splitHorzBtn.classList.toggle('active', mode==='horizontal');
      requestAnimationFrame(()=>window.dispatchEvent(new Event('resize')));
    }

    (function pairButtonsInit(){
      const buttons=[...document.querySelectorAll('.heroPairBtn')];
      buttons.forEach(btn=>btn.addEventListener('click',()=>{
        buttons.forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        setPair(btn.dataset.pair);
      }));
    })();

    (function splitOrientationInit(){
      splitVertBtn.addEventListener('click',()=>setOrientation('vertical'));
      splitHorzBtn.addEventListener('click',()=>setOrientation('horizontal'));
    })();

    (function splitDragInit(){
      let dragging=false;
      function setSplitFromPointer(clientX,clientY){
        const rect=splitHero.getBoundingClientRect();
        const isVertical=splitHero.classList.contains('vertical');
        let rel=isVertical?(clientY-rect.top)/rect.height:(clientX-rect.left)/rect.width;
        rel=Math.max(0,Math.min(1,rel));
        const pct=Math.max(20,Math.min(80,Math.round(rel*100)));
        document.documentElement.style.setProperty('--hero-split',pct);
        window.dispatchEvent(new Event('resize'));
      }
      const handle=$("splitHandle");
      handle.addEventListener('mousedown',e=>{ dragging=true; e.preventDefault(); });
      window.addEventListener('mousemove',e=>{ if(!dragging)return; setSplitFromPointer(e.clientX,e.clientY); });
      window.addEventListener('mouseup',()=>{ if(dragging){ dragging=false; window.dispatchEvent(new Event('resize')); } });
      handle.addEventListener('touchstart',e=>{ dragging=true; e.preventDefault(); },{passive:false});
      window.addEventListener('touchmove',e=>{ if(!dragging)return; const t=e.touches[0]; setSplitFromPointer(t.clientX,t.clientY); },{passive:false});
      window.addEventListener('touchend',()=>{ if(dragging){ dragging=false; window.dispatchEvent(new Event('resize')); } });
    })();

    function updateModeAlternator(){
      const S=Number($("ma_S").value||0), r=Number($("ma_r").value||0), f=Number($("ma_f").value||0);
      const phi_ms=Number($("ma_phi").value||0), tau_ms=Number($("ma_tau").value||60), qi=$("ma_qi").checked;
      const eps_cas=1.0, eps_sq=1.0, k_payback=qi?1.4:1.0;
      const rho_cas=-eps_cas*S, rho_neg=-eps_sq*r, rho_pos=+k_payback*eps_sq*r;
      $("ma_S_lbl").textContent=S.toFixed(2);
      $("ma_r_lbl").textContent=r.toFixed(2);
      const legend=`Casimir-like offset: ${rho_cas.toFixed(2)} ‚Ä¢ Neg lobe: ${rho_neg.toFixed(2)} ‚Ä¢ Payback: +${rho_pos.toFixed(2)} ‚Ä¢ œÑ=${tau_ms} ms ‚Ä¢ œÜ=${phi_ms} ms ‚Ä¢ f=${f.toFixed(2)} Hz ‚Ä¢ QI ${qi?"ON":"OFF"}`;
      $("ma_legend").textContent=legend;
    }

    function updatePulseRadiation(){
      const Ep=Number($("pr_Ep").value||0), freq=Number($("pr_f").value||0);
      const R=Math.max(0,Math.min(1,Number($("pr_R").value||0)));
      const chi=Math.max(0,Math.min(1,Number($("pr_chi").value||0))), A=Math.max(1e-6,Number($("pr_A").value||1));
      const Ar=Math.max(1e-6,Number($("pr_Ar").value||10)), eps=Math.max(0.01,Math.min(0.99,Number($("pr_eps").value||0.8)));
      const mship=Math.max(1,Number($("pr_m").value||50000)), Tsp=Math.max(0,Number($("pr_Tspace").value||3));

      const Jgamma = chi * (1+R) * Ep / C_MPS;
      const Favg   = Jgamma * freq;
      const a      = Favg / mship;
      const dV1h   = a * 3600;
      const Pavg   = Ep * freq;
      const Iavg   = Pavg / A;
      const Pabs   = chi * (1 - R) * Pavg;
      const Teq4   = (Pabs / (SIGMA_SB * eps * Ar)) + Math.pow(Tsp,4);
      const Teq    = Math.pow(Math.max(0,Teq4), 0.25);

      $("pr_legend").innerHTML =
        `Per-pulse impulse J<sub>Œ≥</sub>=${Jgamma.toExponential(3)} N¬∑s ‚Ä¢ ` +
        `F<sub>avg</sub>=${Favg.toExponential(3)} N ‚Ä¢ a=${(a*1e3).toFixed(3)} mm/s¬≤ ‚Ä¢ Œîv/hr=${dV1h.toFixed(3)} m/s<br>` +
        `P<sub>avg</sub>=${Pavg.toFixed(1)} W ‚Ä¢ I<sub>avg</sub>=${Iavg.toFixed(1)} W/m¬≤ ‚Ä¢ T<sub>rad,eq</sub>‚âà${Teq.toFixed(1)} K`;
    }

    window.addEventListener('resize',()=>{ drawCurve(); drawOrbitView(); updateAllStatus(); });
    window.onload=()=>{
      try{ const saved=localStorage.getItem('uiScalePct'); if(saved){ $("uiScale").value=saved; }}catch{}
      setCalibration($("calibration").value||"off");
      setPair('traj-star');
      setOrientation('vertical');
      ["ma_S","ma_r","ma_f","ma_phi","ma_tau","ma_qi"].forEach(id=>{ const el=$(id); if(el) el.addEventListener("input",updateModeAlternator); });
      updateModeAlternator();
      ["pr_Ep","pr_f","pr_R","pr_chi","pr_A","pr_Ar","pr_eps","pr_m","pr_Tspace"].forEach(id=>{ const el=$(id); if(el) el.addEventListener("input",updatePulseRadiation); });
      updatePulseRadiation();
      drawCurve();
      drawOrbitView();
      updateOrbitTable();
      updateAllStatus();
      applyScale();
    };
  </script>
</body>
</html>
