<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FTL Nav Console — CST + Solver (Grouped + Wider)</title>
<style>
:root{--bg:#060a16;--card:#0f1630;--ink:#eaf0ff;--muted:#9fb0e0;--good:#3dd07f;--warn:#ffd166;--bad:#ef476f;--grid:16px}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#060a16,#0b1233);color:var(--ink);font:16.5px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial}
header{padding:26px 28px;border-bottom:1px solid rgba(255,255,255,.06);position:sticky;top:0;background:rgba(8,12,30,.78);backdrop-filter:blur(8px)}
.wrap{padding:26px;max-width:1900px;margin:0 auto}
.grid{display:grid;grid-template-columns:repeat(12,1fr);gap:var(--grid)}
.card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:18px;padding:20px;box-shadow:0 10px 28px rgba(0,0,0,.28)}
.card h2{margin:0 0 10px 0;font-size:19px}
.row{display:grid;
  grid-template-columns:340px 96px 1.2fr 0.9fr 0.9fr 1fr 1fr 0.9fr 0.9fr 0.9fr 0.9fr 1.1fr 1fr;
  gap:12px;align-items:flex-start;padding:12px 0;border-bottom:1px dashed rgba(255,255,255,.08)}
.row.header{font-weight:700;color:#cbd5ff;border-bottom:1px solid rgba(255,255,255,.14);position:sticky;top:86px;background:linear-gradient(180deg,#0f1630,rgba(15,22,48,.6));z-index:5}
.row > div{min-height:24px}
.group{padding:10px 12px;margin:10px 0;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);font-weight:700;color:#b9c7ff}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:1.06em;word-break:break-word}
.pill{display:inline-block;padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.08);font-size:.95em}
.ok{color:var(--good)}.warn{color:var(--warn)}.bad{color:var(--bad)}
.small{font-size:13.3px;color:var(--muted)}
button{background:#19234d;color:#eaf0ff;border:1px solid rgba(255,255,255,.16);padding:8px 12px;border-radius:12px;cursor:pointer;white-space:nowrap}
button:hover{background:#1e2a5c}
input,select{background:#0b1233;color:#eaf0ff;border:1px solid rgba(255,255,255,.16);padding:8px 10px;border-radius:9px}
.flex{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.banner{margin:12px 0;padding:12px 14px;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12)}
/* make the big panel itself taller with inner scrolling for the table */
.scrolly{max-height:60vh;overflow:auto;padding-right:6px}
</style>
</head>
<body>
<header>
  <h1>FTL Nav Console — CST + Solver</h1>
  <div class="small">Targets from <code>targets.json</code> (top-level keys: <b>planets</b>, <b>moons</b>, <b>stars</b>, <b>galaxies</b>). Live vectors via NASA Horizons; Gaia for stellar context. Includes a <b>CST arrival solver</b> and <b>bubble shaping</b> for Δ<sub>warp</sub>.</div>
</header>

<div class="wrap grid">
  <section class="card" style="grid-column: span 7">
    <h2>Quantum Clocks</h2>
    <div class="grid" style="grid-template-columns: repeat(3,1fr); gap:14px">
      <div><div class="small">Local Time (America/Chicago)</div><div class="mono" id="localTime">—</div><div class="small" id="tzName">—</div></div>
      <div><div class="small">Interstellar Time (demo)</div><div class="mono" id="interstellarYear">—</div></div>
      <div><div class="small">Stardate (demo)</div><div class="mono" id="stardate">—</div></div>
    </div>
    <div class="small" style="margin-top:6px">CST↔UTC offset: <span id="cstOffset">—</span> • UTC epoch: <span class="mono" id="utcEpoch">—</span></div>
    <div class="banner mono" id="statusBanner">Loading targets.json…</div>
  </section>

  <section class="card" style="grid-column: span 5">
    <h2>Solver Settings</h2>
    <div class="flex">
      <label>H₀ (km/s/Mpc)<input id="h0" type="number" step="0.1" value="70" style="width:110px"></label>
      <label>Tolerance (km)<input id="tolKm" type="number" step="100" value="10000" style="width:140px"></label>
      <label>Max Horizon Δt (s)<input id="maxDt" type="number" step="1" value="86400" style="width:140px"></label>
      <span class="small">Ship exits when |error| ≤ tolerance.</span>
    </div>
  </section>

  <section class="card" style="grid-column: span 12">
    <h2>Targets + CST Solver</h2>
    <div class="row header">
      <div>Name</div><div>Type</div><div>Live Vector (AU)</div><div>Dist. Sun</div><div>Dist. Earth</div>
      <div>Proper Motion</div><div>Radial Vel.</div><div>Distance</div><div>Rec. Vel</div>
      <div>Uncertainty</div><div>Last Update</div><div>Status</div><div>Actions</div>
    </div>
    <div id="targets" class="scrolly"></div>
    <div class="small" style="margin-top:10px">Actions → <b>Solve T<sub>c</sub></b> (closest approach) and <b>Shape Bubble</b> (∫(γ⁻¹−1)dt for Δ<sub>warp</sub>).</div>
  </section>

  <section class="card" style="grid-column: span 12">
    <h2>Math (implemented)</h2>
    <div class="small">
      Arrival: Pₐ(T)=P₀+Vₜ·T+Δₑₓₚ(T)+Δ𝑤𝑎𝑟𝑝(T)
      <br/>Closest-approach (no Δ terms): T* = − (R·V) / |V|², with R = Pₜ₀ − P₀ and V = Vₜ − Vref.
      <br/>Expansion (demo): vrec = H₀·D (Mpc). Warp shaping: I = ∫(γ⁻¹−1)dt = Δ𝑤𝑎𝑟𝑝 / c ; flat profile → (γ⁻¹−1) ≈ I/T.
    </div>
  </section>
</div>

<script>
/******** CONFIG ********/
const TARGETS_URL = "targets.json";
const HORIZONS_ENDPOINT = "https://ssd-api.jpl.nasa.gov/horizons.api";
const GAIA_TAP = "https://mast.stsci.edu/vo-tap/api/v0.1/gaiadr3/tap/sync";
const CORS_PROXY = ""; // set to your proxy base + ?url=

/******** TIME & UNITS ********/
const AU_KM = 149_597_870.700, KM_PER_MI = 1.609344, MI_PER_AU = AU_KM/KM_PER_MI;
const KM_PER_MPC = 3.085677581e19, C_KM_S = 299_792.458;
function fmt(n,d=6){return Number(n).toFixed(d)}
function fmtAU(x){return fmt(x,6)+" AU"}
function fmtMi(x){return Intl.NumberFormat().format(Math.round(x))+" miles"}
function fmtISO(d){return new Date(d).toISOString().replace('.000Z','Z')}
function chicagoNow(){const o={timeZone:'America/Chicago',hour12:true,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'};return new Intl.DateTimeFormat(undefined,o).format(new Date())}
function tzLabel(){try{return Intl.DateTimeFormat().resolvedOptions().timeZone}catch{return'Local TZ'}}
function interstellarYear(){const s=Date.now()/1000;const y=57_800_000+(s/31557600)*100;return `Year ~${y.toFixed(2)}`}
function stardate(){const ms=Date.now();const base=Date.UTC(2323,0,1);const sd=1000*((ms-base)/31557600000);return `Stardate ${(sd/10).toFixed(1)}`}
function cstToUtcOffset(){const off=-new Date().getTimezoneOffset()/60;const s=off>=0?'+':'';return `${s}${off.toFixed(0)} h`}

/******** VECTORS & MATH ********/
function norm(v){return Math.hypot(...v)}
function sub(a,b){return a.map((v,i)=>v-b[i])}
function add(a,b){return a.map((v,i)=>v+b[i])}
function scale(a,s){return a.map(v=>v*s)}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}

async function horizonsVector(command, isoUtc){
  const params=new URLSearchParams({format:'json',COMMAND:command,EPHEM_TYPE:'VECTORS',CENTER:'500@0',TLIST:`'${isoUtc}'`,REF_PLANE:'ECLIPTIC'});
  const url=HORIZONS_ENDPOINT+'?'+params.toString();
  const finalUrl=CORS_PROXY?(CORS_PROXY+encodeURIComponent(url)):url;
  const res=await fetch(finalUrl); if(!res.ok) throw new Error(`Horizons ${res.status}`);
  const j=await res.json(); const vecTxt=j?.result||j?.vectors; if(!vecTxt) throw new Error('No vectors in response');
  const m=vecTxt.match(/X\s*=\s*([\-0-9\.E+]+).*?Y\s*=\s*([\-0-9\.E+]+).*?Z\s*=\s*([\-0-9\.E+]+).*?VX\s*=\s*([\-0-9\.E+]+).*?VY\s*=\s*([\-0-9\.E+]+).*?VZ\s*=\s*([\-0-9\.E+]+)/s);
  if(!m) throw new Error('Parse error');
  const km=[+m[1],+m[2],+m[3]], vkm=[+m[4],+m[5],+m[6]];
  const au=km.map(v=>v/AU_KM), v_au_s=vkm.map(v=>v/AU_KM);
  return {au,km,vkm,v_au_s};
}

/******** GAIA (proper motion) ********/
async function gaiaCone(raDeg,decDeg,radiusDeg=0.2,limit=1){
  const adql=`SELECT TOP ${limit} source_id,ra,dec,parallax,pmra,pmdec,radial_velocity,phot_g_mean_mag
FROM gaiadr3.gaia_source
WHERE 1=CONTAINS(POINT('ICRS', ra, dec), CIRCLE('ICRS', ${raDeg}, ${decDeg}, ${radiusDeg}))
ORDER BY phot_g_mean_mag ASC`;
  const form=new URLSearchParams({QUERY:adql});
  const r=await fetch(GAIA_TAP,{method:'POST',body:form}); if(!r.ok) return [];
  const text=await r.text(); const lines=text.trim().split(/\n+/); if(lines[0]?.includes('<?xml')) return [];
  const header=lines[0].split(/,|\t/);
  return lines.slice(1).map(l=>{const a=l.split(/,|\t/);const o={}; header.forEach((h,i)=>o[h.trim()]=a[i]?a[i].trim():null); return o;});
}

/******** FILTER (alpha-beta) ********/
class AlphaBeta{constructor(a=0.6,b=0.05){this.a=a;this.b=b;this.x=[0,0,0];this.v=[0,0,0];this.ready=false}
  seed(x,v){this.x=[...x];this.v=[...v];this.ready=true}
  update(z,dt){if(!this.ready){this.seed(z,[0,0,0]);return {x:z,v:[0,0,0]}}; const xp=add(this.x,scale(this.v,dt)); const r=sub(z,xp); this.x=add(xp,scale(r,this.a)); this.v=add(this.v,scale(r,this.b/dt)); return {x:[...this.x],v:[...this.v]}}
}

/******** UI + GROUPING ********/
const rowsEl=document.getElementById('targets');
const banner=document.getElementById('statusBanner');
function setBanner(msg,cls){banner.textContent=msg;banner.className='banner mono '+(cls||'')}
let filters=new Map(); let cache=new Map();

const GROUP_ORDER=["planets","moons","stars","galaxies"];
const GROUP_LABEL={planets:"Planets", moons:"Moons", stars:"Stars", galaxies:"Galaxies", other:"Other"};

function addGroupHeader(label){
  const g=document.createElement('div');
  g.className='group';
  g.textContent=label;
  rowsEl.appendChild(g);
}

function makeRow(t){
  const el=document.createElement('div'); el.className='row';
  const id=(t.id||t.name||'target').toString().replace(/\W+/g,'_'); el.id=`row-${id}`;
  el.innerHTML=`
    <div><div><strong>${t.name||'(unnamed target)'}</strong></div><div class="small">${t.id||''}</div></div>
    <div><span class="pill">${t.type||t.group||'—'}</span></div>
    <div class="mono" id="vec-${id}">—</div>
    <div id="sun-${id}">—</div>
    <div id="earth-${id}">—</div>
    <div id="pm-${id}">—</div>
    <div id="rv-${id}">—</div>
    <div id="dist-${id}">—</div>
    <div id="rec-${id}">—</div>
    <div id="unc-${id}">—</div>
    <div class="small" id="upd-${id}">—</div>
    <div class="small" id="status-${id}">pending…</div>
    <div class="flex">
      <button id="solve-${id}">Solve Tc</button>
      <button id="shape-${id}">Shape Bubble</button>
    </div>`;
  rowsEl.appendChild(el);
  document.getElementById(`solve-${id}`).addEventListener('click',()=>solveRow(t,id));
  document.getElementById(`shape-${id}`).addEventListener('click',()=>shapeRow(t,id));
  updateRow(t,id,true);
}

async function updateRow(t,id){
  const g = sel => document.getElementById(sel);
  const vecEl=g(`vec-${id}`), sunEl=g(`sun-${id}`), earthEl=g(`earth-${id}`), pmEl=g(`pm-${id}`),
        rvEl=g(`rv-${id}`), distEl=g(`dist-${id}`), recEl=g(`rec-${id}`), uncEl=g(`unc-${id}`),
        updEl=g(`upd-${id}`), stEl=g(`status-${id}`);
  try{
    const isoUtc=new Date().toISOString();
    const cmd = t?.horizonsId ?? t?.naifId ?? t?.command ?? null;

    if(cmd){
      const vec=await horizonsVector(String(cmd),isoUtc);
      const earth=await horizonsVector('399',isoUtc);
      if(!filters.has(t.name)) filters.set(t.name,new AlphaBeta());
      const f=filters.get(t.name);
      const res=f.update(vec.au,1);
      vecEl.textContent=`[${fmt(res.x[0])}, ${fmt(res.x[1])}, ${fmt(res.x[2])}]`;
      const rSun=norm(res.x); sunEl.textContent=`${fmtAU(rSun)} (${fmtMi(rSun*MI_PER_AU)})`;
      const rEarth=norm(sub(res.x,earth.au)); earthEl.textContent=`${fmtAU(rEarth)} (${fmtMi(rEarth*MI_PER_AU)})`;
      const vmag=norm(vec.vkm); const sigmaKm=vmag*0.5; const sigmaAu=sigmaKm/AU_KM;
      uncEl.textContent=`${sigmaAu.toExponential(2)} AU (~${Math.round(sigmaKm)} km)`;
      updEl.textContent=fmtISO(isoUtc);
      stEl.textContent='live via Horizons'; stEl.classList.add('ok');
      cache.set(t.name,{vec,earth});
    } else {
      vecEl.textContent=(typeof t?.ra==='number' && typeof t?.dec==='number') ? `RA ${t.ra}°, Dec ${t.dec}°` : '—';
      updEl.textContent=fmtISO(isoUtc);
      stEl.textContent='static (add horizonsId/naifId/command for live)'; stEl.classList.add('warn');
    }

    if(typeof t?.ra==='number' && typeof t?.dec==='number'){
      const stars=await gaiaCone(t.ra,t.dec,0.2,1);
      if(stars.length){
        const s=stars[0];
        const pmra=+(s.pmra||0), pmdec=+(s.pmdec||0); pmEl.textContent=`${pmra.toFixed(1)}, ${pmdec.toFixed(1)} mas/yr`;
        const rv=parseFloat(s.radial_velocity||''); rvEl.textContent=isFinite(rv)?`${rv.toFixed(1)} km/s`:'—';
        const px=+(s.parallax||0);
        if(px>0){ const d_pc=1000/px; distEl.textContent=`${d_pc.toFixed(0)} pc`; const vrec=(+document.getElementById('h0').value)*(d_pc/1e6); recEl.textContent=`${vrec.toFixed(3)} km/s`; }
      }
    }
  }catch(e){ stEl.textContent='error: '+e.message; stEl.classList.add('bad'); }
}

function solveRow(t,id){
  const stEl=document.getElementById(`status-${id}`);
  const tolKm=+document.getElementById('tolKm').value;
  const entry=cache.get(t.name); if(!entry){stEl.textContent='solve: no live vectors yet'; stEl.classList.add('warn'); return}
  const {vec,earth}=entry;
  const R0=sub(vec.au,earth.au);        // AU
  const Vrel=sub(vec.v_au_s,earth.v_au_s); // AU/s
  const denom=dot(Vrel,Vrel);
  if(denom===0){stEl.textContent='solve: zero relative velocity'; stEl.classList.add('warn'); return}
  let Tstar=-dot(R0,Vrel)/denom; if(!isFinite(Tstar)||Tstar<0) Tstar=Math.max(0,Tstar||0);
  const errKm=norm(add(R0,scale(Vrel,Tstar)))*AU_KM;
  const ok=errKm<=tolKm;
  stEl.textContent= ok ? `Tc ≈ ${Tstar.toFixed(1)} s (within tol)` : `Tc ≈ ${Tstar.toFixed(1)} s, residual ${Math.round(errKm)} km > tol`;
  stEl.classList.toggle('ok',ok); stEl.classList.toggle('warn',!ok);
  entry.tc=Tstar; entry.residualKm=errKm;
}

function shapeRow(t,id){
  const stEl=document.getElementById(`status-${id}`);
  const entry=cache.get(t.name); if(!entry||!entry.tc){stEl.textContent='shape: run Solve Tc first'; stEl.classList.add('warn'); return}
  const I = (entry.residualKm||0) / C_KM_S; // ∫(γ⁻¹−1)dt = Δwarp/c
  const flat = I / entry.tc;
  stEl.textContent=`Shape: need ∫(γ⁻¹−1)dt ≈ ${I.toExponential(3)} s ⇒ flat (γ⁻¹−1) ≈ ${flat.toExponential(3)}`;
  stEl.classList.add('ok');
}

/******** TARGETS LOADER supporting sub-categories ********/
function normalizeTargets(raw){
  // case 1: array of items
  if(Array.isArray(raw)) return raw.map(x=> typeof x==='string'? {name:x} : x);

  // case 2: top-level sub-categories
  const groups=["planets","moons","stars","galaxies"];
  let out=[];
  for(const g of groups){
    if(Array.isArray(raw?.[g])){
      out = out.concat(raw[g].map(item=>{
        const o = (typeof item==='string')? {name:item} : {...item};
        o.group = g;                       // remember group for headers
        o.type  = o.type || g.slice(0,-1); // default type if missing (planet/moon/star/galaxy)
        return o;
      }));
    }
  }
  if(out.length) return out;

  // case 3: { targets: [...] } or { data: [...] } fallbacks
  for (const key of ['targets','data','items']) {
    if (raw && Array.isArray(raw[key])) return raw[key].map(x=> typeof x==='string'? {name:x}: x);
  }

  // case 4: object of named entries
  if (raw && typeof raw==='object') {
    const arr = [];
    for (const k of Object.keys(raw)) {
      const v=raw[k];
      if(v && typeof v==='object') arr.push({ name: v.name || k, ...v });
    }
    if (arr.length) return arr;
  }

  return [];
}

function renderTargets(list){
  rowsEl.innerHTML='';
  // group by .group (planets/moons/stars/galaxies), keep a stable order
  const by= new Map();
  list.forEach(t=>{const g=t.group||'other'; if(!by.has(g)) by.set(g,[]); by.get(g).push(t)});
  GROUP_ORDER.concat(['other']).forEach(g=>{
    const arr=by.get(g)||[];
    if(!arr.length) return;
    addGroupHeader(GROUP_LABEL[g]||g);
    arr.forEach(makeRow);
  });
}

async function loadTargets(){
  try{
    const r=await fetch(`${TARGETS_URL}?v=${Date.now()}`, { cache: "no-store" });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const text=await r.text();
    let data; try { data=JSON.parse(text); } catch { throw new Error('Invalid JSON in targets.json'); }
    const list=normalizeTargets(data);
    if(!list.length){ setBanner('No targets found. Expect top-level arrays under planets/moons/stars/galaxies or a flat list.', 'warn'); return; }
    setBanner(`Loaded ${list.length} target(s) from targets.json.`, 'ok');
    renderTargets(list);
  } catch (e) { setBanner('Failed to load targets.json: ' + e.message, 'bad'); }
}

/******** CLOCKS ********/
function tick(){
  document.getElementById('localTime').textContent=chicagoNow();
  document.getElementById('tzName').textContent=tzLabel();
  document.getElementById('interstellarYear').textContent=interstellarYear();
  document.getElementById('stardate').textContent=stardate();
  document.getElementById('cstOffset').textContent=cstToUtcOffset();
  document.getElementById('utcEpoch').textContent=new Date().toISOString().replace('T',' ').replace('Z','Z');
}
setInterval(tick,1000); tick();

/******** INIT ********/
loadTargets();
</script>
</body>
</html>
