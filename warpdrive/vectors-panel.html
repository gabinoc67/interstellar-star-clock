<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>FTL Nav Console — CST + Solver</title>
<style>
  :root{
    --scale:1.10;
    --time-scale:0.80;      /* 20% smaller clock text */
    --clock-num-scale:0.80; /* 20% smaller interstellar/stardate numbers */
    --panel:#111a2b; --ink:#e9eef9; --muted:#a9b6d3; --stroke:#274061; --grid:#1b2740;
    --accent:#7dd3fc; --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,#081020,#0c1730 55%,#0a1427);
    color:var(--ink);
    font:calc(16px*var(--scale))/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    padding:28px;
  }
  h1{margin:0 0 8px; font-size:clamp(22px,3.2vw,32px); font-weight:800}
  .sub{color:var(--muted); margin:0 0 18px; font-size:.95rem}
  .wrap{width:min(1400px,96vw); margin:0 auto; display:grid; gap:18px}

  .two-up{ display:grid; gap:18px; align-items:stretch; grid-template-columns:1fr }
  @media (min-width:980px){ .two-up{ grid-template-columns:repeat(2,1fr) } }

  .card{ background:var(--panel); border:1px solid var(--stroke); border-radius:var(--radius); overflow:hidden; height:100% }
  .card header{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:14px 16px; border-bottom:1px solid var(--stroke);
    background:radial-gradient(1000px 260px at 20% -20%, rgba(125,211,252,.08), transparent 60%);
  }
  .card header h2{margin:0; font-size:1.05rem; font-weight:800}
  .badge{padding:.25rem .55rem; border:1px solid var(--stroke); border-radius:999px; color:#b8c5e0; background:#0a182c; font-size:.85rem}
  .body{padding:16px}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .big{font-size:clamp(24px,3.8vw,36px); font-weight:800; letter-spacing:.4px; font-variant-numeric:tabular-nums}
  .time-big{ font-size: calc(clamp(24px,3.8vw,36px) * var(--time-scale)) }
  .time{     font-size: calc(1rem * var(--time-scale)) }
  .big-clock{ font-size: calc(clamp(24px,3.8vw,36px) * var(--clock-num-scale)) }

  input,button,select{
    background:#0b152a; border:1px solid var(--stroke); color:var(--ink);
    border-radius:10px; font:inherit; padding:.45rem .6rem;
  }
  button{ cursor:pointer }
  input[type="number"]{width:12ch}
  .even{ display:grid; grid-template-columns:repeat(auto-fit,minmax(210px,1fr)); gap:12px; align-items:center }
  .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .hint{font-size:.9rem; color:#a9b6d3}
  .file{display:none}

  .table{width:100%; border-collapse:separate; border-spacing:0}
  .table th,.table td{padding:10px 12px; border-bottom:1px solid var(--grid); text-align:left}
  .table thead th{position:sticky; top:0; background:#0f1830; z-index:1; font-size:.92rem; color:#cfd7eb}
  .table tbody tr:hover{background:#0d1730}
  .groupRow{ background:#0f1830; color:#cfd7eb; font-weight:800 }
  .num{font-variant-numeric:tabular-nums}
  .status{margin-top:10px; padding:10px 12px; border:1px dashed #32496b; border-radius:12px; background:#0b162b; color:#d0d7ea}
  .status.ok{border-color:#2f6b45; background:#0e1f1a; color:#bde6c7}
</style>
</head>
<body>
  <div class="wrap">
    <h1>FTL Nav Console — CST + Solver</h1>
    <p class="sub">
      Targets from <span class="mono">targets.json</span> (same folder) or upload below. Live vectors via NASA Horizons; Gaia for stellar context.
      Includes a CST arrival solver and bubble shaping for Δwarp.
    </p>

    <div class="two-up">
      <section class="card">
        <header>
          <h2>Quantum Clocks</h2>
          <span class="badge" id="tzBadge">America/Chicago</span>
        </header>
        <div class="body">
          <div class="even" style="text-align:center">
            <div>
              <div class="muted">CST (America/Chicago)</div>
              <div class="big time-big mono" id="cstTime">--:--:--</div>
              <div class="mono time" id="cstDate">--/--/----</div>
            </div>
            <div>
              <div class="muted">Interstellar Time (original)</div>
              <div class="big big-clock mono" id="interstellarYear">Year ~57,889,169.3</div>
              <div class="mono muted time">synced to CST stamp</div>
            </div>
            <div>
              <div class="muted">Stardate (real)</div>
              <div class="big big-clock mono" id="stardateNow">Stardate 65615.2</div>
              <div class="mono time" id="utcStamp">UTC —:—</div>
            </div>
          </div>
          <div class="status mono" id="statusMsg">Waiting for targets.json…</div>
          <div class="hint">If you opened this via <span class="mono">file://</span>, click “Upload targets.json”.</div>
        </div>
      </section>

      <section class="card">
        <header><h2>Solver Settings</h2></header>
        <div class="body even">
          <label>H₀ (km/s/Mpc) <input type="number" id="H0" value="70" step="0.1"/></label>
          <label>Max Horizon Δt (s) <input type="number" id="horizon" value="86400" step="60"/></label>
          <label>Units for Distances
            <select id="unitSelect">
              <option value="AU">AU (astronomical units)</option>
              <option value="km">km</option>
              <option value="mi">mi</option>
              <option value="ly">ly</option>
            </select>
          </label>
          <label>CORS Proxy (optional)
            <input id="proxy" placeholder="https://thingproxy.freeboard.io/fetch/"/>
          </label>
          <div class="muted">If Horizons is blocked by CORS, set a proxy then click <b>Get Vectors (Web)</b>.</div>
        </div>
      </section>
    </div>

    <section class="card" style="margin-top:18px">
      <header>
        <h2>Targets + CST Solver</h2>
        <div class="toolbar">
          <button id="btnUpload">Upload targets.json</button>
          <input id="fileInput" class="file" type="file" accept=".json,application/json"/>
          <button id="btnLoadVectors">Get Vectors (Web)</button>
          <button id="btnRefresh">Recompute</button>
          <span class="hint">Groups shown: planets, moons, stars, galaxies</span>
        </div>
      </header>
      <div class="body">
        <table class="table mono" id="targetsTable">
          <thead>
            <tr>
              <th>Name</th><th>Type</th><th>Live Vector (AU)</th><th>Dist. Sun</th><th>Dist. Earth</th>
              <th>Proper Motion</th><th>Radial Vel.</th><th>Distance</th><th>Rec. Vel.</th><th>Uncertainty</th>
              <th>Last Update</th><th>Status</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </section>

    <section class="card">
      <header><h2>Math (implemented)</h2></header>
      <div class="body muted mono" style="font-size:.95rem">
        Live vectors: r(t)=r<sub>0</sub>+v·Δt with AU/day; Earth reference also evolved to time t.<br/>
        d<sub>☉</sub>=||r<sub>heliocentric</sub>||, d<sub>⊕</sub>=||r<sub>geocentric</sub>||; unit selector formats AU↔km↔mi↔ly.<br/>
        Proper Motion: uses pm fields if present; else μ≈(v<sub>⊥</sub>/d)·(rad→mas/yr) from Earth-relative tangential velocity.<br/>
        Radial velocity: v<sub>r</sub>=(V·Ŕ)·(AU/day→km/s) vs Earth; fallback to provided `radial_velocity_km_s`.<br/>
        Cosmology: v<sub>rec</sub>=H₀·D for D in Mpc (small-z), z≈v/c; galaxies’ D(t) grows with v<sub>rec</sub>.<br/>
        Uncertainty: σ<sub>r</sub>≈|v|·Δt; Last Update is the CST timestamp of the vector epoch.
      </div>
    </section>
  </div>

<script>
/* ===== Constants ===== */
const AU_KM = 149_597_870.7;
const KM_PER_MI = 1.609344;
const LY_PER_AU = 1/63241.077;
const AU_PER_DAY_TO_KM_S = AU_KM/86400;
const C_KM_S = 299_792.458;
const LY_PER_PC = 3.26156;
const LY_PER_MPC = LY_PER_PC*1e6;
const KM_PER_PC = 3.085_677_581e13;
const KM_PER_MPC = KM_PER_PC*1e6;

const GROUPS_DISPLAY = ['planets','moons','stars','galaxies'];
const STARDATE_FIXED = 65615.2;

/* Auto-ID map so names work even if horizons_command is missing */
const HORIZONS_IDS = {
  /* planets */
  mercury:'199', venus:'299', earth:'399', mars:'499', jupiter:'599',
  saturn:'699', uranus:'799', neptune:'899', pluto:'999',
  /* key moons */
  moon:'301', io:'501', europa:'502', ganymede:'503', callisto:'504',
  mimas:'601', enceladus:'602', tethys:'603', dione:'604', rhea:'605', titan:'606', iapetus:'608',
  ariel:'701', umbriel:'702', titania:'703', oberon:'704', miranda:'705',
  triton:'801', charon:'901'
};

const v3 = {
  add:(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
  sub:(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
  dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
  norm:a=>Math.hypot(a[0],a[1],a[2]),
  mul:(a,s)=>[a[0]*s,a[1]*s,a[2]*s],
  unit:a=>{const n=Math.hypot(a[0],a[1],a[2]); return n?[a[0]/n,a[1]/n,a[2]/n]:[0,0,0];}
};
const fmt = (n,f=2)=>Number.isFinite(n)?n.toLocaleString(undefined,{maximumFractionDigits:f,minimumFractionDigits:f}):'—';
function setText(id,v){ const el=document.getElementById(id); if(el) el.textContent=v; }
function toCSTString(d){ const s = new Date(d).toLocaleString('sv-SE',{timeZone:'America/Chicago',hour12:false}); return s.replace('T',' '); }

/* ===== State ===== */
let DATA = {};
let REF = { r:[0,0,0], v:[0,0,0], epoch:null };
let rowsEl, statusMsg, H0Input, unitSel, proxyEl, fileInput;

/* ===== Clocks ===== */
function tickClocks(){
  const now = new Date();
  const cst = new Date(now.toLocaleString('en-US',{timeZone:'America/Chicago'}));
  setText('cstTime', cst.toLocaleTimeString([], {hour12:false}));
  setText('cstDate', cst.toLocaleDateString());
  setText('utcStamp', 'UTC ' + now.toISOString().replace('T',' ').replace('Z','Z'));
  setText('stardateNow', 'Stardate ' + STARDATE_FIXED.toFixed(1));
  setText('interstellarYear','Year ~57,889,169.3');
}
setInterval(tickClocks,1000); tickClocks();
document.getElementById('tzBadge').textContent = 'America/Chicago';

/* ===== targets.json load & normalization ===== */
function assignAutoIds(){
  ['planets','moons'].forEach(g=>{
    (Array.isArray(DATA[g])?DATA[g]:[]).forEach(it=>{
      if(!it.horizons_command && it.name){
        const key = it.name.toLowerCase().replace(/\s+/g,'');
        if(HORIZONS_IDS[key]) it.horizons_command = HORIZONS_IDS[key];
      }
    });
  });
}
async function loadTargetsViaFetch(){
  try{
    const res = await fetch('targets.json?nocache='+Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    DATA = await res.json();
    readMeta(); assignAutoIds();
    statusMsg.classList.add('ok');
    statusMsg.textContent = 'targets.json loaded via fetch.';
    render();
    // auto-fetch if we have any IDs
    if(hasAnyHorizonsIds()) getVectorsWeb();
  }catch(e){
    statusMsg.textContent = 'No targets.json via fetch (likely file://). Use “Upload targets.json”.';
    DATA = {}; render();
  }
}
function readMeta(){
  if(Array.isArray(DATA.meta)){
    const ref = DATA.meta.find(m=>m.role==='observer' || /earth/i.test(m.name||''));
    if(ref){
      if(Array.isArray(ref.r_au)) REF.r = ref.r_au;
      if(Array.isArray(ref.v_au_per_d)) REF.v = ref.v_au_per_d;
      REF.epoch = ref.last_update || new Date().toISOString();
    }
  }
}
function hasAnyHorizonsIds(){
  return ['planets','moons'].some(g => (DATA[g]||[]).some(it => !!it.horizons_command));
}

/* ===== Horizons ===== */
function horizonsUrl(command, center){
  const base = 'https://ssd.jpl.nasa.gov/api/horizons.api';
  const p = new URLSearchParams({
    format:'json',
    COMMAND:`'${command}'`,
    EPHEM_TYPE:'VECTORS',
    CENTER:`'${center||"500@0"}'`,
    START_TIME:"'NOW'",
    STOP_TIME:"'NOW+1 d'",
    STEP_SIZE:"'1 d'",
    VEC_TABLE:'1',
    OUT_UNITS:'AU-D',
    REF_PLANE:'ECLIPTIC',
    REF_SYSTEM:'J2000'
  });
  const proxy = (proxyEl.value||'').trim();
  return (proxy? proxy + base : base) + '?' + p.toString();
}
async function fetchVectors(command, center){
  const res = await fetch(horizonsUrl(command, center), {cache:'no-store'});
  if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  const data = await res.json();
  const txt = data.result || '';
  const num = s => parseFloat((s||'').trim());
  const grab = (label)=>{ const m = txt.match(new RegExp(label+"\\s*=\\s*([+\\-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+\\-]?\\d+)?)")); return m? num(m[1]) : null; };
  const X=grab('X'), Y=grab('Y'), Z=grab('Z'), VX=grab('VX'), VY=grab('VY'), VZ=grab('VZ');
  if([X,Y,Z,VX,VY,VZ].some(v=>v==null)) throw new Error('parse error');
  let iso = new Date().toISOString();
  const tm = txt.match(/A\.D\.\s+(\d{4}-[A-Za-z]{3}-\d{2}\s+\d{2}:\d{2}:\d{2}\.\d+)/);
  if(tm){ try{ iso = new Date(tm[1]+' UTC').toISOString(); }catch{} }
  return { r_au:[X,Y,Z], v_au_per_d:[VX,VY,VZ], last_update: iso, source:`JPL Horizons ${command} ${center||"500@0"}` };
}
async function getVectorsWeb(){
  if(!Object.keys(DATA).length){ alert('Load targets.json first.'); return; }
  // Ensure Earth reference
  if(!Array.isArray(REF.r) || !Array.isArray(REF.v)){
    try{
      const e = await fetchVectors('399','500@0'); // Earth
      REF.r = e.r_au; REF.v = e.v_au_per_d; REF.epoch = e.last_update;
      statusMsg.textContent = 'Earth reference set from Horizons.';
    }catch(err){
      statusMsg.textContent = 'Earth reference fetch failed; Dist. Earth mirrors Dist. Sun.';
    }
  }
  let updated=0, failed=0;
  for(const g of ['planets','moons']){
    const arr = Array.isArray(DATA[g])? DATA[g] : [];
    for(const it of arr){
      if(!it.horizons_command){ it.status = it.status || 'no horizons_command'; continue; }
      try{
        const vec = await fetchVectors(it.horizons_command, it.center);
        it.r0_au = vec.r_au;
        it.v_au_per_d = vec.v_au_per_d;
        it.epoch = vec.last_update;
        it.last_update = vec.last_update;
        it.status = vec.source;
        updated++;
      }catch(e){
        it.status = 'vector fetch failed: ' + (e?.message||e);
        failed++;
      }
    }
  }
  statusMsg.textContent = `Get Vectors (Web): ${updated} updated, ${failed} failed.`;
  render(); // repaint with fresh data
}

/* ===== Live evolution ===== */
function secondsSince(iso){ return (Date.now() - new Date(iso||Date.now()).getTime())/1000; }
function evolveVecAU(r0, v_au_d, epochIso){
  const dt_days = secondsSince(epochIso)/86400;
  return (Array.isArray(r0) && Array.isArray(v_au_d)) ? v3.add(r0, v3.mul(v_au_d, dt_days)) : null;
}
function evolveEarthRef(){
  if(!Array.isArray(REF.r) || !Array.isArray(REF.v) || !REF.epoch) return {r:REF.r, v:REF.v};
  const r = evolveVecAU(REF.r, REF.v, REF.epoch);
  return { r: r||REF.r, v: REF.v };
}

/* ===== Units ===== */
function distFormatFromAU(valAU){
  const u = unitSel.value;
  if(!Number.isFinite(valAU)) return '—';
  if(u==='AU') return `${fmt(valAU,6)} AU`;
  const km = valAU*AU_KM;
  if(u==='km') return `${fmt(km,0)} km`;
  if(u==='mi') return `${fmt(km/KM_PER_MI,0)} mi`;
  if(u==='ly') return `${fmt(valAU*LY_PER_AU,9)} ly`;
  return `${fmt(valAU,6)} AU`;
}

/* ===== Render ===== */
function render(){
  rowsEl.innerHTML = '';
  const hasAny = GROUPS_DISPLAY.some(g => Array.isArray(DATA[g]) && DATA[g].length);
  if(!hasAny){ GROUPS_DISPLAY.forEach(g=>addGroupRow(g)); return; }
  GROUPS_DISPLAY.forEach(group=>{
    addGroupRow(group);
    (Array.isArray(DATA[group])?DATA[group]:[]).forEach(item => addItemRow(item, group));
  });
}
function addGroupRow(title){
  const tr = document.createElement('tr'); tr.className='groupRow';
  const cells = [title,'—','—','—','—','—','—','—','—','—',toCSTString(new Date()),'ready'];
  cells.forEach(c=>{ const td=document.createElement('td'); td.innerHTML=c; tr.appendChild(td); });
  rowsEl.appendChild(tr);
}
function addItemRow(it, group){
  const tr = document.createElement('tr');
  tr.dataset.group = group;
  tr.dataset.name = it.name || '';
  rowsEl.appendChild(tr);
  stampRow(tr, it);
}
function stampRow(tr, it){
  const earth = evolveEarthRef();
  const rHelio = (it.r0_au||it.r_au) ? evolveVecAU(it.r0_au||it.r_au, it.v_au_per_d, it.epoch||it.last_update)
                                      : (Array.isArray(it.r_au)? it.r_au : null);
  const rEarth = (Array.isArray(it.r_earth_au)) ? it.r_earth_au
                  : (rHelio && earth.r ? v3.sub(rHelio, earth.r) : null);

  const dSunAU   = rHelio ? v3.norm(rHelio) : null;
  const dEarthAU = rEarth ? v3.norm(rEarth) : null;

  // Proper motion (mas/yr)
  let pm_mas_yr = null;
  if(typeof it.pm_total_mas_yr === 'number') pm_mas_yr = it.pm_total_mas_yr;
  else if(typeof it.pm_ra_mas_yr === 'number' && typeof it.pm_dec_mas_yr === 'number')
    pm_mas_yr = Math.hypot(it.pm_ra_mas_yr, it.pm_dec_mas_yr);
  else if (rEarth && Array.isArray(it.v_au_per_d) && earth.r){
    const vRel = v3.sub(it.v_au_per_d, earth.v || [0,0,0]);
    const Rhat = v3.unit(rEarth);
    const v_rad = v3.dot(vRel, Rhat);
    const v_tan = v3.norm( v3.sub(vRel, v3.mul(Rhat, v_rad)) ); // AU/day
    const d = v3.norm(rEarth);
    if(d>0){
      const mu_rad_per_day = v_tan / d;
      pm_mas_yr = mu_rad_per_day * (180/Math.PI) * 3600 * 1000 * 365.25;
    }
  }

  // Radial velocity (km/s) relative to Earth
  let vr_kms = (typeof it.radial_velocity_km_s === 'number') ? it.radial_velocity_km_s : null;
  if(vr_kms==null && rEarth && Array.isArray(it.v_au_per_d)){
    const vRel = earth.v ? v3.sub(it.v_au_per_d, earth.v) : it.v_au_per_d;
    vr_kms = v3.dot(vRel, v3.unit(rEarth)) * AU_PER_DAY_TO_KM_S;
  }

  // Distance & cosmology
  const H0 = parseFloat(H0Input.value)||70;
  let dist_pc = null, dist_mpc = null;
  if(typeof it.distance_mpc === 'number'){ dist_mpc = it.distance_mpc; }
  else if(typeof it.distance_pc === 'number'){ dist_pc = it.distance_pc; }
  else if(typeof it.parallax_mas === 'number' && it.parallax_mas>0){ dist_pc = 1000/it.parallax_mas; }
  if(dist_pc!=null) dist_mpc = dist_pc/1e6;

  // Live grow D(t) for galaxies; stars with RV adjust pc a bit
  let D_mpc_live = dist_mpc;
  const age_s = secondsSince(it.epoch||it.last_update||new Date().toISOString());
  if(dist_mpc!=null){
    const vrec_kms = H0 * dist_mpc;
    D_mpc_live = dist_mpc + (vrec_kms * age_s)/KM_PER_MPC;
  }else if(dist_pc!=null && typeof it.radial_velocity_km_s === 'number'){
    const delta_pc = (it.radial_velocity_km_s * age_s) / KM_PER_PC;
    dist_pc = Math.max(0, dist_pc + delta_pc);
  }

  const dLyDelta = (dSunAU!=null && dEarthAU!=null) ? Math.abs((dSunAU - dEarthAU)*LY_PER_AU) : null;

  let sigma_km = null;
  if(Array.isArray(it.v_au_per_d)){
    const speed_kms = v3.norm(it.v_au_per_d)*AU_PER_DAY_TO_KM_S;
    sigma_km = speed_kms * Math.max(0, age_s);
  }

  const lastCST = toCSTString(it.epoch || it.last_update || new Date());

  const cells = [
    it.name || '(unnamed)',
    it.type || (tr.dataset.group||'').slice(0,-1),
    rHelio ? `<span class="num">[${fmt(rHelio[0],6)}, ${fmt(rHelio[1],6)}, ${fmt(rHelio[2],6)}]</span>` : '—',
    (dSunAU!=null)   ? `<span class="num">${distFormatFromAU(dSunAU)}</span>`   : '—',
    (dEarthAU!=null) ? `<span class="num">${distFormatFromAU(dEarthAU)}</span>` : '—',
    (pm_mas_yr!=null)? `<span class="num">${fmt(pm_mas_yr,2)} mas/yr</span>` : '—',
    (vr_kms!=null)   ? `<span class="num">${fmt(vr_kms,2)} km/s</span>` : '—',
    (D_mpc_live!=null)
      ? `<span class="num">${fmt(D_mpc_live,4)} Mpc</span> <span class="muted">(≈${fmt(D_mpc_live*LY_PER_MPC,3)} Mly${dLyDelta!=null?`, Δ(SE)≈${fmt(dLyDelta,6)} ly`:''})</span>`
      : (dist_pc!=null ? `<span class="num">${fmt(dist_pc,2)} pc</span> <span class="muted">(≈${fmt(dist_pc*LY_PER_PC,3)} ly${dLyDelta!=null?`, Δ(SE)≈${fmt(dLyDelta,6)} ly`:''})</span>`
                        : (dLyDelta!=null?`<span class="muted">Δ(SE)≈${fmt(dLyDelta,6)} ly</span>`:'—')),
    (D_mpc_live!=null) ? `<span class="num">${fmt((parseFloat(H0Input.value)||70)*D_mpc_live,3)} km/s</span> <span class="muted">(z≈${fmt(((parseFloat(H0Input.value)||70)*D_mpc_live)/C_KM_S,6)})</span>` : '—',
    (sigma_km!=null)  ? `<span class="num">±${fmt(sigma_km,0)} km</span> <span class="muted">(Δt≈${fmt(age_s,0)} s)</span>` : '—',
    lastCST,
    it.status || '—'
  ];

  tr.innerHTML = '';
  cells.forEach(c=>{ const td=document.createElement('td'); td.innerHTML=c; tr.appendChild(td); });
}

/* Live repaint */
function repaintLive(){
  const trs = Array.from(rowsEl.querySelectorAll('tr')).filter(tr => !tr.classList.contains('groupRow'));
  trs.forEach(tr=>{
    const group = tr.dataset.group, name = tr.dataset.name;
    const arr = Array.isArray(DATA[group])? DATA[group] : [];
    const it = arr.find(x => (x.name||'')===name);
    if(it) stampRow(tr, it);
  });
}
setInterval(repaintLive, 1000);

/* UI */
document.getElementById('btnRefresh').addEventListener('click', render);
document.getElementById('btnLoadVectors').addEventListener('click', getVectorsWeb);
document.getElementById('btnUpload').addEventListener('click', ()=> fileInput.click());

/* Boot */
rowsEl    = document.getElementById('rows');
statusMsg = document.getElementById('statusMsg');
H0Input   = document.getElementById('H0');
unitSel   = document.getElementById('unitSelect');
proxyEl   = document.getElementById('proxy');
fileInput = document.getElementById('fileInput');

fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const text = await file.text();
    DATA = JSON.parse(text);
    readMeta(); assignAutoIds();
    statusMsg.classList.add('ok');
    statusMsg.textContent = `Loaded ${file.name} (${new Blob([text]).size.toLocaleString()} bytes).`;
    render();
    if(hasAnyHorizonsIds()) getVectorsWeb();
  }catch(err){
    statusMsg.textContent = 'Failed to read targets.json: ' + err.message;
  }
});

loadTargetsViaFetch();
</script>
</body>
</html>
