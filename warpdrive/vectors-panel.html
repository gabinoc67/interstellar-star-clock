<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FTL Nav Console — CST + Solver (Offline Ephemeris)</title>
<style>
:root{--bg:#060a16;--card:#0f1630;--ink:#eaf0ff;--muted:#9fb0e0;--good:#3dd07f;--warn:#ffd166;--bad:#ef476f;--grid:16px}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#060a16,#0b1233);color:var(--ink);font:16.5px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial}
header{padding:26px 28px;border-bottom:1px solid rgba(255,255,255,.06);position:sticky;top:0;background:rgba(8,12,30,.78);backdrop-filter:blur(8px);z-index:50}
.wrap{padding:26px;max-width:1900px;margin:0 auto}
.grid{display:grid;grid-template-columns:repeat(12,1fr);gap:var(--grid)}
.card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:18px;padding:20px;box-shadow:0 10px 28px rgba(0,0,0,.28)}
.card h2{margin:0 0 10px 0;font-size:19px}
/* 12 columns, no Actions */
.row{display:grid;grid-template-columns:340px 96px 1.2fr 0.9fr 0.9fr 1fr 1fr 0.9fr 0.9fr 0.9fr 0.9fr 1.1fr;gap:12px;align-items:flex-start;padding:12px 0;border-bottom:1px dashed rgba(255,255,255,.08)}
.row.header{font-weight:700;color:#cbd5ff;border-bottom:1px solid rgba(255,255,255,.14);position:sticky;top:86px;background:linear-gradient(180deg,#0f1630,rgba(15,22,48,.6));z-index:5}
.row > div{min-height:24px}
.group{padding:10px 12px;margin:10px 0;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);font-weight:700;color:#b9c7ff}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:1.06em;word-break:break-word}
.pill{display:inline-block;padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.08);font-size:.95em}
.ok{color:var(--good)}.warn{color:var(--warn)}.bad{color:var(--bad)}
.small{font-size:13.3px;color:#9fb0e0}
.banner{margin:12px 0;padding:12px 14px;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12)}
.scrolly{max-height:60vh;overflow:auto;padding-right:6px}
</style>
</head>
<body>
<header>
  <h1>FTL Nav Console — CST + Solver</h1>
  <div class="small">
    <b>Offline mode:</b> built-in Kepler ephemeris (no server required). Columns marked “offline” skip GAIA/Horizons.
    Put optional targets in <code>targets.json</code> later (top-level: <b>planets</b>, <b>moons</b>, <b>stars</b>, <b>galaxies</b>).
  </div>
</header>

<div class="wrap grid">
  <section class="card" style="grid-column: span 7">
    <h2>Quantum Clocks</h2>
    <div class="grid" style="grid-template-columns: repeat(3,1fr); gap:14px">
      <div><div class="small">Local Time (America/Chicago)</div><div class="mono" id="localTime">—</div><div class="small" id="tzName">—</div></div>
      <div><div class="small">Interstellar Time (demo)</div><div class="mono" id="interstellarYear">—</div></div>
      <div><div class="small">Stardate (demo)</div><div class="mono" id="stardate">—</div></div>
    </div>
    <div class="small" style="margin-top:6px">CST↔UTC offset: <span id="cstOffset">—</span> • UTC epoch: <span class="mono" id="utcEpoch">—</span></div>
    <div class="banner mono" id="statusBanner">Starting offline ephemeris…</div>
  </section>

  <section class="card" style="grid-column: span 5">
    <h2>Solver Settings</h2>
    <div class="flex">
      <label>H₀ (km/s/Mpc) <input id="h0" type="number" step="0.1" value="70" style="width:110px" disabled></label>
      <label>Tolerance (km) <input id="tolKm" type="number" step="100" value="10000" style="width:140px" disabled></label>
      <label>Max Horizon Δt (s) <input id="maxDt" type="number" step="1" value="86400" style="width:140px" disabled></label>
      <span class="small">Online solver disabled (offline mode).</span>
    </div>
  </section>

  <section class="card" style="grid-column: span 12">
    <h2>Targets + CST Solver</h2>
    <div class="row header">
      <div>Name</div><div>Type</div><div>Live Vector (AU)</div><div>Dist. Sun</div><div>Dist. Earth</div>
      <div>Proper Motion</div><div>Radial Vel.</div><div>Distance</div><div>Rec. Vel</div>
      <div>Uncertainty</div><div>Last Update</div><div>Status</div>
    </div>
    <div id="targets" class="scrolly"></div>
  </section>

  <section class="card" style="grid-column: span 12">
    <h2>Math (implemented)</h2>
    <div class="small">
      Offline propagation: two-body Kepler (J2000 elements, constant mean motion).
      Positions update every second; velocities from 2-s central difference.
    </div>
  </section>
</div>

<script>
/* ================= OFFLINE CONSTANTS & UTILS ================= */
const AU_KM=149_597_870.700, KM_PER_MI=1.609344, MI_PER_AU=AU_KM/KM_PER_MI, C_KM_S=299_792.458;
const DEG=Math.PI/180, RAD=180/Math.PI;
const fmt=(n,d=6)=>Number(n).toFixed(d);
const fmtAU=x=>fmt(x,6)+" AU";
const fmtMi=x=>Number(x).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1})+" miles";
const fmtISO=d=>new Date(d).toISOString().replace('.000Z','Z');
function chicagoNow(){const o={timeZone:'America/Chicago',hour12:true,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'};return new Intl.DateTimeFormat(undefined,o).format(new Date())}
function tzLabel(){try{return Intl.DateTimeFormat().resolvedOptions().timeZone}catch{return'Local TZ'}}
function interstellarYear(){const s=Date.now()/1000;const y=57_800_000+(s/31557600)*100;return `Year ~${y.toFixed(2)}`}
function stardate(){const ms=Date.now();const base=Date.UTC(2323,0,1);const sd=1000*((ms-base)/31557600000);return `Stardate ${(sd/10).toFixed(1)}`}
function cstToUtcOffset(){const off=-new Date().getTimezoneOffset()/60;const s=off>=0?'+':'';return `${s}${off.toFixed(0)} h`}

const norm=v=>Math.hypot(...v);
const sub=(a,b)=>a.map((v,i)=>v-b[i]);
const add=(a,b)=>a.map((v,i)=>v+b[i]);
const scale=(a,s)=>a.map(v=>v*s);

/* Julian Date (UTC) */
function toJD(date){
  let Y=date.getUTCFullYear(), M=date.getUTCMonth()+1, D=date.getUTCDate();
  let h=date.getUTCHours(), m=date.getUTCMinutes(), s=date.getUTCSeconds()+date.getUTCMilliseconds()/1000;
  if (M<=2){Y-=1;M+=12;}
  const A=Math.floor(Y/100);
  const B=2-A+Math.floor(A/4);
  const day=D+(h+(m+s/60)/60)/24;
  return Math.floor(365.25*(Y+4716))+Math.floor(30.6001*(M+1))+day+B-1524.5;
}
const JD_J2000 = 2451545.0;

/* ================= OFFLINE ORBITS (J2000, simple mean motion) =================
   Elements: a (AU), e, i (deg), Ω (deg), ϖ (deg, longitude of perihelion), L0 (deg at J2000), P (days)
   ω = ϖ - Ω, M = (L0 - ϖ) + n*Δt_days, n = 360/P deg/day
*/
const ORBITS = {
  Mercury:{ a:0.38709893, e:0.20563069, i:7.00487,  O:48.33167,  p:77.45645,  L0:252.25084, P:87.969 },
  Venus:  { a:0.72333199, e:0.00677323, i:3.39471,  O:76.68069,  p:131.53298, L0:181.97973, P:224.701 },
  Earth:  { a:1.00000011, e:0.01671022, i:0.00005,  O:-11.26064, p:102.94719, L0:100.46435, P:365.256 },
  Mars:   { a:1.52366231, e:0.09341233, i:1.85061,  O:49.57854,  p:336.04084, L0:355.45332, P:686.980 },
  Jupiter:{ a:5.20336301, e:0.04839266, i:1.30530,  O:100.55615, p:14.75385,  L0:34.40438,  P:4332.589 }
};

/* Solve Kepler (elliptic) */
function solveKepler(M,e){
  let E=M, d;
  for(let k=0;k<12;k++){
    d=(E - e*Math.sin(E) - M)/(1 - e*Math.cos(E));
    E-=d;
    if (Math.abs(d)<1e-12) break;
  }
  return E;
}

/* Heliocentric ecliptic state (AU) for planet name at Julian Date jd.
   Returns {r:[x,y,z] in AU}
*/
function planetPosAU(name, jd){
  const el = ORBITS[name];
  if(!el) return {r:[NaN,NaN,NaN]};
  const dt = jd - JD_J2000;            // days since J2000
  const n  = 360/el.P;                 // deg/day
  const M  = ((el.L0 - el.p) + n*dt) * DEG;   // rad
  const w  = (el.p - el.O) * DEG;             // ω
  const O  = el.O * DEG;                       // Ω
  const I  = el.i * DEG;                       // i
  const e  = el.e, a = el.a;

  const E = solveKepler(M,e);
  const cosE=Math.cos(E), sinE=Math.sin(E);
  const sqrt1e=Math.sqrt(1-e*e);

  // position in orbital plane
  const r = a*(1 - e*cosE);
  const cosv = (cosE - e)/(1 - e*cosE);
  const sinv = (sqrt1e*sinE)/(1 - e*cosE);
  const v = Math.atan2(sinv, cosv);
  const u = w + v; // argument of latitude

  const cosO=Math.cos(O), sinO=Math.sin(O);
  const cosI=Math.cos(I), sinI=Math.sin(I);
  const cosu=Math.cos(u), sinu=Math.sin(u);

  const x = r*(cosO*cosu - sinO*sinu*cosI);
  const y = r*(sinO*cosu + cosO*sinu*cosI);
  const z = r*(sinu*sinI);

  return { r:[x,y,z] };
}

/* Position and velocity via central difference (±1s) */
function stateAU(name, date){
  const jd = toJD(date);
  const dtDays = 1/86400; // 1 second in days
  const p0 = planetPosAU(name, jd).r;
  const pPlus = planetPosAU(name, jd+dtDays).r;
  const pMinus= planetPosAU(name, jd-dtDays).r;
  const v_au_s = scale(sub(pPlus, pMinus), 1/(2*1)); // AU per second
  return { r:p0, v_au_s };
}

/* ================= UI + RENDER ================= */
const rowsEl=document.getElementById('targets');
const banner=document.getElementById('statusBanner');
function setBanner(msg,cls){banner.textContent=msg;banner.className='banner mono '+(cls||'')}

const GROUP_ORDER=["planets","moons","stars","galaxies"];
const GROUP_LABEL={planets:"Planets", moons:"Moons", stars:"Stars", galaxies:"Galaxies", other:"Other"};

function addGroupHeader(label){
  const g=document.createElement('div'); g.className='group'; g.textContent=label; rowsEl.appendChild(g);
}

function makeRow(t){
  const el=document.createElement('div'); el.className='row';
  const id=(t.id||t.name||'target').toString().replace(/\W+/g,'_'); el.id=`row-${id}`;
  el.innerHTML=`
    <div><div><strong>${t.name||'(unnamed target)'}</strong></div><div class="small">${t.id||''}</div></div>
    <div><span class="pill">${t.type||t.group||'—'}</span></div>
    <div class="mono" id="vec-${id}">—</div>
    <div id="sun-${id}">—</div>
    <div id="earth-${id}">—</div>
    <div id="pm-${id}">offline</div>
    <div id="rv-${id}">offline</div>
    <div id="dist-${id}">offline</div>
    <div id="rec-${id}">offline</div>
    <div id="unc-${id}">—</div>
    <div class="small" id="upd-${id}">—</div>
    <div class="small" id="status-${id}">pending…</div>`;
  rowsEl.appendChild(el);
}

/* Build rows grouped */
function renderTargets(list){
  rowsEl.innerHTML='';
  const by=new Map();
  list.forEach(t=>{const g=t.group||'other'; if(!by.has(g)) by.set(g,[]); by.get(g).push(t)});
  [...GROUP_ORDER,'other'].forEach(g=>{
    const arr=by.get(g)||[];
    if(!arr.length) return;
    addGroupHeader(GROUP_LABEL[g]||g);
    arr.forEach(makeRow);
  });
}

/* ================= OFFLINE UPDATE LOOP (1 Hz) ================= */
const keyOf=t=>(t.id||t.name||'target').toString().replace(/\W+/g,'_');
let LIVE_LIST=[], liveTimer=null;

function updateRowOffline(t){
  const id=keyOf(t);
  const g=sel=>document.getElementById(sel);
  const vecEl=g(`vec-${id}`), sunEl=g(`sun-${id}`), earthEl=g(`earth-${id}`),
        uncEl=g(`unc-${id}`), updEl=g(`upd-${id}`), stEl=g(`status-${id}`);

  try{
    const now = new Date();
    // Earth heliocentric state
    const earth = stateAU("Earth", now);
    let r=[NaN,NaN,NaN], v_au_s=[0,0,0];

    const name = (t.name||"").toLowerCase();
    const isPlanet = !!ORBITS[t.name] || !!ORBITS[capitalize(t.name)];
    const displayName = pickOrbitName(name);

    if (displayName){
      const s = stateAU(displayName, now);
      r = s.r; v_au_s = s.v_au_s;
    }

    // Live vector
    vecEl.textContent = `[${fmt(r[0])}, ${fmt(r[1])}, ${fmt(r[2])}]`;
    const rSun = norm(r);
    const rEarth = isFinite(earth.r[0]) ? norm(sub(r, earth.r)) : NaN;

    // Distances (AU + miles)
    sunEl.textContent   = isFinite(rSun)   ? `${fmtAU(rSun)} (${fmtMi(rSun*MI_PER_AU)})`   : '—';
    earthEl.textContent = isFinite(rEarth) ? `${fmtAU(rEarth)} (${fmtMi(rEarth*MI_PER_AU)})` : (displayName==="Earth" ? `${fmtAU(0)} (${fmtMi(0)})` : '—');

    // Uncertainty: simple model ~ |v| * 10 s (km)
    const v_km_s = norm(v_au_s) * AU_KM;
    const sigmaKm = v_km_s * 10;
    const sigmaAu = sigmaKm / AU_KM;
    uncEl.textContent = `${sigmaAu.toExponential(2)} AU (~${Math.round(sigmaKm)} km)`;

    updEl.textContent = fmtISO(now.toISOString());
    stEl.textContent = displayName ? 'offline ephemeris (1 Hz)' : 'offline (no elements)';
    stEl.className = 'small ' + (displayName ? 'ok' : 'warn');
  }catch(e){
    stEl.textContent='error: '+e.message;
    stEl.className='small bad';
  }
}

function refreshOnce(){
  if(!LIVE_LIST.length) return;
  for(const t of LIVE_LIST) updateRowOffline(t);
}
function startLiveUpdates(){ stopLiveUpdates(); liveTimer=setInterval(refreshOnce, 1000); }
function stopLiveUpdates(){ if(liveTimer){ clearInterval(liveTimer); liveTimer=null; } }

/* Helper: map name variants to ORBITS keys */
function capitalize(s){return s.charAt(0).toUpperCase()+s.slice(1);}
function pickOrbitName(name){
  const map = {
    mercury:"Mercury", venus:"Venus", earth:"Earth", terra:"Earth",
    mars:"Mars", jupiter:"Jupiter"
  };
  const k = map[name] || map[name.replace(/\s+/g,'')];
  if (k && ORBITS[k]) return k;
  // also try capitalized direct key
  const c = capitalize(name);
  return ORBITS[c] ? c : null;
}

/* ================= CLOCKS ================= */
function tick(){
  document.getElementById('localTime').textContent=chicagoNow();
  document.getElementById('tzName').textContent=tzLabel();
  document.getElementById('interstellarYear').textContent=interstellarYear();
  document.getElementById('stardate').textContent=stardate();
  document.getElementById('cstOffset').textContent=cstToUtcOffset();
  document.getElementById('utcEpoch').textContent=new Date().toISOString().replace('T',' ').replace('Z','Z');
}
setInterval(tick,1000); tick();

/* ================= TARGETS LOADING =================
   Works offline: if fetch fails or page is file://, we use a built-in default.
*/
function normalizeTargets(raw){
  if(Array.isArray(raw)) return raw.map(x=> typeof x==='string'? {name:x} : x);
  const groups=["planets","moons","stars","galaxies"];
  let out=[];
  for(const g of groups){
    if(Array.isArray(raw?.[g])){
      out=out.concat(raw[g].map(item=>{
        const o=(typeof item==='string')? {name:item} : {...item};
        o.group=g; o.type=o.type||g.slice(0,-1);
        return o;
      }));
    }
  }
  if(out.length) return out;
  for (const key of ['targets','data','items']) {
    if (raw && Array.isArray(raw[key])) return raw[key].map(x=> typeof x==='string'? {name:x}: x);
  }
  if (raw && typeof raw==='object') {
    const arr=[]; for (const k of Object.keys(raw)) { const v=raw[k]; if(v && typeof v==='object') arr.push({ name: v.name || k, ...v }); }
    if (arr.length) return arr;
  }
  return [];
}

function defaultTargets(){
  return normalizeTargets({
    planets:[{name:"Mercury"},{name:"Venus"},{name:"Earth"},{name:"Mars"},{name:"Jupiter"}],
    stars:[{name:"Sirius"},{name:"Vega"}]
  });
}

async function loadTargets(){
  try{
    if (location.protocol === 'file:') throw new Error('file:// offline');
    const r = await fetch("targets.json?v="+Date.now(), {cache:"no-store"});
    if(!r.ok) throw new Error("HTTP "+r.status);
    const text=await r.text();
    let data; try{ data=JSON.parse(text); } catch { throw new Error('Invalid JSON in targets.json'); }
    const list=normalizeTargets(data);
    if(!list.length) throw new Error('No targets in targets.json');
    setBanner(`Loaded ${list.length} target(s) (offline ephemeris).`, 'ok');
    initWithList(list);
  }catch(e){
    const list = defaultTargets();
    setBanner(`Offline ephemeris active — using built-in targets (${list.length}).`, 'warn');
    initWithList(list);
  }
}
function initWithList(list){
  renderTargets(list);
  LIVE_LIST = list.filter(t => pickOrbitName((t.name||"").toLowerCase())); // only those we can propagate
  startLiveUpdates();
}

loadTargets();
</script>
</body>
</html>
