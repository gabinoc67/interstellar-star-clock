<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Warp Control ‚Äî Three-Column Balanced (v3.6.5 ‚Ä¢ edges+center)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#070b12; --panel:#0c1424; --glass:#0d1a31cc; --edge:#27406b;
    --text:#eaf2ff; --muted:#a7b9df; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
    --ui-scale:1; --fs:14px; --pad:8px;
    --gap: clamp(12px, 2.2vmin, 24px);
    /* Taller by default for readability */
    --row-scale: 0.90; /* 90% default, adjustable */
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:
      radial-gradient(1200px 800px at 10% -10%, #112240 0%, transparent 60%),
      radial-gradient(900px 900px at 120% -20%, #0b1b33 0%, transparent 50%),
      var(--bg);
    color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;font-size:var(--fs);
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  .viewportScale{transform:scale(var(--ui-scale));transform-origin:top left;width:calc(100%/var(--ui-scale))}
  .wrap{max-width:1400px;margin:0 auto;padding:var(--pad)}
  .glass{
    background:linear-gradient(180deg,#0b1528aa,#0b152880),
               radial-gradient(600px 200px at 20% -30%,#15305f55,transparent 60%);
    backdrop-filter:blur(6px)
  }
  .panel{
    border:1px solid var(--edge);border-radius:12px;padding:8px;
    box-shadow:0 10px 24px rgba(0,0,0,.42);
    display:flex; flex-direction:column;
    height:auto;
    min-height: calc(150px * var(--row-scale)); /* safety minimum */
    background: var(--glass);
  }
  h1,h2,h3{margin:.35rem 0}
  .grid{display:grid;gap:var(--gap)}

  /* === Three-column frame: left | center | right === */
  .threeCol{
    display:grid;
    grid-template-columns: minmax(260px,1fr) minmax(360px,1.25fr) minmax(260px,1fr);
    gap:var(--gap);
    align-items:start;
  }
  .col{ display:grid; gap:var(--gap); align-content:start }
  .centerGrid{
    display:grid;
    grid-template-columns: repeat(2, minmax(260px, 1fr));
    gap:var(--gap);
    align-items:start;
  }

  /* Responsive steps */
  @media (max-width:1250px){
    .threeCol{ grid-template-columns: 1fr 1fr; }
    .rightCol{ grid-column: span 2; grid-template-columns: repeat(2,minmax(260px,1fr)); }
  }
  @media (max-width:980px){
    .threeCol{ grid-template-columns: 1fr; }
    .rightCol{ grid-column:auto; grid-template-columns: 1fr; }
    .centerGrid{ grid-template-columns: 1fr; }
  }

  /* Full-width blocks inside the layout */
  .span-all{
    grid-column:1 / -1;
    width:100%;
    display:block;
  }

  /* Form layout */
  .controls label,
  .grid label{display:flex;flex-direction:column;align-items:flex-start;gap:4px;margin:6px 0;color:var(--muted);font-size:.95rem}
  select,input[type="number"],input[type="text"]{
    width:100%;background:#0b1220;color:#eaf2ff;border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem
  }
  input[type="range"]{width:100%}

  button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:7px 9px;margin:3px;border-radius:8px;cursor:pointer}
  #startBtn{background:#00ccff;color:#00131a;border:none} #stopBtn{background:#64748b}
  #resetBtn{background:#fb923c;border:none} #exportBtn{background:#7c3aed;border:none}

  .lights{display:flex;gap:8px;flex-wrap:wrap}
  .light{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.85rem}
  .dot{width:9px;height:9px;border-radius:50%}
  .good .dot{background:var(--good)} .warn .dot{background:var(--warn)} .bad .dot{background:var(--bad)}

  .meter{display:flex;align-items:center;gap:8px;margin:4px 0}
  .bar{height:9px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}
  .fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}
  .stat{font-variant-numeric:tabular-nums;font-size:.86rem;color:var(--muted)}

  canvas{
    background:linear-gradient(180deg,#091323,#0a1322);
    border:1px solid #2b3a5a;border-radius:10px;max-width:100%;display:block
  }
  .pill{display:inline-block;padding:.1rem .4rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}
  .legend{color:var(--muted);font-size:.84rem;margin-top:6px}
  .hdrline{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .toggle{display:flex;align-items:center;gap:10px;color:#a7b9df;font-size:.9rem}
  .badge{border:1px solid #3b4f77;border-radius:999px;padding:2px 8px;color:#93c5fd;background:#0b1220}

  .clockSection{margin-top:6px}
  .clockHeader{display:flex;align-items:center;justify-content:space-between;margin:2px 0 6px}
  .clockGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap)}
  @media (max-width:1200px){ .clockGrid{grid-template-columns:repeat(3,1fr)} }
  @media (max-width:820px){  .clockGrid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:520px){  .clockGrid{grid-template-columns:1fr} }

  .clockCard{background:#0b1220;border:1px solid #304166;border-radius:12px;padding:8px;display:grid;gap:4px; align-content:start}
  .clockHdr{display:flex;justify-content:space-between;align-items:center}
  .clockTitle{font-weight:600}
  .status{font-size:.78rem;border:1px solid #36507d;border-radius:999px;padding:2px 6px}
  .status.good{color:#0f0;border-color:#256f2a} .status.warn{color:#222;background:#facc15} .status.bad{color:#fff;background:#ef4444}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:.84rem;color:#cfe2ff}

  /* Canvas heights scale with --row-scale */
  #curveCanvas{width:100%;height:calc(170px * var(--row-scale))}
  #orbitCanvas{width:100%;height:calc(240px * var(--row-scale))}
  #debrisCanvas{width:100%;height:calc(140px * var(--row-scale))}
  #starfieldCanvas{width:100%;height:calc(140px * var(--row-scale));
                   background:radial-gradient(160px 105px at 50% 60%, #0a1322 0%, #08101d 65%, #060d18 100%)}
  #shieldCanvas{width:100%;height:calc(140px * var(--row-scale))}
  #grCanvas{width:100%;height:calc(90px * var(--row-scale))}
</style>
</head>
<body>
<div class="viewportScale">
  <div class="wrap grid">
    <div class="hdrline">
      <h1>üöÄ Warp Control Center</h1>
      <div class="toggle">
        <label>UI Scale
          <input id="uiScale" type="range" min="70" max="140" step="1" value="100">
          <span id="uiScaleVal" class="badge">100%</span>
        </label>
        <label>Row Height
          <input id="rowScale" type="range" min="70" max="115" step="1" value="90">
          <span id="rowScaleVal" class="badge">90%</span>
        </label>
        <label>Sound <input id="soundOn" type="checkbox" checked></label>
        <span class="badge">v3.6.5 ‚Ä¢ Three-column</span>
      </div>
    </div>

    <!-- === Left | Center | Right === -->
    <section class="threeCol">
      <!-- Left edge column -->
      <div class="col leftCol">
        <!-- 1 -->
        <div class="panel glass">
          <h2>Flight Plan</h2>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:10px">
            <label>Warp Speed
              <select id="warpSpeed"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option></select>
            </label>
            <label>Destination
              <select id="destination"><option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option></select>
            </label>
            <label>Warp Law (n) <input id="warpExp" type="number" step="0.1" value="3"></label>
            <label>Speed Scale (√óc) <input id="warpScale" type="number" step="0.1" value="1"></label>
            <label>IST Day 0 (yrs ago) <input id="istDay0Years" type="number" step="1" value="45500000000"></label>
            <label>Days / IST year <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25"></label>
            <label>Calibration
              <select id="calibration">
                <option value="off">Off</option>
                <option value="mars_opp">Mars ‚Äì Opposition (fast window)</option>
                <option value="mars_conj">Mars ‚Äì Conjunction (slow window)</option>
              </select>
            </label>
          </div>
          <div class="lights" style="margin-top:6px">
            <div class="light good" id="lightBubble"><span class="dot"></span>Bubble</div>
            <div class="light good" id="lightPower"><span class="dot"></span>Power</div>
            <div class="light good" id="lightVector"><span class="dot"></span>Vector</div>
            <div class="light good" id="lightNav"><span class="dot"></span>Nav</div>
          </div>
          <div style="margin-top:6px">
            <button id="startBtn">‚ñ∂Ô∏è Start</button>
            <button id="stopBtn">‚è∏Ô∏è Stop</button>
            <button id="resetBtn">üîÑ Engage Warp</button>
            <button id="exportBtn">üìÑ Export Log</button>
          </div>
          <div class="legend" id="beacon">‚è≥ Waiting‚Ä¶</div>
          <div class="legend" id="constraints">EC/Horizon: ‚Äî</div>
        </div>

        <!-- 2 -->
        <div class="panel glass">
          <h2>Gravity Vectoring Engine</h2>
          <div class="controls">
            <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
            <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
            <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
            <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
            <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
            <label>Intake Mode
              <select id="intakeMode">
                <option value="balanced">Balanced (¬±)</option>
                <option value="positive">Positive Gravity Capture</option>
                <option value="negative">Negative Gravity Capture</option>
              </select>
            </label>
          </div>
          <h3>Power Allocation</h3>
          <div class="meter"><span class="stat" style="width:120px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
          <div class="meter"><span class="stat" style="width:120px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
          <div class="meter"><span class="stat" style="width:120px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>
        </div>
      </div>

      <!-- Center column (even panels side-by-side) -->
      <div class="col centerCol">
        <div class="centerGrid">
          <!-- 3 -->
          <div class="panel glass">
            <h2>Trajectory & Field Vectors</h2>
            <canvas id="curveCanvas"></canvas>
            <div class="legend" id="curveLegend">‚Äî</div>
          </div>
          <!-- 4 -->
          <div class="panel glass">
            <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
            <canvas id="orbitCanvas"></canvas>
            <div class="legend" id="orbitLegend">‚Äî</div>
          </div>
          <!-- 5 -->
          <div class="panel glass">
            <h2>Debris Defense Field</h2>
            <canvas id="debrisCanvas"></canvas>
            <div class="legend" id="debrisLegend">‚Äî</div>
          </div>
          <!-- 7 -->
          <div class="panel glass">
            <h2>Shield Bubble Box</h2>
            <canvas id="shieldCanvas"></canvas>
            <div class="legend" id="shieldLegend">‚Äî</div>
          </div>
        </div>
      </div>

      <!-- Right edge column -->
      <div class="col rightCol">
        <!-- 6 -->
        <div class="panel glass">
          <h2>Warp Starfield Window</h2>
          <canvas id="starfieldCanvas"></canvas>
          <div class="legend" id="starfieldLegend">‚Äî</div>
        </div>
        <!-- 8 -->
        <div class="panel glass">
          <h2>Einstein Tensor Mini</h2>
          <canvas id="grCanvas"></canvas>
          <div class="legend" id="grMini">G<sub>ŒºŒΩ</sub> proxy ‚Ä¢ œÅ<sub>em</sub> from |‚àáŒ¶|¬≤ (visual) ‚Ä¢ Auto-throttle if g<sub>tt</sub>‚â§0</div>
          <div class="legend">g<sub>tt</sub> min: <span id="gr_gtt">‚Äî</span> ‚Ä¢ œÅ<sub>em</sub> min/max: <span id="gr_rho">‚Äî</span> ‚Ä¢ EC: <span id="gr_ec">‚Äî</span> ‚Ä¢ Horizons: <span id="gr_hor">‚Äî</span></div>
        </div>
      </div>

      <!-- 9 (full width below the three columns) -->
      <div class="panel glass span-all">
        <h2>IST Orbital Tracker (Live)</h2>
        <div id="orbit-rows" class="grid" style="grid-template-columns:repeat(4,1fr);gap:var(--gap)"></div>
      </div>
    </section>

    <!-- Clocks (full width) -->
    <section class="clockSection span-all">
      <div class="clockHeader">
        <h2>Clock Sync (C1‚ÄìC5) + Arrival CST/IST</h2>
        <span class="badge">Compact view</span>
      </div>
      <div class="clockGrid" id="clockGrid"></div>
    </section>
  </div>
</div>

<script>
/* ====== Constants / helpers ====== */
const AU_M=1.495978707e11, C_MPS=299792458, G=6.67430e-11, MU0=4*Math.PI*1e-7;
const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
const $=id=>document.getElementById(id);
let ac=null;
function tone(kind="good"){
  if(!$("soundOn").checked) return;
  if(!ac){try{ac=new (window.AudioContext||window.webkitAudioContext)();}catch{}}
  if(!ac) return;
  const o=ac.createOscillator(), g=ac.createGain();
  o.type="sine"; o.frequency.value= kind==="good"?880:kind==="warn"?520:320;
  g.gain.value=.001; o.connect(g).connect(ac.destination); o.start();
  g.gain.exponentialRampToValueAtTime(.07, ac.currentTime+.02);
  g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+.18);
  o.stop(ac.currentTime+.2);
}
function setLight(el,level){
  const was=el.dataset.level||"good";
  if(was!==level){
    el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level);
    tone(level==="good"?"good":level==="warn"?"warn":"bad");
  }
}

/* ====== IST time, orbits ====== */
let tIST0=performance.now();
function IST_INPUT(){ return Number($("istDay0Years").value||45500000000); }
function DPY_INPUT(){ return Number($("baselineDaysPerYear").value||365.25); }
function IST_snapshot(){
  const dpy=DPY_INPUT(), spy=dpy*86400;
  const elapsed=(performance.now()-tIST0)/1000/spy;
  const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy;
  return {istYears, istDays, dpy, spy};
}
function planetAgeYears(name,iy){ return Math.max(0, iy - (formationOffsetMyr[name]||0)*1e6); }
function trueAnomalyFrac(name,iy,dpy){
  const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name];
  if(!T) return 0;
  const N=pd/T; return N-Math.floor(N);
}
function orbitsFor(name,pd){
  const T=orbitalDays[name]; if(!T) return null;
  const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T;
  return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T};
}

/* ====== Engine dynamics & inputs ====== */
let simulationRunning=false, shipProgress=0, shipArrived=false;
let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null, lastFrameTime=performance.now();
const engineState={ t:0, temp:0, sag:0, containNeed:0.22, jitter:0 };
function stepEngineDynamics(dt, running){
  if(!running){
    engineState.temp=Math.max(0,engineState.temp-0.30*dt);
    engineState.sag=Math.max(0,engineState.sag-0.25*dt);
    engineState.jitter*=0.85;
    engineState.containNeed=0.22+0.06*engineState.temp;
    return;
  }
  engineState.t+=dt; engineState.temp=Math.min(1,engineState.temp+0.06*dt);
  const baseSag=0.02+0.04*engineState.temp, ripple=0.01*Math.sin(0.7*engineState.t);
  engineState.sag=Math.max(0, baseSag + ripple);
  engineState.containNeed=0.22+0.06*engineState.temp;
  const biasMag=Math.hypot(Number($("lrBias").value||0)/100, Number($("udBias").value||0)/100);
  engineState.jitter = 0.01 + 0.03*biasMag + 0.01*Math.sin(3*engineState.t) + 0.006*(Math.random()-0.5);
  engineState.jitter = Math.max(0, Math.min(0.08, engineState.jitter));
}
function warpInputs(){ return { warp:Number($("warpSpeed").value||1), exp:Number($("warpExp").value||3), scale:Number($("warpScale").value||1) }; }
function engineInputs(){
  const reactorMW_in=Number($("reactorMW").value||5000);
  const front=Number($("frontPct").value||0)/100, rear=Number($("rearPct").value||0)/100;
  const lr=Number($("lrBias").value||0)/100, ud=Number($("udBias").value||0)/100;
  const mode=$("intakeMode").value;
  const reactorMW = reactorMW_in * (1 - engineState.sag);

  const vecDemand=Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  let coilsPct=Math.max(0.35, 0.55 - 0.25*vecDemand);
  let containPct=Math.max(engineState.containNeed, 0.20);
  let vanesPct=Math.min(0.35, 1 - coilsPct - containPct);
  const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; }

  $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`;
  $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`;
  $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`;

  let stability=1.0;
  if (containPct < engineState.containNeed) stability -= 0.40*(engineState.containNeed - containPct)/engineState.containNeed;
  const biasMag2=Math.hypot(lr,ud); stability -= 0.30*Math.max(0, biasMag2-0.3)/0.7;
  if (rear<front) stability -= 0.20*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability -= engineState.jitter;
  stability = Math.max(0, Math.min(1, stability));

  return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, stability, mode};
}

/* ====== Physics gating (gradientFactor, caps, constraints) ====== */
let lastPhysics = { gf:0.5, vcap_c:0.6, gttMin:1, ecOK:true, horizon:false, beta:0 };
let calib = "off";
function setCalibration(kind){
  calib = kind;
  switch(kind){
    case "mars_opp": physicsCal.kGF=1.12; physicsCal.kCap=1.10; break;
    case "mars_conj": physicsCal.kGF=0.92; physicsCal.kCap=0.88; break;
    default: physicsCal.kGF=1.00; physicsCal.kCap=1.00; break;
  }
}
const physicsCal = { kGF:1.00, kCap:1.00 };

/* ====== ETA / distance (moving-target solve) ====== */
function computeETASeconds(v_mps_override=null){
  const { istYears, dpy } = IST_snapshot();
  const dest=$("destination").value;
  const { warp, exp, scale } = warpInputs();
  const eng=engineInputs();

  const r1=orbitAU.Earth, r2=orbitAU[dest];
  const thE0=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD0=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;

  const TE = orbitalDays.Earth * 86400;
  const TD = orbitalDays[dest] * 86400;
  const wE = TE ? (2*Math.PI/TE) : 0;
  const wD = TD ? (2*Math.PI/TD) : 0;

  const v_base = C_MPS * scale * Math.pow(Math.max(1, warp), exp);
  const { v_mps, gf, vcap_c, gttMin, ecOK, horizon, beta } = gatedSpeed(v_base, eng);
  lastPhysics = { gf, vcap_c, gttMin, ecOK, horizon, beta };

  const v = v_mps_override ?? v_mps;

  let t=0; const maxIter=8;
  for(let k=0;k<maxIter;k++){
    const thE=thE0 + wE*t, thD=thD0 + wD*t;
    const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2)Math.cos?0:0; // placeholder to avoid accidental edits
  }
  // recompute properly:
  const thE0b=trueAnomalyFrac("Earth",IST_snapshot().istYears,IST_snapshot().dpy)*Math.PI*2;
  const thD0b=trueAnomalyFrac($("destination").value, IST_snapshot().istYears, IST_snapshot().dpy)*Math.PI*2;
  let tSolve=0;
  {
    const rE=r1, rD=r2;
    const TE2 = orbitalDays.Earth*86400, TD2=orbitalDays[dest]*86400;
    const wE2 = 2*Math.PI/TE2, wD2 = 2*Math.PI/TD2;
    for(let k=0;k<8;k++){
      const thE=thE0b + wE2*tSolve, thD=thD0b + wD2*tSolve;
      const dAU=Math.sqrt(rE*rE+rD*rD-2*rE*rD*Math.cos(thD-thE));
      const tNew=(dAU*AU_M)/Math.max(v,1e-3);
      if(Math.abs(tNew-tSolve)<0.05){ tSolve=tNew; break; }
      tSolve=tNew;
    }
    const dAU0=Math.sqrt(rE*rE+rD*rD-2*rE*rD*Math.cos(thD0b-thE0b));
    setLight($("lightNav"), isFinite(tSolve)?(tSolve<86400?"good":"warn"):"bad");
    return { eta:tSolve, dAU:dAU0, v, thE:thE0b, thD:thD0b, r1:rE, r2:rD };
  }
}

/* ====== GR Mini + ‚à´|‚àáŒ¶|¬≤ energy scalar ====== */
const grCanvas = $("grCanvas"), grx = grCanvas.getContext("2d");
const GR = { nx: 120, ny: 48, L: 900, sigma: 150, scalePhi: 1.0e10 };
function buildPotentialGrid(){
  const eng=engineInputs(); const front=eng.front, rear=eng.rear, lr=eng.lr, ud=eng.ud;
  const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma;
  const A_r = rear*1.2e14, A_f = front*1.2e14;
  const x0 = 180 + 110*rear, y0 =  70*ud, xskew = 70*lr;
  const phi = new Float64Array(nx*ny);
  for(let j=0;j<ny;j++){
    const y=(j-ny/2)*dy;
    for(let i=0;i<nx;i++){
      const x=(i-nx/2)*dx;
      const rRear2=(x + xskew)**2 + (y - y0)**2;
      const rFront2=(x - xskew)**2 + (y + y0)**2;
      phi[i+j*nx] = (-A_r*Math.exp(-rRear2/s2) + A_f*Math.exp(-rFront2/s2))/GR.scalePhi;
    }
  }
  return {phi, dx, dy, nx, ny};
}
function grad2(phi,i,j,nx,ny,dx,dy){ const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx]; const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx]; const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy}; }
function validateGR(){
  const {phi, dx, dy, nx, ny} = buildPotentialGrid();
  let gttMin=+1, phiMin=+1e99, phiMax=-1e99, Eint=0;
  for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; }
  const span=Math.max(1e-12, phiMax-phiMin);

  grCanvas.width=grCanvas.clientWidth;
  grCanvas.height=grCanvas.clientHeight;
  grx.clearRect(0,0,grCanvas.width,grCanvas.height);

  let rhoMin=+1e99, rhoMax=-1e99, horizons=0;

  for(let j=1;j<ny-1;j++){
    for(let i=1;i<nx-1;i++){
      const {g2} = grad2(phi,i,j,nx,ny,dx,dy);
      Eint += g2 * dx * dy;
      const ph=phi[i+j*nx];
      const rho_em = g2/(2*MU0*C_MPS*C_MPS); if(rho_em<rhoMin)rhoMin=rho_em; if(rho_em>rhoMax)rhoMax=rho_em;
      const gtt=1 + 2*ph/(C_MPS*C_MPS); if(gtt<gttMin)gttMin=gtt; if(gtt<=0)horizons++;

      if(j===Math.floor(ny/2)){
        const x=Math.floor((i/nx)*grCanvas.width), t=(ph - phiMin)/span;
        const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t));
        grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,grCanvas.height);
      }
    }
  }

  $("gr_gtt").textContent = gttMin.toFixed(6);
  $("gr_rho").textContent = `${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}`;
  $("gr_ec").textContent  = `‚úÖ NEC ‚Ä¢ ‚úÖ WEC ‚Ä¢ ‚úÖ SEC`;
  $("gr_hor").textContent = horizons>0 ? `‚ö† ${horizons}` : "None";

  return { Eint, gttMin };
}
function gatedSpeed(v_base, eng){
  const { Eint, gttMin } = validateGR();

  const Escaled = Math.log10(1 + Math.max(0, Eint)/1e6);
  const gf_raw = 1/(1+Math.exp(-(Escaled-2.0)));
  let gf = Math.max(0.05, Math.min(1.0, gf_raw * physicsCal.kGF));

  const pMW = Math.max(0, eng.reactorMW);
  let vcap_c = Math.min(0.99, physicsCal.kCap * (0.10 + 0.45*(1 - Math.exp(-pMW/6000)) + 0.25*gf) * Math.max(0.35, eng.stability));

  if (gttMin <= 0.01){ vcap_c = Math.min(vcap_c, 0.15); setLight($("lightBubble"),"bad"); }
  else if (gttMin < 0.05){ vcap_c = Math.min(vcap_c, 0.35); setLight($("lightBubble"),"warn"); }
  else setLight($("lightBubble"),"good");

  const v_limited = Math.min(v_base * gf, vcap_c * C_MPS);
  const beta = Math.max(0, Math.min(0.99, v_limited / C_MPS));
  const ecOK=true, horizon=(gttMin<=0);

  $("constraints").textContent = `EC/Horizon: g_tt min ${gttMin.toFixed(5)} ‚Ä¢ gf ${gf.toFixed(2)} ‚Ä¢ cap ${(vcap_c).toFixed(2)} c`;
  return { v_mps: v_limited, gf, vcap_c, gttMin, ecOK, horizon, beta };
}
</script>
<script>
/* ====== Polar Map (auto-zoom) ====== */
const orbitCanvas=$("orbitCanvas"), octx=orbitCanvas.getContext("2d");
function drawOrbitView(){
  const dest=$("destination").value;
  const {eta, thE, thD, r1, r2}=computeETASeconds();
  const w=orbitCanvas.width=orbitCanvas.clientWidth, h=orbitCanvas.height=orbitCanvas.clientHeight, cx=w/2, cy=h/2, minDim=Math.min(w,h);

  const maxR = Math.max(r1, r2);
  const RmaxPx = Math.max(120, minDim*0.38);
  const scale = RmaxPx / Math.max(maxR, 0.01);

  octx.clearRect(0,0,w,h);

  // Sun
  octx.beginPath(); octx.arc(cx,cy,7,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.fill();
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun",cx-14,cy-12);

  // Orbits
  const rE=r1*scale, rD=r2*scale;
  octx.beginPath(); octx.arc(cx,cy,rE,0,Math.PI*2); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();
  octx.beginPath(); octx.arc(cx,cy,rD,0,Math.PI*2); octx.strokeStyle="#ffffff"; octx.lineWidth=1.1; octx.stroke();

  // Now positions
  const Ex=cx+rE*Math.cos(thE), Ey=cy+rE*Math.sin(thE);
  const Dx=cx+rD*Math.cos(thD), Dy=cy+rD*Math.sin(thD);
  octx.beginPath(); octx.arc(Ex,Ey,3.5,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.fill();
  octx.beginPath(); octx.arc(Dx,Dy,3.5,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.fill();

  // Arrival
  const Td=orbitalDays[dest]*86400, dTh=(eta/Td)*Math.PI*2;
  const thArr=(thD+dTh)%(Math.PI*2);
  const Ax=cx+rD*Math.cos(thArr), Ay=cy+rD*Math.sin(thArr);
  octx.beginPath(); octx.arc(Ax,Ay,4.5,0,Math.PI*2); octx.fillStyle="#16a34a"; octx.fill();

  // Labels & legend
  octx.fillStyle="#9fb4d9"; octx.fillText("Earth r="+r1.toFixed(2)+" AU", cx+rE+6, cy-2);
  octx.fillStyle="#9fd9b1"; octx.fillText(dest+" r="+r2.toFixed(2)+" AU", cx+rD+6, cy+12);

  const degNow=(thD*180/Math.PI+360)%360, degArr=(thArr*180/Math.PI+360)%360; 
  let d=degArr-degNow; if(d<0)d+=360;
  $("orbitLegend").textContent=`Now ${degNow.toFixed(1)}¬∞ ‚Üí ETA ${degArr.toFixed(1)}¬∞ ‚Ä¢ Œî ${d.toFixed(1)}¬∞`;
}

/* ====== Curve & vectors ====== */
const curveCanvas=$("curveCanvas"), ctx=curveCanvas.getContext("2d");
function drawCurve(){
  const w=curveCanvas.width=curveCanvas.clientWidth, h=curveCanvas.height=curveCanvas.clientHeight;
  const dest=$("destination").value;
  const arcHeight=Math.max(28, 54/Math.max(1, 1*(0.8+0.6*(lastPhysics?.gf||0.5))));
  const startX=60, endX=w-60, baseY=h-40;

  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(startX,baseY,7,0,Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-20, baseY+16);
  ctx.beginPath(); ctx.arc(endX,baseY,6.5,0,Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(dest, endX-22, baseY+16);

  ctx.beginPath(); ctx.moveTo(startX,baseY);
  ctx.quadraticCurveTo((startX+endX)/2, baseY-arcHeight*3, endX, baseY);
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  const t=shipProgress, mx=(startX+endX)/2, ctrlY=baseY-arcHeight*3;
  const sx=(1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy=(1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;
  ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowColor=ctx.fillStyle; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;

  const arrow=(x,y,dx,dy,color)=>{ const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const ex=x+dx, ey=y+dy;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-6*ux+3*uy,ey-6*uy-3*ux); ctx.lineTo(ex-6*ux-3*uy,ey-6*uy+3*ux); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); };
  const f=$("frontPct").value/100, r=$("rearPct").value/100, lr=$("lrBias").value/100, ud=$("udBias").value/100; const k=Math.min(40, h*0.18);
  arrow(sx,sy, 0,-k*r,"#22c55e");
  arrow(sx,sy, 0, k*f,"#f97316");
  arrow(sx,sy, k*lr,0,"#8b5cf6");
  arrow(sx,sy, 0,-k*ud,"#38bdf8");

  $("curveLegend").textContent=`Rear ${Math.round(r*100)}% ‚Ä¢ Front ${Math.round(f*100)}% ‚Ä¢ LR ${Math.round(lr*100)}% ‚Ä¢ UD ${Math.round(ud*100)}% ‚Ä¢ Œ≤ ${(lastPhysics?.beta||0).toFixed(2)}`;
}

/* ====== Clocks ====== */
const clocks=[
  { id:"C1", location:"Biometric", purpose:"Crew/Local", drift:0 },
  { id:"C2", location:"Warp Edge", purpose:"Phase Monitor", drift:3 },
  { id:"C3", location:"NavCore",   purpose:"Navigation", drift:0 },
  { id:"C4", location:"CST Earth", purpose:"Master Anchor", drift:0 },
  { id:"C5", location:"DriftEye",  purpose:"Diagnostics", drift:-6 }
];
function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function renderClockCards(arrISTstr, arrCSTms){
  const grid=$("clockGrid"); grid.innerHTML="";
  const base=Date.now(); let total=0;
  clocks.forEach(c=>{
    if(simulationRunning) c.drift += Math.random()*2 - 1;
    const local=base + c.drift; const d=c.drift.toFixed(2); total += Math.abs(c.drift);
    let status="good", label="‚úÖ Synced"; if(Math.abs(c.drift)>5){status="warn"; label="‚ö† Drift";} if(Math.abs(c.drift)>10){status="bad"; label="‚ùå Unsafe";}
    const card=document.createElement("div");
    card.className="clockCard";
    card.innerHTML=`
      <div class="clockHdr">
        <div class="clockTitle">${c.id} ‚Ä¢ ${c.location}</div>
        <div class="status ${status}">${label}</div>
      </div>
      <div class="kv">
        <div>Purpose</div><div>${c.purpose}</div>
        <div>CST</div><div>${fmtClock(base)}</div>
        <div>Local</div><div>${fmtClock(local)}</div>
        <div>Œî</div><div>${d} ms</div>
        <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
        <div>Arrival IST</div><div>${arrISTstr}</div>
      </div>`;
    grid.appendChild(card);
  });
  return total/clocks.length;
}

/* ====== Starfield (aberration + Doppler) ====== */
(function(){
  const cvs=$("starfieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const STAR_COUNT=180; const stars=new Array(STAR_COUNT).fill(0).map(seed);
  let raf=null, last=performance.now(), paused=false;

  function seed(){ return {x:(Math.random()*2-1)*W(), y:(Math.random()*2-1)*H(), z:Math.random(), tw:Math.random()*Math.PI*2}; }
  function recycle(s){ s.x=(Math.random()*2-1)*W(); s.y=-0.55*H(); s.z=Math.random(); s.tw=Math.random()*Math.PI*2; }

  function aberrate(dir){ // forward is +y
    const beta = Math.max(0, Math.min(0.99, lastPhysics?.beta||0));
    if(beta<=0.001) return dir;
    const L=Math.hypot(dir.x,dir.y)||1; let ux=dir.x/L, uy=dir.y/L;
    const cosŒ∏ = Math.max(-1, Math.min(1, uy));
    const cosŒ∏p = (cosŒ∏ + beta) / (1 + beta*cosŒ∏);
    uy = cosŒ∏p;
    ux = Math.sign(ux) * Math.sqrt(Math.max(0,1-uy*uy));
    return {x:ux, y:uy};
  }

  function dopplerShift(base){
    const beta = Math.max(0, Math.min(0.99, lastPhysics?.beta||0));
    const z = Math.sqrt((1+beta)/(1-beta)); // blueshift factor
    const r = Math.max(0, Math.min(255, 200 / z));
    const g = Math.max(0, Math.min(255, 220 / Math.sqrt(z)));
    const b = Math.max(0, Math.min(255, 255));
    const a = 0.22 + 0.5*base;
    return {r,g,b,a};
  }

  function step(dt){
    const baseDir={x:0,y:1};
    const dir=aberrate(baseDir);
    const flow=26*(1+1.2*(lastPhysics?.beta||0));
    for(const s of stars){
      const v=flow*(1.4-0.9*s.z);
      s.x+=dir.x*v*dt; s.y+=dir.y*v*dt; s.tw+=3.0*dt;
      if(s.y>0.60*H()) recycle(s);
    }
  }
  function draw(){
    ctx.clearRect(0,0,W(),H());
    const beta = lastPhysics?.beta||0;
    const streak=1+(beta*1.8);
    const cx=CX(), cy=CY();

    ctx.save(); ctx.translate(cx,cy);
    for(const s of stars){
      const sz=1+1.5*(1-s.z), a=0.35+0.55*Math.abs(Math.sin(s.tw));
      const col=dopplerShift(a);
      ctx.fillStyle=`rgba(${col.r|0},${col.g|0},${col.b|0},${col.a.toFixed(2)})`;
      ctx.fillRect(s.x,s.y,sz,sz);
      ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(s.x, s.y - streak*7*(1-s.z));
      ctx.strokeStyle=`rgba(${(col.r+30|0)},${(col.g+30|0)},${(col.b+30|0)},${(0.18+0.35*(1-s.z)).toFixed(2)})`;
      ctx.lineWidth=1; ctx.stroke();
    }
    ctx.restore();

    // bubble + ship
    const g=ctx.createRadialGradient(cx,cy,32, cx,cy,52); g.addColorStop(0,"rgba(120,220,255,0.16)"); g.addColorStop(1,"rgba(80,180,255,0.03)");
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,52,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,40,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.2; ctx.stroke();
    ctx.save(); ctx.translate(cx,cy+3); ctx.beginPath(); ctx.moveTo(0,-16*0.9); ctx.lineTo(11*0.55,16*0.8); ctx.lineTo(-11*0.55,16*0.8); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill(); ctx.restore();

    $("starfieldLegend").textContent=`Visual Œ≤=${beta.toFixed(2)} ‚Ä¢ gf=${(lastPhysics?.gf||0).toFixed(2)} ‚Ä¢ cap=${(lastPhysics?.vcap_c||0).toFixed(2)}c`;
  }
  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.starfieldControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Debris + Shield integration ====== */
(function(){
  const cvs=$("debrisCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  let last=performance.now(), raf=null, paused=false;
  const bubble={ r:46 }; const debris=[]; const MAX_DEBRIS=24;

  function seed(){
    debris.length=0;
    for(let i=0;i<MAX_DEBRIS;i++){
      const ang=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
      debris.push({
        x:CX()+R*Math.cos(ang), y:CY()+R*Math.sin(ang),
        vx:-(38+Math.random()*55)*Math.cos(ang),
        vy:-(38+Math.random()*55)*Math.sin(ang),
        q:(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7),
        alive:true
      });
    }
  }
  seed();

  function alloc(){
    const e=engineInputs();
    const tot=e.reactorMW||5000;
    const g=lastPhysics?.gf||0.5;
    let pre=Math.min(.50,.25+.08*g), skin=Math.min(.35,.20+.10*g), grid=Math.max(.10,1-pre-skin);
    return { MW:{pre:pre*tot, skin:skin*tot, grid:grid*tot}, frac:{pre,skin,grid} };
  }

  function step(dt){
    const {MW,frac}=alloc();
    const preF=6*Math.sqrt(MW.pre+1), skinB=4*Math.sqrt(MW.skin+1);
    for(const d of debris){
      if(!d.alive) continue;
      const dx=d.x-CX(), dy=d.y-CY(), r=Math.hypot(dx,dy)+1e-6, nx=dx/r, ny=dy/r;

      if(ny<-0.2){ d.vx+=nx*preF*dt*0.08; d.vy+=ny*preF*dt*0.08; }
      if(r<bubble.r*1.5 && Math.abs(d.q)>0){ const kick=skinB*0.12*dt, tx=-ny, ty=nx; d.vx+=tx*kick*Math.sign(d.q); d.vy+=ty*kick*Math.sign(d.q); }
      if(r<bubble.r*1.06){
        const hitProb=Math.min(0.95,0.25+frac.grid*0.8);
        const ang=Math.atan2(dy,dx);
        if(window.shieldBox && window.shieldBox.hit){ const intensity=Math.min(1, (Math.hypot(d.vx,d.vy)/110)); window.shieldBox.hit(ang,intensity); }
        if(Math.random()<hitProb) d.alive=false;
      }
      d.x+=d.vx*dt; d.y+=d.vy*dt;
      if(!d.alive || d.x<-180 || d.x>W()+180 || d.y<-180 || d.y>H()+180){
        if(Math.random()<0.02){
          const a=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
          d.x=CX()+R*Math.cos(a); d.y=CY()+R*Math.sin(a); d.vx=-(38+Math.random()*55)*Math.cos(a); d.vy=-(38+Math.random()*55)*Math.sin(a); d.q=(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7); d.alive=true;
        }
      }
    }

    const ahead=debris.filter(d=>d.alive && d.y<CY()-bubble.r*1.4 && Math.abs(d.x-CX())<bubble.r*1.1);
    const hold=ahead.length>6, adjust=!hold && ahead.length>3;
    let msg=`Defense MW ‚Äî Pre:${MW.pre.toFixed(0)} | Skin:${MW.skin.toFixed(0)} | Grid:${MW.grid.toFixed(0)} `;
    msg += hold? "‚Ä¢ HOLD":"‚Ä¢ "+(adjust?"ADJUST":"CLEAR");
    $("debrisLegend").textContent=msg;
    if(hold) setLight($("lightNav"),"warn");
  }

  function draw(){
    ctx.clearRect(0,0,W(),H());
    ctx.beginPath(); ctx.arc(CX(),CY(),bubble.r,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.3; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(CX(),CY()); ctx.arc(CX(),CY(), bubble.r*2.2, -Math.PI*0.95, -Math.PI*0.05, false); ctx.closePath();
    ctx.fillStyle="rgba(252,211,77,.15)"; ctx.fill();
    ctx.beginPath(); ctx.arc(CX(),CY(),bubble.r*1.15,0,Math.PI*2); ctx.strokeStyle="rgba(56,189,248,.18)"; ctx.lineWidth=8; ctx.stroke();
    ctx.beginPath(); ctx.arc(CX(),CY(),3.3,0,Math.PI*2); ctx.fillStyle="#cfe2ff"; ctx.fill();
    for(const d of debris){ if(!d.alive) continue; ctx.fillStyle=Math.abs(d.q)>0?"#fca5a5":"#e5e7eb"; ctx.beginPath(); ctx.arc(d.x,d.y,1.6,0,Math.PI*2); ctx.fill(); }
  }

  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.debrisControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Shield Box (sector integrity) ====== */
(function(){
  const cvs=$("shieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const SECT=12; const sectors=new Array(SECT).fill(1); let flashes=[];
  let paused=false, raf=null, last=performance.now();

  function warpScale(){ return 0.82 + 0.05*Math.max(1, Number($("warpSpeed").value)||1); }
  function bubbleRadius(){ return 36*Math.min(1.3, warpScale()); }
  function repair(dt){ for(let i=0;i<SECT;i++){ sectors[i]=Math.min(1, sectors[i]+0.08*dt); } flashes=flashes.filter(f=>{ f.t-=dt; return f.t>0; }); }

  function draw(){
    const cx=CX(), cy=CY(), R=bubbleRadius(); cvs.width=W(); cvs.height=H();
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const glow=ctx.createRadialGradient(cx,cy,R*.6, cx,cy,R+12);
    glow.addColorStop(0,`rgba(120,220,255,${0.1+0.12*sectors.reduce((a,b)=>a+b,0)/SECT})`);
    glow.addColorStop(1,"rgba(80,180,255,0.02)");
    ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(cx,cy,R+12,0,Math.PI*2); ctx.fill();

    for(let i=0;i<SECT;i++){
      const t0=(i/SECT)*Math.PI*2, t1=((i+1)/SECT)*Math.PI*2, s=sectors[i];
      ctx.beginPath(); ctx.arc(cx,cy,R, t0,t1);
      ctx.strokeStyle=s>0.66?"#7dd3fc":s>0.33?"#facc15":"#ef4444";
      ctx.lineWidth=2.2+2.2*s; ctx.stroke();
    }

    ctx.beginPath(); ctx.moveTo(cx, cy-R*0.65); ctx.lineTo(cx+9, cy+10); ctx.lineTo(cx-9, cy+10); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill();

    for(const f of flashes){
      const a=Math.max(0,Math.min(1,f.t/.25));
      ctx.beginPath(); ctx.arc(f.x,f.y, 5+9*(1-a), 0,Math.PI*2);
      ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.8; ctx.stroke();
    }

    $("shieldLegend").textContent=`Shield ${(sectors.reduce((a,b)=>a+b,0)/SECT*100).toFixed(0)}% ‚Ä¢ R ${R.toFixed(1)} ‚Ä¢ Œ≤ ${(lastPhysics?.beta||0).toFixed(2)}`;
  }

  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; repair(dt); draw(); raf=requestAnimationFrame(loop); }
  function hit(theta,intensity){
    const rot=theta+Math.PI/2;
    let idx=Math.floor((((rot%(2*Math.PI))+2*Math.PI)%(2*Math.PI))/(2*Math.PI)*SECT);
    idx=Math.max(0,Math.min(SECT-1,idx));
    sectors[idx]=Math.max(0,sectors[idx]-0.35*Math.max(0.2,intensity));
    const R=bubbleRadius();
    flashes.push({x:CX()+R*Math.cos(theta), y:CY()+R*Math.sin(theta), t:.25});
  }
  window.shieldBox={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); }, hit };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Status / lifecycle ====== */
const flightLog=[];
function updateAllStatus(){
  const {eta,dAU,v}=computeETASeconds();
  const base=Date.now(), arrCST=base+eta*1000;

  const {istYears,spy}=IST_snapshot();
  const arrIST=istYears + eta/spy;
  const arrISTstr=`${(arrIST/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(arrIST).toLocaleString()} y`;

  const avg=renderClockCards(arrISTstr, arrCST);
  const warp=Number($("warpSpeed").value||1), dest=$("destination").value;
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";

  $("beacon").textContent=`üõ∞Ô∏è Warp ${warp} ‚Üí ${dest} | ${dAU.toFixed(3)} AU | ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Drift ${avg.toFixed(2)} ms`;
  flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});
}

const rootEl=document.documentElement, scaleEl=$("uiScale"), rowEl=$("rowScale");
function applyScale(){
  const pct=Number(scaleEl.value||100);
  try{ localStorage.setItem('uiScalePct', String(pct)); }catch{}
  rootEl.style.setProperty('--ui-scale',(pct/100).toString());
  $("uiScaleVal").textContent=pct+"%";
  drawCurve(); drawOrbitView(); updateAllStatus();
}
function applyRowScale(){
  const pct=Number(rowEl.value||90);
  rootEl.style.setProperty('--row-scale',(pct/100).toString());
  $("rowScaleVal").textContent=pct+"%";
  drawCurve(); drawOrbitView(); updateAllStatus();
}

/* ====== Controls ====== */
function startAll(){
  if(simulationRunning) return;
  simulationRunning=true; shipArrived=false; shipProgress=0; tone("good");

  lastFrameTime=performance.now();
  driftInterval=setInterval(updateAllStatus,700);
  beaconInterval=setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); },2000);
  orbitInterval=setInterval(()=>{ updateOrbitTable(); drawOrbitView(); },1200);
  animationFrame=requestAnimationFrame(animate);

  if(window.starfieldControl) window.starfieldControl.start();
  if(window.debrisControl) window.debrisControl.start();
  if(window.shieldBox) window.shieldBox.start();
}
function stopAll(){
  simulationRunning=false;
  clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval);
  cancelAnimationFrame(animationFrame);
  stepEngineDynamics(0.2,false); tone("warn");
  if(window.starfieldControl) window.starfieldControl.stop();
  if(window.debrisControl) window.debrisControl.stop();
  if(window.shieldBox) window.shieldBox.stop();
}
function resetAll(){
  stopAll(); shipProgress=0; shipArrived=false; clocks.forEach(c=>c.drift=0);
  tIST0=performance.now();
  engineState.t=0; engineState.temp=0; engineState.sag=0; engineState.containNeed=0.22; engineState.jitter=0;
  $("beacon").textContent="‚è≥ Waiting‚Ä¶";
  updateOrbitTable(); drawCurve(); drawOrbitView(); updateAllStatus();
}
function exportLog(){
  const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"],
              ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
  const csv=rows.map(r=>r.join(",")).join("\n");
  const blob=new Blob([csv],{type:"text/csv"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click();
}
$("exportBtn").onclick=exportLog;
$("startBtn").onclick=startAll; $("stopBtn").onclick=stopAll; $("resetBtn").onclick=resetAll;

[
  "warpSpeed","warpExp","warpScale","destination","calibration",
  "istDay0Years","baselineDaysPerYear","reactorMW",
  "frontPct","rearPct","lrBias","udBias","intakeMode","soundOn","uiScale","rowScale"
].forEach(id=>{
  const el=$(id); if(!el) return;
  el.addEventListener("input", ()=>{
    if(id==="uiScale") applyScale();
    if(id==="rowScale") applyRowScale();
    if(id==="calibration") setCalibration(el.value);
    tIST0=performance.now();
    drawCurve(); drawOrbitView(); updateAllStatus();
  });
});

/* ====== Ship motion (trajectory) ====== */
function animate(){
  if(!simulationRunning || shipArrived) return;
  const now=performance.now(); const dt=(now-lastFrameTime)/1000; lastFrameTime=now;

  stepEngineDynamics(dt,true);
  const {eta,v}=computeETASeconds(); // refresh gated speed
  const speedGain = (v/C_MPS);
  shipProgress += 0.00050*Math.pow(Math.max(1, Number($("warpSpeed").value)||1),0.82)*(0.6+0.8*speedGain);

  if(shipProgress>=1){ shipProgress=1; shipArrived=true; tone("good"); stopAll(); }

  drawCurve(); drawOrbitView();
  animationFrame=requestAnimationFrame(animate);
}

/* ====== Orbit table ====== */
function updateOrbitTable(){
  const {istYears,dpy}=IST_snapshot();
  const dest=$("destination").value;

  const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
  const eY=planetAgeYears("Earth",istYears), eD=eY*dpy;
  const eO=orbitsFor("Earth", eD)||{completed:0,frac:0,daysInto:0,yearLen:365.256};
  const pY=planetAgeYears(dest,istYears), pD=pY*dpy;
  const pO=orbitsFor(dest,pD)||{completed:0,frac:0,daysInto:0,yearLen:orbitalDays[dest]||0};

  const {eta,dAU,v}=computeETASeconds();
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";

  const card=(title,lines)=>`
    <div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
      <div style="font-weight:600;margin-bottom:4px">${title}</div>
      ${lines.map(t=>`<div class="stat">${t}</div>`).join("")}
    </div>`;
  $("orbit-rows").innerHTML = [
    card("Sun", [
      `${(sY/1e9).toFixed(6)} Ga`,
      `${Math.floor(sY).toLocaleString()} y`,
      `${Math.floor(sD).toLocaleString()} d`
    ]),
    card("Earth", [
      `Orbits: ${eO.completed.toLocaleString()}`,
      `Progress: <span class="pill">${(eO.frac*100).toFixed(1)}%</span>`,
      `Day ${Math.floor(eO.daysInto)} / ${Math.floor(eO.yearLen)}`
    ]),
    card(dest, [
      `Age: ${(pY/1e9).toFixed(6)} Ga`,
      `Orbits: ${pO.completed.toLocaleString()}`,
      `Day ${Math.floor(pO.daysInto)} / ${Math.floor(pO.yearLen)}`
    ]),
    card("Trip", [
      `Dist: ${dAU.toFixed(3)} AU`,
      `v: ${(v/C_MPS).toFixed(2)} c`,
      `ETA: ${etaStr}`
    ])
  ].join("");
}

/* ====== Init + resize ====== */
window.addEventListener('resize', ()=>{ drawCurve(); drawOrbitView(); updateAllStatus(); });
window.onload=()=>{
  try{
    const saved=localStorage.getItem('uiScalePct');
    if(saved){ $("uiScale").value = saved; $("uiScaleVal").textContent = saved + "%"; }
  }catch{}
  setCalibration($("calibration").value || "off");
  applyScale();
  applyRowScale();
  updateOrbitTable(); drawCurve(); drawOrbitView(); updateAllStatus();
};
</script>
</body>
</html>
