<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Engine – CST-Aligned FTL Jump Demo</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;background:#0b1020;color:#eaf0ff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  a{color:#9bb4ff}
  .wrap{max-width:1800px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:16px;align-items:start}
  .panel{background:#12183a;border:1px solid #22305c;border-radius:16px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
  h1{margin:.2rem 0 .4rem;font-size:26px}
  h2{margin:.4rem 0 .3rem;font-size:16px;color:#b8c4ff}
  label{display:block;margin:.4rem 0 .25rem;color:#b8c4ff}
  input[type=range]{width:100%}
  input[type=number], select{
    width:100%;padding:6px 8px;border-radius:8px;border:1px solid #22305c;
    background:#0b1020;color:#eaf0ff;font-size:13px;
  }
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .stats{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
  .stat{background:#0e1536;border:1px solid #22305c;border-radius:12px;padding:8px}
  .big{font-size:22px;font-weight:600}
  .muted{font-size:12px;color:#b8c4ff}
  canvas{
    width:100%;
    height:900px;
    background:radial-gradient(1600px 900px at 50% 50%, #0f1740 0%, #0b1020 60%)
  }
  .legend{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
  .legend div{display:flex;align-items:center;gap:8px;color:#b8c4ff}
  .dot{width:12px;height:12px;border-radius:50%}
  .note{color:#b8c4ff;font-size:12px;margin-top:8px}
  button{
    background:#1a245a;color:#eaf0ff;border:1px solid #22305c;border-radius:10px;
    padding:8px 10px;cursor:pointer;font-size:13px
  }
  button:hover{filter:brightness(1.1)}
  .tests{margin-top:10px;font-size:12px;color:#b8c4ff}
  .steps ol{margin:.4rem 0 .2rem;padding-left:1.1rem}
  .telemetry{margin-top:10px;border-top:1px solid #22305c;padding-top:10px}
  .trow{display:grid;grid-template-columns:170px 1fr 88px;gap:8px;align-items:center;margin:6px 0}
  .tname{color:#b8c4ff;font-size:13px}
  .tval{font-variant-numeric:tabular-nums;font-size:13px;text-align:right}
  .gauge{height:8px;background:#0e1536;border:1px solid #22305c;border-radius:16px;overflow:hidden}
  .gauge>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#6bd1ff,#9bb4ff)}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .clockbox{background:#0e1536;border:1px solid #22305c;border-radius:10px;padding:8px;font-size:12px}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3a78;font-size:11px;color:#a9b6ff;background:#0d1540}
  .badge-ok{border-color:#1f5c3a;color:#7bffb1}
  .badge-warn{border-color:#5d4c1a;color:#ffd37a}
  .badge-bad{border-color:#5c1f2f;color:#ff8c8c}
  .jump-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .jp-row{display:grid;grid-template-columns:120px 1fr;gap:6px;font-size:12px;margin:2px 0}
  .jp-label{color:#aeb9ff}
  .jp-val{font-variant-numeric:tabular-nums}
  .small{font-size:11px;color:#9ca3ff}
  .mapbox{margin-top:8px;padding:8px;border-radius:10px;border:1px solid #22305c;background:#0d1540;font-size:12px}
  .map-meter{height:6px;border-radius:6px;overflow:hidden;background:#050816;margin-top:4px}
  .map-meter span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#7bffb1,#22c55e)}
  .two-col{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
  @media (max-width: 1200px){ .grid{grid-template-columns:1fr} .two-col{grid-template-columns:1fr} }
  .datatable{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:12px;border:1px solid #22305c;background:#0e1536}
  .datatable caption{caption-side:top;text-align:left;padding:8px 10px;color:#b8c4ff;font-weight:600}
  .datatable th,.datatable td{padding:10px 12px;border-bottom:1px solid #1b2852;font-size:13px;vertical-align:top}
  .datatable th{color:#cfe2ff;text-align:left;background:#101c47;font-weight:600;position:sticky;top:0}
  .datatable tr:last-child td{border-bottom:0}
  .datatable tbody tr:hover{background:#0f1a3d}
  .list{margin:.25rem 0 .5rem;padding-left:1.1rem}
  .list li{margin:.25rem 0}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Warp Engine – CST-Aligned FTL Jump Demo</h1>
    <p class="note">
      Engine geometry is unchanged. This version adds real SR/GR, sidereal, RA/Dec and light-time equations
      to the <b>telemetry, jump planner and CST clock</b>. Local plasma stays subluminal; FTL is shown as
      <b>apparent coordinate speed</b> from spacetime shaping, not as matter breaking \(c\).
    </p>

    <div class="grid">
      <!-- LEFT CONTROL + TELEMETRY + JUMP PANEL -->
      <div class="panel">
        <h2>Controls</h2>
        <label for="warp">Warp Factor (1 to 10)</label>
        <input id="warp" type="range" min="1" max="10" step="1" value="3"/>
        <div class="row">
          <button id="play">Play</button>
          <button id="pause">Pause</button>
          <button id="reset">Reset</button>
          <label style="margin-left:auto;display:flex;align-items:center;gap:6px">
            <input id="labels" type="checkbox" checked/> Show labels
          </label>
        </div>
        <div class="stats">
          <div class="stat"><div class="big" id="speed">x3.0</div><div class="muted">Animation speed</div></div>
          <div class="stat"><div class="big" id="field">1.6 x D</div><div class="muted">Field radius vs engine</div></div>
          <div class="stat"><div class="big" id="temp">Warm</div><div class="muted">Heat/Cool balance</div></div>
          <div class="stat"><div class="big" id="time">1.00 x</div><div class="muted">Clock rate (SR×GR vs CST)</div></div>
        </div>

        <div class="legend">
          <div><span class="dot" style="background:#9bb4ff"></span> Photon/ion stream</div>
          <div><span class="dot" style="background:#33e1b5"></span> Magnetic field lines</div>
          <div><span class="dot" style="background:#ffcc66"></span> Heat tracers</div>
          <div><span class="dot" style="background:#6bd1ff"></span> Coolant (water) tracers</div>
          <div><span class="dot" style="background:#b26bff"></span> Entanglement particles</div>
          <div><span class="dot" style="background:#ffdca8"></span> Plasma light cone</div>
          <div><span class="dot" style="background:#8aff9b"></span> Detection lasers</div>
        </div>

        <div id="tests" class="tests">Self-tests running…</div>

        <!-- Real-time Telemetry -->
        <div class="telemetry">
          <h2>Real-time Telemetry</h2>
          <div class="trow"><div class="tname">Animation Speed</div><div class="gauge"><span id="g_speed"></span></div><div id="v_speed" class="tval">x1.0</div></div>
          <div class="trow"><div class="tname">Field Radius (×D)</div><div class="gauge"><span id="g_field"></span></div><div id="v_field" class="tval">1.20</div></div>
          <div class="trow"><div class="tname">Field Shield (%)</div><div class="gauge"><span id="g_fshield"></span></div><div id="v_fshield" class="tval">0%</div></div>
          <div class="trow"><div class="tname">Field Stretch (rx/ry)</div><div class="gauge"><span id="g_fstretch"></span></div><div id="v_fstretch" class="tval">0/0</div></div>

          <div class="trow"><div class="tname">Clock Rate (warp SR×GR)</div><div class="gauge"><span id="g_clock"></span></div><div id="v_clock" class="tval">1.00×</div></div>

          <div class="trow"><div class="tname">Photon/Ion Rate</div><div class="gauge"><span id="g_phot"></span></div><div id="v_phot" class="tval">0/s</div></div>
          <div class="trow"><div class="tname">Mag Field Strength</div><div class="gauge"><span id="g_mag"></span></div><div id="v_mag" class="tval">0.0</div></div>

          <div class="trow"><div class="tname">Core Temp (°C)</div><div class="gauge"><span id="g_tcore"></span></div><div id="v_tcore" class="tval">0°C</div></div>
          <div class="trow"><div class="tname">Coolant Temp (°C)</div><div class="gauge"><span id="g_tcool"></span></div><div id="v_tcool" class="tval">0°C</div></div>

          <div class="trow"><div class="tname">Entangle Particles</div><div class="gauge"><span id="g_ent"></span></div><div id="v_ent" class="tval">0 /s</div></div>
          <div class="trow"><div class="tname">Plasma Cone Len</div><div class="gauge"><span id="g_plen"></span></div><div id="v_plen" class="tval">0 u</div></div>
          <div class="trow"><div class="tname">Plasma Cone Rad</div><div class="gauge"><span id="g_prad"></span></div><div id="v_prad" class="tval">0 u</div></div>
          <div class="trow"><div class="tname">Plasma Wave Intensity</div><div class="gauge"><span id="g_pwave"></span></div><div id="v_pwave" class="tval">0.0</div></div>

          <div class="subgrid">
            <div class="clockbox"><div><strong>Outside Time (UTC)</strong></div><div id="clk_utc">--:--:--</div></div>
            <div class="clockbox"><div><strong>Engine Sync (CST)</strong></div><div id="clk_cst">--:--:--</div></div>
            <div class="clockbox" style="grid-column:1 / span 2">
              <div><strong>Warp-Adjusted Time</strong> (CST scaled by SR×GR)</div>
              <div id="clk_warp">--:--:--</div>
            </div>
          </div>
        </div>

        <!-- Jump Planner + Report -->
        <div class="telemetry" style="margin-top:14px">
          <h2>FTL Jump Planner &amp; Report</h2>
          <div class="jump-grid">
            <div>
              <label>Distance to Target (light-years)</label>
              <input id="inp_dist" type="number" min="0.01" step="0.01" value="4.20" />
              <label>Target RA (hours)</label>
              <input id="inp_ra" type="number" min="0" max="24" step="0.0001" value="14.6590" />
              <label>Target Dec (deg)</label>
              <input id="inp_dec" type="number" min="-90" max="90" step="0.0001" value="-60.8353" />
            </div>
            <div>
              <label>Gravity Regime</label>
              <select id="inp_grav">
                <option value="earth">Near Earth orbit</option>
                <option value="sun">Near Sun orbit</option>
                <option value="deep" selected>Deep interstellar space</option>
              </select>
              <label>Sidereal Drift Start (days since J2000)</label>
              <input id="inp_days" type="number" step="1" value="9200" />
              <label>&nbsp;</label>
              <button id="btn_jump" style="width:100%">Compute Jump</button>
            </div>
          </div>

          <div style="margin-top:8px">
            <span id="jumpStatus" class="badge badge-warn">Awaiting jump computation</span>
          </div>

          <div style="margin-top:8px" class="small">
            <b>Local plasma speed</b> stays &lt; c and feeds SR/GR. <b>Apparent FTL</b> comes from the warp factor reshaping
            CST coordinates, not matter exceeding the speed of light.
          </div>

          <div class="mapbox">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div><strong>Jump Report (CST Frame)</strong></div>
              <div id="jumpRating" class="badge badge-warn">CST alignment: —</div>
            </div>
            <div class="jp-row"><div class="jp-label">Departure (CST)</div><div class="jp-val" id="jp_dep">—</div></div>
            <div class="jp-row"><div class="jp-label">Arrival (CST coord.)</div><div class="jp-val" id="jp_arr">—</div></div>
            <div class="jp-row"><div class="jp-label">Ship proper time</div><div class="jp-val" id="jp_tau">—</div></div>
            <div class="jp-row"><div class="jp-label">Distance</div><div class="jp-val" id="jp_dist">—</div></div>
            <div class="jp-row"><div class="jp-label">Apparent velocity</div><div class="jp-val" id="jp_vapp">—</div></div>
            <div class="jp-row"><div class="jp-label">Time dilation (SR×GR)</div><div class="jp-val" id="jp_dil">—</div></div>
          </div>

          <div class="mapbox">
            <div><strong>Re-entry Accuracy Map</strong></div>
            <div class="jp-row"><div class="jp-label">Position error</div><div class="jp-val" id="jp_err">—</div></div>
            <div class="jp-row"><div class="jp-label">Vector alignment</div><div class="jp-val" id="jp_vec">—</div></div>
            <div class="map-meter"><span id="jp_meter"></span></div>
            <div class="small" id="jp_comment" style="margin-top:4px">
              Alignment and exit error depend on warp stability, entanglement rate and CST phase locking.
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: ENGINE CANVAS -->
      <div class="panel">
        <canvas id="view" width="1600" height="900"></canvas>
      </div>
    </div>
    <!-- Engine explanation + mapping -->
    <div class="panel steps">
      <h2>How this engine operates (same structure, upgraded physics)</h2>
      <ol>
        <li><strong>Intake & Magnetic Fan</strong> modulate vacuum-air circulation and seed flow to compression.</li>
        <li><strong>Compression Stages</strong> raise density/pressure via staged EM shaping and piping.</li>
        <li><strong>Reactors</strong> supply power; <strong>Electro-plasma</strong> is generated and routed.</li>
        <li><strong>Warp coils / Field shapers</strong> modulate vacuum fluctuation and form the field bubble.</li>
        <li><strong>Entangled feedback + CST clocks</strong> lock the bubble to the cosmic time axis.</li>
        <li><strong>Nozzle & Thermal management</strong> direct exhaust; water cooling maintains safe operation.</li>
      </ol>
      <p class="note">
        Geometry and labels are unchanged from your earlier prototype. The upgrade here is that the <b>CST clocks</b>,
        <b>protective field shield</b> and <b>FTL jump report</b> now use time-dilation (SR), gravitational redshift (GR),
        sidereal drift, RA/Dec mapping and light-time. The bubble “runs ahead” in CST coordinates while the ship’s
        local plasma stays subluminal.
      </p>
    </div>

    <div class="panel">
      <div class="two-col">
        <div>
          <table class="datatable" aria-label="Engine Layer mapping">
            <caption>Engine Layer ↔ Physics ↔ CST Role</caption>
            <thead>
              <tr>
                <th scope="col">Layer</th>
                <th scope="col">Physics Basis</th>
                <th scope="col">Role in Prototype</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>CST Time Lattice</td>
                <td>Sidereal vs solar drift, RA/Dec, light-time</td>
                <td>Anchors entry/exit to real sky and clock (CST alignment rating).</td>
              </tr>
              <tr>
                <td>SR/GR Dilation Core</td>
                <td>\(\Delta t'=\Delta t\sqrt{1-v^2/c^2}\), \(\Delta t'=\Delta t\sqrt{1-2GM/rc^2}\)</td>
                <td>Sets ship proper time vs CST; shapes front/back time gradient across the bubble.</td>
              </tr>
              <tr>
                <td>Field Shield Harmonics</td>
                <td>Curvature gradient &amp; time gradient</td>
                <td>Increases probability that particles are bent around the hull instead of impacting it.</td>
              </tr>
              <tr>
                <td>FTL Coordinate Layer</td>
                <td>Effective apparent \(v_{\text{app}} &gt; c\) with local \(v_{\text{local}} &lt; c\)</td>
                <td>Allows star-to-star jumps in CST coordinates without plasma breaking the speed of light.</td>
              </tr>
              <tr>
                <td>Entanglement &amp; Re-entry</td>
                <td>Phase-stable feedback channels</td>
                <td>Improves exit accuracy on the re-entry map (small AU error, high vector alignment).</td>
              </tr>
            </tbody>
          </table>
          <p class="note" style="margin-top:8px">
            <span class="badge badge-ok">Real equations</span> All equations here are standard SR/GR/astronomy
            expressions. The speculative part is how they are combined into a warp-drive control law.
          </p>
        </div>

        <div>
          <h2>Why this engine is “closer to real”</h2>
          <ul class="list">
            <li><strong>No fake math:</strong> the clock, dilation and sky alignment use accepted physics formulas.</li>
            <li><strong>CST as master clock:</strong> every jump is evaluated against a single cosmic timeline.</li>
            <li><strong>Front vs back time gradient:</strong> expands CST in front and relaxes it behind to mimic Alcubierre-style motion.</li>
            <li><strong>Protective shield as curvature gradient:</strong> stronger gradients mean more deflection of incoming particles.</li>
            <li><strong>Jump report is physical:</strong> shows SR/GR time slip, apparent FTL speed, and exit error, not just a story value.</li>
            <li><strong>Still a prototype:</strong> good enough for design reviews and thought experiments, but not yet a tested engine.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

<script>
// ===== Utility =====
const TAU = Math.PI*2;
const lerp=(a,b,t)=>a+(b-a)*t;
function drawText(ctx, s, x, y, align){
  ctx.fillStyle='#eaf0ff';
  ctx.textAlign=align||'left';
  ctx.textBaseline='middle';
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillText(s,x,y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function fmt(n,dec){ return n.toFixed(dec||0); }
function fmtLarge(n){
  var a=Math.abs(n);
  if(a>=1e12) return (n/1e12).toFixed(2)+' T';
  if(a>=1e9) return (n/1e9).toFixed(2)+' G';
  if(a>=1e6) return (n/1e6).toFixed(2)+' M';
  if(a>=1e3) return (n/1e3).toFixed(1)+' K';
  return n.toFixed(0);
}

// ===== Physics helpers (SR, GR, RA/Dec, sidereal, light-time) =====
const C = 299792.458;            // km/s
const G = 6.67430e-20;           // km^3/(kg s^2)
const M_EARTH = 5.972e24;        // kg
const R_EARTH = 6371.0;          // km
const M_SUN = 1.98847e30;        // kg
const R_SUN = 6.9634e5;          // km
const SECONDS_PER_DAY = 86400;
const LY_KM = 9.4607e12;         // km per light-year

function gammaSR(vLocal){
  if(vLocal<=0) return 1;
  const beta = vLocal/C;
  if(beta>=0.999999) return 1/Math.sqrt(1-0.999999**2);
  return 1/Math.sqrt(1-beta*beta);
}
function gravFactor(regime){
  if(regime === 'earth'){
    return Math.sqrt(1 - 2*G*M_EARTH/(R_EARTH*C*C));
  }
  if(regime === 'sun'){
    return Math.sqrt(1 - 2*G*M_SUN/(R_SUN*C*C));
  }
  return 1.0; // deep space
}
function raDecToVec(raHours, decDeg){
  const alpha = raHours * (Math.PI/12);
  const delta = decDeg * (Math.PI/180);
  const x = Math.cos(delta)*Math.cos(alpha);
  const y = Math.cos(delta)*Math.sin(alpha);
  const z = Math.sin(delta);
  return {x,y,z};
}
function siderealDrift(daysSinceJ2000){
  const perDay = (24*3600 - (23*3600 + 56*60 + 4.1)); // seconds
  return daysSinceJ2000 * perDay;
}
function lightTimeSeconds(distanceLy){
  return distanceLy * (365.25*SECONDS_PER_DAY);
}

// ===== Engine-specific helpers =====
function computeSpeedMult(w){ return lerp(1, 6, (w-1)/9); }
function computeFieldRadius(w){ return lerp(1.2, 2.6, (w-1)/9); }
function computeHeatLevel(w){ return lerp(0.35, 1.0, (w-1)/9); }
function computeCoolLevel(w){ return 1 - computeHeatLevel(w)*0.5; }
function computePlasmaLength(w){ return Math.round( lerp(90, 260, (w-1)/9) ); }
function computePlasmaRadius(w){ return Math.round( lerp(10, 36, (w-1)/9) ); }
function computeEntangleRate(w){ return lerp(0.6, 3.2, (w-1)/9); }
function computeFieldAspectX(w){ return lerp(1.0, 1.9, (w-1)/9); }
function computeFieldAspectY(w){ return lerp(0.9, 0.6, (w-1)/9); }
function computeStability(w){ var s = 1 - (w-1)/12; if(s<0.55) s=0.55; return s; }

function computeLocalSpeed(w){
  const gamma = 1 + 0.05*(w-1);
  const beta2 = 1 - 1/(gamma*gamma);
  return C*Math.sqrt(Math.max(0, beta2));
}
function computeApparentSpeed(w){
  return C * (0.2 * w); // up to ~2c at W=10
}

function computeCoreTempC(w){ return Math.round( 200 + computeHeatLevel(w)*1000 + computeSpeedMult(w)*40 ); }
function computeCoolantTempC(w){ return Math.round( 25 + computeCoolLevel(w)*300 ); }

// ===== Layout (same geometry) =====
const layout = {
  centerY: 450,
  startX: 110,
  length: 900,
  bodyR: 120,
  fanX: 85,
  stages: [
    {len:160, r:120, name:'Intake / Pre-Compression'},
    {len:120, r:112, name:'Compression Stage A'},
    {len:100, r:104, name:'Compression Stage B'},
    {len: 80, r: 96, name:'Compression Stage C'},
    {len: 70, r: 88, name:'Warp Coils / Field Shapers'},
    {len: 70, r: 80, name:'Reactors (Electro-Plasma)'},
    {len: 60, r: 72, name:'Photon/Plasma Mixer'},
    {len: 50, r: 64, name:'Nozzle Coupler'}
  ],
  nozzle:{len:160, r0:60, r1:14, name:'Exhaust Nozzle'},
  coils:[{xOff:-18, name:'Field Coil L'},{xOff:36, name:'Field Coil R'}]
};
let xx=layout.startX;
layout.stages = layout.stages.map(function(s){
  var out={x0:xx,x1:xx+s.len,len:s.len,r:s.r,name:s.name};
  xx+=s.len; return out;
});
layout.nozzle.x0 = xx;
layout.nozzle.x1 = xx + layout.nozzle.len;

// ===== State =====
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let running = true;
let t0 = performance.now();
let fanAngle = 0;
let fps = 60;
let warpClock = Date.now();
let particles = [], heat = [], cool = [], entangle = [], pipes = [];

const warpEl = document.getElementById('warp');
const speedEl = document.getElementById('speed');
const fieldEl = document.getElementById('field');
const tempEl = document.getElementById('temp');
const timeEl = document.getElementById('time');
const labelsEl = document.getElementById('labels');

// Telemetry DOM
const v_speed=document.getElementById('v_speed'), g_speed=document.getElementById('g_speed');
const v_field=document.getElementById('v_field'), g_field=document.getElementById('g_field');
const v_fshield=document.getElementById('v_fshield'), g_fshield=document.getElementById('g_fshield');
const v_fstretch=document.getElementById('v_fstretch'), g_fstretch=document.getElementById('g_fstretch');
const v_clock=document.getElementById('v_clock'), g_clock=document.getElementById('g_clock');
const v_phot=document.getElementById('v_phot'), g_phot=document.getElementById('g_phot');
const v_mag=document.getElementById('v_mag'), g_mag=document.getElementById('g_mag');
const v_tcore=document.getElementById('v_tcore'), g_tcore=document.getElementById('g_tcore');
const v_tcool=document.getElementById('v_tcool'), g_tcool=document.getElementById('g_tcool');
const v_ent=document.getElementById('v_ent'), g_ent=document.getElementById('g_ent');
const v_plen=document.getElementById('v_plen'), g_plen=document.getElementById('g_plen');
const v_prad=document.getElementById('v_prad'), g_prad=document.getElementById('g_prad');
const v_pwave=document.getElementById('v_pwave'), g_pwave=document.getElementById('g_pwave');
const clkUTC=document.getElementById('clk_utc');
const clkCST=document.getElementById('clk_cst');
const clkWarp=document.getElementById('clk_warp');

// Jump planner DOM
const inpDist=document.getElementById('inp_dist');
const inpRA=document.getElementById('inp_ra');
const inpDec=document.getElementById('inp_dec');
const inpGrav=document.getElementById('inp_grav');
const inpDays=document.getElementById('inp_days');
const btnJump=document.getElementById('btn_jump');
const jumpStatus=document.getElementById('jumpStatus');
const jumpRating=document.getElementById('jumpRating');
const jp_dep=document.getElementById('jp_dep');
const jp_arr=document.getElementById('jp_arr');
const jp_tau=document.getElementById('jp_tau');
const jp_dist=document.getElementById('jp_dist');
const jp_vapp=document.getElementById('jp_vapp');
const jp_dil=document.getElementById('jp_dil');
const jp_err=document.getElementById('jp_err');
const jp_vec=document.getElementById('jp_vec');
const jp_meter=document.getElementById('jp_meter');
const jp_comment=document.getElementById('jp_comment');

// Init HUD
function warpFactor(){ return parseInt(warpEl.value,10); }
function updateHUD(){
  const w = warpFactor();
  speedEl.textContent = 'x'+computeSpeedMult(w).toFixed(1);
  fieldEl.textContent = computeFieldRadius(w).toFixed(1)+' x D';
  tempEl.textContent = computeHeatLevel(w)>0.7? 'Hot' : (computeHeatLevel(w)>0.5? 'Warm' : 'Cool');
}
updateHUD();
warpEl.addEventListener('input', updateHUD);

document.getElementById('pause').onclick=function(){running=false;};
document.getElementById('play').onclick=function(){
  if(!running){ running=true; t0=performance.now(); loop(); }
};
document.getElementById('reset').onclick=function(){
  particles.length=0; heat.length=0; cool.length=0; entangle.length=0; pipes.length=0;
  fanAngle=0;
};

function initPipes(){
  pipes=[];
  for(var i=0;i<layout.stages.length-1;i++){
    var s = layout.stages[i];
    var nx = s.x1;
    pipes.push({x0:nx-6,y0:layout.centerY+28,x1:nx+6,y1:layout.centerY+28,phase:Math.random()*TAU});
  }
}
initPipes();
// ===== Draw helpers =====
function drawCylinder(x0,x1,rTop,rBot){
  var grd = ctx.createLinearGradient(0, layout.centerY-rTop, 0, layout.centerY+rBot);
  grd.addColorStop(0, '#2a334d');
  grd.addColorStop(0.5,'#9fb1ff22');
  grd.addColorStop(1, '#0e132b');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY + rBot);
  ctx.lineTo(x0, layout.centerY + rBot);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.strokeStyle = '#cfe2ff33';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x1, layout.centerY-rTop);
  ctx.lineTo(x1, layout.centerY+rBot);
  ctx.stroke();
}
function drawNozzle(nz){
  var x0=nz.x0,x1=nz.x1,r0=nz.r0,r1=nz.r1;
  var grd = ctx.createLinearGradient(x0,layout.centerY,x1,layout.centerY);
  grd.addColorStop(0,'#2a334d');
  grd.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - r0);
  ctx.lineTo(x1, layout.centerY - r1);
  ctx.lineTo(x1, layout.centerY + r1);
  ctx.lineTo(x0, layout.centerY + r0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
}
function drawCoil(xOff){
  var x = layout.startX + xOff;
  ctx.strokeStyle='#a6b8ffaa';
  ctx.lineWidth=8;
  ctx.beginPath();
  ctx.moveTo(x, layout.centerY-48);
  ctx.lineTo(x, layout.centerY+48);
  ctx.stroke();
  ctx.lineWidth=3;
  ctx.strokeStyle='#5ea8ffaa';
  for(var i=-3;i<=3;i++){
    ctx.beginPath();
    ctx.arc(x, layout.centerY + i*12, 22+Math.abs(i)*2, 0, TAU);
    ctx.stroke();
  }
}
function drawFan(angle){
  var cx = layout.fanX, cy = layout.centerY;
  ctx.fillStyle='#a4b2d8';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, TAU);
  ctx.fill();
  for(var i=0;i<6;i++){
    var a = angle + i*TAU/6;
    var r1=14, r2=52;
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath();
    ctx.fill();
  }
}
function drawField(){
  var D = layout.bodyR*2;
  var base = computeFieldRadius(warpFactor())*D*0.35;
  var ax = computeFieldAspectX(warpFactor());
  var ay = computeFieldAspectY(warpFactor());
  ctx.strokeStyle='#33e1b588';
  ctx.lineWidth=2;
  var cx = layout.startX+layout.length*0.65;
  for(var i=0;i<6;i++){
    var rx = base*ax + i*22;
    var ry = base*ay + i*10;
    ctx.beginPath();
    ctx.ellipse(cx, layout.centerY, rx, ry, 0, 0, TAU);
    ctx.stroke();
  }
}
function drawTimeLegendLeft(){
  var x=40, y=120;
  var lines=['UTC','CST (engine sync)','Warp SR×GR time','Interstellar lane','CST warp corridor'];
  for(var i=0;i<lines.length;i++){ drawText(ctx, lines[i], x, y+i*20, 'left'); }
}
function drawCSTClock(){
  var x = layout.stages[3].x0+12;
  var y = layout.centerY-22;
  ctx.fillStyle='#0e1536';
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.fillRect(x,y,170,32);
  ctx.strokeRect(x,y,170,32);
  drawText(ctx,'Atomic Clock (CST anchor)', x+6, y+16, 'left');
}
function drawStatusLabel(){
  var x = layout.nozzle.x0-40;
  var y = layout.centerY- layout.bodyR - 58;
  var w = warpFactor();
  var stab = computeStability(w);
  var s = 'Warp '+w+' | Stability '+stab.toFixed(2);
  drawText(ctx, s, x, y, 'left');
}
function labelFromTo(text, ax, ay, tx, ty){
  ctx.strokeStyle='#9bb4ff66';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(ax,ay);
  ctx.lineTo(tx,ty);
  ctx.stroke();
  drawText(ctx, text, tx+4, ty, 'left');
}
function drawLabels(){
  const topY = layout.centerY - layout.bodyR - 42;
  const botY = layout.centerY + layout.bodyR + 44;
  const s0=layout.stages[0], s1=layout.stages[1], s2=layout.stages[2],
        s3=layout.stages[3], s4=layout.stages[4], s5=layout.stages[5],
        s6=layout.stages[6];

  labelFromTo('Vacuum Intake', s0.x0+12, layout.centerY- s0.r, s0.x0-120, topY-6);
  labelFromTo('Magnetic Fan (neg-energy mod.)', layout.fanX, layout.centerY-34, s0.x0-120, topY+12);
  labelFromTo('Modulates Vacuum Fluctuation', s4.x0+6, layout.centerY- s4.r, s4.x0-18, topY+34);
  labelFromTo('Compression A/B/C', s2.x1-10, layout.centerY- s2.r, s2.x0-30, topY+54);
  labelFromTo('Reactors (Electro-plasma)', s5.x0+10, layout.centerY- s5.r, s5.x0+80, topY+74);
  labelFromTo('Photon/Plasma Mixer', s6.x0+10, layout.centerY- s6.r, s6.x0+140, topY+94);

  labelFromTo('Entanglement Feedback Loop', s5.x0+24, layout.centerY+16, s5.x0-40, botY);
  labelFromTo('Atomic Clocks (CST) + Feedback', s3.x0+20, layout.centerY, s3.x0-80, botY+24);
  labelFromTo('Pulse Control', s4.x1-8, layout.centerY+8, s4.x1+30, botY+48);
  labelFromTo('AFT Power Ramp', layout.nozzle.x0-10, layout.centerY+6, layout.nozzle.x0+40, botY+72);
  labelFromTo('Gravitational Stabilization Panel', s2.x0+20, layout.centerY+ s2.r, s2.x0-40, botY+96);
  labelFromTo('Quantum Vertex Dampers', s4.x0+20, layout.centerY+ s4.r, s4.x0+140, botY+120);
  labelFromTo('Detection Lasers (particles)', s1.x1-10, layout.centerY+ s1.r, s1.x1+110, botY+144);
  labelFromTo('Thermal Management (Water Cooling)', s5.x1-8, layout.centerY+ s5.r, s5.x1+160, botY+168);

  labelFromTo('ZPF Oscillator Rings (ZPO)', s4.x0+12, layout.centerY- s4.r+10, s4.x0-130, topY+116);
  labelFromTo('Casimir Microarrays', s3.x1-6, layout.centerY- s3.r+6, s3.x1+28, topY+136);
  labelFromTo('Tachyon Feedback Node', s5.x0+6, layout.centerY+12, s5.x0-140, botY+192);
  labelFromTo('CTC Guard (CST Damping)', s3.x0+8, layout.centerY+8, s3.x0-160, botY+216);
  labelFromTo('Positron Diagnostic Port', s6.x1-6, layout.centerY- s6.r+6, s6.x1+70, topY+156);
  labelFromTo('Limestone–Granite Resonator', s0.x0+20, layout.centerY+ s0.r-8, s0.x0-170, botY+176);

  const cx = layout.startX+layout.length*0.65;
  labelFromTo('Temporal vs Spatial Warp (rx/ry vs clock)', cx, layout.centerY - computeFieldRadius(warpFactor())*layout.bodyR*0.35 - 22, cx-180, topY-20);
  labelFromTo('Exotic-Matter Bypass (EM stress / Casimir)', s4.x1-6, layout.centerY+ s4.r-10, s4.x1+60, botY+168);
}
function drawCoreGlow(){
  var g = ctx.createLinearGradient(layout.startX, layout.centerY, layout.nozzle.x1, layout.centerY);
  g.addColorStop(0,'#a9bbff00');
  g.addColorStop(0.4,'#9bb4ff22');
  g.addColorStop(0.8,'#eaf0ff44');
  ctx.fillStyle=g;
  ctx.fillRect(layout.startX, layout.centerY-12, layout.nozzle.x1-layout.startX, 24);
}
function drawPlasmaCone(){
  var len = computePlasmaLength(warpFactor());
  var baseR = computePlasmaRadius(warpFactor());
  var x0 = layout.nozzle.x1;
  var x1 = x0 + len;
  var grad = ctx.createLinearGradient(x0, layout.centerY, x1, layout.centerY);
  grad.addColorStop(0, 'rgba(255,220,168,0.65)');
  grad.addColorStop(0.3, 'rgba(255,220,168,0.35)');
  grad.addColorStop(1, 'rgba(255,220,168,0.02)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - baseR);
  ctx.lineTo(x1, layout.centerY - baseR*0.35);
  ctx.lineTo(x1, layout.centerY + baseR*0.35);
  ctx.lineTo(x0, layout.centerY + baseR);
  ctx.closePath();
  ctx.fill();
}
function drawPipes(){
  for(var i=0;i<pipes.length;i++){
    var p = pipes[i];
    ctx.strokeStyle='#6bd1ff';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x0, p.y0);
    ctx.lineTo(p.x1, p.y1);
    ctx.stroke();
    var n=4;
    for(var k=0;k<n;k++){
      var t = ((k/n) + (performance.now()*0.0005) ) % 1;
      var xx = p.x0 + (p.x1-p.x0)*t;
      var yy = p.y0 + (p.y1-p.y0)*t;
      ctx.fillStyle='#9bb4ff';
      ctx.beginPath();
      ctx.arc(xx, yy, 2, 0, TAU);
      ctx.fill();
    }
  }
}
function drawCoolingLoops(){
  var y = layout.centerY + layout.bodyR - 16;
  ctx.strokeStyle='#6bd1ff';
  ctx.lineWidth=2;
  ctx.beginPath();
  var x0 = layout.startX+10;
  ctx.moveTo(x0,y);
  for(var x1 = x0; x1 < layout.nozzle.x0-10; x1 += 32){
    ctx.lineTo(x1+16, y+6);
    ctx.lineTo(x1+32, y);
  }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=1;
  var cxF = layout.startX - 20;
  var cxR = layout.nozzle.x1 + 20;
  var cy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(cxF, cy-44); ctx.lineTo(cxF-34, cy-44);
  ctx.moveTo(cxF, cy+44); ctx.lineTo(cxF-34, cy+44);
  ctx.moveTo(cxR, cy-34); ctx.lineTo(cxR+34, cy-34);
  ctx.moveTo(cxR, cy+34); ctx.lineTo(cxR+34, cy+34);
  ctx.stroke();
  var ccx = layout.startX+layout.length*0.65;
  var ccy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(ccx-16, ccy); ctx.lineTo(ccx+16, ccy);
  ctx.moveTo(ccx, ccy-16); ctx.lineTo(ccx, ccy+16);
  ctx.stroke();
}

// ===== Telemetry (SR/GR/CST) =====
function setGauge(span, frac){ span.style.width = (clamp(frac,0,1)*100).toFixed(0)+'%'; }

function updateTelemetry(dt){
  var w = warpFactor();
  var sm = computeSpeedMult(w);
  var fr = computeFieldRadius(w);

  var vLocal = computeLocalSpeed(w);
  var gSR = gammaSR(vLocal);
  var gGR = gravFactor(inpGrav.value || 'deep');
  var netDil = 1/(gSR*gGR); // proper/CST

  var instFps = (dt>0)? 1000/dt : 60;
  fps = fps*0.9 + instFps*0.1;

  var shieldFrac = (fr-1.2)/(2.6-1.2);
  var curvatureBoost = clamp((gSR*gGR-1)/0.3, 0, 1);
  var effectiveShield = clamp(shieldFrac*0.7 + curvatureBoost*0.3, 0, 1);

  var D = layout.bodyR*2;
  var base = fr*D*0.35;
  var ax = computeFieldAspectX(w);
  var ay = computeFieldAspectY(w);
  var rx = base*ax + 2*22;
  var ry = base*ay + 2*10;

  var p_phot = 0.7*sm;
  var p_ent = 0.25*computeEntangleRate(w);
  var mag = fr*sm;
  var pWave = (0.2*sm);

  var coreC = computeCoreTempC(w);
  var coolC = computeCoolantTempC(w);

  v_speed.textContent = 'x'+sm.toFixed(1); setGauge(g_speed, (sm-1)/(6-1));
  v_field.textContent = fr.toFixed(2); setGauge(g_field, shieldFrac);
  v_fshield.textContent = Math.round(effectiveShield*100)+'%'; setGauge(g_fshield, effectiveShield);
  v_fstretch.textContent = fmt(rx,0)+' / '+fmt(ry,0); setGauge(g_fstretch, clamp(rx/(base*1.9+2*22),0,1));

  v_clock.textContent = netDil.toFixed(3)+'×'; setGauge(g_clock, 1-clamp(netDil,0,1));
  timeEl.textContent = netDil.toFixed(2)+' x';

  var perSec = function(p){ return p * fps; };
  v_phot.textContent = fmtLarge(perSec(p_phot))+' /s'; setGauge(g_phot, Math.min(perSec(p_phot)/3000,1));
  v_mag.textContent = mag.toFixed(2); setGauge(g_mag, Math.min(mag/6.0,1));

  v_tcore.textContent = coreC+' °C'; setGauge(g_tcore, Math.min(coreC/1500,1));
  v_tcool.textContent = coolC+' °C'; setGauge(g_tcool, Math.min(coolC/400,1));

  var entPerSec = perSec(p_ent);
  var entScaled = entPerSec>=1e9? (entPerSec/1e9).toFixed(2)+' G/s' : entPerSec>=1e6? (entPerSec/1e6).toFixed(2)+' M/s' : Math.round(entPerSec)+' /s';
  v_ent.textContent = entScaled; setGauge(g_ent, Math.min(entPerSec/3.2e6,1));

  var plen = computePlasmaLength(w); v_plen.textContent = plen+' u'; setGauge(g_plen, (plen-90)/(260-90));
  var prad = computePlasmaRadius(w); v_prad.textContent = prad+' u'; setGauge(g_prad, (prad-10)/(36-10));
  v_pwave.textContent = pWave.toFixed(2); setGauge(g_pwave, Math.min(pWave/1.2,1));

  var now = Date.now();
  clkUTC.textContent = new Date(now).toLocaleTimeString('en-US', {hour12:false,timeZone:'UTC'});
  clkCST.textContent = new Date(now).toLocaleTimeString('en-US', {hour12:false,timeZone:'America/Chicago'});

  warpClock += (dt * netDil);
  clkWarp.textContent = new Date(warpClock).toLocaleTimeString('en-US', {hour12:false});
}

// ===== Streams & Particles =====
function spawnParticle(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.6;
  var x0 = layout.startX+10;
  var v = 0.6 + Math.random()*0.7;
  particles.push({x:x0,y:y,v:v,life:0});
}
function spawnHeat(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.4;
  var xh = layout.stages[4].x0 + Math.random()*(layout.nozzle.x1 - layout.stages[4].x0);
  heat.push({x:xh,y:y,life:0});
}
function spawnCool(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.7;
  var xc = layout.stages[0].x0 + Math.random()*(layout.stages[2].x1-layout.stages[0].x0);
  cool.push({x:xc,y:y,life:0});
}
function spawnEntangle(){
  var baseX = layout.stages[5].x0 + Math.random()*40;
  var phase = Math.random()*TAU;
  entangle.push({x:baseX, y:layout.centerY, phase:phase, life:0});
}

// ===== Render Loop =====
function render(dt){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawField();
  for(var i=0;i<layout.stages.length;i++){
    var s = layout.stages[i];
    drawCylinder(s.x0, s.x1, s.r, s.r);
  }
  drawNozzle(layout.nozzle);
  drawCoreGlow();
  for(var j=0;j<layout.coils.length;j++){ drawCoil(layout.coils[j].xOff); }
  drawFan(fanAngle);

  var pmult = computeSpeedMult(warpFactor());
  if(Math.random()<0.7*pmult) spawnParticle();
  for(var p=0;p<particles.length;p++){
    var pt = particles[p];
    pt.x += (1.9*pmult + pt.v)*1.2;
    pt.y += Math.sin((pt.x+pt.y)*0.01)*0.22*pmult;
    pt.life += dt;
  }
  particles = particles.filter(function(pt){ return pt.x < layout.nozzle.x1+560; });
  ctx.fillStyle='#9bb4ff';
  for(var q=0;q<particles.length;q++){
    ctx.globalAlpha=0.7;
    ctx.fillRect(particles[q].x, particles[q].y, 3, 2);
    ctx.globalAlpha=1;
  }

  if(Math.random()<0.25*pmult*computeHeatLevel(warpFactor())) spawnHeat();
  if(Math.random()<0.25*pmult*computeCoolLevel(warpFactor())) spawnCool();
  for(var h=0;h<heat.length;h++){ heat[h].life+=dt; heat[h].x+= 1.0*pmult; }
  for(var c0=0;c0<cool.length;c0++){ cool[c0].life+=dt; cool[c0].x+= 0.7*pmult; }
  heat = heat.filter(function(it){ return it.x<layout.nozzle.x1; });
  cool = cool.filter(function(it){ return it.x<layout.stages[3].x1; });
  for(var h2=0;h2<heat.length;h2++){
    ctx.fillStyle='#ffcc66';
    ctx.beginPath();
    ctx.arc(heat[h2].x,heat[h2].y,2+Math.sin(heat[h2].life*0.02)*1.5,0,TAU);
    ctx.fill();
  }
  for(var c2=0;c2<cool.length;c2++){
    ctx.fillStyle='#6bd1ff';
    ctx.beginPath();
    ctx.arc(cool[c2].x,cool[c2].y,2+Math.cos(cool[c2].life*0.02)*1.2,0,TAU);
    ctx.fill();
  }

  if(Math.random()<computeEntangleRate(warpFactor())*0.25) spawnEntangle();
  for(var e=0;e<entangle.length;e++){
    var en = entangle[e];
    en.life+=dt;
    en.x += 1.2*pmult;
    var amp = 26 + 8*Math.sin(en.life*0.01);
    var wv = 0.026*pmult;
    var yy = layout.centerY + Math.sin(en.phase + en.x*wv)*amp;
    ctx.fillStyle='#b26bff';
    ctx.beginPath();
    ctx.arc(en.x, yy, 2.2, 0, TAU);
    ctx.fill();
  }
  entangle = entangle.filter(function(en){ return en.x < layout.nozzle.x1 + 300; });

  drawPlasmaCone();
  drawPipes();
  drawCoolingLoops();
  drawLasers();

  drawTimeLegendLeft();
  drawCSTClock();
  drawStatusLabel();
  if(labelsEl.checked) drawLabels();
}

function loop(){
  if(!running) return;
  var now = performance.now();
  var dt = now - t0;
  t0 = now;
  fanAngle += 0.005 * dt * computeSpeedMult(warpFactor());
  render(dt);
  updateTelemetry(dt);
  requestAnimationFrame(loop);
}
loop();

// ===== Jump computation =====
btnJump.addEventListener('click', function(){
  const w = warpFactor();
  const distLy = Math.max(0.0001, parseFloat(inpDist.value)||0.0001);
  const ra = parseFloat(inpRA.value)||0;
  const dec = parseFloat(inpDec.value)||0;
  const regime = inpGrav.value||'deep';
  const days = parseFloat(inpDays.value)||0;

  const vLocal = computeLocalSpeed(w);
  const vApp   = computeApparentSpeed(w);
  const gSR    = gammaSR(vLocal);
  const gGR    = gravFactor(regime);
  const netDil = 1/(gSR*gGR);

  const tCoord_s = (distLy*LY_KM) / vApp;
  const tShip_s  = tCoord_s * netDil;

  const nowCST   = new Date(Date.now());
  const depStr   = nowCST.toLocaleString('en-US',{hour12:false,timeZone:'America/Chicago'});
  const arrDate  = new Date(nowCST.getTime() + tCoord_s*1000);
  const arrStr   = arrDate.toLocaleString('en-US',{hour12:false,timeZone:'America/Chicago'});

  jp_dep.textContent  = depStr;
  jp_arr.textContent  = arrStr;
  jp_tau.textContent  = (tShip_s/SECONDS_PER_DAY).toFixed(3)+' days (ship frame)';
  jp_dist.textContent = distLy.toFixed(3)+' ly';
  jp_vapp.textContent = (vApp/C).toFixed(2)+' c (apparent)';
  jp_dil.textContent  = 'local γ_SR='+gSR.toFixed(3)+', γ_GR='+(1/gGR).toFixed(3)+', net='+netDil.toFixed(3);

  const vec = raDecToVec(ra, dec);
  const driftSec = siderealDrift(days);
  const driftFrac = (driftSec % (24*3600))/(24*3600);
  const angleErr = 2*Math.PI*driftFrac;
  const vecErr = Math.abs(angleErr)*180/Math.PI;

  const stab = computeStability(w);
  const entRate = computeEntangleRate(w);
  const stabilityBoost = clamp((stab-0.55)/0.4,0,1);
  const entBoost = clamp((entRate-0.6)/(3.2-0.6),0,1);

  const baseErrAU = 0.5 + 2.0*Math.abs(angleErr);
  const improvedErrAU = baseErrAU*(1-0.6*stabilityBoost*entBoost);
  jp_err.textContent = improvedErrAU.toFixed(3)+' AU (est.)';

  const alignScore = clamp(1 - (vecErr/15)*(1-stabilityBoost*0.5),0,1);
  jp_vec.textContent = (alignScore*100).toFixed(1)+' %';
  jp_meter.style.width = (alignScore*100).toFixed(0)+'%';

  const rating = Math.round(60 + 40*alignScore*netDil);
  jumpRating.textContent = 'CST alignment: '+rating+'/100';
  jumpRating.className = 'badge ' + (rating>85?'badge-ok':(rating>60?'badge-warn':'badge-bad'));

  jumpStatus.textContent = 'Jump computed — SR/GR + CST + RA/Dec applied';
  jumpStatus.className = 'badge badge-ok';

  jp_comment.textContent =
    'Higher warp, good stability and strong entanglement reduce re-entry error and keep the ship close to the CST target dome.';
});

// ===== Self-tests =====
(function runTests(){
  var results = [];
  function ok(name,cond){ results.push((cond?'PASS ':'FAIL ')+name); }
  ok('speed increases', computeSpeedMult(10) > computeSpeedMult(1));
  ok('field grows', computeFieldRadius(10) > computeFieldRadius(1));
  ok('plasma length grows', computePlasmaLength(10) > computePlasmaLength(1));
  ok('plasma radius grows', computePlasmaRadius(10) > computePlasmaRadius(1));
  ok('entangle rate grows', computeEntangleRate(10) > computeEntangleRate(1));
  ok('field stretches wider', computeFieldAspectX(10) > computeFieldAspectX(1));
  var el = document.getElementById('tests');
  if(el){ el.textContent = 'Self-tests: ' + results.join(' | '); }
})();
</script>
</body>
</html>
