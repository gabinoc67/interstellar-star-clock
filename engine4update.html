<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interstellar Star Clock — Warp Engine (Energy ↔ Mass Core)</title>
<style>
  :root{
    --bg:#050815;
    --panel:#111735;
    --ink:#eaf0ff;
    --muted:#9fa8d6;
    --accent:#8fb4ff;
    --grid:#1d264e;
    --border:#1c2750;
    --ok:#35e6a2;
    --warn:#ffd15a;
    --bad:#ff6b8b;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:1800px;
    margin:0 auto;
    padding:16px;
  }
  header{
    padding:12px 16px 18px;
    border-radius:16px;
    background:radial-gradient(circle at top left,#3b82f6 0,#020617 40%,#000 100%);
    border:1px solid rgba(148,163,184,0.4);
    margin-bottom:14px;
  }
  header h1{
    margin:0 0 4px;
    font-size:22px;
    letter-spacing:0.04em;
    text-transform:uppercase;
  }
  header p{
    margin:2px 0;
    font-size:13px;
    color:var(--muted);
  }
  .tagline{
    font-size:12px;
    color:#a5b4fc;
  }

  .grid-main{
    display:grid;
    grid-template-columns:340px minmax(0,1fr);
    gap:14px;
    align-items:flex-start;
    margin-bottom:14px;
  }
  .left-col{
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  .panel{
    background:var(--panel);
    border-radius:16px;
    border:1px solid var(--border);
    padding:12px 14px 14px;
    box-shadow:0 18px 40px rgba(15,23,42,0.75);
  }
  .panel h2{
    margin:0 0 8px;
    font-size:16px;
  }
  .panel h3{
    margin:12px 0 4px;
    font-size:14px;
  }
  .panel p{
    font-size:13px;
    color:var(--muted);
    margin:3px 0 6px;
  }
  .inline-label{
    font-size:12px;
    color:var(--muted);
    margin-right:6px;
  }
  .controls-group{
    margin-bottom:10px;
    padding:8px 10px;
    border-radius:10px;
    border:1px dashed rgba(148,163,184,0.4);
  }
  .controls-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    margin-bottom:6px;
  }
  .controls-row:last-child{margin-bottom:0;}
  .controls-row label{
    font-size:12px;
    color:var(--muted);
  }
  input[type="range"]{
    width:100%;
  }
  .badge{
    padding:2px 6px;
    border-radius:999px;
    font-size:11px;
    border:1px solid rgba(148,163,184,0.6);
    color:#e5e7eb;
    white-space:nowrap;
  }
  .badge.ok{border-color:var(--ok);color:var(--ok);}
  .badge.warn{border-color:var(--warn);color:var(--warn);}
  .badge.bad{border-color:var(--bad);color:var(--bad);}

  .btn-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:8px;
  }
  button{
    font-size:12px;
    border-radius:999px;
    padding:4px 10px;
    border:1px solid rgba(148,163,184,0.5);
    background:#020617;
    color:#e5e7eb;
    cursor:pointer;
  }
  button:hover{background:#02081f;}
  button.primary{
    border-color:#4ade80;
    color:#bbf7d0;
  }

  .time-box{
    margin-top:8px;
    padding:8px 10px;
    border-radius:10px;
    background:rgba(15,23,42,0.9);
    border:1px solid rgba(148,163,184,0.45);
    font-size:12px;
  }
  .time-row{
    display:flex;
    justify-content:space-between;
    gap:8px;
    margin-bottom:4px;
  }
  .time-row:last-child{margin-bottom:0;}
  .time-label{color:var(--muted);}
  .time-value{font-family:monospace;font-size:12px;}

  .grad-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }
  .grad-toggle{
    display:flex;
    align-items:center;
    gap:4px;
    font-size:11px;
    color:#e5e7eb;
  }
  .grad-sliders{
    opacity:1;
    transition:opacity .2s ease;
  }
  .grad-sliders.ghosted{
    opacity:0.35;
  }

  .labels-toggle{
    margin-top:8px;
    font-size:12px;
    display:flex;
    align-items:center;
    gap:6px;
    color:var(--muted);
  }

  canvas{
    display:block;
    width:100%;
    max-width:100%;
    border-radius:12px;
    background:#020617;
    border:1px solid var(--grid);
  }
  .tests{
    font-size:11px;
    color:var(--muted);
    margin-top:6px;
    word-break:break-word;
  }

  /* Telemetry gauges */
  .telemetry-grid{
    display:grid;
    grid-template-columns:repeat(4,minmax(0,1fr));
    gap:10px;
    margin-top:4px;
  }
  .telemetry-card{
    padding:6px 8px;
    border-radius:10px;
    border:1px solid rgba(148,163,184,0.45);
    background:#020617;
    font-size:11px;
  }
  .telemetry-title{
    font-size:11px;
    margin-bottom:2px;
    color:#e5e7eb;
  }
  .telemetry-value{
    font-family:monospace;
    font-size:11px;
    margin-bottom:2px;
  }
  .gauge{
    position:relative;
    width:100%;
    height:5px;
    border-radius:999px;
    background:#020617;
    overflow:hidden;
  }
  .gauge-fill{
    position:absolute;
    left:0;top:0;bottom:0;
    width:0%;
    border-radius:inherit;
    background:linear-gradient(90deg,#22c55e,#eab308,#ef4444);
    transition:width .12s linear;
  }

  .note{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }
  .eq{
    font-family:"SF Mono",ui-monospace,Menlo,Consolas,monospace;
    font-size:13px;
    margin:3px 0 5px;
    color:#e5e7eb;
  }
  .list{
    margin:4px 0 8px 18px;
    padding:0;
    font-size:12px;
    color:var(--muted);
  }
  .list li{margin-bottom:2px;}

  /* === CST Sync & Inertial Safety Panel === */
  .safety-grid{
    display:grid;
    grid-template-columns:repeat(3,minmax(0,1fr));
    gap:8px;
    margin-top:6px;
  }
  .safety-item{
    text-align:center;
    font-size:11px;
    color:var(--muted);
  }
  .safety-circle{
    width:18px;
    height:18px;
    border-radius:50%;
    margin:0 auto 3px;
    border:2px solid #4b5563;
    background:#020617;
    box-shadow:0 0 0 1px #020617;
  }
  .safe-green{
    border-color:#22c55e;
    background:#16a34a;
    box-shadow:0 0 8px rgba(34,197,94,0.9);
  }
  .safe-amber{
    border-color:#eab308;
    background:#facc15;
    box-shadow:0 0 6px rgba(234,179,8,0.8);
  }
  .safe-red{
    border-color:#ef4444;
    background:#b91c1c;
    box-shadow:0 0 6px rgba(239,68,68,0.9);
  }
  .safety-status{
    font-size:12px;
    margin-top:6px;
    color:var(--muted);
  }
  .jump-summary-row{
    display:flex;
    justify-content:space-between;
    font-size:11px;
    margin-bottom:2px;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Interstellar Star Clock — Warp Engine Field Simulator</h1>
    <p>Engine core, CST clock, and 4D navigation all on one canvas. This version shows where <strong>E ⇌ m</strong> happens inside the ship.</p>
    <p class="tagline">Mass–Energy core, hull conversion shell, toroidal field trim, all driven by CST timing.</p>
  </header>

  <div class="grid-main">
    <!-- ===== LEFT COLUMN: CONTROLS + CST SAFETY ===== -->
    <div class="left-col">
      <!-- Warp Engine Controls & CST Time -->
      <div class="panel">
        <h2>Warp Engine Controls & CST Time</h2>

        <div class="controls-group">
          <div class="controls-row">
            <label>Warp Factor</label>
            <span class="badge ok" id="speed">x1.0</span>
          </div>
          <div class="controls-row">
            <input type="range" id="warp" min="1" max="10" step="1" value="4" />
          </div>
          <div class="controls-row">
            <span class="inline-label">Field Radius</span>
            <span class="badge" id="field">1.2 x D</span>
          </div>
          <div class="controls-row">
            <span class="inline-label">Core Status</span>
            <span class="badge warn" id="temp">Warm</span>
          </div>
          <div class="controls-row">
            <span class="inline-label">Ship Clock vs CST</span>
            <span class="badge" id="time">1.00 x</span>
          </div>
        </div>

        <div class="controls-group">
          <div class="grad-header">
            <span>Warp Gradient Trim</span>
            <label class="grad-toggle">
              <input type="checkbox" id="gradMode" />
              <span id="gradModeLabel">Manual Trim</span>
            </label>
          </div>
          <div id="grad_sliders" class="grad-sliders">
            <div class="controls-row">
              <label>Front ↔ Rear Focus</label>
            </div>
            <div class="controls-row">
              <input id="grad_frontRear" type="range" min="0.7" max="1.3" step="0.01" value="1.00">
            </div>
            <div class="controls-row">
              <label>Left ↔ Right Bias</label>
            </div>
            <div class="controls-row">
              <input id="grad_leftRight" type="range" min="-0.3" max="0.3" step="0.01" value="0">
            </div>
            <div class="controls-row">
              <label>Warp vs Shield Emphasis</label>
            </div>
            <div class="controls-row">
              <input id="grad_warpShield" type="range" min="0" max="1" step="0.01" value="0.5">
            </div>
          </div>
        </div>

        <div class="time-box">
          <div class="time-row">
            <span class="time-label">UTC Atomic</span>
            <span class="time-value" id="clk_utc">--:--:--</span>
          </div>
          <div class="time-row">
            <span class="time-label">CST (Engine Sync)</span>
            <span class="time-value" id="clk_cst">--:--:--</span>
          </div>
          <div class="time-row">
            <span class="time-label">Warp-Frame Clock</span>
            <span class="time-value" id="clk_warp">--:--:--</span>
          </div>
        </div>

        <!-- Mirror of safety state under CST panel -->
        <div class="safety-status" id="mirrorSafetyText">
          CST Sync: UNLOCKED · Cabin Inertia: RED · Warp Clearance: NO-GO
        </div>
      </div>

      <!-- CST Sync & Inertial Safety — Planet Warp Jump -->
      <div class="panel">
        <h2>CST Sync & Inertial Safety — Planet Warp Jump</h2>
        <p class="note">
          All three indicators must be <strong>green</strong> before a warp jump can engage. Inside the bubble:
          dτ<sub>ship</sub> / dT<sub>CST</sub> ≈ 1 and a<sub>inside</sub> ≈ 0 (Zero-G Cabin Condition). Earth is static.
        </p>

        <div class="controls-group">
          <div class="controls-row">
            <label>Target Planet (Earth is static)</label>
            <select id="targetPlanet" style="flex:1;font-size:12px;padding:3px 6px;border-radius:6px;border:1px solid rgba(148,163,184,0.6);background:#020617;color:#e5e7eb;">
              <option value="mercury">Mercury</option>
              <option value="venus">Venus</option>
              <option value="earth">Earth</option>
              <option value="mars" selected>Mars</option>
              <option value="jupiter">Jupiter</option>
              <option value="saturn">Saturn</option>
              <option value="uranus">Uranus</option>
              <option value="neptune">Neptune</option>
              <option value="pluto">Pluto</option>
            </select>
          </div>
          <div class="controls-row">
            <span class="inline-label">Distance (AU)</span>
            <span class="badge" id="distAU">—</span>
          </div>
          <div class="controls-row">
            <span class="inline-label">Recommended Warp</span>
            <span class="badge" id="recWarp">—</span>
          </div>

          <div class="btn-row">
            <button id="btnLockTarget">1. Lock Planet</button>
            <button id="btnCalcSafety" class="primary">2. Calculate Safety</button>
          </div>
          <div class="btn-row">
            <button id="btnEngageJump">3. Engage Jump</button>
            <button id="btnResetJump">4. Reset Jump</button>
          </div>
        </div>

        <div class="safety-grid">
          <div class="safety-item">
            <div id="circ_cst" class="safety-circle safe-red"></div>
            <div id="label_cst">CST Sync: UNLOCKED</div>
          </div>
          <div class="safety-item">
            <div id="circ_inertia" class="safety-circle safe-red"></div>
            <div id="label_inertia">Cabin Inertia: RED</div>
          </div>
          <div class="safety-item">
            <div id="circ_clear" class="safety-circle safe-red"></div>
            <div id="label_clear">Warp Clearance: NO-GO</div>
          </div>
        </div>

        <div class="time-box" id="jumpSummaryBox">
          <div class="jump-summary-row">
            <span>Trip Progress</span>
            <span id="jump_progress">0%</span>
          </div>
          <div class="jump-summary-row">
            <span>CST Coord Time (hours)</span>
            <span id="jump_time">—</span>
          </div>
          <div class="jump-summary-row">
            <span>E ⇌ m Budget</span>
            <span id="jump_energy">—</span>
          </div>
          <div class="jump-summary-row">
            <span>Calc</span>
            <span id="jump_calc">—</span>
          </div>
          <div class="jump-summary-row">
            <span>Status</span>
            <span id="jump_status">Idle — lock planet, then calculate safety.</span>
          </div>
        </div>
      </div>
    </div>

    <!-- ===== RIGHT PANEL: ENGINE CANVAS ===== -->
    <div class="panel">
      <h2>Engine View — Mass–Energy Core & Toroidal Shell</h2>
      <canvas id="view" width="1500" height="900"></canvas>
      <label class="labels-toggle">
        <input type="checkbox" id="labels" checked>
        Show detailed labels and CST research zones
      </label>
      <div id="tests" class="tests">Self-tests: pending…</div>
    </div>
  </div>

  <!-- ===== TELEMETRY PANEL ===== -->
  <div class="panel">
    <h2>Warp Telemetry — Streams, Temperatures, Field Shape</h2>
    <div class="telemetry-grid">
      <div class="telemetry-card">
        <div class="telemetry-title">Plasma Speed Multiplier</div>
        <div class="telemetry-value" id="v_speed">x1.0</div>
        <div class="gauge"><div class="gauge-fill" id="g_speed"></div></div>
        <div class="telemetry-title" style="margin-top:4px;">Field Radius (Warp Shell)</div>
        <div class="telemetry-value" id="v_field">1.20</div>
        <div class="gauge"><div class="gauge-fill" id="g_field"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Shield Fraction & Stretch</div>
        <div class="telemetry-value" id="v_fshield">0%</div>
        <div class="gauge"><div class="gauge-fill" id="g_fshield"></div></div>
        <div class="telemetry-value" id="v_fstretch" style="margin-top:4px;">0 / 0</div>
        <div class="gauge"><div class="gauge-fill" id="g_fstretch"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Gradient Trim (FR / LR / Warp–Shield)</div>
        <div class="telemetry-value" id="v_gradFR">1.00×</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradFR"></div></div>
        <div class="telemetry-value" id="v_gradLR" style="margin-top:4px;">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradLR"></div></div>
        <div class="telemetry-value" id="v_gradWS" style="margin-top:4px;">50% warp / 50% shield</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradWS"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Clock & Photons & Magnetics</div>
        <div class="telemetry-value" id="v_clock">1.000×</div>
        <div class="gauge"><div class="gauge-fill" id="g_clock"></div></div>
        <div class="telemetry-value" id="v_phot" style="margin-top:4px;">0 /s</div>
        <div class="gauge"><div class="gauge-fill" id="g_phot"></div></div>
        <div class="telemetry-value" id="v_mag" style="margin-top:4px;">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_mag"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Core & Coolant Temperatures</div>
        <div class="telemetry-value" id="v_tcore">0 °C</div>
        <div class="gauge"><div class="gauge-fill" id="g_tcore"></div></div>
        <div class="telemetry-value" id="v_tcool" style="margin-top:4px;">0 °C</div>
        <div class="gauge"><div class="gauge-fill" id="g_tcool"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Entanglement Flux & Plasma Shape</div>
        <div class="telemetry-value" id="v_ent">0 /s</div>
        <div class="gauge"><div class="gauge-fill" id="g_ent"></div></div>
        <div class="telemetry-value" id="v_plen" style="margin-top:4px;">0 u</div>
        <div class="gauge"><div class="gauge-fill" id="g_plen"></div></div>
        <div class="telemetry-value" id="v_prad" style="margin-top:4px;">0 u</div>
        <div class="gauge"><div class="gauge-fill" id="g_prad"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Plasma Wave Metric</div>
        <div class="telemetry-value" id="v_pwave">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_pwave"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Status</div>
        <p style="font-size:11px;margin:3px 0 0;">
          Plasma stays subluminal; apparent FTL comes from warp geometry + CST mapping, with <strong>E ⇌ m</strong> core and hull shell conversion.
        </p>
      </div>
    </div>
  </div>

  <!-- ===== SCIENTIFIC ENHANCEMENTS FOR THE INTERSTELLAR STAR CLOCK ===== -->
  <div class="panel">
    <h2>Scientific Enhancements for the Interstellar Star Clock & Warp Drive</h2>
    <p class="note">
      These equations sit behind the CST clock and warp navigation. They convert poetry into physics while keeping your
      bold vision intact — time slippage, star coordinates, and energy gradients all feed one unified engine.
    </p>
    <h3>1. Time Dilation (Special Relativity)</h3>
    <div class="eq">Δt' = Δt × √(1 - v² / c²)</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> Used to adjust ship proper time vs CST when plasma streams move at a fraction of <em>c</em> inside the engine.</li>
      <li><strong>Navigation:</strong> High-velocity segments of a jump arc show reduced proper time; CST keeps the crew anchored to the master cosmic clock.</li>
    </ul>

    <h3>2. Gravitational Time Dilation (General Relativity)</h3>
    <div class="eq">Δt' = Δt × √(1 - 2GM / (r c²))</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> Used when the ship operates near stars, planets, or compact objects; CST compensates for slower clocks in deeper wells.</li>
      <li><strong>Warp control:</strong> The engine avoids curvature regimes where GR plus warp geometry could create unstable CTC-like loops.</li>
    </ul>

    <h3>3. Star Coordinate Mapping (RA / Dec → 3D)</h3>
    <div class="eq">
      x = cos(δ) × cos(α),&nbsp;
      y = cos(δ) × sin(α),&nbsp;
      z = sin(δ)
    </div>
    <ul class="list">
      <li><strong>Star clock:</strong> Anchors each star to a fixed direction on the celestial sphere at a given epoch.</li>
      <li><strong>Warp navigation:</strong> Converts RA/Dec into a 3D target vector for the FTL jump planner; the CST engine rides curvature along that vector.</li>
    </ul>

    <h3>4. Sidereal Clock Adjustment</h3>
    <div class="eq">Sidereal Day = 23h 56m 4.1s</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> The CST clock keeps both solar time and sidereal time; over years, the tiny offset accumulates into real star drift.</li>
      <li><strong>Warp navigation:</strong> Corrects star positions for drift since J2000 so the RA/Dec map stays aligned over long deep-time jumps.</li>
    </ul>

    <h3>5. Light-Time Correction</h3>
    <div class="eq">t = d / c</div>
    <ul class="list">
      <li><strong>Star clock:</strong> Shows how “old” the light is from each star; your constellations become time-delayed snapshots.</li>
      <li><strong>Warp comms:</strong> Compares conventional light-time to instantaneous entanglement or warp-burst signals in your communication panels.</li>
    </ul>

    <h3>6. Stefan–Boltzmann Law (Radiative Heat from Coils & Panels)</h3>
    <div class="eq">F = σ T⁴</div>
    <ul class="list">
      <li><strong>Engine core:</strong> Predicts heat flux from hot coils, plasma chambers, and gradient panels as a function of temperature.</li>
      <li><strong>Safety / Shield mix:</strong> When radiative flux approaches structural limits, the controller shifts energy from warp geometry into cooling and shielding.</li>
      <li><strong>Telemetry:</strong> The “Core Temp” and “Coolant Temp” readouts conceptually trace back to this T⁴ scaling.</li>
    </ul>

    <h3>7. Hamiltonian Operator (Energy of the Warp Field)</h3>
    <div class="eq">Ĥ ψ = E ψ</div>
    <ul class="list">
      <li><strong>Field layer:</strong> Treats the warp shell and vacuum modes as a quantum system with a Hamiltonian that encodes all energy terms (plasma, EM, vacuum).</li>
      <li><strong>Gradient design:</strong> By choosing a Hamiltonian with stable eigenmodes, you bias the engine toward field configurations that maintain a smooth bubble.</li>
      <li><strong>CST integration:</strong> The CST clock can be thought of as following the phase evolution of the warp state vector over long-duration missions.</li>
    </ul>

    <h3>8. Wave Equation (Propagation of Warp & Shield Fields)</h3>
    <div class="eq">∂²ψ/∂t² = c² ∇²ψ  &nbsp; (classical form)</div>
    <ul class="list">
      <li><strong>Field geometry:</strong> Describes how disturbances in EM, plasma, and vacuum modes propagate through the warp shell.</li>
      <li><strong>Gradient control:</strong> The controller uses an internal wave model so pulses launched by the coils arrive in phase at the front vs rear shell.</li>
      <li><strong>Shield shaping:</strong> Radiation and particle shielding are engineered as standing-wave solutions that wrap the hull in a stable harmonic envelope.</li>
    </ul>

    <p class="note">
      Together, these equations let the Interstellar Star Clock do more than tell time: it <em>predicts</em> how time, energy, and geometry interact.
      Your warp engine sits on top of this clock, using CST to keep energy gradients, curvature, and crew experience in sync.
      The <strong>E ⇌ m zones</strong> inside the engine are: (1) the nuclear mass core (m → E) and (2) the hull conversion shell (E → m effective mass around the ship).
    </p>
  </div>
  <!-- ===== ENGINE + TELEMETRY SCRIPT (ENGINE + SAFETY PANEL) ===== -->
  <script>
// ===== Utility =====
const TAU = Math.PI*2;
const lerp=(a,b,t)=>a+(b-a)*t;
function drawText(ctx, s, x, y, align){
  ctx.fillStyle='#eaf0ff';
  ctx.textAlign=align||'left';
  ctx.textBaseline='middle';
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillText(s,x,y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function fmt(n,dec){ return n.toFixed(dec||0); }
function fmtLarge(n){
  var aa=Math.abs(n);
  if(aa>=1e12) return (n/1e12).toFixed(2)+' T';
  if(aa>=1e9)  return (n/1e9 ).toFixed(2)+' G';
  if(aa>=1e6)  return (n/1e6 ).toFixed(2)+' M';
  if(aa>=1e3)  return (n/1e3 ).toFixed(1)+' K';
  return n.toFixed(0);
}

// ===== Helpers with physics-aware timing =====
function computeSpeedMult(w){ return lerp(1, 6, (w-1)/9); }
function computeFieldRadius(w){ return lerp(1.2, 2.6, (w-1)/9); }
function computeHeatLevel(w){ return lerp(0.35, 1.0, (w-1)/9); }
function computeCoolLevel(w){ return 1 - computeHeatLevel(w)*0.5; }
function computePlasmaLength(w){ return Math.round( lerp(90, 260, (w-1)/9) ); }
function computePlasmaRadius(w){ return Math.round( lerp(10, 36, (w-1)/9) ); }
function computeEntangleRate(w){ return lerp(0.6, 3.2, (w-1)/9); }
function computeFieldAspectX(w){ return lerp(1.0, 1.9, (w-1)/9); }
function computeFieldAspectY(w){ return lerp(0.9, 0.6, (w-1)/9); }
function computeStability(w){
  var s = 1 - (w-1)/12;
  if(s<0.55) s=0.55;
  return s;
}

// simple SR speed fraction for telemetry
function localSpeedFrac(w){
  return clamp(0.2 + 0.08*(w-1), 0.2, 0.92);
}
function gammaSR(w){
  const v = localSpeedFrac(w);
  return 1/Math.sqrt(1-v*v);
}
function gammaGR_regime(reg){
  if(reg === 'earth') return 1.0000000003;
  if(reg === 'sun')   return 1.0000020;
  if(reg === 'deep')  return 1.0;
  return 1.0;
}
function combinedClockRate(w, reg){
  const warpScale = lerp(1, 1.6, (w-1)/9);
  const gSR = gammaSR(w);
  const gGR = gammaGR_regime(reg);
  const rate = 1/(warpScale * gSR * gGR);
  return rate;
}

// Temps (conceptual mapping)
function computeCoreTempC(w){ return Math.round( 200 + computeHeatLevel(w)*1000 + computeSpeedMult(w)*40 ); }
function computeCoolantTempC(w){ return Math.round( 25 + computeCoolLevel(w)*300 ); }

// ===== Planet table (Earth static, for jump planning) =====
const PLANETS = {
  mercury:{name:'Mercury', au:0.39},
  venus  :{name:'Venus',   au:0.72},
  earth  :{name:'Earth',   au:1.00},
  mars   :{name:'Mars',    au:1.52},
  jupiter:{name:'Jupiter', au:5.20},
  saturn :{name:'Saturn',  au:9.58},
  uranus :{name:'Uranus',  au:19.2},
  neptune:{name:'Neptune', au:30.1},
  pluto  :{name:'Pluto',   au:39.5}
};

// ===== Layout (ENGINE SHIFTED LEFT) =====
const layout = {
  centerY: 450,
  startX: 40,
  length: 900,
  bodyR: 120,
  fanX: 70,
  stages: [
    {len:160, r:120, name:'Intake / Pre-Compression'},
    {len:120, r:112, name:'Compression Stage A'},
    {len:100, r:104, name:'Compression Stage B'},
    {len: 80, r: 96, name:'Compression Stage C'},
    {len: 70, r: 88, name:'Warp Coils / Field Shapers'},
    {len: 70, r: 80, name:'Reactors (Electro-Plasma / Nuclear Mass Core)'},
    {len: 60, r: 72, name:'Photon/Plasma Mixer'},
    {len: 50, r: 64, name:'Nozzle Coupler'}
  ],
  nozzle:{len:160, r0:60, r1:14, name:'Exhaust Nozzle'},
  coils:[{xOff:-18, name:'Field Coil L'},{xOff:36, name:'Field Coil R'}]
};
let xx=layout.startX;
layout.stages = layout.stages.map(function(s){
  var out={x0:xx,x1:xx+s.len,len:s.len,r:s.r,name:s.name};
  xx+=s.len; return out;
});
layout.nozzle.x0 = xx;
layout.nozzle.x1 = xx + layout.nozzle.len;

// ===== State =====
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let running = true;
let t0 = performance.now();
let fanAngle = 0;
let fps = 60;
let warpClock = Date.now();

// Jump / safety state
let warpClearanceGo = false;
let lastJumpPlan = null;
let autoJumpActive = false;
let jumpProgress = 0;
let jumpDurationMs = 10000;
let lockedPlanetKey = 'mars';

// particle arrays
let particles = [], heat = [], cool = [], entangle = [], pipes = [];

// Controls
const warpEl   = document.getElementById('warp');
const speedEl  = document.getElementById('speed');
const fieldEl  = document.getElementById('field');
const tempEl   = document.getElementById('temp');
const timeEl   = document.getElementById('time');
const labelsEl = document.getElementById('labels');

// Gradient trim controls
const gradFrontRearEl  = document.getElementById('grad_frontRear');
const gradLeftRightEl  = document.getElementById('grad_leftRight');
const gradWarpShieldEl = document.getElementById('grad_warpShield');

// Gradient mode controls
const gradModeEl      = document.getElementById('gradMode');
const gradModeLabelEl = document.getElementById('gradModeLabel');
const gradSlidersBox  = document.getElementById('grad_sliders');
let autoTrim = false;

// Safety / jump DOM
const targetPlanetEl   = document.getElementById('targetPlanet');
const distAUEl         = document.getElementById('distAU');
const recWarpEl        = document.getElementById('recWarp');
const btnLockTarget    = document.getElementById('btnLockTarget');
const btnCalcSafety    = document.getElementById('btnCalcSafety');
const btnEngageJump    = document.getElementById('btnEngageJump');
const btnResetJump     = document.getElementById('btnResetJump');

const circCST          = document.getElementById('circ_cst');
const circInertia      = document.getElementById('circ_inertia');
const circClear        = document.getElementById('circ_clear');
const labelCST         = document.getElementById('label_cst');
const labelInertia     = document.getElementById('label_inertia');
const labelClear       = document.getElementById('label_clear');
const jumpStatusEl     = document.getElementById('jump_status');
const jumpProgEl       = document.getElementById('jump_progress');
const jumpTimeEl       = document.getElementById('jump_time');
const jumpEnergyEl     = document.getElementById('jump_energy');
const jumpCalcEl       = document.getElementById('jump_calc');
const mirrorSafety     = document.getElementById('mirrorSafetyText');

// Telemetry DOM
const v_speed=document.getElementById('v_speed'), g_speed=document.getElementById('g_speed');
const v_field=document.getElementById('v_field'), g_field=document.getElementById('g_field');
const v_fshield=document.getElementById('v_fshield'), g_fshield=document.getElementById('g_fshield');
const v_fstretch=document.getElementById('v_fstretch'), g_fstretch=document.getElementById('g_fstretch');

const v_gradFR=document.getElementById('v_gradFR'), g_gradFR=document.getElementById('g_gradFR');
const v_gradLR=document.getElementById('v_gradLR'), g_gradLR=document.getElementById('g_gradLR');
const v_gradWS=document.getElementById('v_gradWS'), g_gradWS=document.getElementById('g_gradWS');

const v_clock=document.getElementById('v_clock'), g_clock=document.getElementById('g_clock');
const v_phot=document.getElementById('v_phot'), g_phot=document.getElementById('g_phot');
const v_mag=document.getElementById('v_mag'), g_mag=document.getElementById('g_mag');
const v_tcore=document.getElementById('v_tcore'), g_tcore=document.getElementById('g_tcore');
const v_tcool=document.getElementById('v_tcool'), g_tcool=document.getElementById('g_tcool');
const v_ent=document.getElementById('v_ent'), g_ent=document.getElementById('g_ent');
const v_plen=document.getElementById('v_plen'), g_plen=document.getElementById('g_plen');
const v_prad=document.getElementById('v_prad'), g_prad=document.getElementById('g_prad');
const v_pwave=document.getElementById('v_pwave'), g_pwave=document.getElementById('g_pwave');
const clkUTC=document.getElementById('clk_utc');
const clkCST=document.getElementById('clk_cst');
const clkWarp=document.getElementById('clk_warp');

function warpFactor(){ return parseInt(warpEl.value,10); }
function speedMult(){ return computeSpeedMult(warpFactor()); }
function fieldRadius(){ return computeFieldRadius(warpFactor()); }
function heatLevel(){ return computeHeatLevel(warpFactor()); }
function coolLevel(){ return computeCoolLevel(warpFactor()); }

// gradient helpers
function gradFrontRear(){ return parseFloat(gradFrontRearEl.value)||1; }
function gradLeftRight(){ return parseFloat(gradLeftRightEl.value)||0; }
function gradWarpShield(){ return clamp(parseFloat(gradWarpShieldEl.value)||0.5,0,1); }

function updateHUD(){
  speedEl.textContent = 'x'+speedMult().toFixed(1);
  fieldEl.textContent = fieldRadius().toFixed(1)+' x D';
  tempEl.textContent  = heatLevel()>0.7? 'Hot' : (heatLevel()>0.5? 'Warm' : 'Cool');
  const reg = 'sun';
  const rate = combinedClockRate(warpFactor(), reg);
  timeEl.textContent = rate.toFixed(2)+' x';
}
updateHUD();
warpEl.addEventListener('input', ()=>{
  if(!autoJumpActive){ updateHUD(); }
});

// Toggle mode UI
function updateGradModeUI(){
  if(autoTrim){
    gradModeLabelEl.textContent = 'Sensor Auto-Trim';
    gradSlidersBox.classList.add('ghosted');
    gradFrontRearEl.disabled  = true;
    gradLeftRightEl.disabled  = true;
    gradWarpShieldEl.disabled = true;
  }else{
    gradModeLabelEl.textContent = 'Manual Trim';
    gradSlidersBox.classList.remove('ghosted');
    gradFrontRearEl.disabled  = false;
    gradLeftRightEl.disabled  = false;
    gradWarpShieldEl.disabled = false;
  }
}
autoTrim = false;
updateGradModeUI();

gradModeEl.addEventListener('change', ()=>{
  autoTrim = gradModeEl.checked;
  updateGradModeUI();
});

// ===== Streams & Pipes =====
function spawnParticle(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.6;
  var x0 = layout.startX+10;
  var v = 0.6 + Math.random()*0.7;
  particles.push({x:x0,y:y,v:v,life:0});
}
function spawnHeat(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.4;
  var xh = layout.stages[4].x0 + Math.random()*(layout.nozzle.x1 - layout.stages[4].x0);
  heat.push({x:xh,y:y,life:0});
}
function spawnCool(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.7;
  var xc = layout.stages[0].x0 + Math.random()*(layout.stages[2].x1-layout.stages[0].x0);
  cool.push({x:xc,y:y,life:0});
}
function spawnEntangle(){
  var baseX = layout.stages[5].x0 + Math.random()*40;
  var phase = Math.random()*TAU;
  entangle.push({x:baseX, y:layout.centerY, phase:phase, life:0});
}
function initPipes(){
  pipes = [];
  for(var i=0;i<layout.stages.length-1;i++){
    var s = layout.stages[i];
    var nx = s.x1;
    pipes.push({x0:nx-6,y0:layout.centerY+28,x1:nx+6,y1:layout.centerY+28,phase:Math.random()*TAU});
  }
}
initPipes();

// ===== Draw helpers =====
function drawCylinder(x0,x1,rTop,rBot){
  var grd = ctx.createLinearGradient(0, layout.centerY-rTop, 0, layout.centerY+rBot);
  grd.addColorStop(0, '#2a334d');
  grd.addColorStop(0.5,'#9fb1ff22');
  grd.addColorStop(1, '#0e132b');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY + rBot);
  ctx.lineTo(x0, layout.centerY + rBot);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.strokeStyle = '#cfe2ff33';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x1, layout.centerY-rTop);
  ctx.lineTo(x1, layout.centerY+rBot);
  ctx.stroke();
}
function drawNozzle(nz){
  var x0=nz.x0,x1=nz.x1,r0=nz.r0,r1=nz.r1;
  var grd = ctx.createLinearGradient(x0,layout.centerY,x1,layout.centerY);
  grd.addColorStop(0,'#2a334d');
  grd.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - r0);
  ctx.lineTo(x1, layout.centerY - r1);
  ctx.lineTo(x1, layout.centerY + r1);
  ctx.lineTo(x0, layout.centerY + r0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
}
function drawCoil(xOff){
  var x = layout.startX + xOff;
  ctx.strokeStyle='#a6b8ffaa';
  ctx.lineWidth=8;
  ctx.beginPath();
  ctx.moveTo(x, layout.centerY-48);
  ctx.lineTo(x, layout.centerY+48);
  ctx.stroke();
  ctx.lineWidth=3;
  ctx.strokeStyle='#5ea8ffaa';
  for(var i=-3;i<=3;i++){
    ctx.beginPath();
    ctx.arc(x, layout.centerY + i*12, 22+Math.abs(i)*2, 0, TAU);
    ctx.stroke();
  }
}
function drawFan(angle){
  var cx = layout.fanX, cy = layout.centerY;
  ctx.fillStyle='#a4b2d8';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, TAU);
  ctx.fill();
  for(var i=0;i<6;i++){
    var a = angle + i*TAU/6;
    var r1=14, r2=52;
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath();
    ctx.fill();
  }
}

// Nuclear mass core + E ⇌ m hull conversion shell
function drawShieldPlatesAndCore(){
  var reactorStage = layout.stages[5];
  var coreX = (reactorStage.x0 + reactorStage.x1)/2;
  var coreY = layout.centerY;
  var coreR = 26;

  ctx.beginPath();
  ctx.fillStyle='#f5f0c8';
  ctx.arc(coreX, coreY, coreR, 0, TAU);
  ctx.fill();
  ctx.strokeStyle='#d0c86b';
  ctx.lineWidth=2;
  ctx.stroke();

  ctx.fillStyle='#11131a';
  ctx.font='10px system-ui,Segoe UI,Roboto,Arial';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText('E=mc²', coreX, coreY-6);
  ctx.fillText('m=E/c²', coreX, coreY+6);

  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=3;
  var plateOffset = layout.bodyR + 16;
  for(var i=-1;i<=1;i++){
    var dy = plateOffset + i*12;
    ctx.beginPath();
    ctx.ellipse(coreX, coreY - dy, 110, 12, 0, 0, Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(coreX, coreY + dy, 110, 12, 0, Math.PI, 0);
    ctx.stroke();
  }

  ctx.strokeStyle='#ffcc66aa';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(coreX+coreR, coreY);
  ctx.lineTo(coreX+coreR+34, coreY-34);
  ctx.lineTo(coreX+coreR+80, coreY-34);
  ctx.stroke();
}

function drawField(){
  var D = layout.bodyR*2;
  var base = fieldRadius()*D*0.35;
  var ax = computeFieldAspectX(warpFactor());
  var ay = computeFieldAspectY(warpFactor());

  var gFR = gradFrontRear();
  var gLR = gradLeftRight();

  if(autoTrim){
    var t = performance.now()*0.00025;
    gFR += 0.04*Math.sin(t*1.2);
    gLR *= 0.45;
  }

  ctx.strokeStyle='#33e1b588';
  ctx.lineWidth=2;

  var cx = layout.startX+layout.length*0.65 + gLR*40;

  for(var i=0;i<6;i++){
    var rx = base*ax + i*22;
    var ry = base*ay + i*10;

    var frontBias = 1 + (gFR-1)*0.6;
    var localCx   = cx + (i-2)*4*(gFR-1);

    ctx.beginPath();
    ctx.ellipse(localCx, layout.centerY, rx*frontBias, ry, 0, 0, TAU);
    ctx.stroke();
  }
}

function drawTimeLegendLeft(){
  var x=20;
  var y=120;
  var lines=[
    'UTC Atomic',
    'CST (engine)',
    'Interstellar CST',
    'Universal Time',
    'UTA'
  ];
  for(var i=0;i<lines.length;i++){
    drawText(ctx, lines[i], x, y+i*20, 'left');
  }
}
function drawCSTClock(){
  var x = layout.stages[3].x0+12;
  var y = layout.centerY-22;
  ctx.fillStyle='#0e1536';
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.fillRect(x,y,150,32);
  ctx.strokeRect(x,y,150,32);
  drawText(ctx,'Atomic Clock (CST)', x+6, y+16, 'left');
}
function drawStatusLabel(){
  var x = layout.nozzle.x0-40;
  var y = layout.centerY- layout.bodyR - 58;
  var warp = warpFactor();
  var stab = computeStability(warp);
  var s = 'Warp '+warp+' | Stability '+stab.toFixed(2);
  drawText(ctx, s, x, y, 'left');
}
function labelFromTo(text, ax, ay, tx, ty){
  ctx.strokeStyle='#9bb4ff66';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(ax,ay);
  ctx.lineTo(tx,ty);
  ctx.stroke();
  drawText(ctx, text, tx+4, ty, 'left');
}

// Labels
function drawLabels(){
  const topY = layout.centerY - layout.bodyR - 42;
  const botY = layout.centerY + layout.bodyR + 44;

  const s0=layout.stages[0], s1=layout.stages[1], s2=layout.stages[2],
        s3=layout.stages[3], s4=layout.stages[4], s5=layout.stages[5],
        s6=layout.stages[6];

  labelFromTo('Vacuum Intake', s0.x0+12, layout.centerY- s0.r, s0.x0-40, topY-4);
  labelFromTo('Magnetic Fan (negative-energy modulator)', layout.fanX, layout.centerY-34, s0.x0-20, topY+16);
  labelFromTo('Modulates Vacuum Air Circulation', s1.x0+6, layout.centerY- s1.r, s1.x0+20, topY+38);
  labelFromTo('Compression A/B/C Stages', s2.x1-10, layout.centerY- s2.r, s2.x0+40, topY+60);
  labelFromTo('Vacuum Fluctuation Modulator', s4.x0+6, layout.centerY- s4.r, s4.x0-10, topY+82);
  labelFromTo('Reactors (Mass–Energy Core)', s5.x0+10, layout.centerY- s5.r, s5.x0+120, topY+104);
  labelFromTo('Photon/Plasma Mixer', s6.x0+10, layout.centerY- s6.r, s6.x0+180, topY+126);

  const coreX = (s5.x0 + s5.x1)/2;
  labelFromTo('E ⇌ m Conversion Core (E=mc² / m=E/c²)', coreX, layout.centerY, coreX-80, topY+148);
  const cxField = layout.startX+layout.length*0.65;
  labelFromTo('Hull Conversion Shell (E → m effective mass around hull)', cxField, layout.centerY+ computeFieldRadius(warpFactor())*layout.bodyR*0.35+8, cxField+110, botY+250);

  labelFromTo('Entanglement Feedback Loop', s5.x0+24, layout.centerY+16, s5.x0-20, botY+8);
  labelFromTo('Atomic Clocks (CST) + Entangled Feedback', s3.x0+20, layout.centerY, s3.x0-40, botY+32);
  labelFromTo('Pulse Control Panel', s4.x1-8, layout.centerY+8, s4.x1+40, botY+56);
  labelFromTo('AFT Power Ramp', layout.nozzle.x0-10, layout.centerY+6, layout.nozzle.x0+40, botY+80);
  labelFromTo('AFT Power Ramp (Gradual / Safe)', layout.nozzle.x0+20, layout.centerY+22, layout.nozzle.x0+150, botY+104);
  labelFromTo('Gravitational Stabilization Panel', s2.x0+20, layout.centerY+ s2.r, s2.x0-20, botY+128);
  labelFromTo('Quantum Vertex Dampers (F/R/U/D/L/R)', s4.x0+20, layout.centerY+ s4.r, s4.x0+140, botY+152);
  labelFromTo('Detection Lasers (particles)', s1.x1-10, layout.centerY+ s1.r, s1.x1+110, botY+176);
  labelFromTo('Thermal Management (Water Cooling)', s5.x1-8, layout.centerY+ s5.r, s5.x1+160, botY+200);

  labelFromTo('ZPF Oscillator Rings (ZPO)', s4.x0+12, layout.centerY- s4.r+10, s4.x0-100, topY+170);
  labelFromTo('Casimir Microarrays', s3.x1-6, layout.centerY- s3.r+6, s3.x1+28, topY+192);
  labelFromTo('Tachyon Feedback Node', s5.x0+6, layout.centerY+12, s5.x0-120, botY+224);
  labelFromTo('CTC Guard (CST Damping)', s3.x0+8, layout.centerY+8, s3.x0-140, botY+248);
  labelFromTo('Positron Diagnostic Port', s6.x1-6, layout.centerY- s6.r+6, s6.x1+70, topY+214);
  labelFromTo('Limestone–Granite Resonator', s0.x0+20, layout.centerY+ s0.r-8, s0.x0-140, botY+272);

  labelFromTo('Temporal vs Spatial Warp (rx/ry vs clock)', cxField, layout.centerY - computeFieldRadius(warpFactor())*layout.bodyR*0.35 - 22, cxField-160, topY-18);
  labelFromTo('Exotic-Matter Bypass (EM stress / Casimir)', s4.x1-6, layout.centerY+ s4.r-10, s4.x1+60, botY+224);

  labelFromTo('Forward Gradient Panel (Contraction Field)', s4.x0+40, layout.centerY- s4.r-6, s4.x0+110, topY-24);
  labelFromTo('Aft Gradient Panel (Expansion Dump)', layout.nozzle.x0+40, layout.centerY+ layout.nozzle.r0, layout.nozzle.x0+170, botY+296);
}

function drawCoreGlow(){
  var g = ctx.createLinearGradient(layout.startX, layout.centerY, layout.nozzle.x1, layout.centerY);
  g.addColorStop(0,'#a9bbff00');
  g.addColorStop(0.4,'#9bb4ff22');
  g.addColorStop(0.8,'#eaf0ff44');
  ctx.fillStyle=g;
  ctx.fillRect(layout.startX, layout.centerY-12, layout.nozzle.x1-layout.startX, 24);
}
function drawPlasmaCone(){
  var len = computePlasmaLength(warpFactor());
  var baseR = computePlasmaRadius(warpFactor());
  var x0 = layout.nozzle.x1;
  var x1 = x0 + len;
  var grad = ctx.createLinearGradient(x0, layout.centerY, x1, layout.centerY);
  grad.addColorStop(0, 'rgba(255,220,168,0.65)');
  grad.addColorStop(0.3, 'rgba(255,220,168,0.35)');
  grad.addColorStop(1, 'rgba(255,220,168,0.02)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - baseR);
  ctx.lineTo(x1, layout.centerY - baseR*0.35);
  ctx.lineTo(x1, layout.centerY + baseR*0.35);
  ctx.lineTo(x0, layout.centerY + baseR);
  ctx.closePath();
  ctx.fill();
}
function drawPipes(){
  for(var i=0;i<pipes.length;i++){
    var p = pipes[i];
    ctx.strokeStyle='#6bd1ff';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x0,p.y0);
    ctx.lineTo(p.x1,p.y1);
    ctx.stroke();
    var n=4;
    for(var k=0;k<n;k++){
      var t = ((k/n) + (performance.now()*0.0005) ) % 1;
      var xx = p.x0 + (p.x1-p.x0)*t;
      var yy = p.y0 + (p.y1-p.y0)*t;
      ctx.fillStyle='#9bb4ff';
      ctx.beginPath();
      ctx.arc(xx, yy, 2, 0, TAU);
      ctx.fill();
    }
  }
}
function drawCoolingLoops(){
  var y = layout.centerY + layout.bodyR - 16;
  ctx.strokeStyle='#6bd1ff';
  ctx.lineWidth=2;
  ctx.beginPath();
  var x0 = layout.startX+10;
  ctx.moveTo(x0,y);
  for(var x1 = x0; x1 < layout.nozzle.x0-10; x1 += 32){
    ctx.lineTo(x1+16, y+6);
    ctx.lineTo(x1+32, y);
  }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=1;
  var cxF = layout.startX - 10;
  var cxR = layout.nozzle.x1 + 20;
  var cy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(cxF, cy-44); ctx.lineTo(cxF-34, cy-44);
  ctx.moveTo(cxF, cy+44); ctx.lineTo(cxF-34, cy+44);
  ctx.moveTo(cxR, cy-34); ctx.lineTo(cxR+34, cy-34);
  ctx.moveTo(cxR, cy+34); ctx.lineTo(cxR+34, cy+34);
  ctx.stroke();

  var ccx = layout.startX+layout.length*0.65;
  var ccy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(ccx-16, ccy); ctx.lineTo(ccx+16, ccy);
  ctx.moveTo(ccx, ccy-16); ctx.lineTo(ccx, ccy+16);
  ctx.stroke();
}

// ===== Telemetry Update =====
function setGauge(span, frac){ span.style.width = (clamp(frac,0,1)*100).toFixed(0)+'%'; }
function updateTelemetry(dt){
  var w  = warpFactor();
  var sm = computeSpeedMult(w);
  var fr = computeFieldRadius(w);
  var hl = computeHeatLevel(w);
  var cl = computeCoolLevel(w);

  var instFps = (dt>0)? 1000/dt : 60;
  fps = fps*0.9 + instFps*0.1;

  var vLocal = localSpeedFrac(w);
  var gSR = gammaSR(w);
  var gGR = gammaGR_regime('sun');
  var effClockRate = combinedClockRate(w,'sun');

  var p_phot = 0.7*sm;
  var p_ent  = 0.25*computeEntangleRate(w);
  var pWave  = (0.2*sm);

  var perSec = function(p){ return p * fps; };
  var mag = fr*sm;

  var gFR = gradFrontRear();
  var gLR = gradLeftRight();
  var gWS = gradWarpShield();

  if(autoTrim){
    var t = performance.now()*0.0002;
    gFR += 0.04*Math.sin(t*1.4);
    gLR *= 0.45;
    gWS = clamp(gWS + 0.12*Math.sin(t*0.7), 0.25, 0.85);
  }

  var D = layout.bodyR*2;
  var base = fr*D*0.35;
  var ax = computeFieldAspectX(w);
  var ay = computeFieldAspectY(w);
  var rx = base*ax + 2*22;
  var ry = base*ay + 2*10;

  var coreC = computeCoreTempC(w);
  var coolC = computeCoolantTempC(w);

  v_speed.textContent = 'x'+sm.toFixed(1); setGauge(g_speed, (sm-1)/(6-1));
  v_field.textContent = fr.toFixed(2); setGauge(g_field, (fr-1.2)/(2.6-1.2));

  var shieldFracRaw = (fr-1.2)/(2.6-1.2);
  var shieldFrac    = clamp(shieldFracRaw + (1-gWS)*0.3,0,1);

  v_fshield.textContent = Math.round(shieldFrac*100)+'%'; setGauge(g_fshield, shieldFrac);
  v_fstretch.textContent = fmt(rx,0)+' / '+fmt(ry,0); setGauge(g_fstretch, clamp(rx/(base*1.9+2*22),0,1));

  v_gradFR.textContent = gFR.toFixed(2)+'×';
  setGauge(g_gradFR, clamp(Math.abs(gFR-1)/0.3,0,1));
  v_gradLR.textContent = (gLR>=0?'+':'')+gLR.toFixed(2);
  setGauge(g_gradLR, Math.abs(gLR)/0.3);
  var warpPct   = Math.round(gWS*100);
  var shieldPct = 100-warpPct;
  v_gradWS.textContent = warpPct+'% warp / '+shieldPct+'% shield';
  setGauge(g_gradWS, gWS);

  v_clock.textContent = effClockRate.toFixed(3)+'×'; setGauge(g_clock, 1-effClockRate);
  v_phot.textContent = fmtLarge(perSec(p_phot))+' /s'; setGauge(g_phot, Math.min(perSec(p_phot)/3000,1));
  v_mag.textContent = mag.toFixed(2); setGauge(g_mag, Math.min(mag/6.0,1));

  v_tcore.textContent = coreC+' °C'; setGauge(g_tcore, Math.min(coreC/1500,1));
  v_tcool.textContent = coolC+' °C'; setGauge(g_tcool, Math.min(coolC/400,1));

  var entPerSec = perSec(p_ent);
  var entScaled = entPerSec>=1e9? (entPerSec/1e9).toFixed(2)+' G/s'
                 : entPerSec>=1e6? (entPerSec/1e6).toFixed(2)+' M/s'
                 : Math.round(entPerSec)+' /s';
  v_ent.textContent = entScaled; setGauge(g_ent, Math.min(entPerSec/3.2e6,1));

  var plen = computePlasmaLength(w); v_plen.textContent = plen+' u'; setGauge(g_plen, (plen-90)/(260-90));
  var prad = computePlasmaRadius(w); v_prad.textContent = prad+' u'; setGauge(g_prad, (prad-10)/(36-10));
  v_pwave.textContent = pWave.toFixed(2); setGauge(g_pwave, Math.min(pWave/1.2,1));

  var now = Date.now();
  clkUTC.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'UTC'});
  clkCST.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'America/Chicago'});

  warpClock += dt * effClockRate;
  clkWarp.textContent = new Date(warpClock).toLocaleTimeString('en-US',{hour12:false});
}
// ===== Safety indicator helpers =====
function setCircleState(circleEl, labelEl, stateText, level){
  circleEl.classList.remove('safe-green','safe-amber','safe-red');
  if(level === 'green') circleEl.classList.add('safe-green');
  else if(level === 'amber') circleEl.classList.add('safe-amber');
  else circleEl.classList.add('safe-red');
  labelEl.textContent = stateText;
}

// Evaluate safety for given warp + front/rear trim
function evaluateSafety(w, gFRCand){
  const clockRate = combinedClockRate(w,'sun');
  const syncErr   = Math.abs(clockRate - 1);

  // Thresholds tuned so a safe band exists
  let cstLevel;
  if(syncErr < 0.11) cstLevel = 'green';
  else if(syncErr < 0.25) cstLevel = 'amber';
  else cstLevel = 'red';

  const inertialIndex = ((w-1)/9) + Math.abs(gFRCand-1)*0.6;
  let inerLevel;
  if(inertialIndex < 0.35) inerLevel = 'green';
  else if(inertialIndex < 0.6) inerLevel = 'amber';
  else inerLevel = 'red';

  const clearance = (cstLevel==='green' && inerLevel==='green');
  return {clockRate,syncErr,inertialIndex,cstLevel,inerLevel,clearance};
}

// Recommend warp based on distance in AU
function recommendWarpForDistance(au){
  let w = 2 + au*0.22;   // Mars ~2.3, Saturn ~4, Pluto ~10
  if(w < 1) w = 1;
  if(w > 9) w = 9;
  return Math.round(w);
}

// Compute safety; auto-search for a safe combination so all 3 can go green
function calculateJumpSafety(){
  // Always sync locked planet with current selector so Pluto really means Pluto
  lockedPlanetKey = targetPlanetEl.value || lockedPlanetKey;
  const key  = lockedPlanetKey;
  const info = PLANETS[key] || PLANETS['mars'];
  const au   = info.au;
  const recW0 = recommendWarpForDistance(au);

  // Search warp 1–9 and gFR 0.9–1.1 for a "green + green" combo
  let best = null;
  for(let w=1; w<=9; w++){
    for(let g=0.9; g<=1.1; g+=0.02){
      const s = evaluateSafety(w,g);
      if(s.clearance){
        const score = s.syncErr + s.inertialIndex;
        if(!best || score < best.score){
          best = {w,g,s,score};
        }
      }
    }
  }

  let chosenW, chosenGFR, safety;
  if(best){
    chosenW  = best.w;
    chosenGFR = best.g;
    safety   = best.s;
  }else{
    // Fall back to recommended warp and current trim
    chosenW  = recW0;
    chosenGFR = gradFrontRear();
    safety   = evaluateSafety(chosenW, chosenGFR);
  }

  // Apply chosen safe configuration back to controls
  warpEl.value          = chosenW;
  gradFrontRearEl.value = chosenGFR.toFixed(2);
  updateHUD();

  const cstLevel  = safety.cstLevel;
  const inerLevel = safety.inerLevel;
  warpClearanceGo = safety.clearance;
  const clearLevel = warpClearanceGo ? 'green' : 'red';

  setCircleState(circCST,     labelCST,     'CST Sync: '+(cstLevel==='green'?'LOCKED':'UNLOCKED'), cstLevel);
  setCircleState(circInertia, labelInertia, 'Cabin Inertia: '+(inerLevel==='green'?'GREEN':(inerLevel==='amber'?'AMBER':'RED')), inerLevel);
  setCircleState(circClear,   labelClear,   'Warp Clearance: '+(warpClearanceGo?'GO':'NO-GO'), clearLevel);

  if(mirrorSafety){
    mirrorSafety.textContent =
      'CST Sync: '+(cstLevel==='green'?'LOCKED':'UNLOCKED')+
      ' · Cabin Inertia: '+(inerLevel==='green'?'GREEN':(inerLevel==='amber'?'AMBER':'RED'))+
      ' · Warp Clearance: '+(warpClearanceGo?'GO':'NO-GO');
  }

  distAUEl.textContent  = au.toFixed(2)+' AU';
  recWarpEl.textContent = 'Warp '+chosenW;

  // === CALCULATIONS: from AU to CST coord time ===
  // Base: 4 hours per AU at Warp 1 (fiction), then divide by warp.
  const baseHours  = au * 4;                 // Δt_base = AU × 4 h
  const coordHours = baseHours / chosenW;    // Δt_CST = Δt_base / Warp
  const coordMs    = coordHours * 3600 * 1000;

  // E ⇌ m “budget” (conceptual indices)
  const coreIndex  = Math.round(au*chosenW*120); // core m→E activity
  const hullIndex  = Math.round(au*chosenW*80);  // hull E→m effective mass

  jumpTimeEl.textContent   = coordHours.toFixed(2);
  jumpEnergyEl.textContent = 'Core m→E '+coreIndex+' | Hull E→m '+hullIndex;
  jumpCalcEl.textContent   = 'Δt_base = '+au.toFixed(2)+' AU × 4 h = '+baseHours.toFixed(2)+' h; Δt_CST = Δt_base / Warp '+chosenW+' ≈ '+coordHours.toFixed(2)+' h';

  lastJumpPlan = {
    planetKey:key,
    distAU:au,
    recWarp:chosenW,
    coordHours:coordHours,
    coordMs:coordMs
  };

  // Map [0.1 h, 48 h] into [6 s, 30 s] animation
  let baseH = coordHours;
  if(baseH < 0.1) baseH = 0.1;
  if(baseH > 48)  baseH = 48;
  const minDur = 6000;
  const maxDur = 30000;
  const norm = (baseH - 0.1) / (48 - 0.1);
  jumpDurationMs = minDur + norm*(maxDur-minDur);

  jumpStatusEl.textContent = warpClearanceGo
    ? 'Safety OK — all circles can be GREEN. Ready to engage warp to '+info.name+'.'
    : 'Safety check: this configuration is not fully green; adjust or try again.';
  jumpProgEl.textContent = '0%';
}

// ===== Autopilot warp profile for jump =====
function updateAutoJump(dt){
  if(!autoJumpActive || !lastJumpPlan) return;
  const info = PLANETS[lastJumpPlan.planetKey];

  jumpProgress += dt / jumpDurationMs;
  if(jumpProgress >= 1){
    jumpProgress = 1;
    autoJumpActive = false;
    jumpStatusEl.textContent = 'Jump complete — simulated arrival at '+info.name+'. Engine continues at low warp.';
  }

  const phase = jumpProgress;
  const cruise  = lastJumpPlan.recWarp;
  const lowWarp = 2;
  let w;
  if(phase < 0.25){
    w = lerp(lowWarp, cruise, phase/0.25);              // accelerate
  }else if(phase < 0.75){
    w = cruise;                                         // cruise
  }else{
    w = lerp(cruise, lowWarp, (phase-0.75)/0.25);       // decelerate
  }

  warpEl.value = Math.round(clamp(w,1,10));
  updateHUD();
  jumpProgEl.textContent = Math.round(jumpProgress*100)+'%';
}

// ===== Render Loop =====
function render(dt){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawField();
  for(var i=0;i<layout.stages.length;i++){
    var s = layout.stages[i];
    drawCylinder(s.x0, s.x1, s.r, s.r);
  }
  drawNozzle(layout.nozzle);
  drawShieldPlatesAndCore();
  drawCoreGlow();
  for(var j=0;j<layout.coils.length;j++){ drawCoil(layout.coils[j].xOff); }
  drawFan(fanAngle);

  var pmult = computeSpeedMult(warpFactor());
  if(Math.random()<0.7*pmult) spawnParticle();
  for(var p=0;p<particles.length;p++){
    var pt = particles[p];
    pt.x += (1.9*pmult + pt.v)*1.2;
    pt.y += Math.sin((pt.x+pt.y)*0.01)*0.22*pmult;
    pt.life += dt;
  }
  particles = particles.filter(function(pt){ return pt.x < layout.nozzle.x1+560; });
  ctx.fillStyle='#9bb4ff';
  for(var q=0;q<particles.length;q++){
    ctx.globalAlpha=0.7;
    ctx.fillRect(particles[q].x, particles[q].y, 3, 2);
    ctx.globalAlpha=1;
  }

  if(Math.random()<0.25*pmult*heatLevel()) spawnHeat();
  if(Math.random()<0.25*pmult*coolLevel()) spawnCool();
  for(var h=0;h<heat.length;h++){ heat[h].life+=dt; heat[h].x+= 1.0*pmult; }
  for(var c0=0;c0<cool.length;c0++){ cool[c0].life+=dt; cool[c0].x+= 0.7*pmult; }
  heat = heat.filter(function(it){ return it.x<layout.nozzle.x1; });
  cool = cool.filter(function(it){ return it.x<layout.stages[3].x1; });
  for(var h2=0;h2<heat.length;h2++){
    ctx.fillStyle='#ffcc66';
    ctx.beginPath();
    ctx.arc(heat[h2].x,heat[h2].y,2+Math.sin(heat[h2].life*0.02)*1.5,0,TAU);
    ctx.fill();
  }
  for(var c2=0;c2<cool.length;c2++){
    ctx.fillStyle='#6bd1ff';
    ctx.beginPath();
    ctx.arc(cool[c2].x,c2+layout.centerY - layout.centerY,2+Math.cos(c2*0.02)*1.2,0,TAU);
    ctx.fill();
  }

  if(Math.random()<computeEntangleRate(warpFactor())*0.25) spawnEntangle();
  for(var e=0;e<entangle.length;e++){
    var en = entangle[e];
    en.life+=dt;
    en.x += 1.2*pmult;
    var amp = 26 + 8*Math.sin(en.life*0.01);
    var wv = 0.026*pmult;
    var yy = layout.centerY + Math.sin(en.phase + en.x*wv)*amp;
    ctx.fillStyle='#b26bff';
    ctx.beginPath();
    ctx.arc(en.x, yy, 2.2, 0, TAU);
    ctx.fill();
  }
  entangle = entangle.filter(function(en){ return en.x < layout.nozzle.x1 + 300; });

  drawPlasmaCone();
  drawPipes();
  drawCoolingLoops();
  drawLasers();

  drawTimeLegendLeft();
  drawCSTClock();
  drawStatusLabel();
  if(labelsEl.checked) drawLabels();
}

function loop(){
  if(!running) return;
  var now = performance.now();
  var dt = now - t0;
  t0 = now;
  fanAngle += 0.005 * dt * computeSpeedMult(warpFactor());

  updateAutoJump(dt);
  render(dt);
  updateTelemetry(dt);
  requestAnimationFrame(loop);
}
loop();

// ===== Buttons / interactions =====

// Lock planet selection
btnLockTarget.addEventListener('click', ()=>{
  lockedPlanetKey = targetPlanetEl.value || 'mars';
  const info = PLANETS[lockedPlanetKey] || PLANETS['mars'];
  distAUEl.textContent = info.au.toFixed(2)+' AU';
  jumpStatusEl.textContent = 'Planet locked: '+info.name+'. Now click "2. Calculate Safety".';
});

// Calculate safety
btnCalcSafety.addEventListener('click', ()=>{
  calculateJumpSafety();
});

// Engage jump (only if all circles green)
btnEngageJump.addEventListener('click', ()=>{
  if(!lastJumpPlan){
    jumpStatusEl.textContent = 'No jump plan — lock planet and calculate safety first.';
    return;
  }
  if(!warpClearanceGo){
    jumpStatusEl.textContent = 'Jump blocked — all circles must be GREEN (Warp Clearance = GO).';
    return;
  }
  autoJumpActive = true;
  jumpProgress = 0;
  const info = PLANETS[lastJumpPlan.planetKey];
  jumpStatusEl.textContent = 'Jump engaged — CST controls acceleration and deceleration toward '+info.name+'.';
});

// Reset jump + safety to defaults
btnResetJump.addEventListener('click', ()=>{
  lastJumpPlan = null;
  autoJumpActive = false;
  jumpProgress = 0;
  jumpDurationMs = 10000;
  warpClearanceGo = false;

  targetPlanetEl.value = 'mars';
  lockedPlanetKey = 'mars';

  distAUEl.textContent  = '—';
  recWarpEl.textContent = '—';
  jumpProgEl.textContent   = '0%';
  jumpTimeEl.textContent   = '—';
  jumpEnergyEl.textContent = '—';
  jumpCalcEl.textContent   = '—';
  jumpStatusEl.textContent = 'Idle — lock planet, then calculate safety.';

  setCircleState(circCST,     labelCST,     'CST Sync: UNLOCKED', 'red');
  setCircleState(circInertia, labelInertia, 'Cabin Inertia: RED', 'red');
  setCircleState(circClear,   labelClear,   'Warp Clearance: NO-GO', 'red');

  if(mirrorSafety){
    mirrorSafety.textContent = 'CST Sync: UNLOCKED · Cabin Inertia: RED · Warp Clearance: NO-GO';
  }

  warpEl.value = 4;
  gradFrontRearEl.value = '1.00';
  updateHUD();
});

// ===== Self-Tests =====
(function runTests(){
  var results = [];
  function ok(name,cond){ results.push((cond?'PASS ':'FAIL ')+name); }
  ok('speed increases', computeSpeedMult(10) > computeSpeedMult(1));
  ok('field grows', computeFieldRadius(10) > computeFieldRadius(1));
  ok('plasma length grows', computePlasmaLength(10) > computePlasmaLength(1));
  ok('plasma radius grows', computePlasmaRadius(10) > computePlasmaRadius(1));
  ok('entangle rate grows', computeEntangleRate(10) > computeEntangleRate(1));
  ok('field stretches wider', computeFieldAspectX(10) > computeFieldAspectX(1));
  var el = document.getElementById('tests');
  if(el){ el.textContent = 'Self-tests: ' + results.join(' | '); }
})();
  </script>
</div> <!-- end .wrap -->
</body>
</html>
