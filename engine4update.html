<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interstellar Star Clock — Warp Engine Field Simulator (Warp Trip Planner)</title>
<style>
  :root{
    --bg:#050815;
    --panel:#111735;
    --ink:#eaf0ff;
    --muted:#9fa8d6;
    --accent:#8fb4ff;
    --grid:#1d264e;
    --border:#1c2750;
    --ok:#35e6a2;
    --warn:#ffd15a;
    --bad:#ff6b8b;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:1800px;
    margin:0 auto;
    padding:16px;
  }
  header{
    padding:12px 16px 18px;
    border-radius:16px;
    background:radial-gradient(circle at top left,#3b82f6 0,#020617 40%,#000 100%);
    border:1px solid rgba(148,163,184,0.4);
    margin-bottom:14px;
  }
  header h1{
    margin:0 0 4px;
    font-size:22px;
    letter-spacing:0.04em;
    text-transform:uppercase;
  }
  header p{
    margin:2px 0;
    font-size:13px;
    color:var(--muted);
  }
  .tagline{
    font-size:12px;
    color:#a5b4fc;
  }

  .grid-main{
    display:grid;
    grid-template-columns:minmax(0,1fr);
    gap:14px;
    align-items:flex-start;
    margin-bottom:14px;
  }
  .panel{
    background:var(--panel);
    border-radius:16px;
    border:1px solid var(--border);
    padding:12px 14px 14px;
    box-shadow:0 18px 40px rgba(15,23,42,0.75);
  }
  .panel h2{
    margin:0 0 8px;
    font-size:16px;
  }
  .panel h3{
    margin:12px 0 4px;
    font-size:14px;
  }
  .panel p{
    font-size:13px;
    color:var(--muted);
    margin:3px 0 6px;
  }
  .inline-label{
    font-size:12px;
    color:var(--muted);
    margin-right:6px;
  }
  .controls-group{
    margin-bottom:10px;
    padding:8px 10px;
    border-radius:10px;
    border:1px dashed rgba(148,163,184,0.4);
  }
  .controls-row{
    display:flex;
    align-items:center;
    gap:6px;
    margin-bottom:6px;
  }
  .controls-row.space{
    justify-content:space-between;
  }
  .controls-row:last-child{margin-bottom:0;}
  .controls-row label{
    font-size:12px;
    color:var(--muted);
  }
  input[type="range"]{
    width:100%;
  }
  .badge{
    padding:2px 6px;
    border-radius:999px;
    font-size:11px;
    border:1px solid rgba(148,163,184,0.6);
    color:#e5e7eb;
    white-space:nowrap;
  }
  .badge.ok{border-color:var(--ok);color:var(--ok);}
  .badge.warn{border-color:var(--warn);color:var(--warn);}
  .badge.bad{border-color:var(--bad);color:var(--bad);}

  .btn-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:8px;
  }
  button{
    font-size:12px;
    border-radius:999px;
    padding:4px 10px;
    border:1px solid rgba(148,163,184,0.5);
    background:#020617;
    color:#e5e7eb;
    cursor:pointer;
  }
  button:hover{background:#02081f;}
  button.primary{
    border-color:#4ade80;
    color:#bbf7d0;
  }
  button:disabled{
    opacity:0.45;
    cursor:default;
  }

  .time-box{
    margin-top:8px;
    padding:8px 10px;
    border-radius:10px;
    background:rgba(15,23,42,0.9);
    border:1px solid rgba(148,163,184,0.45);
    font-size:12px;
  }
  .time-row{
    display:flex;
    justify-content:space-between;
    gap:8px;
    margin-bottom:4px;
  }
  .time-row:last-child{margin-bottom:0;}
  .time-label{color:var(--muted);}
  .time-value{font-family:monospace;font-size:12px;}

  .labels-toggle{
    margin-top:8px;
    font-size:12px;
    display:flex;
    align-items:center;
    gap:6px;
    color:var(--muted);
  }

  canvas{
    display:block;
    width:100%;
    max-width:100%;
    border-radius:12px;
    background:#020617;
    border:1px solid var(--grid);
  }
  .tests{
    font-size:11px;
    color:var(--muted);
    margin-top:6px;
    word-break:break-word;
  }

  /* Telemetry gauges */
  .telemetry-grid{
    display:grid;
    grid-template-columns:repeat(4,minmax(0,1fr));
    gap:10px;
    margin-top:4px;
  }
  .telemetry-card{
    padding:6px 8px;
    border-radius:10px;
    border:1px solid rgba(148,163,184,0.45);
    background:#020617;
    font-size:11px;
  }
  .telemetry-title{
    font-size:11px;
    margin-bottom:2px;
    color:#e5e7eb;
  }
  .telemetry-value{
    font-family:monospace;
    font-size:11px;
    margin-bottom:2px;
  }
  .gauge{
    position:relative;
    width:100%;
    height:5px;
    border-radius:999px;
    background:#020617;
    overflow:hidden;
  }
  .gauge-fill{
    position:absolute;
    left:0;top:0;bottom:0;
    width:0%;
    border-radius:inherit;
    background:linear-gradient(90deg,#22c55e,#eab308,#ef4444);
    transition:width .12s linear;
  }

  /* Warp Trip Planner panel */
  .trip-grid{
    display:grid;
    grid-template-columns:minmax(0,1fr);
    gap:10px;
  }
  .trip-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-bottom:6px;
    align-items:center;
  }
  .trip-field{
    display:flex;
    flex-direction:column;
    gap:2px;
    min-width:140px;
    font-size:12px;
  }
  .trip-field label{
    font-size:11px;
    color:var(--muted);
  }
  .trip-field select{
    width:100%;
    font-size:12px;
    padding:4px 6px;
    border-radius:6px;
    border:1px solid rgba(148,163,184,0.5);
    background:#020617;
    color:#e5e7eb;
  }

  .warp-go-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-top:6px;
    font-size:12px;
  }
  .go-bubble{
    width:64px;
    height:64px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    border:2px solid #22c55e;
    color:#bbf7d0;
    background:rgba(34,197,94,0.12);
    text-align:center;
    box-shadow:0 0 18px rgba(34,197,94,0.25);
  }
  .go-bubble.no{
    border-color:#ef4444;
    color:#fecaca;
    background:rgba(239,68,68,0.18);
    box-shadow:0 0 18px rgba(239,68,68,0.4);
  }

  .trip-status{
    margin-top:4px;
    font-size:11px;
    color:#fbbf24;
  }
  .trip-report{
    margin-top:6px;
    border-top:1px dashed rgba(148,163,184,0.5);
    padding-top:6px;
    font-size:11px;
  }
  .trip-report-row{
    display:flex;
    justify-content:space-between;
    gap:6px;
    margin-bottom:2px;
  }
  .trip-report-row span:first-child{
    color:var(--muted);
  }

  /* Scientific Enhancements panel */
  .note{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }
  .eq{
    font-family: "SF Mono",ui-monospace,Menlo,Consolas,monospace;
    font-size:13px;
    margin:3px 0 5px;
    color:#e5e7eb;
  }
  .list{
    margin:4px 0 8px 18px;
    padding:0;
    font-size:12px;
    color:var(--muted);
  }
  .list li{margin-bottom:2px;}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Interstellar Star Clock — Warp Engine Field Simulator</h1>
    <p>Engine core, CST clock, and 4D navigation all on one canvas. This version shows where <strong>E ⇌ m</strong> happens inside the ship.</p>
    <p class="tagline">Mass–Energy core, hull conversion shell, warp bubble safety, and Earth→planet warp trip planner — all driven by CST timing.</p>
  </header>

  <div class="grid-main">
    <!-- ===== ENGINE CANVAS ===== -->
    <div class="panel">
      <h2>Engine View — Mass–Energy Core & Toroidal Shell</h2>
      <canvas id="view" width="1500" height="900"></canvas>
      <label class="labels-toggle">
        <input type="checkbox" id="labels" checked>
        Show detailed labels and CST research zones
      </label>
      <div id="tests" class="tests">Self-tests: pending…</div>
    </div>
  </div>

  <!-- ===== TELEMETRY PANEL ===== -->
  <div class="panel">
    <h2>Warp Telemetry — Streams, Temperatures, Field Shape</h2>
    <div class="telemetry-grid">
      <div class="telemetry-card">
        <div class="telemetry-title">Plasma Speed Multiplier</div>
        <div class="telemetry-value" id="v_speed">x1.0</div>
        <div class="gauge"><div class="gauge-fill" id="g_speed"></div></div>
        <div class="telemetry-title" style="margin-top:4px;">Field Radius (Warp Shell)</div>
        <div class="telemetry-value" id="v_field">1.20</div>
        <div class="gauge"><div class="gauge-fill" id="g_field"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Shield Fraction & Stretch</div>
        <div class="telemetry-value" id="v_fshield">0%</div>
        <div class="gauge"><div class="gauge-fill" id="g_fshield"></div></div>
        <div class="telemetry-value" id="v_fstretch" style="margin-top:4px;">0 / 0</div>
        <div class="gauge"><div class="gauge-fill" id="g_fstretch"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Gradient Trim (FR / LR / Warp–Shield)</div>
        <div class="telemetry-value" id="v_gradFR">1.00×</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradFR"></div></div>
        <div class="telemetry-value" id="v_gradLR" style="margin-top:4px;">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradLR"></div></div>
        <div class="telemetry-value" id="v_gradWS" style="margin-top:4px;">50% warp / 50% shield</div>
        <div class="gauge"><div class="gauge-fill" id="g_gradWS"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Clock & Photons & Magnetics</div>
        <div class="telemetry-value" id="v_clock">1.000×</div>
        <div class="gauge"><div class="gauge-fill" id="g_clock"></div></div>
        <div class="telemetry-value" id="v_phot" style="margin-top:4px;">0 /s</div>
        <div class="gauge"><div class="gauge-fill" id="g_phot"></div></div>
        <div class="telemetry-value" id="v_mag" style="margin-top:4px;">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_mag"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Core & Coolant Temperatures</div>
        <div class="telemetry-value" id="v_tcore">0 °C</div>
        <div class="gauge"><div class="gauge-fill" id="g_tcore"></div></div>
        <div class="telemetry-value" id="v_tcool" style="margin-top:4px;">0 °C</div>
        <div class="gauge"><div class="gauge-fill" id="g_tcool"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Entanglement Flux & Plasma Shape</div>
        <div class="telemetry-value" id="v_ent">0 /s</div>
        <div class="gauge"><div class="gauge-fill" id="g_ent"></div></div>
        <div class="telemetry-value" id="v_plen" style="margin-top:4px;">0 u</div>
        <div class="gauge"><div class="gauge-fill" id="g_plen"></div></div>
        <div class="telemetry-value" id="v_prad" style="margin-top:4px;">0 u</div>
        <div class="gauge"><div class="gauge-fill" id="g_prad"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Plasma Wave Metric</div>
        <div class="telemetry-value" id="v_pwave">0.00</div>
        <div class="gauge"><div class="gauge-fill" id="g_pwave"></div></div>
      </div>

      <div class="telemetry-card">
        <div class="telemetry-title">Status</div>
        <p style="font-size:11px;margin:3px 0 0;">
          Plasma stays subluminal; apparent FTL comes from warp geometry + CST mapping, with <strong>E ⇌ m</strong> core and hull shell conversion.
        </p>
      </div>
    </div>
  </div>

  <!-- ===== WARP TRIP PLANNER — EARTH → PLANET ===== -->
  <div class="panel">
    <h2>Warp Trip Planner — Earth → Planet (Buttons 1–5)</h2>
    <div class="trip-grid">
      <div>
        <div class="trip-row">
          <div class="trip-field">
            <label>1 — Target Planet (Earth is launch point)</label>
            <select id="wp_target">
              <option value="mercury">Mercury (0.39 AU)</option>
              <option value="venus">Venus (0.72 AU)</option>
              <option value="mars" selected>Mars (1.52 AU)</option>
              <option value="jupiter">Jupiter (5.20 AU)</option>
              <option value="saturn">Saturn (9.58 AU)</option>
              <option value="uranus">Uranus (19.2 AU)</option>
              <option value="neptune">Neptune (30.1 AU)</option>
              <option value="pluto">Pluto (39.5 AU)</option>
            </select>
          </div>

          <div class="trip-field">
            <label>2 — Warp Drive Factor (1–10)</label>
            <select id="wp_warp">
              <option value="1">Warp 1</option>
              <option value="2">Warp 2</option>
              <option value="3">Warp 3</option>
              <option value="4" selected>Warp 4</option>
              <option value="5">Warp 5</option>
              <option value="6">Warp 6</option>
              <option value="7">Warp 7</option>
              <option value="8">Warp 8</option>
              <option value="9">Warp 9</option>
              <option value="10">Warp 10</option>
            </select>
          </div>
        </div>

        <div class="btn-row">
          <button id="btn_plan" class="primary">3 — Compute Warp Trip</button>
          <button id="btn_reset">4 — Reset to Defaults</button>
          <button id="btn_warp" disabled>5 — Engage Warp (click when highlighted)</button>
        </div>

        <div class="warp-go-row">
          <div id="goBubble" class="go-bubble">SAFE<br>GO</div>
          <div>
            <div style="font-size:12px;color:var(--muted);">
              Bubble shows <strong>Go / No-Go</strong> based on curvature, time dilation, and g-force.
            </div>
            <div id="wp_status" class="trip-status">
              Idle — select planet + warp, then press “Compute Warp Trip”.
            </div>
          </div>
        </div>

        <div class="trip-report">
          <div class="trip-report-row">
            <span>Distance (Earth → planet)</span>
            <span id="trip_dist">—</span>
          </div>
          <div class="trip-report-row">
            <span>Coordinate Trip Time (CST)</span>
            <span id="trip_coord">—</span>
          </div>
          <div class="trip-report-row">
            <span>Ship Proper Time (warp frame)</span>
            <span id="trip_ship">—</span>
          </div>
          <div class="trip-report-row">
            <span>ΔAge (CST − Ship) for this trip</span>
            <span id="trip_age">—</span>
          </div>
          <div class="trip-report-row">
            <span>Speeds</span>
            <span id="trip_speed">—</span>
          </div>
          <div class="trip-report-row">
            <span>Curvature Index</span>
            <span id="trip_curv">—</span>
          </div>
          <div class="trip-report-row">
            <span>Approx g-force (accel)</span>
            <span id="trip_g">—</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== CST CLOCK PANEL ===== -->
  <div class="panel">
    <h2>CST Clock Panel — UTC • CST • Ship Warp Clock</h2>
    <div class="time-box">
      <div class="time-row">
        <span class="time-label">UTC Atomic</span>
        <span class="time-value" id="clk_utc">--:--:--</span>
      </div>
      <div class="time-row">
        <span class="time-label">CST (Observer)</span>
        <span class="time-value" id="clk_cst">--:--:--</span>
      </div>
      <div class="time-row">
        <span class="time-label">Ship Warp Clock</span>
        <span class="time-value" id="clk_warp">--:--:--</span>
      </div>
      <div class="time-row">
        <span class="time-label">Accumulated ΔAge (CST − Ship)</span>
        <span class="time-value" id="clk_delta">0.0 s</span>
      </div>
    </div>
  </div>

  <!-- ===== SCIENTIFIC ENHANCEMENTS FOR THE INTERSTELLAR STAR CLOCK ===== -->
  <div class="panel">
    <h2>Scientific Enhancements for the Interstellar Star Clock & Warp Drive</h2>
    <p class="note">
      These equations sit behind the CST clock and warp navigation. They convert poetry into physics while keeping your
      bold vision intact — time slippage, star coordinates, and energy gradients all feed one unified engine.
    </p>
    <h3>1. Time Dilation (Special Relativity)</h3>
    <div class="eq">Δt' = Δt × √(1 - v² / c²)</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> Used to adjust ship proper time vs CST when plasma streams move at a fraction of <em>c</em> inside the engine.</li>
      <li><strong>Navigation:</strong> High-velocity segments of a jump arc show reduced proper time; CST keeps the crew anchored to the master cosmic clock.</li>
    </ul>

    <h3>2. Gravitational Time Dilation (General Relativity)</h3>
    <div class="eq">Δt' = Δt × √(1 - 2GM / (r c²))</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> Used when the ship operates near stars, planets, or compact objects; CST compensates for slower clocks in deeper wells.</li>
      <li><strong>Warp control:</strong> The engine avoids curvature regimes where GR plus warp geometry could create unstable CTC-like loops.</li>
    </ul>

    <h3>3. Star Coordinate Mapping (RA / Dec → 3D)</h3>
    <div class="eq">
      x = cos(δ) × cos(α),&nbsp;
      y = cos(δ) × sin(α),&nbsp;
      z = sin(δ)
    </div>
    <ul class="list">
      <li><strong>Star clock:</strong> Anchors each star to a fixed direction on the celestial sphere at a given epoch.</li>
      <li><strong>Warp navigation:</strong> Converts RA/Dec into a 3D target vector for the FTL jump planner; the CST engine rides curvature along that vector.</li>
    </ul>

    <h3>4. Sidereal Clock Adjustment</h3>
    <div class="eq">Sidereal Day = 23h 56m 4.1s</div>
    <ul class="list">
      <li><strong>Clock layer:</strong> The CST clock keeps both solar time and sidereal time; over years, the tiny offset accumulates into real star drift.</li>
      <li><strong>Warp navigation:</strong> Corrects star positions for drift since J2000 so the RA/Dec map stays aligned over long deep-time jumps.</li>
    </ul>

    <h3>5. Light-Time Correction</h3>
    <div class="eq">t = d / c</div>
    <ul class="list">
      <li><strong>Star clock:</strong> Shows how “old” the light is from each star; your constellations become time-delayed snapshots.</li>
      <li><strong>Warp comms:</strong> Compares conventional light-time to instantaneous entanglement or warp-burst signals in your communication panels.</li>
    </ul>

    <h3>6. Stefan–Boltzmann Law (Radiative Heat from Coils & Panels)</h3>
    <div class="eq">F = σ T⁴</div>
    <ul class="list">
      <li><strong>Engine core:</strong> Predicts heat flux from hot coils, plasma chambers, and gradient panels as a function of temperature.</li>
      <li><strong>Safety / Shield mix:</strong> When radiative flux approaches structural limits, the controller shifts energy from warp geometry into cooling and shielding.</li>
      <li><strong>Telemetry:</strong> The “Core Temp” and “Coolant Temp” readouts conceptually trace back to this T⁴ scaling.</li>
    </ul>

    <h3>7. Hamiltonian Operator (Energy of the Warp Field)</h3>
    <div class="eq">Ĥ ψ = E ψ</div>
    <ul class="list">
      <li><strong>Field layer:</strong> Treats the warp shell and vacuum modes as a quantum system with a Hamiltonian that encodes all energy terms (plasma, EM, vacuum).</li>
      <li><strong>Gradient design:</strong> By choosing a Hamiltonian with stable eigenmodes, you bias the engine toward field configurations that maintain a smooth bubble.</li>
      <li><strong>CST integration:</strong> The CST clock can be thought of as following the phase evolution of the warp state vector over long-duration missions.</li>
    </ul>

    <h3>8. Wave Equation (Propagation of Warp & Shield Fields)</h3>
    <div class="eq">∂²ψ/∂t² = c² ∇²ψ  &nbsp; (classical form)</div>
    <ul class="list">
      <li><strong>Field geometry:</strong> Describes how disturbances in EM, plasma, and vacuum modes propagate through the warp shell.</li>
      <li><strong>Gradient control:</strong> The controller uses an internal wave model so pulses launched by the coils arrive in phase at the front vs rear shell.</li>
      <li><strong>Shield shaping:</strong> Radiation and particle shielding are engineered as standing-wave solutions that wrap the hull in a stable harmonic envelope.</li>
    </ul>

    <p class="note">
      Together, these equations let the Interstellar Star Clock do more than tell time: it <em>predicts</em> how time, energy, and geometry interact.
      Your warp engine sits on top of this clock, using CST to keep energy gradients, curvature, and crew experience in sync.
      The <strong>E ⇌ m zones</strong> inside the engine are: (1) the nuclear mass core (m → E) and (2) the hull conversion shell (E → m effective mass around the ship).
    </p>
  </div>
  <!-- ===== ENGINE + TELEMETRY + WARP TRIP SCRIPT ===== -->
  <script>
const TAU = Math.PI*2;
const lerp=(a,b,t)=>a+(b-a)*t;
function drawText(ctx, s, x, y, align){
  ctx.fillStyle='#eaf0ff';
  ctx.textAlign=align||'left';
  ctx.textBaseline='middle';
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillText(s,x,y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function fmt(n,dec){ return n.toFixed(dec||0); }
function fmtLarge(n){
  var a=Math.abs(n);
  if(a>=1e12) return (n/1e12).toFixed(2)+' T';
  if(a>=1e9)  return (n/1e9 ).toFixed(2)+' G';
  if(a>=1e6)  return (n/1e6 ).toFixed(2)+' M';
  if(a>=1e3)  return (n/1e3 ).toFixed(1)+' K';
  return n.toFixed(0);
}
function formatDuration(seconds){
  if(seconds < 120) return seconds.toFixed(1)+' s';
  const minutes = seconds/60;
  if(minutes < 120) return minutes.toFixed(1)+' min';
  const hours = minutes/60;
  if(hours < 48) return hours.toFixed(2)+' h';
  const days = hours/24;
  return days.toFixed(2)+' d';
}

// ===== Physics helpers with timing =====
function computeSpeedMult(w){ return lerp(1, 6, (w-1)/9); }
function computeFieldRadius(w){ return lerp(1.2, 2.6, (w-1)/9); }
function computeHeatLevel(w){ return lerp(0.35, 1.0, (w-1)/9); }
function computeCoolLevel(w){ return 1 - computeHeatLevel(w)*0.5; }
function computePlasmaLength(w){ return Math.round( lerp(90, 260, (w-1)/9) ); }
function computePlasmaRadius(w){ return Math.round( lerp(10, 36, (w-1)/9) ); }
function computeEntangleRate(w){ return lerp(0.6, 3.2, (w-1)/9); }
function computeFieldAspectX(w){ return lerp(1.0, 1.9, (w-1)/9); }
function computeFieldAspectY(w){ return lerp(0.9, 0.6, (w-1)/9); }
function computeStability(w){
  var s = 1 - (w-1)/12;
  if(s<0.55) s=0.55;
  return s;
}

// SR local plasma speed fraction
function localSpeedFrac(w){
  return clamp(0.2 + 0.08*(w-1), 0.2, 0.92);
}
function gammaSR(w){
  const v = localSpeedFrac(w);
  return 1/Math.sqrt(1-v*v);
}
function gammaGR_regime(reg){
  if(reg === 'earth') return 1.0000000003;
  if(reg === 'sun')   return 1.0000020;
  if(reg === 'deep')  return 1.0;
  return 1.0;
}
function combinedClockRate(w, reg){
  const warpScale = lerp(1, 1.6, (w-1)/9);
  const gSR = gammaSR(w);
  const gGR = gammaGR_regime(reg);
  const rate = 1/(warpScale * gSR * gGR);
  return rate;
}

// Temps
function computeCoreTempC(w){ return Math.round( 200 + computeHeatLevel(w)*1000 + computeSpeedMult(w)*40 ); }
function computeCoolantTempC(w){ return Math.round( 25 + computeCoolLevel(w)*300 ); }

// ===== Planet table (AU from Sun; Earth=1.0 AU launch point) =====
const PLANETS = {
  mercury:{name:'Mercury', au:0.39},
  venus  :{name:'Venus',   au:0.72},
  earth  :{name:'Earth',   au:1.00},
  mars   :{name:'Mars',    au:1.52},
  jupiter:{name:'Jupiter', au:5.20},
  saturn :{name:'Saturn',  au:9.58},
  uranus :{name:'Uranus',  au:19.2},
  neptune:{name:'Neptune', au:30.1},
  pluto  :{name:'Pluto',   au:39.5}
};
const AU_METERS = 1.495978707e11;
const C = 299792458;

// ===== Layout (ENGINE SHIFTED LEFT) =====
const layout = {
  centerY: 450,
  startX: 40,
  length: 900,
  bodyR: 120,
  fanX: 70,
  stages: [
    {len:160, r:120, name:'Intake / Pre-Compression'},
    {len:120, r:112, name:'Compression Stage A'},
    {len:100, r:104, name:'Compression Stage B'},
    {len: 80, r: 96, name:'Compression Stage C'},
    {len: 70, r: 88, name:'Warp Coils / Field Shapers'},
    {len: 70, r: 80, name:'Reactors (Electro-Plasma / Nuclear Mass Core)'},
    {len: 60, r: 72, name:'Photon/Plasma Mixer'},
    {len: 50, r: 64, name:'Nozzle Coupler'}
  ],
  nozzle:{len:160, r0:60, r1:14, name:'Exhaust Nozzle'},
  coils:[{xOff:-18, name:'Field Coil L'},{xOff:36, name:'Field Coil R'}]
};
let xx=layout.startX;
layout.stages = layout.stages.map(function(s){
  var out={x0:xx,x1:xx+s.len,len:s.len,r:s.r,name:s.name};
  xx+=s.len; return out;
});
layout.nozzle.x0 = xx;
layout.nozzle.x1 = xx + layout.nozzle.len;

// ===== State =====
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let running = true;
let t0 = performance.now();
let fanAngle = 0;
let fps = 60;

// Warp setting — dynamically controlled by trip animation
let warpSetting = 1;

// dilation clocks
let warpClock = Date.now();
let ageDeltaAccumMs = 0;

// particle arrays
let particles = [], heat = [], cool = [], entangle = [], pipes = [];

// Controls (labels toggle)
const labelsEl = document.getElementById('labels');

// Telemetry DOM
const v_speed=document.getElementById('v_speed'), g_speed=document.getElementById('g_speed');
const v_field=document.getElementById('v_field'), g_field=document.getElementById('g_field');
const v_fshield=document.getElementById('v_fshield'), g_fshield=document.getElementById('g_fshield');
const v_fstretch=document.getElementById('v_fstretch'), g_fstretch=document.getElementById('g_fstretch');

const v_gradFR=document.getElementById('v_gradFR'), g_gradFR=document.getElementById('g_gradFR');
const v_gradLR=document.getElementById('v_gradLR'), g_gradLR=document.getElementById('g_gradLR');
const v_gradWS=document.getElementById('v_gradWS'), g_gradWS=document.getElementById('g_gradWS');

const v_clock=document.getElementById('v_clock'), g_clock=document.getElementById('g_clock');
const v_phot=document.getElementById('v_phot'), g_phot=document.getElementById('g_phot');
const v_mag=document.getElementById('v_mag'), g_mag=document.getElementById('g_mag');
const v_tcore=document.getElementById('v_tcore'), g_tcore=document.getElementById('g_tcore');
const v_tcool=document.getElementById('v_tcool'), g_tcool=document.getElementById('g_tcool');
const v_ent=document.getElementById('v_ent'), g_ent=document.getElementById('g_ent');
const v_plen=document.getElementById('v_plen'), g_plen=document.getElementById('g_plen');
const v_prad=document.getElementById('v_prad'), g_prad=document.getElementById('g_prad');
const v_pwave=document.getElementById('v_pwave'), g_pwave=document.getElementById('g_pwave');

// Clocks DOM
const clkUTC=document.getElementById('clk_utc');
const clkCST=document.getElementById('clk_cst');
const clkWarpEl=document.getElementById('clk_warp');
const clkDelta=document.getElementById('clk_delta');

// Warp trip planner DOM
const targetEl = document.getElementById('wp_target');
const warpSelectEl = document.getElementById('wp_warp');
const btnPlan = document.getElementById('btn_plan');
const btnReset = document.getElementById('btn_reset');
const btnWarp = document.getElementById('btn_warp');
const goBubble = document.getElementById('goBubble');
const wpStatus = document.getElementById('wp_status');

const tripDistEl = document.getElementById('trip_dist');
const tripCoordEl = document.getElementById('trip_coord');
const tripShipEl = document.getElementById('trip_ship');
const tripAgeEl = document.getElementById('trip_age');
const tripSpeedEl = document.getElementById('trip_speed');
const tripCurvEl = document.getElementById('trip_curv');
const tripGEl = document.getElementById('trip_g');

// Trip simulation state
let lastTripResult = null;
let tripActive = false;
let tripProgress = 0;
let tripDurationMs = 10000;
let tripWarpFactor = 1;

// Helpers bound to warpSetting
function warpFactor(){ return warpSetting; }
function speedMult(){ return computeSpeedMult(warpFactor()); }
function fieldRadius(){ return computeFieldRadius(warpFactor()); }
function heatLevel(){ return computeHeatLevel(warpFactor()); }
function coolLevel(){ return computeCoolLevel(warpFactor()); }

// gradient helpers now fixed (no manual sliders)
function gradFrontRear(){ return 1.0; }
function gradLeftRight(){ return 0.0; }
function gradWarpShield(){ return 0.5; }

// ===== Streams & Pipes =====
function spawnParticle(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.6;
  var x0 = layout.startX+10;
  var v = 0.6 + Math.random()*0.7;
  particles.push({x:x0,y:y,v:v,life:0});
}
function spawnHeat(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.4;
  var xh = layout.stages[4].x0 + Math.random()*(layout.nozzle.x1 - layout.stages[4].x0);
  heat.push({x:xh,y:y,life:0});
}
function spawnCool(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.7;
  var xc = layout.stages[0].x0 + Math.random()*(layout.stages[2].x1-layout.stages[0].x0);
  cool.push({x:xc,y:y,life:0});
}
function spawnEntangle(){
  var baseX = layout.stages[5].x0 + Math.random()*40;
  var phase = Math.random()*TAU;
  entangle.push({x:baseX, y:layout.centerY, phase:phase, life:0});
}
function initPipes(){
  pipes = [];
  for(var i=0;i<layout.stages.length-1;i++){
    var s = layout.stages[i];
    var nx = s.x1;
    pipes.push({x0:nx-6,y0:layout.centerY+28,x1:nx+6,y1:layout.centerY+28,phase:Math.random()*TAU});
  }
}
initPipes();

// ===== Draw helpers =====
function drawCylinder(x0,x1,rTop,rBot){
  var grd = ctx.createLinearGradient(0, layout.centerY-rTop, 0, layout.centerY+rBot);
  grd.addColorStop(0, '#2a334d');
  grd.addColorStop(0.5,'#9fb1ff22');
  grd.addColorStop(1, '#0e132b');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY + rBot);
  ctx.lineTo(x0, layout.centerY + rBot);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.strokeStyle = '#cfe2ff33';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x1, layout.centerY-rTop);
  ctx.lineTo(x1, layout.centerY+rBot);
  ctx.stroke();
}
function drawNozzle(nz){
  var x0=nz.x0,x1=nz.x1,r0=nz.r0,r1=nz.r1;
  var grd = ctx.createLinearGradient(x0,layout.centerY,x1,layout.centerY);
  grd.addColorStop(0,'#2a334d');
  grd.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - r0);
  ctx.lineTo(x1, layout.centerY - r1);
  ctx.lineTo(x1, layout.centerY + r1);
  ctx.lineTo(x0, layout.centerY + r0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
}
function drawCoil(xOff){
  var x = layout.startX + xOff;
  ctx.strokeStyle='#a6b8ffaa';
  ctx.lineWidth=8;
  ctx.beginPath();
  ctx.moveTo(x, layout.centerY-48);
  ctx.lineTo(x, layout.centerY+48);
  ctx.stroke();
  ctx.lineWidth=3;
  ctx.strokeStyle='#5ea8ffaa';
  for(var i=-3;i<=3;i++){
    ctx.beginPath();
    ctx.arc(x, layout.centerY + i*12, 22+Math.abs(i)*2, 0, TAU);
    ctx.stroke();
  }
}
function drawFan(angle){
  var cx = layout.fanX, cy = layout.centerY;
  ctx.fillStyle='#a4b2d8';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, TAU);
  ctx.fill();
  for(var i=0;i<6;i++){
    var a = angle + i*TAU/6;
    var r1=14, r2=52;
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath();
    ctx.fill();
  }
}

// Nuclear mass core + E ⇌ m hull conversion shell
function drawShieldPlatesAndCore(){
  var reactorStage = layout.stages[5];
  var coreX = (reactorStage.x0 + reactorStage.x1)/2;
  var coreY = layout.centerY;
  var coreR = 26;

  ctx.beginPath();
  ctx.fillStyle='#f5f0c8';
  ctx.arc(coreX, coreY, coreR, 0, TAU);
  ctx.fill();
  ctx.strokeStyle='#d0c86b';
  ctx.lineWidth=2;
  ctx.stroke();

  ctx.fillStyle='#11131a';
  ctx.font='10px system-ui,Segoe UI,Roboto,Arial';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText('E=mc²', coreX, coreY-6);
  ctx.fillText('m=E/c²', coreX, coreY+6);

  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=3;
  var plateOffset = layout.bodyR + 16;
  for(var i=-1;i<=1;i++){
    var dy = plateOffset + i*12;
    ctx.beginPath();
    ctx.ellipse(coreX, coreY - dy, 110, 12, 0, 0, Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(coreX, coreY + dy, 110, 12, 0, Math.PI, 0);
    ctx.stroke();
  }

  ctx.strokeStyle='#ffcc66aa';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(coreX+coreR, coreY);
  ctx.lineTo(coreX+coreR+34, coreY-34);
  ctx.lineTo(coreX+coreR+80, coreY-34);
  ctx.stroke();
}

// field uses gradient trim
function drawField(){
  var D = layout.bodyR*2;
  var base = fieldRadius()*D*0.35;
  var ax = computeFieldAspectX(warpFactor());
  var ay = computeFieldAspectY(warpFactor());

  var gFR = gradFrontRear();
  var gLR = gradLeftRight();

  ctx.strokeStyle='#33e1b588';
  ctx.lineWidth=2;

  var cx = layout.startX+layout.length*0.65 + gLR*40;

  for(var i=0;i<6;i++){
    var rx = base*ax + i*22;
    var ry = base*ay + i*10;

    var frontBias = 1 + (gFR-1)*0.6;
    var localCx   = cx + (i-2)*4*(gFR-1);

    ctx.beginPath();
    ctx.ellipse(localCx, layout.centerY, rx*frontBias, ry, 0, 0, TAU);
    ctx.stroke();
  }
}

function drawTimeLegendLeft(){
  var x=20;
  var y=120;
  var lines=[
    'UTC Atomic',
    'CST (engine)',
    'Interstellar CST',
    'Universal Time',
    'UTA'
  ];
  for(var i=0;i<lines.length;i++){
    drawText(ctx, lines[i], x, y+i*20, 'left');
  }
}
function drawCSTClock(){
  var x = layout.stages[3].x0+12;
  var y = layout.centerY-22;
  ctx.fillStyle='#0e1536';
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.fillRect(x,y,150,32);
  ctx.strokeRect(x,y,150,32);
  drawText(ctx,'Atomic Clock (CST)', x+6, y+16, 'left');
}
function drawStatusLabel(){
  var x = layout.nozzle.x0-40;
  var y = layout.centerY- layout.bodyR - 58;
  var warp = warpFactor();
  var stab = computeStability(warp);
  var s = 'Warp '+warp.toFixed(1)+' | Stability '+stab.toFixed(2);
  drawText(ctx, s, x, y, 'left');
}
function labelFromTo(text, ax, ay, tx, ty){
  ctx.strokeStyle='#9bb4ff66';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(ax,ay);
  ctx.lineTo(tx,ty);
  ctx.stroke();
  drawText(ctx, text, tx+4, ty, 'left');
}

// Labels
function drawLabels(){
  const topY = layout.centerY - layout.bodyR - 42;
  const botY = layout.centerY + layout.bodyR + 44;

  const s0=layout.stages[0], s1=layout.stages[1], s2=layout.stages[2],
        s3=layout.stages[3], s4=layout.stages[4], s5=layout.stages[5],
        s6=layout.stages[6];

  labelFromTo('Vacuum Intake', s0.x0+12, layout.centerY- s0.r, s0.x0-40, topY-4);
  labelFromTo('Magnetic Fan (negative-energy modulator)', layout.fanX, layout.centerY-34, s0.x0-20, topY+16);
  labelFromTo('Modulates Vacuum Air Circulation', s1.x0+6, layout.centerY- s1.r, s1.x0+20, topY+38);
  labelFromTo('Compression A/B/C Stages', s2.x1-10, layout.centerY- s2.r, s2.x0+40, topY+60);
  labelFromTo('Vacuum Fluctuation Modulator', s4.x0+6, layout.centerY- s4.r, s4.x0-10, topY+82);
  labelFromTo('Reactors (Mass–Energy Core)', s5.x0+10, layout.centerY- s5.r, s5.x0+120, topY+104);
  labelFromTo('Photon/Plasma Mixer', s6.x0+10, layout.centerY- s6.r, s6.x0+180, topY+126);

  const coreX = (s5.x0 + s5.x1)/2;
  labelFromTo('E ⇌ m Conversion Core (E=mc² / m=E/c²)', coreX, layout.centerY, coreX-80, topY+148);
  const cxField = layout.startX+layout.length*0.65;
  labelFromTo('Hull Conversion Shell (E → m effective mass around hull)', cxField, layout.centerY+ computeFieldRadius(warpFactor())*layout.bodyR*0.35+8, cxField+110, botY+250);

  labelFromTo('Entanglement Feedback Loop', s5.x0+24, layout.centerY+16, s5.x0-20, botY+8);
  labelFromTo('Atomic Clocks (CST) + Entangled Feedback', s3.x0+20, layout.centerY, s3.x0-40, botY+32);
  labelFromTo('Pulse Control Panel', s4.x1-8, layout.centerY+8, s4.x1+40, botY+56);
  labelFromTo('AFT Power Ramp', layout.nozzle.x0-10, layout.centerY+6, layout.nozzle.x0+40, botY+80);
  labelFromTo('AFT Power Ramp (Gradual / Safe)', layout.nozzle.x0+20, layout.centerY+22, layout.nozzle.x0+150, botY+104);
  labelFromTo('Gravitational Stabilization Panel', s2.x0+20, layout.centerY+ s2.r, s2.x0-20, botY+128);
  labelFromTo('Quantum Vertex Dampers (F/R/U/D/L/R)', s4.x0+20, layout.centerY+ s4.r, s4.x0+140, botY+152);
  labelFromTo('Detection Lasers (particles)', s1.x1-10, layout.centerY+ s1.r, s1.x1+110, botY+176);
  labelFromTo('Thermal Management (Water Cooling)', s5.x1-8, layout.centerY+ s5.r, s5.x1+160, botY+200);

  labelFromTo('ZPF Oscillator Rings (ZPO)', s4.x0+12, layout.centerY- s4.r+10, s4.x0-100, topY+170);
  labelFromTo('Casimir Microarrays', s3.x1-6, layout.centerY- s3.r+6, s3.x1+28, topY+192);
  labelFromTo('Tachyon Feedback Node', s5.x0+6, layout.centerY+12, s5.x0-120, botY+224);
  labelFromTo('CTC Guard (CST Damping)', s3.x0+8, layout.centerY+8, s3.x0-140, botY+248);
  labelFromTo('Positron Diagnostic Port', s6.x1-6, layout.centerY- s6.r+6, s6.x1+70, topY+214);
  labelFromTo('Limestone–Granite Resonator', s0.x0+20, layout.centerY+ s0.r-8, s0.x0-140, botY+272);

  labelFromTo('Temporal vs Spatial Warp (rx/ry vs clock)', cxField, layout.centerY - computeFieldRadius(warpFactor())*layout.bodyR*0.35 - 22, cxField-160, topY-18);
  labelFromTo('Exotic-Matter Bypass (EM stress / Casimir)', s4.x1-6, layout.centerY+ s4.r-10, s4.x1+60, botY+224);

  labelFromTo('Forward Gradient Panel (Contraction Field)', s4.x0+40, layout.centerY- s4.r-6, s4.x0+110, topY-24);
  labelFromTo('Aft Gradient Panel (Expansion Dump)', layout.nozzle.x0+40, layout.centerY+ layout.nozzle.r0, layout.nozzle.x0+170, botY+296);
}

function drawCoreGlow(){
  var g = ctx.createLinearGradient(layout.startX, layout.centerY, layout.nozzle.x1, layout.centerY);
  g.addColorStop(0,'#a9bbff00');
  g.addColorStop(0.4,'#9bb4ff22');
  g.addColorStop(0.8,'#eaf0ff44');
  ctx.fillStyle=g;
  ctx.fillRect(layout.startX, layout.centerY-12, layout.nozzle.x1-layout.startX, 24);
}
function drawPlasmaCone(){
  var len = computePlasmaLength(warpFactor());
  var baseR = computePlasmaRadius(warpFactor());
  var x0 = layout.nozzle.x1;
  var x1 = x0 + len;
  var grad = ctx.createLinearGradient(x0, layout.centerY, x1, layout.centerY);
  grad.addColorStop(0, 'rgba(255,220,168,0.65)');
  grad.addColorStop(0.3, 'rgba(255,220,168,0.35)');
  grad.addColorStop(1, 'rgba(255,220,168,0.02)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - baseR);
  ctx.lineTo(x1, layout.centerY - baseR*0.35);
  ctx.lineTo(x1, layout.centerY + baseR*0.35);
  ctx.lineTo(x0, layout.centerY + baseR);
  ctx.closePath();
  ctx.fill();
}
function drawPipes(){
  for(var i=0;i<pipes.length;i++){
    var p = pipes[i];
    ctx.strokeStyle='#6bd1ff';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x0,p.y0);
    ctx.lineTo(p.x1,p.y1);
    ctx.stroke();
    var n=4;
    for(var k=0;k<n;k++){
      var t = ((k/n) + (performance.now()*0.0005) ) % 1;
      var xx = p.x0 + (p.x1-p.x0)*t;
      var yy = p.y0 + (p.y1-p.y0)*t;
      ctx.fillStyle='#9bb4ff';
      ctx.beginPath();
      ctx.arc(xx, yy, 2, 0, TAU);
      ctx.fill();
    }
  }
}
function drawCoolingLoops(){
  var y = layout.centerY + layout.bodyR - 16;
  ctx.strokeStyle='#6bd1ff';
  ctx.lineWidth=2;
  ctx.beginPath();
  var x0 = layout.startX+10;
  ctx.moveTo(x0,y);
  for(var x1 = x0; x1 < layout.nozzle.x0-10; x1 += 32){
    ctx.lineTo(x1+16, y+6);
    ctx.lineTo(x1+32, y);
  }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=1;
  var cxF = layout.startX - 10;
  var cxR = layout.nozzle.x1 + 20;
  var cy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(cxF, cy-44); ctx.lineTo(cxF-34, cy-44);
  ctx.moveTo(cxF, cy+44); ctx.lineTo(cxF-34, cy+44);
  ctx.moveTo(cxR, cy-34); ctx.lineTo(cxR+34, cy-34);
  ctx.moveTo(cxR, cy+34); ctx.lineTo(cxR+34, cy+34);
  ctx.stroke();

  var ccx = layout.startX+layout.length*0.65;
  var ccy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(ccx-16, ccy); ctx.lineTo(ccx+16, ccy);
  ctx.moveTo(ccx, ccy-16); ctx.lineTo(ccx, ccy+16);
  ctx.stroke();
}

// ===== Telemetry Update =====
function setGauge(span, frac){ span.style.width = (clamp(frac,0,1)*100).toFixed(0)+'%'; }
function updateTelemetry(dt){
  var w  = warpFactor();
  var sm = speedMult();
  var fr = fieldRadius();
  var hl = heatLevel();
  var cl = coolLevel();

  var instFps = (dt>0)? 1000/dt : 60;
  fps = fps*0.9 + instFps*0.1;

  var vLocal = localSpeedFrac(w);
  var gSR = gammaSR(w);
  var gGR = gammaGR_regime('sun');
  var effClockRate = combinedClockRate(w,'sun');

  var p_phot = 0.7*sm;
  var p_ent  = 0.25*computeEntangleRate(w);
  var pWave  = (0.2*sm);

  var perSec = function(p){ return p * fps; };
  var mag = fr*sm;

  var gFR = gradFrontRear();
  var gLR = gradLeftRight();
  var gWS = gradWarpShield();

  var D = layout.bodyR*2;
  var base = fr*D*0.35;
  var ax = computeFieldAspectX(w);
  var ay = computeFieldAspectY(w);
  var rx = base*ax + 2*22;
  var ry = base*ay + 2*10;

  var coreC = computeCoreTempC(w);
  var coolC = computeCoolantTempC(w);

  if(v_speed){ v_speed.textContent = 'x'+sm.toFixed(1); setGauge(g_speed, (sm-1)/(6-1)); }
  if(v_field){ v_field.textContent = fr.toFixed(2); setGauge(g_field, (fr-1.2)/(2.6-1.2)); }

  var shieldFracRaw = (fr-1.2)/(2.6-1.2);
  var shieldFrac    = clamp(shieldFracRaw + (1-gWS)*0.3,0,1);

  if(v_fshield){ v_fshield.textContent = Math.round(shieldFrac*100)+'%'; setGauge(g_fshield, shieldFrac); }
  if(v_fstretch){ v_fstretch.textContent = fmt(rx,0)+' / '+fmt(ry,0); setGauge(g_fstretch, clamp(rx/(base*1.9+2*22),0,1)); }

  if(v_gradFR){ v_gradFR.textContent = gFR.toFixed(2)+'×'; setGauge(g_gradFR, clamp(Math.abs(gFR-1)/0.3,0,1)); }
  if(v_gradLR){ v_gradLR.textContent = (gLR>=0?'+':'')+gLR.toFixed(2); setGauge(g_gradLR, Math.abs(gLR)/0.3); }
  if(v_gradWS){
    var warpPct   = Math.round(gWS*100);
    var shieldPct = 100-warpPct;
    v_gradWS.textContent = warpPct+'% warp / '+shieldPct+'% shield';
    setGauge(g_gradWS, gWS);
  }

  if(v_clock){ v_clock.textContent = effClockRate.toFixed(3)+'×'; setGauge(g_clock, 1-effClockRate); }
  if(v_phot){ v_phot.textContent = fmtLarge(perSec(p_phot))+' /s'; setGauge(g_phot, Math.min(perSec(p_phot)/3000,1)); }
  if(v_mag){ v_mag.textContent = mag.toFixed(2); setGauge(g_mag, Math.min(mag/6.0,1)); }

  if(v_tcore){ v_tcore.textContent = coreC+' °C'; setGauge(g_tcore, Math.min(coreC/1500,1)); }
  if(v_tcool){ v_tcool.textContent = coolC+' °C'; setGauge(g_tcool, Math.min(coolC/400,1)); }

  var entPerSec = perSec(p_ent);
  var entScaled = entPerSec>=1e9? (entPerSec/1e9).toFixed(2)+' G/s'
                 : entPerSec>=1e6? (entPerSec/1e6).toFixed(2)+' M/s'
                 : Math.round(entPerSec)+' /s';
  if(v_ent){ v_ent.textContent = entScaled; setGauge(g_ent, Math.min(entPerSec/3.2e6,1)); }

  var plen = computePlasmaLength(w); if(v_plen){ v_plen.textContent = plen+' u'; setGauge(g_plen, (plen-90)/(260-90)); }
  var prad = computePlasmaRadius(w); if(v_prad){ v_prad.textContent = prad+' u'; setGauge(g_prad, (prad-10)/(36-10)); }
  if(v_pwave){ v_pwave.textContent = pWave.toFixed(2); setGauge(g_pwave, Math.min(pWave/1.2,1)); }

  // Live clocks
  var now = Date.now();
  if(clkUTC){
    clkUTC.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'UTC'});
  }
  if(clkCST){
    clkCST.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'America/Chicago'});
  }

  // Warp-adjusted proper time clock: integrate CST time scaled by effClockRate
  warpClock += dt * effClockRate;
  if(clkWarpEl){
    clkWarpEl.textContent = new Date(warpClock).toLocaleTimeString('en-US',{hour12:false});
  }
  // Accumulated age difference (CST - ship) in ms
  ageDeltaAccumMs += dt*(1-effClockRate);
  if(clkDelta){
    clkDelta.textContent = (ageDeltaAccumMs/1000).toFixed(2)+' s';
  }
}

// ===== Warp Trip Planner Physics =====
function computeTrip(){
  const targetKey = targetEl.value;
  const warpSel = parseInt(warpSelectEl.value,10) || 1;
  const target = PLANETS[targetKey];

  const rEarth = PLANETS.earth.au;
  const distAU = Math.abs(target.au - rEarth);   // simple radial estimate Earth→planet
  const distMeters = distAU * AU_METERS;
  const distKm = distMeters / 1000;
  const distLightSeconds = distMeters / C;

  const w = warpSel;
  const vLocal = localSpeedFrac(w);              // local plasma speed (units of c)
  const gSR = gammaSR(w);
  const gGR = gammaGR_regime('sun');

  const vApp = w * vLocal;                       // apparent warp speed in units of c

  // Coordinate CST time (seconds) — distance / (v_app * c)
  const coordSeconds = distLightSeconds / (vApp > 0 ? vApp : 1);

  // Ship proper time (seconds) under SR·GR
  const shipSeconds = coordSeconds / (gSR*gGR);
  const deltaAgeSeconds = coordSeconds - shipSeconds;

  // Curvature index: how strongly we bend spacetime for this run
  const curvatureIndex = distAU * w;

  // Approx g-force: assume ramp-up over 20% of CST time, from 0 to vLocal*c
  const rampFrac = 0.2;
  const rampTime = coordSeconds * rampFrac || 1;
  const accel = vLocal*C / rampTime;            // m/s²
  const gForce = accel / 9.81;

  // Animation duration mapping [60 s, 24 h] CST to [8 s, 25 s] display
  const minPhys = 60;
  const maxPhys = 24*3600;
  const clamped = clamp(coordSeconds, minPhys, maxPhys);
  const minDurMs = 8000;
  const maxDurMs = 25000;
  const norm = (clamped - minPhys) / (maxPhys - minPhys);
  const animMs = minDurMs + norm*(maxDurMs - minDurMs);

  // Safety criteria for GO / NO-GO bubble
  const safeGamma = gSR < 2.0;
  const safeG = gForce <= 3.0;                  // ~3 g comfort-ish
  const safeAge = deltaAgeSeconds < 60;         // less than 1 minute age gap
  const safeCurv = curvatureIndex < 400;        // arbitrary curvature safety cap
  const isSafe = safeGamma && safeG && safeAge && safeCurv;

  // Update text report
  tripDistEl.textContent =
    distAU.toFixed(3)+' AU  ≈ '+fmtLarge(distKm)+' km  (light-time '+distLightSeconds.toFixed(1)+' s)';
  tripCoordEl.textContent = formatDuration(coordSeconds);
  tripShipEl.textContent  = formatDuration(shipSeconds);
  tripAgeEl.textContent   = deltaAgeSeconds.toFixed(3)+' s (CST ahead of ship)';
  tripSpeedEl.textContent = 'v_app ≈ '+vApp.toFixed(2)+' c,  v_local ≈ '+vLocal.toFixed(2)+' c';
  tripCurvEl.textContent  = curvatureIndex.toFixed(2)+' (AU × Warp)';
  tripGEl.textContent     = gForce.toFixed(2)+' g';

  // Update GO/NO-GO bubble
  if(isSafe){
    goBubble.classList.remove('no');
    goBubble.textContent = 'SAFE\nGO';
    wpStatus.textContent =
      'GO — curvature, g-force, and dilation in safe band. Press “Engage Warp” to run animated trip Earth → '+target.name+'.';
  }else{
    goBubble.classList.add('no');
    goBubble.textContent = 'NO-GO';
    wpStatus.textContent =
      'NO-GO — one or more limits exceeded (g, gamma, age, curvature). Adjust warp or pick a closer planet, then recompute.';
  }

  // Enable / disable warp button
  btnWarp.disabled = !isSafe;

  return {
    targetKey,
    warp: w,
    distAU,
    distMeters,
    distKm,
    distLightSeconds,
    coordSeconds,
    shipSeconds,
    deltaAgeSeconds,
    vLocal,
    vApp,
    curvatureIndex,
    gForce,
    animDurationMs: animMs,
    safe: isSafe
  };
}

// ===== Trip animation control (button 5) =====
btnPlan.addEventListener('click', ()=>{
  lastTripResult = computeTrip();
});

btnWarp.addEventListener('click', ()=>{
  if(!lastTripResult || !lastTripResult.safe) return;
  // Start warp animation: engine ramps up, holds, ramps down
  tripActive = true;
  tripProgress = 0;
  tripDurationMs = lastTripResult.animDurationMs;
  tripWarpFactor = lastTripResult.warp;
  wpStatus.textContent = 'Warp in progress — engine ramping up, holding, then ramping down while ship travels Earth → '+PLANETS[lastTripResult.targetKey].name+'.';
  btnWarp.disabled = true;
});

btnReset.addEventListener('click', ()=>{
  targetEl.value = 'mars';
  warpSelectEl.value = '4';
  tripActive = false;
  tripProgress = 0;
  tripWarpFactor = 1;
  warpSetting = 1;
  lastTripResult = null;
  goBubble.classList.remove('no');
  goBubble.textContent = 'SAFE\nGO';
  wpStatus.textContent = 'Idle — select planet + warp, then press “Compute Warp Trip”.';

  tripDistEl.textContent  = '—';
  tripCoordEl.textContent = '—';
  tripShipEl.textContent  = '—';
  tripAgeEl.textContent   = '—';
  tripSpeedEl.textContent = '—';
  tripCurvEl.textContent  = '—';
  tripGEl.textContent     = '—';

  ageDeltaAccumMs = 0;
  warpClock = Date.now();
});

// ===== Render Loop =====
function render(dt){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawField();
  for(var i=0;i<layout.stages.length;i++){
    var s = layout.stages[i];
    drawCylinder(s.x0, s.x1, s.r, s.r);
  }
  drawNozzle(layout.nozzle);
  drawShieldPlatesAndCore();
  drawCoreGlow();
  for(var j=0;j<layout.coils.length;j++){ drawCoil(layout.coils[j].xOff); }
  drawFan(fanAngle);

  var pmult = speedMult();
  if(Math.random()<0.7*pmult) spawnParticle();
  for(var p=0;p<particles.length;p++){
    var pt = particles[p];
    pt.x += (1.9*pmult + pt.v)*1.2;
    pt.y += Math.sin((pt.x+pt.y)*0.01)*0.22*pmult;
    pt.life += dt;
  }
  particles = particles.filter(function(pt){ return pt.x < layout.nozzle.x1+560; });
  ctx.fillStyle='#9bb4ff';
  for(var q=0;q<particles.length;q++){
    ctx.globalAlpha=0.7;
    ctx.fillRect(particles[q].x, particles[q].y, 3, 2);
    ctx.globalAlpha=1;
  }

  if(Math.random()<0.25*pmult*heatLevel()) spawnHeat();
  if(Math.random()<0.25*pmult*coolLevel()) spawnCool();
  for(var h=0;h<heat.length;h++){ heat[h].life+=dt; heat[h].x+= 1.0*pmult; }
  for(var c0=0;c0<cool.length;c0++){ cool[c0].life+=dt; cool[c0].x+= 0.7*pmult; }
  heat = heat.filter(function(it){ return it.x<layout.nozzle.x1; });
  cool = cool.filter(function(it){ return it.x<layout.stages[3].x1; });
  for(var h2=0;h2<heat.length;h2++){
    ctx.fillStyle='#ffcc66';
    ctx.beginPath();
    ctx.arc(heat[h2].x,heat[h2].y,2+Math.sin(heat[h2].life*0.02)*1.5,0,TAU);
    ctx.fill();
  }
  for(var c2=0;c2<cool.length;c2++){
    ctx.fillStyle='#6bd1ff';
    ctx.beginPath();
    ctx.arc(cool[c2].x,cool[c2].y,2+Math.cos(c2*0.02)*1.2,0,TAU);
    ctx.fill();
  }

  if(Math.random()<computeEntangleRate(warpFactor())*0.25) spawnEntangle();
  for(var e=0;e<entangle.length;e++){
    var en = entangle[e];
    en.life+=dt;
    en.x += 1.2*pmult;
    var amp = 26 + 8*Math.sin(en.life*0.01);
    var wv = 0.026*pmult;
    var yy = layout.centerY + Math.sin(en.phase + en.x*wv)*amp;
    ctx.fillStyle='#b26bff';
    ctx.beginPath();
    ctx.arc(en.x, yy, 2.2, 0, TAU);
    ctx.fill();
  }
  entangle = entangle.filter(function(en){ return en.x < layout.nozzle.x1 + 300; });

  drawPlasmaCone();
  drawPipes();
  drawCoolingLoops();
  drawLasers();

  drawTimeLegendLeft();
  drawCSTClock();
  drawStatusLabel();
  if(labelsEl && labelsEl.checked) drawLabels();
}

function loop(){
  if(!running) return;
  var now = performance.now();
  var dt = now - t0;
  t0 = now;

  // Warp trip animation: ramp up → hold → ramp down warpSetting
  if(tripActive && lastTripResult){
    tripProgress += dt / tripDurationMs;
    if(tripProgress >= 1){
      tripProgress = 1;
      tripActive = false;
      warpSetting = 1;
      wpStatus.textContent = 'Warp trip complete — ship has arrived at '+PLANETS[lastTripResult.targetKey].name+'. Engine back to idle.';
    }else{
      var baseW = lastTripResult.warp;
      var t = tripProgress;
      var rampIn = 0.2;
      var rampOut = 0.8;
      var f;
      if(t < rampIn){
        f = t / rampIn;          // 0→1
      }else if(t > rampOut){
        f = (1 - t) / (1 - rampOut); // 1→0
      }else{
        f = 1;
      }
      f = clamp(f,0,1);
      warpSetting = 1 + (baseW - 1)*f;
    }
  }

  fanAngle += 0.005 * dt * speedMult();
  render(dt);
  updateTelemetry(dt);
  requestAnimationFrame(loop);
}
loop();

// ===== Self-Tests =====
(function runTests(){
  var results = [];
  function ok(name,cond){ results.push((cond?'PASS ':'FAIL ')+name); }
  ok('speed increases', computeSpeedMult(10) > computeSpeedMult(1));
  ok('field grows', computeFieldRadius(10) > computeFieldRadius(1));
  ok('plasma length grows', computePlasmaLength(10) > computePlasmaLength(1));
  ok('plasma radius grows', computePlasmaRadius(10) > computePlasmaRadius(1));
  ok('entangle rate grows', computeEntangleRate(10) > computeEntangleRate(1));
  ok('field stretches wider', computeFieldAspectX(10) > computeFieldAspectX(1));
  var el = document.getElementById('tests');
  if(el){ el.textContent = 'Self-tests: ' + results.join(' | '); }
})();
  </script>
</div> <!-- end .wrap -->
</body>
</html>
