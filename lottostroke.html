<!-- ======================= PART 1 / 2 ======================= -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>20-Ticket Tight Coach — Prize-Weighted + Dyson + Prune/Decay + Pair-Circulation</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    font-size:18px;
  }
  .wrap{max-width:1320px;margin:0 auto;padding:24px 16px 40px}
  h1{margin:4px 0 10px;font-size:2rem}
  h2{margin:16px 0 8px;font-size:1.4rem}
  p{margin:4px 0 10px;color:var(--muted)}
  .grid{
    display:grid;
    grid-template-columns:minmax(0,1.15fr) minmax(0,1fr);
    gap:18px;
    align-items:flex-start;
  }
  .card{
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 0 0 1px rgba(0,0,0,0.4),0 10px 25px rgba(0,0,0,0.55);
  }
  textarea{
    width:100%;
    min-height:180px;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    resize:vertical;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.9rem;
    line-height:1.3;
  }
  label{display:block;font-weight:700;margin:8px 0 4px;color:var(--ink)}
  .controls-row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center}
  button{
    border:none;border-radius:999px;padding:10px 18px;font-size:1rem;font-weight:700;
    cursor:pointer;background:linear-gradient(135deg,var(--accent),#b4d0ff);
    color:#020415;box-shadow:0 4px 12px rgba(0,0,0,0.45);
    display:inline-flex;align-items:center;gap:6px;
  }
  button:active{transform:translateY(1px);box-shadow:0 2px 6px rgba(0,0,0,0.6)}
  .btn-secondary{background:#222a4a;color:var(--ink)}
  .badge{
    display:inline-block;padding:2px 8px;border-radius:999px;font-size:0.78rem;
    font-weight:700;background:#182044;color:var(--muted);border:1px solid var(--grid);
    margin-left:6px;
  }
  .stats{margin-top:8px;font-size:0.95rem}
  .stats-row{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0}
  .pill{padding:3px 9px;border-radius:999px;font-size:0.85rem;border:1px solid var(--grid);background:#050816}
  .pill-hot{ border-color:var(--good); color:var(--good); }
  .pill-warm{ border-color:var(--accent); color:var(--accent); }
  .pill-cold{ border-color:var(--muted); color:var(--muted); }
  .output-box{
    margin-top:10px;background:#050816;border-radius:10px;padding:10px 12px;border:1px solid var(--grid);
    font-family:ui-monospace,Consolas,monospace;font-size:1.05rem;line-height:1.45;
    max-height:520px;overflow:auto;
  }
  .ticket-line{display:flex;justify-content:space-between;align-items:center;padding:3px 0}
  .ticket-label{color:var(--muted);font-size:0.9rem;margin-right:10px}
  .ticket-numbers{letter-spacing:1px}
  .legend{margin-top:6px;font-size:0.9rem;color:var(--muted)}
  .small-note{font-size:0.82rem;color:var(--muted);margin-top:6px}
  .mini-note{font-size:0.84rem;color:var(--muted);margin-top:8px}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .controlbox{background:#0a0f25;border:1px solid var(--grid);border-radius:12px;padding:12px}
  .kv{display:grid;grid-template-columns:180px 1fr;gap:8px;align-items:center}
  input[type="number"], input[type="text"], select{
    width:100%;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    font-size:0.95rem;
  }
  input[type="range"]{width:100%}
  .rangeRow{display:grid;grid-template-columns:1fr 64px;gap:10px;align-items:center}
  .rangeVal{
    text-align:center;
    background:#050816;border:1px solid var(--grid);border-radius:10px;padding:8px 6px;
    font-weight:800;color:var(--ink);
  }
  .checkrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .checkrow label{margin:0;display:flex;gap:8px;align-items:center;color:var(--muted);font-weight:800}
  input[type="checkbox"]{transform:scale(1.15)}
  .hr{height:1px;background:var(--grid);margin:12px 0}
  .mono{font-family:ui-monospace,Consolas,monospace}
  .ok{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
  .tiny{font-size:0.78rem;color:var(--muted);margin-top:6px}
  .kpiGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .kpi{background:#050816;border:1px solid var(--grid);border-radius:10px;padding:10px}
  .kpi b{display:block;margin-bottom:4px}

  @media print {
    body{background:#ffffff;color:#000000;}
    body *{visibility:hidden;}
    #ticketsBox, #ticketsBox *{visibility:visible;}
    #ticketsBox{
      position:absolute;left:0;top:0;width:100%;
      border:none;background:#ffffff;box-shadow:none;font-size:1.1rem;
      max-height:none;overflow:visible;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>20-Ticket Tight Coach</h1>
  <p>
    History + prize-winner weighting + Dyson phase bias + prune/decay + <strong>pair-circulation control</strong> to generate
    <strong>20 tight lines</strong> (6/54).
  </p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <h2>1. Official Draw History</h2>
      <p>Paste recent official draws here (e.g., last 300–500 draws). One line per draw, 6 numbers per line.</p>
      <textarea id="historyInput" placeholder="Example:&#10;24 39 22 20 25 43&#10;50 39 27 23 42 44&#10;..."></textarea>

      <h2 style="margin-top:18px;">2. Prize / Jackpot Winners (pre-loaded)</h2>
      <p>These prize-winning lines are used as an anchor weight. Exact repeats are blocked.</p>
      <textarea id="winnersInput">
1 2 4 27 40 42
1 3 11 15 16 50
1 3 13 14 22 52
1 4 10 14 15 26
1 6 8 11 15 25
1 6 31 43 44 53
1 7 15 35 43 53
1 9 14 23 29 41
1 10 11 31 38 49
1 12 25 36 39 45
1 16 19 39 42 46
1 25 35 42 48 51
2 3 8 12 25 27
2 3 17 35 41 44
2 5 13 16 23 38
2 6 14 26 36 50
2 6 18 39 40 48
2 6 28 29 46 53
2 7 21 35 43 50
2 8 22 29 35 38
2 9 34 38 43 51
2 11 22 27 33 40
2 14 16 19 25 28
2 19 25 28 30 51
2 23 31 37 41 50
3 4 6 23 34 54
3 4 29 31 33 50
3 5 9 32 36 37
3 5 18 29 30 52
3 6 14 43 44 50
3 6 24 36 38 49
3 8 13 25 33 44
3 9 13 25 30 51
3 11 23 35 41 54
3 13 14 17 31 33
3 16 18 23 40 44
4 5 14 16 18 19
4 10 35 38 41 49
4 11 16 19 27 30
4 12 13 26 39 54
4 13 14 18 26 38
4 14 21 29 34 43
4 14 37 39 51 52
4 19 34 35 40 52
4 21 24 40 43 48
5 6 9 14 27 51
5 6 14 25 36 44
5 7 10 28 31 44
5 8 15 25 40 53
5 9 18 22 35 48
5 9 26 38 41 44
5 10 16 22 26 46
5 10 23 35 41 48
5 11 20 24 27 46
5 13 22 29 37 48
5 14 16 17 39 46
6 7 23 34 37 50
6 11 13 18 26 49
6 11 16 21 25 32
6 14 30 45 49 50
6 20 23 24 31 54
7 9 11 30 33 53
7 10 23 34 46 47
7 14 16 35 48 52
7 15 26 31 51 54
8 10 15 18 26 44
8 11 22 24 30 49
8 13 15 32 37 47
8 14 27 30 47 51
8 16 31 36 38 51
8 19 22 31 41 43
8 19 29 44 46 48
8 21 32 35 45 52
8 25 42 45 47 53
8 34 37 44 46 54
9 10 12 17 37 51
9 13 17 20 26 28
9 15 20 28 39 43
9 19 28 41 45 51
9 20 27 42 51 53
9 28 36 38 41 42
10 14 17 31 38 48
10 14 22 28 40 44
10 16 23 24 48 50
10 27 42 43 47 52
11 21 25 30 32 50
11 28 32 49 51 53
12 15 17 31 38 47
13 24 26 30 36 52
13 36 38 45 46 49
15 17 43 45 47 50
16 17 18 19 21 47
16 17 21 28 41 52
16 34 38 40 49 54
16 36 37 45 49 52
17 23 26 32 38 45
18 19 26 29 32 42
19 21 25 45 47 52
20 24 27 37 39 41
21 23 29 44 47 53
21 25 27 30 36 48
22 33 44 45 47 54
25 26 40 43 46 51
26 27 34 37 48 53
31 35 42 44 51 53
7 17 23 28 39 48
      </textarea>

      <h2 style="margin-top:18px;">3. Tightness Controls</h2>
      <div class="controlbox">
        <div style="font-weight:900;margin-bottom:6px;">Top Pool Slider (18–24)</div>
        <div class="rangeRow">
          <input id="topPool" type="range" min="18" max="24" step="1" value="18" />
          <div class="rangeVal" id="topPoolVal">18</div>
        </div>
        <div class="mini-note">
          Lower = tighter/narrower. For larger buying (80+ tickets), use 22–24 to increase coverage.
        </div>
      </div>

      <div class="subgrid" style="margin-top:12px;">
        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Dyson Sphere Bias</div>
          <div class="kv">
            <div>Capture (0–1)</div>
            <input id="dysonCapture" type="number" step="0.05" min="0" max="1" value="0.55" />
            <div>Field Amp (0–3)</div>
            <input id="dysonAmp" type="number" step="0.1" min="0" max="3" value="1.6" />
            <div>Cooling Suppress (0–2)</div>
            <input id="coolSuppress" type="number" step="0.1" min="0" max="2" value="1.0" />
          </div>
          <div class="mini-note">
            Higher Dyson can tighten again. For “many tickets” mode, keep capture ~0.35–0.55.
          </div>
        </div>

        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Prune & Decay</div>
          <div class="kv">
            <div>Decay Rate</div>
            <input id="decayRate" type="number" step="0.01" min="0" max="0.35" value="0.12" />
            <div>Decay Mode</div>
            <select id="decayMode">
              <option value="row">Decay numbers used per ticket</option>
              <option value="coverage">Extra decay for over-used numbers</option>
              <option value="both" selected>Both</option>
            </select>
            <div>Prune</div>
            <select id="pruneOn">
              <option value="off">Off</option>
              <option value="on" selected>On</option>
            </select>
            <div>Prune Threshold</div>
            <input id="pruneThreshold" type="number" step="0.01" min="0" max="0.25" value="0.12" />
          </div>
          <div class="checkrow">
            <label><input id="decayTargetsOnly" type="checkbox" checked />Decay top-pool only</label>
            <label><input id="microReheat" type="checkbox" checked />Micro re-heat unused</label>
          </div>
          <div class="mini-note">
            Tight default: prune 0.12, decay 0.12. For broader coverage: decay 0.16, top pool 22–24.
          </div>
        </div>
      </div>

      <h2 style="margin-top:18px;">4. Pair-Circulation (Stokes-style) Controls</h2>
      <div class="controlbox">
        <div style="font-weight:900;margin-bottom:6px;">Pair Penalty Strength (λ)</div>
        <div class="rangeRow">
          <input id="pairLambda" type="range" min="0" max="0.35" step="0.01" value="0.18" />
          <div class="rangeVal" id="pairLambdaVal">0.18</div>
        </div>
        <div class="checkrow">
          <label><input id="sessionMemoryOn" type="checkbox" checked />Carry memory across batches (20→20→20…)</label>
        </div>
        <div class="tiny">
          Idea: repeated pair reuse = repeated boundary “flow” (circulation). λ penalizes over-used edges to reduce looping and expand coverage.
        </div>
      </div>

      <div class="controls-row" style="margin-top:14px;">
        <button id="analyzeBtn" type="button">Analyze History</button>
        <button id="generateBtn" type="button" class="btn-secondary">Generate 20 Tickets</button>
        <button id="printBtn" type="button" class="btn-secondary">Print 20 Tickets</button>
        <button id="resetSessionBtn" type="button" class="btn-secondary">Reset Session Memory</button>
      </div>

      <div class="small-note">
        Rules: 6 numbers from 1–54. Exact prize lines blocked. Any run of 3+ consecutive numbers blocked.
        Near-duplicates sharing 5/6 numbers are blocked to keep variety.
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2>5. Bands & Dyson Phase Summary</h2>
      <div id="summaryBox" class="stats">Paste history and click <b>Analyze History</b>.</div>

      <div class="legend">
        <span class="pill pill-hot">Hot</span> top frequency &nbsp;
        <span class="pill pill-warm">Warm</span> mid &nbsp;
        <span class="pill pill-cold">Cold</span> low frequency
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Dyson z-score phases</strong> (from your history)</div>
        <div class="stats-row" id="phaseRow">Analyze history first.</div>
        <div class="mini-note" id="dysonExplain"></div>
      </div>

      <div class="hr"></div>

      <h2>6. Generated 20-Ticket Set</h2>
      <div id="ticketsBox" class="output-box">Click “Generate 20 Tickets” after analyzing.</div>

      <div class="kpiGrid">
        <div class="kpi"><b>Coverage</b><div id="coverageBox" class="mini-note">—</div></div>
        <div class="kpi"><b>Circulation / Pairs</b><div id="pairsBox" class="mini-note">—</div></div>
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Effective pool after prune</strong></div>
        <div id="effectivePool" class="mono">—</div>
        <div class="mini-note">Shows how many Top Pool numbers still carry meaningful weight after prune.</div>
      </div>

      <div class="hr"></div>
      <div class="stats">
        <div><strong>Session Memory</strong> (optional)</div>
        <div id="sessionBox" class="mini-note">No session stats yet.</div>
      </div>

    </div>
  </div>
</div>

<script>
(function(){
  const N_MIN = 1;
  const N_MAX = 54;
  const TICKET_SIZE = 6;
  const NUM_TICKETS = 20;

  const historyInput = document.getElementById('historyInput');
  const winnersInput = document.getElementById('winnersInput');
  const summaryBox   = document.getElementById('summaryBox');
  const ticketsBox   = document.getElementById('ticketsBox');
  const analyzeBtn   = document.getElementById('analyzeBtn');
  const generateBtn  = document.getElementById('generateBtn');
  const printBtn     = document.getElementById('printBtn');
  const resetSessionBtn = document.getElementById('resetSessionBtn');

  // Top pool slider
  const topPoolSlider = document.getElementById('topPool');
  const topPoolVal = document.getElementById('topPoolVal');

  // Pair-circulation controls
  const pairLambda = document.getElementById('pairLambda');
  const pairLambdaVal = document.getElementById('pairLambdaVal');
  const sessionMemoryOn = document.getElementById('sessionMemoryOn');

  // Dyson controls
  const dysonCaptureInput = document.getElementById('dysonCapture');
  const dysonAmpInput = document.getElementById('dysonAmp');
  const coolSuppressInput = document.getElementById('coolSuppress');

  // Prune/decay controls
  const decayRateInput = document.getElementById('decayRate');
  const decayModeInput = document.getElementById('decayMode');
  const pruneOnInput = document.getElementById('pruneOn');
  const pruneThresholdInput = document.getElementById('pruneThreshold');
  const decayTargetsOnlyInput = document.getElementById('decayTargetsOnly');
  const microReheatInput = document.getElementById('microReheat');

  const phaseRowEl = document.getElementById('phaseRow');
  const dysonExplainEl = document.getElementById('dysonExplain');
  const coverageBoxEl = document.getElementById('coverageBox');
  const pairsBoxEl = document.getElementById('pairsBox');
  const effectivePoolEl = document.getElementById('effectivePool');
  const sessionBoxEl = document.getElementById('sessionBox');

  let lastStats = null;
  let forbiddenSet = new Set();

  // Session memory across batches (optional)
  let sessionUsageCounts = new Array(N_MAX+1).fill(0);
  let sessionPairCounts = new Map(); // key "a-b" -> count
  let sessionTicketsGenerated = 0;

  // ---- helpers ----
  function parseCombos(text) {
    const combos = [];
    if (!text) return combos;
    const lines = text.trim().split(/\n+/);
    for (let line of lines) {
      const nums = line.trim().split(/[\s,]+/).map(x => parseInt(x,10)).filter(n => !isNaN(n));
      if (nums.length >= TICKET_SIZE) {
        const combo = nums.slice(0, TICKET_SIZE).sort((a,b)=>a-b);
        if (combo.every(n => n >= N_MIN && n <= N_MAX)) combos.push(combo);
      }
    }
    return combos;
  }
  function keyForCombo(combo) { return combo.join('-'); }
  function pairKey(a,b){ return (a<b) ? (a+"-"+b) : (b+"-"+a); }

  function meanStd(values){
    const n = values.length || 1;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  function computeZPhases(freq){
    const vals = [];
    for (let n=N_MIN; n<=N_MAX; n++) vals.push(freq[n] || 0);
    const {mu, sigma} = meanStd(vals);

    const z = new Array(N_MAX+1).fill(0);
    const phases = {rising:[], neutral:[], cooling:[]};
    for (let n=N_MIN; n<=N_MAX; n++){
      const zz = (sigma>0) ? ((freq[n]-mu)/sigma) : 0;
      z[n] = zz;
      if (zz <= -0.5) phases.rising.push(n);
      else if (Math.abs(zz) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    }
    return {z, phases, mu, sigma};
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function clamp01(x){ return clamp(x,0,1); }

  function dysonFieldFactor(z, capture, amp, coolSuppress){
    const strength = capture * amp;
    if (strength <= 0) return 1;

    if (z <= -0.5){
      const t = Math.min(1, (-z - 0.5) / 1.5);
      return 1 + (0.8*strength) * (0.6 + 0.4*t);
    }
    if (z >= 0.5){
      const t = Math.min(1, (z - 0.5) / 1.5);
      const sup = (coolSuppress * strength) * (0.6 + 0.4*t);
      return 1 / (1 + sup);
    }
    return 1 + 0.10*strength*(0.5 - Math.abs(z));
  }

  function median(values){
    const a = values.slice().sort((x,y)=>x-y);
    const n = a.length;
    if(!n) return 0;
    return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
  }

  function computeStats(historyCombos, winnerCombos) {
    const freq = new Array(N_MAX + 1).fill(0);
    const prizeBoost = new Array(N_MAX + 1).fill(0);

    historyCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) freq[n]++; }));
    winnerCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) prizeBoost[n]++; }));

    const totalHits = freq.reduce((a,b)=>a+b,0);
    const drawsCount = historyCombos.length;

    const {z, phases, mu, sigma} = computeZPhases(freq);

    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push({ n, freq:freq[n], boost:prizeBoost[n] });
    arr.sort((a,b) => b.freq - a.freq || b.boost - a.boost || a.n - b.n);

    const hotCount  = 10;
    const warmCount = 15;
    const hot  = arr.slice(0, hotCount).map(o=>o.n);
    const warm = arr.slice(hotCount, hotCount+warmCount).map(o=>o.n);
    const cold = arr.slice(hotCount+warmCount).map(o=>o.n);

    const weights = new Array(N_MAX + 1).fill(1);
    for (let n=N_MIN; n<=N_MAX; n++){
      const base = 1 + freq[n];
      const prizeExtra = 0.6 * prizeBoost[n];
      weights[n] = Math.max(1, base + prizeExtra);
    }

    return { freq, prizeBoost, weights, hot, warm, cold, drawsCount, totalHits, mu, sigma, z, phases };
  }

  function renderStats(stats) {
    const {hot, warm, cold, drawsCount, totalHits, mu, sigma} = stats;
    function fmtList(list){ return list.length ? list.join(' ') : '(none)'; }
    summaryBox.innerHTML = `
      <div><strong>Draws analyzed:</strong> ${drawsCount}</div>
      <div><strong>Total hits counted:</strong> ${totalHits}</div>
      <div><strong>Avg hits per number:</strong> ${(mu).toFixed(2)}
        <span class="badge">σ ≈ ${(sigma).toFixed(2)}</span>
      </div>
      <div class="stats-row" style="margin-top:8px;">
        <span class="pill pill-hot"><strong>Hot</strong> ${fmtList(hot)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-warm"><strong>Warm</strong> ${fmtList(warm)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-cold"><strong>Cold</strong> ${fmtList(cold)}</span>
      </div>
    `;
  }

  function renderPhases(stats){
    const r = stats.phases.rising.length;
    const n = stats.phases.neutral.length;
    const c = stats.phases.cooling.length;
    phaseRowEl.innerHTML = `
      <span class="pill pill-hot">Rising (z≤-0.5): <b>${r}</b></span>
      <span class="pill pill-warm">Neutral (|z|&lt;0.5): <b>${n}</b></span>
      <span class="pill pill-cold">Cooling (z≥0.5): <b>${c}</b></span>
    `;
    dysonExplainEl.textContent =
      `Dyson bias uses your history z-scores: Rising numbers get boosted, Cooling get suppressed.`;
  }

  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function hasSequenceRun(combo, minLen) {
    let run = 1;
    for (let i = 1; i < combo.length; i++) {
      if (combo[i] === combo[i-1] + 1) { run++; if (run >= minLen) return true; }
      else run = 1;
    }
    return false;
  }

  // ---- Pair-circulation (Stokes-style) picking ----
  function pairPenalty(candidate, chosen, pairCounts){
    let p = 0;
    for (const x of chosen){
      const k = pairKey(candidate, x);
      p += (pairCounts.get(k) || 0);
    }
    return p;
  }

  function weightedPickWithPenalty(available, weights, rng, chosen, pairCounts, lambda){
    const lam = clamp(+lambda || 0, 0, 0.35);
    if (lam <= 0) {
      // fallback plain weighted pick
      let total = 0;
      for (const n of available) total += weights[n];
      if (total <= 0) return available[Math.floor(rng()*available.length)];
      let r = rng() * total;
      for (const n of available) { r -= weights[n]; if (r <= 0) return n; }
      return available[available.length-1];
    }

    let total = 0;
    const eff = [];
    for (const n of available){
      const pen = pairPenalty(n, chosen, pairCounts);
      const factor = 1 / (1 + lam * pen);          // repeated edge => lower weight
      const w = Math.max(1e-9, weights[n] * factor);
      eff.push([n, w]);
      total += w;
    }
    if (total <= 0) return available[Math.floor(rng()*available.length)];
    let r = rng() * total;
    for (const [n,w] of eff){ r -= w; if (r <= 0) return n; }
    return eff[eff.length-1][0];
  }

  function generateTicketFromWeights(weights, rng, pairCounts, lambda) {
    const available = [];
    for (let n=N_MIN; n<=N_MAX; n++) available.push(n);

    const combo = [];
    for (let i=0; i<TICKET_SIZE; i++){
      const pick = weightedPickWithPenalty(available, weights, rng, combo, pairCounts, lambda);
      combo.push(pick);
      const idx = available.indexOf(pick);
      if (idx >= 0) available.splice(idx,1);
    }
    combo.sort((a,b)=>a-b);
    return combo;
  }

  function applyDysonToWeights(baseWeights, zArr){
    const cap = clamp01(+dysonCaptureInput.value || 0);
    const amp = clamp(+dysonAmpInput.value || 0, 0, 3);
    const sup = clamp(+coolSuppressInput.value || 0, 0, 2);
    const out = baseWeights.slice();
    for (let n=N_MIN; n<=N_MAX; n++){
      const factor = dysonFieldFactor(zArr[n] || 0, cap, amp, sup);
      out[n] = Math.max(1e-6, out[n] * factor);
    }
    return out;
  }

  function makeTopPool(weights, k){
    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push([n, weights[n]]);
    arr.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    return new Set(arr.slice(0,k).map(x=>x[0]));
  }

  function pruneWeights(weights, topPoolSet){
    const pruneOn = (pruneOnInput.value === 'on');
    if(!pruneOn) return weights;

    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    const cut = med * threshFrac;
    if (cut <= 0) return weights;

    const out = weights.slice();
    for (let n of topPoolSet){
      if (out[n] < cut) out[n] = 1e-6;
    }
    return out;
  }

  function effectivePoolCount(weights, topPoolSet){
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    if (med <= 0) return {count: topPoolSet.size, cut: 0};
    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const cut = med * threshFrac;
    let c = 0;
    for (let n of topPoolSet) if (weights[n] >= cut) c++;
    return {count:c, cut};
  }

  function applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet){
    const rate = clamp(+decayRateInput.value || 0, 0, 0.35);
    const mode = decayModeInput.value || 'both';
    const decayTargetsOnly = !!decayTargetsOnlyInput.checked;
    const microReheat = !!microReheatInput.checked;

    const out = weights.slice();

    if (mode === 'row' || mode === 'both'){
      for (const n of ticket){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = Math.max(1e-6, out[n] * (1 - rate));
      }
    }

    if (mode === 'coverage' || mode === 'both'){
      for (let n=N_MIN; n<=N_MAX; n++){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        const c = usageCounts[n] || 0;
        if (c >= 4){
          const extra = Math.min(0.22, rate * 0.75);
          out[n] = Math.max(1e-6, out[n] * (1 - extra));
        }
      }
    }

    if (microReheat){
      const lift = rate * 0.10;
      for (let n=N_MIN; n<=N_MAX; n++){
        if (ticket.includes(n)) continue;
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = out[n] * (1 + lift);
      }
    }

    return out;
  }

  function circulationIndex(pairCounts){
    // sum of squares: higher = more looping / reuse
    let s = 0;
    pairCounts.forEach(c => { s += c*c; });
    return s;
  }
  function pairDiversity(pairCounts){
    // count of pairs that appear 2+ times
    let c2 = 0;
    pairCounts.forEach(c => { if (c >= 2) c2++; });
    return c2;
  }

  function renderSessionStats(){
    const totalUsed = sessionUsageCounts.reduce((a,b)=>a+b,0);
    const usedNums = sessionUsageCounts.filter(x=>x>0).length;
    const ci = circulationIndex(sessionPairCounts);
    const pd = pairDiversity(sessionPairCounts);
    sessionBoxEl.innerHTML =
      `<div><b>Tickets generated:</b> ${sessionTicketsGenerated}</div>` +
      `<div><b>Unique numbers touched:</b> ${usedNums} / 54</div>` +
      `<div><b>Total picks:</b> ${totalUsed}</div>` +
      `<div><b>Session pair diversity (pairs ≥2):</b> ${pd}</div>` +
      `<div><b>Session circulation index (Σpair²):</b> ${ci}</div>`;
  }

  function syncTopPoolUI(){ topPoolVal.textContent = String(topPoolSlider.value); }
  function syncLambdaUI(){ pairLambdaVal.textContent = (+pairLambda.value).toFixed(2); }

  syncTopPoolUI(); syncLambdaUI();

  topPoolSlider.addEventListener('input', ()=>{
    syncTopPoolUI();
    if (lastStats) {
      const txt = (ticketsBox.textContent || '').trim();
      if (txt && !txt.includes('Analyze') && !txt.includes('Generate')) generateTickets(lastStats);
    }
  });

  pairLambda.addEventListener('input', ()=>{
    syncLambdaUI();
    maybeRefresh();
  });

  resetSessionBtn.addEventListener('click', ()=>{
    sessionUsageCounts = new Array(N_MAX+1).fill(0);
    sessionPairCounts = new Map();
    sessionTicketsGenerated = 0;
    sessionBoxEl.textContent = 'Session memory reset.';
  });

  // Analyze
  analyzeBtn.addEventListener('click', ()=>{
    const historyCombos = parseCombos(historyInput.value);
    const winnerCombos = parseCombos(winnersInput.value);

    forbiddenSet = new Set();
    winnerCombos.forEach(c => forbiddenSet.add(keyForCombo(c)));

    if (!historyCombos.length){
      summaryBox.innerHTML = '<span class="bad"><b>No valid history draws detected.</b> Paste some lines first.</span>';
      phaseRowEl.textContent = 'Analyze history first.';
      dysonExplainEl.textContent = '';
      effectivePoolEl.textContent = '—';
      ticketsBox.textContent = '—';
      coverageBoxEl.textContent = '—';
      pairsBoxEl.textContent = '—';
      return;
    }

    lastStats = computeStats(historyCombos, winnerCombos);
    renderStats(lastStats);
    renderPhases(lastStats);

    ticketsBox.textContent = 'History analyzed. Now click “Generate 20 Tickets”.';
    coverageBoxEl.textContent = '—';
    pairsBoxEl.textContent = '—';
    effectivePoolEl.textContent = '—';
  });

  // Generate click
  generateBtn.addEventListener('click', ()=> generateTickets(lastStats));

  // Print
  printBtn.addEventListener('click', ()=>{
    const txt = ticketsBox.textContent.trim();
    if (!txt || txt.includes('Generate 20') || txt.includes('History analyzed') || txt === '—') {
      alert('Generate your 20 tickets first before printing.');
      return;
    }
    window.print();
  });

  // Auto-regenerate if user tweaks controls after generation
  function maybeRefresh(){
    if (!lastStats) return;
    const txt = (ticketsBox.textContent || '').trim();
    if (!txt || txt.includes('History analyzed') || txt.includes('Analyze') || txt.includes('Generate')) return;
    generateTickets(lastStats);
  }
  [
    dysonCaptureInput, dysonAmpInput, coolSuppressInput,
    decayRateInput, decayModeInput, pruneOnInput, pruneThresholdInput,
    decayTargetsOnlyInput, microReheatInput, sessionMemoryOn
  ].forEach(el=>{
    el.addEventListener('input', maybeRefresh);
    el.addEventListener('change', maybeRefresh);
  });

  function generateTickets(stats){
    if (!stats){
      ticketsBox.textContent = 'Please analyze history first.';
      return;
    }

    // Step 1: base -> Dyson
    let weights = applyDysonToWeights(stats.weights, stats.z);

    // Step 2: Top pool
    const TOP_POOL_K = clamp(parseInt(topPoolSlider.value,10) || 18, 18, 24);
    const topPoolSet = makeTopPool(weights, TOP_POOL_K);

    // Step 3: prune in pool
    weights = pruneWeights(weights, topPoolSet);

    // Step 4: downweight outside pool (tightness)
    for (let n=N_MIN; n<=N_MAX; n++){
      if (!topPoolSet.has(n)) weights[n] *= 0.30;
    }

    // Effective pool after prune
    const ep = effectivePoolCount(weights, topPoolSet);
    effectivePoolEl.textContent = `TopPool=${TOP_POOL_K} • pruneCut≈${ep.cut.toFixed(4)} • effective≈${ep.count}/${TOP_POOL_K}`;

    // Batch state
    const tickets = [];
    const seen = new Set(forbiddenSet);
    const usageCounts = new Array(N_MAX+1).fill(0);

    // Pair counts for this batch (optionally seeded from session)
    const batchPairCounts = new Map();
    const useSession = !!sessionMemoryOn.checked;
    if (useSession){
      // seed lightly (so it nudges, not dominates)
      sessionPairCounts.forEach((c,k)=> batchPairCounts.set(k, Math.round(c * 0.35)));
    }

    const rng = mulberry32((Date.now() ^ (Math.random()*1e9)) >>> 0);
    const lambda = clamp(+pairLambda.value || 0, 0, 0.35);

    let attempts = 0;
    while (tickets.length < NUM_TICKETS && attempts < 14000){
      attempts++;

      const ticket = generateTicketFromWeights(weights, rng, batchPairCounts, lambda);
      const key = keyForCombo(ticket);

      if (seen.has(key)) continue;
      if (hasSequenceRun(ticket, 3)) continue;

      // near-duplicate filter (5/6 overlap)
      let tooSimilar = false;
      for (const t of tickets){
        let common = 0;
        for (const n of ticket) if (t.includes(n)) common++;
        if (common >= 5){ tooSimilar = true; break; }
      }
      if (tooSimilar) continue;

      seen.add(key);
      tickets.push(ticket);

      // update counts
      for (const n of ticket) usageCounts[n]++;

      // update pair counts (Stokes-style “boundary circulation” memory)
      for (let i=0;i<ticket.length;i++){
        for (let j=i+1;j<ticket.length;j++){
          const k = pairKey(ticket[i], ticket[j]);
          batchPairCounts.set(k, (batchPairCounts.get(k)||0) + 1);
        }
      }

      // decay between tickets
      weights = applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet);
      weights = pruneWeights(weights, topPoolSet);
    }

    if (!tickets.length){
      ticketsBox.textContent = 'No tickets generated (constraints too tight). Raise Top Pool or lower prune/decay.';
      coverageBoxEl.textContent = '—';
      pairsBoxEl.textContent = '—';
      return;
    }

    ticketsBox.innerHTML = tickets.map((t,i)=>`
      <div class="ticket-line">
        <span class="ticket-label">#${(i+1).toString().padStart(2,'0')}</span>
        <span class="ticket-numbers">${t.join('  ')}</span>
      </div>
    `).join('');

    // Coverage stats
    const used = new Set();
    tickets.forEach(t=>t.forEach(n=>used.add(n)));
    let inPool = 0;
    used.forEach(n=>{ if (topPoolSet.has(n)) inPool++; });

    const freqList = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      if (usageCounts[n]>0) freqList.push([n, usageCounts[n]]);
    }
    freqList.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const topUsed = freqList.slice(0,12).map(([n,c])=>`${n}(${c})`).join('  ');

    coverageBoxEl.innerHTML =
      `<div><b>Unique numbers used:</b> <b>${used.size}</b> / 54</div>` +
      `<div><b>Inside Top Pool:</b> <b>${inPool}</b> / ${TOP_POOL_K}</div>` +
      `<div class="mono"><b>Most repeated:</b> ${topUsed || '—'}</div>`;

    // Pair diversity + circulation
    const batchPairs2 = pairDiversity(batchPairCounts);
    const batchCI = circulationIndex(batchPairCounts);
    pairsBoxEl.innerHTML =
      `<div><b>Pair diversity (pairs ≥2):</b> <b>${batchPairs2}</b></div>` +
      `<div><b>Circulation index (Σpair²):</b> <b>${batchCI}</b></div>` +
      `<div class="tiny">Lower circulation usually means less “looping” (less repeated pair reuse).</div>`;

    // Update session memory
    if (useSession){
      tickets.forEach(t=>{
        for (const n of t) sessionUsageCounts[n]++;
        for (let i=0;i<t.length;i++){
          for (let j=i+1;j<t.length;j++){
            const k = pairKey(t[i], t[j]);
            sessionPairCounts.set(k, (sessionPairCounts.get(k)||0) + 1);
          }
        }
      });
      sessionTicketsGenerated += tickets.length;
      renderSessionStats();
    } else {
      sessionBoxEl.textContent = 'Session memory is OFF (no cross-batch carry).';
    }
  }

})();
</script>
</body>
</html>
