<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST String Momentum — String Theory • Einstein Master Equation • Navigation</title>
<meta name="description" content="Autonomous visualization of CST-driven string vibrations with momentum flux, linking String Theory intuition to Einstein-style geometric timing for CST navigation. © Gabino Casanova."/>
<style>
  :root{
    --bg:#090d14; --panel:#0f1626; --ink:#e7eefc; --muted:#9fb0cc; --accent:#7fe0ff;
    --border:#1b2740; --grid:#142036; --ok:#24e0a6; --warn:#ffd159; --hot:#ff6f8a;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:16px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0e1522,#0a0f17)}
  h1{margin:0 0 6px;font-size:20px;letter-spacing:.2px}
  .sub{font-size:12px;color:var(--muted)}
  .wrap{display:grid;grid-template-columns:1fr 380px;gap:14px;max-width:1600px;margin:0 auto;padding:14px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 40px #00000033;overflow:hidden}
  .titlebar{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--border);background:#101a2b}
  .pad{padding:14px}
  .kv{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .box{background:#0c1322;border:1px solid var(--border);border-radius:10px;padding:10px}
  .k{font-size:11px;color:var(--muted)}
  .v{font-size:14px}
  canvas{display:block;width:100%;height:640px;background:radial-gradient(1200px 600px at 50% 50%,#0b1324 0,#0a0f17 70%);}
  .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
  .dot{width:12px;height:12px;border-radius:2px;display:inline-block;margin-right:6px;vertical-align:middle}
  .log{font-family:ui-monospace,Consolas,monospace;font-size:12px;background:#0b1220;border:1px solid var(--border);border-radius:10px;padding:10px;white-space:pre-wrap}
  .note{font-size:12px;color:var(--muted);margin-top:8px}
  a{color:var(--accent);text-decoration:none}
</style>
</head>
<body>
<header>
  <h1>CST String Momentum — Autonomous Visualization</h1>
  <div class="sub">“Humans dream of the impossible before building it.” — <strong>Gabino Casanova</strong></div>
</header>

<div class="wrap">
  <!-- Visualizer -->
  <section class="card">
    <div class="titlebar">
      <div>Field Visualizer (Strings + Momentum Flux)</div>
      <div class="legend">
        <span><span class="dot" style="background:#8dd6ff"></span>String displacement</span>
        <span><span class="dot" style="background:#24e0a6"></span>Positive momentum</span>
        <span><span class="dot" style="background:#ff6f8a"></span>Negative momentum</span>
      </div>
    </div>
    <canvas id="view" width="1400" height="640"></canvas>
    <div class="pad">
      <div class="kv">
        <div class="box"><div class="k">CST since Epoch</div><div class="v" id="cstClock">—</div></div>
        <div class="box"><div class="k">Base notional f₀</div><div class="v" id="f0">—</div></div>
        <div class="box"><div class="k">Strings × Harmonics</div><div class="v" id="conf">—</div></div>
        <div class="box"><div class="k">Tension • Damping • Coupling</div><div class="v" id="phys">—</div></div>
      </div>
      <div class="note">Autonomous mode: no controls. The system runs continuously to show persistent momentum transport.</div>
    </div>
  </section>

  <!-- Explanation -->
  <aside class="card">
    <div class="titlebar"><div>What this program shows</div></div>
    <div class="pad" id="explain">
      <p><strong>Overview.</strong> This visualization shows a set of coupled “strings” that vibrate continuously and exchange <em>momentum</em>. The driver is <strong>CST (Cosmic Standard Time)</strong>: a cosmic clock that maps elapsed time since a fixed epoch into the base harmonic that excites the strings. The viewer cannot interact — the point is to simply <em>watch</em> how momentum flows in a living field.</p>

      <p><strong>String Theory intuition.</strong> In string-theory thinking, fundamental excitations are vibrating degrees of freedom. Here we model a simplified classical field of strings with multiple harmonics and neighbor coupling (“entanglement-like” phase exchange). The colored lines show transverse displacement; the green/pink tracer shows the local <em>momentum flux</em> (direction and strength of energy transport along the strings).</p>

      <p><strong>Einstein Master Equation link.</strong> In GR, geometry dictates dynamics; stress-energy feeds curvature. Conceptually, we emulate this by letting the <em>cosmic timing rhythm</em> (CST) set the base drive frequency/phase, while the field responds through wave equations with tension and damping. Energy density and momentum flux (∝ velocity × spatial gradient) are computed each frame, giving a visual analogy to how stress-energy flows through a geometric background.</p>

      <p><strong>CST Navigation purpose.</strong> For CST-guided navigation, stable rhythms are crucial. By tying the drive to cycles (e.g., Metonic, precession, or your 988-year resets), the vehicle’s control system can phase-lock to reproducible cosmic “beats.” The goal is to maintain <em>coherent momentum transport</em> in the surrounding field — a necessary ingredient for your positive-energy, corridor-shaping warp-navigation concept.</p>

      <p><strong>How to read the screen.</strong></p>
      <ul>
        <li><em>Blue strings</em>: displacement. Fixed ends give standing-plus-driven waves.</li>
        <li><em>Green/Pink streaks</em>: momentum flux parcels; green → positive direction, pink → negative. Density = strength.</li>
        <li><em>Continuous evolution</em>: no reset — the field “remembers” and transports momentum non-stop.</li>
      </ul>

      <p class="note"><strong>Credit:</strong> © <em>Gabino Casanova</em> — Interstellar Star Clock (CST). Concept visualization only; parameters are illustrative.</p>

      <div class="log" id="log"></div>
    </div>
  </aside>
</div>

<script>
(() => {
  // ====== Elements ======
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  const cstClock = document.getElementById('cstClock');
  const f0El = document.getElementById('f0');
  const confEl = document.getElementById('conf');
  const physEl = document.getElementById('phys');
  const logEl = document.getElementById('log');

  // ====== Parameters (fixed; no controls) ======
  // Epoch: 3114-08-11 BCE (proleptic Gregorian)
  const EPOCH = new Date(Date.UTC(-3113,7,11,0,0,0));
  const METONIC_YEARS = 19;     // base CST cycle
  const STRINGS = 7;            // number of strings
  const SEGMENTS = 280;         // spatial resolution per string
  const HARMONICS = 9;          // harmonics per string
  const TENSION = 1.8;          // wave speed^2
  const DAMPING = 0.010;        // velocity damping
  const COUPLING = 0.12;        // neighbor coupling
  const DRIVE = 2.2;            // multiplies base f0
  const MOMENTUM_TRACERS = 160; // number of tracer particles

  // ====== State ======
  const field = {
    y: Array.from({length:STRINGS}, ()=>new Float32Array(SEGMENTS).fill(0)),
    v: Array.from({length:STRINGS}, ()=>new Float32Array(SEGMENTS).fill(0)),
    phaseJitter: Array.from({length:STRINGS}, ()=>Math.random()*Math.PI*2),
    basePhase: 0,
    tracers: []
  };

  // Create momentum tracers spread across strings
  function initTracers(){
    field.tracers = [];
    for (let n=0;n<MOMENTUM_TRACERS;n++){
      field.tracers.push({
        i: Math.floor(Math.random()*STRINGS),      // which string
        x: Math.random()*(SEGMENTS-2)+1,           // position in segment index space
        dir: Math.random()<0.5? -1: 1,             // travel direction (flips with local flux)
        age: Math.random()*200+50                  // lifespan frames
      });
    }
  }

  function log(s){
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${s}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ====== CST mapping ======
  function cstNowSeconds(){
    const now = new Date();
    return (now.getTime() - EPOCH.getTime())/1000;
  }
  function updatePanel(){
    const secs = cstNowSeconds();
    const years = secs/(365.2422*24*3600);
    const phaseInCycle = (years % METONIC_YEARS)/METONIC_YEARS;
    const f0 = (0.1 + 0.9*phaseInCycle) * DRIVE;
    cstClock.textContent = `${years.toFixed(3)} CST-years since 3114-08-11 (BCE)`;
    f0El.textContent = f0.toFixed(3);
    confEl.textContent = `${STRINGS} × ${HARMONICS}`;
    physEl.textContent = `${TENSION.toFixed(2)} • ${DAMPING.toFixed(3)} • ${COUPLING.toFixed(2)}`;
    return f0;
  }

  // ====== Driver ======
  function driveAt(x01, i, t, f0){
    let s = 0;
    const base = field.phaseJitter[i] + field.basePhase;
    for (let k=1;k<=HARMONICS;k++){
      const w = 2*Math.PI*(f0*k);
      const phase = base + k*2*Math.PI*x01;
      s += Math.sin(w*t + phase)/k;
    }
    return s;
  }

  // ====== Simulation Step ======
  let simTime = 0, last = performance.now();
  function step(dt){
    const f0 = updatePanel();
    field.basePhase += 0.25*dt*f0;

    for (let i=0;i<STRINGS;i++){
      const y = field.y[i], v = field.v[i];
      for (let j=1;j<SEGMENTS-1;j++){
        const yxx = y[j-1] - 2*y[j] + y[j+1];
        let coupling = 0;
        if (i>0)       coupling += field.y[i-1][j] - y[j];
        if (i<STRINGS-1) coupling += field.y[i+1][j] - y[j];
        const x01 = j/(SEGMENTS-1);
        const F = 0.6*driveAt(x01,i,simTime,f0);
        v[j] += (TENSION*yxx + COUPLING*coupling + F - DAMPING*v[j]) * dt;
      }
    }
    // Integrate positions with fixed ends
    for (let i=0;i<STRINGS;i++){
      const y = field.y[i], v = field.v[i];
      y[0]=0; y[SEGMENTS-1]=0;
      for (let j=1;j<SEGMENTS-1;j++) y[j] += v[j]*dt;
    }

    // Momentum tracers update: move along direction of local flux
    // Flux ~ -v * y_x (up to constant factors). We'll use sgn(flux) for direction and |flux| for speed.
    for (const p of field.tracers){
      const i = p.i;
      const j = Math.max(1, Math.min(SEGMENTS-2, Math.floor(p.x)));
      const vy = field.v[i][j];
      const yx = field.y[i][j+1] - field.y[i][j-1];
      const flux = -vy * yx; // positive → energy to +x
      const speed = 0.75 + 3.5*Math.min(1, Math.abs(flux)*6); // visualization speed
      const dir = Math.sign(flux) || p.dir;
      p.x += dir*speed*dt*30;  // scale to look lively
      p.dir = dir;
      p.age -= dt*60;
      if (p.x<=1 || p.x>=SEGMENTS-2 || p.age<=0){
        // respawn
        p.i = Math.floor(Math.random()*STRINGS);
        p.x = Math.random()*(SEGMENTS-2)+1;
        p.dir = Math.random()<0.5? -1: 1;
        p.age = Math.random()*200+50;
      }
    }
  }

  // ====== Rendering ======
  function colorString(i, sampleVal){
    // soft blue shifted by index and center value
    const hue = 205 + Math.sin(i*0.9 + sampleVal*2.0)*15;
    return `hsl(${hue} 90% 65%)`;
  }
  function render(){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // grid
    ctx.strokeStyle = '#12203a';
    ctx.lineWidth = 1;
    for (let gy=1; gy<=STRINGS; gy++){
      const y = gy*(h/(STRINGS+1));
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }

    // strings
    const gap = h/(STRINGS+1);
    for (let i=0;i<STRINGS;i++){
      const y0 = (i+1)*gap;
      ctx.beginPath();
      for (let j=0;j<SEGMENTS;j++){
        const x = j/(SEGMENTS-1)*w;
        const y = y0 + field.y[i][j]*gap*0.7;
        if (j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.lineWidth = 2;
      const sampleMid = field.y[i][Math.floor(SEGMENTS/2)];
      ctx.strokeStyle = colorString(i, sampleMid);
      ctx.stroke();
    }

    // momentum flux tracers
    for (const p of field.tracers){
      const y0 = (p.i+1)*gap;
      const j = Math.max(1, Math.min(SEGMENTS-2, Math.floor(p.x)));
      const x = (p.x/(SEGMENTS-1))*w;
      const vloc = field.v[p.i][j];
      const yx   = field.y[p.i][j+1] - field.y[p.i][j-1];
      const flux = -vloc*yx;
      const len = Math.min(18, 6 + Math.abs(flux)*120);
      const y = y0 + field.y[p.i][j]*gap*0.7;

      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.sign(flux)*len, y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = flux>=0 ? 'rgba(36,224,166,0.95)' : 'rgba(255,111,138,0.95)';
      ctx.stroke();

      // small head dot
      ctx.beginPath();
      ctx.arc(x + Math.sign(flux)*len, y, 2.3, 0, Math.PI*2);
      ctx.fillStyle = flux>=0 ? 'rgba(36,224,166,0.9)' : 'rgba(255,111,138,0.9)';
      ctx.fill();
    }
  }

  // ====== Main loop (autonomous) ======
  function loop(now){
    const dt = Math.min(0.04, (now - last)/1000); // clamp dt for stability
    last = now;
    simTime += dt;
    step(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ====== Boot ======
  initTracers();
  // Prime with small noise so motion starts immediately
  for (let i=0;i<STRINGS;i++){
    for (let j=0;j<SEGMENTS;j++){
      field.y[i][j] = (Math.random()*2-1)*0.08;
    }
  }
  updatePanel();
  render();
  requestAnimationFrame(t=>{
    last = t;
    log('Autonomous CST-driven run started. Momentum flux tracers show energy transport direction.');
    loop(t);
  });
})();
</script>
</body>
</html>
