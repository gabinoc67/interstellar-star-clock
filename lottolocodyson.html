<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>10-Ticket Tight Coach — Prize-Weighted + Dyson + Prune/Decay</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --chip:#1e2a59;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    font-size:18px;
  }
  .wrap{
    max-width:1300px;
    margin:0 auto;
    padding:24px 16px 40px;
  }
  h1{margin:4px 0 10px;font-size:2rem}
  h2{margin:16px 0 8px;font-size:1.4rem}
  p{margin:4px 0 10px;color:var(--muted)}
  .grid{
    display:grid;
    grid-template-columns:minmax(0,1.2fr) minmax(0,1fr);
    gap:18px;
    align-items:flex-start;
  }
  .card{
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 0 0 1px rgba(0,0,0,0.4),0 10px 25px rgba(0,0,0,0.55);
  }
  textarea{
    width:100%;
    min-height:180px;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    resize:vertical;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.9rem;
    line-height:1.3;
  }
  label{display:block;font-weight:600;margin:8px 0 4px}
  .controls-row{
    display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center;
  }
  button{
    border:none;border-radius:999px;padding:10px 18px;font-size:1rem;font-weight:600;
    cursor:pointer;background:linear-gradient(135deg,var(--accent),#b4d0ff);
    color:#020415;box-shadow:0 4px 12px rgba(0,0,0,0.45);
    display:inline-flex;align-items:center;gap:6px;
  }
  button:active{transform:translateY(1px);box-shadow:0 2px 6px rgba(0,0,0,0.6)}
  .btn-secondary{background:#222a4a;color:var(--ink)}
  .badge{
    display:inline-block;padding:2px 8px;border-radius:999px;font-size:0.78rem;
    font-weight:600;background:#182044;color:var(--muted);border:1px solid var(--grid);
    margin-left:6px;
  }
  .stats{margin-top:8px;font-size:0.95rem}
  .stats-row{display:flex;flex-wrap:wrap;gap:8px;margin:4px 0}
  .pill{
    padding:3px 9px;border-radius:999px;font-size:0.8rem;border:1px solid var(--grid);background:#050816;
  }
  .pill-hot{ border-color:var(--good); color:var(--good); }
  .pill-warm{ border-color:var(--accent); color:var(--accent); }
  .pill-cold{ border-color:var(--muted); color:var(--muted); }
  .output-box{
    margin-top:10px;background:#050816;border-radius:10px;padding:10px 12px;border:1px solid var(--grid);
    font-family:ui-monospace,Consolas,monospace;font-size:1.05rem;line-height:1.45;
    max-height:420px;overflow:auto;
  }
  .ticket-line{display:flex;justify-content:space-between;align-items:center;padding:3px 0}
  .ticket-label{color:var(--muted);font-size:0.9rem;margin-right:10px}
  .ticket-numbers{letter-spacing:1px}
  .legend{margin-top:6px;font-size:0.86rem;color:var(--muted)}
  .small-note{font-size:0.8rem;color:var(--muted);margin-top:4px}
  .mini-note{font-size:0.82rem;color:var(--muted);margin-top:8px}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .controlbox{
    background:#0a0f25;border:1px solid var(--grid);border-radius:12px;padding:12px;
  }
  .kv{
    display:grid;grid-template-columns:170px 1fr;gap:8px;align-items:center;
  }
  input[type="number"], input[type="text"], select{
    width:100%;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    font-size:0.95rem;
  }
  .checkrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .checkrow label{margin:0;display:flex;gap:8px;align-items:center;color:var(--muted);font-weight:700}
  input[type="checkbox"]{transform:scale(1.15)}
  .hr{height:1px;background:var(--grid);margin:12px 0}
  .mono{font-family:ui-monospace,Consolas,monospace}

  /* Print: show only ticket block cleanly */
  @media print {
    body{background:#ffffff;color:#000000;}
    body *{visibility:hidden;}
    #ticketsBox, #ticketsBox *{visibility:visible;}
    #ticketsBox{
      position:absolute;left:0;top:0;width:100%;
      border:none;background:#ffffff;box-shadow:none;font-size:1.1rem;
      max-height:none;overflow:visible;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>10-Ticket Tight Coach</h1>
  <p>
    Uses your <strong>official draw history</strong> + <strong>prize-winning tickets</strong> to weight numbers,
    then generates <strong>10 tight lines</strong> (6/54 game). Adds <strong>Dyson Sphere bias</strong> + <strong>Prune & Decay</strong>
    to narrow and spread coverage across 10 tickets.
  </p>

  <div class="grid">
    <!-- LEFT: INPUTS -->
    <div class="card">
      <h2>1. Official Draw History</h2>
      <p>Paste recent official draws here (e.g., last 300–500 draws). One line per draw, 6 numbers per line.</p>
      <textarea id="historyInput" placeholder="Example:&#10;24 39 22 20 25 43&#10;50 39 27 23 42 44&#10;..."></textarea>

      <h2 style="margin-top:18px;">2. Prize / Jackpot Winners (pre-loaded)</h2>
      <p>These are your prize-winning lines. The coach uses them as an anchor weight.</p>
      <textarea id="winnersInput">
1 2 4 27 40 42
1 3 11 15 16 50
1 3 13 14 22 52
1 4 10 14 15 26
1 6 8 11 15 25
1 6 31 43 44 53
1 7 15 35 43 53
1 9 14 23 29 41
1 10 11 31 38 49
1 12 25 36 39 45
1 16 19 39 42 46
1 25 35 42 48 51
2 3 8 12 25 27
2 3 17 35 41 44
2 5 13 16 23 38
2 6 14 26 36 50
2 6 18 39 40 48
2 6 28 29 46 53
2 7 21 35 43 50
2 8 22 29 35 38
2 9 34 38 43 51
2 11 22 27 33 40
2 14 16 19 25 28
2 19 25 28 30 51
2 23 31 37 41 50
3 4 6 23 34 54
3 4 29 31 33 50
3 5 9 32 36 37
3 5 18 29 30 52
3 6 14 43 44 50
3 6 24 36 38 49
3 8 13 25 33 44
3 9 13 25 30 51
3 11 23 35 41 54
3 13 14 17 31 33
3 16 18 23 40 44
4 5 14 16 18 19
4 10 35 38 41 49
4 11 16 19 27 30
4 12 13 26 39 54
4 13 14 18 26 38
4 14 21 29 34 43
4 14 37 39 51 52
4 19 34 35 40 52
4 21 24 40 43 48
5 6 9 14 27 51
5 6 14 25 36 44
5 7 10 28 31 44
5 8 15 25 40 53
5 9 18 22 35 48
5 9 26 38 41 44
5 10 16 22 26 46
5 10 23 35 41 48
5 11 20 24 27 46
5 13 22 29 37 48
5 14 16 17 39 46
6 7 23 34 37 50
6 11 13 18 26 49
6 11 16 21 25 32
6 14 30 45 49 50
6 20 23 24 31 54
7 9 11 30 33 53
7 10 23 34 46 47
7 14 16 35 48 52
7 15 26 31 51 54
8 10 15 18 26 44
8 11 22 24 30 49
8 13 15 32 37 47
8 14 27 30 47 51
8 16 31 36 38 51
8 19 22 31 41 43
8 19 29 44 46 48
8 21 32 35 45 52
8 25 42 45 47 53
8 34 37 44 46 54
9 10 12 17 37 51
9 13 17 20 26 28
9 15 20 28 39 43
9 19 28 41 45 51
9 20 27 42 51 53
9 28 36 38 41 42
10 14 17 31 38 48
10 14 22 28 40 44
10 16 23 24 48 50
10 27 42 43 47 52
11 21 25 30 32 50
11 28 32 49 51 53
12 15 17 31 38 47
13 24 26 30 36 52
13 36 38 45 46 49
15 17 43 45 47 50
16 17 18 19 21 47
16 17 21 28 41 52
16 34 38 40 49 54
16 36 37 45 49 52
17 23 26 32 38 45
18 19 26 29 32 42
19 21 25 45 47 52
20 24 27 37 39 41
21 23 29 44 47 53
21 25 27 30 36 48
22 33 44 45 47 54
25 26 40 43 46 51
26 27 34 37 48 53
31 35 42 44 51 53
7 17 23 28 39 48
      </textarea>

      <h2 style="margin-top:18px;">3. Dyson + Prune/Decay Controls</h2>
      <p class="mini-note">
        These do <b>not</b> change true lottery odds. They help you <b>narrow</b> your choices and <b>spread coverage</b> across 10 tickets.
      </p>

      <div class="subgrid">
        <div class="controlbox">
          <div class="section-title" style="font-weight:800;margin-bottom:8px;">Dyson Sphere Bias (by z-score)</div>
          <div class="kv">
            <div class="hint">Capture (0–1)</div>
            <input id="dysonCapture" type="number" step="0.05" min="0" max="1" value="0.45" />
            <div class="hint">Field Amp (0–3)</div>
            <input id="dysonAmp" type="number" step="0.1" min="0" max="3" value="1.4" />
            <div class="hint">Cool Suppress (0–2)</div>
            <input id="coolSuppress" type="number" step="0.1" min="0" max="2" value="0.9" />
          </div>
          <div class="mini-note">
            Rising numbers (below-average frequency) get boosted; high-frequency (“cooling”) numbers get suppressed.
          </div>
        </div>

        <div class="controlbox">
          <div class="section-title" style="font-weight:800;margin-bottom:8px;">Prune & Decay (across 10 tickets)</div>
          <div class="kv">
            <div class="hint">Decay Rate (0–0.35)</div>
            <input id="decayRate" type="number" step="0.01" min="0" max="0.35" value="0.10" />
            <div class="hint">Decay Mode</div>
            <select id="decayMode">
              <option value="row">Decay numbers used per ticket</option>
              <option value="coverage">Extra decay for over-used numbers</option>
              <option value="both" selected>Both</option>
            </select>
            <div class="hint">Prune</div>
            <select id="pruneOn">
              <option value="off">Off</option>
              <option value="on" selected>On</option>
            </select>
            <div class="hint">Prune Thresh (0–0.25)</div>
            <input id="pruneThreshold" type="number" step="0.01" min="0" max="0.25" value="0.08" />
          </div>
          <div class="checkrow">
            <label><input id="decayTargetsOnly" type="checkbox" checked />Decay top-pool only</label>
            <label><input id="microReheat" type="checkbox" checked />Micro re-heat unused</label>
          </div>
          <div class="mini-note">
            Decay reduces repeats across the 10 lines; prune drops tiny-weight numbers so the generator stays “tight.”
          </div>
        </div>
      </div>

      <div class="controls-row">
        <button id="analyzeBtn" type="button">Analyze History</button>
        <button id="generateBtn" type="button" class="btn-secondary">Generate 10 Tight Tickets</button>
        <button id="printBtn" type="button" class="btn-secondary">Print 10 Tickets</button>
      </div>

      <div class="small-note">
        Game assumed: 6 numbers from 1–54. Duplicates across tickets are allowed, but exact copy of
        any prize line is blocked. Long sequences like 6–7–8–9 are filtered out. Dyson uses history z-scores.
      </div>
    </div>

    <!-- RIGHT: STATS + OUTPUT -->
    <div class="card">
      <h2>4. Bands & Output</h2>
      <div id="summaryBox" class="stats">
        Paste history and click <strong>Analyze History</strong> to see bands.
      </div>

      <div class="legend">
        <span class="pill pill-hot">Hot</span> top frequency &nbsp;
        <span class="pill pill-warm">Warm</span> mid &nbsp;
        <span class="pill pill-cold">Cold</span> low frequency
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Dyson z-score phases</strong> (computed from your history)</div>
        <div class="stats-row" id="phaseRow">Analyze history first.</div>
        <div class="mini-note" id="dysonExplain"></div>
      </div>

      <h2 style="margin-top:16px;">5. Generated 10-Ticket Set</h2>
      <div id="ticketsBox" class="output-box">
        Click “Generate 10 Tight Tickets” after you analyze.
      </div>

      <div class="mini-note" id="coverageBox"></div>
    </div>
  </div>
</div>

<script>
(function(){
  const N_MIN = 1;
  const N_MAX = 54;        // 6/54 game
  const TICKET_SIZE = 6;
  const NUM_TICKETS = 10;  // 10 tickets

  const historyInput = document.getElementById('historyInput');
  const winnersInput = document.getElementById('winnersInput');
  const summaryBox   = document.getElementById('summaryBox');
  const ticketsBox   = document.getElementById('ticketsBox');
  const analyzeBtn   = document.getElementById('analyzeBtn');
  const generateBtn  = document.getElementById('generateBtn');
  const printBtn     = document.getElementById('printBtn');

  // Dyson controls
  const dysonCaptureInput = document.getElementById('dysonCapture');
  const dysonAmpInput = document.getElementById('dysonAmp');
  const coolSuppressInput = document.getElementById('coolSuppress');

  // Prune/decay controls
  const decayRateInput = document.getElementById('decayRate');
  const decayModeInput = document.getElementById('decayMode');
  const pruneOnInput = document.getElementById('pruneOn');
  const pruneThresholdInput = document.getElementById('pruneThreshold');
  const decayTargetsOnlyInput = document.getElementById('decayTargetsOnly');
  const microReheatInput = document.getElementById('microReheat');

  const phaseRowEl = document.getElementById('phaseRow');
  const dysonExplainEl = document.getElementById('dysonExplain');
  const coverageBoxEl = document.getElementById('coverageBox');

  let lastStats = null;         // store stats after Analyze
  let forbiddenSet = new Set(); // exact combos not allowed (prize winners)

  // ---------- parsing ----------
  function parseCombos(text) {
    const combos = [];
    if (!text) return combos;
    const lines = text.trim().split(/\n+/);
    for (let line of lines) {
      const nums = line.trim().split(/[\s,]+/).map(x => parseInt(x,10))
        .filter(n => !isNaN(n));
      if (nums.length >= TICKET_SIZE) {
        const combo = nums.slice(0, TICKET_SIZE).sort((a,b)=>a-b);
        if (combo.every(n => n >= N_MIN && n <= N_MAX)) combos.push(combo);
      }
    }
    return combos;
  }

  function keyForCombo(combo) { return combo.join('-'); }

  // ---------- stats + z-score phases ----------
  function meanStd(values){
    const n = values.length || 1;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  function computeZPhases(freq){
    // freq is array [0..N_MAX]
    const vals = [];
    for (let n=N_MIN; n<=N_MAX; n++) vals.push(freq[n] || 0);
    const {mu, sigma} = meanStd(vals);

    const z = new Array(N_MAX+1).fill(0);
    const phases = {rising:[], neutral:[], cooling:[]};
    for (let n=N_MIN; n<=N_MAX; n++){
      const zz = (sigma>0) ? ((freq[n]-mu)/sigma) : 0;
      z[n] = zz;
      if (zz <= -0.5) phases.rising.push(n);
      else if (Math.abs(zz) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    }
    return {z, phases, mu, sigma};
  }

  // Dyson factor (same idea as your other sim)
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function clamp01(x){ return clamp(x,0,1); }

  function dysonFieldFactor(z, capture, amp, coolSuppress){
    const strength = capture * amp; // 0..3
    if (strength <= 0) return 1;

    if (z <= -0.5){
      const t = Math.min(1, (-z - 0.5) / 1.5);
      return 1 + (0.8*strength) * (0.6 + 0.4*t);
    }
    if (z >= 0.5){
      const t = Math.min(1, (z - 0.5) / 1.5);
      const sup = (coolSuppress * strength) * (0.6 + 0.4*t);
      return 1 / (1 + sup);
    }
    return 1 + 0.10*strength*(0.5 - Math.abs(z));
  }

  function median(values){
    const a = values.slice().sort((x,y)=>x-y);
    const n = a.length;
    if(!n) return 0;
    return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
  }

  // ---------- compute stats ----------
  function computeStats(historyCombos, winnerCombos) {
    const freq = new Array(N_MAX + 1).fill(0);
    const prizeBoost = new Array(N_MAX + 1).fill(0);

    historyCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) freq[n]++; }));
    winnerCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) prizeBoost[n]++; }));

    const totalHits = freq.reduce((a,b)=>a+b,0);
    const drawsCount = historyCombos.length;

    const {z, phases, mu, sigma} = computeZPhases(freq);

    // Build array of {n, freq, boost}
    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      arr.push({ n, freq:freq[n], boost:prizeBoost[n], z:z[n] });
    }
    arr.sort((a,b) => b.freq - a.freq || b.boost - a.boost || a.n - b.n);

    const hotCount  = 10;
    const warmCount = 15;
    const hot  = arr.slice(0, hotCount).map(o=>o.n);
    const warm = arr.slice(hotCount, hotCount+warmCount).map(o=>o.n);
    const cold = arr.slice(hotCount+warmCount).map(o=>o.n);

    // Base weights: history frequency + prize boost
    const weights = new Array(N_MAX + 1).fill(1);
    for (let n=N_MIN; n<=N_MAX; n++){
      const base = 1 + freq[n];
      const prizeExtra = 0.6 * prizeBoost[n];
      weights[n] = Math.max(1, base + prizeExtra);
    }

    return { freq, prizeBoost, weights, hot, warm, cold, drawsCount, totalHits, mu, sigma, z, phases };
  }

  function renderStats(stats) {
    const {freq, hot, warm, cold, drawsCount, totalHits, mu, sigma} = stats;

    function fmtList(list){ return list.length ? list.join(' ') : '(none)'; }

    summaryBox.innerHTML = `
      <div><strong>Draws analyzed:</strong> ${drawsCount}</div>
      <div><strong>Total hits counted:</strong> ${totalHits}</div>
      <div><strong>Avg hits per number:</strong> ${(mu).toFixed(2)}
        <span class="badge">σ ≈ ${(sigma).toFixed(2)}</span>
      </div>
      <div class="stats-row" style="margin-top:8px;">
        <span class="pill pill-hot"><strong>Hot</strong> ${fmtList(hot)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-warm"><strong>Warm</strong> ${fmtList(warm)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-cold"><strong>Cold</strong> ${fmtList(cold)}</span>
      </div>
    `;
  }

  function renderPhases(stats){
    const r = stats.phases.rising.length;
    const n = stats.phases.neutral.length;
    const c = stats.phases.cooling.length;
    phaseRowEl.innerHTML = `
      <span class="pill pill-hot">Rising (z≤-0.5): <b>${r}</b></span>
      <span class="pill pill-warm">Neutral (|z|&lt;0.5): <b>${n}</b></span>
      <span class="pill pill-cold">Cooling (z≥0.5): <b>${c}</b></span>
    `;
    dysonExplainEl.textContent =
      `Dyson bias uses your history z-scores: low-frequency numbers (Rising) get boosted; high-frequency (Cooling) get suppressed.`;
  }

  // ---------- ticket generation ----------
  function weightedPick(available, weights, rng) {
    let total = 0;
    for (const n of available) total += weights[n];
    if (total <= 0) return available[Math.floor(rng()*available.length)];
    let r = rng() * total;
    for (const n of available) {
      r -= weights[n];
      if (r <= 0) return n;
    }
    return available[available.length-1];
  }

  // Seeded RNG so the generator is stable per click (still looks random)
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // Detect consecutive runs (true if any run >= minLen)
  function hasSequenceRun(combo, minLen) {
    let run = 1;
    for (let i = 1; i < combo.length; i++) {
      if (combo[i] === combo[i-1] + 1) {
        run++;
        if (run >= minLen) return true;
      } else {
        run = 1;
      }
    }
    return false;
  }

  function generateTicketFromWeights(weights, rng) {
    const available = [];
    for (let n=N_MIN; n<=N_MAX; n++) available.push(n);

    const combo = [];
    for (let i=0; i<TICKET_SIZE; i++){
      const pick = weightedPick(available, weights, rng);
      combo.push(pick);
      const idx = available.indexOf(pick);
      if (idx >= 0) available.splice(idx,1);
    }
    combo.sort((a,b)=>a-b);
    return combo;
  }

  // Apply Dyson to weights (post-analysis)
  function applyDysonToWeights(baseWeights, zArr){
    const cap = clamp01(+dysonCaptureInput.value || 0);
    const amp = clamp(+dysonAmpInput.value || 0, 0, 3);
    const sup = clamp(+coolSuppressInput.value || 0, 0, 2);

    const out = baseWeights.slice();
    for (let n=N_MIN; n<=N_MAX; n++){
      const factor = dysonFieldFactor(zArr[n] || 0, cap, amp, sup);
      out[n] = Math.max(1e-6, out[n] * factor);
    }
    return out;
  }

  // Prune: drop tiny weights relative to median (optionally only in top pool)
  function pruneWeights(weights, topPoolSet){
    const pruneOn = (pruneOnInput.value === 'on');
    if(!pruneOn) return weights;

    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const vals = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      if (topPoolSet && !topPoolSet.has(n)) continue;
      vals.push(weights[n]);
    }
    const med = median(vals) || 0;
    const cut = med * threshFrac;
    if (cut <= 0) return weights;

    const out = weights.slice();
    for (let n=N_MIN; n<=N_MAX; n++){
      if (topPoolSet && !topPoolSet.has(n)) continue;
      if (out[n] < cut) out[n] = 1e-6;
    }
    return out;
  }

  // Build a "top pool" from weights (to keep lines tight)
  function makeTopPool(weights, k){
    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push([n, weights[n]]);
    arr.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const set = new Set(arr.slice(0,k).map(x=>x[0]));
    return set;
  }

  // Decay & micro re-heat between tickets
  function applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet){
    const rate = clamp(+decayRateInput.value || 0, 0, 0.35);
    const mode = decayModeInput.value || 'both';
    const decayTargetsOnly = !!decayTargetsOnlyInput.checked;
    const microReheat = !!microReheatInput.checked;

    const out = weights.slice();

    // decay numbers used in the ticket
    if (mode === 'row' || mode === 'both'){
      for (const n of ticket){
        if (decayTargetsOnly && topPoolSet && !topPoolSet.has(n)) continue;
        out[n] = Math.max(1e-6, out[n] * (1 - rate));
      }
    }

    // extra decay for over-used numbers (usageCounts based)
    if (mode === 'coverage' || mode === 'both'){
      for (let n=N_MIN; n<=N_MAX; n++){
        if (decayTargetsOnly && topPoolSet && !topPoolSet.has(n)) continue;
        const c = usageCounts[n] || 0;
        if (c >= 3){
          const extra = Math.min(0.22, rate * 0.75);
          out[n] = Math.max(1e-6, out[n] * (1 - extra));
        }
      }
    }

    // micro re-heat unused numbers (prevents dead zones)
    if (microReheat){
      const lift = rate * 0.10;
      for (let n=N_MIN; n<=N_MAX; n++){
        if (ticket.includes(n)) continue;
        if (decayTargetsOnly && topPoolSet && !topPoolSet.has(n)) continue;
        out[n] = out[n] * (1 + lift);
      }
    }

    return out;
  }

  function generateTickets(stats) {
    if (!stats) {
      ticketsBox.textContent = 'Please analyze history first.';
      return;
    }

    // 1) Start from base weights (history+prize)
    // 2) Apply Dyson shaping using z-scores from your history
    // 3) Build a top pool from shaped weights (tightness)
    // 4) Prune within that pool (optional)
    // 5) Generate 10 tickets, applying decay between tickets to spread coverage
    let weights = applyDysonToWeights(stats.weights, stats.z);

    // Tight top pool (keeps results focused)
    const TOP_POOL_K = 22; // tuned for 10-line set: 18–24 range; default 22
    const topPoolSet = makeTopPool(weights, TOP_POOL_K);

    // prune within pool
    weights = pruneWeights(weights, topPoolSet);

    // optional: enforce pool tightness by downweighting outside pool
    // (keeps “tight coach” feel)
    for (let n=N_MIN; n<=N_MAX; n++){
      if (!topPoolSet.has(n)) weights[n] *= 0.35;
    }

    const tickets = [];
    const seen = new Set(forbiddenSet); // include forbidden prize combos

    const usageCounts = new Array(N_MAX+1).fill(0);
    const rng = mulberry32((Date.now() ^ (Math.random()*1e9)) >>> 0);

    let attempts = 0;
    while (tickets.length < NUM_TICKETS && attempts < 6000) {
      attempts++;

      const ticket = generateTicketFromWeights(weights, rng);
      const key = keyForCombo(ticket);

      // Block exact prize lines
      if (seen.has(key)) continue;

      // Block sequences: avoid any run of 3+ consecutive numbers
      if (hasSequenceRun(ticket, 3)) continue;

      // Soft diversity check: avoid near-duplicates (share 5/6 numbers)
      let tooSimilar = false;
      for (const t of tickets){
        let common = 0;
        for (const n of ticket) if (t.includes(n)) common++;
        if (common >= 5){ tooSimilar = true; break; }
      }
      if (tooSimilar) continue;

      // accept
      seen.add(key);
      tickets.push(ticket);

      // update usage + decay between tickets
      for (const n of ticket) usageCounts[n]++;

      weights = applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet);
      weights = pruneWeights(weights, topPoolSet);
    }

    if (!tickets.length){
      ticketsBox.textContent = 'No tickets generated (too many constraints / too little randomness).';
      return;
    }

    const lines = tickets.map((t,i)=> {
      return `
        <div class="ticket-line">
          <span class="ticket-label">#${(i+1).toString().padStart(2,'0')}</span>
          <span class="ticket-numbers">${t.join('  ')}</span>
        </div>
      `;
    }).join('');
    ticketsBox.innerHTML = lines;

    // Coverage summary across the 10 tickets
    const used = new Set();
    tickets.forEach(t => t.forEach(n => used.add(n)));
    const usedCount = used.size;

    // show topPool coverage
    let inPool = 0;
    used.forEach(n => { if (topPoolSet.has(n)) inPool++; });

    // show most-used numbers in the 10 tickets
    const freq10 = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      if (usageCounts[n]>0) freq10.push([n, usageCounts[n]]);
    }
    freq10.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const topUsed = freq10.slice(0,10).map(([n,c])=>`${n}(${c})`).join('  ');

    coverageBoxEl.innerHTML =
      `<div><b>10-ticket coverage:</b> unique numbers used = <b>${usedCount}</b> (out of 54)</div>` +
      `<div><b>Inside top-pool(22):</b> used = <b>${inPool}</b> / 22</div>` +
      `<div class="mono"><b>Most repeated:</b> ${topUsed || '—'}</div>`;
  }

  // ---------- UI events ----------
  analyzeBtn.addEventListener('click', () => {
    const historyCombos = parseCombos(historyInput.value);
    const winnerCombos  = parseCombos(winnersInput.value);

    forbiddenSet = new Set();
    winnerCombos.forEach(c => forbiddenSet.add(keyForCombo(c)));

    if (!historyCombos.length){
      summaryBox.innerHTML = '<span style="color:var(--bad);">No valid history draws detected. Paste some lines first.</span>';
      phaseRowEl.textContent = 'Analyze history first.';
      dysonExplainEl.textContent = '';
      return;
    }

    lastStats = computeStats(historyCombos, winnerCombos);
    renderStats(lastStats);
    renderPhases(lastStats);

    ticketsBox.textContent = 'History analyzed. Now click “Generate 10 Tight Tickets”.';
    coverageBoxEl.textContent = '';
  });

  generateBtn.addEventListener('click', () => {
    generateTickets(lastStats);
  });

  // Auto-refresh tickets if already analyzed + user changes Dyson/decay settings
  function maybeRefresh(){
    // Only regenerate if tickets already exist and analysis done
    if (!lastStats) return;
    const txt = (ticketsBox.textContent || '').trim();
    if (!txt || txt.includes('Generate 10 Tight Tickets') || txt.includes('History analyzed')) return;
    generateTickets(lastStats);
  }

  [
    dysonCaptureInput, dysonAmpInput, coolSuppressInput,
    decayRateInput, decayModeInput, pruneOnInput, pruneThresholdInput,
    decayTargetsOnlyInput, microReheatInput
  ].forEach(el=>{
    el.addEventListener('input', maybeRefresh);
    el.addEventListener('change', maybeRefresh);
  });

  // Print just the 10-ticket block
  printBtn.addEventListener('click', () => {
    const txt = ticketsBox.textContent.trim();
    if (!txt || txt.includes('Generate 10 Tight Tickets') || txt.includes('History analyzed')) {
      alert('Generate your 10 tickets first before printing.');
      return;
    }
    window.print();
  });

})();
</script>
</body>
</html>
