<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wave Forecast — Next High Peaks (Dyson + Prune/Decay • $20 Budget Tuned)</title>
<style>
  :root{
    --bg:#0b1020;--ink:#eaf0ff;--mut:#9fb0d0;--panel:#121936;--line:#223062;--pill:#0d1a3b;
    --good:#24d17e;--warn:#ffd166;--bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:1150px;margin:0 auto;padding:20px}
  h1{margin:0 0 10px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{cursor:pointer;font-weight:800;border-radius:12px;border:1px solid var(--line);padding:12px 14px}
  .primary{background:linear-gradient(180deg,#1e90ff,#1672cc);border-color:#1672cc;color:#fff}
  .ghost{background:transparent;color:var(--ink)}
  .miniBtn{padding:10px 12px;border-radius:10px}
  pre{white-space:pre-wrap;word-break:break-word;background:#0f1533;border:1px solid var(--line);border-radius:12px;padding:12px;min-height:140px}
  .hint{color:var(--mut);font-size:.95rem}
  .grid{display:grid;gap:12px}
  .two{grid-template-columns:1fr 1fr}
  .three{grid-template-columns:1fr 1fr 1fr}
  .pill{display:inline-block;background:var(--pill);border:1px solid #2a386f;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;font-weight:700}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .quote{font-style:italic;color:#cfe2ff}
  input[type="text"],input[type="number"],select{
    flex:1;min-width:160px;background:#0f1533;color:var(--ink);
    border:1px solid var(--line);border-radius:10px;padding:12px
  }
  select{min-width:180px}
  .caps{text-transform:uppercase;letter-spacing:.02em;font-weight:700}
  .tiny{font-size:.9rem}
  .tag{display:inline-block;border:1px dashed #2a386f;border-radius:999px;padding:2px 8px;margin:4px 6px 0 0}
  .note{font-size:.9rem;color:#a9b7e1;margin-top:6px}
  .kv{display:grid;grid-template-columns:190px 1fr;gap:8px;align-items:center}
  .section-title{font-weight:800;margin-top:6px}
  .split{display:grid;grid-template-columns:1fr 220px;gap:10px;align-items:center}
  .mini{font-size:.85rem;color:#a9b7e1}
  .svgbox{display:flex;justify-content:center}
  .checkrow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .checkrow label{display:flex;align-items:center;gap:8px;color:var(--mut);font-weight:700}
  input[type="checkbox"]{transform:scale(1.15)}
  .badge{display:inline-block;background:#0f1533;border:1px solid #2a386f;border-radius:999px;padding:4px 10px;font-weight:800}
  .disabled{opacity:.65}
</style>
</head>
<body>
<div class="wrap">
  <h1>Wave Forecast — Next High Peaks (Dyson + Prune/Decay)</h1>

  <div class="panel">
    <div class="hint"><b>What this does (honest)</b></div>
    <p class="quote">
      This does <b>not</b> change the lottery’s true odds. It helps you <b>narrow</b> to a model-based pool
      and <b>spread coverage</b> across many lines (less duplication, more organized exploration).
    </p>

    <!-- Budget / Rows -->
    <div class="panel" style="margin-top:10px">
      <div class="section-title">Budget Mode (tuned for your “$20 per draw”)</div>
      <div class="grid two" style="margin-top:8px">
        <div class="panel">
          <div class="kv">
            <div class="hint">Budget (per draw)</div>
            <input id="budget" type="number" min="1" step="1" value="20" />
            <div class="hint">Cost per line</div>
            <input id="lineCost" type="number" min="0.25" step="0.25" value="1" />
            <div class="hint">Use Budget → set Rows automatically</div>
            <select id="budgetMode">
              <option value="on" selected>ON (recommended)</option>
              <option value="off">OFF (manual rows)</option>
            </select>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="preset20" class="miniBtn primary" style="width:160px">Preset: $20</button>
            <button id="preset10" class="miniBtn ghost" style="width:140px">Preset: $10</button>
            <button id="preset40" class="miniBtn ghost" style="width:140px">Preset: $40</button>
          </div>

          <div class="note" id="budgetInfo" style="margin-top:10px"></div>
        </div>

        <div class="panel">
          <div class="hint"><b>Rows generated</b></div>
          <div style="margin-top:10px;font-size:1.05rem">
            Rows (lines): <span class="badge" id="rowsBadge">20</span>
          </div>
          <div class="mini" style="margin-top:10px">
            If your lottery uses a different line price, just change “Cost per line.”
            Budget Mode will automatically compute rows = floor(budget / cost).
          </div>
        </div>
      </div>
    </div>

    <!-- Inputs Row 1 -->
    <div class="row" style="margin-top:12px">
      <label for="lastDraw" class="caps tiny">Last draw (6 numbers):</label>
      <input id="lastDraw" type="text" placeholder="e.g., 4 10 12 15 28 54" />
      <button id="applyLast" class="primary">Apply Last Draw</button>
      <button id="resetLast" class="ghost">Reset</button>
    </div>
    <div id="lastDrawView" class="note"></div>

    <!-- Inputs Row 2 -->
    <div class="row" style="margin-top:10px">
      <label for="lockNums" class="caps tiny">Lock (force include ≤6):</label>
      <input id="lockNums" type="text" placeholder="e.g., 28 44 or 4,10,12" />
      <label for="pairBoosts" class="caps tiny">Pair boosts (comma list A-B):</label>
      <input id="pairBoosts" type="text" placeholder="e.g., 28-44, 12-15" />
    </div>

    <!-- Knobs row -->
    <div class="grid three" style="margin-top:10px">
      <div class="panel">
        <div class="section-title">Generator</div>
        <div class="kv">
          <div class="hint">Rows (manual override)</div>
          <input id="rowsN" type="number" min="5" max="200" value="20" />
          <div class="hint">Top Pool</div>
          <input id="topPool" type="number" min="6" max="54" value="22" />
          <div class="hint">Seed</div>
          <input id="seed" type="number" value="12345" />
        </div>
        <div class="mini" style="margin-top:8px">
          For $20/draw, a good narrowing range is <b>Top Pool 18–24</b>. Default here is <b>22</b>.
        </div>
      </div>

      <div class="panel">
        <div class="section-title">Coverage & Cohesion</div>
        <div class="kv">
          <div class="hint">Coverage Target (per #)</div>
          <input id="coverTarget" type="number" min="1" max="6" value="2" />
          <div class="hint">Cohesion (0–3)</div>
          <input id="cohesion" type="number" step="0.1" min="0" max="3" value="1.25" />
          <div class="hint">Pair Boost (0–4)</div>
          <input id="pairLambda" type="number" step="0.1" min="0" max="4" value="2.2" />
        </div>
        <div class="mini" style="margin-top:8px">
          For 20 lines: coverage target <b>2</b> keeps diversity without scattering too much.
        </div>
      </div>

      <div class="panel">
        <div class="section-title">Penalties</div>
        <div class="kv">
          <div class="hint">Last Draw Penalty (0–1)</div>
          <input id="penaltyFactor" type="number" step="0.05" min="0" max="1" value="0.35" />
          <div class="hint">Neutral Tilt (−1..+1)</div>
          <input id="neutralTilt" type="number" step="0.1" min="-1" max="1" value="0.0" />
          <div class="hint">Rising Bonus (0–2)</div>
          <input id="risingBonus" type="number" step="0.1" min="0" max="2" value="0.55" />
        </div>
        <div class="mini" style="margin-top:8px">
          For narrowing, rising bonus a bit higher (<b>0.5–0.7</b>) is reasonable.
        </div>
      </div>
    </div>

    <!-- Dyson + prune/decay -->
    <div class="grid two" style="margin-top:12px">
      <div class="panel">
        <div class="section-title">Dyson Sphere Field (narrowing bias)</div>
        <div class="split">
          <div>
            <div class="kv">
              <div class="hint">Capture Fraction (0–1)</div>
              <input id="dysonCapture" type="number" step="0.05" min="0" max="1" value="0.45" />
              <div class="hint">Field Amplifier (0–3)</div>
              <input id="dysonAmp" type="number" step="0.1" min="0" max="3" value="1.4" />
              <div class="hint">Cooling Suppression (0–2)</div>
              <input id="coolSuppress" type="number" step="0.1" min="0" max="2" value="0.9" />
            </div>
            <div class="mini" style="margin-top:8px">
              Your $20/draw “narrowing” tune: capture <b>0.45</b>, amp <b>1.4</b>, cooling suppress <b>0.9</b>.
            </div>
          </div>
          <div class="svgbox">
            <svg id="dysonSvg" width="200" height="200" viewBox="0 0 200 200" aria-label="Dyson capture">
              <defs>
                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                  <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                </filter>
              </defs>
              <circle cx="100" cy="100" r="72" fill="none" stroke="#223062" stroke-width="14"/>
              <path id="dysonArc" d="" fill="none" stroke="#1e90ff" stroke-width="14" stroke-linecap="round" filter="url(#glow)"/>
              <circle cx="100" cy="100" r="40" fill="#0f1533" stroke="#223062" stroke-width="2"/>
              <text id="dysonPct" x="100" y="104" text-anchor="middle" font-size="18" fill="#eaf0ff" font-weight="800">45%</text>
              <text x="100" y="126" text-anchor="middle" font-size="11" fill="#9fb0d0" font-weight="700">CAPTURE</text>
            </svg>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="section-title">Prune & Decay (coverage across 20 lines)</div>
        <div class="kv">
          <div class="hint">Decay Rate (0–0.35)</div>
          <input id="decayRate" type="number" step="0.01" min="0" max="0.35" value="0.10" />
          <div class="hint">Decay Mode</div>
          <select id="decayMode">
            <option value="row">Decay numbers used in each row</option>
            <option value="coverage">Extra decay for over-covered targets</option>
            <option value="both" selected>Both</option>
          </select>
          <div class="hint">Prune</div>
          <select id="pruneOn">
            <option value="off">Off</option>
            <option value="on" selected>On</option>
          </select>
          <div class="hint">Prune Threshold (0–0.25)</div>
          <input id="pruneThreshold" type="number" step="0.01" min="0" max="0.25" value="0.08" />
        </div>
        <div class="checkrow" style="margin-top:10px">
          <label><input id="decayTargetsOnly" type="checkbox" checked />Apply decay to Top-Pool only</label>
          <label><input id="microReheat" type="checkbox" checked />Micro re-heat unused numbers</label>
        </div>
        <div class="mini" style="margin-top:8px">
          For 20 lines: decay around <b>0.08–0.12</b> helps prevent repeats and spreads your pool.
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="gen" class="primary" style="width:200px">Generate</button>
      <button id="clear" class="ghost" style="width:120px">Clear</button>
    </div>
  </div>

  <div class="grid two" style="margin-top:14px">
    <div class="panel">
      <div class="hint"><b>Rising (Next-peak candidates)</b></div>
      <div id="rising" class="mono" style="margin-top:6px">—</div>
      <div class="mini" id="risingNote" style="margin-top:8px"></div>
    </div>
    <div class="panel">
      <div class="hint"><b>Phase summary</b> (count of numbers in each phase)</div>
      <div id="phases" style="margin-top:6px">—</div>
      <div id="meta" class="hint" style="margin-top:10px"></div>
      <div id="dysonMeta" class="mini" style="margin-top:10px"></div>
    </div>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Primary Pick</b> (top 6 by current weight)</div>
    <pre id="primary">—</pre>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Forecast Set</b> (<span id="rowsCount">20</span> rows)</div>
    <pre id="out">—</pre>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Coverage Stats</b> (Top-Pool coverage counts)</div>
    <pre id="coverage">—</pre>
    <div class="note" id="coverageNote"></div>
  </div>
</div>

<script>
(() => {
  // =========================
  // Data: cumulative counts
  // =========================
  const COUNTS_TEXT = `
number count_in_group 26-331, 4-318, 31 318 19 317 27 312 8 310 5 308 21 304 10 302 16 297 22 294 39 294 14 293 38 293 35 292 15 292 7 292 9 290 18 289 33 287 32 285 44 285 41 282 6 280 3 280 28 279 29 278 12 277 40 276 37 275 49 275 13 274 17 273 42 272 34 270 43 269 36 266 24 264 20 264 1 261 2 261 25 258 11 252 23 249 30 247 47 238 46 229 48 229 45 222 50 205 52 193 54 179 51 158 53 157
`.trim();

  // =========================
  // UI elements
  // =========================
  const genBtn = document.getElementById('gen');
  const clrBtn = document.getElementById('clear');

  const risingEl = document.getElementById('rising');
  const risingNoteEl = document.getElementById('risingNote');

  const phasesEl = document.getElementById('phases');
  const metaEl = document.getElementById('meta');
  const dysonMetaEl = document.getElementById('dysonMeta');

  const primaryEl = document.getElementById('primary');
  const outEl = document.getElementById('out');

  const coverageEl = document.getElementById('coverage');
  const coverageNoteEl = document.getElementById('coverageNote');

  const rowsCountEl = document.getElementById('rowsCount');

  const lastDrawInput = document.getElementById('lastDraw');
  const applyLastBtn = document.getElementById('applyLast');
  const resetLastBtn = document.getElementById('resetLast');
  const lastDrawView = document.getElementById('lastDrawView');

  const lockNumsInput = document.getElementById('lockNums');
  const pairBoostsInput = document.getElementById('pairBoosts');

  const rowsNInput = document.getElementById('rowsN');
  const topPoolInput = document.getElementById('topPool');
  const seedInput = document.getElementById('seed');

  const coverTargetInput = document.getElementById('coverTarget');
  const cohesionInput = document.getElementById('cohesion');
  const pairLambdaInput = document.getElementById('pairLambda');

  const penaltyFactorInput = document.getElementById('penaltyFactor');
  const neutralTiltInput = document.getElementById('neutralTilt');
  const risingBonusInput = document.getElementById('risingBonus');

  // Dyson + prune/decay controls
  const dysonCaptureInput = document.getElementById('dysonCapture');
  const dysonAmpInput = document.getElementById('dysonAmp');
  const coolSuppressInput = document.getElementById('coolSuppress');

  const decayRateInput = document.getElementById('decayRate');
  const decayModeInput = document.getElementById('decayMode');
  const pruneOnInput = document.getElementById('pruneOn');
  const pruneThresholdInput = document.getElementById('pruneThreshold');
  const decayTargetsOnlyInput = document.getElementById('decayTargetsOnly');
  const microReheatInput = document.getElementById('microReheat');

  // Budget
  const budgetInput = document.getElementById('budget');
  const lineCostInput = document.getElementById('lineCost');
  const budgetModeInput = document.getElementById('budgetMode');
  const budgetInfoEl = document.getElementById('budgetInfo');
  const rowsBadgeEl = document.getElementById('rowsBadge');
  const preset20Btn = document.getElementById('preset20');
  const preset10Btn = document.getElementById('preset10');
  const preset40Btn = document.getElementById('preset40');

  // Dyson SVG
  const dysonArc = document.getElementById('dysonArc');
  const dysonPct = document.getElementById('dysonPct');

  // =========================
  // Helpers
  // =========================
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function clamp01(x){ return clamp(x,0,1); }

  function parseCounts(text){
    const pairs = [];
    const tokens = text.replace(/[,;]/g,' ').split(/\s+/);
    for(let i=0;i<tokens.length;i++){
      const t = tokens[i];
      if(/^\d+-\d+$/.test(t)){ // "n-m"
        const [n,c] = t.split('-').map(Number);
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
        continue;
      }
      if(/^\d+$/.test(t) && i+1<tokens.length && /^\d+$/.test(tokens[i+1])){ // "n m"
        const n = +t, c = +tokens[i+1];
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
      }
    }
    const map = new Map();
    pairs.forEach(([n,c])=>map.set(n,c));
    for(let n=1;n<=54;n++) if(!map.has(n)) map.set(n,0);
    return map;
  }

  function meanStd(values){
    const n = values.length;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  function classifyPhases(countMap){
    const entries = Array.from(countMap.entries());
    entries.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const counts = entries.map(e=>e[1]);
    const {mu, sigma} = meanStd(counts);

    const phases = { rising: [], neutral: [], cooling: [] };
    const zmap = new Map();

    entries.forEach(([n,c])=>{
      const z = sigma>0 ? (c - mu)/sigma : 0;
      zmap.set(n, z);
      if(z <= -0.5) phases.rising.push(n);
      else if(Math.abs(z) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    });

    return {phases, zmap, mu, sigma};
  }

  function nextPeakProb(z){
    const a = 2.2, b = 0.0;
    return 1 / (1 + Math.exp(a * (z - b)));
  }

  function parseSix(str){
    if(!str) return [];
    const nums = str.split(/[^0-9]+/).filter(Boolean).map(x=>+x);
    const uniq = Array.from(new Set(nums.filter(n=>n>=1 && n<=54)));
    return uniq.length === 6 ? uniq.slice(0,6) : [];
  }

  function parseLocks(str){
    if(!str) return [];
    const nums = str.split(/[^0-9]+/).filter(Boolean).map(x=>+x);
    const uniq = Array.from(new Set(nums.filter(n=>n>=1 && n<=54)));
    return uniq.slice(0,6);
  }

  function parsePairs(str){
    const res = [];
    if(!str) return res;
    const chunks = str.split(/[,]+/).map(s=>s.trim()).filter(Boolean);
    for(const ch of chunks){
      const m = ch.match(/^\s*(\d+)\s*[-:–]\s*(\d+)\s*$/);
      if(m){
        const a = +m[1], b = +m[2];
        if(a>=1&&a<=54&&b>=1&&b<=54&&a!==b){
          res.push([Math.min(a,b), Math.max(a,b)]);
        }
      }
    }
    return res;
  }

  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function weightedPick(localMap, rng){
    let total = 0;
    for(const w of localMap.values()) total += w;
    if(total<=0) return null;
    let r = rng()*total;
    for(const [n,w] of localMap.entries()){
      r -= w; if(r<=0) return n;
    }
    return localMap.keys().next().value;
  }

  function median(values){
    const a = values.slice().sort((x,y)=>x-y);
    const n = a.length;
    if(!n) return 0;
    return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
  }

  // Dyson arc rendering
  function polarToCartesian(cx, cy, r, angDeg){
    const a = (angDeg-90) * Math.PI/180;
    return {x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)};
  }
  function arcPath(cx, cy, r, startDeg, endDeg){
    const s = polarToCartesian(cx, cy, r, endDeg);
    const e = polarToCartesian(cx, cy, r, startDeg);
    const large = (endDeg - startDeg) <= 180 ? 0 : 1;
    return `M ${e.x.toFixed(2)} ${e.y.toFixed(2)} A ${r} ${r} 0 ${large} 1 ${s.x.toFixed(2)} ${s.y.toFixed(2)}`;
  }
  function updateDysonViz(){
    const cap = clamp01(+dysonCaptureInput.value || 0);
    dysonPct.textContent = Math.round(cap*100) + '%';
    const end = Math.max(1, cap*360);
    dysonArc.setAttribute('d', arcPath(100,100,72,0,end));
  }

  // =========================
  // Core modeling
  // =========================
  const COUNT_MAP = parseCounts(COUNTS_TEXT);
  const {phases, zmap, mu, sigma} = classifyPhases(COUNT_MAP);

  function dysonFieldFactor(z, capture, amp, coolSuppress){
    const strength = capture * amp; // 0..3
    if(strength <= 0) return 1;

    if(z <= -0.5){
      const t = Math.min(1, (-z - 0.5) / 1.5);
      return 1 + (0.8*strength) * (0.6 + 0.4*t);
    }
    if(z >= 0.5){
      const t = Math.min(1, (z - 0.5) / 1.5);
      const sup = (coolSuppress * strength) * (0.6 + 0.4*t);
      return 1 / (1 + sup);
    }
    return 1 + 0.10*strength*(0.5 - Math.abs(z));
  }

  function buildBaseWeights(opts){
    const {
      penaltySet=new Set(), penaltyFactor=0.35, neutralTilt=0.0, risingBonus=0.55,
      dysonCapture=0.45, dysonAmp=1.4, coolSuppress=0.9
    } = opts;

    const weights = new Map();
    for(let n=1;n<=54;n++){
      const z = zmap.get(n) ?? 0;
      let w = Math.max(0.0001, nextPeakProb(z));

      if(Math.abs(z) < 0.5) w *= (1 + neutralTilt);
      if(z <= -0.5) w *= (1 + risingBonus);

      w *= dysonFieldFactor(z, dysonCapture, dysonAmp, coolSuppress);

      if(penaltySet.has(n)) w *= penaltyFactor;

      weights.set(n, Math.max(0.000001, w));
    }
    return weights;
  }

  function topPoolFromWeights(weights, k){
    return new Set(
      Array.from(weights.entries())
        .sort((a,b)=>b[1]-a[1] || a[0]-b[0])
        .slice(0,k)
        .map(([n])=>n)
    );
  }

  function makePairMap(pairs){
    const m = new Map();
    for(const [a,b] of pairs){
      if(!m.has(a)) m.set(a, new Set());
      if(!m.has(b)) m.set(b, new Set());
      m.get(a).add(b);
      m.get(b).add(a);
    }
    return m;
  }

  function applyDecayAndPrune(state){
    const {
      baseWeights, rowNums, targetSet, coverageMap,
      decayRate, decayMode, pruneOn, pruneThreshold,
      decayTargetsOnly, microReheat
    } = state;

    const rate = clamp(decayRate, 0, 0.35);

    // decay numbers used in the row
    if(decayMode === 'row' || decayMode === 'both'){
      for(const n of rowNums){
        if(decayTargetsOnly && !targetSet.has(n)) continue;
        baseWeights.set(n, Math.max(0.000001, baseWeights.get(n) * (1 - rate)));
      }
    }

    // extra decay for over-covered targets
    if(decayMode === 'coverage' || decayMode === 'both'){
      for(const n of targetSet){
        const c = coverageMap.get(n) || 0;
        if(c >= 3){
          const extra = Math.min(0.22, rate * 0.75);
          baseWeights.set(n, Math.max(0.000001, baseWeights.get(n) * (1 - extra)));
        }
      }
    }

    // micro re-heat unused numbers (prevents dead zones)
    if(microReheat){
      const lift = rate * 0.10;
      for(let n=1;n<=54;n++){
        if(rowNums.includes(n)) continue;
        if(decayTargetsOnly && !targetSet.has(n)) continue;
        baseWeights.set(n, baseWeights.get(n) * (1 + lift));
      }
    }

    // prune tiny weights relative to median in the target pool
    if(pruneOn){
      const poolVals = [];
      for(const n of targetSet) poolVals.push(baseWeights.get(n) || 0);
      const med = median(poolVals) || 0;
      const cut = clamp(pruneThreshold, 0, 0.25);
      const thresh = med * cut;
      if(thresh > 0){
        for(const n of targetSet){
          const w = baseWeights.get(n) || 0;
          if(w < thresh) baseWeights.set(n, 0.000001);
        }
      }
    }
  }

  function buildRow(params){
    const {
      rng, baseWeights, locked, pairMap, coverageMap, targetSet, coverTarget,
      cohesionLambda, pairLambda
    } = params;

    const pick = new Set(locked);
    if(pick.size > 6) return null;
    const chosen = new Set(locked);

    const currentWeights = () => {
      const wm = new Map();
      for(const [n,w0] of baseWeights.entries()){
        if(chosen.has(n)) continue;
        let w = w0;

        if(targetSet.has(n)){
          const have = coverageMap.get(n) || 0;
          const need = Math.max(0, coverTarget - have);
          if(need>0) w *= (1 + 0.9 * Math.sqrt(need));
        }

        const partners = pairMap.get(n);
        if(partners){
          let links = 0;
          for(const p of partners) if(chosen.has(p)) links++;
          if(links>0) w *= (1 + links * pairLambda);
        }

        if(cohesionLambda > 0 && chosen.size>0){
          let avgz = 0;
          for(const c of chosen) avgz += (zmap.get(c)||0);
          avgz /= chosen.size;
          const z = zmap.get(n)||0;
          const dz = Math.abs(z - avgz);
          w *= 1 / (1 + cohesionLambda * dz);
        }

        wm.set(n, Math.max(0.000001, w));
      }
      return wm;
    };

    while(pick.size < 6){
      const wm = currentWeights();
      if(wm.size===0) break;
      const chosenN = weightedPick(wm, rng);
      if(chosenN==null) break;
      pick.add(chosenN);
      chosen.add(chosenN);
    }
    if(pick.size < 6) return null;
    return Array.from(pick).sort((a,b)=>a-b);
  }

  function generateSet(options){
    const {
      rowsN, lastDrawSet, penaltyFactor, neutralTilt, risingBonus,
      locks, pairs, topPoolK, coverTarget, cohesionLambda, pairLambda, seed,
      dysonCapture, dysonAmp, coolSuppress,
      decayRate, decayMode, pruneOn, pruneThreshold, decayTargetsOnly, microReheat
    } = options;

    const rng = mulberry32(seed>>>0);
    const baseWeights = buildBaseWeights({
      penaltySet: lastDrawSet,
      penaltyFactor, neutralTilt, risingBonus,
      dysonCapture, dysonAmp, coolSuppress
    });

    const targetSet = topPoolFromWeights(baseWeights, topPoolK);
    const pairMap = makePairMap(pairs);

    const coverageMap = new Map();
    for(const t of targetSet) coverageMap.set(t, 0);

    const seenRows = new Set();
    const rows = [];
    let guard = 0;

    while(rows.length < rowsN && guard++ < rowsN*260){
      const row = buildRow({
        rng, baseWeights,
        locked: locks, pairMap,
        coverageMap, targetSet,
        coverTarget, cohesionLambda,
        pairLambda
      });
      if(!row) continue;

      const sig = row.join('-');
      if(seenRows.has(sig)) continue;

      // update coverage
      for(const n of row){
        if(targetSet.has(n)) coverageMap.set(n, (coverageMap.get(n)||0) + 1);
      }

      // shape next rows
      applyDecayAndPrune({
        baseWeights, rowNums: row, targetSet, coverageMap,
        decayRate, decayMode, pruneOn, pruneThreshold,
        decayTargetsOnly, microReheat
      });

      rows.push(sig);
      seenRows.add(sig);
    }

    // Primary pick: current top6 by weight
    const top6 = Array.from(baseWeights.entries())
      .sort((a,b)=>b[1]-a[1] || a[0]-b[0])
      .slice(0,6)
      .map(([n])=>n)
      .sort((a,b)=>a-b);

    return {rows, top6, targetSet, coverageMap};
  }

  // =========================
  // Phase rendering
  // =========================
  function renderPhaseSummary(ph){
    phasesEl.innerHTML = `
      <div class="pill ok">Rising: ${ph.rising.length}</div>
      <div class="pill warn">Neutral: ${ph.neutral.length}</div>
      <div class="pill bad">Cooling: ${ph.cooling.length}</div>
    `;
  }
  function renderRisingList(ph){
    const list = ph.rising.slice().sort((a,b)=>COUNT_MAP.get(a)-COUNT_MAP.get(b) || a-b);
    risingEl.textContent = list.length ? list.join(' ') : '—';
    risingNoteEl.textContent = list.length ? `Rising list sorted by lowest cumulative count first.` : '';
  }
  renderPhaseSummary(phases);
  renderRisingList(phases);
  metaEl.textContent =
    `Mean (μ) ≈ ${mu.toFixed(1)}, σ ≈ ${sigma.toFixed(1)}. ` +
    `Phases by z: Rising (z ≤ −0.5), Neutral (|z| < 0.5), Cooling (z ≥ +0.5).`;

  // =========================
  // Last draw UI
  // =========================
  let lastDrawSet = new Set();

  function showLastDraw(list){
    if(list.length === 6){
      lastDrawView.innerHTML = `Penalizing (cooling after last draw): ` + list.map(n=>`<span class="tag">${n}</span>`).join(' ');
    }else{
      lastDrawView.textContent = 'Enter exactly 6 numbers (1–54), separated by spaces or commas.';
    }
  }

  applyLastBtn.addEventListener('click', ()=>{
    const list = parseSix(lastDrawInput.value);
    if(list.length === 6){
      lastDrawSet = new Set(list);
      showLastDraw(list);
      runOnce();
    }else{
      showLastDraw([]);
      alert('Please enter exactly 6 valid numbers between 1 and 54.');
    }
  });

  resetLastBtn.addEventListener('click', ()=>{
    lastDrawSet = new Set();
    lastDrawInput.value = '';
    showLastDraw([]);
    runOnce();
  });

  // =========================
  // Budget mode
  // =========================
  function computeRowsFromBudget(){
    const budget = Math.max(1, +budgetInput.value || 20);
    const cost = Math.max(0.01, +lineCostInput.value || 1);
    const rows = Math.max(5, Math.min(200, Math.floor(budget / cost)));
    return {budget, cost, rows};
  }

  function syncRows(){
    const mode = budgetModeInput.value;
    const {budget, cost, rows} = computeRowsFromBudget();

    if(mode === 'on'){
      rowsNInput.value = rows;
      rowsNInput.classList.add('disabled');
      rowsNInput.setAttribute('disabled','disabled');
    }else{
      rowsNInput.classList.remove('disabled');
      rowsNInput.removeAttribute('disabled');
    }

    rowsBadgeEl.textContent = String(mode === 'on' ? rows : (+rowsNInput.value||20));
    budgetInfoEl.textContent = (mode === 'on')
      ? `Budget mode ON → rows = floor(${budget} / ${cost}) = ${rows} lines.`
      : `Budget mode OFF → using manual “Rows” input. Budget is informational only.`;
  }

  [budgetInput, lineCostInput, budgetModeInput].forEach(el=>{
    el.addEventListener('input', ()=>{ syncRows(); runOnce(); });
    el.addEventListener('change', ()=>{ syncRows(); runOnce(); });
  });

  rowsNInput.addEventListener('input', ()=>{
    syncRows();
    runOnce();
  });

  preset20Btn.addEventListener('click', ()=>{
    budgetInput.value = 20;
    syncRows(); runOnce();
  });
  preset10Btn.addEventListener('click', ()=>{
    budgetInput.value = 10;
    syncRows(); runOnce();
  });
  preset40Btn.addEventListener('click', ()=>{
    budgetInput.value = 40;
    syncRows(); runOnce();
  });

  // Dyson viz listeners
  [dysonCaptureInput, dysonAmpInput, coolSuppressInput].forEach(el=>{
    el.addEventListener('input', ()=>{ updateDysonViz(); runOnce(); });
  });

  // =========================
  // Main run
  // =========================
  function runOnce(){
    syncRows();

    const rowsN = Math.max(5, Math.min(200, +rowsNInput.value||20));
    const topPoolK = clamp(+topPoolInput.value||22, 6, 54);
    const seed = (+seedInput.value||12345) >>> 0;

    const locks = parseLocks(lockNumsInput.value);
    const pairs = parsePairs(pairBoostsInput.value);

    const coverTarget = clamp(+coverTargetInput.value||2, 1, 6);
    const cohesionLambda = clamp(+cohesionInput.value||1.25, 0, 3);
    const pairLambda = clamp(+pairLambdaInput.value||2.2, 0, 4);

    const penaltyFactor = clamp(+penaltyFactorInput.value||0.35, 0, 1);
    const neutralTilt = clamp(+neutralTiltInput.value||0.0, -1, 1);
    const risingBonus = clamp(+risingBonusInput.value||0.55, 0, 2);

    const dysonCapture = clamp01(+dysonCaptureInput.value||0.45);
    const dysonAmp = clamp(+dysonAmpInput.value||1.4, 0, 3);
    const coolSuppress = clamp(+coolSuppressInput.value||0.9, 0, 2);

    const decayRate = clamp(+decayRateInput.value||0.10, 0, 0.35);
    const decayMode = decayModeInput.value || 'both';
    const pruneOn = (pruneOnInput.value === 'on');
    const pruneThreshold = clamp(+pruneThresholdInput.value||0.08, 0, 0.25);
    const decayTargetsOnly = !!decayTargetsOnlyInput.checked;
    const microReheat = !!microReheatInput.checked;

    const {rows, top6, targetSet, coverageMap} = generateSet({
      rowsN,
      lastDrawSet,
      penaltyFactor,
      neutralTilt,
      risingBonus,
      locks,
      pairs,
      topPoolK,
      coverTarget,
      cohesionLambda,
      pairLambda,
      seed,
      dysonCapture,
      dysonAmp,
      coolSuppress,
      decayRate,
      decayMode,
      pruneOn,
      pruneThreshold,
      decayTargetsOnly,
      microReheat
    });

    rowsCountEl.textContent = rowsN.toString();
    primaryEl.textContent = top6.join('-');
    outEl.textContent = rows.length ? rows.join('\n') : '—';

    // Coverage panel summary
    const targetList = Array.from(targetSet).sort((a,b)=>a-b);
    let minC = Infinity, maxC = -Infinity, sum = 0;
    const covLines = targetList.map(n=>{
      const c = coverageMap.get(n)||0;
      minC = Math.min(minC, c);
      maxC = Math.max(maxC, c);
      sum += c;
      return String(n).padStart(2,' ') + ': ' + c;
    });
    coverageEl.textContent = covLines.join('  |  ');
    const avg = targetList.length ? (sum/targetList.length) : 0;
    coverageNoteEl.textContent = targetList.length
      ? `Top-Pool size=${targetList.length}. Coverage min=${minC}, max=${maxC}, avg=${avg.toFixed(2)}.`
      : '';

    // Dyson meta
    const draws = rowsN * 6;
    const energyUnits = Math.round(draws * dysonCapture * (1 + dysonAmp*0.35) * 10);
    dysonMetaEl.textContent =
      `Dyson capture=${Math.round(dysonCapture*100)}% • amp=${dysonAmp.toFixed(1)} • ` +
      `cool-suppress=${coolSuppress.toFixed(1)} • synthetic “harvest”≈${energyUnits} units (scaled).`;
  }

  genBtn.addEventListener('click', runOnce);
  clrBtn.addEventListener('click', ()=>{
    primaryEl.textContent = '—';
    outEl.textContent = '—';
    coverageEl.textContent = '—';
    coverageNoteEl.textContent = '';
  });

  // Auto-run
  updateDysonViz();
  showLastDraw([]);
  syncRows();
  runOnce();
})();
</script>
</body>
</html>
