<!-- ======================= PART 1 / 3 ======================= -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Warp Tunnels on a 2D Disk (Earth-Centered) — Inner Expanded + Asteroidal Helix</title>
  <style>
    :root{
      --bg:#0b0f19;--panel:#0f1629;--ink:#e8ecf3;--muted:#9fb0d0;--accent:#7aa2ff;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;background:radial-gradient(1200px 800px at 20% -10%,#14203b,var(--bg));color:var(--ink)}
    .wrap{max-width:1200px;margin:24px auto;padding:16px}
    .title{font-size:28px;font-weight:800;letter-spacing:.3px;display:flex;align-items:baseline;gap:12px;flex-wrap:wrap}
    .title small{color:var(--muted);font-weight:500}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.3),inset 0 1px 0 rgba(255,255,255,.05);overflow:hidden}
    .card h2{margin:0;padding:12px 14px;font-size:16px;letter-spacing:.3px;background:linear-gradient(180deg,rgba(122,162,255,.12),rgba(122,162,255,0));border-bottom:1px solid rgba(255,255,255,.06)}
    .card .body{padding:12px 14px;display:grid;gap:10px}
    canvas{width:100%;height:600px;display:block;background:radial-gradient(900px 520px at 50% 40%,rgba(122,162,255,.06),rgba(0,0,0,0))}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center}
    label{color:var(--muted);font-size:13px}
    input[type="range"],select{width:100%;accent-color:var(--accent)}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btn{cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.1);background:rgba(122,162,255,.12);color:var(--ink);font-weight:700}
    .btn:hover{background:rgba(122,162,255,.2)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(122,162,255,.12);border:1px solid rgba(122,162,255,.4);color:var(--accent);font-size:11px;letter-spacing:.2px}
    .note{color:var(--muted);font-size:12px;line-height:1.35}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 12px;align-items:baseline}
    .kv .k{color:var(--muted);font-size:12px}
    .kv .v{font-weight:800}
    .subgrid{display:grid;grid-template-columns:1fr;gap:10px}
    .hide{display:none !important}
    @media (max-width:1100px){.grid{grid-template-columns:1fr}canvas{height:520px}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      2D Ball (Disk) → Earth-Centered Warp Tunnels
      <small>inner planets expanded • outer planets compressed • <b>Asteroidal Helix</b> tunnels</small>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Disk View — Earth at center (R is visual radius)</h2>
        <div class="body">

          <div class="cols">
            <div class="row">
              <label>Visual radius R (px)</label>
              <input id="R" type="range" min="240" max="620" value="500">
            </div>
            <div class="row">
              <label>Nonlinear map α (inner expand / outer compress)</label>
              <input id="alpha" type="range" min="0.2" max="10" step="0.01" value="4.2">
            </div>
          </div>

          <div class="cols">
            <div class="row">
              <label>Inner expansion γ (lower = more inner spread)</label>
              <input id="gamma" type="range" min="0.35" max="1.25" step="0.01" value="0.62">
            </div>
            <div class="row">
              <label>Warp factor (×c)</label>
              <input id="warp" type="range" min="0.1" max="20" step="0.1" value="3">
            </div>
          </div>

          <div class="cols">
            <div class="row">
              <label>Destination planet</label>
              <select id="dest"></select>
            </div>
            <div class="row">
              <label>Show orbits</label>
              <select id="showOrbits">
                <option value="1" selected>Yes</option>
                <option value="0">No</option>
              </select>
            </div>
          </div>

          <div class="cols">
            <div class="row">
              <label>Tunnel style</label>
              <select id="tunnelStyle">
                <option value="helix" selected>Asteroidal Helix</option>
                <option value="curve">Curved (arc)</option>
                <option value="straight">Straight (reference)</option>
              </select>
            </div>
            <div class="row">
              <label>Helix intensity (amp)</label>
              <input id="helixAmp" type="range" min="0" max="1" step="0.01" value="0.55">
            </div>
          </div>

          <div class="cols">
            <div class="row">
              <label>Helix turns (along tunnel)</label>
              <input id="helixTurns" type="range" min="1" max="60" step="1" value="24">
            </div>
            <div class="row">
              <label>Asteroid-belt focus (AU center)</label>
              <input id="beltAU" type="range" min="1.6" max="3.6" step="0.01" value="2.80">
            </div>
          </div>

          <canvas id="cv"></canvas>

          <div class="cols">
            <div class="kv">
              <div class="k">Mapping</div>
              <div class="v">
                <span class="pill">r′ = R·atan(α·(r/Rmax)^γ) / atan(α)</span>
              </div>
              <div class="k">Earth→Dest (AU)</div><div class="v" id="auDist">—</div>
              <div class="k">Tunnel length (visual AU*)</div><div class="v" id="tunLen">—</div>
              <div class="k">Est. time at warp ×c</div><div class="v" id="eta">—</div>
            </div>
            <div class="note">
              *Visual AU uses a consistent mapped scale (based on mapped 1 AU ring) so relative comparisons hold,
              even though outer space is compressed. <br>
              Drag to pan, scroll to zoom. Click <b>Engage</b> to animate along the selected tunnel.
            </div>
          </div>

          <div>
            <button class="btn" id="engage">▶ Engage Tunnel</button>
            <button class="btn" id="reset">↺ Reset View</button>
          </div>

        </div>
      </div>

      <div class="card">
        <h2>What changed (so you can see inner-planet tunnels)</h2>
        <div class="body">
          <div class="note">
            • <b>Inner expansion γ</b>: we raise the true radius fraction (r/Rmax) to γ before the atan map. When γ &lt; 1, inner radii are “stretched” apart, so Mercury/Venus/Mars tunnels stop stacking on top of each other.<br>
            • <b>Asteroidal Helix tunnel</b>: we draw a bowed centerline (like before), then apply a sinusoidal offset perpendicular to the path. The offset envelope peaks near the <b>asteroid belt AU</b> (default 2.80 AU), so the tunnel “twists” most through that region.<br>
            • This is still a qualitative visualization (not a Lambert transfer solver).
          </div>
          <div class="kv">
            <div class="k">Tip</div><div class="v">Try γ ≈ 0.55–0.70 and α ≈ 3–7 for maximum inner separation.</div>
            <div class="k">Helix clarity</div><div class="v">Increase turns for more coils; increase amp to widen the helix.</div>
          </div>
        </div>
      </div>
    </div>
  </div>
<!-- ======================= PART 2 / 3 ======================= -->
<script>
(function(){
  const TAU = Math.PI*2;
  const AU_KM = 149_597_870.7; // km
  const C_KM_S = 299_792.458;  // km/s

  const PLANETS = [
    { key:'mercury', name:'Mercury', a:0.387, color:'#f5d08a', ang: 15 },
    { key:'venus',   name:'Venus',   a:0.723, color:'#ffcf9b', ang: 75 },
    { key:'earth',   name:'Earth',   a:1.000, color:'#7aa2ff', ang: 0 },
    { key:'mars',    name:'Mars',    a:1.524, color:'#ff8a7a', ang: 130 },
    { key:'jupiter', name:'Jupiter', a:5.204, color:'#d6c3a1', ang: 200 },
    { key:'saturn',  name:'Saturn',  a:9.582, color:'#f0e2b7', ang: 300 },
    { key:'uranus',  name:'Uranus',  a:19.20, color:'#a8e3ff', ang: 250 },
    { key:'neptune', name:'Neptune', a:30.05, color:'#82b7ff', ang: 330 }
  ];
  const EARTH = PLANETS.find(p=>p.key==='earth');
  const RMAX_AU = PLANETS[PLANETS.length-1].a; // Neptune ~ 30 AU

  // --- Elements ---
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const REl = document.getElementById('R');
  const alphaEl = document.getElementById('alpha');
  const gammaEl = document.getElementById('gamma');
  const warpEl = document.getElementById('warp');
  const destEl = document.getElementById('dest');
  const showOrbitsEl = document.getElementById('showOrbits');
  const tunnelStyleEl = document.getElementById('tunnelStyle');

  const helixAmpEl = document.getElementById('helixAmp');
  const helixTurnsEl = document.getElementById('helixTurns');
  const beltAUEl = document.getElementById('beltAU');

  const auDistEl = document.getElementById('auDist');
  const tunLenEl = document.getElementById('tunLen');
  const etaEl = document.getElementById('eta');

  const engageBtn = document.getElementById('engage');
  const resetBtn = document.getElementById('reset');

  // Populate destination dropdown (exclude Earth)
  PLANETS.forEach(p=>{
    if(p.key!=='earth'){
      const opt=document.createElement('option');
      opt.value=p.key; opt.textContent=p.name;
      destEl.appendChild(opt);
    }
  });
  destEl.value = 'mars';

  // --- Camera / interaction ---
  let cam = {x:0,y:0,s:1,dragging:false,lx:0,ly:0};

  function resizeCanvas(){
    const dpr = Math.min(window.devicePixelRatio||1,2);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.floor(rect.width*dpr);
    cv.height = Math.floor(rect.height*dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr,dpr);
  }
  resizeCanvas();
  window.addEventListener('resize', ()=>{ resizeCanvas(); draw(); });

  cv.addEventListener('mousedown', e=>{ cam.dragging=true; cam.lx=e.clientX; cam.ly=e.clientY; });
  window.addEventListener('mouseup', ()=> cam.dragging=false);
  window.addEventListener('mousemove', e=>{
    if(!cam.dragging) return;
    cam.x += (e.clientX-cam.lx);
    cam.y += (e.clientY-cam.ly);
    cam.lx=e.clientX; cam.ly=e.clientY;
    draw();
  });

  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    const k = Math.exp(-e.deltaY*0.001);
    cam.s = Math.max(0.45, Math.min(3.5, cam.s*k));
    draw();
  }, {passive:false});

  resetBtn.addEventListener('click', ()=>{
    cam = {x:0,y:0,s:1,dragging:false,lx:0,ly:0};
    draw();
  });

  // --- Mapping r(AU) -> r'(pixels) with extra inner expansion ---
  function mapR(au, Rpx, alpha, gamma){
    // r′ = R · atan( alpha · (r/Rmax)^gamma ) / atan(alpha)
    // gamma<1 spreads inner radii; gamma>1 compresses inner radii
    const frac = Math.max(0, au / RMAX_AU);
    const shaped = Math.pow(frac, gamma);
    const num = Math.atan(alpha * shaped);
    const den = Math.atan(alpha);
    return Rpx * (num/den);
  }

  function planetXY(p, Rpx, alpha, gamma){
    const rpx = mapR(p.a, Rpx, alpha, gamma);
    const ang = (p.ang/180)*Math.PI;
    return { x: rpx*Math.cos(ang), y: rpx*Math.sin(ang), rpx };
  }

  // True-ish chord distance Earth->dest in AU (nominal angles)
  function trueDistanceAU(dest){
    const a1=EARTH.a, a2=dest.a;
    const th1=0, th2=(dest.ang/180)*Math.PI;
    const x1=a1*Math.cos(th1), y1=a1*Math.sin(th1);
    const x2=a2*Math.cos(th2), y2=a2*Math.sin(th2);
    return Math.hypot(x2-x1, y2-y1);
  }

  // Centerline curve (quadratic bezier bowed outward)
  function tunnelCenterlinePts(Rpx, alpha, gamma, dest, samples=260){
    const E = planetXY(EARTH, Rpx, alpha, gamma);
    const D = planetXY(dest , Rpx, alpha, gamma);

    const mid = { x:(E.x+D.x)/2, y:(E.y+D.y)/2 };
    const out = (E.rpx + D.rpx)/2 * 0.38;

    // normal direction: from origin to mid (push outward away from Sun)
    const nx = mid.x, ny = mid.y;
    const nlen = Math.hypot(nx,ny)||1;
    const ux = nx/nlen, uy = ny/nlen;

    const C = { x: mid.x + ux*out, y: mid.y + uy*out };

    const pts = [];
    for(let i=0;i<=samples;i++){
      const t=i/samples, mt=1-t;
      const x = mt*mt*E.x + 2*mt*t*C.x + t*t*D.x;
      const y = mt*mt*E.y + 2*mt*t*C.y + t*t*D.y;
      pts.push({x,y,t});
    }
    return pts;
  }

  function polylineLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++){
      L += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
    }
    return L;
  }

  function drawGrid(g){
    const step=50;
    g.save();
    g.strokeStyle='rgba(255,255,255,0.06)';
    g.lineWidth=1;
    for(let x=-2200; x<=2200; x+=step){ g.beginPath(); g.moveTo(x,-2200); g.lineTo(x,2200); g.stroke(); }
    for(let y=-2200; y<=2200; y+=step){ g.beginPath(); g.moveTo(-2200,y); g.lineTo(2200,y); g.stroke(); }
    g.restore();
  }

  // --- Asteroidal Helix: offset perpendicular to centerline, envelope peaks near beltAU ---
  function helixFromCenterline(centerPts, Rpx, alpha, gamma){
    const amp = +helixAmpEl.value;           // 0..1
    const turns = +helixTurnsEl.value;       // integer
    const beltAU = +beltAUEl.value;          // belt center
    const beltSigma = 0.45;                  // width in AU (fixed; looks good)

    // Convert beltAU to mapped pixels so envelope aligns with displayed radius
    const beltRpx = mapR(beltAU, Rpx, alpha, gamma);

    const pts = [];
    for(let i=0;i<centerPts.length;i++){
      const p = centerPts[i];
      // tangent (use neighbor difference)
      const p0 = centerPts[Math.max(0,i-1)];
      const p1 = centerPts[Math.min(centerPts.length-1,i+1)];
      const tx = p1.x - p0.x;
      const ty = p1.y - p0.y;
      const tlen = Math.hypot(tx,ty) || 1;
      // normal to tangent
      const nx = -ty / tlen;
      const ny =  tx / tlen;

      // radius at this point in mapped space
      const r = Math.hypot(p.x, p.y);

      // envelope: gaussian around asteroid belt mapped radius
      const dr = r - beltRpx;
      const env = Math.exp(-(dr*dr) / (2*(mapR(beltSigma, Rpx, alpha, gamma)**2 + 1e-6)));

      // core oscillation along t
      const phase = TAU * turns * p.t;
      const wobble = Math.sin(phase);

      // amplitude in pixels: scaled by mapped 1 AU ring and envelope peak
      const pxPerAU = mapR(1, Rpx, alpha, gamma);
      const Apx = amp * 0.20 * pxPerAU; // 0.20 AU visually at max amp
      const off = wobble * env * Apx;

      pts.push({ x: p.x + nx*off, y: p.y + ny*off, t: p.t });
    }
    return pts;
  }
<!-- ======================= PART 3 / 3 ======================= -->
  // --- Animation state ---
  let anim = { active:false, t:0, pts:[], speed:0.35 }; // speed fraction per second
  engageBtn.addEventListener('click', ()=>{
    const Rpx = +REl.value, alpha = +alphaEl.value, gamma = +gammaEl.value;
    const dest = PLANETS.find(p=>p.key===destEl.value);

    const center = tunnelCenterlinePts(Rpx, alpha, gamma, dest, 360);
    if(tunnelStyleEl.value==='helix'){
      anim.pts = helixFromCenterline(center, Rpx, alpha, gamma);
    } else if(tunnelStyleEl.value==='curve'){
      anim.pts = center;
    } else { // straight: animate on straight line (two-point polyline)
      const E = planetXY(EARTH, Rpx, alpha, gamma);
      const D = planetXY(dest , Rpx, alpha, gamma);
      const pts=[];
      for(let i=0;i<=360;i++){
        const t=i/360;
        pts.push({x:E.x+(D.x-E.x)*t, y:E.y+(D.y-E.y)*t, t});
      }
      anim.pts = pts;
    }

    anim.t = 0;
    anim.active = true;
  });

  function updateMetrics(dest, tunnelLenAU, warp){
    const distAU = trueDistanceAU(dest);
    auDistEl.textContent = distAU.toFixed(3) + ' AU';
    tunLenEl.textContent = tunnelLenAU.toFixed(3) + ' AU*';

    const km = tunnelLenAU * AU_KM;
    const v = warp * C_KM_S;
    const seconds = km / v;
    etaEl.textContent = formatDuration(seconds) + `  (warp ${warp.toFixed(1)}×c)`;
  }

  function formatDuration(sec){
    if(sec<60) return sec.toFixed(1)+' s';
    const m = Math.floor(sec/60);
    const s = Math.round(sec%60);
    if(m<60) return `${m} m ${s} s`;
    const h = Math.floor(m/60);
    const m2 = m%60;
    if(h<48) return `${h} h ${m2} m`;
    const d = Math.floor(h/24);
    const h2 = h%24;
    return `${d} d ${h2} h`;
  }

  // frame timer for animation (stable dt)
  let lastFrame = performance.now();

  function draw(){
    const Rpx = +REl.value;
    const alpha = +alphaEl.value;
    const gamma = +gammaEl.value;
    const warp = +warpEl.value;

    resizeCanvas();
    ctx.clearRect(0,0,cv.width,cv.height);

    const rect = cv.getBoundingClientRect();
    ctx.save();
    ctx.translate(rect.width/2 + cam.x, rect.height/2 + cam.y);
    ctx.scale(cam.s, cam.s);

    drawGrid(ctx);

    // Sun
    ctx.fillStyle='rgba(255,215,120,0.25)';
    ctx.beginPath(); ctx.arc(0,0,12,0,TAU); ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.3)';
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(0,0,12,0,TAU); ctx.stroke();

    // Orbits
    if(showOrbitsEl.value==='1'){
      PLANETS.forEach(p=>{
        const rr = mapR(p.a, Rpx, alpha, gamma);
        ctx.strokeStyle='rgba(255,255,255,0.12)';
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(0,0,rr,0,TAU); ctx.stroke();
      });

      // Asteroid belt hint ring (visual)
      const beltAU = +beltAUEl.value;
      const beltR = mapR(beltAU, Rpx, alpha, gamma);
      ctx.strokeStyle='rgba(255,255,255,0.18)';
      ctx.setLineDash([6,8]);
      ctx.beginPath(); ctx.arc(0,0,beltR,0,TAU); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='rgba(255,255,255,0.7)';
      ctx.font='12px ui-sans-serif';
      ctx.fillText('Asteroid Belt (focus)', beltR+10, -8);
    }

    // Planets
    PLANETS.forEach(p=>{
      const {x,y} = planetXY(p, Rpx, alpha, gamma);
      ctx.fillStyle=p.color;
      ctx.beginPath();
      ctx.arc(x,y, p.key==='earth'?6:4, 0, TAU);
      ctx.fill();

      // label
      ctx.fillStyle='rgba(255,255,255,0.9)';
      ctx.font='12px ui-sans-serif';
      ctx.textAlign='left';
      ctx.fillText(p.name, x+8, y-6);
    });

    // Active destination + tunnel drawing
    const dest = PLANETS.find(p=>p.key===destEl.value);
    const E = planetXY(EARTH, Rpx, alpha, gamma);
    const D = planetXY(dest , Rpx, alpha, gamma);

    // metrics scale: pixels per mapped AU based on mapped 1 AU ring
    const pxPerAU = mapR(1, Rpx, alpha, gamma);

    let tunnelPts = [];
    if(tunnelStyleEl.value==='straight'){
      ctx.strokeStyle='rgba(255,255,255,0.55)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(E.x,E.y); ctx.lineTo(D.x,D.y); ctx.stroke();

      // tunnel length in AU*: use mapped straight line length scaled by pxPerAU
      const Lpx = Math.hypot(D.x-E.x, D.y-E.y);
      const LAU = Lpx / pxPerAU;
      updateMetrics(dest, LAU, warp);

      // build pts for animation
      for(let i=0;i<=240;i++){
        const t=i/240;
        tunnelPts.push({x:E.x+(D.x-E.x)*t, y:E.y+(D.y-E.y)*t, t});
      }
    } else {
      const center = tunnelCenterlinePts(Rpx, alpha, gamma, dest, 280);

      if(tunnelStyleEl.value==='helix'){
        tunnelPts = helixFromCenterline(center, Rpx, alpha, gamma);

        // helix stroke
        ctx.strokeStyle='rgba(122,162,255,0.95)';
        ctx.lineWidth=2.4;
        ctx.beginPath();
        for(let i=0;i<tunnelPts.length;i++){
          const p=tunnelPts[i];
          if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();

        // glow
        ctx.strokeStyle='rgba(122,162,255,0.30)';
        ctx.lineWidth=7;
        ctx.beginPath();
        for(let i=0;i<tunnelPts.length;i++){
          const p=tunnelPts[i];
          if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
      } else {
        tunnelPts = center;

        ctx.strokeStyle='rgba(122,162,255,0.9)';
        ctx.lineWidth=2.5;
        ctx.beginPath();
        for(let i=0;i<tunnelPts.length;i++){
          const p=tunnelPts[i];
          if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();

        ctx.strokeStyle='rgba(122,162,255,0.35)';
        ctx.lineWidth=6;
        ctx.beginPath();
        for(let i=0;i<tunnelPts.length;i++){
          const p=tunnelPts[i];
          if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
      }

      // length in AU* from polyline pixels
      const Lpx = polylineLength(tunnelPts);
      const LAU = Lpx / pxPerAU;
      updateMetrics(dest, LAU, warp);
    }

    // animation (ship dot)
    if(anim.active && anim.pts && anim.pts.length){
      const now = performance.now();
      const dt = Math.min(0.033, (now-lastFrame)/1000);
      anim.t += anim.speed*dt;
      if(anim.t>=1){ anim.t=1; anim.active=false; }

      const idx = Math.max(0, Math.min(anim.pts.length-1, Math.floor(anim.t*(anim.pts.length-1))));
      const ship = anim.pts[idx];

      // ship glow
      ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.beginPath(); ctx.arc(ship.x, ship.y, 5, 0, TAU); ctx.fill();
      ctx.strokeStyle='rgba(122,162,255,0.55)';
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(ship.x, ship.y, 8, 0, TAU); ctx.stroke();
    }

    ctx.restore();
  }

  // Hook controls
  const controls = [REl, alphaEl, gammaEl, warpEl, destEl, showOrbitsEl, tunnelStyleEl, helixAmpEl, helixTurnsEl, beltAUEl];
  controls.forEach(el => el.addEventListener('input', draw));

  function loop(){
    lastFrame = performance.now();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
