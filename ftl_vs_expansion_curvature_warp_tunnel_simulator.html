<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FTL vs Expansion — Curvature Warp Tunnel Simulator (v2.6)</title>
<style>
  :root{
    --bg:#0b1020; --ink:#eaf0ff; --mut:#9fb0d0; --panel:#111834; --line:#223062;
    --accent:#60a5fa; --accent2:#34d399; --warn:#f59e0b; --bad:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial}
  .wrap{max-width:1240px;margin:0 auto;padding:22px}
  h1{margin:0 0 10px;line-height:1.2}
  h2{margin:0 0 8px}
  p{color:var(--mut);margin:6px 0 14px}
  .grid{display:grid;gap:14px;grid-template-columns:1fr 1fr}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
  .row{display:grid;grid-template-columns:200px 1fr 180px;gap:10px;align-items:center;margin:8px 0}
  label{color:var(--mut);font-size:14px}
  input[type="number"], select{width:100%;padding:6px 8px;border-radius:10px;border:1px solid var(--line);background:#0e1530;color:#eaf0ff}
  input[type="checkbox"]{transform:scale(1.2)}
  .pill{display:inline-flex;gap:8px;flex-wrap:wrap}
  .pill button{cursor:pointer;border:1px solid var(--line);background:#0e1530;color:#eaf0ff;padding:6px 10px;border-radius:999px}
  .pill button.active{border-color:var(--accent);outline:2px solid #1f2b50}
  .btn{cursor:pointer;border:1px solid var(--line);background:#0e1530;color:#eaf0ff;padding:10px 12px;border-radius:12px}
  .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#041125;font-weight:700}
  .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .metric{background:#0e1530;border:1px dashed #1d2a56;border-radius:12px;padding:10px}
  .metric h3{margin:0 0 6px;font-size:13px;color:#9fb3e0}
  .metric .v{font-size:18px;font-weight:800}
  canvas.sim{width:100%;height:140px;border-radius:10px;background:#0e1530;border:1px solid var(--line);display:block}
  .small{font-size:12px;color:#90a4d4}
  .ok{color:var(--accent2)} .no{color:var(--bad)} .warn{color:var(--warn)}
  .foot{margin-top:12px;color:#8aa1d4}
  code{background:#0e1530;padding:2px 6px;border-radius:8px;border:1px solid var(--line)}
  .twocol{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .ledgers{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .ledger{background:#0e1530;border:1px dashed #1d2a56;border-radius:12px;padding:10px}
  .ledger h3{margin:0 0 6px;font-size:13px;color:#9fb3e0}
  @keyframes pulseValue { 0%{transform:scale(1); color:var(--ink);} 40%{transform:scale(1.06);} 60%{color:var(--accent2);} 100%{transform:scale(1); color:var(--ink);} }
  .pulse{animation:pulseValue 750ms ease-out 1}
  .panel .miniControls{position:absolute;right:12px;top:12px;display:flex;gap:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>FTL vs Expansion — Curvature Warp Tunnel Simulator (v2.6)</h1>
  <p>New: <b>Warp Speed Meter</b> — compute effective speed using distance and synchronized clocks (Earth & Ship). This is the right way to quantify a warp tunnel.</p>

  <div class="grid">
    <section class="panel" id="panelCosmo">
      <div class="miniControls"><button class="btn" id="playCosmo">Play</button></div>
      <h2>Target & Cosmology</h2>
      <div class="row">
        <label>Preset target</label>
        <div class="pill" id="presets"></div>
        <button class="btn" id="clearPreset">Clear</button>
      </div>
      <div class="row">
        <label>Total distance D (Gly)</label>
        <input id="D" type="number" min="0.1" step="0.1" value="16" />
        <span class="small">Comoving target distance</span>
      </div>
      <div class="row">
        <label>H<sub>0</sub> (km/s/Mpc)</label>
        <input id="H0" type="number" min="40" max="90" step="0.1" value="70" />
        <span class="small">Try 67.7 or 70</span>
      </div>
      <div class="row">
        <label>Ω<sub>m</sub>, Ω<sub>Λ</sub></label>
        <div class="twocol">
          <input id="Om" type="number" min="0" max="1" step="0.01" value="0.30" />
          <input id="Ol" type="number" min="0" max="1" step="0.01" value="0.70" />
        </div>
        <span class="small">Flat universe assumed</span>
      </div>
      <div class="row">
        <label>H<sub>eff</sub> model</label>
        <select id="HeffMode">
          <option value="lcdm" selected>ΛCDM approx (√Ω<sub>Λ</sub>·H<sub>0</sub>)</option>
          <option value="H0">Constant H<sub>0</sub></option>
        </select>
        <span class="small">Expansion used during travel</span>
      </div>
      <canvas id="cosmoSim" class="sim" width="560" height="140"></canvas>
    </section>

    <section class="panel" id="panelVehicle">
      <div class="miniControls"><button class="btn" id="playVehicle">Play</button></div>
      <h2>Vehicle / Tunnel</h2>
      <div class="row">
        <label>Mode</label>
        <div class="pill">
          <button data-mode="ftl" class="active">Direct FTL</button>
          <button data-mode="tunnel">Warp Tunnel</button>
        </div>
        <span id="modeHint" class="small">FTL cruise at f·c</span>
      </div>
      <div class="row" data-only="ftl">
        <label>FTL factor f (v=f·c)</label>
        <input id="f" type="number" min="1.01" step="0.01" value="10" />
        <span class="small">Unknown → explore</span>
      </div>
      <div class="row" data-only="ftl">
        <label>Drag model</label>
        <select id="dragModel">
          <option value="local" selected>Local recession (v<sub>rec</sub>=H·D)</option>
          <option value="none">Ignore expansion while cruising</option>
        </select>
        <span class="small">Toy Hubble headwind</span>
      </div>
      <div class="row" data-only="tunnel" style="display:none">
        <label>Jump per activation J (Gly)</label>
        <input id="J" type="number" min="0.1" step="0.1" value="10" />
        <span class="small">“How many billion ly at a time”</span>
      </div>
      <div class="row" data-only="tunnel" style="display:none">
        <label>Latency per jump (Myr)</label>
        <input id="latencyMyr" type="number" min="0" step="0.1" value="50" />
        <span class="small">CST sync + stabilization</span>
      </div>
      <div class="row" data-only="tunnel" style="display:none">
        <label>Latency split</label>
        <div class="twocol">
          <input id="cstFrac" type="number" min="0" max="1" step="0.05" value="0.6" />
          <input id="shieldFrac" type="number" min="0" max="1" step="0.05" value="0.4" />
        </div>
        <span class="small">CST sync fraction | Shield dwell fraction</span>
      </div>
      <div class="row">
        <label>Safety margin</label>
        <input id="margin" type="number" min="0" step="0.01" value="0.10" />
        <span class="small">Extra 10% distance/time</span>
      </div>
      <div class="row" data-only="tunnel" style="display:none">
        <label>On‑site time (hours)</label>
        <input id="onsiteHours" type="number" min="0" step="0.1" value="1" />
        <span class="small">Time you choose to spend there</span>
      </div>
      <div class="row" data-only="tunnel" style="display:none">
        <label>Count latency as crew aging?</label>
        <div><input id="ageLatency" type="checkbox" checked /> Include latency in ship time</div>
        <span class="small">Uncheck to age only on‑site time</span>
      </div>
      <div class="row">
        <label></label>
        <button class="btn primary" id="run">Compute</button>
      </div>
      <canvas id="vehicleSim" class="sim" width="560" height="140"></canvas>
    </section>
  </div>

  <!-- Jump Planner & FTL Solver -->
  <div class="grid" style="margin-top:14px">
    <section class="panel" id="panelPlanner">
      <div class="miniControls"><button class="btn" id="playPlanner">Play</button></div>
      <h2>Jump Planner (Warp‑Hole)</h2>
      <div class="row">
        <label>Plan: J per jump (Gly)</label>
        <input id="planJ" type="number" min="0.1" step="0.1" value="10" />
        <button class="btn" id="applyPlan">Use in simulator</button>
      </div>
      <div class="row">
        <label>Auto‑compute</label>
        <button class="btn" id="autoPlan">Add Jump Plan</button>
        <span class="small">Sets J and estimates requirements</span>
      </div>
      <div class="metrics">
        <div class="metric"><h3># of jumps</h3><div class="v" id="jumpsPlan">—</div><div class="small">Ceil(D/J) with margin</div></div>
        <div class="metric"><h3>Total time</h3><div class="v" id="timePlan">—</div><div class="small">Latency‑dominated (Myr)</div></div>
        <div class="metric"><h3>Field Power Index</h3><div class="v" id="fpi">—</div><div class="small">Toy: ∝ J · H<sub>eff</sub>/H<sub>0</sub></div></div>
      </div>
      <div class="metrics" style="margin-top:8px">
        <div class="metric"><h3>CST sync / jump</h3><div class="v" id="cstTime">—</div><div class="small">Myr</div></div>
        <div class="metric"><h3>Shield dwell / jump</h3><div class="v" id="shieldTime">—</div><div class="small">Myr</div></div>
        <div class="metric"><h3>Notes</h3><div class="v" id="planNote">—</div><div class="small">Stability gates ok?</div></div>
      </div>
      <canvas id="plannerSim" class="sim" width="560" height="140"></canvas>
    </section>

    <section class="panel" id="panelSolver">
      <h2>FTL Time Solver (beat expansion)</h2>
      <div class="row">
        <label>Target time (Myr)</label>
        <input id="targetMyr" type="number" min="0.001" step="0.001" value="20" />
        <button class="btn" id="solveF">Solve f</button>
      </div>
      <div class="metrics">
        <div class="metric"><h3>Required f</h3><div class="v" id="fReq">—</div><div class="small">v = f·c in local‑drag model</div></div>
        <div class="metric"><h3>Check</h3><div class="v" id="reachCheck">—</div><div class="small">Is f > v<sub>rec</sub>/c at D?</div></div>
        <div class="metric"><h3>Recession at D</h3><div class="v" id="vrec2">—</div><div class="small">km/s and in c</div></div>
      </div>
      <p class="small">FTL (toy) from t = (1/H)·ln[(f c)/(f c − H D)] ⇒ <b>f = (H D / c) / (1 − e^{−H t})</b>. Uses H from the chosen model and D with margin.</p>
    </section>
  </div>

  <!-- NEW: Warp Speed Meter -->
  <section class="panel" id="panelWarp" style="margin-top:14px">
    <h2>Warp Speed Meter (Distance + Synchronized Clocks)</h2>
    <p class="small">Use this to measure effective translation speed of a warp tunnel. Enter the separation and the elapsed time on Earth and on the Ship (proper time). Works for any baseline (Pluto, exoplanet, etc.).</p>
    <div class="row">
      <label>Distance L</label>
      <div class="twocol">
        <input id="L_km" type="number" min="0" step="1" value="6.0e9" />
        <select id="L_unit">
          <option value="km" selected>km</option>
          <option value="m">m</option>
          <option value="AU">AU</option>
          <option value="ly">ly</option>
        </select>
      </div>
      <span class="small">Earth↔Target separation at event time</span>
    </div>
    <div class="row">
      <label>Earth elapsed Δt<sub>E</sub> (s)</label>
      <input id="tE_s" type="number" min="0" step="0.001" value="1" />
      <span class="small">Earth clock: arrival − departure</span>
    </div>
    <div class="row">
      <label>Ship elapsed Δt<sub>S</sub> (s)</label>
      <input id="tS_s" type="number" min="0" step="0.001" value="1" />
      <span class="small">Ship clock: arrival − departure</span>
    </div>
    <div class="row">
      <label></label>
      <button class="btn primary" id="calcWarp">Compute Warp Speeds</button>
      <span class="small">Compares to c and reports ×c</span>
    </div>
    <div class="metrics">
      <div class="metric"><h3>v<sub>ext</sub> (Earth)</h3><div class="v" id="vext">—</div><div class="small">km/s and ×c</div></div>
      <div class="metric"><h3>v<sub>ship</sub> (Proper)</h3><div class="v" id="vship">—</div><div class="small">km/s and ×c</div></div>
      <div class="metric"><h3>Light time (for L)</h3><div class="v" id="ltime">—</div><div class="small">Seconds @ c for comparison</div></div>
    </div>
    <p class="small">Note: This does not time a light beam. It uses clocks and geometry—the correct way to quantify tunnel translation.</p>
  </section>

  <section class="panel" id="panelResults" style="margin-top:14px">
    <h2>Results</h2>
    <div class="metrics">
      <div class="metric"><h3>Recession speed at D</h3><div class="v" id="vrec">—</div><div class="small">Using chosen H model</div></div>
      <div class="metric"><h3>Reachability</h3><div class="v" id="reach">—</div><div class="small">Can the mission beat expansion?</div></div>
      <div class="metric"><h3>Est. travel time</h3><div class="v" id="t">—</div><div class="small">Gyr (toy model)</div></div>
    </div>
    <div class="foot small">Warp‑hole ≠ wormhole. The bubble moves spacetime; latency (CST sync + stability) sets mission time. FPI is a heuristic scaling with jump size and expansion pressure.</div>
  </section>

  <section class="panel" id="panelMath" style="margin-top:14px">
    <h2>Math & CST Ledger</h2>
    <div class="ledgers">
      <div class="ledger">
        <h3>Equations (toy forms)</h3>
        <div class="small">
          <div>Recession: <code>v_rec = H · D</code></div>
          <div>FTL time (drag model): <code>t = (1/H) · ln[(f·c)/(f·c − H·D)]</code></div>
          <div>Required f for target t: <code>f = (H·D/c) / (1 − e^{−H·t})</code></div>
          <div>Warp‑tunnel jumps: <code>N = ceil((1+margin)·D / J)</code>, <code>T_ext ≈ N · τ_lat</code></div>
          <div>Warp Meter: <code>v_ext = L / Δt_E</code>, <code>v_ship = L / Δt_S</code>, <code>k = v/c</code></div>
        </div>
        <hr/>
        <div class="small">
          <div><b>H_eff</b>: <span id="mathHeff">—</span> km/s/Mpc</div>
          <div><b>v_rec(D)</b>: <span id="mathVrec">—</span></div>
          <div><b>N jumps</b>: <span id="mathN">—</span></div>
          <div><b>Tunnel time</b>: <span id="mathT">—</span></div>
          <div><b>f (for target t)</b>: <span id="mathF">—</span></div>
        </div>
      </div>
      <div class="ledger">
        <h3>CST Time Ledger (Warp‑Hole/Tunnel)</h3>
        <div class="small">
          <div>On‑site time: <span id="onsiteDisp">—</span></div>
          <div>Latency counts as crew aging? <span id="ageLatencyDisp">—</span></div>
          <div><b>Ship aging</b>: <span id="shipAging">—</span></div>
          <div><b>Earth elapsed</b>: <span id="earthElapsed">—</span></div>
          <div class="foot">If CST-locked, ship and Earth advance together; only time you live (on‑site and, if chosen, latency) accrues.</div>
        </div>
      </div>
    </div>
  </section>

</div>

<script>
  // ---------- Constants & helpers ----------
  const c = 299792.458; // km/s
  const sec_per_Gyr = 3.15576e16;
  const sec_per_Myr = 3.15576e13;
  const hours_per_Myr = 1e6 * 365.25 * 24;
  const Gly_to_km = 9.4607e17 * 1e9;

  function heff(H0, Om, Ol, mode){ return (mode==='lcdm')? Math.sqrt(Math.max(Ol,0))*H0 : H0; }
  function kmpsMpc_to_perGyr(H){ const Mpc_km=3.08567758128e19; return (H/Mpc_km)*sec_per_Gyr; }
  function vrec_kmps(H_kmpsMpc, D_Gly){ const Gly_Mpc=1.0e9/3.26156; const D_Mpc=D_Gly*Gly_Mpc; return H_kmpsMpc*D_Mpc; }
  function ftl_time_local_drag(H_kmpsMpc, D_Gly, f){ const H_perGyr=kmpsMpc_to_perGyr(H_kmpsMpc); const vrec=vrec_kmps(H_kmpsMpc,D_Gly); const fc=f*c; if(vrec>=fc) return Infinity; return Math.log(fc/(fc-vrec))/H_perGyr; }
  function solve_f_for_time(H_kmpsMpc, D_Gly, t_Gyr){ const H_perGyr=kmpsMpc_to_perGyr(H_kmpsMpc); const HD=vrec_kmps(H_kmpsMpc,D_Gly); const denom=1-Math.exp(-H_perGyr*t_Gyr); if(denom<=0) return Infinity; return (HD/c)/denom; }
  function fmt(x,d=3){ if(!isFinite(x)) return '—'; if(Math.abs(x)>=1000) return x.toFixed(0); return x.toFixed(d); }
  function fmtTimeMyrToNice(my){ if(!isFinite(my)) return '—'; if(my<1e-3) return (my*1e3).toFixed(3)+' kyr'; if(my<1) return (my).toFixed(3)+' Myr'; if(my<1000) return my.toFixed(2)+' Myr'; return (my/1000).toFixed(3)+' Gyr'; }
  function hoursToMyr(h){ return h/hours_per_Myr; }

  // ---------- Elements ----------
  const $ = id=>document.getElementById(id);
  const D=$('D'), H0=$('H0'), Om=$('Om'), Ol=$('Ol'), HeffMode=$('HeffMode');
  const f=$('f'), dragModel=$('dragModel'), J=$('J'), latencyMyr=$('latencyMyr'), margin=$('margin');
  const cstFrac=$('cstFrac'), shieldFrac=$('shieldFrac');
  const onsiteHours=$('onsiteHours'), ageLatency=$('ageLatency');

  const vrecOut=$('vrec'), reachOut=$('reach'), tOut=$('t');
  const mathHeff=$('mathHeff'), mathVrec=$('mathVrec'), mathN=$('mathN'), mathT=$('mathT'), mathF=$('mathF');
  const onsiteDisp=$('onsiteDisp'), ageLatencyDisp=$('ageLatencyDisp'), shipAging=$('shipAging'), earthElapsed=$('earthElapsed');

  // Planner & solver elements
  const planJ=$('planJ'), jumpsPlan=$('jumpsPlan'), timePlan=$('timePlan');
  const fpiOut=$('fpi'), cstTime=$('cstTime'), shieldTime=$('shieldTime'), planNote=$('planNote');
  const targetMyr=$('targetMyr'), fReq=$('fReq'), reachCheck=$('reachCheck'), vrec2=$('vrec2');

  // Warp Meter elements
  const L_km=$('L_km'), L_unit=$('L_unit'), tE_s=$('tE_s'), tS_s=$('tS_s');
  const vext=$('vext'), vship=$('vship'), ltime=$('ltime');

  // canvases still present (only in a few panels)
  const cosmoSim=$('cosmoSim'), vehicleSim=$('vehicleSim'), plannerSim=$('plannerSim');
  // buttons that remain
  const playCosmo=$('playCosmo'), playVehicle=$('playVehicle'), playPlanner=$('playPlanner');

  // presets
  const presets=$('presets');
  const presetList=[{label:'Cosmic horizon ~16 Gly',D:16},{label:'Observable edge ~46.5 Gly',D:46.5},{label:'Local group ~1 Gly',D:1},{label:'Deep reach ~100 Gly',D:100}];
  presetList.forEach(p=>{const b=document.createElement('button');b.textContent=p.label;b.onclick=()=>{D.value=p.D;compute();};presets.appendChild(b);});
  $('clearPreset').onclick=()=>{D.value='';D.focus();};

  // mode toggle
  let mode='ftl';
  document.querySelectorAll('[data-mode]').forEach(btn=>{
    btn.onclick=()=>{
      document.querySelectorAll('[data-mode]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      mode=btn.dataset.mode;
      document.querySelectorAll('[data-only]').forEach(el=>{ el.style.display=(el.getAttribute('data-only')===mode)?'grid':'none'; });
      $('modeHint').textContent= mode==='ftl'? 'FTL cruise at f·c' : 'Warp tunnel jumps at J Gly each';
      compute();
    };
  });

  // main actions
  $('run').onclick=compute;
  $('applyPlan').onclick=()=>{ J.value=planJ.value; if(mode!=='tunnel'){ switchTo('tunnel'); } compute(); };
  $('autoPlan').onclick=()=>{ J.value=planJ.value; switchTo('tunnel'); compute(); };
  $('solveF').onclick=solveFAction;
  $('calcWarp').onclick=calcWarpAction;

  // input listeners
  [D,H0,Om,Ol,HeffMode,f,dragModel,J,latencyMyr,margin,cstFrac,shieldFrac,onsiteHours,ageLatency].forEach(el=> el.addEventListener('input', compute));

  function switchTo(m){
    mode=m;
    document.querySelectorAll('[data-mode]').forEach(b=>b.classList.remove('active'));
    document.querySelector(`[data-mode="${m}"]`).classList.add('active');
    document.querySelectorAll('[data-only]').forEach(el=>{ el.style.display=(el.getAttribute('data-only')===m)?'grid':'none'; });
    $('modeHint').textContent= m==='ftl'? 'FTL cruise at f·c' : 'Warp tunnel jumps at J Gly each';
  }

  // ---------- Compute ----------
  function compute(){
    const Dg=parseFloat(D.value||'0');
    const Htoy=heff(parseFloat(H0.value),parseFloat(Om.value),parseFloat(Ol.value),HeffMode.value);
    const marginVal=Number.isFinite(parseFloat(margin.value))?parseFloat(margin.value):0;
    const Dg_eff=Dg*(1+marginVal);

    const vrec=vrec_kmps(Htoy,Dg);
    vrecOut.textContent=fmt(vrec)+' km/s ('+fmt(vrec/c,3)+' c)'; vrecOut.classList.add('pulse'); setTimeout(()=>vrecOut.classList.remove('pulse'),800);

    if(mode==='ftl'){
      const fv=parseFloat(f.value);
      const Huse=(dragModel.value==='none')?0:Htoy;
      let tGyr;
      if(Huse===0){ const dist_km=Dg_eff*Gly_to_km; const sec=dist_km/(fv*c); tGyr=sec/sec_per_Gyr; reachOut.innerHTML=fv>0?'<span class="ok">Reachable (ignoring drag)</span>':'<span class="no">Not set</span>'; }
      else { tGyr=ftl_time_local_drag(Huse,Dg_eff,fv); reachOut.innerHTML=isFinite(tGyr)?'<span class="ok">Reachable (toy)</span>':'<span class="no">Unreachable: v_rec ≥ f·c</span>'; }
      tOut.textContent=isFinite(tGyr)?fmt(tGyr,4)+' Gyr':'—';

      // Math panel
      mathHeff.textContent=fmt(Htoy,3); mathVrec.textContent=fmt(vrec)+' km/s ('+fmt(vrec/c,3)+' c)';
      mathN.textContent='— (FTL mode)'; mathT.textContent=tOut.textContent; mathF.textContent='Use solver below';

      // CST ledger
      onsiteDisp.textContent='—'; ageLatencyDisp.textContent='—'; shipAging.textContent='—'; earthElapsed.textContent=tOut.textContent;
    } else {
      const Jg=parseFloat(J.value)||1; const latMyrVal=parseFloat(latencyMyr.value)||0;
      const jumpsN=Math.ceil(Dg_eff/Jg); const totalMyr=jumpsN*latMyrVal;
      reachOut.innerHTML='<span class="ok">Reachable (tunnel model)</span>';
      tOut.textContent=fmt(totalMyr/1000,4)+' Gyr';

      // Planner
      jumpsPlan.textContent=String(jumpsN);
      timePlan.textContent=fmt(totalMyr,3)+' Myr';
      const cstPer=(Math.max(0,Math.min(1,parseFloat(cstFrac.value)))||0)*latMyrVal;
      const shieldPer=(Math.max(0,Math.min(1,parseFloat(shieldFrac.value)))||0)*latMyrVal;
      cstTime.textContent=fmt(cstPer,2)+' Myr'; shieldTime.textContent=fmt(shieldPer,2)+' Myr';
      const FPI=(Jg/1)*(Htoy/parseFloat(H0.value))*(1+marginVal); fpiOut.textContent=fmt(FPI,2);
      const s=(parseFloat(cstFrac.value)||0)+(parseFloat(shieldFrac.value)||0); planNote.textContent = Math.abs(s-1)<1e-9?'Latency split OK':'Fractions do not sum to 1';

      // Math & CST ledger numbers
      mathHeff.textContent=fmt(Htoy,3); mathVrec.textContent=fmt(vrec)+' km/s ('+fmt(vrec/c,3)+' c)';
      mathN.textContent=jumpsN+' jumps (J='+Jg+' Gly, margin '+(marginVal*100).toFixed(0)+'%)';
      mathT.textContent=fmt(totalMyr,2)+' Myr'; mathF.textContent='Not needed (warp)';

      const onsiteH=parseFloat(onsiteHours.value)||0; onsiteDisp.textContent=onsiteH.toFixed(2)+' hours';
      ageLatencyDisp.textContent=ageLatency.checked?'Yes':'No';
      const shipMyr=(ageLatency.checked?totalMyr:0)+hoursToMyr(onsiteH); const earthMyr=totalMyr+hoursToMyr(onsiteH);
      shipAging.textContent=fmtTimeMyrToNice(shipMyr); earthElapsed.textContent=fmtTimeMyrToNice(earthMyr);
    }

    // run mini sims for the panels that still have canvases
    runCosmoSimOnce(); runVehicleSimOnce(); runPlannerSimOnce();
  }

  function solveFAction(){
    const Dg=(parseFloat(D.value)||0)*(1+(Number.isFinite(parseFloat(margin.value))?parseFloat(margin.value):0));
    const Htoy=heff(parseFloat(H0.value),parseFloat(Om.value),parseFloat(Ol.value),HeffMode.value);
    const tMyr=parseFloat(targetMyr.value)||0; const fNeeded=solve_f_for_time(Htoy,Dg,tMyr/1000);
    fReq.textContent=isFinite(fNeeded)?fmt(fNeeded,3):'—';
    const vrec=vrec_kmps(Htoy,Dg); vrec2.textContent=fmt(vrec)+' km/s ('+fmt(vrec/c,3)+' c)';
    reachCheck.innerHTML=(isFinite(fNeeded)&&fNeeded>vrec/c)?'<span class="ok">Yes (f > v_rec/c)</span>':'<span class="warn">Borderline / No</span>';
  }

  // ---------- Warp Speed Meter ----------
  function toKm(value, unit){
    const v=parseFloat(value)||0;
    switch(unit){
      case 'm':  return v/1000;
      case 'AU': return v*149597870.7; // km
      case 'ly': return v*9.4607e12;  // km
      default:   return v; // km
    }
  }
  function calcWarpAction(){
    const Lkm = toKm(L_km.value, L_unit.value);
    const tE = Math.max(0, parseFloat(tE_s.value)||0);
    const tS = Math.max(0, parseFloat(tS_s.value)||0);
    if(Lkm<=0 || (tE<=0 && tS<=0)){
      vext.textContent='—'; vship.textContent='—'; ltime.textContent='—'; return;
    }
    const c_kmps = c; // km/s
    const ltime_s = Lkm / c_kmps; ltime.textContent = ltime_s.toFixed(6)+' s';
    if(tE>0){ const vE = Lkm/tE; vext.innerHTML = vE.toFixed(3)+' km/s  ('+(vE/c_kmps).toFixed(3)+' ×c)'; } else { vext.textContent='—'; }
    if(tS>0){ const vS = Lkm/tS; vship.innerHTML = vS.toFixed(3)+' km/s  ('+(vS/c_kmps).toFixed(3)+' ×c)'; } else { vship.textContent='—'; }
  }

  // ---------- Mini simulations (only for panels with canvases) ----------
  function runCosmoSimOnce(){ const ctx=cosmoSim.getContext('2d'); const W=cosmoSim.width,H=cosmoSim.height,p=28; ctx.clearRect(0,0,W,H);
    const Dmax=60; const Htoy=heff(parseFloat(H0.value),parseFloat(Om.value),parseFloat(Ol.value),HeffMode.value); const vMax=vrec_kmps(Htoy,Dmax)/c; const Dg=parseFloat(D.value)||0;
    ctx.strokeStyle='#25407a'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(p,H-p); ctx.lineTo(W-p,H-p); ctx.lineTo(W-p,p); ctx.stroke();
    ctx.strokeStyle='#6aa7ff'; ctx.beginPath(); for(let i=0;i<=200;i++){ const Dx=i/200*Dmax; const v=vrec_kmps(Htoy,Dx)/c; const X=p+(W-2*p)*(Dx/Dmax); const Y=H-p-(H-2*p)*(v/Math.max(vMax,1e-6)); if(i===0)ctx.moveTo(X,Y); else ctx.lineTo(X,Y);} ctx.stroke();
    let t=0; const Xtarget=p+(W-2*p)*Math.min(Math.max(Dg,0),Dmax)/Dmax; const Ytarget=(()=>{const v=vrec_kmps(Htoy,Math.min(Math.max(Dg,0),Dmax))/c; return H-p-(H-2*p)*(v/Math.max(vMax,1e-6));})();
    const id=setInterval(()=>{ t+=0.08; const X=p+(Xtarget-p)*Math.min(t,1); ctx.fillStyle='#34d399'; ctx.beginPath(); ctx.arc(X,Ytarget,4,0,Math.PI*2); ctx.fill(); if(t>=1){ clearInterval(id);} },60);
  }

  function runVehicleSimOnce(){ const ctx=vehicleSim.getContext('2d'); const W=vehicleSim.width,H=vehicleSim.height; ctx.clearRect(0,0,W,H);
    if(mode==='ftl'){
      const Htoy=heff(parseFloat(H0.value),parseFloat(Om.value),parseFloat(Ol.value),HeffMode.value); const Dg=parseFloat(D.value)||0; const vrec=vrec_kmps(Htoy,Dg)/c; const fval=parseFloat(f.value)||1; const vmax=Math.max(1,fval,vrec);
      const bx=W*0.1, bw=W*0.35; const by1=H*0.2, by2=H*0.6, bh=H*0.18;
      ctx.fillStyle='#9fb0d0'; ctx.fillRect(bx,by1,bw*(vrec/vmax),bh); ctx.fillStyle='#34d399'; ctx.fillRect(bx,by2,bw*(fval/vmax),bh);
      ctx.fillStyle='#a9b9e6'; ctx.fillText('v_rec/c', bx, by1-6); ctx.fillText('f', bx, by2-6);
      const net=fval-vrec; ctx.strokeStyle= net>0?'#34d399':'#ef4444'; ctx.lineWidth=3; const ax=W*0.6, ay=H*0.5; ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(ax+Math.max(-80,Math.min(80,net*60)),ay); ctx.stroke();
    } else {
      const Jg=Math.max(0.1,parseFloat(J.value)||1); const Dg=parseFloat(D.value)||0; const marginVal=parseFloat(margin.value)||0; const total=Dg*(1+marginVal);
      const N=Math.ceil(total/Jg); const left=40,right=W-40, y=H*0.65; ctx.strokeStyle='#6aa7ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke();
      const step=(right-left)/Math.max(1,N); ctx.fillStyle='#f7c948'; let i=0; const id=setInterval(()=>{ if(i>=N){clearInterval(id);return;} const x=left+step*(i+1); ctx.fillRect(x-1,y-14,2,12); i++; },70);
    }
  }

  function runPlannerSimOnce(){ const ctx=plannerSim.getContext('2d'); const W=plannerSim.width,H=plannerSim.height; ctx.clearRect(0,0,W,H);
    const Jg=Math.max(0.1,parseFloat(J.value)||parseFloat(planJ.value)||1); const Dg=parseFloat(D.value)||0; const marginVal=parseFloat(margin.value)||0; const total=Dg*(1+marginVal); const N=Math.ceil(total/Jg);
    const lat=parseFloat(latencyMyr.value)||0; const totalMyr=N*lat; const left=30,right=W-30, top=H*0.35;
    ctx.strokeStyle='#25407a'; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(right,top); ctx.stroke();
    const step=(right-left)/Math.max(1,N); let i=0; ctx.fillStyle='#34d399'; const id=setInterval(()=>{ if(i>=N){ clearInterval(id); return;} const x=left+step*(i+1); ctx.fillRect(x-1,top-10,2,20); i++; },60);
    ctx.fillStyle='#a9b9e6'; ctx.fillText(`N=${N} jumps, Total ≈ ${fmt(totalMyr,2)} Myr`, left, top+40);
  }

  // Panel mini play buttons
  playCosmo.onclick=runCosmoSimOnce; playVehicle.onclick=runVehicleSimOnce; playPlanner.onclick=runPlannerSimOnce;

  // ---------- Tiny self-tests ----------
  (function selfTest(){
    try{
      const mustHave=['jumpsPlan','timePlan','fpi','cstTime','shieldTime','planNote','planJ','targetMyr','fReq','reachCheck','vrec2','L_km','L_unit','tE_s','tS_s','vext','vship','ltime'];
      mustHave.forEach(id=>{ if(!document.getElementById(id)) throw new Error('Missing element id: '+id); });
      // sanity: warp meter with L=6e9 km, tE=1s -> v≈6e9 km/s ≈ 2e4 c
      L_km.value = 6.0e9; L_unit.value='km'; tE_s.value=1; tS_s.value=1; calcWarpAction();
      console.log('[v2.6] Self-test passed.');
    }catch(e){ console.error('Self-test failed:', e); }
  })();

  // init
  compute();
</script>
</body>
</html>
