<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wave Forecast — Next High Peaks From 336 Groups (Optimized)</title>
<style>
  :root{--bg:#0b1020;--ink:#eaf0ff;--mut:#9fb0d0;--panel:#121936;--line:#223062;--pill:#0d1a3b}
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:980px;margin:0 auto;padding:20px}
  h1{margin:0 0 10px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{cursor:pointer;font-weight:800;border-radius:12px;border:1px solid var(--line);padding:12px 14px}
  .primary{background:linear-gradient(180deg,#1e90ff,#1672cc);border-color:#1672cc;color:#fff}
  .ghost{background:transparent;color:var(--ink)}
  pre{white-space:pre-wrap;word-break:break-word;background:#0f1533;border:1px solid var(--line);border-radius:12px;padding:12px;min-height:140px}
  .hint{color:var(--mut);font-size:.95rem}
  .grid{display:grid;gap:12px}
  .two{grid-template-columns:1fr 1fr}
  .three{grid-template-columns:1fr 1fr 1fr}
  .pill{display:inline-block;background:var(--pill);border:1px solid #2a386f;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;font-weight:700}
  .ok{color:#24d17e} .warn{color:#ffd166} .bad{color:#ff6b6b}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .quote{font-style:italic;color:#cfe2ff}
  input[type="text"],input[type="number"]{flex:1;min-width:160px;background:#0f1533;color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:12px}
  .caps{text-transform:uppercase;letter-spacing:.02em;font-weight:700}
  .tiny{font-size:.9rem}
  .tag{display:inline-block;border:1px dashed #2a386f;border-radius:999px;padding:2px 8px;margin:4px 6px 0 0}
  .note{font-size:.9rem;color:#a9b7e1;margin-top:6px}
  .kv{display:grid;grid-template-columns:160px 1fr;gap:8px;align-items:center}
  .section-title{font-weight:800;margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Wave Forecast — Next High Peaks (Coverage Optimized)</h1>

  <div class="panel">
    <div class="hint"><b>Wave behavior in draw frequencies</b></div>
    <p class="quote">
      Each number has its own waveform across the 336 groups.<br>
      <b>High peak (hot phase)</b>: the number appears frequently across several consecutive groups (like 28 &amp; 44).<br>
      <b>Cooling phase</b>: frequency drops for 3–6 groups.<br>
      <b>Re-heat</b>: the number returns when its internal cycle resets.<br>
      We model this with z-scores on cumulative counts and bias selection toward rising numbers, while spreading coverage so co-occurrence is more likely across rows.
    </p>

    <!-- Inputs Row 1 -->
    <div class="row" style="margin-top:6px">
      <label for="lastDraw" class="caps tiny">Last draw (6 numbers):</label>
      <input id="lastDraw" type="text" placeholder="e.g., 4 10 12 15 28 54" />
      <button id="applyLast" class="primary">Apply Last Draw</button>
      <button id="resetLast" class="ghost">Reset</button>
    </div>
    <div id="lastDrawView" class="note"></div>

    <!-- Inputs Row 2 -->
    <div class="row" style="margin-top:10px">
      <label for="lockNums" class="caps tiny">Lock (force include ≤6):</label>
      <input id="lockNums" type="text" placeholder="e.g., 28 44 or 4,10,12" />
      <label for="pairBoosts" class="caps tiny">Pair boosts (comma list A-B):</label>
      <input id="pairBoosts" type="text" placeholder="e.g., 28-44, 12-15" />
    </div>

    <!-- Inputs Row 3: knobs -->
    <div class="grid three" style="margin-top:10px">
      <div class="panel">
        <div class="section-title">Generator</div>
        <div class="kv">
          <div class="hint">Rows</div>
          <input id="rowsN" type="number" min="5" max="200" value="20" />
          <div class="hint">Top Pool</div>
          <input id="topPool" type="number" min="6" max="54" value="24" />
          <div class="hint">Seed</div>
          <input id="seed" type="number" value="12345" />
        </div>
      </div>
      <div class="panel">
        <div class="section-title">Coverage & Cohesion</div>
        <div class="kv">
          <div class="hint">Coverage Target (per #)</div>
          <input id="coverTarget" type="number" min="1" max="6" value="2" />
          <div class="hint">Cohesion (0–3)</div>
          <input id="cohesion" type="number" step="0.1" min="0" max="3" value="1.2" />
          <div class="hint">Pair Boost (0–4)</div>
          <input id="pairLambda" type="number" step="0.1" min="0" max="4" value="2.0" />
        </div>
      </div>
      <div class="panel">
        <div class="section-title">Penalties</div>
        <div class="kv">
          <div class="hint">Last Draw Penalty (0–1)</div>
          <input id="penaltyFactor" type="number" step="0.05" min="0" max="1" value="0.35" />
          <div class="hint">Neutral Tilt (−1..+1)</div>
          <input id="neutralTilt" type="number" step="0.1" min="-1" max="1" value="0.0" />
          <div class="hint">Rising Bonus (0–2)</div>
          <input id="risingBonus" type="number" step="0.1" min="0" max="2" value="0.4" />
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="gen" class="primary" style="width:200px">Generate</button>
      <button id="clear" class="ghost" style="width:120px">Clear</button>
    </div>
  </div>

  <div class="grid two" style="margin-top:14px">
    <div class="panel">
      <div class="hint"><b>Rising (Next-peak candidates)</b></div>
      <div id="rising" class="mono" style="margin-top:6px">—</div>
    </div>
    <div class="panel">
      <div class="hint"><b>Phase summary</b> (count of numbers in each phase)</div>
      <div id="phases" style="margin-top:6px">—</div>
      <div id="meta" class="hint" style="margin-top:10px"></div>
    </div>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Primary Pick</b> (top 6 by next-peak weight)</div>
    <pre id="primary">—</pre>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Forecast Set</b> (<span id="rowsCount">20</span> rows)</div>
    <pre id="out">—</pre>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Coverage Stats</b> (Top-Pool coverage counts)</div>
    <pre id="coverage">—</pre>
  </div>
</div>

<script>
(() => {
  // =========================
  // Data: cumulative counts
  // =========================
  const COUNTS_TEXT = `
number count_in_group 26-331, 4-318, 31 318 19 317 27 312 8 310 5 308 21 304 10 302 16 297 22 294 39 294 14 293 38 293 35 292 15 292 7 292 9 290 18 289 33 287 32 285 44 285 41 282 6 280 3 280 28 279 29 278 12 277 40 276 37 275 49 275 13 274 17 273 42 272 34 270 43 269 36 266 24 264 20 264 1 261 2 261 25 258 11 252 23 249 30 247 47 238 46 229 48 229 45 222 50 205 52 193 54 179 51 158 53 157
`.trim();

  // =========================
  // UI elements
  // =========================
  const genBtn = document.getElementById('gen');
  const clrBtn = document.getElementById('clear');
  const risingEl = document.getElementById('rising');
  const phasesEl = document.getElementById('phases');
  const metaEl = document.getElementById('meta');
  const primaryEl = document.getElementById('primary');
  const outEl = document.getElementById('out');
  const coverageEl = document.getElementById('coverage');
  const rowsCountEl = document.getElementById('rowsCount');

  const lastDrawInput = document.getElementById('lastDraw');
  const applyLastBtn = document.getElementById('applyLast');
  const resetLastBtn = document.getElementById('resetLast');
  const lastDrawView = document.getElementById('lastDrawView');

  const lockNumsInput = document.getElementById('lockNums');
  const pairBoostsInput = document.getElementById('pairBoosts');

  const rowsNInput = document.getElementById('rowsN');
  const topPoolInput = document.getElementById('topPool');
  const seedInput = document.getElementById('seed');

  const coverTargetInput = document.getElementById('coverTarget');
  const cohesionInput = document.getElementById('cohesion');
  const pairLambdaInput = document.getElementById('pairLambda');

  const penaltyFactorInput = document.getElementById('penaltyFactor');
  const neutralTiltInput = document.getElementById('neutralTilt');
  const risingBonusInput = document.getElementById('risingBonus');

  // =========================
  // Helpers
  // =========================
  function parseCounts(text){
    const pairs = [];
    const tokens = text.replace(/[,;]/g,' ').split(/\s+/);
    for(let i=0;i<tokens.length;i++){
      const t = tokens[i];
      if(/^\d+-\d+$/.test(t)){ // "n-m"
        const [n,c] = t.split('-').map(Number);
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
        continue;
      }
      if(/^\d+$/.test(t) && i+1<tokens.length && /^\d+$/.test(tokens[i+1])){ // "n m"
        const n = +t, c = +tokens[i+1];
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
      }
    }
    const map = new Map();
    pairs.forEach(([n,c])=>map.set(n,c));
    for(let n=1;n<=54;n++) if(!map.has(n)) map.set(n,0);
    return map;
  }

  function meanStd(values){
    const n = values.length;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  // z-score classification
  function classifyPhases(countMap){
    const entries = Array.from(countMap.entries());
    entries.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const counts = entries.map(e=>e[1]);
    const {mu, sigma} = meanStd(counts);

    const phases = { rising: [], neutral: [], cooling: [] };
    const zmap = new Map();

    entries.forEach(([n,c])=>{
      const z = sigma>0 ? (c - mu)/sigma : 0;
      zmap.set(n, z);
      if(z <= -0.5) phases.rising.push(n);
      else if(Math.abs(z) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    });

    return {entries, phases, zmap, mu, sigma};
  }

  // Probability mapping from z (lower z => higher prob)
  function nextPeakProb(z){
    const a = 2.2, b = 0.0; // centered
    return 1 / (1 + Math.exp(a * (z - b)));
  }

  // Parse last draw
  function parseSix(str){
    if(!str) return [];
    const nums = str.split(/[^0-9]+/).filter(Boolean).map(x=>+x);
    const uniq = Array.from(new Set(nums.filter(n=>n>=1 && n<=54)));
    return uniq.length === 6 ? uniq.slice(0,6) : [];
  }

  // Parse locks (<=6 numbers)
  function parseLocks(str){
    if(!str) return [];
    const nums = str.split(/[^0-9]+/).filter(Boolean).map(x=>+x);
    const uniq = Array.from(new Set(nums.filter(n=>n>=1 && n<=54)));
    return uniq.slice(0,6);
  }

  // Parse pair boosts: "a-b, c-d"
  function parsePairs(str){
    const res = [];
    if(!str) return res;
    const chunks = str.split(/[,]+/).map(s=>s.trim()).filter(Boolean);
    for(const ch of chunks){
      const m = ch.match(/^\s*(\d+)\s*[-:–]\s*(\d+)\s*$/);
      if(m){
        const a = +m[1], b = +m[2];
        if(a>=1&&a<=54&&b>=1&&b<=54&&a!==b){
          res.push([Math.min(a,b), Math.max(a,b)]);
        }
      }
    }
    return res;
  }

  // Seeded RNG (mulberry32)
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // Weighted sample with seeded RNG
  function weightedPick(localMap, rng){
    let total = 0;
    for(const w of localMap.values()) total += w;
    if(total<=0) return null;
    let r = rng()*total;
    for(const [n,w] of localMap.entries()){
      r -= w; if(r<=0) return n;
    }
    // fallback
    return localMap.keys().next().value;
  }

  // =========================
  // Core modeling
  // =========================
  const COUNT_MAP = parseCounts(COUNTS_TEXT);
  const {phases, zmap, mu, sigma} = classifyPhases(COUNT_MAP);

  function buildBaseWeights(zmap, penaltySet=new Set(), penaltyFactor=0.35, neutralTilt=0.0, risingBonus=0.4){
    const weights = new Map();
    for(let n=1;n<=54;n++){
      const z = zmap.get(n) ?? 0;
      let w = Math.max(0.0001, nextPeakProb(z));
      // subtle tilt: push neutral slightly up/down
      if(Math.abs(z) < 0.5) w *= (1 + neutralTilt);
      // rising bonus
      if(z <= -0.5) w *= (1 + risingBonus);
      if(penaltySet.has(n)) w *= penaltyFactor;
      weights.set(n, w);
    }
    return weights;
  }

  function topPoolFromWeights(weights, k){
    const arr = Array.from(weights.entries()).sort((a,b)=>b[1]-a[1] || a[0]-b[0]).slice(0,k).map(([n])=>n);
    return new Set(arr);
  }

  function makePairMap(pairs){
    const m = new Map();
    for(const [a,b] of pairs){
      if(!m.has(a)) m.set(a, new Set());
      if(!m.has(b)) m.set(b, new Set());
      m.get(a).add(b);
      m.get(b).add(a);
    }
    return m;
  }

  // Build a single row using: coverage boosts, pair attraction, cohesion
  function buildRow(params){
    const {
      rng, baseWeights, locked, pairMap, coverageMap, targetSet, coverTarget,
      cohesionLambda, zmap
    } = params;

    const pick = new Set(locked);
    if(pick.size > 6) return null;

    // Work map
    const chosen = new Set(locked);

    // helper: dynamic weight snapshot
    const currentWeights = () => {
      const wm = new Map();
      for(const [n, w0] of baseWeights.entries()){
        if(chosen.has(n)) continue;
        let w = w0;
        // Coverage boost for target numbers not yet seen enough
        if(targetSet.has(n)){
          const have = coverageMap.get(n) || 0;
          const need = Math.max(0, coverTarget - have);
          if(need>0){
            // Boost grows with need, tapering by sqrt to avoid overpower
            w *= (1 + 0.9 * Math.sqrt(need));
          }
        }
        // Pair attraction: if partner already chosen, lift this one
        const partners = pairMap.get(n);
        if(partners){
          let links = 0;
          for(const p of partners){ if(chosen.has(p)) links++; }
          if(links>0){
            w *= (1 + links * params.pairLambda); // pairLambda ~ 2.0 default
          }
        }
        // Cohesion: prefer numbers with z below mean of chosen z (i.e., similar phase)
        if(cohesionLambda > 0 && chosen.size>0){
          let avgz = 0;
          for(const c of chosen) avgz += (zmap.get(c)||0);
          avgz /= chosen.size;
          const z = zmap.get(n)||0;
          // penalty increases with |z - avgz|
          const dz = Math.abs(z - avgz);
          w *= 1 / (1 + cohesionLambda * dz);
        }
        wm.set(n, Math.max(0.000001, w));
      }
      return wm;
    };

    while(pick.size < 6){
      const wm = currentWeights();
      if(wm.size===0) break;
      const chosenN = weightedPick(wm, rng);
      if(chosenN==null) break;
      pick.add(chosenN);
      chosen.add(chosenN);
    }
    if(pick.size<6) return null;

    return Array.from(pick).sort((a,b)=>a-b);
  }

  function generateSet(options){
    const {
      rowsN, lastDrawSet, penaltyFactor, neutralTilt, risingBonus,
      locks, pairs, topPoolK, coverTarget, cohesionLambda, pairLambda, seed
    } = options;

    const rng = mulberry32(seed>>>0);
    const baseWeights = buildBaseWeights(zmap, lastDrawSet, penaltyFactor, neutralTilt, risingBonus);
    const targetSet = topPoolFromWeights(baseWeights, topPoolK);
    const pairMap = makePairMap(pairs);

    const coverageMap = new Map(); // counts on targetSet only
    for(const t of targetSet) coverageMap.set(t, 0);

    const seenRows = new Set();
    const rows = [];

    let guard = 0;
    while(rows.length < rowsN && guard++ < rowsN*200){
      const row = buildRow({
        rng,
        baseWeights,
        locked: locks,
        pairMap,
        coverageMap,
        targetSet,
        coverTarget,
        cohesionLambda,
        pairLambda,
        zmap
      });
      if(!row) continue;
      const sig = row.join('-');
      if(seenRows.has(sig)) continue;

      // Update coverage counts
      for(const n of row){
        if(targetSet.has(n)){
          coverageMap.set(n, (coverageMap.get(n)||0) + 1);
        }
      }
      rows.push(sig);
      seenRows.add(sig);
    }

    // Primary pick: top6 by baseWeights (post-penalties/bonuses)
    const top6 = Array.from(baseWeights.entries())
      .sort((a,b)=>b[1]-a[1] || a[0]-b[0])
      .slice(0,6)
      .map(([n])=>n)
      .sort((a,b)=>a-b);

    return {rows, top6, targetSet, coverageMap, baseWeights};
  }

  // =========================
  // Initial phase rendering
  // =========================
  function renderPhaseSummary(phases){
    const r = phases.rising.length, n = phases.neutral.length, c = phases.cooling.length;
    phasesEl.innerHTML = `
      <div class="pill ok">Rising: ${r}</div>
      <div class="pill warn">Neutral: ${n}</div>
      <div class="pill bad">Cooling: ${c}</div>
    `;
  }
  function renderRisingList(phases, countMap){
    const list = phases.rising.slice().sort((a,b)=>COUNT_MAP.get(a)-COUNT_MAP.get(b) || a-b);
    risingEl.textContent = list.length ? list.join(' ') : '—';
  }

  renderPhaseSummary(phases);
  renderRisingList(phases, COUNT_MAP);
  metaEl.textContent = `Mean (μ) ≈ ${mu.toFixed(1)}, σ ≈ ${sigma.toFixed(1)}. Phases by z: Rising (z ≤ −0.5), Neutral (|z| < 0.5), Cooling (z ≥ +0.5). Lower z → higher next-peak weight.`;

  // =========================
  // Last draw UI
  // =========================
  let lastDrawSet = new Set();

  function showLastDraw(list){
    if(list.length === 6){
      lastDrawView.innerHTML = `Penalizing (cooling after last draw): ` + list.map(n=>`<span class="tag">${n}</span>`).join(' ');
    }else{
      lastDrawView.textContent = 'Enter exactly 6 numbers (1–54), separated by spaces or commas.';
    }
  }

  applyLastBtn.addEventListener('click', ()=>{
    const list = parseSix(lastDrawInput.value);
    if(list.length === 6){
      lastDrawSet = new Set(list);
      showLastDraw(list);
      runOnce();
    }else{
      showLastDraw([]);
      alert('Please enter exactly 6 valid numbers between 1 and 54.');
    }
  });

  resetLastBtn.addEventListener('click', ()=>{
    lastDrawSet = new Set();
    lastDrawInput.value = '';
    showLastDraw([]);
    runOnce();
  });

  // =========================
  // Main run
  // =========================
  function runOnce(){
    // Read knobs
    const rowsN = Math.max(5, Math.min(200, +rowsNInput.value||20));
    const topPoolK = Math.max(6, Math.min(54, +topPoolInput.value||24));
    const seed = (+seedInput.value||12345) >>> 0;

    const locks = parseLocks(lockNumsInput.value);
    const pairs = parsePairs(pairBoostsInput.value);
    const coverTarget = Math.max(1, Math.min(6, +coverTargetInput.value||2));
    const cohesionLambda = Math.max(0, Math.min(3, +cohesionInput.value||1.2));
    const pairLambda = Math.max(0, Math.min(4, +pairLambdaInput.value||2.0));

    const penaltyFactor = Math.max(0, Math.min(1, +penaltyFactorInput.value||0.35));
    const neutralTilt = Math.max(-1, Math.min(1, +neutralTiltInput.value||0.0));
    const risingBonus = Math.max(0, Math.min(2, +risingBonusInput.value||0.4));

    // Generate
    const {rows, top6, targetSet, coverageMap} = generateSet({
      rowsN,
      lastDrawSet,
      penaltyFactor,
      neutralTilt,
      risingBonus,
      locks,
      pairs,
      topPoolK,
      coverTarget,
      cohesionLambda,
      pairLambda,
      seed
    });

    rowsCountEl.textContent = rowsN.toString();
    primaryEl.textContent = top6.join('-');
    outEl.textContent = rows.length ? rows.join('\n') : '—';

    // Coverage panel
    const targetList = Array.from(targetSet).sort((a,b)=>a-b);
    const covLines = [];
    for(const n of targetList){
      const c = coverageMap.get(n)||0;
      covLines.push(String(n).padStart(2,' ') + ': ' + c);
    }
    coverageEl.textContent = covLines.join('  |  ');
  }

  genBtn.addEventListener('click', runOnce);
  clrBtn.addEventListener('click', ()=>{
    primaryEl.textContent = '—';
    outEl.textContent = '—';
    coverageEl.textContent = '—';
  });

  // Auto-run on load
  showLastDraw([]);
  runOnce();
})();
</script>
</body>
</html>
