<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wave Forecast — Next High Peaks From 336 Groups</title>
<style>
  :root{--bg:#0b1020;--ink:#eaf0ff;--mut:#9fb0d0;--panel:#121936;--line:#223062;--pill:#0d1a3b}
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:980px;margin:0 auto;padding:20px}
  h1{margin:0 0 10px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:10px;align-items:center}
  button{cursor:pointer;font-weight:800;border-radius:12px;border:1px solid var(--line);padding:12px 14px;width:100%}
  .primary{background:linear-gradient(180deg,#1e90ff,#1672cc);border-color:#1672cc;color:#fff}
  .ghost{background:transparent;color:var(--ink)}
  pre{white-space:pre-wrap;word-break:break-word;background:#0f1533;border:1px solid var(--line);border-radius:12px;padding:12px;min-height:140px}
  .hint{color:var(--mut);font-size:.95rem}
  .grid{display:grid;gap:12px}
  .two{grid-template-columns:1fr 1fr}
  .pill{display:inline-block;background:var(--pill);border:1px solid #2a386f;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;font-weight:700}
  .ok{color:#24d17e} .warn{color:#ffd166} .bad{color:#ff6b6b}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .quote{font-style:italic;color:#cfe2ff}
</style>
</head>
<body>
<div class="wrap">
  <h1>Wave Forecast — Next High Peaks (No Recent Draws Needed)</h1>

  <!-- Your wave explanation is embedded here -->
  <div class="panel">
    <div class="hint"><b>Wave behavior in draw frequencies</b></div>
    <p class="quote">
      Each number has its own waveform across the 336 groups.<br>
      <b>High peak (hot phase)</b>: the number appears frequently across several consecutive groups (like 28 &amp; 44).<br>
      <b>Cooling phase</b>: frequency drops for 3–6 groups.<br>
      <b>Re-heat</b>: the number returns when its internal cycle resets.<br>
      Think of it as a sinusoidal wave for each ball, at different phases and amplitudes. The dataset lets us measure that phase timing.
    </p>
    <div class="row" style="margin-top:10px">
      <button id="gen" class="primary">Generate 20 numbers</button>
      <button id="clear" class="ghost">Clear</button>
    </div>
  </div>

  <div class="grid two" style="margin-top:14px">
    <div class="panel">
      <div class="hint"><b>Rising (Next-peak candidates)</b></div>
      <div id="rising" class="mono" style="margin-top:6px">—</div>
    </div>
    <div class="panel">
      <div class="hint"><b>Phase summary</b> (count of numbers in each phase)</div>
      <div id="phases" style="margin-top:6px">—</div>
      <div id="meta" class="hint" style="margin-top:10px"></div>
    </div>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Primary Pick</b> (top 6 by next-peak probability)</div>
    <pre id="primary">—</pre>
  </div>

  <div class="panel" style="margin-top:14px">
    <div class="hint"><b>Forecast Set (20 rows)</b></div>
    <pre id="out">—</pre>
  </div>
</div>

<script>
(() => {
  // Your cumulative counts (exactly as provided). Parser accepts "n-m" and "n m".
  const COUNTS_TEXT = `
number count_in_group 26-331, 4-318, 31 318 19 317 27 312 8 310 5 308 21 304 10 302 16 297 22 294 39 294 14 293 38 293 35 292 15 292 7 292 9 290 18 289 33 287 32 285 44 285 41 282 6 280 3 280 28 279 29 278 12 277 40 276 37 275 49 275 13 274 17 273 42 272 34 270 43 269 36 266 24 264 20 264 1 261 2 261 25 258 11 252 23 249 30 247 47 238 46 229 48 229 45 222 50 205 52 193 54 179 51 158 53 157
`.trim();

  const genBtn = document.getElementById('gen');
  const clrBtn = document.getElementById('clear');
  const risingEl = document.getElementById('rising');
  const phasesEl = document.getElementById('phases');
  const metaEl = document.getElementById('meta');
  const primaryEl = document.getElementById('primary');
  const outEl = document.getElementById('out');

  // ---------- Parse counts ----------
  function parseCounts(text){
    const pairs = [];
    const tokens = text.replace(/[,;]/g,' ').split(/\s+/);
    for(let i=0;i<tokens.length;i++){
      const t = tokens[i];
      if(/^\d+-\d+$/.test(t)){ // "n-m"
        const [n,c] = t.split('-').map(Number);
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
        continue;
      }
      if(/^\d+$/.test(t) && i+1<tokens.length && /^\d+$/.test(tokens[i+1])){ // "n m"
        const n = +t, c = +tokens[i+1];
        if(n>=1&&n<=54&&c>=0) pairs.push([n,c]);
      }
    }
    const map = new Map();
    pairs.forEach(([n,c])=>map.set(n,c));
    for(let n=1;n<=54;n++) if(!map.has(n)) map.set(n,0);
    return map;
  }

  function meanStd(values){
    const n = values.length;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  // ---------- Wave model from z-scores ----------
  // Phase rules:
  //   z <= -0.5  -> RISING (due to form next peaks)
  //   |z| < 0.5  -> NEUTRAL
  //   z >= +0.5  -> COOLING (just peaked; suppressed)
  function classifyPhases(countMap){
    const entries = Array.from(countMap.entries()); // [n, count]
    entries.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);    // highest first
    const counts = entries.map(e=>e[1]);
    const {mu, sigma} = meanStd(counts);

    const phases = { rising: [], neutral: [], cooling: [] };
    const zmap = new Map();

    entries.forEach(([n,c])=>{
      const z = sigma>0 ? (c - mu)/sigma : 0;
      zmap.set(n, z);
      if(z <= -0.5) phases.rising.push(n);
      else if(Math.abs(z) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    });

    return {entries, phases, zmap, mu, sigma};
  }

  // Convert phase to next-peak probability via logistic on z (lower z -> higher prob)
  // p = 1 / (1 + exp( a * (z - b) ))
  function nextPeakProb(z){
    const a = 2.2, b = 0.0; // centered at z=0
    return 1 / (1 + Math.exp(a * (z - b)));
  }

  function buildWeights(countMap, zmap){
    const weights = new Map();
    for(const [n] of countMap.entries()){
      const z = zmap.get(n) ?? 0;
      const p = Math.max(0.0001, nextPeakProb(z));
      weights.set(n, p);
    }
    return weights;
  }

  // Weighted sampling without replacement per row
  function weightedSampleNoReplace(weights, k, exclude=new Set()){
    const local = new Map();
    let total = 0;
    for(const [n,w] of weights.entries()){
      if(!exclude.has(n) && w>0){ local.set(n,w); total += w; }
    }
    if(local.size < k) return null;

    const pick = [];
    while(pick.length < k && local.size){
      let r = Math.random() * Array.from(local.values()).reduce((a,b)=>a+b,0);
      let chosen = null;
      for(const [n,w] of local.entries()){
        r -= w; if(r <= 0){ chosen = n; break; }
      }
      if(chosen==null) chosen = local.keys().next().value;
      pick.push(chosen);
      local.delete(chosen);
    }
    return pick.sort((a,b)=>a-b);
  }

  function generateRows(weights, rowsN=20){
    const rows = [];
    const seen = new Set();
    let guard = 0;
    while(rows.length < rowsN && guard++ < 5000){
      const row = weightedSampleNoReplace(weights, 6);
      if(!row) break;
      const sig = row.join('-');
      if(!seen.has(sig)){ seen.add(sig); rows.push(sig); }
    }
    return rows;
  }

  // ---------- Render helpers ----------
  function renderPhaseSummary(phases){
    const r = phases.rising.length, n = phases.neutral.length, c = phases.cooling.length;
    phasesEl.innerHTML = `
      <div class="pill ok">Rising: ${r}</div>
      <div class="pill warn">Neutral: ${n}</div>
      <div class="pill bad">Cooling: ${c}</div>
    `;
  }
  function renderRisingList(phases, countMap){
    const list = phases.rising.slice().sort((a,b)=>countMap.get(a)-countMap.get(b) || a-b);
    risingEl.textContent = list.length ? list.join(' ') : '—';
  }

  // ---------- Main run ----------
  const COUNT_MAP = parseCounts(COUNTS_TEXT);
  const {phases, zmap, mu, sigma} = classifyPhases(COUNT_MAP);
  const WEIGHTS = buildWeights(COUNT_MAP, zmap);

  // Pre-show phase stats and explanation
  renderPhaseSummary(phases);
  renderRisingList(phases, COUNT_MAP);
  metaEl.textContent = `Mean (μ) ≈ ${mu.toFixed(1)}, σ ≈ ${sigma.toFixed(1)}. Phases by z: Rising (z ≤ −0.5), Neutral (|z| < 0.5), Cooling (z ≥ +0.5). Lower z → higher next-peak weight.`;

  function runOnce(){
    // Primary pick = top 6 by next-peak probability (weights)
    const top6 = Array.from(WEIGHTS.entries())
      .sort((a,b)=>b[1]-a[1] || a[0]-b[0])
      .slice(0,6).map(([n])=>n).sort((a,b)=>a-b);
    primaryEl.textContent = top6.join('-');

    // Forecast rows (20)
    const rows = generateRows(WEIGHTS, 20);
    outEl.textContent = rows.length ? rows.join('\n') : '—';
  }

  genBtn.addEventListener('click', runOnce);
  clrBtn.addEventListener('click', ()=>{
    primaryEl.textContent = '—';
    outEl.textContent = '—';
  });

  // Auto-run on load so you immediately see results
  runOnce();
})();
</script>
</body>
</html>
