<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST (America/Chicago) — Live Constellation (un-stoppable)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#111831; --ink:#eaf0ff; --muted:#a7b0c3;
    --gps:#34d399; --geo:#fbbf24; --accent:#5eead4;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1400px;margin:auto;padding:20px;display:grid;gap:16px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
        border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:16px}
  h1{margin:0 0 6px 0;font-size:20px}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .row{display:grid;grid-template-columns:1.05fr 0.95fr;gap:16px}
  .kvs{display:grid;grid-template-columns:auto 1fr;gap:6px 12px;align-items:center}
  .big{font-size:28px;letter-spacing:.5px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.08);text-align:left;font-size:13px}
  thead th{position:sticky;top:0;background:rgba(17,24,49,.9);backdrop-filter:blur(6px)}
  .scroll{max-height:520px;overflow:auto;border:1px solid rgba(255,255,255,.08);border-radius:12px}
  .nowrap{white-space:nowrap}
  .globe{width:100%;aspect-ratio:1.2/1; background:radial-gradient(120% 100% at 50% 50%, #0f1732 0%, #0b1020 60%, #070a16 100%);
         border:1px solid rgba(255,255,255,.08);border-radius:14px;position:relative;overflow:hidden}
  svg{display:block;width:100%;height:100%}
  .sat{fill:var(--gps)}
  .satlbl{fill:var(--gps); font-size:10px}
  .earthStroke{stroke:#2b3f8f; stroke-width:1}
  .gridline{stroke:#1b2b63; stroke-width:0.5; opacity:0.5}
  .small{font-size:12px}
  .ok{color:#22c55e} .warn{color:#fbbf24} .bad{color:#ef4444}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>CST — Central Time (America/Chicago) as Baseline — Live Constellation</h1>
      <div class="muted">
        All clocks use <b>CST (America/Chicago)</b>. 30 satellites orbit with variable speed. Engine has
        watchdog + fallback so the page keeps running even if the browser throttles.
      </div>
      <div class="mono small muted" id="statusLine">status: initializing…</div>
    </div>

    <div class="card">
      <div class="row">
        <div>
          <div class="muted">Local CST (America/Chicago)</div>
          <div id="cstTime" class="big mono">--:--:--.---</div>
          <div class="muted mono" id="cstIso">—</div>

          <div class="kvs" style="margin-top:10px">
            <div>Elapsed since CST midnight</div><div class="mono" id="sinceMid">— s</div>
            <div>Comparison drift rates</div><div class="mono">GEO: +45 μs/day · GPS (net): +38 μs/day</div>
            <div>Nominal orbital radius</div><div class="mono">r ≈ 26,571 km (Earth center → GPS satellite)</div>
            <div>Engine</div><div class="mono" id="engineMode">—</div>
            <div>Watchdog</div><div class="mono" id="watchdog">armed</div>
          </div>
        </div>

        <div>
          <div class="muted">How the phase numbers should look</div>
          <ul class="muted small" style="line-height:1.4">
            <li>Δns GPS ranges from ~0 ns (at CST midnight) to ~38,000 ns (before next midnight).</li>
            <li>Δns GEO ranges from ~0 ns to ~45,000 ns across the CST day.</li>
            <li>If you see ~6× those values, it means a phase was accidentally applied more than once (fixed here).</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="muted" style="margin-bottom:8px">Globe — satellites orbiting (illustrative)</div>
      <div class="globe">
        <svg id="globeSvg" viewBox="0 0 800 500" role="img" aria-label="Earth with satellites">
          <defs>
            <radialGradient id="earthGlow" cx="50%" cy="50%" r="55%">
              <stop offset="0%" stop-color="#1f3b7a"/>
              <stop offset="70%" stop-color="#14234b"/>
              <stop offset="100%" stop-color="#0b1020"/>
            </radialGradient>
          </defs>
          <rect x="0" y="0" width="800" height="500" fill="transparent"/>
          <g id="earth" transform="translate(300,250)">
            <circle r="110" fill="url(#earthGlow)" class="earthStroke"/>
            <g id="grid">
              <circle r="108" fill="none" class="gridline"/>
              <line x1="-110" y1="0" x2="110" y2="0" class="gridline"/>
              <line x1="0" y1="-110" x2="0" y2="110" class="gridline"/>
            </g>
          </g>
          <g id="orbitRing" transform="translate(300,250)">
            <circle r="200" fill="none" stroke="rgba(255,255,255,.12)"/>
          </g>
          <g id="satLayer"></g>
        </svg>
      </div>
    </div>

    <div class="card">
      <div class="muted" style="margin-bottom:8px">Satellites — moving; Angle & Speed vary — all clocks in CST</div>
      <div class="scroll">
        <table id="satTable" class="mono">
          <thead>
            <tr>
              <th>#</th>
              <th>Name</th>
              <th>Angle&nbsp;(°)</th>
              <th>Sub-Lon&nbsp;(°)</th>
              <th>Instant Speed</th>
              <th>Atomic CST</th>
              <th>GEO&nbsp;(+45 μs/day)</th>
              <th>GPS&nbsp;(+38 μs/day)</th>
              <th>Δns&nbsp;GEO</th>
              <th>Δns&nbsp;GPS</th>
            </tr>
          </thead>
          <tbody id="satBody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== CONFIG =====
  const SAT_COUNT = 30;
  const ORBIT_PERIOD_SEC_MEAN = 12 * 3600; // 12 hours mean orbital period
  const ORBITAL_RADIUS_KM     = 26571;     // center-of-Earth -> GPS satellite
  const RATE_GEO_US_PER_DAY   = 45;        // μs/day
  const RATE_GPS_US_PER_DAY   = 38;        // μs/day
  const SECS_PER_DAY          = 86400;
  const CST_TZ                = 'America/Chicago';

  // ===== Robustness tuning =====
  const CLOCK_HZ   = 10;   // top clock updates per second
  const TABLE_HZ   = 5;    // table updates per second
  const SPRITE_HZ  = 15;   // sprite writes per second
  const STALL_MS   = 4000; // watchdog threshold for engine stall
  const INTERVAL_FPS = 60; // fallback engine cadence

  // ===== Time helpers (CST everywhere) =====
  function getCSTParts(epochMs){
    const df = new Intl.DateTimeFormat('en-US', {
      timeZone: CST_TZ, hour12: false,
      year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit'
    });
    const parts = df.formatToParts(new Date(epochMs));
    const map = {};
    for(const p of parts) map[p.type] = p.value;
    const ms = new Date(epochMs).getMilliseconds();
    return {
      year:+map.year, month:+map.month, day:+map.day,
      hour:+map.hour, minute:+map.minute, second:+map.second,
      millisecond: ms
    };
  }
  function formatCST_HMSms(epochMs){
    const p = getCSTParts(epochMs);
    const pad = (n,w=2)=>String(n).padStart(w,'0');
    return `${pad(p.hour)}:${pad(p.minute)}:${pad(p.second)}.${String(p.millisecond).padStart(3,'0')}`;
  }
  function secondsSinceCstMidnight(epochMs){
    const p = getCSTParts(epochMs);
    return p.hour*3600 + p.minute*60 + p.second + p.millisecond/1000;
  }
  function phaseSecondsGeo(dtCst){ return (RATE_GEO_US_PER_DAY*1e-6) * (dtCst/SECS_PER_DAY); }
  function phaseSecondsGps(dtCst){ return (RATE_GPS_US_PER_DAY*1e-6) * (dtCst/SECS_PER_DAY); }

  // ===== Orbit dynamics =====
  const OMEGA_MEAN = 2*Math.PI / ORBIT_PERIOD_SEC_MEAN; // rad/s
  const sats = Array.from({length: SAT_COUNT}, (_,i) => {
    const pertAmp    = 0.003 + Math.random()*0.006;        // small fractional modulation
    const pertPeriod = 300 + Math.random()*1200;           // seconds (5–25 min)
    const omegaMean  = OMEGA_MEAN * (1 + (Math.random()-0.5)*0.002); // ±0.1%
    const initial    = Math.random()*2*Math.PI;
    return {
      id:i+1, name:`SAT-${String(i+1).padStart(2,'0')}`,
      omegaMean, pertAmp, pertPeriod,
      angleRad: initial
    };
  });

  // ===== DOM =====
  const elCstTime  = document.getElementById('cstTime');
  const elCstIso   = document.getElementById('cstIso');
  const elSince    = document.getElementById('sinceMid');
  const tbody      = document.getElementById('satBody');
  const satLayer   = document.getElementById('satLayer');
  const statusLine = document.getElementById('statusLine');
  const engineModeEl = document.getElementById('engineMode');
  const watchdogEl = document.getElementById('watchdog');

  // ===== Build UI (table + globe sprites) =====
  function buildUI(){
    const frag = document.createDocumentFragment();
    const ns = "http://www.w3.org/2000/svg";
    for(const s of sats){
      // table row
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="nowrap">${s.id}</td>
        <td>${s.name}</td>
        <td id="ang-${s.id}" class="nowrap">0.00</td>
        <td id="lon-${s.id}" class="nowrap">0.00</td>
        <td id="spd-${s.id}" class="nowrap">—</td>
        <td id="utc-${s.id}" class="nowrap">--:--:--.---</td>
        <td id="geo-${s.id}" class="nowrap">--:--:--.---</td>
        <td id="gps-${s.id}" class="nowrap">--:--:--.---</td>
        <td id="dnsG-${s.id}" class="nowrap">0 ns</td>
        <td id="dnsP-${s.id}" class="nowrap">0 ns</td>
      `;
      frag.appendChild(tr);

      // SVG sprite
      const g = document.createElementNS(ns,'g');
      g.setAttribute('id', `sprite-${s.id}`);
      const c = document.createElementNS(ns,'circle');
      c.setAttribute('r','4'); c.setAttribute('class','sat');
      const t = document.createElementNS(ns,'text');
      t.setAttribute('class','satlbl mono');
      t.setAttribute('text-anchor','start');
      t.textContent = s.name;
      g.appendChild(c); g.appendChild(t);
      satLayer.appendChild(g);
    }
    tbody.appendChild(frag);
  }

  // map angle (deg) to svg coords
  function orbitXY(angleDeg){
    const cx = 300, cy = 250, R = 200;
    const a = angleDeg * Math.PI/180;
    return { x: cx + R*Math.cos(a), y: cy + R*Math.sin(a) };
  }

  // ===== Engine (RAF with interval fallback) =====
  let rafId = null, intervalId = null;
  let lastPerfTs = performance.now();
  let lastWallUpdate = Date.now();
  let lastClockWrite = 0, lastTableWrite = 0, lastSpriteWrite = 0;

  function setEngineMode(txt, cls){
    engineModeEl.textContent = txt;
    engineModeEl.className = `mono ${cls||''}`;
  }

  function stopEngines(){
    if(rafId!==null){ cancelAnimationFrame(rafId); rafId=null; }
    if(intervalId!==null){ clearInterval(intervalId); intervalId=null; }
  }

  function startRAF(){
    stopEngines();
    setEngineMode('requestAnimationFrame', 'ok');
    lastPerfTs = performance.now();
    rafId = requestAnimationFrame(rafFrame);
  }

  function startInterval(){
    stopEngines();
    setEngineMode('setInterval @ '+INTERVAL_FPS+'fps', 'warn');
    const step = 1000/INTERVAL_FPS;
    lastPerfTs = performance.now();
    intervalId = setInterval(() => rafFrame(performance.now()), step);
  }

  function rafFrame(nowPerf){
    try{
      // queue next raf early (if using RAF)
      if(rafId!==null) rafId = requestAnimationFrame(rafFrame);

      const dt_ms = nowPerf - lastPerfTs; lastPerfTs = nowPerf;
      const dt_s  = Math.max(0, Math.min(dt_ms/1000, 0.2)); // clamp dt to avoid jumps
      const wallNow = Date.now();

      // integrate motion every frame
      for(const s of sats){
        const mod   = 1 + s.pertAmp * Math.sin((2*Math.PI * (wallNow/1000)) / s.pertPeriod + s.id);
        const omega = s.omegaMean * mod; // rad/s
        s.angleRad  = (s.angleRad + omega * dt_s + 2*Math.PI) % (2*Math.PI);
      }

      // Throttled writes
      if(wallNow - lastClockWrite >= 1000/CLOCK_HZ){
        lastClockWrite = wallNow;
        elCstTime.textContent = formatCST_HMSms(wallNow);
        elCstIso.textContent  = new Date(wallNow).toLocaleString('en-US', { timeZone: CST_TZ, hour12:false });
        elSince.textContent   = secondsSinceCstMidnight(wallNow).toFixed(3) + ' s';
      }

      if(wallNow - lastTableWrite >= 1000/TABLE_HZ){
        lastTableWrite = wallNow;
        const secCST = secondsSinceCstMidnight(wallNow);
        const phiGeo = (RATE_GEO_US_PER_DAY*1e-6) * (secCST/SECS_PER_DAY); // s
        const phiGps = (RATE_GPS_US_PER_DAY*1e-6) * (secCST/SECS_PER_DAY); // s
        const dnsGeo = Math.round(phiGeo*1e9);
        const dnsGps = Math.round(phiGps*1e9);

        const atomicCst = formatCST_HMSms(wallNow);
        const geoCst    = formatCST_HMSms(wallNow + phiGeo*1000);
        const gpsCst    = formatCST_HMSms(wallNow + phiGps*1000);

        for(const s of sats){
          const angleDeg = s.angleRad * 180/Math.PI;
          const subLon   = ((angleDeg - 180 + 540) % 360) - 180;
          const omegaNow = (s.omegaMean * (1 + s.pertAmp * Math.sin((2*Math.PI * (wallNow/1000)) / s.pertPeriod + s.id)));
          const v_km_s   = omegaNow * ORBITAL_RADIUS_KM;
          const v_km_h   = v_km_s * 3600;

          document.getElementById(`ang-${s.id}`).textContent  = angleDeg.toFixed(2);
          document.getElementById(`lon-${s.id}`).textContent  = subLon.toFixed(2);
          document.getElementById(`spd-${s.id}`).textContent  = `${v_km_s.toFixed(4)} km/s (${Math.round(v_km_h).toLocaleString()} km/h)`;
          document.getElementById(`utc-${s.id}`).textContent  = atomicCst;
          document.getElementById(`geo-${s.id}`).textContent  = geoCst;
          document.getElementById(`gps-${s.id}`).textContent  = gpsCst;
          document.getElementById(`dnsG-${s.id}`).textContent = `${dnsGeo} ns`;
          document.getElementById(`dnsP-${s.id}`).textContent = `${dnsGps} ns`;
        }
        lastWallUpdate = wallNow;
      }

      if(wallNow - lastSpriteWrite >= 1000/SPRITE_HZ){
        lastSpriteWrite = wallNow;
        for(const s of sats){
          const angleDeg = s.angleRad * 180/Math.PI;
          const p = orbitXY(angleDeg);
          const g = document.getElementById(`sprite-${s.id}`);
          if(g){
            g.setAttribute('transform', `translate(${p.x},${p.y})`);
            const lbl = g.lastChild;
            lbl.setAttribute('x', 6); lbl.setAttribute('y', -6);
          }
        }
      }

      // record progress for watchdog
      lastWallUpdate = wallNow;
    }catch(err){
      statusLine.innerHTML = `status: <span class="warn">recovered</span> — ${err && err.message ? err.message : err}`;
      // keep running; engines continue
    }
  }

  // Watchdog: restart / switch engines on stall or when tab visibility changes
  setInterval(() => {
    const lag = Date.now() - lastWallUpdate;
    if(lag > STALL_MS){
      // Try switching engines
      if(rafId!==null){
        startInterval();
      }else{
        startRAF();
      }
      watchdogEl.textContent = `recovered (lag ${lag}ms)`;
      statusLine.textContent = 'status: restarted after stall';
    }else{
      watchdogEl.textContent = `ok (lag ${lag}ms)`;
    }
  }, 1500);

  document.addEventListener('visibilitychange', () => {
    if(document.visibilityState === 'visible'){
      // Prefer RAF if visible
      startRAF();
    }else{
      // Background tabs get throttled; interval keeps state moving
      startInterval();
    }
  });

  // ===== Boot =====
  (function init(){
    try{
      // build table & sprites
      buildUI();
      // seed sprites at t0 (optional)
      for(const s of sats){
        const p = orbitXY((s.angleRad*180/Math.PI));
        const g = document.getElementById(`sprite-${s.id}`);
        if(g){
          g.setAttribute('transform', `translate(${p.x},${p.y})`);
          const lbl = g.lastChild; lbl.setAttribute('x', 6); lbl.setAttribute('y', -6);
        }
      }
      // start RAF by default
      startRAF();
      statusLine.textContent = 'status: running';
    }catch(e){
      statusLine.textContent = 'status: init error — ' + e.message;
      // still try to start an engine
      startInterval();
    }
  })();
})();
</script>
</body>
</html>
