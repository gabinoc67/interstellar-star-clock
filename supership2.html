<!-- ======================= PART 1 / 4 =======================
CST Warp Navigation — Full Simulation (UPGRADED: SR/GR clocks + E↔m ledger + Bubble A,R,w + Stability)
What’s new (shown LIVE in the new panel + physics readout):
1) SR clock uses γ from a real β=v/c (no more “warp/10 gamma” shortcut)
2) Adds weak-field gravity term: (1 + Φ/c²) / γ
3) Adds strict mass↔energy ledger:
   - Mass burn rate → E_avail
   - Plasma reservoir E_plasma
   - Field energy stored E_stored
   - Equivalent mass m_eq = E_stored / c²
4) Bubble module is now a power-hungry control system:
   - A (amplitude), R (radius), w (wall thickness)
   - E_req(A,R,w)=K*A²*R³/w
   - Stability S decays with A², (R/w), power noise, and |dA/dt|
   - If S ≤ 0 → automatic shutdown + energy dump message
5) Warp “benefit” is tied to bubble health:
   - G_warp = 1 + α*A*S
   - Effective traversal time uses G_warp (toy), capped by stability.
============================================================== -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CST Warp Navigation — Full Simulation (SR/GR + E↔m + Bubble Control)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{
    margin:0;
    height:100%;
    background:#020617;
    overflow:hidden;
    font-family:Segoe UI,Roboto,Arial,sans-serif;
    color:#e8f3ff;
  }
  canvas{ position:fixed; inset:0; }
  .hudpanel{
    position:fixed;
    background:rgba(12,22,52,0.78);
    padding:12px 16px;
    border:1px solid rgba(130,190,255,0.65);
    border-radius:12px;
    backdrop-filter:blur(10px);
    font-size:13px;
  }
  #panelMain{ top:10px; right:10px; max-width:360px; }
  #panelClocks{ bottom:10px; left:10px; max-width:330px; }
  #panelPhysics{ bottom:10px; right:10px; max-width:380px; }
  #panelUpgrades{ top:10px; left:10px; max-width:420px; }

  h2{ margin:0 0 6px; font-size:16px; letter-spacing:.06em; }
  .label{
    margin-top:8px;
    font-size:11px;
    color:#8dbaff;
    text-transform:uppercase;
    letter-spacing:.12em;
  }
  .value{ margin-top:3px; font-size:13px; }
  .tiny{ font-size:12px; color:#bfe3ff; opacity:.92; line-height:1.35; }
  .mono{ font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  select,button{
    width:100%;
    padding:7px 8px;
    margin-top:6px;
    background:#0c1634;
    color:#d5e9ff;
    border:1px solid #3d67b8;
    border-radius:6px;
    font-size:14px;
    cursor:pointer;
  }
  #calcBtn{ background:#0c1634; }
  #engageBtn{ background:#003ae3; }
  #engageBtn:hover{ background:#0d4aff; }
  #stopBtn{ background:#3a0a0a; border-color:#b84747; }
  #stopBtn:hover{ background:#5a1010; }
  #safetyBtn{ background:#07203f; }
  #resetBtn{ background:#0b1222; }

  #msg{ margin-top:8px; font-size:12px; color:#9fd7ff; min-height:18px; }
  #safeMsg{ margin-top:4px; font-size:12px; }

  .grid2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .kv{
    padding:8px 10px;
    border:1px solid rgba(148,163,184,.22);
    border-radius:10px;
    background:rgba(2,6,23,0.22);
  }
  .k{ font-size:11px; color:#8dbaff; letter-spacing:.12em; text-transform:uppercase; }
  .v{ margin-top:4px; font-size:13px; }
</style>
</head>
<body>
<canvas id="sim"></canvas>

<!-- UPGRADES / NEW EXPLANATION PANEL -->
<div class="hudpanel" id="panelUpgrades">
  <h2>Upgrades: SR/GR + E↔m + Bubble Control</h2>
  <div class="tiny">
    This simulation now runs a <b>hard clock</b> and a <b>hard energy ledger</b>:
    <div class="mono" style="margin-top:6px;">
      E = γ m c²<br>
      Δτ ≈ Δt (1 + Φ/c²) / γ<br>
      m_eq = E_stored / c²<br>
      E_req(A,R,w)=K·A²·R³/w<br>
      G_warp = 1 + α·A·S
    </div>
    <div style="margin-top:8px;">
      Click <b>“2 — Engage Warp Drive”</b> to start the live budget:
      mass→energy → plasma → field power → bubble stability.
      If stability <b>S ≤ 0</b>, it auto-shuts down (containment collapse).
    </div>
  </div>

  <div class="label">Live Bubble / Ledger (updates every frame)</div>
  <div class="grid2">
    <div class="kv"><div class="k">γ (from v/c)</div><div class="v mono" id="u_gamma">--</div></div>
    <div class="kv"><div class="k">Δτ/Δt</div><div class="v mono" id="u_dtau">--</div></div>

    <div class="kv"><div class="k">A (amplitude)</div><div class="v mono" id="u_A">--</div></div>
    <div class="kv"><div class="k">S (stability)</div><div class="v mono" id="u_S">--</div></div>

    <div class="kv"><div class="k">E_req</div><div class="v mono" id="u_Ereq">--</div></div>
    <div class="kv"><div class="k">E_stored</div><div class="v mono" id="u_Est">--</div></div>

    <div class="kv"><div class="k">m_eq</div><div class="v mono" id="u_meq">--</div></div>
    <div class="kv"><div class="k">G_warp</div><div class="v mono" id="u_Gwarp">--</div></div>
  </div>
</div>

<!-- MAIN CONTROL PANEL -->
<div class="hudpanel" id="panelMain">
  <h2>Warp Navigation Panel</h2>

  <div class="label">Destination Planet</div>
  <select id="planetSelect">
    <option value="Mercury">Mercury</option>
    <option value="Venus">Venus</option>
    <option value="Mars">Mars</option>
    <option value="Jupiter">Jupiter</option>
    <option value="Saturn">Saturn</option>
    <option value="Uranus">Uranus</option>
    <option value="Neptune">Neptune</option>
    <option value="Pluto">Pluto</option>
  </select>

  <div class="label">Warp Factor (0 – 10)</div>
  <select id="warpSelect">
    <option value="0">0 — Idle</option>
    <option value="1">Warp 1</option>
    <option value="2">Warp 2</option>
    <option value="3">Warp 3</option>
    <option value="4">Warp 4</option>
    <option value="5">Warp 5</option>
    <option value="6">Warp 6</option>
    <option value="7">Warp 7</option>
    <option value="8">Warp 8</option>
    <option value="9">Warp 9</option>
    <option value="10">Warp 10</option>
  </select>

  <button id="calcBtn">1 — Calculate Trip</button>
  <button id="engageBtn">2 — Engage Warp Drive</button>
  <button id="stopBtn">STOP ENGINE</button>
  <button id="safetyBtn">5 — Recalculate Safety</button>
  <button id="resetBtn">Reset Simulation</button>

  <div id="msg"></div>
  <div id="safeMsg"></div>
</div>

<!-- CLOCKS PANEL -->
<div class="hudpanel" id="panelClocks">
  <h2>Time Synchronization</h2>
  <div class="label">CST Synchronized Time</div>
  <div class="value mono" id="cstClock">--:--:--</div>

  <div class="label">Ship Proper Time (τ)</div>
  <div class="value mono" id="shipClock">--:--:--</div>

  <div class="label">Estimated Arrival (CST)</div>
  <div class="value mono" id="arrivalClock">--:--:--</div>

  <div class="label">Effective Traversal (toy warp)</div>
  <div class="value mono" id="effClock">--</div>
</div>

<!-- PHYSICS PANEL -->
<div class="hudpanel" id="panelPhysics">
  <h2>Warp Physics Readout</h2>

  <div class="label">Distance</div>
  <div class="value mono" id="distVal">--</div>

  <div class="label">Coordinate Travel Time (CST frame)</div>
  <div class="value mono" id="timeVal">--</div>

  <div class="label">Ship Proper Time (SR/GR)</div>
  <div class="value mono" id="shipTimeVal">--</div>

  <div class="label">Time Dilation (computed)</div>
  <div class="value mono" id="dilationVal">--</div>

  <div class="label">Gravity Potential Φ (weak-field)</div>
  <div class="value mono" id="phiVal">--</div>

  <div class="label">Mass–Energy Ledger (LIVE)</div>
  <div class="value mono" id="emcVal">--</div>

  <div class="label">Bubble Control (A, R, w, S)</div>
  <div class="value mono" id="bubbleVal">--</div>
</div>

<script>
/* ========== CANVAS SETUP ========== */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");
let W=0,H=0,cx=0,cy=0;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W/2;
  cy = H/2;
}
window.addEventListener("resize", resize);
resize();

/* ========== DOM HOOKS ========== */
const planetSelect = document.getElementById("planetSelect");
const warpSelect   = document.getElementById("warpSelect");
const msgEl        = document.getElementById("msg");
const safeMsgEl    = document.getElementById("safeMsg");

const cstClockEl   = document.getElementById("cstClock");
const shipClockEl  = document.getElementById("shipClock");
const arrClockEl   = document.getElementById("arrivalClock");
const effClockEl   = document.getElementById("effClock");

const distValEl    = document.getElementById("distVal");
const timeValEl    = document.getElementById("timeVal");
const shipTimeValEl= document.getElementById("shipTimeVal");
const dilationValEl= document.getElementById("dilationVal");
const phiValEl     = document.getElementById("phiVal");
const emcValEl     = document.getElementById("emcVal");
const bubbleValEl  = document.getElementById("bubbleVal");

/* Upgrades live panel */
const u_gamma = document.getElementById("u_gamma");
const u_dtau  = document.getElementById("u_dtau");
const u_A     = document.getElementById("u_A");
const u_S     = document.getElementById("u_S");
const u_Ereq  = document.getElementById("u_Ereq");
const u_Est   = document.getElementById("u_Est");
const u_meq   = document.getElementById("u_meq");
const u_Gwarp = document.getElementById("u_Gwarp");

/* ========== CONSTANTS ========== */
const AU = 149597870.7;           // km
const c_km = 299792.458;          // km/s
const c_m  = 299792458;           // m/s
const G = 6.67430e-11;            // SI
const M_earth = 5.97219e24;       // kg
const R_earth = 6371000;          // m

/* Simplified planet distances in AU (Sun-centered), Earth fixed at 1 AU */
const distAU = {
  Mercury:0.387, Venus:0.723, Mars:1.524, Jupiter:5.203,
  Saturn:9.539, Uranus:19.18, Neptune:30.06, Pluto:39.48
};

/* ========== SIM STATE ========== */
let warp = 0;          // 0..10
let running = false;
let trip = null;       // { planet, km, seconds, shipSeconds, gamma, beta, phi }

/* Live clocks (accumulating proper time) */
let shipTauSec = 0;    // accumulated ship proper seconds
let cstBaseMs = 0;     // CST time anchor in ms

/* Energy & bubble ledger */
const ledger = {
  // user-tuned-ish constants (kept internal for now)
  eta_mass_to_energy: 0.0005,     // η : mass conversion efficiency (toy)
  dm_rate: 0.020,                // kg/s converted when running (toy)
  eta_plasma: 0.55,              // ηp
  eta_field: 0.65,               // ηf
  plasma_loss_rate: 0.06,        // fraction per second
  field_loss_rate: 0.03,         // fraction per second (stored energy leakage)
  Tmaint: 6.0,                   // seconds time constant to maintain bubble
  K: 2.5e11,                      // “how impossible is this” knob (J / unit proxy)
  alpha: 0.80,                    // warp gain sensitivity
  // stability decay coefficients
  b1: 0.10,
  b2: 0.02,
  b3: 0.20,
  b4: 0.06,
  // dynamic vars
  E_avail_rate: 0,
  E_plasma: 0,
  E_stored: 0,
  E_req: 0,
  sigmaP: 0,
  meq: 0,
  // bubble
  A: 0,
  R: 60,     // meters (toy)
  w: 6,      // meters (toy)
  S: 1.0,
  Gwarp: 1.0,
  lastA: 0
};

/* ========== CST TIME (UTC - 6) ========== */
function getCSTDate(){
  const now = new Date();
  const utcMs = now.getTime() + now.getTimezoneOffset()*60000;
  return new Date(utcMs - 6*3600000);
}
function pad2(n){ return String(n).padStart(2,"0"); }
function fmtHMS_fromSeconds(sec){
  sec = Math.max(0, sec);
  const h = Math.floor(sec/3600);
  const m = Math.floor((sec%3600)/60);
  const s = Math.floor(sec%60);
  return `${pad2(h%24)}:${pad2(m)}:${pad2(s)}`;
}
</script>
<!-- ======================= PART 2 / 4 =======================
Trip model changes:
- Uses a sub-light ship velocity v based on warp setting (to compute γ honestly)
- Bubble provides a separate toy “metric gain” G_warp = 1 + α·A·S
- Coordinate traversal time is reduced by G_warp (effective speed boost),
  but only if the bubble is stable (S high) and funded by the energy ledger.
============================================================== -->
<script>
/* ========== BUTTON WIRES ========== */
document.getElementById("calcBtn").onclick = () => calculateTrip(true);

document.getElementById("engageBtn").onclick = () => {
  running = true;
  // engage bumps warp by 1 until 10 (or uses manual setting)
  if(warp < 10) warp++;
  warpSelect.value = String(warp);
  // anchor CST + reset ship proper time at engage if first run
  if(!cstBaseMs) cstBaseMs = getCSTDate().getTime();
  calculateTrip(true);
  msgEl.textContent = "ENGAGED: Running SR/GR clocks + E↔m ledger + bubble control.";
};

document.getElementById("stopBtn").onclick = () => {
  running = false;
  warp = 0;
  warpSelect.value = "0";
  ledger.E_avail_rate = 0;
  ledger.Gwarp = 1.0;
  msgEl.textContent = "ENGINE STOPPED: bubble power cut, drift to idle.";
  updatePhysicsPanel();
};

document.getElementById("safetyBtn").onclick = () => recalcSafety();

document.getElementById("resetBtn").onclick = () => {
  warp = 0;
  running = false;
  warpSelect.value = "0";
  trip = null;
  msgEl.textContent = "";
  safeMsgEl.textContent = "";
  clearPhysicsPanel();

  shipTauSec = 0;
  cstBaseMs = 0;

  ledger.E_avail_rate = 0;
  ledger.E_plasma = 0;
  ledger.E_stored = 0;
  ledger.E_req = 0;
  ledger.meq = 0;
  ledger.A = 0;
  ledger.lastA = 0;
  ledger.R = 60;
  ledger.w = 6;
  ledger.S = 1.0;
  ledger.Gwarp = 1.0;
};

warpSelect.onchange = () => {
  warp = Number(warpSelect.value);
  calculateTrip(true);
};

/* ========== SAFETY CHECK ========== */
function recalcSafety(){
  // now depends on stability + warp threshold
  if(warp >= 4 && ledger.S > 0.35){
    safeMsgEl.style.color = "#7bff9f";
    safeMsgEl.textContent = "✔ Safety OK: bubble stability + corridor margin acceptable.";
    return true;
  } else {
    safeMsgEl.style.color = "#ff7272";
    safeMsgEl.textContent = "⚠ Safety LOW: need warp ≥ 4 and stability S > 0.35.";
    return false;
  }
}

/* ========== TRIP CALCULATIONS (SR/GR + bubble gain) ========== */
function calculateTrip(updateUIOnly=false){
  const planet = planetSelect.value;
  const dAU = distAU[planet] - 1;      // Earth at 1 AU (toy)
  const km = Math.abs(dAU)*AU;

  // Ship velocity (sub-light) for honest γ:
  // Warp sets a target β (v/c) up to 0.85 max.
  const beta_target = Math.min(0.85, Math.max(0, warp) * 0.085); // warp10 => 0.85
  const v_km = c_km * beta_target;

  // Weak-field gravitational potential near Earth surface (toy):
  // Φ ≈ -GM/r  (r ~ Earth radius)
  const phi = -(G*M_earth)/R_earth; // J/kg = m²/s² (negative)
  const phiOverC2 = phi/(c_m*c_m);  // dimensionless (negative)

  // γ from SR
  const beta = Math.min(beta_target, 0.999999);
  const gamma = (beta<=0) ? 1 : 1/Math.sqrt(1 - beta*beta);

  // Bubble gain (depends on A and S, computed in ledger update)
  const Gwarp = ledger.Gwarp || 1.0;
  const effectiveSpeed = Math.max(1e-6, v_km * Gwarp); // km/s
  const seconds = (warp<=0) ? Infinity : (km / effectiveSpeed);

  // Proper time scaling factor per coordinate second:
  // dτ/dt ≈ (1 + Φ/c²)/γ   (weak-field)
  const dtau_over_dt = (1 + phiOverC2) / gamma;

  // Travel proper time estimate:
  const shipSeconds = (seconds===Infinity) ? Infinity : seconds * dtau_over_dt;

  trip = { planet, km, seconds, shipSeconds, gamma, beta, phi, dtau_over_dt, Gwarp };
  if(updateUIOnly) updatePhysicsPanel();
}

/* ========== PHYSICS PANEL UPDATE ========== */
function clearPhysicsPanel(){
  distValEl.textContent    = "--";
  timeValEl.textContent    = "--";
  shipTimeValEl.textContent= "--";
  dilationValEl.textContent= "--";
  phiValEl.textContent     = "--";
  emcValEl.textContent     = "--";
  bubbleValEl.textContent  = "--";

  u_gamma.textContent="--";
  u_dtau.textContent="--";
  u_A.textContent="--";
  u_S.textContent="--";
  u_Ereq.textContent="--";
  u_Est.textContent="--";
  u_meq.textContent="--";
  u_Gwarp.textContent="--";
}

function fmtSI_J(x){
  if(!isFinite(x)) return "--";
  const ax=Math.abs(x);
  if(ax>=1e18) return (x/1e18).toFixed(3)+" EJ";
  if(ax>=1e15) return (x/1e15).toFixed(3)+" PJ";
  if(ax>=1e12) return (x/1e12).toFixed(3)+" TJ";
  if(ax>=1e9)  return (x/1e9).toFixed(3)+" GJ";
  if(ax>=1e6)  return (x/1e6).toFixed(3)+" MJ";
  if(ax>=1e3)  return (x/1e3).toFixed(3)+" kJ";
  return x.toFixed(2)+" J";
}
function fmtKg(x){
  if(!isFinite(x)) return "--";
  if(Math.abs(x)>=1e6) return (x/1e6).toFixed(3)+" Mkg";
  if(Math.abs(x)>=1e3) return (x/1e3).toFixed(3)+" t";
  return x.toFixed(6)+" kg";
}

function updatePhysicsPanel(){
  if(!trip || warp<=0){
    msgEl.textContent = "Select planet and click Calculate Trip (set warp > 0).";
    clearPhysicsPanel();
    return;
  }

  msgEl.textContent = `Planet: ${trip.planet} | Warp: ${warp} | Running: ${running ? "YES":"NO"}`;

  // Distance
  distValEl.textContent = `${(trip.km/1e6).toFixed(2)} million km`;

  // Travel time (CST frame)
  const hrs = trip.seconds/3600;
  const days = hrs/24;
  timeValEl.textContent = `${hrs.toFixed(2)} h (~${days.toFixed(2)} d)  [G_warp=${trip.Gwarp.toFixed(3)}]`;

  // Ship proper time
  const shipHrs = trip.shipSeconds/3600;
  const dilationFrac = 1 - (trip.dtau_over_dt); // per-second difference
  shipTimeValEl.textContent =
    `Est: ${shipHrs.toFixed(2)} h | dτ/dt=${trip.dtau_over_dt.toFixed(6)}`;

  // Time dilation output
  dilationValEl.textContent =
    `γ=${trip.gamma.toFixed(6)}  β=${trip.beta.toFixed(4)}  (SR) | Δ per sec=${(dilationFrac*100).toFixed(4)}%`;

  // Gravity potential Φ
  phiValEl.textContent =
    `Φ≈${trip.phi.toExponential(4)} m²/s²  | (1+Φ/c²)≈${(1 + trip.phi/(c_m*c_m)).toFixed(12)}`;

  // Energy ledger
  emcValEl.textContent =
    `Ė_avail=${fmtSI_J(ledger.E_avail_rate)} /s  | E_plasma=${fmtSI_J(ledger.E_plasma)}  | m_eq=${fmtKg(ledger.meq)}`;

  // Bubble status
  bubbleValEl.textContent =
    `A=${ledger.A.toFixed(4)}  R=${ledger.R.toFixed(2)}m  w=${ledger.w.toFixed(2)}m  S=${ledger.S.toFixed(4)}  E_req=${fmtSI_J(ledger.E_req)}`;

  // Upgrades live panel
  u_gamma.textContent = trip.gamma.toFixed(8);
  u_dtau.textContent  = trip.dtau_over_dt.toFixed(10);
  u_A.textContent     = ledger.A.toFixed(6);
  u_S.textContent     = ledger.S.toFixed(6);
  u_Ereq.textContent  = fmtSI_J(ledger.E_req);
  u_Est.textContent   = fmtSI_J(ledger.E_stored);
  u_meq.textContent   = fmtKg(ledger.meq);
  u_Gwarp.textContent = ledger.Gwarp.toFixed(6);
}
</script>
<!-- ======================= PART 3 / 4 =======================
Adds the live “mass→energy→plasma→field→bubble” loop + stability collapse.
Also fixes the ship proper time clock to accumulate realistically:
- CST time: real time in UTC-6
- Ship time τ: integrates dτ = dt * (1+Φ/c²)/γ
- Effective traversal: uses remaining trip time / G_warp (toy)
============================================================== -->
<script>
/* ========== PARTICLES (UNCHANGED FROM YOUR ORIGINAL) ========== */
const coreParticles = [];
const engineLeft = [];
const engineRight = [];
for(let i=0;i<220;i++) coreParticles.push(newCoreParticle());
for(let i=0;i<180;i++) engineLeft.push(newEngineParticle());
for(let i=0;i<180;i++) engineRight.push(newEngineParticle());

function newCoreParticle(){
  return {
    a:Math.random()*Math.PI*2,
    r:Math.random()*10,
    max:70+Math.random()*50,
    sp:0.06+Math.random()*0.14,
    size:1+Math.random()*2,
    life:Math.random()
  };
}
function newEngineParticle(){
  return {
    x:0,y:0,
    vx:(Math.random()-0.5)*0.6,
    vy:2+Math.random()*2.5,
    life:0.7+Math.random()*1.1
  };
}

/* ========== STARFIELD ========== */
const stars = [];
function initStars(count){
  stars.length = 0;
  for(let i=0;i<count;i++){
    stars.push({
      x:Math.random()*W,
      y:Math.random()*H,
      speed:0.5+Math.random()*1.5,
      size:Math.random()*1.8+0.4
    });
  }
}
initStars(220);

function updateStars(dt){
  const speedBoost = 1 + warp*0.4;
  for(let s of stars){
    s.y += s.speed*speedBoost;
    if(s.y > H+10){
      s.y = -10;
      s.x = Math.random()*W;
      s.speed = 0.5+Math.random()*1.5;
    }
  }
}
function drawStars(){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  for(let s of stars){
    ctx.globalAlpha = 0.35 + s.speed*0.1;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.restore();
}

/* ========== FIELD IMPACT PARTICLES ========== */
const fieldParticles = [];
function initFieldParticles(count){
  fieldParticles.length = 0;
  for(let i=0;i<count;i++) fieldParticles.push(newFieldParticle());
}
function newFieldParticle(){
  const angle = Math.random()*Math.PI*2;
  const r = 260 + Math.random()*80;
  const sp = - (20 + Math.random()*40);
  return { a:angle, r:r, sp:sp, hit:false, flash:0 };
}
initFieldParticles(140);

function updateFieldParticles(dt, shieldR){
  for(let p of fieldParticles){
    p.r += p.sp*dt;
    if(!p.hit && p.r <= shieldR){
      p.hit = true;
      p.flash = 0.25;
      p.sp = Math.abs(p.sp);
      p.r = shieldR;
    }
    if(p.hit){
      p.flash -= dt;
      if(p.flash <= 0) p.flash = 0;
    }
    if(p.r > shieldR+140 || p.r < shieldR*0.4){
      Object.assign(p, newFieldParticle());
    }
  }
}
function drawFieldParticles(shieldR, t){
  ctx.save();
  ctx.translate(cx,cy);
  for(let p of fieldParticles){
    const x = Math.cos(p.a)*p.r;
    const y = Math.sin(p.a)*p.r;
    let alpha = 0.4;
    let radius = 2;
    if(p.hit && p.flash>0){
      const blink = 0.5+0.5*Math.sin(t*40);
      alpha = 0.8*blink;
      radius = 3.5;
    }
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.fillStyle = p.hit ? "rgba(255,255,220,1)" : "rgba(150,210,255,1)";
    ctx.fill();
  }
  ctx.restore();
}

/* ========== NEW: LEDGER + BUBBLE UPDATE (LIVE) ========== */
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function updateLedgerAndBubble(dt){
  // Idle behavior
  if(!running || warp<=0){
    // leak stored energy slowly + relax amplitude
    ledger.E_plasma = Math.max(0, ledger.E_plasma * Math.exp(-ledger.plasma_loss_rate*dt));
    ledger.E_stored = Math.max(0, ledger.E_stored * Math.exp(-ledger.field_loss_rate*dt));
    ledger.A = Math.max(0, ledger.A - dt*0.08);
    ledger.Gwarp = 1 + ledger.alpha*ledger.A*ledger.S;
    ledger.meq = ledger.E_stored/(c_m*c_m);
    return;
  }

  // === Bubble geometry from warp (toy but consistent) ===
  // Bigger warp → larger R, thinner w.
  ledger.R = 45 + warp*11;                 // meters
  ledger.w = clamp(9 - warp*0.55, 2.2, 9); // meters (thin at high warp)

  // Target amplitude demand (driver wants this, stability may prevent)
  const A_target = clamp(warp/10, 0, 1);

  // === Mass -> Energy rate ===
  // Ė_avail = η * (dm/dt) * c²
  ledger.E_avail_rate = ledger.eta_mass_to_energy * ledger.dm_rate * (c_m*c_m);

  // Power noise (pulsed nature): σP ∈ [0..~1] grows with warp
  ledger.sigmaP = (0.15 + 0.75*Math.random()) * (warp/10);

  // === Plasma reservoir ===
  // Add energy into plasma, subtract losses
  const Ein = ledger.E_avail_rate * dt;
  ledger.E_plasma += ledger.eta_plasma * Ein;
  ledger.E_plasma -= ledger.E_plasma * ledger.plasma_loss_rate * dt;
  ledger.E_plasma = Math.max(0, ledger.E_plasma);

  // === Bubble requirement proxy ===
  // E_req = K * A^2 * R^3 / w
  // Use the target amplitude for "required" (demand) energy
  ledger.E_req = ledger.K * (A_target*A_target) * Math.pow(ledger.R,3) / ledger.w;

  // Field power available from plasma this frame
  const P_field = ledger.eta_field * (ledger.E_plasma / Math.max(1e-6, dt));
  // maintenance loss proportional to stored energy
  const P_leak = ledger.E_stored / ledger.Tmaint;

  // Update stored field energy (can rise if power exceeds leak)
  ledger.E_stored += (P_field - P_leak) * dt;
  ledger.E_stored = Math.max(0, ledger.E_stored);

  // === Amplitude realized A depends on how funded we are and on stability ===
  // funding ratio: if stored energy < required, amplitude can’t hold
  const fund = clamp(ledger.E_stored / Math.max(1e-9, ledger.E_req), 0, 1);
  // Move A toward target * funding * stability
  const A_real_target = A_target * fund * ledger.S;
  ledger.A += (A_real_target - ledger.A) * clamp(dt*1.2, 0, 1);

  // === Stability update ===
  const dA = (ledger.A - ledger.lastA)/Math.max(1e-6, dt);
  ledger.lastA = ledger.A;

  const term1 = ledger.b1 * (ledger.A*ledger.A);
  const term2 = ledger.b2 * (ledger.R/ledger.w);
  const term3 = ledger.b3 * ledger.sigmaP;
  const term4 = ledger.b4 * Math.abs(dA);

  ledger.S += -(term1 + term2 + term3 + term4) * dt;
  ledger.S = clamp(ledger.S, 0, 1);

  // === Warp gain ===
  ledger.Gwarp = 1 + ledger.alpha * ledger.A * ledger.S;
  ledger.Gwarp = clamp(ledger.Gwarp, 1.0, 8.0);

  // equivalent mass of stored energy
  ledger.meq = ledger.E_stored/(c_m*c_m);

  // Auto-shutdown on collapse
  if(ledger.S <= 0){
    running = false;
    msgEl.textContent = "⚠ CONTAINMENT COLLAPSE: stability S reached 0 → auto shutdown. Stored energy dumped (toy).";
    // dump energy quickly (toy spike)
    ledger.E_plasma *= 0.15;
    ledger.E_stored *= 0.05;
    ledger.A = 0;
    ledger.Gwarp = 1.0;
    safeMsgEl.style.color = "#ff7272";
    safeMsgEl.textContent = "⚠ Bubble collapsed: reset or reduce warp.";
  }

  // Recompute trip with new G_warp influence
  calculateTrip(true);
}

/* ========== CLOCKS (ACCUMULATING PROPER TIME) ========== */
function updateClocks(dt){
  const cstNow = getCSTDate();
  cstClockEl.textContent = cstNow.toTimeString().split(" ")[0];

  if(trip && isFinite(trip.seconds)){
    // Arrival CST from "now + coordinate travel time"
    const arrivalCST = new Date(cstNow.getTime() + trip.seconds*1000);
    arrClockEl.textContent = arrivalCST.toTimeString().split(" ")[0];

    // Accumulate proper time only when running (so “start” shows live change)
    if(running){
      shipTauSec += dt * trip.dtau_over_dt;
    }

    shipClockEl.textContent = fmtHMS_fromSeconds(shipTauSec);

    // Effective traversal display: coordinate time divided by Gwarp (toy)
    const eff = trip.seconds / Math.max(1e-9, ledger.Gwarp);
    effClockEl.textContent = `${(eff/3600).toFixed(2)} h (t/G_warp)`;

  } else {
    shipClockEl.textContent = "--:--:--";
    arrClockEl.textContent  = "--:--:--";
    effClockEl.textContent  = "--";
  }
}

/* ========== WARP VISUAL HELPERS ========== */
function warpEnergy(){
  // make visuals respond to actual bubble amplitude + warp
  const base = 0.25 + (warp/10)*0.55;
  const bubble = 0.20*ledger.A + 0.10*ledger.S;
  return clamp(base + bubble, 0.15, 1.0);
}
</script>
<!-- ======================= PART 4 / 4 =======================
Keeps your visuals, but ties shield radius and glow to the new bubble A/S.
Also runs the new ledger update each frame, and updates physics panel LIVE.
============================================================== -->
<script>
/* ========== MAIN ANIMATION LOOP ========== */
let lastTs = 0;
function loop(ts){
  const dt = (ts-lastTs)/1000 || 0;
  lastTs = ts;

  ctx.clearRect(0,0,W,H);

  // Stars
  updateStars(dt);
  drawStars();

  // Draw ship
  drawShipOutline();

  // Shield radius now responds to bubble amplitude A and stability S
  const baseR = 210;
  const pulse = 0.12*Math.sin(ts*0.004) + 0.88;
  const warpBoost = 1 + warp*0.10;
  const bubbleBoost = 1 + (ledger.A*0.55 + ledger.S*0.20); // NEW
  const shieldR = baseR*pulse*warpBoost*bubbleBoost;

  // Update ledger + bubble
  updateLedgerAndBubble(dt);

  // Protection field
  drawProtectionField(shieldR);

  // Core + rings
  drawCore(ts);

  // Particles
  updateCoreParticles(dt);
  drawCoreParticles();
  updateEngineParticles(dt);
  drawEngineParticles();

  // Impacts
  updateFieldParticles(dt, shieldR);
  drawFieldParticles(shieldR, ts/1000);

  // Clocks + panels
  updateClocks(dt);
  updatePhysicsPanel();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ========== DRAW FUNCTIONS (YOUR ORIGINAL, MINIMAL CHANGES) ========== */
function drawShipOutline(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.strokeStyle = "rgba(120,180,255,0.7)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(0,-200);
  ctx.quadraticCurveTo(60,-80,60,60);
  ctx.quadraticCurveTo(60,150,0,190);
  ctx.quadraticCurveTo(-60,150,-60,60);
  ctx.quadraticCurveTo(-60,-80,0,-200);

  ctx.moveTo(-110,-40);
  ctx.quadraticCurveTo(-160,50,-110,160);
  ctx.quadraticCurveTo(-60,80,-110,-40);

  ctx.moveTo(110,-40);
  ctx.quadraticCurveTo(160,50,110,160);
  ctx.quadraticCurveTo(60,80,110,-40);

  ctx.stroke();
  ctx.restore();
}

function drawProtectionField(R){
  // tie glow to bubble stability + amplitude
  const innerAlpha = 0.14 + 0.10*(warp/10) + 0.10*ledger.A + 0.06*ledger.S;
  const midAlpha   = 0.08 + 0.08*(warp/10) + 0.06*ledger.A;

  ctx.save();
  ctx.translate(cx,cy);
  const g = ctx.createRadialGradient(0,0,R*0.15, 0,0,R);
  g.addColorStop(0, `rgba(200,250,255,${innerAlpha})`);
  g.addColorStop(0.4,`rgba(130,210,255,${midAlpha})`);
  g.addColorStop(1, "rgba(20,40,90,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 0.35 + 0.18*(warp/10) + 0.18*ledger.S;
  ctx.strokeStyle = "rgba(165,225,255,0.95)";
  ctx.lineWidth = 1.5 + warp*0.16 + 1.1*ledger.A;
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.stroke();
  ctx.restore();
}

function drawCore(ts){
  const energy = warpEnergy();
  const t = ts*0.008;

  ctx.save();
  ctx.translate(cx,cy);

  const coreR = 14 + 10*energy*Math.sin(t*4);
  ctx.beginPath();
  ctx.arc(0,0,coreR,0,Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.fill();

  const cor = coreR*1.9;
  const cg = ctx.createRadialGradient(0,0,coreR*0.2, 0,0,cor);
  cg.addColorStop(0,"rgba(255,255,255,0.9)");
  cg.addColorStop(0.4,"rgba(255,210,160,0.65)");
  cg.addColorStop(1,"rgba(255,120,80,0)");
  ctx.fillStyle = cg;
  ctx.beginPath();
  ctx.arc(0,0,cor,0,Math.PI*2);
  ctx.fill();

  // rings
  const reactorR = 55;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(0,255,180,0.9)";
  ctx.lineWidth = 1.3;
  ctx.setLineDash([7,4]);
  ctx.arc(0,0,reactorR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  const fissionR = 95;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(255,190,80,0.9)";
  ctx.lineWidth = 1.3;
  ctx.setLineDash([9,5]);
  ctx.arc(0,0,fissionR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  // labels + NEW live A/S hint
  ctx.fillStyle = "rgba(190,235,255,0.9)";
  ctx.font = "12px Segoe UI";
  ctx.fillText("Nuclear Reactor", -60, reactorR+14);
  ctx.fillText("Fission Converter", -68, fissionR+16);
  ctx.fillText("E = γmc²", -30, -reactorR-10);
  ctx.fillText("m = E / c²", -32, -fissionR-10);
  ctx.fillText(`A=${ledger.A.toFixed(3)}  S=${ledger.S.toFixed(3)}`, -58, 140);

  ctx.restore();
}

/* ========== PARTICLE ANIMATION (YOUR ORIGINAL) ========== */
function updateCoreParticles(dt){
  const speedBoost = 1 + warp*0.7;
  for(let p of coreParticles){
    p.r += p.sp*110*dt*speedBoost;
    p.life += dt*0.5;
    if(p.r > p.max || p.life > 1){
      Object.assign(p, newCoreParticle());
    }
  }
}
function drawCoreParticles(){
  ctx.save();
  ctx.translate(cx,cy);
  for(let p of coreParticles){
    const x = Math.cos(p.a)*p.r;
    const y = Math.sin(p.a)*p.r*0.8;
    const alpha = (1 - p.life) * (0.7 + warp*0.03);
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(x,y,p.size,0,Math.PI*2);
    ctx.fillStyle = "rgba(190,245,255,1)";
    ctx.fill();
  }
  ctx.restore();
}
function updateEngineParticles(dt){
  const boost = 1 + warp*2.3;
  for(let e of engineLeft){
    e.x += e.vx*boost;
    e.y += e.vy*boost;
    e.life -= dt*0.4;
    if(e.life <= 0) Object.assign(e, newEngineParticle());
  }
  for(let e of engineRight){
    e.x += e.vx*boost;
    e.y += e.vy*boost;
    e.life -= dt*0.4;
    if(e.life <= 0) Object.assign(e, newEngineParticle());
  }
}
function drawEngineParticles(){
  ctx.save();
  ctx.translate(cx-110, cy+60);
  for(let e of engineLeft){
    ctx.globalAlpha = e.life;
    ctx.beginPath();
    ctx.arc(e.x, e.y, 2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(120,220,255,1)";
    ctx.fill();
  }
  ctx.restore();

  ctx.save();
  ctx.translate(cx+110, cy+60);
  for(let e of engineRight){
    ctx.globalAlpha = e.life;
    ctx.beginPath();
    ctx.arc(e.x, e.y, 2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(120,220,255,1)";
    ctx.fill();
  }
  ctx.restore();
}
</script>
</body>
</html>
