<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lotto Simulator & Generator ‚Äî Excluding Non-Possibility Numbers & Sums (1‚Äì54, 6 picks)</title>
<style>
  :root{
    --bg:#0b1222;--panel:#121a33;--ink:#edf2ff;--muted:#a9b7e3;--accent:#8fb4ff;
    --ok:#3de6a0;--warn:#ffd37a;--bad:#ff7992;--grid:#1b2550;--chip:#1e2a59;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  a{color:var(--accent)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  h1{margin:4px 0 10px;font-size:1.6rem}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;padding:14px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  textarea{width:100%;min-height:160px;background:#0e1530;color:var(--ink);border:1px solid var(--grid);border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Consolas}
  .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
  label{font-size:0.9rem;color:var(--muted)}
  input[type="number"],input[type="file"],select{
    width:100%;background:#0e1530;color:var(--ink);border:1px solid var(--grid);border-radius:10px;padding:8px
  }
  button{
    background:linear-gradient(180deg,#96b8ff,#6c96ff);
    color:#06102e;border:0;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer
  }
  button.secondary{background:#1f2a57;color:var(--ink);border:1px solid var(--grid)}
  .pill{display:inline-block;background:var(--chip);border:1px solid var(--grid);padding:4px 8px;border-radius:999px;color:var(--muted);font-size:0.8rem}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border-bottom:1px solid var(--grid);padding:6px 8px;font-variant-numeric:tabular-nums}
  th{text-align:left;color:var(--muted);font-weight:600}
  .numchip{display:inline-block;background:#0e1737;border:1px solid var(--grid);padding:3px 7px;border-radius:8px;margin:2px;font-variant-numeric:tabular-nums}
  .ticket{display:flex;gap:6px;flex-wrap:wrap}
  .note{color:var(--muted);font-size:0.9rem}
  .small{font-size:0.85rem}
  .warning{color:var(--warn)}
  .ok{color:var(--ok)}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>üéØ Lotto Simulator ‚Äî Exclude Non-Possibility Numbers & Sums (10 tickets ‚Ä¢ 6 numbers ‚Ä¢ 1‚Äì54)</h1>
  <p class="note">Paste or upload your draws. One line per draw, six integers 1‚Äì54 separated by spaces/commas. Example: <code>3, 12, 18, 27, 41, 52</code></p>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <h3>Winning Draws (won any prize)</h3>
        <span class="pill">used to <b>favor</b> patterns</span>
      </div>
      <textarea id="winTxt" placeholder="Paste winners here..."></textarea>
      <div class="controls">
        <div>
          <label>or Upload CSV</label>
          <input type="file" id="winFile" accept=".csv,text/csv,text/plain"/>
        </div>
        <div>
          <label>Total parsed</label>
          <input id="winCount" type="number" readonly value="0"/>
        </div>
        <div>
          <label>Sum range (auto)</label>
          <input id="winSumRange" type="text" readonly value="-"/>
        </div>
        <div>
          <label>Distinct pairs</label>
          <input id="winPairs" type="number" readonly value="0"/>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <h3>Non-Winning (rollover) Draws</h3>
        <span class="pill">used to <b>penalize</b> patterns</span>
      </div>
      <textarea id="nonTxt" placeholder="Paste non-winners (rollovers) here..."></textarea>
      <div class="controls">
        <div>
          <label>or Upload CSV</label>
          <input type="file" id="nonFile" accept=".csv,text/csv,text/plain"/>
        </div>
        <div>
          <label>Total parsed</label>
          <input id="nonCount" type="number" readonly value="0"/>
        </div>
        <div>
          <label>Sum range (auto)</label>
          <input id="nonSumRange" type="text" readonly value="-"/>
        </div>
        <div>
          <label>Distinct pairs</label>
          <input id="nonPairs" type="number" readonly value="0"/>
        </div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Exclusion Controls (Non-Possibility pruning)</h3>
    <div class="grid" style="grid-template-columns:repeat(6,1fr);gap:8px">
      <div><label>Œª (non-winner penalty)</label><input id="lambda" type="number" step="0.05" value="0.7"/></div>
      <div><label>Œ∫ (sum penalty)</label><input id="kappa" type="number" step="0.05" value="0.7"/></div>
      <div>
        <label>Exclusion mode</label>
        <select id="excludeMode">
          <option value="hard">Hard: drop ‚â§0</option>
          <option value="soft">Soft: drop bottom %</option>
        </select>
      </div>
      <div><label>Soft % (numbers)</label><input id="softPctNum" type="number" step="1" value="15"/></div>
      <div><label>Soft % (sums)</label><input id="softPctSum" type="number" step="1" value="25"/></div>
      <div><label>Samples / ticket</label><input id="attempts" type="number" value="450"/></div>
    </div>

    <h3 style="margin-top:14px">Scoring Weights</h3>
    <div class="grid" style="grid-template-columns:repeat(4,1fr);gap:8px">
      <div><label>Œ≤ pair weight</label><input id="beta" type="number" step="0.05" value="0.15"/></div>
      <div><label>Œ≥ balance weight</label><input id="gamma" type="number" step="0.05" value="0.10"/></div>
      <div><label>Œ¥ sum-band weight</label><input id="delta" type="number" step="0.05" value="0.25"/></div>
      <div><label>Tickets</label><input id="kTickets" type="number" value="10"/></div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="analyzeBtn">Analyze</button>
      <button id="genBtn" class="secondary">Generate Tickets</button>
      <span class="note">Analyze shows hot/cold, excluded numbers & sums, top pairs, balance.</span>
    </div>
  </div>

  <div class="grid" style="margin-top:16px">
    <div class="card">
      <h3>Winners ‚Äî Hot & Cold</h3>
      <div id="wHot" class="small"></div>
      <div id="wCold" class="small" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Winners ‚Äî Top Pairs</h3>
      <div id="wPairsTop" class="small"></div>
      <h3 style="margin-top:14px">Winners ‚Äî Balance Summary</h3>
      <div id="wBal" class="small"></div>
    </div>
    <div class="card">
      <h3>Non-Winners ‚Äî Hot & Cold</h3>
      <div id="nHot" class="small"></div>
      <div id="nCold" class="small" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Non-Winners ‚Äî Top Pairs</h3>
      <div id="nPairsTop" class="small"></div>
      <h3 style="margin-top:14px">Non-Winners ‚Äî Balance Summary</h3>
      <div id="nBal" class="small"></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Excluded (Non-Possibility) ‚Äî Numbers & Sums</h3>
    <div class="row">
      <div id="excludedNums" class="small" style="flex:1"></div>
      <div id="excludedSums" class="small" style="flex:1"></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Suggested Tickets</h3>
    <div id="tickets"></div>
    <p class="note" style="margin-top:8px">
      <span class="warning">Reminder:</span> Lotteries are random by design. This tool prunes patterns typical of rollovers and favors winner-like traits, but can‚Äôt guarantee increased expected value.
    </p>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Method (Equations)</h3>
    <p class="small">
      <b>Per-number weight:</b>
      <code>w(n) ‚àù (c_win(n)+Œ±)/(C_win+Œ±N) ‚àí Œª¬∑(c_non(n)+Œ±)/(C_non+Œ±N)</code>,
      with <code>Œ±=1</code>, <code>N=54</code>.
      <br/>Numbers with <code>w(n) ‚â§ 0</code> (hard mode) or in the bottom <code>p%</code> (soft mode) are <b>excluded</b>.
      <br/><b>Sum band score:</b> <code>W_sum(S) ‚àù H_win(S) ‚àí Œ∫¬∑H_non(S)</code>. Sums with <code>W_sum(S) ‚â§ 0</code> (hard) or in bottom <code>p%</code> (soft) are <b>excluded</b>.
      <br/><b>Ticket scoring:</b>
      <code>Score(T) = (1‚àíŒ≤‚àíŒ≥‚àíŒ¥)¬∑Œ£ w(n) + Œ≤¬∑PairScore + Œ≥¬∑BalanceScore + Œ¥¬∑SumScore</code>.
    </p>
  </div>
</div>

<script>
(function(){
  const NMIN=1, NMAX=54, PICK=6;

  // ---------- Basic utils ----------
  function parseText(txt){
    const lines = (txt||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const draws=[];
    for(const ln of lines){
      let parts = ln.replace(/;/g,',').replace(/-/g,',').split(/[,\s]+/).filter(Boolean);
      let nums = [...new Set(parts.map(p=>parseInt(p,10)).filter(x=>Number.isInteger(x) && x>=NMIN && x<=NMAX))].sort((a,b)=>a-b);
      if(nums.length>=PICK) draws.push(nums.slice(0,PICK));
    }
    return draws;
  }
  function fromFile(input, targetTextarea){
    const f = input.files && input.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = e => { targetTextarea.value = e.target.result; refreshCounts(); };
    reader.readAsText(f);
  }
  function counter(arr){
    const m=new Map();
    for(const x of arr){ m.set(x,(m.get(x)||0)+1); }
    return m;
  }
  function pairsOf(d){
    const ps=[]; for(let i=0;i<d.length;i++){ for(let j=i+1;j<d.length;j++){ ps.push([d[i],d[j]].sort((a,b)=>a-b).join("-")); } }
    return ps;
  }
  function histogram(arr){
    const m=new Map();
    for(const x of arr){ m.set(x,(m.get(x)||0)+1); }
    return m;
  }
  function normalizeMap(mapObj){
    let s=0; for(const v of mapObj.values()) s += Math.max(0,v);
    if(s<=0) return new Map(mapObj); // leave as-is; caller handles zero case
    const m=new Map();
    for(const [k,v] of mapObj.entries()) m.set(k, Math.max(0,v)/s);
    return m;
  }
  function topEntries(mapObj, k, desc=true){
    const arr=[...mapObj.entries()];
    arr.sort((a,b)=> desc ? (b[1]-a[1] || a[0]-b[0]) : (a[1]-b[1] || a[0]-b[0]) );
    return arr.slice(0,k);
  }
  function bottomPercentKeys(mapObj, pct){
    const arr=[...mapObj.entries()];
    arr.sort((a,b)=> a[1]-b[1] || a[0]-b[0]);
    const cut = Math.floor(arr.length * Math.max(0,Math.min(100,pct))/100);
    return new Set(arr.slice(0,cut).map(([k])=>k));
  }
  function describeBalance(draws){
    const rows = draws.map(d=>{
      const sum = d.reduce((s,x)=>s+x,0);
      const odd = d.filter(x=>x%2===1).length;
      const low = d.filter(x=>x<=27).length;
      const spread = Math.max(...d)-Math.min(...d);
      return {sum, odd_count:odd, even_count:PICK-odd, low_count:low, high_count:PICK-low, spread};
    });
    const fields = ["sum","odd_count","even_count","low_count","high_count","spread"];
    const desc={};
    for(const f of fields){
      const vals = rows.map(r=>r[f]).sort((a,b)=>a-b);
      if(!vals.length){ desc[f]={mean:null,std:null,min:null,max:null}; continue; }
      const mean = vals.reduce((s,x)=>s+x,0)/vals.length;
      const variance = vals.reduce((s,x)=>s+(x-mean)*(x-mean),0)/Math.max(1,vals.length-1);
      desc[f]={mean, std:Math.sqrt(variance), min:vals[0], max:vals[vals.length-1]};
    }
    desc._count = rows.length;
    if(rows.length){
      const sums = rows.map(r=>r.sum);
      desc._sumRange = `${Math.min(...sums)}‚Äì${Math.max(...sums)}`;
    } else desc._sumRange="-";
    return desc;
  }
  function zScore(val, mu, sd){ if(!isFinite(sd)||sd<=0) return 0; return -Math.abs((val-mu)/sd); }

  // ---------- DOM ----------
  const winTxt = document.getElementById('winTxt');
  const nonTxt = document.getElementById('nonTxt');
  const winFile = document.getElementById('winFile');
  const nonFile = document.getElementById('nonFile');
  const winCount = document.getElementById('winCount');
  const nonCount = document.getElementById('nonCount');
  const winSumRange = document.getElementById('winSumRange');
  const nonSumRange = document.getElementById('nonSumRange');
  const winPairsBox = document.getElementById('winPairs');
  const nonPairsBox = document.getElementById('nonPairs');

  const wHotDiv = document.getElementById('wHot');
  const wColdDiv = document.getElementById('wCold');
  const wPairsTopDiv = document.getElementById('wPairsTop');
  const wBalDiv = document.getElementById('wBal');
  const nHotDiv = document.getElementById('nHot');
  const nColdDiv = document.getElementById('nCold');
  const nPairsTopDiv = document.getElementById('nPairsTop');
  const nBalDiv = document.getElementById('nBal');

  const excludedNumsDiv = document.getElementById('excludedNums');
  const excludedSumsDiv = document.getElementById('excludedSums');
  const ticketsDiv = document.getElementById('tickets');

  winFile.addEventListener('change', ()=>fromFile(winFile, winTxt));
  nonFile.addEventListener('change', ()=>fromFile(nonFile, nonTxt));
  winTxt.addEventListener('input', refreshCounts);
  nonTxt.addEventListener('input', refreshCounts);

  let W=[], N=[]; // parsed draws

  function refreshCounts(){
    W = parseText(winTxt.value);
    N = parseText(nonTxt.value);
    winCount.value = W.length;
    nonCount.value = N.length;

    function sumRange(draws){
      if(!draws.length) return "-";
      const sums = draws.map(d=>d.reduce((s,x)=>s+x,0));
      return `${Math.min(...sums)}‚Äì${Math.max(...sums)}`;
    }
    winSumRange.value = sumRange(W);
    nonSumRange.value = sumRange(N);

    function distinctPairs(draws){
      const s=new Set();
      for(const d of draws) for(const pk of pairsOf(d)) s.add(pk);
      return s.size;
    }
    winPairsBox.value = distinctPairs(W);
    nonPairsBox.value = distinctPairs(N);
  }

  // ---------- Core analysis ----------
  function analyze(lambda=0.7, kappa=0.7){
    // number frequencies
    const wf=new Map(), nf=new Map();
    for(let n=NMIN;n<=NMAX;n++){ wf.set(n,0); nf.set(n,0); }
    for(const d of W) for(const x of d) wf.set(x, wf.get(x)+1);
    for(const d of N) for(const x of d) nf.set(x, nf.get(x)+1);
    const Cw = [...wf.values()].reduce((s,x)=>s+x,0);
    const Cn = [...nf.values()].reduce((s,x)=>s+x,0);
    const alpha=1, M=(NMAX-NMIN+1);

    // per-number raw score (before normalization)
    const numScore=new Map();
    for(let n=NMIN;n<=NMAX;n++){
      const pW = ( (wf.get(n)||0)+alpha ) / ( (Cw||0) + alpha*M );
      const pN = ( (nf.get(n)||0)+alpha ) / ( (Cn||0) + alpha*M );
      const score = pW - lambda*pN;
      numScore.set(n, score);
    }

    // pairs (winners)
    const pairCounts = new Map();
    for(const d of W) for(const pk of pairsOf(d)) pairCounts.set(pk,(pairCounts.get(pk)||0)+1);
    const totalPairs = [...pairCounts.values()].reduce((s,x)=>s+x,0);

    // winners balance
    const wBal = describeBalance(W);

    // sum histograms
    const sumsW = W.map(d=>d.reduce((s,x)=>s+x,0));
    const sumsN = N.map(d=>d.reduce((s,x)=>s+x,0));
    const hW = histogram(sumsW), hN = histogram(sumsN);

    // sum score = H_win - kappa*H_non (note: raw counts; will normalize later if needed)
    const sumDomain = new Set([...hW.keys(), ...hN.keys()]);
    const sumScore = new Map();
    for(const S of sumDomain){
      sumScore.set(S, (hW.get(S)||0) - kappa*(hN.get(S)||0));
    }

    return {numScore, wf, nf, Cw, Cn, pairCounts, totalPairs, wBal, hW, hN, sumScore};
  }

  function excludeSets(analysis, mode="hard", softPctNum=15, softPctSum=25){
    const { numScore, sumScore } = analysis;

    // Numbers exclusion
    let excludedNums = new Set();
    if(mode==="hard"){
      for(const [n,sc] of numScore.entries()) if(sc<=0) excludedNums.add(n);
    } else {
      // soft: drop bottom % by score
      excludedNums = bottomPercentKeys(numScore, softPctNum);
    }

    // Sums exclusion
    let excludedSums = new Set();
    if(mode==="hard"){
      for(const [S,sc] of sumScore.entries()) if(sc<=0) excludedSums.add(S);
    } else {
      excludedSums = bottomPercentKeys(sumScore, softPctSum);
    }

    return {excludedNums, excludedSums};
  }

  function renderList(div, items, label){
    if(!items || !items.length){ div.innerHTML = `<div class="note">No data</div>`; return; }
    div.innerHTML = `<div class="pill">${label}</div><div>` + items.map(([n,c])=> `<span class="numchip">${String(n).padStart(2,'0')} ‚Ä¢ ${c}</span>`).join('') + `</div>`;
  }
  function renderPairs(div, mapCounts){
    const arr=[...mapCounts.entries()].sort((a,b)=> b[1]-a[1]).slice(0,25);
    if(!arr.length){ div.innerHTML = '<span class="note">No pairs</span>'; return; }
    div.innerHTML = '<div class="pill">Top 25</div><div>' +
      arr.map(([pk,c])=> `<span class="numchip">${pk.replace('-','‚Äì')} ‚Ä¢ ${c}</span>`).join('') + '</div>';
  }
  function renderBalance(div, bal){
    if(!bal || !bal._count){ div.innerHTML = '<span class="note">No balance stats</span>'; return; }
    function row(label, o){ return `<tr><th>${label}</th><td>${o.mean?.toFixed(2)??'-'}</td><td>${o.std?.toFixed(2)??'-'}</td><td>${o.min??'-'}</td><td>${o.max??'-'}</td></tr>`; }
    div.innerHTML = `<div class="pill">n=${bal._count}, sum range ${bal._sumRange}</div>
      <table><thead><tr><th>Metric</th><th>Mean</th><th>Std</th><th>Min</th><th>Max</th></tr></thead>
      <tbody>
        ${row('Sum', bal.sum||{})}
        ${row('Odd count', bal.odd_count||{})}
        ${row('Even count', bal.even_count||{})}
        ${row('Low (<=27)', bal.low_count||{})}
        ${row('High (>=28)', bal.high_count||{})}
        ${row('Spread', bal.spread||{})}
      </tbody></table>`;
  }

  function analyzeUI(){
    const lambda = parseFloat(document.getElementById('lambda').value||'0.7');
    const kappa = parseFloat(document.getElementById('kappa').value||'0.7');
    const excludeMode = document.getElementById('excludeMode').value;
    const softPctNum = parseFloat(document.getElementById('softPctNum').value||'15');
    const softPctSum = parseFloat(document.getElementById('softPctSum').value||'25');

    const A = analyze(lambda, kappa);

    // Hot/cold winners
    const wfArr = [...A.wf.entries()];
    wfArr.sort((a,b)=> b[1]-a[1] || a[0]-b[0]);
    renderList(wHotDiv, wfArr.slice(0,12), "Top 12");
    const wCold = [...A.wf.entries()].sort((a,b)=> a[1]-b[1] || a[0]-b[0]).slice(0,12);
    renderList(wColdDiv, wCold, "Bottom 12");

    // Non-winners hot/cold
    const nfArr = [...A.nf.entries()];
    nfArr.sort((a,b)=> b[1]-a[1] || a[0]-b[0]);
    renderList(nHotDiv, nfArr.slice(0,12), "Top 12");
    const nCold = [...A.nf.entries()].sort((a,b)=> a[1]-b[1] || a[0]-b[0]).slice(0,12);
    renderList(nColdDiv, nCold, "Bottom 12");

    // Pairs & balance
    renderPairs(wPairsTopDiv, A.pairCounts);
    renderBalance(wBalDiv, A.wBal);
    renderBalance(nBalDiv, describeBalance(N));

    // Exclusions
    const {excludedNums, excludedSums} = excludeSets(A, excludeMode, softPctNum, softPctSum);

    excludedNumsDiv.innerHTML = `<div class="pill">Excluded Numbers (${excludedNums.size})</div>` +
      `<div>${[...excludedNums].sort((a,b)=>a-b).map(n=> `<span class="numchip">${String(n).padStart(2,'0')}</span>`).join('')||'<span class="muted">none</span>'}</div>`;

    const sumLabel = `<div class="pill">Excluded Sums (${excludedSums.size})</div>`;
    const sumsSorted = [...excludedSums].sort((a,b)=>a-b);
    excludedSumsDiv.innerHTML = sumLabel + `<div class="small">${sumsSorted.length? sumsSorted.map(S=>`<span class="numchip">${S}</span>`).join('') : '<span class="muted">none</span>'}</div>`;
  }

  function generateTicketsUI(){
    const lambda = parseFloat(document.getElementById('lambda').value||'0.7');
    const kappa = parseFloat(document.getElementById('kappa').value||'0.7');
    const excludeMode = document.getElementById('excludeMode').value;
    const softPctNum = parseFloat(document.getElementById('softPctNum').value||'15');
    const softPctSum = parseFloat(document.getElementById('softPctSum').value||'25');

    const beta = parseFloat(document.getElementById('beta').value||'0.15');
    const gamma = parseFloat(document.getElementById('gamma').value||'0.10');
    const delta = parseFloat(document.getElementById('delta').value||'0.25');
    const attempts = parseInt(document.getElementById('attempts').value||'450',10);
    const kTickets = parseInt(document.getElementById('kTickets').value||'10',10);

    const A = analyze(lambda, kappa);
    const {excludedNums, excludedSums} = excludeSets(A, excludeMode, softPctNum, softPctSum);

    // Allowed numbers pool
    const allowedNums = [];
    for(let n=NMIN;n<=NMAX;n++){
      if(!excludedNums.has(n)) allowedNums.push(n);
    }

    // If too few numbers remain, relax exclusions progressively
    function ensurePool(minNeeded){
      let relax=0;
      while(allowedNums.length<minNeeded && relax<3){
        relax++;
        // bring back some of the best among excluded by score
        const excludedArr = [...A.numScore.entries()].filter(([n])=>excludedNums.has(n));
        excludedArr.sort((a,b)=> b[1]-a[1]); // highest score first
        const toAdd = Math.min(minNeeded - allowedNums.length, Math.ceil(excludedArr.length*0.25));
        for(let i=0;i<toAdd;i++){
          const n = excludedArr[i]?.[0];
          if(n!=null && !allowedNums.includes(n)){ allowedNums.push(n); excludedNums.delete(n); }
        }
      }
    }
    ensurePool(PICK+6); // make sure we can sample 6 without replacement with some cushion

    // Build number weights only over allowed numbers (clip negatives to 0)
    const numWeights = new Map();
    let sumW=0;
    for(const n of allowedNums){
      const sc = Math.max(0, A.numScore.get(n) || 0);
      numWeights.set(n, sc);
      sumW += sc;
    }
    if(sumW<=0){
      // fallback uniform over allowed
      const u=1/allowedNums.length;
      for(const n of allowedNums) numWeights.set(n, u);
    } else {
      for(const n of allowedNums) numWeights.set(n, numWeights.get(n)/sumW);
    }

    // Allowed sums (based on sumScore)
    const allowedSums = new Set();
    if(A.sumScore.size){
      const sumsArr = [...A.sumScore.entries()];
      if(excludeMode==="hard"){
        for(const [S,sc] of sumsArr) if(sc>0) allowedSums.add(S);
      } else {
        const excl = bottomPercentKeys(A.sumScore, softPctSum);
        for(const [S] of sumsArr) if(!excl.has(S)) allowedSums.add(S);
      }
    }

    // Relax sums if empty
    if(!allowedSums.size && A.sumScore.size){
      const sumsArr = [...A.sumScore.entries()].sort((a,b)=> b[1]-a[1]);
      for(let i=0;i<Math.min(30, sumsArr.length); i++){
        const S = sumsArr[i][0]; allowedSums.add(S);
      }
    }

    // Helpers
    function sampleWithoutReplacement(weightsMap, k){
      const entries = [...weightsMap.entries()].filter(([n,w])=>w>0);
      if(entries.length<k){
        // broaden with smallest positive or even zero-weights from allowed nums
        const expand = allowedNums.filter(n=>!entries.find(e=>e[0]===n)).map(n=>[n, 1e-9]);
        entries.push(...expand);
      }
      // normalize
      let sum=0; for(const [,w] of entries) sum+=w;
      if(sum<=0){ // uniform
        const pool = entries.map(e=>e[0]);
        pool.sort(()=>Math.random()-0.5);
        return pool.slice(0,k).sort((a,b)=>a-b);
      }
      const nums=[], used=new Set();
      for(let i=0;i<k;i++){
        let s=0; for(const [n,w] of entries) if(!used.has(n)) s+=w;
        let r=Math.random()*s, acc=0, pick=null;
        for(const [n,w] of entries){
          if(used.has(n)) continue;
          acc += w;
          if(r<=acc){ pick=n; break; }
        }
        if(pick==null){
          const rest = entries.map(e=>e[0]).filter(n=>!used.has(n));
          pick = rest[Math.floor(Math.random()*rest.length)];
        }
        used.add(pick); nums.push(pick);
      }
      return nums.sort((a,b)=>a-b);
    }

    function scoreTicket(nums){
      // base number weight
      let base=0; for(const n of nums) base += Math.max(0, A.numScore.get(n)||0);

      // pair score
      let pairS=0;
      for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
          const pk = [nums[i],nums[j]].sort((a,b)=>a-b).join("-");
          const c = A.pairCounts.get(pk)||0;
          if(A.totalPairs>0) pairS += c/A.totalPairs;
        }
      }

      // balance score
      const sum = nums.reduce((s,x)=>s+x,0);
      const odd = nums.filter(x=>x%2===1).length;
      const low = nums.filter(x=>x<=27).length;
      const spread = Math.max(...nums)-Math.min(...nums);
      const b = A.wBal||{};
      const sScore = zScore(sum, b.sum?.mean, b.sum?.std);
      const oScore = zScore(odd, b.odd_count?.mean, b.odd_count?.std);
      const lScore = zScore(low, b.low_count?.mean, b.low_count?.std);
      const dScore = zScore(spread, b.spread?.mean, b.spread?.std);
      const balS = (sScore + oScore + lScore + dScore)/4;

      // sum score ‚Äî only if allowed sums present; interpolate if needed
      let sumS=0;
      if(A.sumScore.size){
        if(A.sumScore.has(sum) && (allowedSums.size===0 || allowedSums.has(sum))){
          sumS = Math.max(0, A.sumScore.get(sum));
        } else {
          // soft interpolation by distance
          let num=0,den=0;
          for(const [S,w] of A.sumScore.entries()){
            if(allowedSums.size && !allowedSums.has(S)) continue;
            const k = 1/(1+Math.abs(S-sum));
            num += k*Math.max(0,w); den += k;
          }
          sumS = den>0? num/den : 0;
        }
      }

      const beta = parseFloat(document.getElementById('beta').value||'0.15');
      const gamma = parseFloat(document.getElementById('gamma').value||'0.10');
      const delta = parseFloat(document.getElementById('delta').value||'0.25');
      const baseWeight = Math.max(0, 1 - beta - gamma - delta);
      return baseWeight*base + beta*pairS + gamma*balS + delta*sumS;
    }

    // Generate
    const tickets=[];
    const seen=new Set();
    const attempts = parseInt(document.getElementById('attempts').value||'450',10);

    for(let t=0;t<kTickets;t++){
      let best=null, bestScore=-1e9;
      let tries=attempts;
      while(tries--){
        // sample numbers from allowed pool
        const cand = sampleWithoutReplacement(numWeights, PICK);

        // enforce sum restriction (if allowed sums exist, prefer staying inside)
        const s = cand.reduce((a,b)=>a+b,0);
        if(allowedSums.size && !allowedSums.has(s)){
          // give it a chance but lower priority; the scorer also penalizes
        }
        const sc = scoreTicket(cand);
        if(sc>bestScore && !seen.has(cand.join("-"))){
          best=cand; bestScore=sc;
        }
      }
      // if best still null, fallback uniform over allowed
      if(!best){
        const pool = [...allowedNums];
        pool.sort(()=>Math.random()-0.5);
        best = pool.slice(0,PICK).sort((a,b)=>a-b);
        bestScore = scoreTicket(best);
      }
      seen.add(best.join("-"));
      tickets.push({nums:best, score:bestScore});
    }

    ticketsDiv.innerHTML = tickets.map((t,i)=>
      `<div class="row" style="align-items:center;justify-content:space-between;border-bottom:1px solid var(--grid);padding:6px 0">
        <div><span class="pill">Ticket ${i+1}</span></div>
        <div class="ticket">${t.nums.map(n=>`<span class="numchip">${String(n).padStart(2,'0')}</span>`).join('')}</div>
        <div class="small muted">score ${t.score.toFixed(4)}</div>
      </div>`
    ).join('');
  }

  // Wire up buttons
  document.getElementById('analyzeBtn').addEventListener('click', analyzeUI);
  document.getElementById('genBtn').addEventListener('click', generateTicketsUI);

  // Initial
  refreshCounts();
})();
</script>
</body>
</html>
