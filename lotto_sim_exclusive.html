<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lotto 300-Draw Streak & Probability Coach — 1,200 Samples + 10-Ticket Generator</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --chip:#1e2a59;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:16px;
  }
  h1{
    margin:6px 0 4px;
    font-size:1.6rem;
  }
  .tagline{
    margin:0 0 12px;
    color:var(--muted);
    font-size:0.9rem;
  }
  section{
    background:var(--panel);
    border:1px solid var(--grid);
    border-radius:10px;
    padding:12px;
    margin-top:14px;
  }
  h2{
    margin:0 0 8px;
    font-size:1.05rem;
  }
  label{
    font-size:0.85rem;
    color:var(--muted);
    display:block;
    margin-bottom:4px;
  }
  textarea{
    width:100%;
    min-height:90px;
    background:#070c19;
    color:var(--ink);
    border:1px solid var(--grid);
    border-radius:8px;
    padding:8px;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.8rem;
    resize:vertical;
    white-space:pre;
  }
  textarea.small{
    min-height:70px;
  }
  .hint{
    font-size:0.75rem;
    color:var(--muted);
    margin:4px 0 8px;
  }
  .btn-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin:8px 0;
  }
  button{
    border:none;
    border-radius:999px;
    padding:7px 14px;
    font-size:0.85rem;
    cursor:pointer;
    background:var(--chip);
    color:var(--ink);
  }
  button.primary{
    background:var(--accent);
    color:#050816;
    font-weight:600;
  }
  button:disabled{
    opacity:0.55;
    cursor:not-allowed;
  }
  .summary{
    margin-top:8px;
    padding:8px;
    border-radius:8px;
    background:#0c1630;
    border:1px dashed var(--grid);
    font-size:0.8rem;
  }
  .summary strong{
    color:var(--accent);
  }
  .pill-row{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    margin-top:4px;
  }
  .pill{
    font-size:0.7rem;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--grid);
    background:#0a142b;
    color:var(--muted);
  }
  .pill.good{
    border-color:var(--good);
    color:var(--good);
  }
  .pill.bad{
    border-color:var(--bad);
    color:var(--bad);
  }
  .spread{
    margin-top:6px;
    font-size:0.75rem;
    color:var(--muted);
  }
  .spread.tight{color:var(--bad);}
  .spread.loose{color:var(--warn);}
  .spread.balanced{color:var(--good);}
  .footer-note{
    margin-top:12px;
    font-size:0.72rem;
    color:var(--muted);
  }

  /* Stats table for streak/gap model */
  .scroll-table{
    max-height:260px;
    overflow:auto;
    border-radius:8px;
    border:1px solid var(--grid);
    padding:6px 8px;
    background:#050815;
    font-size:0.78rem;
    margin-top:6px;
  }
  table{
    width:100%;
    border-collapse:collapse;
  }
  th,td{
    padding:3px 4px;
    text-align:right;
    border-bottom:1px solid #1b2550;
  }
  th{
    position:sticky;
    top:0;
    background:#080f23;
    z-index:1;
  }
  .tag-badge{
    font-size:0.7rem;
    padding:1px 6px;
    border-radius:999px;
    background:#1e293b;
  }
  .tag-hot{ background:rgba(127,255,177,0.12); color:var(--good); }
  .tag-late{ background:rgba(255,211,122,0.12); color:var(--warn); }
  .tag-run{ background:rgba(143,180,255,0.12); color:var(--accent); }
</style>
</head>
<body>
<div class="wrap">
  <h1>Lotto 300-Draw Streak &amp; Probability Coach</h1>
  <p class="tagline">
    Paste up to 300 official draws → build frequency, gap/recency &amp; streak model → generate 1,200 sample tickets →
    see top-weight numbers → generate 10 final tickets using the best weights.
  </p>

  <!-- PANEL 1: OFFICIAL DRAWS (UP TO 300) + 1,200-SAMPLE ENGINE + STREAK/GAP MODEL -->
  <section>
    <h2>1. Official draws (up to 300) → 1,200-sample engine + streak/gap model</h2>

    <label for="lastDraws60">Official winning draws (oldest → newest)</label>
    <textarea id="lastDraws60" placeholder="Example (one line per draw, 6 numbers):&#10;03 12 24 33 41 52&#10;01 05 18 27 36 49&#10;... paste up to your last 300 official draws"></textarea>
    <div class="hint">
      Each line = 6 numbers, 1–54, separated by spaces or commas. You can paste 60, 100, 300, etc.
      The engine will:
      (1) build the pool from these draws,
      (2) compute frequency, gap/recency, and streaks (3-in-a-row or more),
      (3) compute a combined weight/score for each number,
      and (4) generate 1,200 sample tickets.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="analyzeAndSample()">Analyze draws &amp; generate 1,200 sample tickets</button>
      <button onclick="clearAll()">Reset everything</button>
    </div>

    <label for="bulkTickets">1,200 generated sample tickets (1 ticket per line)</label>
    <textarea id="bulkTickets" class="small" placeholder="Click &quot;Analyze draws &amp; generate 1,200 sample tickets&quot; to see the list here."></textarea>

    <div id="bulkStats" class="summary">
      Waiting for data: paste your official draws and run the analysis to see pool size, frequency statistics,
      probability bands, and the streak/gap model.
    </div>

    <div class="summary">
      <strong>Number probability bands (inside official-draw universe)</strong>
      <div id="scoreBands" class="pill-row">
        <span class="pill">No probabilities yet — run Panel 1 first.</span>
      </div>
    </div>

    <div class="summary">
      <strong>Streak / gap / recency model — top-weight numbers (for next draw)</strong>
      <div id="modelTopNumbers" class="pill-row">
        <span class="pill">Run analysis to see the top-weight numbers.</span>
      </div>
    </div>
  </section>

  <!-- PANEL 1B: FULL NUMBER STATS TABLE -->
  <section>
    <h2>1b. Full number stats (freq, gap/recency, streaks, score)</h2>
    <div class="hint">
      For each number 1–54:
      frequency in the window, last seen (draw index), recency (gap since last hit),
      max streak in a row, number of runs ≥ 3, and the combined score used by the 10-ticket generator.
    </div>
    <div class="scroll-table">
      <table id="statsTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Freq</th>
            <th>Last</th>
            <th>Rec</th>
            <th>MaxRun</th>
            <th>Runs≥3</th>
            <th>Score</th>
            <th style="text-align:left;">Tags</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- PANEL 2: COMPARE YOUR 60 GENERATED TICKETS -->
  <section>
    <h2>2. Compare your 60 generated tickets vs official draws &amp; 1,200 samples</h2>

    <label for="simTickets">Your 60 generated tickets (1 ticket per line)</label>
    <textarea id="simTickets" placeholder="Paste the 60 tickets you generated/played (6 numbers per line, 1–54)."></textarea>
    <div class="hint">
      The simulator will compute how your 60 tickets line up with:
      (a) the official-draw frequencies, and (b) the 1,200-sample frequencies.
      This shows how far your play deviates from the probabilities in the chosen window.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="compare60()">Compare distributions (official vs 1,200 vs your 60)</button>
    </div>

    <div id="compareStats" class="summary">
      After running Panel 1, paste your 60 tickets here and click
      <strong>Compare distributions</strong> to see deviations and top over-used / under-used numbers.
    </div>
  </section>

  <!-- PANEL 3: 10-TICKET GENERATOR USING STREAK/GAP WEIGHTS + ANTI-OVERUSE MEMORY -->
  <section>
    <h2>3. Generate 10 tickets using weight + gap/recency + streak model</h2>

    <div class="hint">
      Uses the combined score from Panel 1 (frequency + lateness/gap + streak strength).
      A memory system tracks how often each number has been used in past generations and penalizes over-used numbers,
      so under-used numbers get a boost and the shape stays closer to the model.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="generate10()">Generate 10 tickets (streak/gap-weighted with correction)</button>
    </div>

    <label for="tenTicketsOut">10-ticket output (model-based play candidates)</label>
    <textarea id="tenTicketsOut" class="small" placeholder="Run Panel 1 first, then click &quot;Generate 10 tickets&quot;."></textarea>

    <div id="spreadDiag" class="spread">
      Spread diagnostic will appear here (tight / balanced / loose) after generation.
    </div>

    <div class="footer-note">
      ⚠️ This simulator cannot defeat true lottery randomness. It only keeps your 10-ticket patterns inside the
      statistical shape of your official draws (frequency, gap/recency, streaks), while automatically reducing
      extreme over-weight / under-weight of individual numbers across many runs.
    </div>
  </section>
<script>
  const MAX_N = 54;
  const NUM_PER_TICKET = 6;
  const SAMPLE_TICKETS = 1200; // 1,200 sample tickets

  // Global state
  let poolNumbers = [];                        // numbers that appear in the official draws window
  let officialFreq = Array(MAX_N+1).fill(0);   // frequency in official draws
  let sampleFreq   = Array(MAX_N+1).fill(0);   // frequency in 1,200 generated tickets
  let combinedScores = null;                   // streak/gap-based weights for generator
  let usageCounts = Array(MAX_N+1).fill(0);    // how many times each number has been used in generated 10-ticket sets

  // Streak/gap model arrays
  let lastSeen   = Array(MAX_N+1).fill(-1);
  let recency    = Array(MAX_N+1).fill(0);
  let maxRun     = Array(MAX_N+1).fill(0);
  let runs3Plus  = Array(MAX_N+1).fill(0);
  let modelScore = Array(MAX_N+1).fill(0);

  function parseTickets(raw){
    const lines = raw.split(/[\r\n]+/).map(l=>l.trim()).filter(l=>l.length>0);
    const tickets = [];
    for(const line of lines){
      const nums = line
        .replace(/,/g,' ')
        .replace(/-/g,' ')
        .split(/\s+/)
        .map(x=>parseInt(x,10))
        .filter(n=>Number.isFinite(n) && n>=1 && n<=MAX_N);
      if(nums.length === NUM_PER_TICKET){
        const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);
        if(uniq.length === NUM_PER_TICKET) tickets.push(uniq);
      }
    }
    return tickets;
  }

  function weightedPickFromPool(scores,pool,used){
    let total=0;
    for(const n of pool){
      if(!used.has(n)) total += Math.max(scores[n] || 0, 0);
    }
    if(total<=0){
      const candidates = pool.filter(n=>!used.has(n));
      return candidates[Math.floor(Math.random()*candidates.length)];
    }
    let r = Math.random()*total;
    for(const n of pool){
      if(used.has(n)) continue;
      const w = Math.max(scores[n] || 0, 0);
      r -= w;
      if(r<=0) return n;
    }
    const candidates = pool.filter(n=>!used.has(n));
    return candidates[0];
  }

  function analyzeAndSample(){
    const raw = document.getElementById('lastDraws60').value;
    const bulkEl = document.getElementById('bulkTickets');
    const statsEl = document.getElementById('bulkStats');
    const scoreBandsEl = document.getElementById('scoreBands');

    const draws = parseTickets(raw);
    if(draws.length === 0){
      statsEl.innerHTML = 'Please paste your official draws (up to 300) before running the analysis.';
      return;
    }

    const D = draws.length;

    // Build pool and official frequencies
    poolNumbers = [];
    const poolSet = new Set();
    officialFreq = Array(MAX_N+1).fill(0);
    for(const d of draws){
      for(const n of d){
        poolSet.add(n);
        officialFreq[n]++;
      }
    }
    poolNumbers = Array.from(poolSet).sort((a,b)=>a-b);

    if(poolNumbers.length < NUM_PER_TICKET){
      statsEl.innerHTML = 'Need at least 6 distinct numbers across the official draws to build a valid pool.';
      bulkEl.value = '';
      return;
    }

    // Official probabilities p_off
    const totalOfficialNums = D * NUM_PER_TICKET;
    const pOff = Array(MAX_N+1).fill(0);
    for(let n=1;n<=MAX_N;n++){
      pOff[n] = officialFreq[n] > 0 ? officialFreq[n]/totalOfficialNums : 0;
    }

    // Generate 1,200 sample tickets from pool using p_off as weights
    const lines = [];
    sampleFreq = Array(MAX_N+1).fill(0);

    for(let t=0;t<SAMPLE_TICKETS;t++){
      const used = new Set();
      while(used.size < NUM_PER_TICKET){
        const num = weightedPickFromPool(pOff,poolNumbers,used);
        used.add(num);
        sampleFreq[num]++;
      }
      const ticket = Array.from(used).sort((a,b)=>a-b);
      lines.push(ticket.map(n=>String(n).padStart(2,'0')).join(' '));
    }
    bulkEl.value = lines.join('\n');

    // Build streak/gap model (freq, lastSeen, recency, maxRun, runs≥3, score)
    buildStreakGapModel(draws);

    // For the generator, use the model score (freq + gap + streak), not just p_off
    combinedScores = Array(MAX_N+1).fill(0);
    for(let n=1;n<=MAX_N;n++){
      combinedScores[n] = modelScore[n];
    }

    // Stats summary for sample distribution
    const totalSampleNums = SAMPLE_TICKETS * NUM_PER_TICKET;

    let minOff=Infinity,maxOff=-Infinity,minSamp=Infinity,maxSamp=-Infinity;
    for(const n of poolNumbers){
      const fOff = officialFreq[n];
      const fSamp = sampleFreq[n];
      if(fOff<minOff) minOff=fOff;
      if(fOff>maxOff) maxOff=fOff;
      if(fSamp<minSamp) minSamp=fSamp;
      if(fSamp>maxSamp) maxSamp=fSamp;
    }
    const avgOff  = totalOfficialNums / poolNumbers.length;
    const avgSamp = totalSampleNums / poolNumbers.length;

    statsEl.innerHTML =
      `Draw window size: <strong>${D}</strong> draws · Pool size: <strong>${poolNumbers.length}</strong> unique numbers.<br>` +
      `Official draws: total numbers = ${totalOfficialNums}, average per pool number ≈ ${avgOff.toFixed(2)} ` +
      `(min ${minOff}, max ${maxOff}).<br>` +
      `1,200 sample tickets: total numbers = ${totalSampleNums}, average per pool number ≈ ${avgSamp.toFixed(2)} ` +
      `(min ${minSamp}, max ${maxSamp}).<br>` +
      `<em>Streak/gap model and 10-ticket generator now use the combined score (frequency + gap/recency + streaks).</em>`;

    // Probability bands based on p_off
    scoreBandsEl.innerHTML = '';
    const vals = poolNumbers.map(n=>pOff[n]);
    const maxVal = Math.max(...vals);
    const minVal = Math.min(...vals);
    const span = maxVal - minVal || 1;
    const bands = {low:0,mid:0,high:0};

    for(const n of poolNumbers){
      const norm = (pOff[n]-minVal)/span;
      if(norm < 0.33) bands.low++;
      else if(norm < 0.66) bands.mid++;
      else bands.high++;
    }

    scoreBandsEl.innerHTML =
      `<span class="pill bad">Low-prob: ${bands.low}</span>
       <span class="pill">Mid-prob: ${bands.mid}</span>
       <span class="pill good">High-prob: ${bands.high}</span>`;

    // Reset usage memory so new runs start fresh
    usageCounts = Array(MAX_N+1).fill(0);

    // Render streak/gap model outputs (top numbers + stats table)
    renderModelOutputs(D);
  }

  function buildStreakGapModel(draws){
    const D = draws.length;

    // presence[n][d] = true if n appears in draw d
    const presence = Array(MAX_N+1).fill(null).map(()=>Array(D).fill(false));
    for(let d=0; d<D; d++){
      const set = new Set(draws[d]);
      for(const n of set){
        if(n>=1 && n<=MAX_N){
          presence[n][d] = true;
        }
      }
    }

    lastSeen  = Array(MAX_N+1).fill(-1);
    recency   = Array(MAX_N+1).fill(0);
    maxRun    = Array(MAX_N+1).fill(0);
    runs3Plus = Array(MAX_N+1).fill(0);

    for(let n=1; n<=MAX_N; n++){
      let last = -1;
      let currentRun = 0;
      let maxR = 0;
      let runs3 = 0;

      for(let d=0; d<D; d++){
        if(presence[n][d]){
          last = d;
          currentRun++;
        }else{
          if(currentRun >= 3) runs3++;
          if(currentRun > maxR) maxR = currentRun;
          currentRun = 0;
        }
      }
      // tail streak
      if(currentRun >= 3) runs3++;
      if(currentRun > maxR) maxR = currentRun;

      lastSeen[n] = last;
      if(last === -1){
        recency[n] = D;  // never seen in this window
      }else{
        recency[n] = (D - 1) - last;
      }
      maxRun[n] = maxR;
      runs3Plus[n] = runs3;
    }

    // Score: combine normalized freq, lateness, streak strength
    modelScore = Array(MAX_N+1).fill(0);
    const freq = officialFreq;

    const maxFreq = Math.max(...freq.slice(1));
    const maxRec  = Math.max(...recency.slice(1));
    const maxRunGlobal = Math.max(...maxRun.slice(1));

    for(let n=1; n<=MAX_N; n++){
      if(!poolNumbers.includes(n)){
        modelScore[n] = 0;
        continue;
      }
      const freqNorm = maxFreq > 0 ? freq[n]/maxFreq : 0;
      const lateNorm = maxRec  > 0 ? recency[n]/maxRec : 0;
      const runNorm  = maxRunGlobal > 0 ? maxRun[n]/maxRunGlobal : 0;
      // You can tweak weights (0.5, 0.4, 0.1)
      const s = 0.5*freqNorm + 0.4*lateNorm + 0.1*runNorm;
      modelScore[n] = s;
    }
  }

  function renderModelOutputs(D){
    const topEl = document.getElementById('modelTopNumbers');
    const statsBody = document.querySelector('#statsTable tbody');

    // Build rows
    const rows = [];
    for(let n=1; n<=MAX_N; n++){
      rows.push({
        n,
        freq: officialFreq[n],
        last: lastSeen[n],
        rec: recency[n],
        maxRun: maxRun[n],
        runs3: runs3Plus[n],
        score: modelScore[n]
      });
    }

    // Top-weight numbers by score
    const sortedByScore = rows.slice().sort((a,b)=>b.score - a.score);
    const topCount = 15;
    const top = sortedByScore.filter(r=>r.score>0).slice(0, topCount);

    topEl.innerHTML = '';
    if(top.length === 0){
      topEl.innerHTML = '<span class="pill">No positive scores yet (check your draws input).</span>';
    }else{
      top.forEach((r,idx)=>{
        const pill = document.createElement('span');
        pill.className = 'pill';
        pill.innerHTML = `<strong>${r.n}</strong> #${idx+1} · score ${r.score.toFixed(3)} · freq ${r.freq} · rec ${r.rec}`;
        topEl.appendChild(pill);
      });
    }

    // Stats table: sort by number
    statsBody.innerHTML = '';
    const maxFreq = Math.max(...officialFreq.slice(1));
    const maxRec  = Math.max(...recency.slice(1));
    const maxRunGlobal = Math.max(...maxRun.slice(1));

    const rowsByN = rows.slice().sort((a,b)=>a.n - b.n);
    rowsByN.forEach(r=>{
      const tr = document.createElement('tr');

      const tags = [];
      if(r.freq === maxFreq && maxFreq>0) tags.push('<span class="tag-badge tag-hot">hottest</span>');
      else if(r.freq >= Math.max(3, Math.round(maxFreq*0.7))) tags.push('<span class="tag-badge tag-hot">hot</span>');
      if(r.rec === maxRec && maxRec>0) tags.push('<span class="tag-badge tag-late">latest</span>');
      else if(r.rec >= Math.max(5, Math.round(maxRec*0.7))) tags.push('<span class="tag-badge tag-late">late</span>');
      if(r.maxRun >= 3) tags.push(`<span class="tag-badge tag-run">run×${r.maxRun}</span>`);

      tr.innerHTML = `
        <td>${r.n}</td>
        <td>${r.freq}</td>
        <td>${r.last === -1 ? '—' : r.last}</td>
        <td>${r.rec}</td>
        <td>${r.maxRun}</td>
        <td>${r.runs3}</td>
        <td>${r.score.toFixed(3)}</td>
        <td style="text-align:left;">${tags.join(' ')}</td>
      `;
      statsBody.appendChild(tr);
    });
  }

  function compare60(){
    const statsEl = document.getElementById('compareStats');
    if(poolNumbers.length === 0 || !combinedScores){
      statsEl.innerHTML = 'Run Panel 1 first (analyze draws & generate 1,200 samples) before comparing.';
      return;
    }

    const draws = parseTickets(document.getElementById('lastDraws60').value);
    if(draws.length === 0){
      statsEl.innerHTML = 'Your official draws are missing. Paste them again in Panel 1 and rerun.';
      return;
    }

    const simTickets = parseTickets(document.getElementById('simTickets').value);
    if(simTickets.length === 0){
      statsEl.innerHTML = 'Paste your 60 generated tickets and try again.';
      return;
    }

    const freqOfficial = officialFreq.slice(); // already computed
    const freqSample   = sampleFreq.slice();   // already computed
    const freqSim      = Array(MAX_N+1).fill(0);

    let outsidePoolSim = 0;
    for(const t of simTickets){
      for(const n of t){
        freqSim[n]++;
        if(!poolNumbers.includes(n)) outsidePoolSim++;
      }
    }

    const totalOfficial = draws.length * NUM_PER_TICKET;
    const totalSample   = SAMPLE_TICKETS * NUM_PER_TICKET;
    const totalSim      = simTickets.length * NUM_PER_TICKET;

    let sumDevOffSample = 0;
    let sumDevOffSim    = 0;
    for(const n of poolNumbers){
      const pOff  = totalOfficial ? freqOfficial[n]/totalOfficial : 0;
      const pSamp = totalSample   ? freqSample[n]/totalSample     : 0;
      const pSim  = totalSim      ? freqSim[n]/totalSim           : 0;
      sumDevOffSample += Math.abs(pOff - pSamp);
      sumDevOffSim    += Math.abs(pOff - pSim);
    }
    const avgDevOffSample = sumDevOffSample / poolNumbers.length;
    const avgDevOffSim    = sumDevOffSim    / poolNumbers.length;

    const diffs = [];
    for(const n of poolNumbers){
      const pOff = totalOfficial ? freqOfficial[n]/totalOfficial : 0;
      const pSim = totalSim      ? freqSim[n]/totalSim           : 0;
      diffs.push({ n, pOff, pSim, diff: pSim - pOff });
    }
    diffs.sort((a,b)=>Math.abs(b.diff) - Math.abs(a.diff));
    const topOver  = diffs.filter(x=>x.diff>0).slice(0,5);
    const topUnder = diffs.filter(x=>x.diff<0).slice(0,5);

    function fmtPercent(x){ return (x*100).toFixed(2)+'%'; }

    let overText = topOver.length ? topOver.map(x =>
      `${String(x.n).padStart(2,'0')} → you: ${fmtPercent(x.pSim)}, official: ${fmtPercent(x.pOff)}`
    ).join('<br>') : 'None (no numbers strongly over-used).';

    let underText = topUnder.length ? topUnder.map(x =>
      `${String(x.n).padStart(2,'0')} → you: ${fmtPercent(x.pSim)}, official: ${fmtPercent(x.pOff)}`
    ).join('<br>') : 'None (no numbers strongly under-used).';

    statsEl.innerHTML =
      `Compared distributions on <strong>${poolNumbers.length}</strong> pool numbers (official-draw universe).<br>` +
      `Average absolute deviation (official vs 1,200 sample): <strong>${fmtPercent(avgDevOffSample)}</strong><br>` +
      `Average absolute deviation (official vs your 60 tickets): <strong>${fmtPercent(avgDevOffSim)}</strong><br>` +
      `<em>Lower deviation means staying closer to the probabilities in your window.</em><br><br>` +
      `Numbers outside pool used in your 60 tickets: <strong>${outsidePoolSim}</strong> (these never appeared in the official window).<br><br>` +
      `<strong>Most over-used numbers in your 60 vs official draws:</strong><br>${overText}<br><br>` +
      `<strong>Most under-used numbers in your 60 vs official draws:</strong><br>${underText}`;
  }

  function generate10(){
    const outEl = document.getElementById('tenTicketsOut');
    const spreadEl = document.getElementById('spreadDiag');

    if(poolNumbers.length === 0 || !combinedScores){
      outEl.value = '';
      spreadEl.className = 'spread';
      spreadEl.textContent = 'Run Panel 1 first (analyze draws & generate 1,200 samples).';
      return;
    }

    const tickets = [];
    const gapsAll = [];

    // Effective scores with anti-overuse correction:
    // effectiveScore = baseScore / (1 + usageCounts[n]/K)
    const K = 10; // controls strength of correction: higher K = softer penalty
    const effectiveScores = Array(MAX_N+1).fill(0);
    for(const n of poolNumbers){
      const base = combinedScores[n] || 0.000001;
      const penalty = 1 + (usageCounts[n] / K);
      effectiveScores[n] = base / penalty;
    }

    for(let t=0;t<10;t++){
      const used = new Set();
      while(used.size < NUM_PER_TICKET){
        const n = weightedPickFromPool(effectiveScores,poolNumbers,used);
        used.add(n);
        usageCounts[n]++; // memory: penalize this number in future generations
      }
      const ticket = Array.from(used).sort((a,b)=>a-b);
      tickets.push(ticket);

      for(let i=1;i<ticket.length;i++){
        gapsAll.push(ticket[i]-ticket[i-1]);
      }
    }

    outEl.value = tickets
      .map(t=>t.map(n=>String(n).padStart(2,'0')).join(' '))
      .join('\n');

    if(gapsAll.length){
      let sum=0,minG=Infinity,maxG=-Infinity;
      for(const g of gapsAll){
        sum+=g;
        if(g<minG) minG=g;
        if(g>maxG) maxG=g;
      }
      const avg = sum/gapsAll.length;
      const label = avg<6 ? 'tight' : avg>10 ? 'loose' : 'balanced';
      spreadEl.className = 'spread '+label;
      spreadEl.textContent =
        `Spread avg gap ${avg.toFixed(2)} (${minG}-${maxG}) → ${label}`;
    }else{
      spreadEl.className = 'spread';
      spreadEl.textContent = 'Spread diagnostic will appear here (tight / balanced / loose) after generation.';
    }
  }

  function clearAll(){
    document.getElementById('lastDraws60').value = '';
    document.getElementById('bulkTickets').value = '';
    document.getElementById('simTickets').value = '';
    document.getElementById('tenTicketsOut').value = '';

    document.getElementById('bulkStats').innerHTML =
      'Waiting for data: paste your official draws and run the analysis to see pool size, frequency statistics, ' +
      'probability bands, and the streak/gap model.';
    document.getElementById('scoreBands').innerHTML =
      '<span class="pill">No probabilities yet — run Panel 1 first.</span>';
    document.getElementById('modelTopNumbers').innerHTML =
      '<span class="pill">Run analysis to see the top-weight numbers.</span>';
    document.querySelector('#statsTable tbody').innerHTML = '';
    document.getElementById('compareStats').innerHTML =
      'After running Panel 1, paste your 60 tickets here and click ' +
      '<strong>Compare distributions</strong> to see deviations and top over-used / under-used numbers.';
    document.getElementById('spreadDiag').className = 'spread';
    document.getElementById('spreadDiag').textContent =
      'Spread diagnostic will appear here (tight / balanced / loose) after generation.';

    poolNumbers = [];
    officialFreq = Array(MAX_N+1).fill(0);
    sampleFreq   = Array(MAX_N+1).fill(0);
    combinedScores = null;
    usageCounts = Array(MAX_N+1).fill(0);

    lastSeen   = Array(MAX_N+1).fill(-1);
    recency    = Array(MAX_N+1).fill(0);
    maxRun     = Array(MAX_N+1).fill(0);
    runs3Plus  = Array(MAX_N+1).fill(0);
    modelScore = Array(MAX_N+1).fill(0);
  }
</script>
</body>
</html>
