<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lotto Simulator ‚Äî Paste-Only (10 tickets ‚Ä¢ 6 numbers ‚Ä¢ 1‚Äì54)</title>
<style>
  :root{--bg:#0b1222;--panel:#121a33;--ink:#edf2ff;--muted:#a9b7e3;--accent:#8fb4ff;--grid:#1b2550;--chip:#1e2a59;--warn:#ffd37a}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:6px 0 10px;font-size:1.6rem}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;padding:14px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  textarea{width:100%;min-height:160px;background:#0e1530;color:var(--ink);border:1px solid var(--grid);border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Consolas}
  label{font-size:0.9rem;color:var(--muted)}
  input[type="number"],select{width:100%;background:#0e1530;color:var(--ink);border:1px solid var(--grid);border-radius:10px;padding:8px}
  input[type="text"]{width:100%;background:#0e1530;color:var(--ink);border:1px solid var(--grid);border-radius:10px;padding:8px}
  button{background:linear-gradient(180deg,#96b8ff,#6c96ff);color:#06102e;border:0;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}
  button.secondary{background:#1f2a57;color:var(--ink);border:1px solid var(--grid)}
  .pill{display:inline-block;background:var(--chip);border:1px solid var(--grid);padding:4px 8px;border-radius:999px;color:var(--muted);font-size:0.8rem}
  .note{color:var(--muted);font-size:0.9rem}
  .numchip{display:inline-block;background:#0e1737;border:1px solid var(--grid);padding:3px 7px;border-radius:8px;margin:2px;font-variant-numeric:tabular-nums}
  .ticket{display:flex;gap:6px;flex-wrap:wrap}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border-bottom:1px solid var(--grid);padding:6px 8px;font-variant-numeric:tabular-nums}
  th{text-align:left;color:var(--muted);font-weight:600}
</style>
</head>
<body>
<div class="wrap">
  <h1>üéØ Lotto Simulator ‚Äî Paste-Only (No Uploads)</h1>
  <p class="note">Paste your draws below. One line per draw, six integers 1‚Äì54 separated by spaces/commas. Example: <code>3, 12, 18, 27, 41, 52</code></p>

  <!-- PRIMARY INPUT PANELS -->
  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:baseline">
        <h3>Winning Draws (any prize)</h3>
        <span class="pill">favored</span>
      </div>
      <textarea id="winTxt" placeholder="Paste winners here...
3, 12, 18, 27, 41, 52
..."></textarea>
      <div class="row">
        <label>Total parsed: <span id="winCount">0</span></label>
        <label>Sum range: <span id="winSumRange">-</span></label>
        <label>Distinct pairs: <span id="winPairs">0</span></label>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:baseline">
        <h3>Non-Winning (rollovers)</h3>
        <span class="pill">penalized</span>
      </div>
      <textarea id="nonTxt" placeholder="Paste non-winners here...
1 5 11 22 33 44
..."></textarea>
      <div class="row">
        <label>Total parsed: <span id="nonCount">0</span></label>
        <label>Sum range: <span id="nonSumRange">-</span></label>
        <label>Distinct pairs: <span id="nonPairs">0</span></label>
      </div>
    </div>
  </div>

  <!-- RECENT DRAWS PANEL -->
  <div class="card" style="margin-top:16px">
    <div class="row" style="justify-content:space-between;align-items:baseline">
      <h3>Last 20 Draws (most recent)</h3>
      <span class="pill">recency prior</span>
    </div>
    <textarea id="recTxt" placeholder="Paste the last 20 official draws here (most recent first or last ‚Äî any order is fine)..."></textarea>
    <div class="row">
      <label>Total parsed: <span id="recCount">0</span></label>
      <label>Sum range: <span id="recSumRange">-</span></label>
      <label>Distinct pairs: <span id="recPairs">0</span></label>
    </div>
    <p class="note">These recent draws are blended into the winners with weight œÅ (below) for numbers, pairs, and sums.</p>
  </div>

  <!-- PREVIOUS GENERATED 0-100 ‚Äî EVALUATION SET -->
  <div class="card" style="margin-top:16px">
    <div class="row" style="justify-content:space-between;align-items:baseline">
      <h3>Previous Generated 0-100 Tickets Created ‚Äî <em>evaluation set</em></h3>
      <span class="pill">evaluation set</span>
    </div>
    <textarea id="genTxt" placeholder="Paste your 40 generated tickets here...
04 10 14 23 34 52
..."></textarea>
    <div class="row">
      <label>Total parsed: <span id="genCount">0</span></label>
      <label>Sum range: <span id="genSumRange">-</span></label>
      <label>Distinct pairs: <span id="genPairs">0</span></label>
    </div>
    <p class="note">Use this to measure how your 40 picks align with winner-like regions and recent trends.</p>

    <!-- NEW: DRAWN NUMBERS + EVALUATION FOR HITS ‚â• 3 -->
    <div class="row" style="margin-top:10px;align-items:flex-end">
      <div style="flex:1;min-width:220px">
        <label>Drawn 6 numbers for this set (evaluation)</label>
        <input id="genWinInput" type="text" placeholder="e.g. 03 12 25 31 44 52" />
      </div>
      <div>
        <button id="genEvalBtn" class="secondary">Evaluate Hits ‚â• 3</button>
      </div>
    </div>
    <p class="note" id="genEvalSummary">No evaluation yet. Paste tickets above, enter the drawn 6 numbers, then click ‚ÄúEvaluate Hits ‚â• 3‚Äù.</p>
    <div class="note" id="genEvalDetails"></div>
  </div>

  <!-- UPCOMING GENERATED 40 ‚Äî EVALUATION PANEL (NEW) -->
  <div class="card" style="margin-top:16px">
    <div class="row" style="justify-content:space-between;align-items:baseline">
      <h3>Upcoming Draw ‚Äî Paste your 40 generated tickets (to evaluate)</h3>
      <span class="pill">upcoming eval</span>
    </div>
    <textarea id="upTxt" placeholder="Paste your 40 upcoming tickets here...
05 09 12 28 39 51
..."></textarea>
    <div class="row">
      <label>Total parsed: <span id="upCount">0</span></label>
      <label>Sum range: <span id="upSumRange">-</span></label>
      <label>Distinct pairs: <span id="upPairs">0</span></label>
    </div>
    <p class="note">This panel is evaluation-only and won‚Äôt bias generation. It‚Äôs compared against Winners / Non-Winners / Recent / Samples.</p>
  </div>

  <!-- CONTROLS -->
  <div class="card" style="margin-top:16px">
    <h3>Exclusion & Scoring Controls</h3>
    <div class="grid" style="grid-template-columns:repeat(8,1fr);gap:8px">
      <div><label>Œª (non-winner penalty)</label><input id="lambda" type="number" step="0.05" value="0.7"></div>
      <div><label>Œ∫ (sum penalty)</label><input id="kappa" type="number" step="0.05" value="0.7"></div>
      <div><label>œÅ (recent weight)</label><input id="rho" type="number" step="0.1" value="0.6"></div>
      <div><label>œÉ (sample weight)</label><input id="sigma" type="number" step="0.1" value="0.4"></div>
      <div>
        <label>Exclusion mode</label>
        <select id="excludeMode"><option value="hard">Hard: drop ‚â§ 0</option><option value="soft">Soft: drop bottom %</option></select>
      </div>
      <div><label>Soft % (numbers)</label><input id="softPctNum" type="number" step="1" value="15"></div>
      <div><label>Soft % (sums)</label><input id="softPctSum" type="number" step="1" value="25"></div>
      <div><label>Samples / ticket</label><input id="attempts" type="number" value="450"></div>
    </div>

    <h4 style="margin-top:12px">Scoring Weights</h4>
    <div class="grid" style="grid-template-columns:repeat(4,1fr);gap:8px">
      <div><label>Œ≤ pair</label><input id="beta" type="number" step="0.05" value="0.15"></div>
      <div><label>Œ≥ balance</label><input id="gamma" type="number" step="0.05" value="0.10"></div>
      <div><label>Œ¥ sum-band</label><input id="delta" type="number" step="0.05" value="0.25"></div>
      <div><label>Tickets</label><input id="kTickets" type="number" value="10"></div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="analyzeBtn">Analyze</button>
      <button id="genBtn" class="secondary">Generate Tickets</button>
      <span class="note">Analyze shows hot/cold, exclusions, top pairs, balance, and cross-panel frequencies. Generate makes tickets from allowed pools.</span>
    </div>
  </div>

  <!-- NEW: SAMPLED CANDIDATES PANEL -->
  <div class="card" style="margin-top:16px">
    <div class="row" style="justify-content:space-between;align-items:baseline">
      <h3>Sampled Candidates (e.g., 1200)</h3>
      <span class="pill">driven by current weights</span>
    </div>
    <div class="grid" style="grid-template-columns:1fr auto auto;align-items:end">
      <div>
        <label>Sample count</label>
        <input id="sampCount" type="number" value="1200" />
      </div>
      <div>
        <button id="sampBtn">Generate Samples</button>
      </div>
      <div class="note">After sampling, œÉ blends these stats back into probabilities.</div>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Total sampled: <span id="sCount">0</span></label>
      <label>Sum range: <span id="sSumRange">-</span></label>
      <label>Distinct pairs: <span id="sPairs">0</span></label>
    </div>
  </div>

  <!-- ANALYTICS: Winners & Non-Winners -->
  <div class="grid" style="margin-top:16px">
    <div class="card">
      <h3>Winners ‚Äî Hot / Cold</h3>
      <div id="wHot" class="note"></div>
      <div id="wCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Winners ‚Äî Top Pairs</h3>
      <div id="wPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Winners ‚Äî Balance</h3>
      <div id="wBal" class="note"></div>
    </div>
    <div class="card">
      <h3>Non-Winners ‚Äî Hot / Cold</h3>
      <div id="nHot" class="note"></div>
      <div id="nCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Non-Winners ‚Äî Top Pairs</h3>
      <div id="nPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Non-Winners ‚Äî Balance</h3>
      <div id="nBal" class="note"></div>
    </div>
  </div>

  <!-- ANALYTICS ‚Äî RECENT & SAMPLES & PREVIOUS/UPCOMING GENERATED -->
  <div class="grid" style="margin-top:16px">
    <div class="card">
      <h3>Last 20 (Recent) ‚Äî Hot / Cold</h3>
      <div id="rHot" class="note"></div>
      <div id="rCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Last 20 (Recent) ‚Äî Top Pairs</h3>
      <div id="rPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Last 20 (Recent) ‚Äî Balance</h3>
      <div id="rBal" class="note"></div>
    </div>

    <div class="card">
      <h3>Samples ‚Äî Hot / Cold</h3>
      <div id="sHot" class="note"></div>
      <div id="sCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Samples ‚Äî Top Pairs</h3>
      <div id="sPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Samples ‚Äî Balance</h3>
      <div id="sBal" class="note"></div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px">
    <div class="card">
      <h3>Previous (Generated) ‚Äî Hot / Cold</h3>
      <div id="gHot" class="note"></div>
      <div id="gCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Previous (Generated) ‚Äî Top Pairs</h3>
      <div id="gPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Previous (Generated) ‚Äî Balance</h3>
      <div id="gBal" class="note"></div>
    </div>

    <div class="card">
      <h3>Upcoming (Generated) ‚Äî Hot / Cold</h3>
      <div id="uHot" class="note"></div>
      <div id="uCold" class="note" style="margin-top:6px"></div>
      <h3 style="margin-top:14px">Upcoming (Generated) ‚Äî Top Pairs</h3>
      <div id="uPairsTop" class="note"></div>
      <h3 style="margin-top:14px">Upcoming (Generated) ‚Äî Balance</h3>
      <div id="uBal" class="note"></div>
    </div>
  </div>
  <!-- EXCLUSIONS -->
  <div class="card" style="margin-top:16px">
    <h3>Excluded (Non-Possibility) ‚Äî Numbers & Sums</h3>
    <div class="row">
      <div id="excludedNums" style="flex:1"></div>
      <div id="excludedSums" style="flex:1"></div>
    </div>
  </div>

  <!-- CROSS-PANEL FREQUENCIES -->
  <div class="card" style="margin-top:16px">
    <h3>Cross-Panel Frequency (Winners, Non-Winners, Recent, Samples, Prev, Upcoming)</h3>
    <div id="crossMost" class="note" style="margin-bottom:8px"></div>
    <div class="row" style="overflow:auto">
      <table id="crossTable">
        <thead>
          <tr>
            <th>#</th><th>W</th><th>N</th><th>R</th><th>S</th><th>G(prev)</th><th>U(up)</th><th>Total</th>
          </tr>
        </thead>
        <tbody id="crossBody"></tbody>
      </table>
    </div>
    <p class="note">‚ÄúMost Repeated‚Äù across all panels (W/N/R/S/G/U) help surface likely regions. Use alongside exclusions and balance.</p>
  </div>

  <!-- OUTPUT TICKETS -->
  <div class="card" style="margin-top:16px">
    <h3>Suggested Tickets</h3>
    <div id="tickets"></div>
    <p class="note" style="margin-top:8px">Lotteries are random by design; this narrows to winner-like regions but can‚Äôt guarantee profit.</p>
  </div>

  <!-- METHOD -->
  <div class="card" style="margin-top:16px">
    <h3>Method (Equations)</h3>
    <p class="note">
      Per-number (with recency & samples): <code>w(n) ‚àù (c_W(n)+œÅ¬∑c_R(n)+œÉ¬∑c_S(n)+Œ±)/(C_W+œÅ¬∑C_R+œÉ¬∑C_S+Œ±N) ‚àí Œª¬∑(c_N(n)+Œ±)/(C_N+Œ±N)</code>, Œ±=1, N=54.<br/>
      Sums: <code>W_sum(S) ‚àù (H_W(S)+œÅ¬∑H_R(S)+œÉ¬∑H_S(S)) ‚àí Œ∫¬∑H_N(S)</code>. Hard excludes ‚â§0; soft excludes bottom p%.<br/>
      Pairs: mixed as <code>P = P_W + œÅ¬∑P_R + œÉ¬∑P_S</code> before normalization.<br/>
      Ticket score: <code>(1‚àíŒ≤‚àíŒ≥‚àíŒ¥)¬∑Œ£w(n) + Œ≤¬∑Pair + Œ≥¬∑Balance + Œ¥¬∑Sum</code>.<br/>
      Upcoming (U) set is evaluation-only; it does not feed back into generation.
    </p>
  </div>
</div>

<script>
(function(){
  const NMIN=1, NMAX=54, PICK=6;
  const $ = sel => document.querySelector(sel);

  // -------- parsing helpers --------
  function parseText(txt){
    const lines=(txt||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const draws=[];
    for(const ln of lines){
      const parts = ln.replace(/;/g,',').replace(/-/g,',').split(/[ ,\t]+/).filter(Boolean);
      const nums = [...new Set(parts.map(p=>parseInt(p,10)).filter(x=>Number.isInteger(x) && x>=NMIN && x<=NMAX))].sort((a,b)=>a-b);
      if(nums.length>=PICK) draws.push(nums.slice(0,PICK));
    }
    return draws;
  }
  function pairsOf(d){ const ps=[]; for(let i=0;i<d.length;i++){ for(let j=i+1;j<d.length;j++){ ps.push([d[i],d[j]].sort((a,b)=>a-b).join('-')); } } return ps; }
  function histogram(arr){ const m=new Map(); for(const x of arr){ m.set(x,(m.get(x)||0)+1); } return m; }
  function bottomPercentKeys(mapObj,pct){ const arr=[...mapObj.entries()].sort((a,b)=> a[1]-b[1] || a[0]-b[0]); const cut=Math.floor(arr.length*Math.max(0,Math.min(100,pct))/100); return new Set(arr.slice(0,cut).map(([k])=>k)); }
  function describeBalance(draws){
    const rows = draws.map(d=>{const sum=d.reduce((s,x)=>s+x,0); const odd=d.filter(x=>x%2===1).length; const low=d.filter(x=>x<=Math.floor((NMAX+NMIN)/2)).length; const spread=Math.max(...d)-Math.min(...d); return {sum,odd,low,spread};});
    const desc={};
    function stat(get){ const v=rows.map(get).sort((a,b)=>a-b); if(!v.length) return {mean:null,std:null,min:null,max:null,count:0}; const m=v.reduce((s,x)=>s+x,0)/v.length; const varc=v.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,v.length-1); return {mean:m,std:Math.sqrt(varc),min:v[0],max:v[v.length-1],count:v.length}; }
    desc.sum=stat(r=>r.sum); desc.odd=stat(r=>r.odd); desc.low=stat(r=>r.low); desc.spread=stat(r=>r.spread); desc._count=rows.length; desc._sumRange=rows.length? `${Math.min(...rows.map(r=>r.sum))}‚Äì${Math.max(...rows.map(r=>r.sum))}`:'-'; return desc;
  }
  function z(val,mu,sd){ if(!isFinite(sd)||sd<=0) return 0; return -Math.abs((val-mu)/sd); }

  // -------- elements --------
  const winTxt = $('#winTxt'), nonTxt = $('#nonTxt'), recTxt = $('#recTxt');
  const genTxt = $('#genTxt'); // previous generated (evaluation)
  const upTxt  = $('#upTxt');  // upcoming generated (evaluation)

  const genWinInput = $('#genWinInput');
  const genEvalSummary = $('#genEvalSummary');
  const genEvalDetails = $('#genEvalDetails');

  const winCount = $('#winCount'), nonCount = $('#nonCount'), recCount = $('#recCount');
  const genCount = $('#genCount'), upCount = $('#upCount');

  const winSumRange = $('#winSumRange'), nonSumRange = $('#nonSumRange'), recSumRange = $('#recSumRange');
  const genSumRange = $('#genSumRange'), upSumRange = $('#upSumRange');

  const winPairs = $('#winPairs'), nonPairs = $('#nonPairs'), recPairs = $('#recPairs');
  const genPairs = $('#genPairs'), upPairs = $('#upPairs');

  // analytics targets
  const wHot=$('#wHot'), wCold=$('#wCold'), wPairsTop=$('#wPairsTop'), wBal=$('#wBal');
  const nHot=$('#nHot'), nCold=$('#nCold'), nPairsTop=$('#nPairsTop'), nBal=$('#nBal');
  const rHot=$('#rHot'), rCold=$('#rCold'), rPairsTop=$('#rPairsTop'), rBal=$('#rBal');
  const gHot=$('#gHot'), gCold=$('#gCold'), gPairsTop=$('#gPairsTop'), gBal=$('#gBal');
  const uHot=$('#uHot'), uCold=$('#uCold'), uPairsTop=$('#uPairsTop'), uBal=$('#uBal');

  const sHot=$('#sHot'), sCold=$('#sCold'), sPairsTop=$('#sPairsTop'), sBal=$('#sBal');
  const sCount=$('#sCount'), sSumRange=$('#sSumRange'), sPairs=$('#sPairs');

  const excludedNumsDiv=$('#excludedNums'), excludedSumsDiv=$('#excludedSums');
  const ticketsDiv=$('#tickets');
  const crossBody=$('#crossBody'), crossMost=$('#crossMost');

  // sampled candidates (in-memory)
  let SAMPLES = [];

  function sumRange(draws){ if(!draws.length) return '-'; const s=draws.map(d=>d.reduce((a,b)=>a+b,0)); return `${Math.min(...s)}‚Äì${Math.max(...s)}`; }
  function distinctPairs(ds){ const s=new Set(); for(const d of ds) for(const pk of pairsOf(d)) s.add(pk); return s.size; }

  function refreshCounts(){
    const W = parseText(winTxt.value);
    const N = parseText(nonTxt.value);
    const R = parseText(recTxt.value);
    const G = parseText(genTxt.value);
    const U = parseText(upTxt.value);

    winCount.textContent = W.length;
    nonCount.textContent = N.length;
    recCount.textContent = R.length;
    genCount.textContent = G.length;
    upCount.textContent  = U.length;

    winSumRange.textContent = sumRange(W);
    nonSumRange.textContent = sumRange(N);
    recSumRange.textContent = sumRange(R);
    genSumRange.textContent = sumRange(G);
    upSumRange.textContent  = sumRange(U);

    winPairs.textContent = distinctPairs(W);
    nonPairs.textContent = distinctPairs(N);
    recPairs.textContent = distinctPairs(R);
    genPairs.textContent = distinctPairs(G);
    upPairs.textContent  = distinctPairs(U);
  }
  winTxt.addEventListener('input', refreshCounts);
  nonTxt.addEventListener('input', refreshCounts);
  recTxt.addEventListener('input', refreshCounts);
  genTxt.addEventListener('input', refreshCounts);
  upTxt.addEventListener('input', refreshCounts);

  // -------- core analysis (W,N,R,G=previous,U=upcoming,S=samples) --------
  function analyze(lambda=0.7,kappa=0.7,rho=0.6,sigma=0.4){
    const W=parseText(winTxt.value), N=parseText(nonTxt.value), R=parseText(recTxt.value),
          G=parseText(genTxt.value), U=parseText(upTxt.value), S=SAMPLES||[];

    // number freqs
    const wf=new Map(), nf=new Map(), rf=new Map(), gf=new Map(), uf=new Map(), sf=new Map();
    for(let n=NMIN;n<=NMAX;n++){ wf.set(n,0); nf.set(n,0); rf.set(n,0); gf.set(n,0); uf.set(n,0); sf.set(n,0); }
    for(const d of W) for(const x of d) wf.set(x, wf.get(x)+1);
    for(const d of N) for(const x of d) nf.set(x, nf.get(x)+1);
    for(const d of R) for(const x of d) rf.set(x, rf.get(x)+1);
    for(const d of G) for(const x of d) gf.set(x, gf.get(x)+1);
    for(const d of U) for(const x of d) uf.set(x, uf.get(x)+1);
    for(const d of S) for(const x of d) sf.set(x, sf.get(x)+1);

    const Cw=[...wf.values()].reduce((s,x)=>s+x,0);
    const Cn=[...nf.values()].reduce((s,x)=>s+x,0);
    const Cr=[...rf.values()].reduce((s,x)=>s+x,0);
    const Cs=[...sf.values()].reduce((s,x)=>s+x,0);

    const alpha=1, M=(NMAX-NMIN+1);
    const numScore=new Map();
    for(let n=NMIN;n<=NMAX;n++){
      const pW=((wf.get(n)||0) + rho*(rf.get(n)||0) + sigma*(sf.get(n)||0) + alpha) / ((Cw + rho*Cr + sigma*Cs) + alpha*M);
      const pN=((nf.get(n)||0) + alpha) / ((Cn) + alpha*M);
      numScore.set(n, pW - lambda*pN);
    }

    // pairs (W + œÅ¬∑R + œÉ¬∑S) ‚Äî note: G/U used only for separate evaluation
    const pairCountsW=new Map(), pairCountsR=new Map(), pairCountsS=new Map();
    for(const d of W) for(const pk of pairsOf(d)) pairCountsW.set(pk,(pairCountsW.get(pk)||0)+1);
    for(const d of R) for(const pk of pairsOf(d)) pairCountsR.set(pk,(pairCountsR.get(pk)||0)+1);
    for(const d of S) for(const pk of pairsOf(d)) pairCountsS.set(pk,(pairCountsS.get(pk)||0)+1);

    const pairCounts=new Map();
    for(const [k,v] of pairCountsW.entries()) pairCounts.set(k,(pairCounts.get(k)||0)+v);
    for(const [k,v] of pairCountsR.entries()) pairCounts.set(k,(pairCounts.get(k)||0)+rho*v);
    for(const [k,v] of pairCountsS.entries()) pairCounts.set(k,(pairCounts.get(k)||0)+sigma*v);
    const totalPairs=[...pairCounts.values()].reduce((s,x)=>s+x,0);

    // evaluation-only pairs for G and U
    const pairCountsG=new Map(), pairCountsU=new Map();
    for(const d of G) for(const pk of pairsOf(d)) pairCountsG.set(pk,(pairCountsG.get(pk)||0)+1);
    for(const d of U) for(const pk of pairsOf(d)) pairCountsU.set(pk,(pairCountsU.get(pk)||0)+1);

    // balances
    const wBal=describeBalance(W), nBal=describeBalance(N), rBal=describeBalance(R),
          sBal=describeBalance(S), gBal=describeBalance(G), uBal=describeBalance(U);

    // sums (W + œÅ¬∑R + œÉ¬∑S) vs Non-Winners, with gentle smoothing
    const sumsW=W.map(d=>d.reduce((s,x)=>s+x,0)),
          sumsN=N.map(d=>d.reduce((s,x)=>s+x,0)),
          sumsR=R.map(d=>d.reduce((s,x)=>s+x,0)),
          sumsS=S.map(d=>d.reduce((s,x)=>s+x,0)),
          sumsG=G.map(d=>d.reduce((s,x)=>s+x,0)),
          sumsU=U.map(d=>d.reduce((s,x)=>s+x,0));
    const hW=histogram(sumsW), hN=histogram(sumsN), hR=histogram(sumsR), hS=histogram(sumsS), hG=histogram(sumsG), hU=histogram(sumsU);

    const sumScore=new Map(); const domain=new Set([...hW.keys(),...hN.keys(),...hR.keys(),...hS.keys()]);
    const aSum = 0.5; // tiny Laplace for sums (smoothing tweak A)
    for(const Ssum of domain){
      const winLike=(hW.get(Ssum)||0) + rho*(hR.get(Ssum)||0) + sigma*(hS.get(Ssum)||0) + aSum;
      const nonLike=(hN.get(Ssum)||0) + aSum;
      sumScore.set(Ssum, winLike - kappa*nonLike);
    }

    return {W,N,R,G,U,S, wf,nf,rf,gf,uf,sf, numScore,
            pairCounts,totalPairs,pairCountsG,pairCountsU,pairCountsR:pairCountsR,pairCountsS:pairCountsS,
            wBal,nBal,rBal,sBal,gBal,uBal, hW,hN,hR,hS,hG,hU, sumScore};
  }

  // -------- exclusion helpers --------
  function bottomPercentKeys(mapObj,pct){ const arr=[...mapObj.entries()].sort((a,b)=> a[1]-b[1] || a[0]-b[0]); const cut=Math.floor(arr.length*Math.max(0,Math.min(100,pct))/100); return new Set(arr.slice(0,cut).map(([k])=>k)); }
  function excludeSets(A, mode, softPctNum, softPctSum){
    let excludedNums=new Set(); let excludedSums=new Set();
    if(mode==='hard'){
      for(const [n,sc] of A.numScore.entries()) if(sc<=0) excludedNums.add(n);
      for(const [S,sc] of A.sumScore.entries()) if(sc<=0) excludedSums.add(S);
    } else {
      excludedNums = bottomPercentKeys(A.numScore, softPctNum);
      excludedSums = bottomPercentKeys(A.sumScore, softPctSum);
    }
    return {excludedNums, excludedSums};
  }

  // -------- render helpers --------
  function renderHotCold(divHot, divCold, map){
    const arr=[...map.entries()].sort((a,b)=> b[1]-a[1] || a[0]-b[0]);
    divHot.innerHTML = arr.length? `<div class="pill">Top 12</div><div>${arr.slice(0,12).map(([n,c])=>`<span class="numchip">${String(n).padStart(2,'0')} ‚Ä¢ ${c}</span>`).join('')}</div>` : '<span class="note">No data</span>';
    const cold=[...map.entries()].sort((a,b)=> a[1]-b[1] || a[0]-b[0]).slice(0,12);
    divCold.innerHTML = arr.length? `<div class="pill">Bottom 12</div><div>${cold.map(([n,c])=>`<span class="numchip">${String(n).padStart(2,'0')} ‚Ä¢ ${c}</span>`).join('')}</div>` : '';
  }
  function renderPairs(div,map){
    const arr=[...map.entries()].sort((a,b)=> b[1]-a[1]).slice(0,25);
    div.innerHTML = arr.length? `<div class="pill">Top 25</div><div>${arr.map(([k,c])=>`<span class="numchip">${k.replace('-', '‚Äì')} ‚Ä¢ ${(+c).toFixed(2)}</span>`).join('')}</div>` : '<span class="note">No pairs</span>';
  }
  function renderBalance(div,b){
    if(!b||!b._count){div.innerHTML='<span class="note">No balance stats</span>';return;}
    const row=(name,o)=>`<tr><th>${name}</th><td>${o.mean?.toFixed(2)??'-'}</td><td>${o.std?.toFixed(2)??'-'}</td><td>${o.min??'-'}</td><td>${o.max??'-'}</td></tr>`;
    div.innerHTML=`<div class="pill">n=${b._count}, sum ${b._sumRange}</div>
      <table><thead><tr><th>Metric</th><th>Mean</th><th>Std</th><th>Min</th><th>Max</th></tr></thead>
      <tbody>${row('Sum',b.sum)}${row('Odd count',b.odd)}${row('Low (‚â§27)',b.low)}${row('Spread',b.spread)}</tbody></table>`;
  }

  // -------- sampling & UI actions --------
  function weightedPool(A, excludedNums){
    const weights=new Map(); let sum=0;
    for(let n=NMIN;n<=NMAX;n++){
      if(excludedNums.has(n)) continue;
      const sc=Math.max(0, A.numScore.get(n)||0);
      if(sc>0){ weights.set(n,sc); sum+=sc; }
    }
    if(weights.size===0){
      for(let n=NMIN;n<=NMAX;n++) if(!excludedNums.has(n)) weights.set(n,1);
      sum=[...weights.values()].reduce((a,b)=>a+b,0);
    }
    for(const [n,w] of [...weights.entries()]) weights.set(n,w/sum);
    return weights;
  }
  function sampleWithoutReplacement(weightsMap,k){
    const entries=[...weightsMap.entries()].filter(([n,w])=>w>0);
    if(entries.length<k){ const pool=[...weightsMap.keys()]; pool.sort(()=>Math.random()-0.5); return pool.slice(0,k).sort((a,b)=>a-b);}
    let nums=[], used=new Set();
    for(let i=0;i<k;i++){
      let s=0; for(const [n,w] of entries) if(!used.has(n)) s+=w;
      let r=Math.random()*s, acc=0, pick=null;
      for(const [n,w] of entries){ if(used.has(n)) continue; acc+=w; if(r<=acc){ pick=n; break; } }
      if(pick==null){ const rest=entries.map(e=>e[0]).filter(n=>!used.has(n)); pick=rest[Math.floor(Math.random()*rest.length)]; }
      used.add(pick); nums.push(pick);
    }
    return nums.sort((a,b)=>a-b);
  }

  function generateSamplesUI(){
    const lambda=parseFloat($('#lambda').value||'0.7');
    const kappa=parseFloat($('#kappa').value||'0.7');
    const rho=parseFloat($('#rho').value||'0.6');
    const sigma=parseFloat($('#sigma').value||'0.4');
    const mode=$('#excludeMode').value;
    const softPctNum=parseFloat($('#softPctNum').value||'15');
    const softPctSum=parseFloat($('#softPctSum').value||'25');
    const K=parseInt($('#sampCount').value||'1200',10);

    const A0=analyze(lambda,kappa,rho,0);
    const {excludedNums}=excludeSets(A0,mode,softPctNum,softPctSum);
    const weights=weightedPool(A0, excludedNums);

    // allowed sums (with hard-mode guard tweak B)
    const allowedSums=new Set();
    if(A0.sumScore.size){
      if(mode==='hard'){ for(const [S,sc] of A0.sumScore.entries()) if(sc>0) allowedSums.add(S); }
      else { const excl = bottomPercentKeys(A0.sumScore, softPctSum); for(const [S] of A0.sumScore.entries()) if(!excl.has(S)) allowedSums.add(S); }
      if(mode==='hard' && allowedSums.size===0){ for(const [S] of A0.sumScore.entries()) allowedSums.add(S); } // guard
    }

    const S=[];
    for(let i=0;i<K;i++){
      let cand = sampleWithoutReplacement(weights,PICK);
      if(allowedSums.size){
        const sumV=cand.reduce((a,b)=>a+b,0);
        if(!allowedSums.has(sumV)){
          for(let t=0;t<2;t++){
            const alt = sampleWithoutReplacement(weights,PICK);
            const sAlt=alt.reduce((a,b)=>a+b,0);
            if(allowedSums.has(sAlt)){ cand=alt; break; }
          }
        }
      }
      S.push(cand);
    }

    SAMPLES = S;
    sCount.textContent = S.length;
    sSumRange.textContent = sumRange(S);
    sPairs.textContent = distinctPairs(S);

    const sf=new Map(); for(let n=NMIN;n<=NMAX;n++) sf.set(n,0);
    for(const d of S) for(const x of d) sf.set(x,(sf.get(x)||0)+1);
    renderHotCold(sHot,sCold,sf);
    const sPairsMap=new Map(); for(const d of S) for(const pk of pairsOf(d)) sPairsMap.set(pk,(sPairsMap.get(pk)||0)+1);
    renderPairs(sPairsTop,sPairsMap);
    renderBalance(sBal, describeBalance(S));

    analyzeUI();
  }

  function analyzeUI(){
    const lambda=parseFloat($('#lambda').value||'0.7');
    const kappa=parseFloat($('#kappa').value||'0.7');
    const rho=parseFloat($('#rho').value||'0.6');
    const sigma=parseFloat($('#sigma').value||'0.4');
    const mode=$('#excludeMode').value;
    const softPctNum=parseFloat($('#softPctNum').value||'15');
    const softPctSum=parseFloat($('#softPctSum').value||'25');

    const A=analyze(lambda,kappa,rho,sigma);

    // Winners & Non-Winners
    renderHotCold(wHot,wCold,A.wf);  renderPairs(wPairsTop,A.pairCounts); renderBalance(wBal,A.wBal);
    const nfPairs=(()=>{const np=new Map(); for(const d of A.N) for(const pk of pairsOf(d)) np.set(pk,(np.get(pk)||0)+1); return np;})();
    renderHotCold(nHot,nCold,A.nf);  renderPairs(nPairsTop,nfPairs);       renderBalance(nBal,A.nBal);

    // Recent
    renderHotCold(rHot,rCold,A.rf);  renderPairs(rPairsTop,A.pairCountsR); renderBalance(rBal,A.rBal);

    // Samples
    const sf=new Map(); for(let n=NMIN;n<=NMAX;n++) sf.set(n,0);
    for(const d of A.S) for(const x of d) sf.set(x,(sf.get(x)||0)+1);
    renderHotCold(sHot,sCold,sf);
    const sPairsMap=A.pairCountsS||new Map(); renderPairs(sPairsTop,sPairsMap);
    renderBalance(sBal,A.sBal);

    // Previous Generated (evaluation)
    renderHotCold(gHot,gCold,A.gf);  renderPairs(gPairsTop,A.pairCountsG); renderBalance(gBal,A.gBal);

    // Upcoming Generated (evaluation)
    renderHotCold(uHot,uCold,A.uf);  renderPairs(uPairsTop,A.pairCountsU); renderBalance(uBal,A.uBal);

    // exclusions
    const {excludedNums,excludedSums}=excludeSets(A,mode,softPctNum,softPctSum);
    excludedNumsDiv.innerHTML = `<div class="pill">Excluded Numbers (${excludedNums.size})</div><div>${[...excludedNums].sort((a,b)=>a-b).map(n=>`<span class="numchip">${String(n).padStart(2,'0')}</span>`).join('')||'<span class="note">none</span>'}</div>`;
    const sumsSorted=[...excludedSums].sort((a,b)=>a-b);
    excludedSumsDiv.innerHTML = `<div class="pill">Excluded Sums (${excludedSums.size})</div><div>${sumsSorted.length? sumsSorted.map(S=>`<span class="numchip">${S}</span>`).join(''):'<span class="note">none</span>'}</div>`;

    // cross-panel frequencies (W/N/R/S/G/U)
    const rows=[];
    for(let n=NMIN;n<=NMAX;n++){
      const w=A.wf.get(n)||0, no=A.nf.get(n)||0, r=A.rf.get(n)||0, s=sf.get(n)||0, g=A.gf.get(n)||0, u=A.uf.get(n)||0;
      rows.push({n,w,no,r,s,g,u,total:w+no+r+s+g+u});
    }
    rows.sort((a,b)=> b.total-a.total || a.n-b.n);

    const topList = rows.slice(0,20).map(x=>`<span class="numchip">${String(x.n).padStart(2,'0')} ‚Ä¢ ${x.total}</span>`).join('');
    crossMost.innerHTML = topList ? `<div class="pill">Most Repeated (Top 20 totals)</div><div>${topList}</div>` : '<span class="note">No data</span>';

    crossBody.innerHTML = rows.map(x=>`<tr>
      <td>${String(x.n).padStart(2,'0')}</td>
      <td>${x.w}</td><td>${x.no}</td><td>${x.r}</td><td>${x.s}</td><td>${x.g}</td><td>${x.u}</td><td><strong>${x.total}</strong></td>
    </tr>`).join('');
  }

  function generateTicketsUI(){
    const lambda=parseFloat($('#lambda').value||'0.7');
    const kappa=parseFloat($('#kappa').value||'0.7');
    const rho=parseFloat($('#rho').value||'0.6');
    const sigma=parseFloat($('#sigma').value||'0.4');
    const mode=$('#excludeMode').value;
    const softPctNum=parseFloat($('#softPctNum').value||'15');
    const softPctSum=parseFloat($('#softPctSum').value||'25');

    const beta=parseFloat($('#beta').value||'0.15');
    const gamma=parseFloat($('#gamma').value||'0.10');
    const delta=parseFloat($('#delta').value||'0.25');

    const attempts=parseInt($('#attempts').value||'450',10);
    const kTickets=parseInt($('#kTickets').value||'10',10);

    const A=analyze(lambda,kappa,rho,sigma);
    const {excludedNums,excludedSums}=excludeSets(A,mode,softPctNum,softPctSum);

    const allowed=[]; for(let n=NMIN;n<=NMAX;n++){ if(!excludedNums.has(n)) allowed.push(n); }
    if(allowed.length<PICK){ ticketsDiv.innerHTML='<span class="note">Too many numbers excluded ‚Äî relax settings.</span>'; return; }

    const weights=new Map(); let sum=0;
    for(const n of allowed){ const sc=Math.max(0, A.numScore.get(n)||0); weights.set(n, sc); sum+=sc; }
    if(sum<=0){ const u=1/allowed.length; for(const n of allowed) weights.set(n,u); }
    else{ for(const n of allowed) weights.set(n, (weights.get(n)/sum)); }

    // allowed sums (with hard-mode guard tweak B)
    const allowedSums=new Set();
    if(A.sumScore.size){
      if(mode==='hard'){ for(const [S,sc] of A.sumScore.entries()) if(sc>0) allowedSums.add(S); }
      else { const excl = bottomPercentKeys(A.sumScore, softPctSum); for(const [S] of A.sumScore.entries()) if(!excl.has(S)) allowedSums.add(S); }
      if(mode==='hard' && allowedSums.size===0){ for(const [S] of A.sumScore.entries()) allowedSums.add(S); } // guard
    }

    function sampleWithoutReplacementTicket(){ return sampleWithoutReplacement(weights,PICK); }

    function scoreTicket(nums){
      let base=0; for(const n of nums) base += Math.max(0, A.numScore.get(n)||0);

      let pairS=0;
      for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
          const pk=[nums[i],nums[j]].sort((a,b)=>a-b).join('-');
          const c=A.pairCounts.get(pk)||0;
          if(A.totalPairs>0) pairS += c/A.totalPairs;
        }
      }

      const sumV = nums.reduce((a,b)=>a+b,0);
      const b=A.wBal||{};
      const balS=(z(sumV,b.sum?.mean,b.sum?.std)
                + z(nums.filter(x=>x%2===1).length,b.odd?.mean,b.odd?.std)
                + z(nums.filter(x=>x<=Math.floor((NMAX+NMIN)/2)).length,b.low?.mean,b.low?.std)
                + z(Math.max(...nums)-Math.min(...nums),b.spread?.mean,b.spread?.std))/4;

      let sumS=0;
      if(A.sumScore.size){
        if(A.sumScore.has(sumV) && (!allowedSums.size || allowedSums.has(sumV))) {
          sumS=Math.max(0,A.sumScore.get(sumV));
        } else {
          let num=0,den=0;
          for(const [S,w] of A.sumScore.entries()){
            if(allowedSums.size && !allowedSums.has(S)) continue;
            const k=1/(1+Math.abs(S-sumV));
            num+=k*Math.max(0,w);
            den+=k;
          }
          sumS=den>0? num/den:0;
        }
      }

      const baseW=Math.max(0,1-beta-gamma-delta);
      return baseW*base + beta*pairS + gamma*balS + delta*sumS;
    }

    const out=[]; const seen=new Set();
    for(let t=0;t<kTickets;t++){
      let best=null, bestScore=-1e9; let tries=attempts;
      while(tries--){
        const cand=sampleWithoutReplacementTicket();
        const sc=scoreTicket(cand);
        const key=cand.join('-');
        if(sc>bestScore && !seen.has(key)){ best=cand; bestScore=sc; }
      }
      if(!best){
        const pool=[...allowed]; pool.sort(()=>Math.random()-0.5);
        best=pool.slice(0,PICK).sort((a,b)=>a-b);
        bestScore=scoreTicket(best);
      }
      seen.add(best.join('-'));
      out.push({nums:best, score:bestScore});
    }

    ticketsDiv.innerHTML = out.map((t,i)=>`<div class="row" style="justify-content:space-between;border-bottom:1px solid var(--grid);padding:6px 0">
      <div><span class="pill">Ticket ${i+1}</span></div>
      <div class="ticket">${t.nums.map(n=>`<span class="numchip">${String(n).padStart(2,'0')}</span>`).join('')}</div>
      <div class="note">score ${t.score.toFixed(4)}</div>
    </div>`).join('');
  }

  // -------- NEW: evaluate previous generated tickets vs drawn 6 numbers --------
  function evaluatePrevTickets(){
    const tickets = parseText(genTxt.value);
    const winDraws = parseText(genWinInput.value);

    if(!tickets.length){
      genEvalSummary.textContent = 'No tickets to evaluate. Paste one or more tickets in the textarea above.';
      genEvalDetails.textContent = '';
      return;
    }
    if(!winDraws.length){
      genEvalSummary.textContent = 'No drawn numbers. Paste the 6 winning numbers in the field above.';
      genEvalDetails.textContent = '';
      return;
    }

    const win = winDraws[0];
    if(win.length < PICK){
      genEvalSummary.textContent = 'The drawn numbers field must contain at least 6 valid numbers between 1 and 54.';
      genEvalDetails.textContent = '';
      return;
    }

    const winSet = new Set(win);
    const results = [];
    let c3=0,c4=0,c5=0,c6=0;

    tickets.forEach((t,idx)=>{
      const hits = t.filter(x=>winSet.has(x));
      const c = hits.length;
      if(c>=3){
        results.push({idx:idx+1, ticket:t, hits, c});
        if(c===3)c3++; else if(c===4)c4++; else if(c===5)c5++; else if(c>=6)c6++;
      }
    });

    genEvalSummary.textContent =
      `Tickets evaluated: ${tickets.length}. Tickets with ‚â•3 hits: ${results.length}. ` +
      `(3 hits: ${c3}, 4 hits: ${c4}, 5 hits: ${c5}, 6 hits: ${c6})`;

    if(!results.length){
      genEvalDetails.textContent = 'No tickets with 3 or more matching numbers for this draw.';
      return;
    }

    const maxShow = 100;
    const lines = results.slice(0,maxShow).map(r=>{
      const tStr = r.ticket.map(n=>String(n).padStart(2,'0')).join(' ');
      const hStr = r.hits.map(n=>String(n).padStart(2,'0')).join(' ');
      return `Ticket #${r.idx}: [${tStr}] ‚Äî hits ${r.c}: ${hStr}`;
    });
    let extra = '';
    if(results.length > maxShow){
      extra = `<br>‚Ä¶ plus ${results.length-maxShow} more tickets with ‚â•3 hits.`;
    }
    genEvalDetails.innerHTML = lines.join('<br>') + extra;
  }

  // wire buttons
  document.getElementById('analyzeBtn').addEventListener('click', analyzeUI);
  document.getElementById('genBtn').addEventListener('click', generateTicketsUI);
  document.getElementById('sampBtn').addEventListener('click', generateSamplesUI);
  document.getElementById('genEvalBtn').addEventListener('click', evaluatePrevTickets);

  // initial counters
  function init(){ refreshCounts(); }
  init();
})();
</script>
</body>
</html>
