<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Engine + 4D Backup Navigation</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#eaf0ff;
    --muted:#9bb7e3;
    --accent:#8fb4ff;
    --good:#7bffb1;
    --bad:#ff8c8c;
    --warn:#ffd37a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:100%;
    margin:0 auto;
    padding:12px;
  }
  .layout{
    display:grid;
    grid-template-columns:380px 1fr;
    gap:14px;
  }
  @media(max-width:1200px){
    .layout{grid-template-columns:1fr;}
  }
  .panel{
    background:var(--panel);
    border:1px solid #22305c;
    border-radius:14px;
    padding:12px;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
  }
  .panel h2{
    margin:0 0 8px;
    font-size:1rem;
    color:var(--muted);
    letter-spacing:.03em;
  }
  label{
    display:block;
    font-size:.8rem;
    margin-top:6px;
  }
  .miniVal{
    font-size:.75rem;
    color:var(--warn);
    margin-left:6px;
  }
  .btn{
    background:#182364;
    border:1px solid #2a3a7c;
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    margin-right:4px;
    color:var(--ink);
  }
  .btn:hover{filter:brightness(1.1)}
  .go-light{
    margin-top:6px;
    padding:10px;
    border-radius:14px;
    text-align:center;
    font-size:.95rem;
    font-weight:600;
  }
  .go-light.go{
    background:rgba(123,255,177,.12);
    border:1px solid rgba(123,255,177,.6);
    color:var(--good);
    box-shadow:0 0 12px rgba(123,255,177,.35);
  }
  .go-light.nogo{
    background:rgba(255,140,140,.12);
    border:1px solid rgba(255,140,140,.55);
    color:var(--bad);
    box-shadow:0 0 12px rgba(255,140,140,.35);
  }
  .statbox{
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
    margin-top:6px;
  }
  .stat{
    background:#0e1536;
    padding:6px;
    border-radius:10px;
    font-size:.8rem;
  }
  .stat .big{
    font-size:22px;
    font-weight:600;
  }
  .gauge{
    width:100%;
    height:7px;
    background:#0e1536;
    border-radius:10px;
    border:1px solid #2b3765;
    overflow:hidden;
  }
  .gauge span{
    display:block;
    height:100%;
    width:0%;
    background:linear-gradient(90deg,#6bd1ff,#9bb4ff);
  }
  canvas{
    width:100%;
    height:900px;
    display:block;
    background:radial-gradient(1400px 900px at 50% 50%, #0f1740 0%, #0b1020 60%);
    border-radius:14px;
    border:1px solid #22305c;
  }
  textarea{
    resize:vertical;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="layout">
    <!-- =============== LEFT: NAVIGATION PANEL =============== -->
    <div class="panel" id="navPanel">
      <h2>4D Backup Navigation â€” Earth â†’ Target Planet</h2>
      <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
        Adjust mission time, warp energy, and 4D phase offset to validate a GO / NO-GO warp corridor
        from Earth to your selected planet. All three channels (distance, energy, phase) must pass for GO.
      </p>

      <label>Target Planet</label>
      <select id="targetPlanet">
        <option value="Mercury">Mercury</option>
        <option value="Venus">Venus</option>
        <option value="Earth">Earth</option>
        <option value="Mars" selected>Mars</option>
        <option value="Jupiter">Jupiter</option>
        <option value="Saturn">Saturn</option>
        <option value="Uranus">Uranus</option>
        <option value="Neptune">Neptune</option>
        <option value="Pluto">Pluto</option>
      </select>

      <!-- Planet presets -->
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 4px;">
        <button type="button" class="btn btnPreset" data-preset="innerTour">Inner Tour (Venus)</button>
        <button type="button" class="btn btnPreset" data-preset="marsFast">Mars Window</button>
        <button type="button" class="btn btnPreset" data-preset="jupiterScout">Jupiter Scout</button>
        <button type="button" class="btn btnPreset" data-preset="saturnRing">Saturn Rings</button>
      </div>

      <label>
        Mission Epoch t (days from reference)
        <span id="navTVal" class="miniVal"></span>
      </label>
      <input id="navT" type="range" min="0" max="1200" value="200"/>

      <label>
        Phase Weight kÏ‡ (4D distance)
        <span id="navKchiVal" class="miniVal"></span>
      </label>
      <input id="navKchi" type="range" min="0" max="4" value="1.5" step="0.1"/>

      <label>
        Warp Energy Budget
        <span id="navEwarpVal" class="miniVal"></span>
      </label>
      <input id="navEwarp" type="range" min="0" max="10" value="2" step="0.01"/>

      <div style="display:flex;gap:10px;margin-top:6px;">
        <div>
          <label>
            Distance Tolerance %
            <span id="navTolDistVal" class="miniVal"></span>
          </label>
          <input id="navTolDist" type="number" value="2" min="0.1" step="0.1"/>
        </div>
        <div>
          <label>
            Energy Tolerance %
            <span id="navTolEVal" class="miniVal"></span>
          </label>
          <input id="navTolE" type="number" value="5" min="0.1" step="0.1"/>
        </div>
        <div>
          <label>
            Phase Tolerance (rad)
            <span id="navTolPhaseVal" class="miniVal"></span>
          </label>
          <input id="navTolPhase" type="number" value="0.4" min="0.05" step="0.05"/>
        </div>
      </div>

      <button id="analyzeBtn" class="btn" style="width:100%;margin-top:10px;">Analyze Trip</button>

      <!-- GO/NO-GO box -->
      <div id="goText" class="go-light nogo" style="margin-top:10px;">
        NO-GO â€” Parameters not validated
      </div>
      <p style="font-size:.75rem;color:var(--muted);margin-top:4px;">
        GO requires: (1) 3D vs 4D distance match within tolerance, (2) warp energy not underpowered,
        (3) phase gap |Î”Ï‡| below the configured limit.
      </p>

      <hr style="margin:14px 0;border:none;border-top:1px solid #253056;">

      <!-- === Output metrics === -->
      <div id="metrics" style="font-size:.85rem;line-height:1.4;">
        Earth position (AU): ( <span id="mEx">0</span>, <span id="mEy">0</span>, <span id="mEz">0</span> )<br>
        Target position (AU): ( <span id="mTx">0</span>, <span id="mTy">0</span>, <span id="mTz">0</span> )<br>
        Ï‡-phase: Ï‡âŠ•=<span id="mEchi">0</span>, Ï‡t=<span id="mTchi">0</span><br><br>

        3D distance: <span id="mD3">0</span> AU<br>
        4D distance: <span id="mD4">0</span> AU<br>
        Phase gap |Î”Ï‡|: <span id="mPgap">0</span><br>
        Expected Energy: <span id="mEexp">0</span><br>
        Warp Energy: <span id="mEwarpEcho">0</span><br>
        Estimated Warp Travel Time: <span id="mTau">0</span><br>
      </div>

      <h3 style="font-size:.8rem;margin:10px 0 4px;color:var(--muted);">
        Trip Configuration (copy/paste to replay later)
      </h3>
      <textarea id="configOutput" rows="8" readonly
        style="width:100%;font-size:.75rem;background:#0b1128;color:var(--ink);
               border-radius:10px;border:1px solid #26325a;padding:6px;"></textarea>
    </div>

    <!-- =============== RIGHT: WARP ENGINE PANEL =============== -->
    <div class="panel" id="enginePanel">
      <h2>Warp Engine Control</h2>
      <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
        Visual warp core demo tied to the navigation solution. When status is GO, you can launch a
        Warp Trip and watch the engine ramp up while the map traces the Earth â†’ target corridor.
      </p>

      <label>Warp Factor</label>
      <input id="warpRange" type="range" min="1" max="10" value="3"/>

      <div style="display:flex;gap:6px;margin-top:6px;">
        <button id="enginePlay" class="btn">Play</button>
        <button id="enginePause" class="btn">Pause</button>
        <button id="engineReset" class="btn">Reset</button>
        <label style="margin-left:auto;display:flex;align-items:center;gap:6px;">
          <input id="engineLabels" type="checkbox" checked/> Labels
        </label>
      </div>

      <div class="statbox" style="margin-top:10px;">
        <div class="stat"><div id="engSpeed" class="big">x1.0</div><div>Speed</div></div>
        <div class="stat"><div id="engField" class="big">1.2 Ã—D</div><div>Field Radius</div></div>
        <div class="stat"><div id="engTemp" class="big">Warm</div><div>Heat</div></div>
        <div class="stat"><div id="engClock" class="big">1.00Ã—</div><div>Clock</div></div>
      </div>

      <!-- GO/NO-GO mirrored from nav -->
      <div id="goBox" class="go-light nogo">NO-GO â€” Run Analyze Panel</div>

      <button id="warpTripBtn" class="btn" style="margin-top:8px;width:100%;">ðŸš€ Warp Trip</button>
      <p style="font-size:.75rem;color:var(--muted);margin-top:4px;">
        Warp Trip will only activate when status is GO from the 4D Backup Navigation panel.
      </p>
    </div>
  </div> <!-- end of left+right layout -->

  <!-- =============== ORBIT MAP PANEL (BOTTOM) =============== -->
  <div class="panel" style="margin-top:12px;">
    <h2>Solar Map â€” Earth + Target Only (4D Projection)</h2>
    <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
      Top-down heliocentric slice. Earth and the target planet are shown with their orbits;
      when you launch a Warp Trip, the travel line and ship marker animate along the corridor.
    </p>
    <div id="mapHolder" style="position:relative;width:100%;padding-top:54%;background:#070b18;border-radius:14px;border:1px solid #253056;overflow:hidden;">
      <canvas id="mapCanvas" width="1800" height="900" style="position:absolute;left:0;top:0;"></canvas>
    </div>
  </div>
</div> <!-- end wrap -->
<script>
/* --- Planet orbital database --- */
const PLANETS = {
  Mercury:{a:0.387, T:87.97},
  Venus:{a:0.723, T:224.70},
  Earth:{a:1.000, T:365.25},
  Mars:{a:1.524, T:686.98},
  Jupiter:{a:5.203, T:4332.59},
  Saturn:{a:9.537, T:10759.22},
  Uranus:{a:19.191, T:30688.5},
  Neptune:{a:30.068, T:60182.0},
  Pluto:{a:39.482, T:90560.0}
};

/* Simple GO-friendly presets (tDays=0 => phases aligned) */
const PRESETS = {
  innerTour: {
    label:'Inner Tour (Venus)',
    target:'Venus',
    tDays:0,
    kChi:1.2,
    Ewarp:2.2,
    tolD:2,
    tolE:10,
    tolP:0.40
  },
  marsFast: {
    label:'Mars Window',
    target:'Mars',
    tDays:0,
    kChi:1.5,
    Ewarp:1.4,
    tolD:2,
    tolE:5,
    tolP:0.40
  },
  jupiterScout: {
    label:'Jupiter Scout',
    target:'Jupiter',
    tDays:0,
    kChi:1.4,
    Ewarp:9.0,
    tolD:5,
    tolE:20,
    tolP:0.50
  },
  saturnRing: {
    label:'Saturn Rings',
    target:'Saturn',
    tDays:0,
    kChi:1.4,
    Ewarp:10.0,
    tolD:6,
    tolE:60,
    tolP:0.60
  }
};

function wrapPhase(a){
  const t=2*Math.PI;
  a=a%t;
  if(a>Math.PI)a-=t;
  if(a<=-Math.PI)a+=t;
  return a;
}

function getPos(planet, tDays){
  const P=PLANETS[planet];
  const ang=2*Math.PI*(tDays/P.T);
  return {
    x:P.a * Math.cos(ang),
    y:P.a * Math.sin(ang),
    z:0,
    chi:wrapPhase(ang)
  };
}

/* --- Navigation state --- */
let lastAnalysis = {go:false};

/* ---------- NAVIGATION LOGIC & GO/NO-GO ---------- */

const navTargetEl     = document.getElementById('targetPlanet');
const navTEl          = document.getElementById('navT');
const navKchiEl       = document.getElementById('navKchi');
const navEwarpEl      = document.getElementById('navEwarp');
const navTolDistEl    = document.getElementById('navTolDist');
const navTolEEl       = document.getElementById('navTolE');
const navTolPhaseEl   = document.getElementById('navTolPhase');
const analyzeBtn      = document.getElementById('analyzeBtn');
const goText          = document.getElementById('goText');
const goBox           = document.getElementById('goBox'); // mirrored in engine panel
const configOutputEl  = document.getElementById('configOutput');

// live readouts for sliders / tolerances
const navTVal         = document.getElementById('navTVal');
const navKchiVal      = document.getElementById('navKchiVal');
const navEwarpVal     = document.getElementById('navEwarpVal');
const navTolDistVal   = document.getElementById('navTolDistVal');
const navTolEVal      = document.getElementById('navTolEVal');
const navTolPhaseVal  = document.getElementById('navTolPhaseVal');

// Metric spans
const mEx   = document.getElementById('mEx');
const mEy   = document.getElementById('mEy');
const mEz   = document.getElementById('mEz');
const mTx   = document.getElementById('mTx');
const mTy   = document.getElementById('mTy');
const mTz   = document.getElementById('mTz');
const mEchi = document.getElementById('mEchi');
const mTchi = document.getElementById('mTchi');
const mD3   = document.getElementById('mD3');
const mD4   = document.getElementById('mD4');
const mPgap = document.getElementById('mPgap');
const mEexp = document.getElementById('mEexp');
const mEwarpEcho = document.getElementById('mEwarpEcho');
const mTau  = document.getElementById('mTau');

function clamp(v,a,b){return v<a?a:(v>b?b:v);}
function fmt(x,d){return x.toFixed(d);}

function updateGoStatus(){
  const go = lastAnalysis.go;
  const msg = go
    ? 'GO â€” Warp corridor validated for Earth â†’ ' + lastAnalysis.target
    : 'NO-GO â€” Verification conditions not all satisfied';

  goText.classList.remove('go','nogo');
  goBox.classList.remove('go','nogo');
  if(go){
    goText.classList.add('go');
    goBox.classList.add('go');
  }else{
    goText.classList.add('nogo');
    goBox.classList.add('nogo');
  }
  goText.textContent = msg;
  goBox.textContent  = msg;
}

function recomputeNav(){
  const target = navTargetEl.value;
  const tDays  = parseFloat(navTEl.value);
  const kChi   = parseFloat(navKchiEl.value);
  const Ewarp  = parseFloat(navEwarpEl.value);
  const tolD   = Math.max(0.01, parseFloat(navTolDistEl.value));
  const tolE   = Math.max(0.01, parseFloat(navTolEEl.value));
  const tolP   = Math.max(0.01, parseFloat(navTolPhaseEl.value));

  // live readouts
  navTVal.textContent        = tDays.toFixed(0) + ' d';
  navKchiVal.textContent     = kChi.toFixed(2);
  navEwarpVal.textContent    = Ewarp.toFixed(2);
  navTolDistVal.textContent  = tolD.toFixed(1) + '%';
  navTolEVal.textContent     = tolE.toFixed(1) + '%';
  navTolPhaseVal.textContent = tolP.toFixed(2) + ' rad';

  const Epos = getPos('Earth', tDays);
  const Tpos = getPos(target, tDays);

  const dx = Tpos.x - Epos.x;
  const dy = Tpos.y - Epos.y;
  const dz = Tpos.z - Epos.z;
  const d3 = Math.sqrt(dx*dx+dy*dy+dz*dz);

  const dChi = wrapPhase(Tpos.chi - Epos.chi);
  const d4 = Math.sqrt(dx*dx+dy*dy+dz*dz + (kChi*dChi)*(kChi*dChi));

  // energy model: simple, user-facing
  const alpha = 2.0;
  const Eexp  = alpha * d3;
  const tauHours = (Ewarp>0 && d4>0) ? (d4*40/Ewarp) : 0; // demo travel time

  // Channel 1: distance consistency
  let distOK;
  if(d3>0){
    const rel = Math.abs(d4-d3)/d3*100;
    distOK = (rel <= tolD);
  }else{
    distOK = (Math.abs(d4) < 1e-5);
  }

  // Channel 2: energy â€” PASS if warp energy is not underpowered
  // Ewarp â‰¥ Eexp * (1 - tolE%)
  let energyOK;
  if(Eexp>0){
    energyOK = (Ewarp >= Eexp*(1 - tolE/100));
  }else{
    energyOK = (Ewarp <= 0.001);
  }

  // Channel 3: phase alignment
  const phaseOK = (Math.abs(dChi) <= tolP);

  const overall = distOK && energyOK && phaseOK;

  lastAnalysis = {
    go:overall,
    distOK,energyOK,phaseOK,
    d3,d4,Eexp,Ewarp,tauHours,
    tDays,kChi,target,
    Epos,Tpos,dChi
  };

  // update metrics
  mEx.textContent   = fmt(Epos.x,3);
  mEy.textContent   = fmt(Epos.y,3);
  mEz.textContent   = fmt(Epos.z,3);
  mTx.textContent   = fmt(Tpos.x,3);
  mTy.textContent   = fmt(Tpos.y,3);
  mTz.textContent   = fmt(Tpos.z,3);
  mEchi.textContent = fmt(Epos.chi,3);
  mTchi.textContent = fmt(Tpos.chi,3);
  mD3.textContent   = fmt(d3,3);
  mD4.textContent   = fmt(d4,3);
  mPgap.textContent = fmt(Math.abs(dChi),3);
  mEexp.textContent = fmt(Eexp,3);
  mEwarpEcho.textContent = fmt(Ewarp,3);
  mTau.textContent  = tauHours>0 ? (fmt(tauHours,2)+' h') : 'â€”';

  updateGoStatus();
}

function buildConfigText(){
  if(!lastAnalysis || !lastAnalysis.target) return '';
  const tDays  = lastAnalysis.tDays || 0;
  const kChi   = lastAnalysis.kChi || 0;
  const Ewarp  = lastAnalysis.Ewarp || 0;
  const tolD   = parseFloat(navTolDistEl.value) || 0;
  const tolE   = parseFloat(navTolEEl.value) || 0;
  const tolP   = parseFloat(navTolPhaseEl.value) || 0;

  return [
    'Trip Configuration â€” GO',
    'Target Planet: ' + lastAnalysis.target,
    'Mission Epoch t: ' + tDays.toFixed(0) + ' days',
    'Phase Weight kÏ‡: ' + kChi.toFixed(2),
    'Warp Energy Budget: ' + Ewarp.toFixed(2),
    'Distance Tolerance: ' + tolD.toFixed(1) + ' %',
    'Energy Tolerance: ' + tolE.toFixed(1) + ' %',
    'Phase Tolerance: ' + tolP.toFixed(2) + ' rad',
    '',
    '3D distance: ' + lastAnalysis.d3.toFixed(3) + ' AU',
    '4D distance: ' + lastAnalysis.d4.toFixed(3) + ' AU',
    'Phase gap |Î”Ï‡|: ' + Math.abs(lastAnalysis.dChi).toFixed(3),
    'Expected Energy: ' + lastAnalysis.Eexp.toFixed(3),
    'Warp Energy: ' + lastAnalysis.Ewarp.toFixed(3),
    'Estimated Warp Travel Time: ' + (lastAnalysis.tauHours>0 ? lastAnalysis.tauHours.toFixed(2)+' h' : 'â€”')
  ].join('\n');
}

// hook slider + inputs to recompute
[navTargetEl,navTEl,navKchiEl,navEwarpEl,
 navTolDistEl,navTolEEl,navTolPhaseEl].forEach(el=>{
  el.addEventListener('input', recomputeNav);
});

// Analyze Trip: recompute + print config if GO
analyzeBtn.addEventListener('click', ()=>{
  recomputeNav();
  if(lastAnalysis.go){
    configOutputEl.value = buildConfigText();
  }else{
    configOutputEl.value =
      'NO-GO â€” Adjust parameters until GO, then Analyze Trip again to record configuration.\n\n'
      + 'Diagnostics:\n'
      + 'â€¢ Distance OK: ' + lastAnalysis.distOK + '\n'
      + 'â€¢ Energy OK: '   + lastAnalysis.energyOK + '\n'
      + 'â€¢ Phase OK: '    + lastAnalysis.phaseOK;
  }
});

// presets
document.querySelectorAll('.btnPreset').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const id = btn.dataset.preset;
    const p = PRESETS[id];
    if(!p) return;
    navTargetEl.value    = p.target;
    navTEl.value         = p.tDays;
    navKchiEl.value      = p.kChi;
    navEwarpEl.value     = p.Ewarp;
    navTolDistEl.value   = p.tolD;
    navTolEEl.value      = p.tolE;
    navTolPhaseEl.value  = p.tolP;
    recomputeNav();
    configOutputEl.value = ''; // clear until user hits Analyze Trip
  });
});

// initial compute so sliders show correct values
recomputeNav();
/* ---------- ENGINE VISUAL + MAP ANIMATION ---------- */

// create engine canvas inside engine panel dynamically
const enginePanelEl = document.getElementById('enginePanel');
const engineCanvas  = document.createElement('canvas');
engineCanvas.id = 'engineCanvas';
engineCanvas.width = 1600;
engineCanvas.height = 900;
engineCanvas.style.marginTop = '10px';
engineCanvas.style.borderRadius = '12px';
engineCanvas.style.border = '1px solid #22305c';
enginePanelEl.appendChild(engineCanvas);

const ectx = engineCanvas.getContext('2d');

// engine UI elements
const warpRangeEl   = document.getElementById('warpRange');
const engSpeedEl    = document.getElementById('engSpeed');
const engFieldEl    = document.getElementById('engField');
const engTempEl     = document.getElementById('engTemp');
const engClockEl    = document.getElementById('engClock');
const enginePlayBtn = document.getElementById('enginePlay');
const enginePauseBtn= document.getElementById('enginePause');
const engineResetBtn= document.getElementById('engineReset');
const engineLabelsEl= document.getElementById('engineLabels');
const warpTripBtn   = document.getElementById('warpTripBtn');

// map canvas
const mapCanvas = document.getElementById('mapCanvas');
const mctx      = mapCanvas.getContext('2d');

// engine state
let engineRunning = true;
let lastTime = performance.now();
let fanPhase = 0;

// warp trip coupling
let warpTripActive = false;
let warpTripStart  = 0;
let warpTripDurMs  = 8000;
let warpTripPeak   = 8;
let warpTripProgress = 0;

// cache nav positions for map travel
let travelStart = null; // {x,y}
let travelEnd   = null; // {x,y}

function engineWarpValue(now){
  const base = parseFloat(warpRangeEl.value);
  if(!warpTripActive) return base;
  const t = clamp((now-warpTripStart)/warpTripDurMs,0,1);
  warpTripProgress = t;
  // smooth in/out
  const ease = t<0.5 ? 2*t*t : 1-2*(1-t)*(1-t);
  return 1 + (warpTripPeak-1)*ease;
}

function updateEngineStats(warp){
  const speedMult = 1 + (warp-1)*0.5;
  const fieldR    = 1.2 + (warp-1)*0.16;
  const heatLevel = warp<4 ? 0.4+0.1*(warp-1) : 0.7+0.05*(warp-4);
  const clockRate = 1/ (1 + (warp-1)*0.07);

  engSpeedEl.textContent = 'x'+speedMult.toFixed(1);
  engFieldEl.textContent = fieldR.toFixed(2)+' Ã—D';
  engTempEl.textContent  = heatLevel>0.75 ? 'Hot' : (heatLevel>0.55?'Warm':'Cool');
  engClockEl.textContent = clockRate.toFixed(2)+'Ã—';
}

function drawEngineFrame(dt, now){
  const w = engineCanvas.width;
  const h = engineCanvas.height;
  ectx.clearRect(0,0,w,h);

  // background
  const bgGrad = ectx.createRadialGradient(
    w*0.5,h*0.5,100,
    w*0.5,h*0.5,700
  );
  bgGrad.addColorStop(0,'#101840');
  bgGrad.addColorStop(1,'#050815');
  ectx.fillStyle = bgGrad;
  ectx.fillRect(0,0,w,h);

  const warp = engineWarpValue(now);
  updateEngineStats(warp);

  const cx = w*0.45;
  const cy = h*0.5;
  const bodyLen = 780;
  const bodyR   = 120;

  // warp field ellipse
  const fieldScale = 1.1 + (warp-1)*0.12;
  ectx.save();
  ectx.translate(cx+bodyLen*0.1, cy);
  ectx.strokeStyle = '#33e1b588';
  ectx.lineWidth   = 2;
  for(let i=0;i<5;i++){
    ectx.beginPath();
    ectx.ellipse(0,0, bodyLen*0.35*fieldScale + i*22,
                     bodyR*0.6/fieldScale + i*12,
                     0,0,Math.PI*2);
    ectx.stroke();
  }
  ectx.restore();

  // main cylinder
  ectx.save();
  ectx.translate(cx-bodyLen*0.5, cy-bodyR);
  const grd = ectx.createLinearGradient(0,0,bodyLen,0);
  grd.addColorStop(0,'#202848');
  grd.addColorStop(0.4,'#151b34');
  grd.addColorStop(1,'#272e58');
  ectx.fillStyle = grd;
  ectx.fillRect(0,0,bodyLen,bodyR*2);
  ectx.strokeStyle = '#3a4a8a';
  ectx.lineWidth = 2;
  ectx.strokeRect(0,0,bodyLen,bodyR*2);
  ectx.restore();

  // nozzle
  ectx.save();
  ectx.translate(cx+bodyLen*0.5, cy);
  const nozLen = 180;
  const nozR0  = bodyR*0.7;
  const nozR1  = 25;
  const nozGrad = ectx.createLinearGradient(0,0,nozLen,0);
  nozGrad.addColorStop(0,'#262f54');
  nozGrad.addColorStop(1,'#9bb4ff');
  ectx.fillStyle = nozGrad;
  ectx.beginPath();
  ectx.moveTo(0,-nozR0);
  ectx.lineTo(nozLen,-nozR1);
  ectx.lineTo(nozLen,nozR1);
  ectx.lineTo(0,nozR0);
  ectx.closePath();
  ectx.fill();
  ectx.strokeStyle='#3a4a8a';
  ectx.lineWidth=2;
  ectx.stroke();
  ectx.restore();

  // plasma jet
  ectx.save();
  ectx.translate(cx+bodyLen*0.5+nozLen, cy);
  const jetLen = 260 + (warp-1)*25;
  const jetR   = 40 + (warp-1)*2;
  const jetGrad = ectx.createLinearGradient(0,0,jetLen,0);
  jetGrad.addColorStop(0,'rgba(255,220,168,0.8)');
  jetGrad.addColorStop(0.5,'rgba(255,220,168,0.3)');
  jetGrad.addColorStop(1,'rgba(255,220,168,0.05)');
  ectx.fillStyle=jetGrad;
  ectx.beginPath();
  ectx.moveTo(0,-jetR);
  ectx.lineTo(jetLen,-jetR*0.3);
  ectx.lineTo(jetLen,jetR*0.3);
  ectx.lineTo(0,jetR);
  ectx.closePath();
  ectx.fill();
  ectx.restore();

  // coils
  ectx.save();
  ectx.translate(cx-bodyLen*0.1, cy);
  const coilGap = 55;
  const coils = [-coilGap, coilGap];
  coils.forEach(x=>{
    ectx.save();
    ectx.translate(x,0);
    ectx.strokeStyle='#a6b8ffcc';
    ectx.lineWidth=7;
    ectx.beginPath();
    ectx.moveTo(0,-60);
    ectx.lineTo(0,60);
    ectx.stroke();
    ectx.strokeStyle='#5ea8ff';
    ectx.lineWidth=2;
    for(let i=-3;i<=3;i++){
      ectx.beginPath();
      ectx.arc(0,i*14,26+Math.abs(i)*3,0,Math.PI*2);
      ectx.stroke();
    }
    ectx.restore();
  });
  ectx.restore();

  // intake fan
  fanPhase += dt*0.004*(1+(warp-1)*0.3);
  ectx.save();
  ectx.translate(cx-bodyLen*0.55, cy);
  ectx.fillStyle='#a4b2d8';
  ectx.beginPath();
  ectx.arc(0,0,36,0,Math.PI*2);
  ectx.fill();
  for(let i=0;i<6;i++){
    const a = fanPhase + i*Math.PI*2/6;
    const r1=18, r2=70;
    ectx.fillStyle='#c7d4ff';
    ectx.beginPath();
    ectx.moveTo(Math.cos(a)*r1,Math.sin(a)*r1);
    ectx.lineTo(Math.cos(a+0.2)*r2,Math.sin(a+0.2)*r2);
    ectx.lineTo(Math.cos(a+0.4)*r1,Math.sin(a+0.4)*r1);
    ectx.closePath();
    ectx.fill();
  }
  ectx.restore();

  // photon/particle stream inside tube
  const numDots = 120;
  ectx.save();
  ectx.translate(cx-bodyLen*0.5, cy);
  for(let i=0;i<numDots;i++){
    const t = (i/numDots);
    const x = t*bodyLen;
    const y = Math.sin((t*20)+now*0.004)*18;
    const heat = warp>6 ? 0.4 : 0.2;
    ectx.fillStyle = i%3===0 ? '#9bb4ff' : (Math.random()<heat?'#ffcc66':'#6bd1ff');
    ectx.fillRect(x,y,3,2);
  }
  ectx.restore();

  // labels optional
  if(engineLabelsEl.checked){
    ectx.fillStyle='#eaf0ff';
    ectx.font='14px system-ui,Segoe UI';
    ectx.textAlign='left';
    ectx.fillText('Intake / Fusion Starter', cx-bodyLen*0.65, cy-bodyR-40);
    ectx.fillText('Warp Coils / Field Shaper', cx-bodyLen*0.15, cy-bodyR-40);
    ectx.fillText('Nozzle / Plasma Jet', cx+bodyLen*0.25, cy-bodyR-40);
  }

  // if warp trip complete, show arrival banner
  if(!warpTripActive && warpTripProgress>=1 && lastAnalysis.go){
    ectx.fillStyle='rgba(0,0,0,0.45)';
    ectx.fillRect(w*0.3,h*0.06,w*0.4,46);
    ectx.fillStyle='#7bffb1';
    ectx.font='18px system-ui,Segoe UI';
    ectx.textAlign='center';
    ectx.fillText('Arrived at '+lastAnalysis.target+' (warp corridor complete)', w*0.5,h*0.09+10);
  }
}

/* ---------- MAP DRAW ---------- */

function drawMapFrame(now){
  const w = mapCanvas.width;
  const h = mapCanvas.height;
  mctx.clearRect(0,0,w,h);

  // background
  mctx.fillStyle='#050814';
  mctx.fillRect(0,0,w,h);

  const cx = w*0.5;
  const cy = h*0.5;

  // guard: need a last analysis with positions
  if(!lastAnalysis || !lastAnalysis.Epos || !lastAnalysis.Tpos) return;

  const aE = PLANETS['Earth'].a;
  const aT = PLANETS[lastAnalysis.target].a;
  const maxA = Math.max(aE,aT)*1.3;
  const scale = Math.min(w,h)*0.42/maxA;

  // Sun
  const sunGrad = mctx.createRadialGradient(cx,cy,5,cx,cy,40);
  sunGrad.addColorStop(0,'#ffd37a');
  sunGrad.addColorStop(1,'#ffb34700');
  mctx.fillStyle = sunGrad;
  mctx.beginPath();
  mctx.arc(cx,cy,16,0,Math.PI*2);
  mctx.fill();

  // orbits
  mctx.strokeStyle='#2a3564';
  mctx.lineWidth=1;
  mctx.setLineDash([5,6]);
  [aE,aT].forEach((ra,i)=>{
    mctx.beginPath();
    mctx.arc(cx,cy,ra*scale,0,Math.PI*2);
    mctx.stroke();
  });
  mctx.setLineDash([]);

  const Epos = lastAnalysis.Epos;
  const Tpos = lastAnalysis.Tpos;

  const Ex = cx + Epos.x*scale;
  const Ey = cy - Epos.y*scale;
  const Tx = cx + Tpos.x*scale;
  const Ty = cy - Tpos.y*scale;

  // travel line if trip or completed
  if(travelStart && travelEnd){
    mctx.strokeStyle='#8fb4ff';
    mctx.lineWidth=2;
    mctx.beginPath();
    mctx.moveTo(travelStart.x, travelStart.y);
    mctx.lineTo(travelEnd.x, travelEnd.y);
    mctx.stroke();

    // moving dot during active trip
    if(warpTripActive){
      const t = warpTripProgress;
      const px = travelStart.x + (travelEnd.x-travelStart.x)*t;
      const py = travelStart.y + (travelEnd.y-travelStart.y)*t;
      mctx.fillStyle='#7bffb1';
      mctx.beginPath();
      mctx.arc(px,py,6,0,Math.PI*2);
      mctx.fill();
    }else if(warpTripProgress>=1){
      // arrival dot stays on planet
      mctx.fillStyle='#7bffb1';
      mctx.beginPath();
      mctx.arc(travelEnd.x,travelEnd.y,6,0,Math.PI*2);
      mctx.fill();
    }
  }

  // Earth
  mctx.fillStyle='#7bffb1';
  mctx.beginPath();
  mctx.arc(Ex,Ey,6,0,Math.PI*2);
  mctx.fill();

  // target
  mctx.fillStyle='#ff8c8c';
  mctx.beginPath();
  mctx.arc(Tx,Ty,6,0,Math.PI*2);
  mctx.fill();

  // legend text
  mctx.fillStyle='#9bb7e3';
  mctx.font='13px system-ui,Segoe UI';
  mctx.textAlign='left';
  mctx.fillText('Earth', Ex+10, Ey-4);
  mctx.fillText(lastAnalysis.target, Tx+10, Ty-4);
}

/* ---------- WARP TRIP BUTTON ---------- */

warpTripBtn.addEventListener('click', ()=>{
  // only if GO
  if(!lastAnalysis.go) return;

  const now = performance.now();
  warpTripActive = true;
  warpTripStart  = now;
  warpTripProgress = 0;

  // set duration from estimated tau, clamp to [4s, 20s] for demo
  const tauH = lastAnalysis.tauHours>0 ? lastAnalysis.tauHours : 1;
  warpTripDurMs = clamp(tauH*800, 4000, 20000);

  // peak warp from distance, but capped
  warpTripPeak = clamp(3 + lastAnalysis.d4*3, 4, 10);

  // freeze travel endpoints for map (Earth â†’ selected planet)
  const w = mapCanvas.width;
  const h = mapCanvas.height;
  const cx = w*0.5;
  const cy = h*0.5;
  const aE = PLANETS['Earth'].a;
  const aT = PLANETS[lastAnalysis.target].a;
  const maxA = Math.max(aE,aT)*1.3;
  const scale = Math.min(w,h)*0.42/maxA;
  travelStart = {
    x:cx + lastAnalysis.Epos.x*scale,
    y:cy - lastAnalysis.Epos.y*scale
  };
  travelEnd = {
    x:cx + lastAnalysis.Tpos.x*scale,
    y:cy - lastAnalysis.Tpos.y*scale
  };
});

// engine play/pause/reset
enginePauseBtn.addEventListener('click', ()=>{
  engineRunning=false;
});
enginePlayBtn.addEventListener('click', ()=>{
  if(!engineRunning){
    engineRunning=true;
    lastTime=performance.now();
    requestAnimationFrame(loop);
  }
});
engineResetBtn.addEventListener('click', ()=>{
  warpTripActive=false;
  warpTripProgress=0;
});

/* ---------- MAIN LOOP ---------- */

function loop(now){
  if(!engineRunning) return;
  const dt = now-lastTime;
  lastTime = now;

  drawEngineFrame(dt, now);
  drawMapFrame(now);

  // stop warp trip when finished
  if(warpTripActive && now-warpTripStart >= warpTripDurMs){
    warpTripActive=false;
    warpTripProgress=1;
  }

  requestAnimationFrame(loop);
}

// kick off animation
requestAnimationFrame(loop);

</script>
</body>
</html>
