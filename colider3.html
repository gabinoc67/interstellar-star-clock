<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Earth–Planet 4D Backup Navigation Check</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --good:#7bffb1;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --chip:#1e2a59;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:100%;
    margin:0;
    padding:16px;
  }
  h1{
    margin:4px 0 6px;
    font-size:1.6rem;
  }
  h2{
    margin:12px 0 8px;
    font-size:1.1rem;
    color:var(--muted);
    text-transform:uppercase;
    letter-spacing:.04em;
  }
  p{
    margin:4px 0 8px;
    color:var(--muted);
    font-size:.9rem;
  }
  .grid{
    display:grid;
    grid-template-columns:minmax(0,1.0fr) minmax(0,1.6fr);
    gap:16px;
    margin-top:10px;
  }
  .card{
    background:var(--panel);
    border-radius:14px;
    padding:12px 14px;
    box-shadow:0 0 0 1px #141c3a,0 14px 30px rgba(0,0,0,.5);
  }
  .card h3{
    margin:0 0 6px;
    font-size:1rem;
  }
  label{
    display:block;
    font-size:.8rem;
    color:var(--muted);
    margin:6px 0 3px;
  }
  input[type="range"],
  input[type="number"],
  select{
    width:100%;
    margin:0 0 6px;
    font-size:.85rem;
    padding:4px 6px;
    border-radius:8px;
    border:1px solid #27305a;
    background:#070b18;
    color:var(--ink);
  }
  input[type="range"]{
    padding:0;
    height:6px;
  }
  .inline-row{
    display:flex;
    gap:8px;
    align-items:center;
  }
  .inline-row > *{
    flex:1;
  }
  .metric-row{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    margin:4px 0;
    font-size:.9rem;
  }
  .metric-label{
    color:var(--muted);
  }
  .metric-value{
    font-variant-numeric:tabular-nums;
  }
  .metric-value strong{
    font-size:1rem;
  }
  .status-row{
    display:flex;
    align-items:center;
    gap:8px;
    margin:4px 0;
    font-size:.85rem;
  }
  .status-dot{
    width:11px;
    height:11px;
    border-radius:50%;
    box-shadow:0 0 8px rgba(0,0,0,.6);
  }
  .status-ok{
    background:var(--good);
  }
  .status-warn{
    background:var(--warn);
  }
  .status-bad{
    background:var(--bad);
  }
  .chip{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:3px 8px;
    border-radius:999px;
    background:var(--chip);
    font-size:.75rem;
    color:var(--muted);
  }
  .big-go{
    margin-top:6px;
    padding:10px 12px;
    border-radius:999px;
    font-size:.95rem;
    font-weight:600;
    text-align:center;
  }
  .big-go.go{
    background:rgba(123,255,177,.12);
    color:var(--good);
    border:1px solid rgba(123,255,177,.5);
    box-shadow:0 0 18px rgba(123,255,177,.4);
  }
  .big-go.nogo{
    background:rgba(255,140,140,.08);
    color:var(--bad);
    border:1px solid rgba(255,140,140,.5);
    box-shadow:0 0 18px rgba(255,140,140,.2);
  }
  .small{
    font-size:.75rem;
    color:var(--muted);
  }
  .xy-plot{
    position:relative;
    width:100%;
    padding-top:100%;
    background:#070b18;
    border-radius:12px;
    border:1px solid #202749;
    overflow:hidden;
  }
  .xy-inner{
    position:absolute;
    inset:10px;
  }
  .xy-inner canvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }
  .xy-center{
    position:absolute;
    left:50%;
    top:50%;
    width:4px;
    height:4px;
    margin:-2px 0 0 -2px;
    border-radius:50%;
    background:#ffffff55;
  }
  .planet-dot{
    position:absolute;
    width:10px;
    height:10px;
    margin:-5px 0 0 -5px;
    border-radius:50%;
    box-shadow:0 0 10px rgba(0,0,0,.8);
  }
  .planet-earth{
    background:#7bffb1;
  }
  .planet-target{
    background:#ff8c8c;
  }
  .orbit-circle{
    position:absolute;
    border-radius:50%;
    border:1px dashed #2a3564;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
  }
  .legend{
    display:flex;
    gap:8px;
    margin-top:6px;
    font-size:.8rem;
    color:var(--muted);
  }
  .legend-item{
    display:flex;
    align-items:center;
    gap:4px;
  }
  .legend-swatch{
    width:10px;
    height:10px;
    border-radius:50%;
  }
  .text-mono{
    font-family:ui-monospace,Menlo,Consolas,monospace;
    font-size:.8rem;
  }
  .planet-row{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    margin:2px 0 6px;
  }
  .planet-btn{
    flex:0 0 auto;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid #27305a;
    background:#070b18;
    color:var(--muted);
    font-size:.75rem;
    cursor:pointer;
  }
  .planet-btn.active{
    border-color:var(--accent);
    color:var(--ink);
    box-shadow:0 0 10px rgba(143,180,255,.5);
    background:#111b3c;
  }
  .btn{
    display:inline-flex;
    justify-content:center;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid #27305a;
    background:#0d1430;
    color:var(--ink);
    font-size:.8rem;
    cursor:pointer;
  }
  .btn-primary{
    border-color:var(--accent);
    box-shadow:0 0 12px rgba(143,180,255,.5);
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Earth–Planet 4D Backup Navigation Check</h1>
  <p>
    Simplified heliocentric model with a 4th dimension for <span class="text-mono">field / phase</span>.  
    Use this as one of your independent verifications before entering warp.
  </p>

  <div class="grid">
    <!-- Controls -->
    <div class="card">
      <h3>Mission Controls</h3>

      <label>Target Planet (heliocentric corridor)</label>
      <div class="planet-row">
        <button type="button" class="planet-btn" data-planet="mercury">Mercury</button>
        <button type="button" class="planet-btn" data-planet="venus">Venus</button>
        <button type="button" class="planet-btn active" data-planet="mars">Mars</button>
        <button type="button" class="planet-btn" data-planet="jupiter">Jupiter</button>
        <button type="button" class="planet-btn" data-planet="saturn">Saturn</button>
        <button type="button" class="planet-btn" data-planet="uranus">Uranus</button>
        <button type="button" class="planet-btn" data-planet="neptune">Neptune</button>
      </div>
      <label for="timeDays">Mission Time <span class="text-mono">(t, days from epoch)</span></label>
      <input id="timeDays" type="range" min="0" max="1200" value="200" step="1">
      <div class="inline-row small">
        <span>0</span>
        <span style="text-align:center;">t = <span id="timeDaysLabel">200</span> days</span>
        <span>1200</span>
      </div>

      <label for="phaseWeight">Phase Weight in 4D Distance <span class="text-mono">(kχ)</span></label>
      <input id="phaseWeight" type="range" min="0" max="5" value="1.5" step="0.1">
      <div class="inline-row small">
        <span>0 = ignore phase</span>
        <span style="text-align:right;">kχ = <span id="phaseWeightLabel">1.5</span></span>
      </div>

      <label for="warpEnergy">Selected Warp Energy Budget (arbitrary units)</label>
      <input id="warpEnergy" type="range" min="0" max="5" value="2" step="0.05">
      <div class="inline-row small">
        <span>0</span>
        <span style="text-align:right;">E<sub>warp</sub> = <span id="warpEnergyLabel">2.00</span></span>
      </div>

      <div class="inline-row">
        <div>
          <label for="distTolerance">Distance Match Tol. (%)</label>
          <input id="distTolerance" type="number" value="2" min="0.1" max="20" step="0.1">
        </div>
        <div>
          <label for="energyTolerance">Energy Match Tol. (%)</label>
          <input id="energyTolerance" type="number" value="5" min="0.5" max="50" step="0.5">
        </div>
      </div>

      <div class="inline-row">
        <div>
          <label for="phaseTolerance">Phase Align Tol. (rad)</label>
          <input id="phaseTolerance" type="number" value="0.4" min="0.05" max="3" step="0.05">
        </div>
        <div>
          <label>Epoch Model</label>
          <div class="chip">
            Circular orbits &middot; demo only
          </div>
        </div>
      </div>

      <div class="inline-row" style="margin-top:8px;">
        <button id="analyzeBtn" class="btn btn-primary">Analyze Trip</button>
        <button id="warpBtn" class="btn">Warp Drive Trip</button>
      </div>

      <div id="goBanner" class="big-go nogo">
        NO-GO: Verification conditions not all satisfied
      </div>
      <p class="small">
        Real system: replace circular-orbit demo with high-precision ephemerides + your CST core + live warp engine telemetry.
      </p>
    </div>

    <!-- Data & Visualization -->
    <div class="card">
      <h3>State Vectors &amp; 4D Metrics</h3>

      <div class="metric-row">
        <div class="metric-label">Earth position (AU, ecliptic plane)</div>
        <div class="metric-value text-mono">
          ( <span id="earthX">0.000</span>,
            <span id="earthY">0.000</span>,
            <span id="earthZ">0.000</span> )
        </div>
      </div>
      <div class="metric-row">
        <div class="metric-label">
          Target position (AU, ecliptic plane) — <span class="text-mono" id="targetName">Mars</span>
        </div>
        <div class="metric-value text-mono">
          ( <span id="marsX">0.000</span>,
            <span id="marsY">0.000</span>,
            <span id="marsZ">0.000</span> )
        </div>
      </div>

      <div class="metric-row">
        <div class="metric-label">4th component χ (phase channel, rad)</div>
        <div class="metric-value text-mono">
          χ<sub>⊕</sub> = <span id="earthChi">0.000</span>,
          χ<sub>⊙</sub> = <span id="marsChi">0.000</span>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid #252f5a;margin:8px 0;">

      <div class="metric-row">
        <div class="metric-label">3D distance |r<sub>target</sub> − r<sub>⊕</sub>|</div>
        <div class="metric-value"><strong><span id="dist3D">0.000</span></strong> AU</div>
      </div>
      <div class="metric-row">
        <div class="metric-label">4D distance ‖ΔX‖ (with χ &amp; kχ)</div>
        <div class="metric-value"><strong><span id="dist4D">0.000</span></strong> AU*</div>
      </div>
      <p class="small">
        *Scaled 4D metric: spatial components in AU, phase axis weighted by kχ slider.
      </p>

      <div class="metric-row">
        <div class="metric-label">Phase gap |Δχ| (wrapped, rad)</div>
        <div class="metric-value"><strong><span id="phaseGap">0.000</span></strong></div>
      </div>

      <hr style="border:none;border-top:1px solid #252f5a;margin:8px 0;">

      <div class="metric-row">
        <div class="metric-label">Expected energy &propto 3D distance</div>
        <div class="metric-value text-mono">E<sub>exp</sub> = <span id="expectedEnergy">0.000</span></div>
      </div>
      <div class="metric-row">
        <div class="metric-label">Warp energy selection</div>
        <div class="metric-value text-mono">E<sub>warp</sub> = <span id="warpEnergyEcho">0.000</span></div>
      </div>

      <div class="metric-row">
        <div class="metric-label">Demo warp trip estimate</div>
        <div class="metric-value text-mono">
          v<sub>sim</sub> = <span id="simSpeed">0.000</span> AU/day,
          t<sub>trip</sub> ≈ <span id="simTime">0.0</span> days
        </div>
      </div>

      <hr style="border:none;border-top:1px solid #252f5a;margin:8px 0;">

      <h3>Verification Channels</h3>

      <div class="status-row">
        <div id="statusDistDot" class="status-dot status-bad"></div>
        <div>
          1. 3D vs 4D distance consistency
          <div class="small">
            |d<sub>4D</sub> − d<sub>3D</sub>| / d<sub>3D</sub> &lt; tol?
            &nbsp;→ &nbsp;<span id="statusDistText" class="text-mono">NO</span>
          </div>
        </div>
      </div>

      <div class="status-row">
        <div id="statusEnergyDot" class="status-dot status-bad"></div>
        <div>
          2. Energy profile consistency
          <div class="small">
            |E<sub>warp</sub> − E<sub>exp</sub>| / E<sub>exp</sub> &lt; tol?
            &nbsp;→ &nbsp;<span id="statusEnergyText" class="text-mono">NO</span>
          </div>
        </div>
      </div>

      <div class="status-row">
        <div id="statusPhaseDot" class="status-dot status-bad"></div>
        <div>
          3. Phase alignment window
          <div class="small">
            |Δχ| &lt; phase tolerance?
            &nbsp;→ &nbsp;<span id="statusPhaseText" class="text-mono">NO</span>
          </div>
        </div>
      </div>

      <div class="status-row">
        <div id="statusOverallDot" class="status-dot status-bad"></div>
        <div>
          4. Overall GO/NO-GO
          <div class="small">
            All three channels green?
            &nbsp;→ &nbsp;<span id="statusOverallText" class="text-mono">NO-GO</span>
          </div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid #252f5a;margin:8px 0;">
      <div class="xy-plot">
        <div class="xy-inner" id="xyInner">
          <canvas id="xyCanvas"></canvas>
          <div class="xy-center"></div>
          <div id="orbitEarth" class="orbit-circle"></div>
          <div id="orbitTarget" class="orbit-circle"></div>
          <div id="dotEarth" class="planet-dot planet-earth"></div>
          <div id="dotTarget" class="planet-dot planet-target"></div>
        </div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <span class="legend-swatch" style="background:#7bffb1;"></span> Earth
        </div>
        <div class="legend-item">
          <span class="legend-swatch" style="background:#ff8c8c;"></span> Target
        </div>
        <div class="legend-item small">
          Top-down heliocentric slice (z=0 plane) + warp corridor line vector
        </div>
      </div>

    </div>
  </div>
</div>

<script>
(function(){
  const AU = 1.0;
  const T_EARTH = 365.25;        // days, orbital period (simplified)

  // Simple planet table (semi-major axis in AU, period in days)
  const PLANETS = {
    mercury:{ name:'Mercury', a:0.387, period:87.97 },
    venus  :{ name:'Venus',   a:0.723, period:224.70 },
    earth  :{ name:'Earth',   a:1.000, period:365.25 },
    mars   :{ name:'Mars',    a:1.524, period:686.98 },
    jupiter:{ name:'Jupiter', a:5.203, period:4332.59 },
    saturn :{ name:'Saturn',  a:9.537, period:10759.22 },
    uranus :{ name:'Uranus',  a:19.191, period:30685.4 },
    neptune:{ name:'Neptune', a:30.068, period:60190.0 }
  };
  const EARTH = PLANETS.earth;
  let currentPlanetKey = 'mars';

  const timeDaysEl = document.getElementById('timeDays');
  const timeDaysLabelEl = document.getElementById('timeDaysLabel');
  const phaseWeightEl = document.getElementById('phaseWeight');
  const phaseWeightLabelEl = document.getElementById('phaseWeightLabel');
  const warpEnergyEl = document.getElementById('warpEnergy');
  const warpEnergyLabelEl = document.getElementById('warpEnergyLabel');
  const distTolEl = document.getElementById('distTolerance');
  const energyTolEl = document.getElementById('energyTolerance');
  const phaseTolEl = document.getElementById('phaseTolerance');

  const earthXEl = document.getElementById('earthX');
  const earthYEl = document.getElementById('earthY');
  const earthZEl = document.getElementById('earthZ');
  const marsXEl = document.getElementById('marsX');   // reused as target X
  const marsYEl = document.getElementById('marsY');
  const marsZEl = document.getElementById('marsZ');
  const targetNameEl = document.getElementById('targetName');
  const earthChiEl = document.getElementById('earthChi');
  const marsChiEl = document.getElementById('marsChi');
  const dist3DEl = document.getElementById('dist3D');
  const dist4DEl = document.getElementById('dist4D');
  const phaseGapEl = document.getElementById('phaseGap');
  const expectedEnergyEl = document.getElementById('expectedEnergy');
  const warpEnergyEchoEl = document.getElementById('warpEnergyEcho');
  const simSpeedEl = document.getElementById('simSpeed');
  const simTimeEl = document.getElementById('simTime');

  const statusDistDot = document.getElementById('statusDistDot');
  const statusEnergyDot = document.getElementById('statusEnergyDot');
  const statusPhaseDot = document.getElementById('statusPhaseDot');
  const statusOverallDot = document.getElementById('statusOverallDot');
  const statusDistText = document.getElementById('statusDistText');
  const statusEnergyText = document.getElementById('statusEnergyText');
  const statusPhaseText = document.getElementById('statusPhaseText');
  const statusOverallText = document.getElementById('statusOverallText');
  const goBanner = document.getElementById('goBanner');

  const xyInner = document.getElementById('xyInner');
  const xyCanvas = document.getElementById('xyCanvas');
  const ctxTrip = xyCanvas.getContext('2d');
  const orbitEarth = document.getElementById('orbitEarth');
  const orbitTarget = document.getElementById('orbitTarget');
  const dotEarth = document.getElementById('dotEarth');
  const dotTarget = document.getElementById('dotTarget');

  const analyzeBtn = document.getElementById('analyzeBtn');
  const warpBtn = document.getElementById('warpBtn');
  const planetButtons = document.querySelectorAll('.planet-btn');

  function fmt(x, digits){
    return x.toFixed(digits);
  }
  function clamp(x, a, b){
    return Math.max(a, Math.min(b, x));
  }
  function wrapAngle(angle){
    const twoPi = Math.PI * 2;
    let a = angle % twoPi;
    if (a <= -Math.PI) a += twoPi;
    if (a >  Math.PI)  a -= twoPi;
    return a;
  }

  function resizeCanvas(){
    const rect = xyInner.getBoundingClientRect();
    xyCanvas.width = rect.width;
    xyCanvas.height = rect.height;
  }

  function updateOrbits(targetA){
    const rect = xyInner.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    const maxAU = Math.max(EARTH.a, targetA) * 1.2;
    const scale = (size/2) / maxAU;

    const re = EARTH.a * scale * 2;
    orbitEarth.style.width = re + 'px';
    orbitEarth.style.height = re + 'px';
    orbitEarth.style.left = '50%';
    orbitEarth.style.top = '50%';

    const rt = targetA * scale * 2;
    orbitTarget.style.width = rt + 'px';
    orbitTarget.style.height = rt + 'px';
    orbitTarget.style.left = '50%';
    orbitTarget.style.top = '50%';

    return {scale};
  }

  // Trip animation state
  let lastState = {
    pxE:0, pyE:0,
    pxT:0, pyT:0,
    dist4:0,
    warpE:0
  };
  let tripRunning = false;
  let tripStartTime = 0;
  let tripDurationMs = 8000;
  let tripProgress = 0;

  function clearTripOverlay(){
    ctxTrip.clearRect(0,0,xyCanvas.width,xyCanvas.height);
  }

  function drawTripOverlay(){
    clearTripOverlay();
    const {pxE,pyE,pxT,pyT} = lastState;
    if (!isFinite(pxE) || !isFinite(pxT)) return;

    // Corridor line
    ctxTrip.strokeStyle = 'rgba(143,180,255,0.9)';
    ctxTrip.lineWidth = 2;
    ctxTrip.beginPath();
    ctxTrip.moveTo(pxE,pyE);
    ctxTrip.lineTo(pxT,pyT);
    ctxTrip.stroke();

    // Moving ship dot
    const sx = pxE + (pxT - pxE) * tripProgress;
    const sy = pyE + (pyT - pyE) * tripProgress;
    ctxTrip.fillStyle = 'rgba(123,255,177,1)';
    ctxTrip.beginPath();
    ctxTrip.arc(sx, sy, 5, 0, Math.PI*2);
    ctxTrip.fill();

    // Simple "field thickness" aura responds to 4D distance
    const auraR = 8 + clamp(lastState.dist4*1.5, 0, 20);
    ctxTrip.strokeStyle = 'rgba(255,220,168,0.55)';
    ctxTrip.lineWidth = 1.2;
    ctxTrip.beginPath();
    ctxTrip.arc(sx, sy, auraR, 0, Math.PI*2);
    ctxTrip.stroke();
  }
  function animateTrip(now){
    if (!tripRunning) return;
    const elapsed = now - tripStartTime;
    tripProgress = clamp(elapsed / tripDurationMs, 0, 1);
    drawTripOverlay();
    if (tripProgress >= 1){
      tripRunning = false;
      return;
    }
    requestAnimationFrame(animateTrip);
  }

  function startTrip(){
    if (lastState.dist4 <= 0 || lastState.warpE <= 0){
      // nothing meaningful to animate
      return;
    }
    const d4 = lastState.dist4;
    const warpE = lastState.warpE;

    // Map 4D distance + warp energy into a demo trip time (3–20 seconds)
    const baseMs = 10000 * (d4 / 2);      // scales with distance
    const speedFactor = Math.max(0.3, warpE / 3);   // faster at higher warp
    tripDurationMs = clamp(baseMs / speedFactor, 3000, 20000);

    tripRunning = true;
    tripProgress = 0;
    tripStartTime = performance.now();
    requestAnimationFrame(animateTrip);
  }

  function recompute(){
    const planet = PLANETS[currentPlanetKey] || PLANETS.mars;
    targetNameEl.textContent = planet.name;

    const t = parseFloat(timeDaysEl.value);               // days
    const kChi = parseFloat(phaseWeightEl.value);
    const warpE = parseFloat(warpEnergyEl.value);
    const distTolPct = Math.max(0.001, parseFloat(distTolEl.value));
    const energyTolPct = Math.max(0.001, parseFloat(energyTolEl.value));
    const phaseTol = Math.max(0.001, parseFloat(phaseTolEl.value));

    timeDaysLabelEl.textContent = fmt(t,0);
    phaseWeightLabelEl.textContent = fmt(kChi,1);
    warpEnergyLabelEl.textContent = fmt(warpE,2);

    // Angles for Earth & Target (circular orbit model)
    const thetaE = 2*Math.PI * (t / T_EARTH);
    const thetaT = 2*Math.PI * (t / planet.period);

    // 3D positions (z = 0 for this simple slice)
    const xE = EARTH.a * Math.cos(thetaE);
    const yE = EARTH.a * Math.sin(thetaE);
    const zE = 0;

    const xT = planet.a * Math.cos(thetaT);
    const yT = planet.a * Math.sin(thetaT);
    const zT = 0;

    // 4th coordinate χ = orbital phase (field/phase channel)
    const chiE = wrapAngle(thetaE);
    const chiT = wrapAngle(thetaT);

    // Update numeric display
    earthXEl.textContent = fmt(xE,3);
    earthYEl.textContent = fmt(yE,3);
    earthZEl.textContent = fmt(zE,3);
    marsXEl.textContent = fmt(xT,3);
    marsYEl.textContent = fmt(yT,3);
    marsZEl.textContent = fmt(zT,3);
    earthChiEl.textContent = fmt(chiE,3);
    marsChiEl.textContent = fmt(chiT,3);

    // Distances
    const dx = xT - xE;
    const dy = yT - yE;
    const dz = zT - zE;
    const d3 = Math.sqrt(dx*dx + dy*dy + dz*dz);

    const dChi = wrapAngle(chiT - chiE);
    const d4 = Math.sqrt(dx*dx + dy*dy + dz*dz + (kChi * dChi)*(kChi * dChi));

    dist3DEl.textContent = fmt(d3,3);
    dist4DEl.textContent = fmt(d4,3);
    phaseGapEl.textContent = fmt(Math.abs(dChi),3);

    // Energy model (demo)
    const alpha = 2.0;
    const Eexp = alpha * d3;
    expectedEnergyEl.textContent = fmt(Eexp,3);
    warpEnergyEchoEl.textContent = fmt(warpE,3);

    // Demo warp trip estimate: speed and time from 4D metric
    let simSpeed = 0;
    let simTime = 0;
    if (warpE > 0){
      simSpeed = 0.02 + warpE * 0.18; // AU/day (demo scaling)
      simTime = (d4 > 0) ? (d4 / simSpeed) : 0;
    }
    simSpeedEl.textContent = fmt(simSpeed,3);
    simTimeEl.textContent = fmt(simTime,1);

    // Verification channel 1: 3D vs 4D distance consistency
    let distOK = false;
    if (d3 > 0){
      const relDiff = Math.abs(d4 - d3) / d3 * 100.0;
      distOK = (relDiff <= distTolPct);
    } else {
      distOK = (Math.abs(d4) < 1e-4);
    }

    // Verification channel 2: energy profile consistency
    let energyOK = false;
    if (Eexp > 0){
      const relEDiff = Math.abs(warpE - Eexp) / Eexp * 100.0;
      energyOK = (relEDiff <= energyTolPct);
    } else {
      energyOK = (Math.abs(warpE) < 1e-4);
    }

    // Verification channel 3: phase alignment window
    const phaseOK = (Math.abs(dChi) <= phaseTol);

    // Update status lights & text
    function setStatus(elDot, elText, ok){
      elDot.classList.remove('status-ok','status-warn','status-bad');
      if (ok){
        elDot.classList.add('status-ok');
      } else {
        elDot.classList.add('status-bad');
      }
      elText.textContent = ok ? 'YES' : 'NO';
    }

    setStatus(statusDistDot, statusDistText, distOK);
    setStatus(statusEnergyDot, statusEnergyText, energyOK);
    setStatus(statusPhaseDot, statusPhaseText, phaseOK);

    const overallOK = distOK && energyOK && phaseOK;
    statusOverallDot.classList.remove('status-ok','status-warn','status-bad');
    statusOverallDot.classList.add(overallOK ? 'status-ok' : 'status-bad');
    statusOverallText.textContent = overallOK ? 'GO' : 'NO-GO';

    goBanner.classList.remove('go','nogo');
    if (overallOK){
      goBanner.classList.add('go');
      goBanner.textContent = 'GO: All backup checks satisfied for Earth–' + planet.name + ' corridor (demo model)';
    } else {
      goBanner.classList.add('nogo');
      goBanner.textContent = 'NO-GO: Verification conditions not all satisfied';
    }

    // Update simple XY visualization + cache state for warp trip overlay
    const {scale} = updateOrbits(planet.a);
    const rect = xyInner.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;

    const pxE = cx + xE * scale;
    const pyE = cy - yE * scale;
    const pxT = cx + xT * scale;
    const pyT = cy - yT * scale;

    dotEarth.style.left = pxE + 'px';
    dotEarth.style.top  = pyE + 'px';
    dotTarget.style.left = pxT + 'px';
    dotTarget.style.top  = pyT + 'px';

    lastState = {
      pxE, pyE,
      pxT, pyT,
      dist4: d4,
      warpE: warpE
    };

    // If not currently running a trip, just clear overlay (no path)
    if (!tripRunning){
      clearTripOverlay();
    }
  }

  // Event listeners
  window.addEventListener('resize', ()=>{
    resizeCanvas();
    recompute();
  });

  planetButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      planetButtons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      currentPlanetKey = btn.getAttribute('data-planet') || 'mars';
      recompute();
    });
  });

  timeDaysEl.addEventListener('input', ()=>{/* wait for Analyze */});
  phaseWeightEl.addEventListener('input', ()=>{/* wait for Analyze */});
  warpEnergyEl.addEventListener('input', ()=>{/* wait for Analyze */});
  distTolEl.addEventListener('input', ()=>{/* wait for Analyze */});
  energyTolEl.addEventListener('input', ()=>{/* wait for Analyze */});
  phaseTolEl.addEventListener('input', ()=>{/* wait for Analyze */});

  analyzeBtn.addEventListener('click', ()=>{
    tripRunning = false;
    clearTripOverlay();
    recompute();
  });

  warpBtn.addEventListener('click', ()=>{
    // Use latest analyzed state; if user changed sliders without Analyze,
    // first recompute to sync math, then launch warp trip.
    recompute();
    startTrip();
  });

  // Initial layout
  resizeCanvas();
  recompute();
})();
</script>
</body>
</html>
