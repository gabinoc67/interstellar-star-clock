<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Engine + 4D Backup Navigation (Multi-Planet)</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#eaf0ff;
    --muted:#9bb7e3;
    --accent:#8fb4ff;
    --good:#7bffb1;
    --bad:#ff8c8c;
    --warn:#ffd37a;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  a{color:#9bb4ff}

  .wrap{
    max-width:1800px;
    margin:0 auto;
    padding:12px;
  }
  .layout{
    display:grid;
    grid-template-columns:380px 1fr;
    gap:14px;
    align-items:start;
  }
  @media(max-width:1200px){
    .layout{grid-template-columns:1fr;}
  }
  .panel{
    background:var(--panel);
    border:1px solid #22305c;
    border-radius:14px;
    padding:12px;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
  }
  h1{
    margin:.2rem 0 .4rem;
    font-size:26px;
  }
  h2{
    margin:.4rem 0 .3rem;
    font-size:16px;
    color:#b8c4ff;
  }
  label{
    display:block;
    font-size:.8rem;
    margin-top:6px;
  }
  select,input[type=number]{
    width:100%;
    padding:4px 6px;
    margin-top:2px;
    border-radius:8px;
    border:1px solid #27305a;
    background:#070b18;
    color:var(--ink);
    font-size:.8rem;
  }
  input[type=range]{width:100%}
  .miniVal{
    font-size:.75rem;
    color:var(--warn);
    margin-left:6px;
  }
  .btn{
    background:#182364;
    border:1px solid #2a3a7c;
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    margin-right:4px;
    color:var(--ink);
    font-size:.8rem;
  }
  .btn:hover{filter:brightness(1.1)}
  .go-light{
    margin-top:6px;
    padding:10px;
    border-radius:14px;
    text-align:center;
    font-size:.95rem;
    font-weight:600;
  }
  .go-light.go{
    background:rgba(123,255,177,.12);
    border:1px solid rgba(123,255,177,.6);
    color:var(--good);
    box-shadow:0 0 12px rgba(123,255,177,.35);
  }
  .go-light.nogo{
    background:rgba(255,140,140,.12);
    border:1px solid rgba(255,140,140,.55);
    color:var(--bad);
    box-shadow:0 0 12px rgba(255,140,140,.35);
  }
  .statbox{
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
    margin-top:6px;
  }
  .stat{
    background:#0e1536;
    padding:6px;
    border-radius:10px;
    font-size:.8rem;
  }
  .stat .big{
    font-size:22px;
    font-weight:600;
  }

  /* Telemetry grid from the detailed engine */
  .telemetry{margin-top:10px;border-top:1px solid #22305c;padding-top:10px}
  .trow{display:grid;grid-template-columns:170px 1fr 88px;gap:8px;align-items:center;margin:6px 0}
  .tname{color:#b8c4ff;font-size:13px}
  .tval{font-variant-numeric:tabular-nums;font-size:13px;text-align:right}
  .gauge{height:8px;background:#0e1536;border:1px solid #22305c;border-radius:16px;overflow:hidden}
  .gauge>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#6bd1ff,#9bb4ff)}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .clockbox{background:#0e1536;border:1px solid #22305c;border-radius:10px;padding:8px;font-size:12px}

  canvas{
    width:100%;
    height:900px;
    display:block;
    background:radial-gradient(1600px 900px at 50% 50%, #0f1740 0%, #0b1020 60%);
    border-radius:14px;
    border:1px solid #22305c;
  }

  .legend{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
  .legend div{display:flex;align-items:center;gap:8px;color:#b8c4ff;font-size:.8rem}
  .dot{width:12px;height:12px;border-radius:50%}
  .note{color:#b8c4ff;font-size:12px;margin-top:4px}

  textarea{
    resize:vertical;
  }

  /* Status dots for nav channels */
  .nav-status-row{
    display:flex;
    align-items:center;
    gap:8px;
    margin:4px 0;
    font-size:.8rem;
  }
  .nav-status-dot{
    width:11px;
    height:11px;
    border-radius:50%;
    box-shadow:0 0 8px rgba(0,0,0,.6);
  }
  .status-ok{background:#7bffb1;}
  .status-warn{background:#ffd37a;}
  .status-bad{background:#ff8c8c;}

  /* Bottom solar map */
  #mapHolder{
    position:relative;
    width:100%;
    padding-top:54%;
    background:#070b18;
    border-radius:14px;
    border:1px solid #253056;
    overflow:hidden;
  }
  #mapCanvas{
    position:absolute;
    left:0;
    top:0;
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Warp Engine + 4D Backup Navigation (Any Planet)</h1>
  <p class="note">
    Left: 4D backup navigation from Earth to any planet. Right: detailed warp engine with particles,
    labels, and live telemetry. The bottom solar map animates the ship from Earth to the selected planet
    during a Warp Trip. Engine warp automatically accelerates and de-accelerates along the path.
  </p>

  <div class="layout">
    <!-- =============== LEFT: 4D BACKUP NAVIGATION PANEL =============== -->
    <div class="panel" id="navPanel">
      <h2>4D Backup Navigation â€” Earth â†’ Target Planet</h2>
      <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
        Adjust mission time, warp energy, and 4D phase weight to validate a GO / NO-GO warp corridor
        from Earth to your selected planet. All three channels (distance, energy, phase) must pass for GO.
      </p>

      <label>Target Planet</label>
      <select id="targetPlanet">
        <option value="Mercury">Mercury</option>
        <option value="Venus">Venus</option>
        <option value="Earth">Earth</option>
        <option value="Mars" selected>Mars</option>
        <option value="Jupiter">Jupiter</option>
        <option value="Saturn">Saturn</option>
        <option value="Uranus">Uranus</option>
        <option value="Neptune">Neptune</option>
        <option value="Pluto">Pluto</option>
      </select>

      <!-- Planet presets -->
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 4px;">
        <button type="button" class="btn btnPreset" data-preset="innerTour">Inner Tour (Venus)</button>
        <button type="button" class="btn btnPreset" data-preset="marsFast">Mars Window</button>
        <button type="button" class="btn btnPreset" data-preset="jupiterScout">Jupiter Scout</button>
        <button type="button" class="btn btnPreset" data-preset="saturnRing">Saturn Rings</button>
      </div>

      <label>
        Mission Epoch t (days from reference)
        <span id="navTVal" class="miniVal"></span>
      </label>
      <input id="navT" type="range" min="0" max="1200" value="200"/>

      <label>
        Phase Weight kÏ‡ (4D distance)
        <span id="navKchiVal" class="miniVal"></span>
        <span id="navKchiFlag" class="miniVal"></span>
      </label>
      <input id="navKchi" type="range" min="0" max="4" value="1.5" step="0.1"/>

      <label>
        Warp Energy Budget
        <span id="navEwarpVal" class="miniVal"></span>
      </label>
      <input id="navEwarp" type="range" min="0" max="10" value="2" step="0.01"/>

      <div style="display:flex;gap:10px;margin-top:6px;">
        <div>
          <label>
            Distance Tolerance %
            <span id="navTolDistVal" class="miniVal"></span>
          </label>
          <input id="navTolDist" type="number" value="2" min="0.1" step="0.1"/>
        </div>
        <div>
          <label>
            Energy Tolerance %
            <span id="navTolEVal" class="miniVal"></span>
          </label>
          <input id="navTolE" type="number" value="5" min="0.1" step="0.1"/>
        </div>
        <div>
          <label>
            Phase Tolerance (rad)
            <span id="navTolPhaseVal" class="miniVal"></span>
          </label>
          <input id="navTolPhase" type="number" value="0.4" min="0.05" step="0.05"/>
        </div>
      </div>

      <button id="analyzeBtn" class="btn" style="width:100%;margin-top:10px;">Analyze Trip</button>

      <!-- Channel status lights -->
      <div style="margin-top:8px;font-size:.8rem;color:var(--muted);">
        <div class="nav-status-row">
          <div id="statusDistDot" class="nav-status-dot status-bad"></div>
          <div>
            1. 3D vs 4D distance match
            <div style="font-size:.75rem;">
              |d<sub>4D</sub> âˆ’ d<sub>3D</sub>| / d<sub>3D</sub> &lt; tol?
              â†’ <span id="statusDistText">NO</span>
            </div>
          </div>
        </div>
        <div class="nav-status-row">
          <div id="statusEnergyDot" class="nav-status-dot status-bad"></div>
          <div>
            2. Energy profile
            <div style="font-size:.75rem;">
              E<sub>warp</sub> high enough?
              â†’ <span id="statusEnergyText">NO</span>
            </div>
          </div>
        </div>
        <div class="nav-status-row">
          <div id="statusPhaseDot" class="nav-status-dot status-bad"></div>
          <div>
            3. Phase alignment
            <div style="font-size:.75rem;">
              |Î”Ï‡| &lt; phase tol?
              â†’ <span id="statusPhaseText">NO</span>
            </div>
          </div>
        </div>
        <div class="nav-status-row">
          <div id="statusOverallDot" class="nav-status-dot status-bad"></div>
          <div>
            4. Overall GO/NO-GO
            <div style="font-size:.75rem;">
              All three channels green?
              â†’ <span id="statusOverallText">NO-GO</span>
            </div>
          </div>
        </div>
      </div>

      <!-- GO/NO-GO box -->
      <div id="goText" class="go-light nogo" style="margin-top:10px;">
        NO-GO â€” Parameters not validated
      </div>
      <p style="font-size:.75rem;color:var(--muted);margin-top:4px;">
        GO requires: (1) 3D vs 4D distance match within tolerance, (2) warp energy not underpowered,
        (3) phase gap |Î”Ï‡| below the configured limit. Phase Weight kÏ‡ = 0 means the phase axis is
        ignored in the distance metric (flag shows NO).
      </p>

      <!-- === Output metrics === -->
      <div id="metrics" style="font-size:.8rem;line-height:1.4;margin-top:6px;">
        Earth position (AU): ( <span id="mEx">0</span>, <span id="mEy">0</span>, <span id="mEz">0</span> )<br>
        Target position (AU): ( <span id="mTx">0</span>, <span id="mTy">0</span>, <span id="mTz">0</span> )<br>
        Ï‡-phase: Ï‡âŠ•=<span id="mEchi">0</span>, Ï‡t=<span id="mTchi">0</span><br><br>

        3D distance: <span id="mD3">0</span> AU<br>
        4D distance: <span id="mD4">0</span> AU<br>
        Phase gap |Î”Ï‡|: <span id="mPgap">0</span><br>
        Expected Energy: <span id="mEexp">0</span><br>
        Warp Energy: <span id="mEwarpEcho">0</span><br>
        Estimated Warp Travel Time: <span id="mTau">0</span><br>
      </div>

      <h3 style="font-size:.8rem;margin:10px 0 4px;color:var(--muted);">
        Trip Configuration (copy/paste to replay later)
      </h3>
      <textarea id="configOutput" rows="7" readonly
        style="width:100%;font-size:.75rem;background:#0b1128;color:var(--ink);
               border-radius:10px;border:1px solid #26325a;padding:6px;"></textarea>

      <button id="warpTripBtn" class="btn" style="margin-top:8px;width:100%;">ðŸš€ Warp Trip (Animate Engine + Map)</button>
      <p style="font-size:.75rem;color:var(--muted);margin-top:4px;">
        Warp Trip will only activate when status is GO. The engine warp slider will ramp up and down automatically
        while the solar map tracks the ship from Earth to the target planet.
      </p>
    </div>

    <!-- =============== RIGHT: DETAILED WARP ENGINE PANEL =============== -->
    <div class="panel" id="enginePanel">
      <h2>Warp Engine Control & Telemetry</h2>
      <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
        Detailed warp core visualization with magnetic fan, collider ring, compression stages, warp coils,
        entanglement feedback, and thermal management. Telemetry feeds the navigation panel (FTL gain, core temp,
        field shield). Warp slider is also driven automatically during Warp Trips.
      </p>

      <label for="warp">Warp Factor (1 to 10)</label>
      <input id="warp" type="range" min="1" max="10" step="1" value="3"/>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
        <button id="play" class="btn">Play</button>
        <button id="pause" class="btn">Pause</button>
        <button id="reset" class="btn">Reset</button>
        <label style="margin-left:auto;display:flex;align-items:center;gap:6px;font-size:.8rem;">
          <input id="colliderToggle" type="checkbox" checked/> Collider On
        </label>
        <label style="display:flex;align-items:center;gap:6px;font-size:.8rem;">
          <input id="labels" type="checkbox" checked/> Show labels
        </label>
      </div>

      <div class="statbox" style="margin-top:8px;">
        <div class="stat"><div class="big" id="speed">x3.0</div><div>Animation speed</div></div>
        <div class="stat"><div class="big" id="field">1.6 Ã—D</div><div>Field radius vs engine</div></div>
        <div class="stat"><div class="big" id="temp">Warm</div><div>Heat/Cool balance</div></div>
        <div class="stat"><div class="big" id="time">1.00Ã—</div><div>Clock rate (visual)</div></div>
      </div>

      <div class="legend">
        <div><span class="dot" style="background:#9bb4ff"></span> Photon/ion stream</div>
        <div><span class="dot" style="background:#33e1b5"></span> Magnetic field lines</div>
        <div><span class="dot" style="background:#ffcc66"></span> Heat tracers</div>
        <div><span class="dot" style="background:#6bd1ff"></span> Coolant (water) tracers</div>
        <div><span class="dot" style="background:#b26bff"></span> Entanglement particles</div>
        <div><span class="dot" style="background:#ffdca8"></span> Plasma light cone</div>
        <div><span class="dot" style="background:#8aff9b"></span> Detection lasers</div>
      </div>

      <div id="tests" class="note" style="margin-top:6px;">Self-tests runningâ€¦</div>

      <!-- Real-time Telemetry -->
      <div class="telemetry">
        <h2>Real-time Telemetry</h2>
        <div class="trow"><div class="tname">Animation Speed</div><div class="gauge"><span id="g_speed"></span></div><div id="v_speed" class="tval">x1.0</div></div>
        <div class="trow"><div class="tname">Field Radius (Ã—D)</div><div class="gauge"><span id="g_field"></span></div><div id="v_field" class="tval">1.20</div></div>
        <div class="trow"><div class="tname">Field Shield (%)</div><div class="gauge"><span id="g_fshield"></span></div><div id="v_fshield" class="tval">0%</div></div>
        <div class="trow"><div class="tname">Field Stretch (rx/ry)</div><div class="gauge"><span id="g_fstretch"></span></div><div id="v_fstretch" class="tval">0/0</div></div>

        <div class="trow"><div class="tname">Clock Rate (warp)</div><div class="gauge"><span id="g_clock"></span></div><div id="v_clock" class="tval">1.00Ã—</div></div>

        <div class="trow"><div class="tname">Photon/Ion Rate</div><div class="gauge"><span id="g_phot"></span></div><div id="v_phot" class="tval">0/s</div></div>
        <div class="trow"><div class="tname">Collider Beam Flux</div><div class="gauge"><span id="g_collider"></span></div><div id="v_collider" class="tval">0/s</div></div>
        <div class="trow"><div class="tname">Mag Field Strength</div><div class="gauge"><span id="g_mag"></span></div><div id="v_mag" class="tval">0.0</div></div>

        <div class="trow"><div class="tname">Core Temp (Â°C)</div><div class="gauge"><span id="g_tcore"></span></div><div id="v_tcore" class="tval">0Â°C</div></div>
        <div class="trow"><div class="tname">Coolant Temp (Â°C)</div><div class="gauge"><span id="g_tcool"></span></div><div id="v_tcool" class="tval">0Â°C</div></div>

        <div class="trow"><div class="tname">Entangle Particles</div><div class="gauge"><span id="g_ent"></span></div><div id="v_ent" class="tval">0 M/s</div></div>
        <div class="trow"><div class="tname">Plasma Cone Len</div><div class="gauge"><span id="g_plen"></span></div><div id="v_plen" class="tval">0 u</div></div>
        <div class="trow"><div class="tname">Plasma Cone Rad</div><div class="gauge"><span id="g_prad"></span></div><div id="v_prad" class="tval">0 u</div></div>
        <div class="trow"><div class="tname">Plasma Wave Intensity</div><div class="gauge"><span id="g_pwave"></span></div><div id="v_pwave" class="tval">0.0</div></div>

        <div class="trow"><div class="tname">Effective FTL Gain (sim)</div><div class="gauge"><span id="g_ftl"></span></div><div id="v_ftl" class="tval">1.00Ã—</div></div>

        <div class="subgrid">
          <div class="clockbox"><div><strong>Outside Time (UTC)</strong></div><div id="clk_utc">--:--:--</div></div>
          <div class="clockbox"><div><strong>Engine Sync (CST)</strong></div><div id="clk_cst">--:--:--</div></div>
          <div class="clockbox" style="grid-column:1 / span 2"><div><strong>Warp-Adjusted Time</strong> (scaled by clock rate)</div><div id="clk_warp">--:--:--</div></div>
        </div>
      </div>

      <canvas id="view" width="1600" height="900"></canvas>
    </div>
  </div> <!-- /layout -->

  <!-- =============== BOTTOM: SOLAR MAP PANEL =============== -->
  <div class="panel" style="margin-top:12px;">
    <h2>Solar Map â€” Earth + Target Only (4D Projection)</h2>
    <p style="font-size:.8rem;color:var(--muted);margin-top:-4px;">
      Top-down heliocentric slice. Earth and the target planet are shown with their orbits;
      when you launch a Warp Trip, the travel line and ship marker animate along the corridor.
    </p>
    <div id="mapHolder">
      <canvas id="mapCanvas" width="1800" height="900"></canvas>
    </div>
  </div>
</div> <!-- /wrap -->
<script>
// ===== Warp Engine Script (detailed visuals, FTL gain exposed) =====
const TAU = Math.PI*2;
const lerp = (a,b,t)=>a+(b-a)*t;
function drawText(ctx, s, x, y, align){
  ctx.fillStyle='#eaf0ff';
  ctx.textAlign=align||'left';
  ctx.textBaseline='middle';
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillText(s,x,y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function fmt(n,dec){ return n.toFixed(dec||0); }
function fmtLarge(n){
  var a=Math.abs(n);
  if(a>=1e12) return (n/1e12).toFixed(2)+' T';
  if(a>=1e9)  return (n/1e9).toFixed(2)+' G';
  if(a>=1e6)  return (n/1e6).toFixed(2)+' M';
  if(a>=1e3)  return (n/1e3).toFixed(1)+' K';
  return n.toFixed(0);
}

// Helpers
function computeSpeedMult(w){ return lerp(1, 6, (w-1)/9); }
function computeFieldRadius(w){ return lerp(1.2, 2.6, (w-1)/9); }
function computeClockRate(w){ return 1/lerp(1, 1.6, (w-1)/9); }
function computeHeatLevel(w){ return lerp(0.35, 1.0, (w-1)/9); }
function computeCoolLevel(w){ return 1 - computeHeatLevel(w)*0.5; }
function computePlasmaLength(w){ return Math.round( lerp(90, 260, (w-1)/9) ); }
function computePlasmaRadius(w){ return Math.round( lerp(10, 36, (w-1)/9) ); }
function computeEntangleRate(w){ return lerp(0.6, 3.2, (w-1)/9); }
function computeFieldAspectX(w){ return lerp(1.0, 1.9, (w-1)/9); }
function computeFieldAspectY(w){ return lerp(0.9, 0.6, (w-1)/9); }
function computeStability(w){ var s = 1 - (w-1)/12; if(s<0.55) s=0.55; return s; }
function computeCoreTempC(w,fps){ return Math.round( 200 + computeHeatLevel(w)*1000 + computeSpeedMult(w)*40 ); }
function computeCoolantTempC(w,fps){ return Math.round( 25 + computeCoolLevel(w)*300 ); }

// Layout
const layout = {
  centerY: 450,
  startX: 110,
  length: 900,
  bodyR: 120,
  fanX: 85,
  stages: [
    {len:160, r:120, name:'Intake / Pre-Compression'},
    {len:120, r:112, name:'Compression Stage A'},
    {len:100, r:104, name:'Compression Stage B'},
    {len: 80, r: 96, name:'Compression Stage C'},
    {len: 70, r: 88, name:'Warp Coils / Field Shapers'},
    {len: 70, r: 80, name:'Reactors (Electro-Plasma)'},
    {len: 60, r: 72, name:'Photon/Plasma Mixer'},
    {len: 50, r: 64, name:'Nozzle Coupler'}
  ],
  nozzle:{len:160, r0:60, r1:14, name:'Exhaust Nozzle'},
  coils:[{xOff:-18, name:'Field Coil L'},{xOff:36, name:'Field Coil R'}]
};
let xLayout = layout.startX;
layout.stages = layout.stages.map(function(s){
  var out={x0:xLayout,x1:xLayout+s.len,len:s.len,r:s.r,name:s.name};
  xLayout+=s.len;
  return out;
});
layout.nozzle.x0 = xLayout;
layout.nozzle.x1 = xLayout + layout.nozzle.len;

// State
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let running = true;
let t0 = performance.now();
let fanAngle = 0;
let fps = 60;
let warpClock = Date.now();
let particles = [], heat = [], cool = [], entangle = [], pipes = [];

const warpEl = document.getElementById('warp');
const colliderEl = document.getElementById('colliderToggle');
const speedEl = document.getElementById('speed');
const fieldEl = document.getElementById('field');
const tempEl = document.getElementById('temp');
const timeEl = document.getElementById('time');
const labelsEl = document.getElementById('labels');

// Telemetry DOM
const v_speed=document.getElementById('v_speed'), g_speed=document.getElementById('g_speed');
const v_field=document.getElementById('v_field'), g_field=document.getElementById('g_field');
const v_fshield=document.getElementById('v_fshield'), g_fshield=document.getElementById('g_fshield');
const v_fstretch=document.getElementById('v_fstretch'), g_fstretch=document.getElementById('g_fstretch');
const v_clock=document.getElementById('v_clock'), g_clock=document.getElementById('g_clock');
const v_phot=document.getElementById('v_phot'), g_phot=document.getElementById('g_phot');
const v_collider=document.getElementById('v_collider'), g_collider=document.getElementById('g_collider');
const v_mag=document.getElementById('v_mag'), g_mag=document.getElementById('g_mag');
const v_ent=document.getElementById('v_ent'), g_ent=document.getElementById('g_ent');
const v_plen=document.getElementById('v_plen'), g_plen=document.getElementById('g_plen');
const v_prad=document.getElementById('v_prad'), g_prad=document.getElementById('g_prad');
const v_pwave=document.getElementById('v_pwave'), g_pwave=document.getElementById('g_pwave');
const v_tcore=document.getElementById('v_tcore'), g_tcore=document.getElementById('g_tcore');
const v_tcool=document.getElementById('v_tcool'), g_tcool=document.getElementById('g_tcool');
const v_ftl=document.getElementById('v_ftl'), g_ftl=document.getElementById('g_ftl');
const clkUTC=document.getElementById('clk_utc');
const clkCST=document.getElementById('clk_cst');
const clkWarp=document.getElementById('clk_warp');

function warpFactor(){ return parseInt(warpEl.value,10); }
function speedMult(){ return computeSpeedMult(warpFactor()); }
function fieldRadius(){ return computeFieldRadius(warpFactor()); }
function clockRate(){ return computeClockRate(warpFactor()); }
function heatLevel(){ return computeHeatLevel(warpFactor()); }
function coolLevel(){ return computeCoolLevel(warpFactor()); }
function colliderEnabled(){ return colliderEl ? colliderEl.checked : true; }

function updateHUD(){
  speedEl.textContent = 'x'+speedMult().toFixed(1);
  fieldEl.textContent = fieldRadius().toFixed(1)+' Ã—D';
  tempEl.textContent = heatLevel()>0.7? 'Hot' : (heatLevel()>0.5? 'Warm' : 'Cool');
  timeEl.textContent = clockRate().toFixed(2)+'Ã—';
}
updateHUD();
warpEl.addEventListener('input', updateHUD);

// expose HUD update so nav script can call when animating warp
window._updateWarpHUD = updateHUD;

document.getElementById('pause').onclick=function(){running=false;};
document.getElementById('play').onclick=function(){
  if(!running){
    running=true;
    t0=performance.now();
    loop();
  }
};
document.getElementById('reset').onclick=function(){
  particles.length=0;
  heat.length=0;
  cool.length=0;
  entangle.length=0;
  pipes.length=0;
  fanAngle=0;
  initPipes();
};

function spawnParticle(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.6;
  var x0 = layout.startX+10;
  var v = 0.6 + Math.random()*0.7;
  particles.push({x:x0,y:y,v:v,life:0});
}
function spawnHeat(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.4;
  var xh = layout.stages[4].x0 + Math.random()*(layout.nozzle.x1 - layout.stages[4].x0);
  heat.push({x:xh,y:y,life:0});
}
function spawnCool(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.7;
  var xc = layout.stages[0].x0 + Math.random()*(layout.stages[2].x1-layout.stages[0].x0);
  cool.push({x:xc,y:y,life:0});
}
function spawnEntangle(){
  var baseX = layout.stages[5].x0 + Math.random()*40;
  var phase = Math.random()*TAU;
  entangle.push({x:baseX, y:layout.centerY, phase:phase, life:0});
}
function initPipes(){
  pipes = [];
  for(var i=0;i<layout.stages.length-1;i++){
    var s = layout.stages[i];
    var nx = s.x1;
    pipes.push({x0:nx-6,y0:layout.centerY+28,x1:nx+6,y1:layout.centerY+28,phase:Math.random()*TAU});
  }
}
initPipes();

function drawCylinder(x0,x1,rTop,rBot){
  var grd = ctx.createLinearGradient(0, layout.centerY-rTop, 0, layout.centerY+rBot);
  grd.addColorStop(0, '#2a334d');
  grd.addColorStop(0.5,'#9fb1ff22');
  grd.addColorStop(1, '#0e132b');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY + rBot);
  ctx.lineTo(x0, layout.centerY + rBot);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.strokeStyle = '#cfe2ff33';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x1, layout.centerY-rTop);
  ctx.lineTo(x1, layout.centerY+rBot);
  ctx.stroke();
}
function drawNozzle(nz){
  var x0=nz.x0,x1=nz.x1,r0=nz.r0,r1=nz.r1;
  var grd = ctx.createLinearGradient(x0,layout.centerY,x1,layout.centerY);
  grd.addColorStop(0,'#2a334d');
  grd.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - r0);
  ctx.lineTo(x1, layout.centerY - r1);
  ctx.lineTo(x1, layout.centerY + r1);
  ctx.lineTo(x0, layout.centerY + r0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
}
function drawCoil(xOff){
  var x = layout.startX + xOff;
  ctx.strokeStyle='#a6b8ffaa';
  ctx.lineWidth=8;
  ctx.beginPath();
  ctx.moveTo(x, layout.centerY-48);
  ctx.lineTo(x, layout.centerY+48);
  ctx.stroke();
  ctx.lineWidth=3;
  ctx.strokeStyle='#5ea8ffaa';
  for(var i=-3;i<=3;i++){
    ctx.beginPath();
    ctx.arc(x, layout.centerY + i*12, 22+Math.abs(i)*2, 0, TAU);
    ctx.stroke();
  }
}
function drawFan(angle){
  var cx = layout.fanX, cy = layout.centerY;
  ctx.fillStyle='#a4b2d8';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, TAU);
  ctx.fill();
  for(var i=0;i<6;i++){
    var a = angle + i*TAU/6;
    var r1=14, r2=52;
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath();
    ctx.fill();
  }
}
function drawField(){
  var D = layout.bodyR*2;
  var base = fieldRadius()*D*0.35;
  var ax = computeFieldAspectX(warpFactor());
  var ay = computeFieldAspectY(warpFactor());
  ctx.strokeStyle='#33e1b588';
  ctx.lineWidth=2;
  var cx = layout.startX+layout.length*0.65;
  for(var i=0;i<6;i++){
    var rx = base*ax + i*22;
    var ry = base*ay + i*10;
    ctx.beginPath();
    ctx.ellipse(cx, layout.centerY, rx, ry, 0, 0, TAU);
    ctx.stroke();
  }
}
function drawTimeLegendLeft(){
  var x=40;
  var y=120;
  var lines=['UTC','CST (engine sync)','Interstellar Time','Universal Time','UTA'];
  for(var i=0;i<lines.length;i++){
    drawText(ctx, lines[i], x, y+i*20, 'left');
  }
}
function drawCSTClock(){
  var x = layout.stages[3].x0+12;
  var y = layout.centerY-22;
  ctx.fillStyle='#0e1536';
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.fillRect(x,y,150,32);
  ctx.strokeRect(x,y,150,32);
  drawText(ctx,'Atomic Clock (CST)', x+6, y+16, 'left');
}
function drawStatusLabel(){
  var x = layout.nozzle.x0-40;
  var y = layout.centerY- layout.bodyR - 58;
  var warp = warpFactor();
  var stab = computeStability(warp);
  var s = 'Warp '+warp+' | Stability '+stab.toFixed(2);
  drawText(ctx, s, x, y, 'left');
}
function labelFromTo(text, ax, ay, tx, ty){
  ctx.strokeStyle='#9bb4ff66';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(ax,ay);
  ctx.lineTo(tx,ty);
  ctx.stroke();
  drawText(ctx, text, tx+4, ty, 'left');
}

// Labels (engine + research components)
function drawLabels(){
  const topY = layout.centerY - layout.bodyR - 42;
  const botY = layout.centerY + layout.bodyR + 44;

  const s0=layout.stages[0], s1=layout.stages[1], s2=layout.stages[2],
        s3=layout.stages[3], s4=layout.stages[4], s5=layout.stages[5],
        s6=layout.stages[6];

  labelFromTo('Vacuum Intake', s0.x0+12, layout.centerY- s0.r, s0.x0-80, topY-6);
  labelFromTo('Magnetic Fan (negative-energy modulator)', layout.fanX, layout.centerY-34, s0.x0-80, topY+12);
  labelFromTo('Fusion Ignition / Pre-Heat', s0.x0+40, layout.centerY- s0.r+16, s0.x0-60, topY+196);
  labelFromTo('Particle Collider Ring (photon+ion)', s1.x0-8, layout.centerY- s1.r+10, s1.x0+40, topY+216);
  labelFromTo('Modulates Vacuum Air Circulation', s1.x0+6, layout.centerY- s1.r, s1.x0-10, topY+34);
  labelFromTo('Compression A/B/C', s2.x1-10, layout.centerY- s2.r, s2.x0-30, topY+54);
  labelFromTo('Modulates Vacuum Fluctuation', s4.x0+6, layout.centerY- s4.r, s4.x0-18, topY+74);
  labelFromTo('Reactors (Electro-plasma)', s5.x0+10, layout.centerY- s5.r, s5.x0+80, topY+94);
  labelFromTo('Photon/Plasma Mixer', s6.x0+10, layout.centerY- s6.r, s6.x0+140, topY+114);

  labelFromTo('Entanglement Feedback Loop', s5.x0+24, layout.centerY+16, s5.x0-40, botY);
  labelFromTo('Atomic Clocks (CST) + Entangled Feedback', s3.x0+20, layout.centerY, s3.x0-80, botY+24);
  labelFromTo('Pulse Control', s4.x1-8, layout.centerY+8, s4.x1+30, botY+48);
  labelFromTo('AFT Power Ramp', layout.nozzle.x0-10, layout.centerY+6, layout.nozzle.x0+40, botY+72);
  labelFromTo('AFT Power Ramp (Gradually)', layout.nozzle.x0+20, layout.centerY+22, layout.nozzle.x0+150, botY+96);
  labelFromTo('Gravitational Stabilization Panel', s2.x0+20, layout.centerY+ s2.r, s2.x0-40, botY+120);
  labelFromTo('Quantum Vertex Dampers (F/R/U/D/L/R)', s4.x0+20, layout.centerY+ s4.r, s4.x0+140, botY+144);
  labelFromTo('Detection Lasers (particles)', s1.x1-10, layout.centerY+ s1.r, s1.x1+110, botY+168);
  labelFromTo('Thermal Management (Water Cooling)', s5.x1-8, layout.centerY+ s5.r, s5.x1+160, botY+192);

  // NEW research components
  labelFromTo('ZPF Oscillator Rings (ZPO)', s4.x0+12, layout.centerY- s4.r+10, s4.x0-130, topY+136);
  labelFromTo('Casimir Microarrays', s3.x1-6, layout.centerY- s3.r+6, s3.x1+28, topY+156);
  labelFromTo('Tachyon Feedback Node', s5.x0+6, layout.centerY+12, s5.x0-140, botY+210);
  labelFromTo('CTC Guard (CST Damping)', s3.x0+8, layout.centerY+8, s3.x0-160, botY+234);
  labelFromTo('Positron Diagnostic Port', s6.x1-6, layout.centerY- s6.r+6, s6.x1+70, topY+176);
  labelFromTo('Limestoneâ€“Granite Resonator', s0.x0+20, layout.centerY+ s0.r-8, s0.x0-60, botY+208);

  const cx = layout.startX+layout.length*0.65;
  labelFromTo('Temporal vs Spatial Warp (rx/ry vs clock)',
    cx, layout.centerY - computeFieldRadius(warpFactor())*layout.bodyR*0.35 - 22,
    cx-180, topY-20);
  labelFromTo('Exotic-Matter Bypass (EM stress / Casimir)',
    s4.x1-6, layout.centerY+ s4.r-10,
    s4.x1+60, botY+180);
}

function drawCoreGlow(){
  var g = ctx.createLinearGradient(layout.startX, layout.centerY, layout.nozzle.x1, layout.centerY);
  g.addColorStop(0,'#a9bbff00');
  g.addColorStop(0.4,'#9bb4ff22');
  g.addColorStop(0.8,'#eaf0ff44');
  ctx.fillStyle=g;
  ctx.fillRect(layout.startX, layout.centerY-12, layout.nozzle.x1-layout.startX, 24);
}
function drawPlasmaCone(){
  var len = computePlasmaLength(warpFactor());
  var baseR = computePlasmaRadius(warpFactor());
  var x0 = layout.nozzle.x1;
  var x1 = x0 + len;
  var grad = ctx.createLinearGradient(x0, layout.centerY, x1, layout.centerY);
  grad.addColorStop(0, 'rgba(255,220,168,0.65)');
  grad.addColorStop(0.3, 'rgba(255,220,168,0.35)');
  grad.addColorStop(1, 'rgba(255,220,168,0.02)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - baseR);
  ctx.lineTo(x1, layout.centerY - baseR*0.35);
  ctx.lineTo(x1, layout.centerY + baseR*0.35);
  ctx.lineTo(x0, layout.centerY + baseR);
  ctx.closePath();
  ctx.fill();
}
function drawPipes(){
  for(var i=0;i<pipes.length;i++){
    var p = pipes[i];
    ctx.strokeStyle='#6bd1ff';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x0, p.y0);
    ctx.lineTo(p.x1, p.y1);
    ctx.stroke();
    var n=4;
    for(var k=0;k<n;k++){
      var t = ((k/n) + (performance.now()*0.0005) ) % 1;
      var xx = p.x0 + (p.x1-p.x0)*t;
      var yy = p.y0 + (p.y1-p.y0)*t;
      ctx.fillStyle='#9bb4ff';
      ctx.beginPath();
      ctx.arc(xx, yy, 2, 0, TAU);
      ctx.fill();
    }
  }
}
function drawCoolingLoops(){
  var y = layout.centerY + layout.bodyR - 16;
  ctx.strokeStyle='#6bd1ff';
  ctx.lineWidth=2;
  ctx.beginPath();
  var x0 = layout.startX+10;
  ctx.moveTo(x0,y);
  for(var x1 = x0; x1 < layout.nozzle.x0-10; x1 += 32){
    ctx.lineTo(x1+16, y+6);
    ctx.lineTo(x1+32, y);
  }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=1;
  var cxF = layout.startX - 20;
  var cxR = layout.nozzle.x1 + 20;
  var cy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(cxF, cy-44);
  ctx.lineTo(cxF-34, cy-44);
  ctx.moveTo(cxF, cy+44);
  ctx.lineTo(cxF-34, cy+44);
  ctx.moveTo(cxR, cy-34);
  ctx.lineTo(cxR+34, cy-34);
  ctx.moveTo(cxR, cy+34);
  ctx.lineTo(cxR+34, cy+34);
  ctx.stroke();
  var ccx = layout.startX+layout.length*0.65;
  var ccy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(ccx-16, ccy);
  ctx.lineTo(ccx+16, ccy);
  ctx.moveTo(ccx, ccy-16);
  ctx.lineTo(ccx, ccy+16);
  ctx.stroke();
}

// Fusion & collider visuals
function drawFusionZone(){
  const s0 = layout.stages[0];
  const cy = layout.centerY;
  const x0 = s0.x0 + 26;
  const x1 = s0.x0 + 86;
  const cx = (x0 + x1) / 2;
  const ry = s0.r * 0.55;
  const rx = (x1 - x0) * 0.55;

  const grd = ctx.createRadialGradient(cx, cy, 4, cx, cy, ry);
  grd.addColorStop(0, 'rgba(255,200,140,0.95)');
  grd.addColorStop(0.4, 'rgba(255,160,90,0.55)');
  grd.addColorStop(1, 'rgba(255,140,80,0.04)');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, TAU);
  ctx.fill();

  ctx.strokeStyle = '#ffcc6699';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, TAU);
  ctx.stroke();
}
function drawColliderRing(){
  const s1 = layout.stages[1];
  const cx = s1.x0 - 18;
  const cy = layout.centerY;
  const R = layout.bodyR * 0.78;

  ctx.strokeStyle = '#b26bffcc';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, TAU);
  ctx.stroke();

  const t = performance.now() * 0.0015;
  ctx.strokeStyle = '#9bb4ffcc';
  ctx.lineWidth = 1.5;
  for(let i=0;i<3;i++){
    const phase = t + i * TAU/3;
    ctx.beginPath();
    for(let a=0;a<=TAU;a+=0.15){
      const r = R + Math.sin(a*3 + phase) * 4;
      const px = cx + Math.cos(a)*r;
      const py = cy + Math.sin(a)*r;
      if(a === 0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
}

function setGauge(span, frac){
  if(!span) return;
  span.style.width = (clamp(frac,0,1)*100).toFixed(0)+'%';
}

// Update Telemetry + globals for nav
function updateTelemetry(dt){
  var w = warpFactor();
  var sm = speedMult();
  var fr = fieldRadius();
  var cr = clockRate();
  var hl = heatLevel();
  var cl = coolLevel();
  var entRate = computeEntangleRate(w);

  var instFps = (dt>0)? 1000/dt : 60;
  fps = fps*0.9 + instFps*0.1;

  var p_phot = 0.7*sm;
  var p_heat = 0.25*sm*hl;
  var p_cool = 0.25*sm*cl;
  var p_ent = 0.25*entRate;

  var perSec = function(p){ return p * fps; };

  var mag = fr*sm;
  var pWave = (0.2*sm);

  var shieldFrac = (fr-1.2)/(2.6-1.2);

  var D = layout.bodyR*2;
  var base = fr*D*0.35;
  var ax = computeFieldAspectX(w);
  var ay = computeFieldAspectY(w);
  var rx = base*ax + 2*22;
  var ry = base*ay + 2*10;

  var coreC = computeCoreTempC(w,fps);
  var coolC = computeCoolantTempC(w,fps);

  var colliderBase = colliderEnabled() ? (0.6*sm*entRate) : 0;
  var colliderPerSec = perSec(colliderBase);

  // Tuned Effective FTL Gain (sim)
  var baseGain = w;
  var entBonus = 0.18 * entRate * (w / 10);
  var colliderBonus = 0;
  if (colliderEnabled()) {
    var x = Math.max(0, w - 4);
    colliderBonus = 0.4 + 0.15 * x * x;
  }
  var ftlGain = baseGain + entBonus + colliderBonus;

  // Expose to global for nav panel
  window._ftlGainSim = ftlGain;
  window._warpCoreTempC = coreC;
  window._shieldFracSim = clamp(shieldFrac,0,1);

  if(v_speed){ v_speed.textContent = 'x'+sm.toFixed(1); setGauge(g_speed, (sm-1)/(6-1)); }
  if(v_field){ v_field.textContent = fr.toFixed(2); setGauge(g_field, shieldFrac); }
  if(v_fshield){ v_fshield.textContent = Math.round(shieldFrac*100)+'%'; setGauge(g_fshield, shieldFrac); }
  if(v_fstretch){ v_fstretch.textContent = fmt(rx,0)+' / '+fmt(ry,0); setGauge(g_fstretch, clamp(rx/(base*1.9+2*22),0,1)); }

  if(v_clock){ v_clock.textContent = cr.toFixed(2)+'Ã—'; setGauge(g_clock, 1-cr); }
  if(v_phot){ v_phot.textContent = fmtLarge(perSec(p_phot))+' /s'; setGauge(g_phot, Math.min(perSec(p_phot)/3000,1)); }

  if(v_collider){
    v_collider.textContent = colliderPerSec>0 ? (fmtLarge(colliderPerSec)+' /s') : '0/s';
    setGauge(g_collider, colliderPerSec>0 ? Math.min(colliderPerSec/5000,1) : 0);
  }

  if(v_mag){ v_mag.textContent = mag.toFixed(2); setGauge(g_mag, Math.min(mag/6.0,1)); }

  if(v_tcore){ v_tcore.textContent = coreC+' Â°C'; setGauge(g_tcore, Math.min(coreC/1500,1)); }
  if(v_tcool){ v_tcool.textContent = coolC+' Â°C'; setGauge(g_tcool, Math.min(coolC/400,1)); }

  var entPerSec = perSec(p_ent);
  var entScaled = entPerSec>=1e9? (entPerSec/1e9).toFixed(2)+' G/s'
                : entPerSec>=1e6? (entPerSec/1e6).toFixed(2)+' M/s'
                : Math.round(entPerSec)+' /s';
  if(v_ent){ v_ent.textContent = entScaled; setGauge(g_ent, Math.min(entPerSec/3.2e6,1)); }

  var plen = computePlasmaLength(w);
  if(v_plen){ v_plen.textContent = plen+' u'; setGauge(g_plen, (plen-90)/(260-90)); }
  var prad = computePlasmaRadius(w);
  if(v_prad){ v_prad.textContent = prad+' u'; setGauge(g_prad, (prad-10)/(36-10)); }
  if(v_pwave){ v_pwave.textContent = pWave.toFixed(2); setGauge(g_pwave, Math.min(pWave/1.2,1)); }

  if(v_ftl){
    v_ftl.textContent = ftlGain.toFixed(2)+'Ã—';
    setGauge(g_ftl, clamp((ftlGain-1)/19, 0, 1));
  }

  var now = Date.now();
  if(clkUTC){ clkUTC.textContent = new Date(now).toLocaleTimeString('en-US', {hour12:false,timeZone:'UTC'}); }
  if(clkCST){ clkCST.textContent = new Date(now).toLocaleTimeString('en-US', {hour12:false,timeZone:'America/Chicago'}); }
  warpClock += (dt * cr);
  if(clkWarp){ clkWarp.textContent = new Date(warpClock).toLocaleTimeString('en-US', {hour12:false}); }
}

function render(dt){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  drawField();
  for(var i=0;i<layout.stages.length;i++){
    var s = layout.stages[i];
    drawCylinder(s.x0, s.x1, s.r, s.r);
  }
  drawNozzle(layout.nozzle);
  drawCoreGlow();
  for(var j=0;j<layout.coils.length;j++){
    drawCoil(layout.coils[j].xOff);
  }
  drawFan(fanAngle);

  drawFusionZone();
  if(colliderEnabled()){
    drawColliderRing();
  }

  var pmult = speedMult();
  if(Math.random()<0.7*pmult) spawnParticle();
  for(var p=0;p<particles.length;p++){
    var pt = particles[p];
    pt.x += (1.9*pmult + pt.v)*1.2;
    pt.y += Math.sin((pt.x+pt.y)*0.01)*0.22*pmult;
    pt.life += dt;
  }
  particles = particles.filter(function(pt){ return pt.x < layout.nozzle.x1+560; });
  ctx.fillStyle='#9bb4ff';
  for(var q=0;q<particles.length;q++){
    ctx.globalAlpha=0.7;
    ctx.fillRect(particles[q].x, particles[q].y, 3, 2);
    ctx.globalAlpha=1;
  }

  if(Math.random()<0.25*pmult*heatLevel()) spawnHeat();
  if(Math.random()<0.25*pmult*coolLevel()) spawnCool();
  for(var h=0;h<heat.length;h++){
    heat[h].life+=dt;
    heat[h].x+= 1.0*pmult;
  }
  for(var c0=0;c0<cool.length;c0++){
    cool[c0].life+=dt;
    cool[c0].x+= 0.7*pmult;
  }
  heat = heat.filter(function(it){ return it.x<layout.nozzle.x1; });
  cool = cool.filter(function(it){ return it.x<layout.stages[3].x1; });
  for(var h2=0;h2<heat.length;h2++){
    ctx.fillStyle='#ffcc66';
    ctx.beginPath();
    ctx.arc(heat[h2].x,heat[h2].y,2+Math.sin(heat[h2].life*0.02)*1.5,0,TAU);
    ctx.fill();
  }
  for(var c2=0;c2<cool.length;c2++){
    ctx.fillStyle='#6bd1ff';
    ctx.beginPath();
    ctx.arc(cool[c2].x,c2[c2].y,2+Math.cos(cool[c2].life*0.02)*1.2,0,TAU);
    ctx.fill();
  }

  if(Math.random()<computeEntangleRate(warpFactor())*0.25) spawnEntangle();
  for(var e=0;e<entangle.length;e++){
    var en = entangle[e];
    en.life+=dt;
    en.x += 1.2*pmult;
    var amp = 26 + 8*Math.sin(en.life*0.01);
    var wv = 0.026*pmult;
    var yy = layout.centerY + Math.sin(en.phase + en.x*wv)*amp;
    ctx.fillStyle='#b26bff';
    ctx.beginPath();
    ctx.arc(en.x, yy, 2.2, 0, TAU);
    ctx.fill();
  }
  entangle = entangle.filter(function(en){ return en.x < layout.nozzle.x1 + 300; });

  drawPlasmaCone();
  drawPipes();
  drawCoolingLoops();
  drawLasers();

  drawTimeLegendLeft();
  drawCSTClock();
  drawStatusLabel();
  if(labelsEl.checked) drawLabels();
}

function loop(){
  if(!running) return;
  var now = performance.now();
  var dt = now - t0;
  t0 = now;
  fanAngle += 0.005 * dt * speedMult();
  render(dt);
  updateTelemetry(dt);
  requestAnimationFrame(loop);
}
loop();

// Self-tests
(function runTests(){
  var results = [];
  function ok(name,cond){ results.push((cond?'PASS ':'FAIL ')+name); }
  ok('speed increases', computeSpeedMult(10) > computeSpeedMult(1));
  ok('field grows', computeFieldRadius(10) > computeFieldRadius(1));
  ok('plasma length grows', computePlasmaLength(10) > computePlasmaLength(1));
  ok('plasma radius grows', computePlasmaRadius(10) > computePlasmaRadius(1));
  ok('entangle rate grows', computeEntangleRate(10) > computeEntangleRate(1));
  ok('field stretches wider', computeFieldAspectX(10) > computeFieldAspectX(1));
  var el = document.getElementById('tests');
  if(el){ el.textContent = 'Self-tests: ' + results.join(' | '); }
})();
</script>
<script>
/* ===== 4D Backup Navigation + Solar Map + Warp Trip coupling to engine ===== */
(function(){
  /* --- Planet orbital database --- */
  const PLANETS = {
    Mercury:{a:0.387, T:87.97},
    Venus:{a:0.723, T:224.70},
    Earth:{a:1.000, T:365.25},
    Mars:{a:1.524, T:686.98},
    Jupiter:{a:5.203, T:4332.59},
    Saturn:{a:9.537, T:10759.22},
    Uranus:{a:19.191, T:30688.5},
    Neptune:{a:30.068, T:60182.0},
    Pluto:{a:39.482, T:90560.0}
  };

  /* Simple GO-friendly presets (tDays=0 => phases aligned) */
  const PRESETS = {
    innerTour: {
      label:'Inner Tour (Venus)',
      target:'Venus',
      tDays:0,
      kChi:1.2,
      Ewarp:2.2,
      tolD:2,
      tolE:10,
      tolP:0.40
    },
    marsFast: {
      label:'Mars Window',
      target:'Mars',
      tDays:0,
      kChi:1.5,
      Ewarp:1.4,
      tolD:2,
      tolE:5,
      tolP:0.40
    },
    jupiterScout: {
      label:'Jupiter Scout',
      target:'Jupiter',
      tDays:0,
      kChi:1.4,
      Ewarp:9.0,
      tolD:5,
      tolE:20,
      tolP:0.50
    },
    saturnRing: {
      label:'Saturn Rings',
      target:'Saturn',
      tDays:0,
      kChi:1.4,
      Ewarp:10.0,
      tolD:6,
      tolE:60,
      tolP:0.60
    }
  };

  function wrapPhase(a){
    const t=2*Math.PI;
    a=a%t;
    if(a>Math.PI)a-=t;
    if(a<=-Math.PI)a+=t;
    return a;
  }

  function getPos(planet, tDays){
    const P=PLANETS[planet];
    const ang=2*Math.PI*(tDays/P.T);
    return {
      x:P.a * Math.cos(ang),
      y:P.a * Math.sin(ang),
      z:0,
      chi:wrapPhase(ang)
    };
  }

  function clampNav(v,a,b){return v<a?a:(v>b?b:v);}
  function fmtNav(x,d){return x.toFixed(d);}

  /* --- Navigation DOM --- */
  const navTargetEl     = document.getElementById('targetPlanet');
  const navTEl          = document.getElementById('navT');
  const navKchiEl       = document.getElementById('navKchi');
  const navEwarpEl      = document.getElementById('navEwarp');
  const navTolDistEl    = document.getElementById('navTolDist');
  const navTolEEl       = document.getElementById('navTolE');
  const navTolPhaseEl   = document.getElementById('navTolPhase');
  const analyzeBtn      = document.getElementById('analyzeBtn');
  const goText          = document.getElementById('goText');
  const configOutputEl  = document.getElementById('configOutput');
  const warpTripBtn     = document.getElementById('warpTripBtn');

  const navTVal         = document.getElementById('navTVal');
  const navKchiVal      = document.getElementById('navKchiVal');
  const navKchiFlag     = document.getElementById('navKchiFlag');
  const navEwarpVal     = document.getElementById('navEwarpVal');
  const navTolDistVal   = document.getElementById('navTolDistVal');
  const navTolEVal      = document.getElementById('navTolEVal');
  const navTolPhaseVal  = document.getElementById('navTolPhaseVal');

  const mEx   = document.getElementById('mEx');
  const mEy   = document.getElementById('mEy');
  const mEz   = document.getElementById('mEz');
  const mTx   = document.getElementById('mTx');
  const mTy   = document.getElementById('mTy');
  const mTz   = document.getElementById('mTz');
  const mEchi = document.getElementById('mEchi');
  const mTchi = document.getElementById('mTchi');
  const mD3   = document.getElementById('mD3');
  const mD4   = document.getElementById('mD4');
  const mPgap = document.getElementById('mPgap');
  const mEexp = document.getElementById('mEexp');
  const mEwarpEcho = document.getElementById('mEwarpEcho');
  const mTau  = document.getElementById('mTau');

  const statusDistDot = document.getElementById('statusDistDot');
  const statusEnergyDot = document.getElementById('statusEnergyDot');
  const statusPhaseDot = document.getElementById('statusPhaseDot');
  const statusOverallDot = document.getElementById('statusOverallDot');
  const statusDistText = document.getElementById('statusDistText');
  const statusEnergyText = document.getElementById('statusEnergyText');
  const statusPhaseText = document.getElementById('statusPhaseText');
  const statusOverallText = document.getElementById('statusOverallText');

  /* --- Map --- */
  const mapCanvas = document.getElementById('mapCanvas');
  const mctx      = mapCanvas.getContext('2d');

  let lastAnalysis = {go:false};

  function setStatus(dot, textEl, ok, warn){
    dot.classList.remove('status-ok','status-warn','status-bad');
    if(ok){
      dot.classList.add('status-ok');
    }else if(warn){
      dot.classList.add('status-warn');
    }else{
      dot.classList.add('status-bad');
    }
    textEl.textContent = ok ? 'YES' : 'NO';
  }

  function updateGoStatus(){
    const go = lastAnalysis.go;
    const msg = go
      ? 'GO â€” Warp corridor validated for Earth â†’ ' + (lastAnalysis.target || '')
      : 'NO-GO â€” Verification conditions not all satisfied';

    goText.classList.remove('go','nogo');
    if(go){
      goText.classList.add('go');
    }else{
      goText.classList.add('nogo');
    }
    goText.textContent  = msg;
  }

  function recomputeNav(){
    const target = navTargetEl.value;
    const tDays  = parseFloat(navTEl.value);
    const kChi   = parseFloat(navKchiEl.value);
    const Ewarp  = parseFloat(navEwarpEl.value);
    const tolD   = Math.max(0.01, parseFloat(navTolDistEl.value));
    const tolE   = Math.max(0.01, parseFloat(navTolEEl.value));
    const tolP   = Math.max(0.01, parseFloat(navTolPhaseEl.value));

    // live readouts
    navTVal.textContent        = tDays.toFixed(0) + ' d';
    navKchiVal.textContent     = kChi.toFixed(2);
    navKchiFlag.textContent    = (kChi > 0.01) ? 'phase in metric: YES' : 'phase in metric: NO';
    navEwarpVal.textContent    = Ewarp.toFixed(2);
    navTolDistVal.textContent  = tolD.toFixed(1) + '%';
    navTolEVal.textContent     = tolE.toFixed(1) + '%';
    navTolPhaseVal.textContent = tolP.toFixed(2) + ' rad';

    const Epos = getPos('Earth', tDays);
    const Tpos = getPos(target, tDays);

    const dx = Tpos.x - Epos.x;
    const dy = Tpos.y - Epos.y;
    const dz = Tpos.z - Epos.z;
    const d3 = Math.sqrt(dx*dx+dy*dy+dz*dz);

    const dChi = wrapPhase(Tpos.chi - Epos.chi);
    const d4 = Math.sqrt(dx*dx+dy*dy+dz*dz + (kChi*dChi)*(kChi*dChi));

    // energy model: simple, user-facing
    const alpha = 2.0;
    const Eexp  = alpha * d3;

    // use engine's FTL gain if available
    const ftlGain = (window._ftlGainSim || 1.0);
    const baseTauHours = (Ewarp>0 && d4>0) ? (d4*40/Ewarp) : 0;
    const tauHours = baseTauHours / ftlGain;

    // Channel 1: distance consistency
    let distOK;
    if(d3>0){
      const rel = Math.abs(d4-d3)/d3*100;
      distOK = (rel <= tolD);
    }else{
      distOK = (Math.abs(d4) < 1e-5);
    }

    // Channel 2: energy â€” PASS if warp energy is not underpowered
    let energyOK;
    if(Eexp>0){
      energyOK = (Ewarp >= Eexp*(1 - tolE/100));
    }else{
      energyOK = (Ewarp <= 0.001);
    }

    // Channel 3: phase alignment
    const phaseOK = (Math.abs(dChi) <= tolP);

    const overall = distOK && energyOK && phaseOK;

    lastAnalysis = {
      go:overall,
      distOK,energyOK,phaseOK,
      d3,d4,Eexp,Ewarp,tauHours,
      tDays,kChi,target,
      Epos,Tpos,dChi
    };

    // update metrics
    mEx.textContent   = fmtNav(Epos.x,3);
    mEy.textContent   = fmtNav(Epos.y,3);
    mEz.textContent   = fmtNav(Epos.z,3);
    mTx.textContent   = fmtNav(Tpos.x,3);
    mTy.textContent   = fmtNav(Tpos.y,3);
    mTz.textContent   = fmtNav(Tpos.z,3);
    mEchi.textContent = fmtNav(Epos.chi,3);
    mTchi.textContent = fmtNav(Tpos.chi,3);
    mD3.textContent   = fmtNav(d3,3);
    mD4.textContent   = fmtNav(d4,3);
    mPgap.textContent = fmtNav(Math.abs(dChi),3);
    mEexp.textContent = fmtNav(Eexp,3);
    mEwarpEcho.textContent = fmtNav(Ewarp,3);
    mTau.textContent  = tauHours>0 ? (fmtNav(tauHours,2)+' h') : 'â€”';

    // channel status dots
    setStatus(statusDistDot, statusDistText,   distOK);
    setStatus(statusEnergyDot, statusEnergyText, energyOK);
    setStatus(statusPhaseDot, statusPhaseText, phaseOK);
    statusOverallDot.classList.remove('status-ok','status-warn','status-bad');
    if(overall){
      statusOverallDot.classList.add('status-ok');
      statusOverallText.textContent = 'GO';
    }else{
      statusOverallDot.classList.add('status-bad');
      statusOverallText.textContent = 'NO-GO';
    }

    updateGoStatus();
  }

  function buildConfigText(){
    if(!lastAnalysis || !lastAnalysis.target) return '';
    const tDays  = lastAnalysis.tDays || 0;
    const kChi   = lastAnalysis.kChi || 0;
    const Ewarp  = lastAnalysis.Ewarp || 0;
    const tolD   = parseFloat(navTolDistEl.value) || 0;
    const tolE   = parseFloat(navTolEEl.value) || 0;
    const tolP   = parseFloat(navTolPhaseEl.value) || 0;

    return [
      'Trip Configuration â€” GO',
      'Target Planet: ' + lastAnalysis.target,
      'Mission Epoch t: ' + tDays.toFixed(0) + ' days',
      'Phase Weight kÏ‡: ' + kChi.toFixed(2),
      'Warp Energy Budget: ' + Ewarp.toFixed(2),
      'Distance Tolerance: ' + tolD.toFixed(1) + ' %',
      'Energy Tolerance: ' + tolE.toFixed(1) + ' %',
      'Phase Tolerance: ' + tolP.toFixed(2) + ' rad',
      '',
      '3D distance: ' + lastAnalysis.d3.toFixed(3) + ' AU',
      '4D distance: ' + lastAnalysis.d4.toFixed(3) + ' AU',
      'Phase gap |Î”Ï‡|: ' + Math.abs(lastAnalysis.dChi).toFixed(3),
      'Expected Energy: ' + lastAnalysis.Eexp.toFixed(3),
      'Warp Energy: ' + lastAnalysis.Ewarp.toFixed(3),
      'Estimated Warp Travel Time (with engine FTL): ' + (lastAnalysis.tauHours>0 ? lastAnalysis.tauHours.toFixed(2)+' h' : 'â€”')
    ].join('\n');
  }

  // hook slider + inputs to recompute
  [navTargetEl,navTEl,navKchiEl,navEwarpEl,
   navTolDistEl,navTolEEl,navTolPhaseEl].forEach(el=>{
    el.addEventListener('input', recomputeNav);
  });

  // Analyze Trip: recompute + print config if GO
  analyzeBtn.addEventListener('click', ()=>{
    recomputeNav();
    if(lastAnalysis.go){
      configOutputEl.value = buildConfigText();
    }else{
      configOutputEl.value =
        'NO-GO â€” Adjust parameters until GO, then Analyze Trip again to record configuration.\n\n'
        + 'Diagnostics:\n'
        + 'â€¢ Distance OK: ' + lastAnalysis.distOK + '\n'
        + 'â€¢ Energy OK: '   + lastAnalysis.energyOK + '\n'
        + 'â€¢ Phase OK: '    + lastAnalysis.phaseOK;
    }
  });

  // presets
  document.querySelectorAll('.btnPreset').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.dataset.preset;
      const p = PRESETS[id];
      if(!p) return;
      navTargetEl.value    = p.target;
      navTEl.value         = p.tDays;
      navKchiEl.value      = p.kChi;
      navEwarpEl.value     = p.Ewarp;
      navTolDistEl.value   = p.tolD;
      navTolEEl.value      = p.tolE;
      navTolPhaseEl.value  = p.tolP;
      recomputeNav();
      configOutputEl.value = ''; // clear until user hits Analyze Trip
    });
  });

  // initial compute
  recomputeNav();

  /* ---------- WARP TRIP + MAP ANIMATION ---------- */

  let warpTripActive = false;
  let warpTripStart  = 0;
  let warpTripDurMs  = 8000;
  let warpTripPeak   = 8;
  let warpTripProgress = 0;
  let travelStart = null;
  let travelEnd   = null;
  let warpBaseVal = 3;

  const warpSlider = document.getElementById('warp');

  warpTripBtn.addEventListener('click', ()=>{
    if(!lastAnalysis.go) return;

    const now = performance.now();
    warpTripActive = true;
    warpTripStart  = now;
    warpTripProgress = 0;

    const tauH = lastAnalysis.tauHours>0 ? lastAnalysis.tauHours : 1;
    warpTripDurMs = clampNav(tauH*800, 4000, 20000);
    warpTripPeak = clampNav(3 + lastAnalysis.d4*3, 4, 10);

    warpBaseVal = parseInt(warpSlider.value,10) || 3;

    // freeze travel endpoints for map (Earth â†’ selected planet)
    const w = mapCanvas.width;
    const h = mapCanvas.height;
    const cx = w*0.5;
    const cy = h*0.5;
    const aE = PLANETS['Earth'].a;
    const aT = PLANETS[lastAnalysis.target].a;
    const maxA = Math.max(aE,aT)*1.3;
    const scale = Math.min(w,h)*0.42/maxA;
    travelStart = {
      x:cx + lastAnalysis.Epos.x*scale,
      y:cy - lastAnalysis.Epos.y*scale
    };
    travelEnd = {
      x:cx + lastAnalysis.Tpos.x*scale,
      y:cy - lastAnalysis.Tpos.y*scale
    };
  });

  function drawMapFrame(now){
    const w = mapCanvas.width;
    const h = mapCanvas.height;
    mctx.clearRect(0,0,w,h);

    // background
    mctx.fillStyle='#050814';
    mctx.fillRect(0,0,w,h);

    const cx = w*0.5;
    const cy = h*0.5;

    if(!lastAnalysis || !lastAnalysis.Epos || !lastAnalysis.Tpos) return;

    const aE = PLANETS['Earth'].a;
    const aT = PLANETS[lastAnalysis.target].a;
    const maxA = Math.max(aE,aT)*1.3;
    const scale = Math.min(w,h)*0.42/maxA;

    // Sun
    const sunGrad = mctx.createRadialGradient(cx,cy,5,cx,cy,40);
    sunGrad.addColorStop(0,'#ffd37a');
    sunGrad.addColorStop(1,'#ffb34700');
    mctx.fillStyle = sunGrad;
    mctx.beginPath();
    mctx.arc(cx,cy,16,0,Math.PI*2);
    mctx.fill();

    // orbits
    mctx.strokeStyle='#2a3564';
    mctx.lineWidth=1;
    mctx.setLineDash([5,6]);
    [aE,aT].forEach(ra=>{
      mctx.beginPath();
      mctx.arc(cx,cy,ra*scale,0,Math.PI*2);
      mctx.stroke();
    });
    mctx.setLineDash([]);

    const Epos = lastAnalysis.Epos;
    const Tpos = lastAnalysis.Tpos;

    const Ex = cx + Epos.x*scale;
    const Ey = cy - Epos.y*scale;
    const Tx = cx + Tpos.x*scale;
    const Ty = cy - Tpos.y*scale;

    // travel line
    if(travelStart && travelEnd){
      mctx.strokeStyle='#8fb4ff';
      mctx.lineWidth=2;
      mctx.beginPath();
      mctx.moveTo(travelStart.x, travelStart.y);
      mctx.lineTo(travelEnd.x, travelEnd.y);
      mctx.stroke();

      if(warpTripActive){
        const t = warpTripProgress;
        const px = travelStart.x + (travelEnd.x-travelStart.x)*t;
        const py = travelStart.y + (travelEnd.y-travelStart.y)*t;
        mctx.fillStyle='#7bffb1';
        mctx.beginPath();
        mctx.arc(px,py,6,0,Math.PI*2);
        mctx.fill();
      }else if(warpTripProgress>=1){
        mctx.fillStyle='#7bffb1';
        mctx.beginPath();
        mctx.arc(travelEnd.x,travelEnd.y,6,0,Math.PI*2);
        mctx.fill();
      }
    }

    // Earth
    mctx.fillStyle='#7bffb1';
    mctx.beginPath();
    mctx.arc(Ex,Ey,6,0,Math.PI*2);
    mctx.fill();

    // target
    mctx.fillStyle='#ff8c8c';
    mctx.beginPath();
    mctx.arc(Tx,Ty,6,0,Math.PI*2);
    mctx.fill();

    // legend text
    mctx.fillStyle='#9bb7e3';
    mctx.font='13px system-ui,Segoe UI';
    mctx.textAlign='left';
    mctx.fillText('Earth', Ex+10, Ey-4);
    mctx.fillText(lastAnalysis.target, Tx+10, Ty-4);
  }

  function loop(now){
    // warp trip engine coupling
    if(warpTripActive){
      const dt = now - warpTripStart;
      let t = dt / warpTripDurMs;
      if(t >= 1){
        t = 1;
        warpTripActive = false;
        warpTripProgress = 1;
      }else{
        warpTripProgress = t;
      }

      // smooth in/out
      const ease = t<0.5 ? 2*t*t : 1-2*(1-t)*(1-t);
      const wVal = warpBaseVal + (warpTripPeak - warpBaseVal)*ease;
      warpSlider.value = wVal.toFixed(0);
      if(typeof window._updateWarpHUD === 'function'){
        window._updateWarpHUD();
      }else{
        warpSlider.dispatchEvent(new Event('input'));
      }
    }

    drawMapFrame(now);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
