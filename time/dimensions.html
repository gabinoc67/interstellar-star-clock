<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST String-Dimension Jump Simulator — v5 (Live-on-Load)</title>
<meta name="description" content="Ball starts at current CST time on current dimension. Enter hour & dimension to jump; animation with sparks and stability ring." />
<style>
  :root{
    --bg:#0b1020;--panel:#111735;--ink:#eaf0ff;--muted:#a9b3d6;--accent:#8fb4ff;
    --grid:#20306b;--ring:#ff324f;--halo:#e9f4ff;--cursor:#7fb1ff;
    --border:#1a2550;--amber:#ffd15a;--ok:#35e6a2;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  a{color:var(--accent)}
  .wrap{max-width:1300px;margin:0 auto;padding:16px}
  h1{margin:0 0 8px;font-size:1.6rem;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:.95rem;margin-bottom:16px}
  .grid{display:grid;grid-template-columns:360px 1fr;gap:16px;align-items:start}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  .card .hd{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
  .card .bd{padding:14px}
  .pill{font-size:.75rem;color:var(--muted);background:#0e1430;border:1px solid var(--border);padding:4px 8px;border-radius:999px}
  label{display:block;font-size:.85rem;color:var(--muted);margin:10px 0 6px}
  input[type="number"],input[type="time"],input[type="range"],select{width:100%}
  input,select,button{background:#0c1330;color:var(--ink);border:1px solid var(--border);border-radius:10px;padding:8px}
  button{cursor:pointer}
  button.primary{background:linear-gradient(180deg,#2446b3,#1b2f7d);border-color:#1a2f7a}
  button.ghost{background:transparent}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* WALL */
  .wall{height:560px;position:relative;border-top:1px solid var(--border);border-bottom:1px solid var(--border);
    background:
      repeating-linear-gradient(to right, rgba(255,255,255,.05) 0 1px, transparent 1px 40px),
      linear-gradient(180deg, rgba(159,210,255,.04), rgba(159,210,255,.02));
    overflow:hidden;border-radius:14px;margin:8px 12px}
  .axis{position:absolute;left:0;right:0;height:1px;background:var(--grid);opacity:.7}
  .axis .lbl{position:absolute;left:8px;top:-10px;font-size:.7rem;color:var(--muted)}
  .hourTick{position:absolute;top:0;bottom:0;width:2px;background:#21316b;opacity:.35}
  .hourLbl{position:absolute;top:6px;font-size:.65rem;color:var(--muted);transform:translateX(-50%)}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin:8px 12px}
  .legend span{display:inline-flex;align-items:center;gap:6px;font-size:.8rem;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%}
  .stable{background:var(--ring)}
  .note{color:var(--muted);font-size:.8rem}
  .reading{font-variant-numeric:tabular-nums;font-weight:600}
  canvas#viz{position:absolute;inset:0}
  .badge{display:inline-block;padding:3px 8px;border:1px solid var(--border);border-radius:999px;font-size:.75rem;color:var(--muted)}
  .good{color:var(--ok)}
  .bad{color:var(--amber)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST String-Dimension Jump Simulator — v5</h1>
  <div class="sub">On page load the ball <strong>automatically sits at the current CST time</strong> on the <strong>current dimension</strong>. Type a target <em>hour</em> and <em>dimension</em>, then press <strong>Jump</strong> to animate and lock at that coordinate. Static sparks & brightness scale with jump distance; a thin red ring shows a <em>stable paradox</em> at destination.</div>

  <div class="grid">
    <!-- LEFT: Controls -->
    <section class="card">
      <div class="hd"><div>Mission Planner</div><span class="pill">Inputs</span></div>
      <div class="bd">
        <div class="row">
          <div>
            <label>Current Dimension</label>
            <input type="number" id="curDim" min="1" max="12" value="1" />
          </div>
          <div>
            <label>CST Offset (hrs vs UTC)</label>
            <input type="number" id="cstOffset" step="0.25" value="0" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Target Dimension (1–12)</label>
            <input type="number" id="targetDim" min="1" max="12" value="5" />
          </div>
          <div>
            <label>Jump Hour (0–24)</label>
            <input type="number" id="destHour" min="0" max="24" step="0.1" value="23" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Paradox Stability Threshold <span class="note">(S ≥ threshold = stable)</span></label>
            <input type="range" id="paradoxThresh" min="0" max="1" step="0.01" value="0.60" />
          </div>
          <div>
            <label>Sparks Intensity Gain</label>
            <input type="range" id="sparkGain" min="0.5" max="2.5" step="0.1" value="1.2" />
          </div>
        </div>
        <div class="row" style="align-items:end">
          <button id="btnJump" class="primary">Jump & Lock</button>
          <button id="btnUnlock" class="ghost">Unlock (Return to Live)</button>
        </div>
        <div class="note" style="margin-top:8px">
          <strong>Live mode (default on load):</strong> ball follows CST on Current Dimension. <strong>Locked:</strong> stays at Target Dimension @ Jump Hour until you press <em>Unlock</em>.
        </div>
      </div>
    </section>

    <!-- RIGHT: Visualization -->
    <section class="card">
      <div class="hd"><div>String-Wall (24h)</div><span class="pill">CST Live</span></div>
      <div class="bd">
        <div class="legend">
          <span><span class="dot stable"></span> Ball rim (red) = present/locked point</span>
          <span><span class="dot" style="background:var(--cursor)"></span> Dashed line = selected Jump Hour</span>
          <span class="note">Sparks = static discharge while tunneling</span>
        </div>
        <div class="wall" id="wall">
          <canvas id="viz"></canvas>
        </div>

        <div class="row">
          <div>
            <label>UTC</label>
            <div class="reading" id="utcClock">—</div>
          </div>
          <div>
            <label>CST</label>
            <div class="reading" id="cstClock">—</div>
          </div>
        </div>
        <div class="row" style="margin-top:6px">
          <div>
            <label>Today (CST frame)</label>
            <div class="reading" id="todayStr">—</div>
          </div>
          <div>
            <label>Paradox @ Target</label>
            <div class="reading"><span id="paradoxState" class="badge">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- EXPLANATION -->
    <section class="card">
      <div class="hd"><div>Explanation • Equations</div><span class="pill">Model Notes</span></div>
      <div class="bd">
        <p class="note" style="line-height:1.6">
          <strong>1) Paradox Stability Field:</strong>
          <span class="mono">S(i,t) = ½·[1 + cos(ωᵢ·t + φᵢ + 0.6·h_dest)]</span>, with <span class="mono">ωᵢ = 0.4 + 0.06·i</span> and random phase <span class="mono">φᵢ</span> per dimension. Stable if <span class="mono">S ≥ S_th</span> (slider).<br>
          <strong>2) Mis-Sync (CST vs Jump Hour):</strong>
          <span class="mono">ε = min(|CST − h_dest|, 24 − |CST − h_dest|)/24</span> (wrap to 0..12h).<br>
          <strong>3) Equilibrium Intuition:</strong>
          <span class="mono">E = clamp(1 − (ε + (1 − S(i*,t))), 0, 1)</span>, where <span class="mono">i*</span> is target dimension.<br>
          <strong>4) Power Proxy:</strong>
          <span class="mono">P ∝ T(i*) · Δd² · (ε + 0.1)/(0.4 + S(i*,t))</span>, with string tension <span class="mono">T(i)=T₀(1+0.05·i)</span> and <span class="mono">Δd=|d_target−d_current|</span>.<br>
          <strong>5) Visual Mapping:</strong> jump distance controls intensity <span class="mono">I=clamp(Δd/11,0.08,1)</span> → halo brightness, blink depth, and spark emission. A thin red ring is drawn at the destination while/when <span class="mono">S ≥ S_th</span>.<br><br>
          <em>Credit:</em> Conceptual inspiration linking <strong>paradox loops</strong> and <strong>dimension crossing</strong> is attributed to <strong>Prof. Jaroslav Kletetschka</strong>. This is a CST-synchronization toy model expanding that framing.
        </p>
      </div>
    </section>
  </div>
</div>

<script>
(function(){
  // === DOM refs ===
  const wall = document.getElementById('wall');
  const canvas = document.getElementById('viz');
  const ctx = canvas.getContext('2d');

  const curDim    = document.getElementById('curDim');
  const targetDim = document.getElementById('targetDim');
  const destHour  = document.getElementById('destHour');
  const cstOffset = document.getElementById('cstOffset');
  const paradoxThresh = document.getElementById('paradoxThresh');
  const sparkGain = document.getElementById('sparkGain');

  const utcClock  = document.getElementById('utcClock');
  const cstClock  = document.getElementById('cstClock');
  const todayStr  = document.getElementById('todayStr');
  const paradoxState = document.getElementById('paradoxState');

  const btnJump   = document.getElementById('btnJump');
  const btnUnlock = document.getElementById('btnUnlock');

  // === Layout ===
  function resize(){
    const rect = wall.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width);
    canvas.height = Math.floor(rect.height);
    buildGrid();
  }
  window.addEventListener('resize', resize);

  function buildGrid(){
    [...wall.querySelectorAll('.hourTick,.hourLbl,.axis')].forEach(n=>n.remove());
    for(let i=1;i<=12;i++){
      const y = lineY(i);
      const axis = document.createElement('div');
      axis.className='axis'; axis.style.top = `${y}px`;
      const lbl = document.createElement('div');
      lbl.className='lbl'; lbl.textContent=`Dim ${i}`;
      axis.appendChild(lbl);
      wall.appendChild(axis);
    }
    for(let h=0;h<=24;h++){
      const x = hourX(h);
      const tick = document.createElement('div');
      tick.className='hourTick'; tick.style.left = `${x-1}px`;
      wall.appendChild(tick);
      const hl = document.createElement('div');
      hl.className='hourLbl'; hl.style.left = `${x}px`; hl.textContent = `${h}`;
      wall.appendChild(hl);
    }
  }

  function lineY(i){
    const H = canvas.height; const pad=26; const usable = H - pad*2; const step = usable/11;
    return Math.round(pad + (i-1)*step);
  }
  function hourX(h){
    const W = canvas.width; const pad=20; const usable=W-pad*2;
    return Math.round(pad + (h/24)*usable);
  }

  // === Time helpers ===
  function getCSTDate(){
    const now = new Date();
    const utcMs = now.getTime() + now.getTimezoneOffset()*60000;
    return new Date(utcMs + (+cstOffset.value)*3600000);
  }
  function getCSTHour(){
    const d = getCSTDate();
    return d.getHours() + d.getMinutes()/60 + d.getSeconds()/3600;
  }
  function fmtTime(d){
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  // === Model: stability S(i,t) ===
  const phaseSeed = Array.from({length:12},()=>Math.random()*Math.PI*2);
  function S(i, hour, tms){
    const w = 0.4 + 0.06*i;
    const phi = phaseSeed[i-1];
    const t = tms/1000;
    const arg = w*t + 0.6*hour + phi;
    return 0.5*(1 + Math.cos(arg));
  }

  // === State (ensure live on load) ===
  let locked = false;       // important: start unlocked so ball follows current time
  let lockDim = 1;
  let lockHour = 0;
  let anim = null;

  // Sparks during jump
  const sparks = [];
  function spawnSparks(x, y, intensity){
    const k = Math.floor(14 * intensity * +sparkGain.value);
    for(let n=0;n<k;n++){
      const a = Math.random()*Math.PI*2;
      const v = 0.6 + 2.5*intensity*Math.random();
      const life = 200 + 450*intensity*Math.random();
      sparks.push({
        x, y,
        vx: Math.cos(a)*v,
        vy: Math.sin(a)*v,
        life, age:0,
        size: 0.7 + 1.8*Math.random()*intensity,
        q: Math.random() < 0.5 ? 1 : -1
      });
    }
    if(sparks.length>1200) sparks.splice(0, sparks.length-1200);
  }
  function stepSparks(dt){
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.age += dt;
      if(p.age>=p.life){ sparks.splice(i,1); continue; }
      p.vx *= 0.996; p.vy = p.vy*0.996 + 0.005;
      p.x += p.vx*dt; p.y += p.vy*dt;
    }
  }
  function drawSparks(){
    for(const p of sparks){
      const alpha = 1 - p.age/p.life;
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.35*alpha + 0.25*Math.sin((p.age*0.02 + p.q)*8)*alpha;
      ctx.strokeStyle = p.q>0 ? '#eaf2ff' : '#9fd2ff';
      ctx.lineWidth = Math.max(0.6, p.size*(alpha));
      ctx.beginPath();
      const jx = p.x + Math.sin(p.age*0.06 + p.q)*2.0;
      const jy = p.y + Math.cos(p.age*0.07 + p.q)*2.0;
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(jx, jy);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  // === Visuals ===
  function drawWallpaper(){
    const W = canvas.width, H = canvas.height; ctx.clearRect(0,0,W,H);
    const t = performance.now()/1000;
    for(let n=0;n<70;n++){
      const x = (Math.sin(n*12.7 + t*0.7)*0.5+0.5) * (W-40) + 20;
      const y = (Math.cos(n*9.3 + t*0.6)*0.5+0.5) * (H-40) + 20;
      const r = 0.6 + 0.6*Math.sin(t*1.5 + n);
      ctx.globalAlpha = 0.08 + 0.08*Math.sin(t*2 + n);
      ctx.fillStyle = '#d9ecff';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
  }
  function drawStrings(){
    const now = performance.now();
    for(let i=1;i<=12;i++){
      const y = lineY(i);
      ctx.strokeStyle = 'rgba(255,50,79,0.50)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(hourX(0), y);
      for(let h=1; h<=24; h++){
        ctx.lineTo(hourX(h), y + Math.sin((h+now/1000)*0.2 + i)*0.6);
      }
      ctx.stroke();
    }
  }
  function drawPlannedHour(){
    const xPlan = hourX(+destHour.value);
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--cursor') || '#7fb1ff';
    ctx.setLineDash([6,6]); ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(xPlan,0); ctx.lineTo(xPlan,canvas.height); ctx.stroke();
    ctx.restore();
  }
  function drawBall(x, y, intensity=0.1, blinking=false){
    const t = performance.now();
    const blink = blinking ? (0.55 + 0.45*Math.abs(Math.sin(t*0.006*(0.7+1.6*intensity)))) : 1.0;

    ctx.save(); ctx.translate(x,y);
    const R = 12 + 2*Math.sin(t/160)*blink;
    const haloR = R*(2.8 + 1.8*intensity);
    const g = ctx.createRadialGradient(0,0,0,0,0,haloR);
    const innerAlpha = 0.75 + 0.25*intensity;
    const outerAlpha = 0.05 + 0.20*intensity;
    g.addColorStop(0,`rgba(233,244,255,${innerAlpha*blink})`);
    g.addColorStop(1,`rgba(159,210,255,${outerAlpha*blink})`);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,haloR,0,Math.PI*2); ctx.fill();

    ctx.fillStyle = `rgba(233,244,255,${0.95*blink})`;
    ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

    ctx.lineWidth=3; ctx.strokeStyle = '#ff324f';
    ctx.beginPath(); ctx.arc(0,0,R+2,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function drawParadoxRing(dim, hour, isStable){
    if(!isStable) return;
    const x = hourX(hour);
    const y = lineY(dim);
    ctx.save();
    ctx.strokeStyle = '#ff324f';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.9;
    const pulse = 2 + 2*Math.sin(performance.now()/700);
    ctx.beginPath(); ctx.arc(x, y, 24 + pulse, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  // === Animation ===
  function startJump(){
    const cd = clampInt(+curDim.value,1,12);
    const td = clampInt(+targetDim.value,1,12);
    const dh = clampFloat(+destHour.value,0,24);

    const liveHr = getCSTHour();
    const x0 = hourX(liveHr), y0 = lineY(cd);
    const x1 = hourX(dh),     y1 = lineY(td);

    const dSteps = Math.abs(td - cd);                 // 0..11
    const intensity = Math.max(0.08, Math.min(1, dSteps/11));
    const DUR = 1200 + 180*dSteps;

    anim = {
      t0: performance.now(),
      DUR, x0, y0, x1, y1, td, dh,
      intensity,
      lastFrame: performance.now()
    };
    locked = false;             // ensure we leave live mode only after animation ends
    sparks.length = 0;
  }
  function stepAnimation(now){
    if(!anim) return false;
    const {t0,DUR,x0,y0,x1,y1,td,dh,intensity} = anim;
    const dt = now - anim.lastFrame; anim.lastFrame = now;

    const p = Math.max(0, Math.min(1, (now - t0)/DUR));
    const cx = x0 + (x1-x0)*0.5;
    const cy = Math.min(y0,y1) - 60 - 40*Math.sin(now/300);
    const x = (1-p)*(1-p)*x0 + 2*(1-p)*p*cx + p*p*x1;
    const y = (1-p)*(1-p)*y0 + 2*(1-p)*p*cy + p*p*y1;

    drawWallpaper(); drawStrings(); drawPlannedHour();

    spawnSparks(x, y, intensity*(0.6 + 0.8*Math.sin(now/90)*(1-p)));
    stepSparks(dt);
    drawSparks();

    drawBall(x, y, intensity, true);

    const stable = isStable(td, dh);
    drawParadoxRing(td, dh, stable);
    paradoxState.textContent = stable ? 'Stable' : 'Unstable';
    paradoxState.className = 'badge ' + (stable ? 'good' : 'bad');

    if(p>=1){
      locked = true; lockDim = td; lockHour = dh; anim = null;
    }
    return true;
  }

  function isStable(dim, hour){
    const s = S(dim, hour, performance.now());
    return s >= +paradoxThresh.value;
  }

  // === Main loop ===
  function loop(){
    const now = performance.now();
    if(anim){
      stepAnimation(now);
    }else{
      drawWallpaper(); drawStrings(); drawPlannedHour();
      if(locked){
        const x = hourX(lockHour);
        const y = lineY(lockDim);
        drawParadoxRing(lockDim, lockHour, isStable(lockDim, lockHour));
        drawBall(x,y,0.25,false);
        const st = isStable(lockDim, lockHour);
        paradoxState.textContent = st ? 'Stable' : 'Unstable';
        paradoxState.className = 'badge ' + (st ? 'good' : 'bad');
      }else{
        // LIVE ON LOAD: follow current CST time on current dimension
        const liveHr = getCSTHour();
        const x = hourX(liveHr);
        const y = lineY(clampInt(+curDim.value,1,12));
        drawBall(x,y,0.12,false);

        const st = isStable(clampInt(+targetDim.value,1,12), clampFloat(+destHour.value,0,24));
        paradoxState.textContent = st ? 'Stable' : 'Unstable';
        paradoxState.className = 'badge ' + (st ? 'good' : 'bad');
      }
    }
    tickClocks();
    requestAnimationFrame(loop);
  }

  // === Clocks ===
  function tickClocks(){
    const now = new Date();
    const utc = new Date(now.getTime() + now.getTimezoneOffset()*60000);
    const cst = getCSTDate();
    utcClock.textContent = fmtTime(utc);
    cstClock.textContent = fmtTime(cst);
    todayStr.textContent = cst.toDateString();
  }

  // === Utils & Events ===
  function clampInt(v,a,b){ v=Math.round(v); return Math.max(a,Math.min(b,v)); }
  function clampFloat(v,a,b){ return Math.max(a,Math.min(b,v)); }

  btnJump.addEventListener('click', ()=>{
    if(locked && +targetDim.value===lockDim && +destHour.value===lockHour) return;
    startJump();
  });
  btnUnlock.addEventListener('click', ()=>{ locked = false; anim = null; sparks.length = 0; });

  [curDim,targetDim,destHour,cstOffset,paradoxThresh,sparkGain].forEach(el=>{
    el.addEventListener('input', ()=>{ /* reactive via loop */ });
  });

  function init(){
    resize();
    // Ensure LIVE mode at first paint (locked=false by default)
    locked = false;
    requestAnimationFrame(loop);
  }
  window.addEventListener('load', init);
})();
</script>
</body>
</html>
