<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>🪐 Cosmic Clock (Dual Panel)</title>
<style>
  :root{ --gap:22px; }
  body{
    margin:0; background:#0a0f1f; color:#fff; font-family:Arial, Helvetica, sans-serif;
    min-height:100vh; display:flex; align-items:center; justify-content:center;
  }
  #container{
    display:flex; align-items:flex-start; justify-content:center; gap:var(--gap);
    padding:18px; max-width:calc(100vw - 18px); overflow:auto; flex-wrap:wrap;
  }
  #infoPanel{ width:420px; text-align:left; line-height:1.7em; }
  #infoPanel h1{ color:gold; font-size:28px; margin:0 0 12px 0; }
  label{ display:block; margin:8px 0 4px; font-size:1.05em; }
  input, select{
    width:100%; padding:9px 10px; font-size:1.05em;
    border:1px solid #334155; background:#0f172a; color:#e5e7eb; border-radius:8px;
  }
  .btnRow{ margin-top:10px; display:flex; gap:10px; }
  .btn{
    background:#2563eb; color:#fff; border:none; border-radius:8px; cursor:pointer;
    padding:9px 16px; font-size:1.05em;
  }
  .btn:hover{ background:#1d4ed8; }
  #output{ font-size:1.05em; margin-top:12px; }
  .note{ font-size:0.95em; color:#bbb; margin-top:10px; }
  .error{ color:#ff7b7b; }

  #clocks{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:var(--gap); }
  canvas{ background:#111; border:2px solid #333; display:block; }
  #cosmicClock, #bottomClock{ width:715px; height:715px; }
</style>
</head>
<body>
  <div id="container">
    <!-- Left controls -->
    <div id="infoPanel">
      <h1>🪐 Cosmic Clock</h1>

      <label for="dateInput">Date (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)</label>
      <input type="text" id="dateInput" placeholder="e.g. 1987-05-09 or 05/11/1967" />

      <label for="latInput">Latitude (°) — optional, for orientation</label>
      <input type="number" id="latInput" step="0.00001" placeholder="e.g. 25.93742" />

      <label for="lonInput">Longitude (°) — optional, for orientation</label>
      <input type="number" id="lonInput" step="0.00001" placeholder="e.g. -97.45960" />

      <label for="orientSel">Orientation</label>
      <select id="orientSel">
        <option value="noon">Local noon at location (on that date)</option>
        <option value="lst">Sidereal (LST at location)</option>
        <option value="north" selected>Fixed meridian (true north up)</option>
      </select>

      <div class="btnRow">
        <button class="btn" onclick="startClock()">Start</button>
        <button class="btn" onclick="resetClock()">Reset</button>
      </div>

      <div id="output">Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.</div>
      <div class="note">
        ⚠️ Antikythera-style mechanism. The Moon is the main dial that drives the system.
      </div>
    </div>

    <!-- Right: stacked clocks -->
    <div id="clocks">
      <canvas id="cosmicClock" width="715" height="715"></canvas>
      <canvas id="bottomClock" width="715" height="715"></canvas>
    </div>
  </div>

<script>
/* ------------------ shared helpers ------------------ */
function dims(canvas){
  const cx = canvas.width/2, cy = canvas.height/2;
  const rMax = Math.min(cx, cy) - 18; // safety margin
  return { cx, cy, rMax };
}
function setMid(ctx){ ctx.textAlign="center"; ctx.textBaseline="middle"; }
function circle(ctx, cx, cy, r, color="#333", lw=1){
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.stroke(); ctx.lineWidth=1;
}
function deg2rad(deg){ return (deg-90)*Math.PI/180; }
function normDeg(x){ x%=360; return x<0?x+360:x; }
function shortestDelta(a,b){ let d=(b-a+540)%360-180; return d; }
function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }

function strokeFillText(ctx, text, x, y, color){
  ctx.lineWidth=3; ctx.strokeStyle="rgba(0,0,0,0.65)";
  ctx.strokeText(text, x, y);
  ctx.fillStyle=color; ctx.fillText(text, x, y);
  ctx.lineWidth=1;
}

// Pointed hand
function pointer(ctx, cx, cy, r, angleDeg, color){
  const a = deg2rad(angleDeg);
  const tipX = cx + r*Math.cos(a), tipY = cy + r*Math.sin(a);
  const back = 18, half = 6;
  ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tipX,tipY); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(tipX - back*Math.cos(a) + half*Math.sin(a), tipY - back*Math.sin(a) - half*Math.cos(a));
  ctx.lineTo(tipX - back*Math.cos(a) - half*Math.sin(a), tipY - back*Math.sin(a) + half*Math.cos(a));
  ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
  ctx.lineWidth=1;
}

// Label aligned along the 0° meridian (slightly to the right)
function labelOnMeridian(ctx, cx, cy, r, text, color){
  ctx.textAlign="left"; ctx.textBaseline="middle";
  ctx.font="13px Arial";
  const x = cx + 10, y = cy - r;               // just to the right of the vertical line
  // tiny color chip
  ctx.fillStyle=color; ctx.beginPath(); ctx.arc(cx+2, y, 3.5, 0, Math.PI*2); ctx.fill();
  strokeFillText(ctx, text, x, y, color);
  setMid(ctx); // restore
}

/* ------------------ time / cycle engine ------------------ */
const TROPICAL_YEAR = 365.2422;
const MOON_SYNODIC = 29.530588;
const MOON_SIDEREAL = 27.321661;
const METONIC = 6939.69;
const SAROS = 6585.321;
const EXELIGMOS = SAROS * 3;
const OLYMPIAD = 1461.0;
const MESOAMERICAN_52Y = 52 * 365.0;
const NATIVE_YEAR = 365.0;

const EPOCH = Date.UTC(2000,0,1,12,0,0);
const NEW_MOON_REF = Date.UTC(2000,0,6,18,14,0);

function daysSince(ms, ref){ return (ms - ref) / 86400000; }
function norm(x,p){ x%=p; return x<0?x+p:x; }

// Simple Sun ecliptic longitude (~1°)
function sunEclipticLongitude(dateUTC){
  const n = (dateUTC.getTime() - Date.UTC(2000,0,1,0,0,0)) / 86400000;
  const L = 280.460 + 0.9856474 * n;
  const g = (357.528 + 0.9856003 * n) * Math.PI/180;
  const lambda = L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2*g);
  return normDeg(lambda);
}
function sunZodiacName(lambda){
  const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
  return signs[Math.floor(normDeg(lambda)/30)];
}
function signDegMin(lambda){
  const sign = sunZodiacName(lambda);
  const dTot = normDeg(lambda) % 30;
  const d = Math.floor(dTot);
  const m = Math.round((dTot - d) * 60);
  return {sign, d, m};
}

// JD / GMST / LST (deg)
function julianDay(dateUTC){ return dateUTC.getTime()/86400000 + 2440587.5; }
function gmstDeg(dateUTC){
  const JD = julianDay(dateUTC);
  const T = (JD - 2451545.0)/36525.0;
  let gmst = 280.46061837 + 360.98564736629*(JD-2451545.0) + 0.000387933*T*T - (T*T*T)/38710000.0;
  return normDeg(gmst);
}
function lstDeg(dateUTC, longitudeDeg){ return normDeg(gmstDeg(dateUTC) + longitudeDeg); }

// Parse date (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)
function parseDateFlexible(s){
  if(!s) return null;
  if (s.includes('-')){
    const parts = s.split('-').map(n=>parseInt(n,10));
    if (parts[0] > 31) { // YYYY-MM-DD
      const [y,m,d]=parts; if(isFinite(y)&&isFinite(m)&&isFinite(d)) return {y,m,d};
    } else {             // MM-DD-YYYY
      const [mm,dd,yy]=parts; if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return {y:yy,m:mm,d:dd};
    }
  }
  if(s.includes('/')){
    const [mm,dd,yy] = s.split('/').map(n=>parseInt(n,10));
    if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return { y:yy, m:mm, d:dd };
  }
  return null;
}

// Build UTC instant at Local Mean Noon for a given longitude
function utcFromLocalMeanNoonYMD(y,m,d, lonDeg){
  const utcNoon = Date.UTC(y, m-1, d, 12, 0, 0);
  return new Date(utcNoon - lonDeg*240000); // 4 min/deg -> ms
}

function computeAngles(dateUTC){
  const t = dateUTC.getTime();
  const dMoon = daysSince(t, NEW_MOON_REF);
  const dEpoch = daysSince(t, EPOCH);
  return {
    moon:      normDeg( norm(dMoon, MOON_SYNODIC) / MOON_SYNODIC * 360 ),
    moonDay:   norm(dMoon, MOON_SYNODIC),           // 0..29.53
    mansions:  normDeg(dMoon / MOON_SIDEREAL * 360),
    zodiac:    sunEclipticLongitude(dateUTC),
    decans:    normDeg(dEpoch / TROPICAL_YEAR * 360),
    tepe:      normDeg(dEpoch / TROPICAL_YEAR * 360),
    maya:      normDeg(dEpoch / 20.0 * 360),
    metonic:   normDeg(dEpoch / METONIC * 360),
    saros:     normDeg(dEpoch / SAROS * 360),
    exeligmos: normDeg(dEpoch / EXELIGMOS * 360),
    olympiad:  normDeg(dEpoch / OLYMPIAD * 360),
    meso:      normDeg(dEpoch / MESOAMERICAN_52Y * 360),
    native365: normDeg(dEpoch / NATIVE_YEAR * 360),
  };
}

/* ------------------ TOP CLOCK (art) ------------------ */
const topCanvas = document.getElementById("cosmicClock");
const tctx = topCanvas.getContext("2d");
const tepeSymbols = ["🦂","🦊","🦅","🐂","🐍","🐇","🐺","🐟","🐦","🦌","🦃","🐢"];
const mayaSigns  = ["🐊","🌬️","🌊","🔥","🦅","🐍","🌽","🐢","🕷️","🐒","🐕","🌿","🌞","🌑","🌽","🦌","🌴","🦂","🌕","🐟"];
const zodiacIcons = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];

function drawTopClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(topCanvas);
  tctx.clearRect(0,0,topCanvas.width,topCanvas.height);
  setMid(tctx);

  const outer = 0.96*rMax, inner = 0.40*rMax;
  const steps = 7, step = (outer-inner)/steps;
  const R = {
    degRing:  outer,
    mansions: outer - step*1,
    decans :  outer - step*2,
    maya   :  outer - step*3,
    tepe   :  outer - step*4,
    zodiacR:  outer - step*5,
    metonic:  outer - step*6,
    moonPh :  outer - step*7
  };

  // Degree ring
  circle(tctx, cx, cy, R.degRing, "#444");
  for(let d=0; d<360; d+=5){
    const a=deg2rad(d), major = d%30===0, len = major?14:7;
    const x1=cx+(R.degRing-len)*Math.cos(a), y1=cy+(R.degRing-len)*Math.sin(a);
    const x2=cx+R.degRing*Math.cos(a),      y2=cy+R.degRing*Math.sin(a);
    tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2);
    tctx.strokeStyle="#667085"; tctx.stroke();
    if(major){
      tctx.fillStyle="#aab4c8"; tctx.font="12px Arial";
      tctx.fillText(String(d), cx+(R.degRing-28)*Math.cos(a), cy+(R.degRing-28)*Math.sin(a));
    }
  }
  ["mansions","decans","maya","tepe","zodiacR","metonic"].forEach(k=>circle(tctx,cx,cy,R[k],"#2a3347"));

  // labels (art on rings)
  tctx.fillStyle="violet"; tctx.font="22px Arial";
  zodiacIcons.forEach((z,i)=>{ const a=deg2rad(i*30); tctx.fillText(z, cx+R.zodiacR*Math.cos(a), cy+R.zodiacR*Math.sin(a)); });

  tctx.fillStyle="orange";
  for(let i=0;i<19;i++){ const a=deg2rad(i*(360/19)); tctx.fillRect(cx+R.metonic*Math.cos(a)-2, cy+R.metonic*Math.sin(a)-2, 4,4); }

  tctx.fillStyle="cyan"; tctx.font="18px Arial";
  tepeSymbols.forEach((s,i)=>{ const a=deg2rad(i*30); tctx.fillText(s, cx+R.tepe*Math.cos(a), cy+R.tepe*Math.sin(a)); });

  tctx.fillStyle="lime"; tctx.font="16px Arial";
  mayaSigns.forEach((s,i)=>{ const a=deg2rad(i*(360/20)); tctx.fillText(s, cx+R.maya*Math.cos(a), cy+R.maya*Math.sin(a)); });

  tctx.fillStyle="red"; tctx.font="13px Arial";
  for(let i=0;i<36;i++){ const a=deg2rad(i*10); tctx.fillText(String(i+1), cx+R.decans*Math.cos(a), cy+R.decans*Math.sin(a)); }

  tctx.fillStyle="yellow"; tctx.font="13px Arial";
  for(let i=0;i<28;i++){ const a=deg2rad(i*(360/28)); tctx.fillText(String(i+1), cx+R.mansions*Math.cos(a), cy+R.mansions*Math.sin(a)); }

  tctx.fillStyle="white"; tctx.font="18px Arial";
  ["🌑","🌓","🌕","🌗"].forEach((p,i)=>{ const a=deg2rad(i*90); tctx.fillText(p, cx+R.moonPh*Math.cos(a), cy+R.moonPh*Math.sin(a)); });

  const rot = rotDeg||0;

  // Gray meridian hand
  pointer(tctx,cx,cy,R.degRing, 0, "#9aa0a6");

  // Hands (subtract orientation)
  const dialColors = { mansions:"#ffd166", decans:"#ff4d4d", maya:"#98fb98", tepe:"#6ee7ff", zodiac:"#c084fc", metonic:"#ffa500", moonPh:"#ffffff" };
  pointer(tctx,cx,cy,R.mansions, normDeg(angles.mansions - rot), dialColors.mansions);
  pointer(tctx,cx,cy,R.decans,   normDeg(angles.decans   - rot), dialColors.decans);
  pointer(tctx,cx,cy,R.maya,     normDeg(angles.maya     - rot), dialColors.maya);
  pointer(tctx,cx,cy,R.tepe,     normDeg(angles.tepe     - rot), dialColors.tepe);
  pointer(tctx,cx,cy,R.zodiacR,  normDeg(angles.zodiac   - rot), dialColors.zodiac);   // Sun along zodiac
  pointer(tctx,cx,cy,R.metonic,  normDeg(angles.metonic  - rot), dialColors.metonic);
  pointer(tctx,cx,cy,R.moonPh,   normDeg(angles.moon     - rot), dialColors.moonPh);   // Moon master

  // Names along the meridian (top to bottom)
  labelOnMeridian(tctx, cx, cy, R.mansions, "Mansions (27.3d)", dialColors.mansions);
  labelOnMeridian(tctx, cx, cy, R.decans,   "Decans (36)",       dialColors.decans);
  labelOnMeridian(tctx, cx, cy, R.maya,     "Maya (20)",         dialColors.maya);
  labelOnMeridian(tctx, cx, cy, R.tepe,     "Tepe (12)",         dialColors.tepe);
  labelOnMeridian(tctx, cx, cy, R.zodiacR,  "Sun (Zodiac)",      dialColors.zodiac);
  labelOnMeridian(tctx, cx, cy, R.metonic,  "Metonic (19y)",     dialColors.metonic);
  labelOnMeridian(tctx, cx, cy, R.moonPh,   "Moon (Phases)",     dialColors.moonPh);
}

/* ------------------ BOTTOM CLOCK (art) ------------------ */
const bottomCanvas = document.getElementById("bottomClock");
const bctx = bottomCanvas.getContext("2d");

const BASE_NUM_PX = 12.6;
const BASE_LABEL_PX = 13.5;

const rings = [
  {label:"Moon Cycle (Phases)", key:"moon",     color:"white",   divisions:8,   symbols:["🌑","🌒","🌓","🌔","🌕","🌖","🌗","🌘"], showNumbers:false, numbersFontPx:BASE_NUM_PX, tickLen:5},
  {label:"Moon Days 1–29",      key:"moondays", color:"white",   divisions:29,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:6},
  {label:"Olympiad 4y",         key:"olymp",    color:"blue",    divisions:4,   showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Agricultural 12",     key:"farm",     color:"green",   divisions:12,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Metonic 19y",         key:"meton",    color:"orange",  divisions:19,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Saros 18y+11d",       key:"saros",    color:"red",     divisions:18,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Exeligmos 54y",       key:"exel",     color:"cyan",    divisions:54,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Mesoamerican 52y",    key:"meso",     color:"yellow",  divisions:52,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Native American Days (1–365)", key:"native365", color:"#9acd32", divisions:365, showNumbers:true, labelEvery:10, numbersFontPx:11, tickLen:6}
];

function computeLabelEvery(ctx, r, divisions, fontPx, padding=10){
  const radiusForLabels = r - 20;
  const circumference = 2 * Math.PI * Math.max(radiusForLabels, 1);
  const sample = String(divisions);
  ctx.font = `${fontPx}px Arial`;
  const sampleWidth = Math.max(ctx.measureText(sample).width, ctx.measureText("88").width);
  const needed = sampleWidth + padding;
  const maxLabels = Math.max(1, Math.floor(circumference / needed));
  return Math.max(1, Math.ceil(divisions / Math.max(1,maxLabels)));
}

function ringTicksAndNumbers(ctx,cx,cy,r,ring){
  const { divisions, color, showNumbers, symbols, numbersFontPx=BASE_NUM_PX, tickLen=7 } = ring;

  circle(ctx,cx,cy,r,color);
  setMid(ctx);
  const labelPx = (ring.key === 'farm') ? BASE_LABEL_PX * 0.90 : BASE_LABEL_PX;
  ctx.fillStyle=color; ctx.font=`${labelPx}px Arial`;
  ctx.fillText(ring.label, cx, cy - r - 13);

  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.font=`${numbersFontPx}px Arial`;
  const every = ring.labelEvery ?? computeLabelEvery(ctx, r, divisions, numbersFontPx);

  for(let i=0;i<divisions;i++){
    const a=deg2rad(i*(360/divisions));
    const x1=cx+(r-tickLen)*Math.cos(a), y1=cy+(r-tickLen)*Math.sin(a);
    const x2=cx+(r)*Math.cos(a),         y2=cy+(r)*Math.sin(a);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    const tx=cx+(r-20)*Math.cos(a), ty=cy+(r-20)*Math.sin(a);
    if(symbols){ ctx.fillText(symbols[i%symbols.length], tx, ty); }
    else if(showNumbers){ if(i % every === 0){ ctx.fillText(String(i+1), tx, ty); } }
  }
}

function drawBottomClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(bottomCanvas);
  bctx.clearRect(0,0,bottomCanvas.width,bottomCanvas.height);
  setMid(bctx);

  const inner = 0.18*rMax, outer = 0.95*rMax;
  const step = (outer-inner)/(rings.length-1);
  rings.forEach((ring,i)=> ring.r = inner + i*step);

  rings.forEach(ring => ringTicksAndNumbers(bctx,cx,cy,ring.r,ring));

  const rot = rotDeg||0;

  // Gray meridian
  pointer(bctx, cx, cy, rings[rings.length-1].r, 0, "#9aa0a6");
  // Yellow Moon hand to outermost
  pointer(bctx, cx, cy, rings[rings.length-1].r, normDeg(angles.moon - rot), "yellow");
  bctx.beginPath(); bctx.arc(cx,cy,6,0,Math.PI*2); bctx.fillStyle="yellow"; bctx.fill();

  // Names along meridian for each ring (outermost label near each ring)
  rings.forEach(r => labelOnMeridian(bctx, cx, cy, r.r, r.label, r.color));
}

/* ------------------ Controller: always visible + animate ------------------ */

// Current state — start at 0° everywhere
let rotCurrent = 0;
let anglesCurrent = {
  moon:0, mansions:0, zodiac:0, decans:0, tepe:0, maya:0, metonic:0,
  saros:0, exeligmos:0, olympiad:0, meso:0, native365:0, moonDay:0
};

// Draw from current state
function drawFromCurrent(){
  drawTopClock(anglesCurrent, rotCurrent);
  drawBottomClock(anglesCurrent, rotCurrent);
}

// Animate to target state
let rafId = null;
function animateTo(targetAngles, targetRot, durationMs=1500){
  if(rafId) cancelAnimationFrame(rafId);
  const start = performance.now();
  const startAngles = {...anglesCurrent};
  const startRot = rotCurrent;

  function step(now){
    let t=(now-start)/durationMs; if(t>1) t=1;
    const e=easeInOut(t);
    Object.keys(anglesCurrent).forEach(k=>{
      const a0=startAngles[k]||0, a1=targetAngles[k]||0;
      const d=shortestDelta(a0,a1);
      anglesCurrent[k]=normDeg(a0+d*e);
    });
    const dRot=shortestDelta(startRot,targetRot);
    rotCurrent=normDeg(startRot+dRot*e);

    drawFromCurrent();
    if(t<1) rafId=requestAnimationFrame(step);
  }
  rafId=requestAnimationFrame(step);
}

/* ------------------ Input / validation / control ------------------ */
function getInputs(){
  const dateStr = document.getElementById('dateInput').value.trim();
  const latStr  = document.getElementById('latInput').value.trim();
  const lonStr  = document.getElementById('lonInput').value.trim();
  const orient  = document.getElementById('orientSel').value;

  const parts = parseDateFlexible(dateStr);
  if(!parts) return {ok:false, msg:"Please enter a valid <b>date</b> (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)."};

  const {y,m,d}=parts;
  let dateUTC = new Date(Date.UTC(y, m-1, d, 12, 0, 0)); // base
  let haveLon=false, lon=0, lat=0;

  if(lonStr!=="" && latStr!==""){
    lon=parseFloat(lonStr); lat=parseFloat(latStr);
    if(!isFinite(lon)||!isFinite(lat)) return {ok:false, msg:"Latitude/Longitude must be numbers."};
    if(lat<-90||lat>90) return {ok:false, msg:"Latitude must be between -90 and 90°."};
    if(lon<-180||lon>180) return {ok:false, msg:"Longitude must be between -180 and 180°."};
    haveLon=true;
    // for noon orientation we want local mean noon time
    dateUTC = utcFromLocalMeanNoonYMD(y,m,d, lon);
  }

  return {ok:true, y,m,d, dateUTC, haveLon, lon, lat, orient};
}

function startClock(){
  const out = document.getElementById('output');
  const res = getInputs();
  if(!res.ok){ out.className="error"; out.innerHTML = res.msg; return; }
  out.className="";

  const A = computeAngles(res.dateUTC);

  // Orientation
  let rot = 0;
  if(res.orient === "noon"){
    // Put the Sun at the top (0°) for that date/location
    rot = A.zodiac;
  }else if(res.orient === "lst" && res.haveLon){
    rot = lstDeg(res.dateUTC, res.lon);
  }else{
    rot = 0; // fixed north up
  }

  const s = signDegMin(A.zodiac);
  const md = Math.floor(A.moonDay) + 1;
  const ymd = `${res.y.toString().padStart(4,"0")}-${res.m.toString().padStart(2,"0")}-${res.d.toString().padStart(2,"0")}`;
  const where = res.haveLon ? ` at lat <b>${res.lat.toFixed(5)}°</b>, lon <b>${res.lon.toFixed(5)}°</b>` : ``;
  const orientTxt = (res.orient==="noon") ? "Local noon at location."
                  : (res.orient==="lst") ? "Sidereal (LST at location)."
                  : "Fixed meridian (north up).";
  out.innerHTML = `Synced for <b>${ymd}</b>${where} • Sun on zodiac: <b>${s.sign} ${s.d}° ${s.m}′</b> • Moon day: <b>${md}</b> • Orientation: ${orientTxt}`;

  animateTo(A, rot, 1500);
}

function resetClock(){
  if (rafId) cancelAnimationFrame(rafId);
  rotCurrent = 0;
  for (const k in anglesCurrent) anglesCurrent[k] = 0;
  // clear inputs
  document.getElementById('dateInput').value = "";
  document.getElementById('latInput').value = "";
  document.getElementById('lonInput').value = "";
  document.getElementById('orientSel').value = "north";
  const out = document.getElementById('output');
  out.className=""; out.innerHTML = 'Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.';
  drawFromCurrent();
}

/* ------------------ Initial draw ------------------ */
drawFromCurrent();
</script>
</body>
</html>
