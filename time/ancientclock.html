<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>🪐 Cosmic Clock (Dual Panel)</title>
  <style>
    :root{ --gap:22px; }
    body{
      margin:0; background:#0a0f1f; color:#fff; font-family:Arial, Helvetica, sans-serif;
      min-height:100vh; display:flex; align-items:center; justify-content:center;
    }
    #container{
      display:flex; align-items:flex-start; justify-content:center; gap:var(--gap);
      padding:18px; max-width:calc(100vw - 18px); overflow:auto; flex-wrap:wrap;
    }

    /* Left control panel (20% bigger inputs) */
    #infoPanel{ width:400px; text-align:left; line-height:1.7em; }
    #infoPanel h1{ color:gold; font-size:28px; margin:0 0 12px 0; }
    label{ display:block; margin:8px 0 4px; font-size:1.05em; }
    input{
      width:100%; padding:9px 10px; font-size:1.2em;
      border:1px solid #334155; background:#0f172a; color:#e5e7eb; border-radius:8px;
    }
    .btnRow{ margin-top:10px; display:flex; gap:10px; }
    .btn{
      background:#2563eb; color:#fff; border:none; border-radius:8px; cursor:pointer;
      padding:9px 16px; font-size:1.05em;
    }
    .btn:hover{ background:#1d4ed8; }
    #output{ font-size:1.05em; margin-top:12px; }
    .note{ font-size:0.95em; color:#bbb; margin-top:10px; }
    .error{ color:#ff7b7b; }

    /* Right clocks column */
    #clocks{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:var(--gap); }

    /* Canvases (+30% from 550 → 715) */
    canvas{ background:#111; border:2px solid #333; display:block; }
    #cosmicClock, #bottomClock{ width:715px; height:715px; }
  </style>
</head>
<body>
  <div id="container">
    <!-- Left: controls -->
    <div id="infoPanel">
      <h1>🪐 Cosmic Clock</h1>

      <label for="dateInput">Birthday</label>
      <input type="date" id="dateInput" placeholder="mm/dd/yyyy" />

      <label for="latInput">Latitude (°)</label>
      <input type="number" id="latInput" step="0.0001" placeholder="e.g. 34.05" />

      <label for="lonInput">Longitude (°)</label>
      <input type="number" id="lonInput" step="0.0001" placeholder="e.g. -118.25" />

      <div class="btnRow">
        <button class="btn" onclick="startClock()">Start</button>
        <button class="btn" onclick="resetClock()">Reset</button>
      </div>

      <div id="output">Enter <b>date + latitude + longitude</b> to sync both clocks.</div>
      <div class="note">
        ⚠️ Antikythera-style mechanism. The Moon is the main dial that drives the system.
      </div>
    </div>

    <!-- Right: stacked clocks -->
    <div id="clocks">
      <canvas id="cosmicClock" width="715" height="715"></canvas>
      <canvas id="bottomClock" width="715" height="715"></canvas>
    </div>
  </div>

  <script>
    /* ------------------ shared helpers ------------------ */
    function dims(canvas){
      const cx = canvas.width/2, cy = canvas.height/2;
      const rMax = Math.min(cx, cy) - 18; // safety margin
      return { cx, cy, rMax };
    }
    function setMid(ctx){ ctx.textAlign="center"; ctx.textBaseline="middle"; }
    function circle(ctx, cx, cy, r, color="#333", lw=1){
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.stroke(); ctx.lineWidth=1;
    }
    function deg2rad(deg){ return (deg-90)*Math.PI/180; }
    function normDeg(x){ x%=360; return x<0?x+360:x; }

    // Pointed hand
    function pointer(ctx, cx, cy, r, angleDeg, color){
      const a = deg2rad(angleDeg);
      const tipX = cx + r*Math.cos(a), tipY = cy + r*Math.sin(a);
      const back = 18, half = 6;
      ctx.strokeStyle=color; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tipX,tipY); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(tipX - back*Math.cos(a) + half*Math.sin(a), tipY - back*Math.sin(a) - half*Math.cos(a));
      ctx.lineTo(tipX - back*Math.cos(a) - half*Math.sin(a), tipY - back*Math.sin(a) + half*Math.cos(a));
      ctx.closePath(); ctx.fillStyle=color; ctx.fill();
      ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
      ctx.lineWidth=1;
    }

    /* ------------------ time / cycle engine ------------------ */
    const TROPICAL_YEAR = 365.2422;
    const MOON_SYNODIC = 29.530588;
    const MOON_SIDEREAL = 27.321661;
    const METONIC = 6939.69;
    const SAROS = 6585.321;
    const EXELIGMOS = SAROS * 3;
    const OLYMPIAD = 1461.0;
    const MESOAMERICAN_52Y = 52 * 365.0;
    const NATIVE_YEAR = 365.0;

    const EPOCH = Date.UTC(2000,0,1,12,0,0);
    const NEW_MOON_REF = Date.UTC(2000,0,6,18,14,0);

    function daysSince(ms, ref){ return (ms - ref) / 86400000; }
    function norm(x,p){ x%=p; return x<0?x+p:x; }

    // Simple Sun ecliptic longitude (~1°)
    function sunEclipticLongitude(dateUTC){
      const n = (dateUTC.getTime() - Date.UTC(2000,0,1,0,0,0)) / 86400000;
      const L = 280.460 + 0.9856474 * n;
      const g = (357.528 + 0.9856003 * n) * Math.PI/180;
      const lambda = L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2*g);
      return normDeg(lambda);
    }
    function sunZodiacName(lambda){
      const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
      return signs[Math.floor(normDeg(lambda)/30)];
    }

    // JD / GMST / LST (deg)
    function julianDay(dateUTC){ return dateUTC.getTime()/86400000 + 2440587.5; }
    function gmstDeg(dateUTC){
      const JD = julianDay(dateUTC);
      const T = (JD - 2451545.0)/36525.0;
      let gmst = 280.46061837 + 360.98564736629*(JD-2451545.0) + 0.000387933*T*T - (T*T*T)/38710000.0;
      return normDeg(gmst);
    }
    function lstDeg(dateUTC, longitudeDeg){ return normDeg(gmstDeg(dateUTC) + longitudeDeg); }

    // Parse both "YYYY-MM-DD" and "MM/DD/YYYY"
    function parseDateFlexible(s){
      if(!s) return null;
      if(s.includes('-')){            // native date input
        const [y,m,d] = s.split('-').map(n=>parseInt(n,10));
        if(isFinite(y)&&isFinite(m)&&isFinite(d)) return { y, m, d };
      }
      if(s.includes('/')){            // typed as mm/dd/yyyy
        const [mm,dd,yy] = s.split('/').map(n=>parseInt(n,10));
        if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return { y:yy, m:mm, d:dd };
      }
      return null;
    }

    // Build UTC instant at Local Mean Noon for a given longitude
    function utcFromLocalMeanNoonYMD(y,m,d, lonDeg){
      const utcNoon = Date.UTC(y, m-1, d, 12, 0, 0);
      return new Date(utcNoon - lonDeg*240000); // 4 min/deg -> ms
    }

    function computeAngles(dateUTC){
      const t = dateUTC.getTime();
      const dMoon = daysSince(t, NEW_MOON_REF);
      const dEpoch = daysSince(t, EPOCH);
      return {
        moon:      normDeg( norm(dMoon, MOON_SYNODIC) / MOON_SYNODIC * 360 ),
        moonDay:   norm(dMoon, MOON_SYNODIC),           // 0..29.53
        mansions:  normDeg(dMoon / MOON_SIDEREAL * 360),
        zodiac:    sunEclipticLongitude(dateUTC),
        decans:    normDeg(dEpoch / TROPICAL_YEAR * 360),
        tepe:      normDeg(dEpoch / TROPICAL_YEAR * 360),
        maya:      normDeg(dEpoch / 20.0 * 360),
        metonic:   normDeg(dEpoch / METONIC * 360),
        saros:     normDeg(dEpoch / SAROS * 360),
        exeligmos: normDeg(dEpoch / EXELIGMOS * 360),
        olympiad:  normDeg(dEpoch / OLYMPIAD * 360),
        meso:      normDeg(dEpoch / MESOAMERICAN_52Y * 360),
        native365: normDeg(dEpoch / NATIVE_YEAR * 360),
      };
    }

    /* ------------------ TOP CLOCK ------------------ */
    const topCanvas = document.getElementById("cosmicClock");
    const tctx = topCanvas.getContext("2d");
    const tepeSymbols = ["🦂","🦊","🦅","🐂","🐍","🐇","🐺","🐟","🐦","🦌","🦃","🐢"];
    const mayaSigns  = ["🐊","🌬️","🌊","🔥","🦅","🐍","🌽","🐢","🕷️","🐒","🐕","🌿","🌞","🌑","🌽","🦌","🌴","🦂","🌕","🐟"];
    const zodiac     = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];

    function drawTopClock(dateUTC, rotDeg){
      const A = computeAngles(dateUTC);
      const {cx, cy, rMax} = dims(topCanvas);
      tctx.clearRect(0,0,topCanvas.width,topCanvas.height);
      setMid(tctx);

      const outer = 0.96*rMax, inner = 0.40*rMax;
      const steps = 7, step = (outer-inner)/steps;
      const R = {
        degRing:  outer,
        mansions: outer - step*1,
        decans :  outer - step*2,
        maya   :  outer - step*3,
        tepe   :  outer - step*4,
        zodiacR:  outer - step*5,
        metonic:  outer - step*6,
        moonPh :  outer - step*7
      };

      // Degree ring
      circle(tctx, cx, cy, R.degRing, "#444");
      for(let d=0; d<360; d+=5){
        const a=deg2rad(d), major = d%30===0, len = major?14:7;
        const x1=cx+(R.degRing-len)*Math.cos(a), y1=cy+(R.degRing-len)*Math.sin(a);
        const x2=cx+R.degRing*Math.cos(a),      y2=cy+R.degRing*Math.sin(a);
        tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2);
        tctx.strokeStyle="#667085"; tctx.stroke();
        if(major){
          tctx.fillStyle="#aab4c8"; tctx.font="12px Arial";
          tctx.fillText(String(d), cx+(R.degRing-28)*Math.cos(a), cy+(R.degRing-28)*Math.sin(a));
        }
      }

      ["mansions","decans","maya","tepe","zodiacR","metonic"].forEach(k=>circle(tctx,cx,cy,R[k],"#2a3347"));

      // labels (unchanged art)
      tctx.fillStyle="violet"; tctx.font="22px Arial";
      zodiac.forEach((z,i)=>{ const a=deg2rad(i*30); tctx.fillText(z, cx+R.zodiacR*Math.cos(a), cy+R.zodiacR*Math.sin(a)); });

      tctx.fillStyle="orange";
      for(let i=0;i<19;i++){ const a=deg2rad(i*(360/19)); tctx.fillRect(cx+R.metonic*Math.cos(a)-2, cy+R.metonic*Math.sin(a)-2, 4,4); }

      tctx.fillStyle="cyan"; tctx.font="18px Arial";
      tepeSymbols.forEach((s,i)=>{ const a=deg2rad(i*30); tctx.fillText(s, cx+R.tepe*Math.cos(a), cy+R.tepe*Math.sin(a)); });

      tctx.fillStyle="lime"; tctx.font="16px Arial";
      mayaSigns.forEach((s,i)=>{ const a=deg2rad(i*(360/20)); tctx.fillText(s, cx+R.maya*Math.cos(a), cy+R.maya*Math.sin(a)); });

      tctx.fillStyle="red"; tctx.font="13px Arial";
      for(let i=0;i<36;i++){ const a=deg2rad(i*10); tctx.fillText(String(i+1), cx+R.decans*Math.cos(a), cy+R.decans*Math.sin(a)); });

      tctx.fillStyle="yellow"; tctx.font="13px Arial";
      for(let i=0;i<28;i++){ const a=deg2rad(i*(360/28)); tctx.fillText(String(i+1), cx+R.mansions*Math.cos(a), cy+R.mansions*Math.sin(a)); });

      tctx.fillStyle="white"; tctx.font="18px Arial";
      ["🌑","🌓","🌕","🌗"].forEach((p,i)=>{ const a=deg2rad(i*90); tctx.fillText(p, cx+R.moonPh*Math.cos(a), cy+R.moonPh*Math.sin(a)); });

      const rot = rotDeg||0;

      // Gray meridian hand
      pointer(tctx,cx,cy,R.degRing, 0, "#9aa0a6");

      // Hands (subtract orientation)
      const dialColors = { mansions:"#ffd166", decans:"#ff4d4d", maya:"#98fb98", tepe:"#6ee7ff", zodiac:"#c084fc", metonic:"#ffa500", moonPh:"#ffffff" };
      pointer(tctx,cx,cy,R.mansions, normDeg(A.mansions - rot), dialColors.mansions);
      pointer(tctx,cx,cy,R.decans,   normDeg(A.decans   - rot), dialColors.decans);
      pointer(tctx,cx,cy,R.maya,     normDeg(A.maya     - rot), dialColors.maya);
      pointer(tctx,cx,cy,R.tepe,     normDeg(A.tepe     - rot), dialColors.tepe);
      pointer(tctx,cx,cy,R.zodiacR,  normDeg(A.zodiac   - rot), dialColors.zodiac);   // Sun along zodiac
      pointer(tctx,cx,cy,R.metonic,  normDeg(A.metonic  - rot), dialColors.metonic);
      pointer(tctx,cx,cy,R.moonPh,   normDeg(A.moon     - rot), dialColors.moonPh);   // Moon master
    }

    /* ------------------ BOTTOM CLOCK ------------------ */
    const bottomCanvas = document.getElementById("bottomClock");
    const bctx = bottomCanvas.getContext("2d");

    const BASE_NUM_PX = 12.6;
    const BASE_LABEL_PX = 13.5;

    const rings = [
      {label:"Moon Cycle (Phases)", key:"moon",     color:"white",   divisions:8,   symbols:["🌑","🌒","🌓","🌔","🌕","🌖","🌗","🌘"], showNumbers:false, numbersFontPx:BASE_NUM_PX, tickLen:5},
      {label:"Moon Days 1–29",      key:"moondays", color:"white",   divisions:29,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:6},
      {label:"Olympiad 4y",         key:"olymp",    color:"blue",    divisions:4,   showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Agricultural 12",     key:"farm",     color:"green",   divisions:12,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Metonic 19y",         key:"meton",    color:"orange",  divisions:19,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Saros 18y+11d",       key:"saros",    color:"red",     divisions:18,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Exeligmos 54y",       key:"exel",     color:"cyan",    divisions:54,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Mesoamerican 52y",    key:"meso",     color:"yellow",  divisions:52,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Native American Days (1–365)", key:"native365", color:"#9acd32", divisions:365, showNumbers:true, labelEvery:10, numbersFontPx:11, tickLen:6}
    ];

    function computeLabelEvery(ctx, r, divisions, fontPx, padding=10){
      const radiusForLabels = r - 20;
      const circumference = 2 * Math.PI * Math.max(radiusForLabels, 1);
      const sample = String(divisions);
      ctx.font = `${fontPx}px Arial`;
      const sampleWidth = Math.max(ctx.measureText(sample).width, ctx.measureText("88").width);
      const needed = sampleWidth + padding;
      const maxLabels = Math.max(1, Math.floor(circumference / needed));
      return Math.max(1, Math.ceil(divisions / Math.max(1,maxLabels)));
    }

    function ringTicksAndNumbers(ctx,cx,cy,r,ring){
      const { divisions, color, showNumbers, symbols, numbersFontPx=BASE_NUM_PX, tickLen=7 } = ring;

      circle(ctx,cx,cy,r,color);
      setMid(ctx);
      const labelPx = (ring.key === 'farm') ? BASE_LABEL_PX * 0.90 : BASE_LABEL_PX;
      ctx.fillStyle=color; ctx.font=`${labelPx}px Arial`;
      ctx.fillText(ring.label, cx, cy - r - 13);

      ctx.strokeStyle=color; ctx.fillStyle=color; ctx.font=`${numbersFontPx}px Arial`;
      const every = ring.labelEvery ?? computeLabelEvery(ctx, r, divisions, numbersFontPx);

      for(let i=0;i<divisions;i++){
        const a=deg2rad(i*(360/divisions));
        const x1=cx+(r-tickLen)*Math.cos(a), y1=cy+(r-tickLen)*Math.sin(a);
        const x2=cx+(r)*Math.cos(a),         y2=cy+(r)*Math.sin(a);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

        const tx=cx+(r-20)*Math.cos(a), ty=cy+(r-20)*Math.sin(a);
        if(symbols){ ctx.fillText(symbols[i%symbols.length], tx, ty); }
        else if(showNumbers){ if(i % every === 0){ ctx.fillText(String(i+1), tx, ty); } }
      }
    }

    function drawBottomClock(dateUTC, rotDeg){
      const A = computeAngles(dateUTC);
      const {cx, cy, rMax} = dims(bottomCanvas);
      bctx.clearRect(0,0,bottomCanvas.width,bottomCanvas.height);
      setMid(bctx);

      const inner = 0.18*rMax, outer = 0.95*rMax;
      const step = (outer-inner)/(rings.length-1);
      rings.forEach((ring,i)=> ring.r = inner + i*step);

      rings.forEach(ring => ringTicksAndNumbers(bctx,cx,cy,ring.r,ring));

      const rot = rotDeg||0;

      // Gray meridian hand
      pointer(bctx, cx, cy, rings[rings.length-1].r, 0, "#9aa0a6");
      // Yellow Moon hand
      pointer(bctx, cx, cy, rings[rings.length-1].r, normDeg(A.moon - rot), "yellow");

      bctx.beginPath(); bctx.arc(cx,cy,6,0,Math.PI*2); bctx.fillStyle="yellow"; bctx.fill();
    }

    /* ------------------ Input / validation / control ------------------ */
    function getInputsStrict(){
      let dateStr = document.getElementById('dateInput').value.trim();
      const latStr  = document.getElementById('latInput').value.trim();
      const lonStr  = document.getElementById('lonInput').value.trim();

      if(!dateStr || !latStr || !lonStr){
        return { ok:false, msg:"Please enter a <b>date</b>, <b>latitude</b>, and <b>longitude</b> (all three are required)." };
      }

      // Flexible date parsing
      const parts = parseDateFlexible(dateStr);
      if(!parts){ return { ok:false, msg:"Date must be in <b>YYYY-MM-DD</b> or <b>MM/DD/YYYY</b> format." }; }
      const {y,m,d} = parts;

      const lat = parseFloat(latStr), lon = parseFloat(lonStr);
      if(!(isFinite(lat) && isFinite(lon))){
        return { ok:false, msg:"Latitude/Longitude must be valid numbers." };
      }
      if(lat < -90 || lat > 90){ return { ok:false, msg:"Latitude must be between -90 and 90 degrees." }; }
      if(lon < -180 || lon > 180){ return { ok:false, msg:"Longitude must be between -180 and 180 degrees.<br>Texas is negative (e.g., <b>-97.45960</b>)." }; }

      const dateUTC = utcFromLocalMeanNoonYMD(y,m,d, lon);
      const isoYMD = `${y.toString().padStart(4,"0")}-${m.toString().padStart(2,"0")}-${d.toString().padStart(2,"0")}`;

      return { ok:true, dateUTC, lat, lon, dateStr:isoYMD };
    }

    function renderStrict(){
      const out = document.getElementById('output');
      const res = getInputsStrict();
      if(!res.ok){
        out.className = "error";
        out.innerHTML = res.msg;
        [topCanvas, bottomCanvas].forEach(c => c.getContext("2d").clearRect(0,0,c.width,c.height));
        return;
      }
      out.className = "";

      const rot = lstDeg(res.dateUTC, res.lon);    // sky orientation
      drawTopClock(res.dateUTC, rot);
      drawBottomClock(res.dateUTC, rot);

      const lambda = sunEclipticLongitude(res.dateUTC);
      const sign = sunZodiacName(lambda);
      const moonDay = computeAngles(res.dateUTC).moonDay;
      const moonDayRounded = Math.floor(moonDay)+1;

      out.innerHTML =
        `Synced for <b>${res.dateStr}</b> at lat <b>${res.lat.toFixed(5)}°</b>, lon <b>${res.lon.toFixed(5)}°</b> • Sun on zodiac: <b>${sign}</b> • Moon day: <b>${moonDayRounded}</b> • Orientation by LST.`;
    }

    function startClock(){ renderStrict(); }
    function resetClock(){
      document.getElementById('dateInput').value = "";
      document.getElementById('latInput').value = "";
      document.getElementById('lonInput').value = "";
      const out = document.getElementById('output');
      out.className=""; out.innerHTML = 'Enter <b>date + latitude + longitude</b> to sync both clocks.';
      [topCanvas, bottomCanvas].forEach(c => c.getContext("2d").clearRect(0,0,c.width,c.height));
    }
  </script>
</body>
</html>
