<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ğŸª Cosmic Clock (Dual Panel + Physics)</title>
<style>
  :root{ --gap:22px; }
  body{
    margin:0; background:#0a0f1f; color:#fff; font-family:Arial, Helvetica, sans-serif;
    min-height:100vh; display:flex; align-items:flex-start; justify-content:center;
  }
  #container{
    display:flex; align-items:flex-start; justify-content:center; gap:var(--gap);
    padding:18px; max-width:calc(100vw - 18px); overflow:auto; flex-wrap:wrap;
  }

  /* Left controls */
  #infoPanel{ width:420px; text-align:left; line-height:1.6em; }
  #infoPanel h1{ color:gold; font-size:28px; margin:0 0 8px 0; }

  #howto{ font-size:0.95em; color:#cfd8e3; margin:0 0 8px 0; }
  #howto p{ margin:4px 0; }

  label{ display:block; margin:8px 0 4px; font-size:1.05em; }
  input, select{
    width:100%; padding:9px 10px; font-size:1.05em;
    border:1px solid #334155; background:#0f172a; color:#e5e7eb; border-radius:8px;
  }
  .btnRow{ margin-top:10px; display:flex; gap:10px; }
  .btn{
    background:#2563eb; color:#fff; border:none; border-radius:8px; cursor:pointer;
    padding:9px 16px; font-size:1.05em;
  }
  .btn:hover{ background:#1d4ed8; }
  #output{ font-size:1.05em; margin-top:12px; }
  .note{ font-size:0.95em; color:#bbb; margin-top:10px; }
  .error{ color:#ff7b7b; }

  /* Readouts panel */
  #readouts{
    margin-top:10px; padding:12px;
    background:#0b1327; border:1px solid #223; border-radius:8px;
    color:#dbe2ef; font-size:0.96em;
  }
  #readouts h3{ margin:6px 0 4px 0; font-size:15px; color:#93c5fd; }
  #readouts ul{ margin:6px 0 10px 16px; padding:0; }
  #readouts li{ margin:2px 0; }

  /* Physics panel */
  #physicsPanel{
    margin-top:12px; padding:12px;
    background:#020617; border:1px solid #1f2937; border-radius:8px;
    color:#e5e7eb; font-size:0.93em;
  }
  #physicsPanel h3{ margin:4px 0 4px 0; font-size:14px; color:#7dd3fc; }
  #physicsPanel p{ margin:4px 0; }
  #physicsPanel .subgrid{
    display:grid; gap:8px 10px;
    grid-template-columns: 1fr;
  }
  #physicsPanel small{ color:#9ca3af; }

  .rowLine{
    display:flex; align-items:center; justify-content:space-between;
    gap:8px; margin-top:4px;
  }
  .rowLine span{ font-size:0.9em; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .muted{ color:#a9b4c2; font-size:0.92em; }

  /* Right column: clocks + legend stacked */
  #rightCol{ display:flex; flex-direction:column; gap:var(--gap); align-items:center; }

  /* Canvases */
  canvas{ background:#111; border:2px solid #333; display:block; }
  #cosmicClock, #bottomClock{ width:715px; height:715px; }

  /* Legend panel */
  #legend{
    width:715px;
    background:#0f172a; border:2px solid #333; border-radius:10px;
    padding:14px; color:#dbe2ef; font-size:0.97em;
  }
  #legend h2{ margin:0 0 8px 0; font-size:18px; color:#ffe58a; }
  #legend h3{ margin:12px 0 6px 0; font-size:15px; color:#9ad1ff; }

  .grid{
    display:grid; gap:8px 14px;
    grid-template-columns: 1fr 1fr;
  }
  .row{ display:flex; align-items:flex-start; gap:8px; }
  .swatch{
    width:14px; height:14px; border-radius:3px; margin-top:3px;
    border:1px solid rgba(255,255,255,0.15);
  }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .muted{ color:#a9b4c2; font-size:0.92em; }
</style>
</head>
<body>
  <div id="container">
    <!-- Left controls -->
    <div id="infoPanel">
      <h1>ğŸª Cosmic Clock</h1>

      <div id="howto">
        <p><b>Quick how-to</b>:</p>
        <p><b>Date only</b> â†’ draws the geocentric sky for that day with <i>north up</i> (12 oâ€™clock).</p>
        <p><b>Date + latitude/longitude</b> â†’ enables the <b>Orientation</b> menu:
          <i>Local noon</i> puts the Sun at the top for that date/place; <i>Sidereal (LST)</i> aligns the meridian with the local sky; <i>Fixed</i> keeps north up.</p>
        <p><b>Steps</b>: (1) Enter date. (2) Optional: enter lat & lon. (3) Choose orientation. (4) Press <b>Start</b>. (5) <b>Reset</b> clears inputs and zeros all dials.</p>
      </div>

      <label for="dateInput">Date (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)</label>
      <input type="text" id="dateInput" placeholder="e.g. 1987-05-09 or 05/11/1967" />

      <label for="latInput">Latitude (Â°) â€” optional, for orientation</label>
      <input type="number" id="latInput" step="0.00001" placeholder="e.g. 25.93742" />

      <label for="lonInput">Longitude (Â°) â€” optional, for orientation</label>
      <input type="number" id="lonInput" step="0.00001" placeholder="e.g. -97.45960" />

      <label for="orientSel">Orientation</label>
      <select id="orientSel">
        <option value="noon">Local noon at location (on that date)</option>
        <option value="lst">Sidereal (LST at location)</option>
        <option value="north" selected>Fixed meridian (true north up)</option>
      </select>

      <div class="btnRow">
        <button class="btn" onclick="startClock()">Start</button>
        <button class="btn" onclick="resetClock()">Reset</button>
      </div>

      <div id="output">Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.</div>
      <div class="note">
        âš ï¸ Antikythera-style mechanism. The Moon is the main dial that drives the system.
      </div>

      <!-- Dial Readouts (auto-filled on Start) -->
      <div id="readouts"></div>

      <!-- Advanced Physics Layer -->
      <div id="physicsPanel">
        <h3>Advanced Physics Enhancements â€” SR â€¢ GR â€¢ Sidereal â€¢ RA/Dec â€¢ Light-time</h3>
        <p class="muted">
          CST stays your narrative layer. These equations add the engineering layer:
          special relativity, gravity wells, true sidereal drift, sky coordinates, and light-travel delay.
        </p>

        <!-- SR + GR -->
        <div class="subgrid" style="margin-top:6px;">
          <div>
            <h3>1. Special Relativity â€” Time Dilation</h3>
            <p class="mono">Î”tâ€² = Î”t Â· âˆš(1 âˆ’ vÂ²/cÂ²)</p>
            <label for="srVelInput">Ship velocity (fraction of c)</label>
            <input id="srVelInput" type="range" min="0" max="0.99" step="0.01" value="0" />
            <div class="rowLine">
              <span>v â‰ˆ <span id="srVelLabel" class="mono">0.0% c</span></span>
              <span>Î³ = <span id="srGammaOut" class="mono">1.000000</span></span>
            </div>

            <label for="srDtYears" style="margin-top:8px;">Reference interval Î”t (years)</label>
            <input id="srDtYears" type="number" step="0.01" value="1.00" />

            <p style="margin-top:6px;">
              <b>CST interval:</b> <span id="srDtBaseOut" class="mono">1.0000 years</span><br/>
              <b>Proper Î”tâ€² (moving frame):</b> <span id="srDtPrimeOut" class="mono">1.0000 years</span>
            </p>
          </div>

          <div>
            <h3>2. Gravitational Time Dilation</h3>
            <p class="mono">Î”tâ€² = Î”t Â· âˆš(1 âˆ’ 2GM/(r cÂ²))</p>
            <label for="grBodySelect">Reference mass / radius</label>
            <select id="grBodySelect">
              <option value="earth">Earth surface</option>
              <option value="leo">Low Earth orbit (400 km)</option>
              <option value="neutron">Toy neutron star (compact)</option>
            </select>
            <p style="margin-top:6px;">
              GR factor âˆš(1 âˆ’ 2GM/rcÂ²): <span id="grFactorOut" class="mono">â€”</span><br/>
              Î”tâ€² in gravity well: <span id="grDtPrimeOut" class="mono">â€”</span>
            </p>
            <p><small>Uses the same Î”t from above. Extreme compact objects will show strong slowing of time.</small></p>
          </div>
        </div>

        <!-- Sidereal -->
        <div style="margin-top:10px;">
          <h3>3. Sidereal vs Solar â€” Star Drift</h3>
          <p class="mono">Sidereal day â‰ˆ 23h 56m 4.1s</p>
          <p>
            Per-day drift (solar âˆ’ sidereal): <span id="sidPerDayOut" class="mono">+00:03:55</span><br/>
            Accumulated drift from J2000 â†’ selected date: <span id="sidAccumOut" class="mono">â€” (set date first)</span>
          </p>
          <p><small>
            As centuries pass, this drift slowly slides your calendars against the true star field.
          </small></p>
        </div>

        <!-- RA/Dec -->
        <div style="margin-top:10px;">
          <h3>4. Star Coordinate Mapping â€” RA/Dec â†’ (x, y, z)</h3>
          <p class="mono">x = cos Î´ Â· cos Î± &nbsp;&nbsp; y = cos Î´ Â· sin Î± &nbsp;&nbsp; z = sin Î´</p>
          <label for="raHours">Right Ascension Î± (hours)</label>
          <input id="raHours" type="number" step="0.0001" placeholder="e.g. 5.9195 (Betelgeuse)" />
          <label for="decDeg">Declination Î´ (degrees)</label>
          <input id="decDeg" type="number" step="0.0001" placeholder="e.g. 7.407" />
          <p style="margin-top:6px;">
            (x, y, z) â‰ˆ
            <span class="mono">
              (<span id="radecXOut">â€”</span>,
               <span id="radecYOut">â€”</span>,
               <span id="radecZOut">â€”</span>)
            </span>
          </p>
        </div>

        <!-- Light-time -->
        <div style="margin-top:10px;">
          <h3>5. Light-Time Correction â€” Lookback Age</h3>
          <p class="mono">t = d / c  (for astronomical distances, t â‰ˆ distance in light-years)</p>
          <label for="ltDistanceLy">Distance d (light-years)</label>
          <input id="ltDistanceLy" type="number" step="0.01" placeholder="e.g. 8.6 (Sirius) or 642 (Betelgeuse)" />
          <p style="margin-top:6px;">
            Light-travel time t â‰ˆ <span id="ltYearsOut" class="mono">â€”</span><br/>
            <span id="ltDescOut" class="muted">Enter a distance to see how far back in time the photons began their journey.</span>
          </p>
        </div>
      </div>
    </div>

    <!-- Right: clocks + legend -->
    <div id="rightCol">
      <canvas id="cosmicClock" width="715" height="715"></canvas>
      <canvas id="bottomClock" width="715" height="715"></canvas>

      <!-- Legend panel -->
      <section id="legend">
        <h2>Legend & Dial Meanings</h2>

        <h3>Hands (pointers)</h3>
        <div class="grid">
          <div class="row"><span class="swatch" style="background:#9aa0a6"></span><div><b>Meridian</b> â€” true-north reference line at 12 oâ€™clock.</div></div>
          <div class="row"><span class="swatch" style="background:#c084fc"></span><div><b>Sun</b> â€” ecliptic longitude (zodiac position) on the top face.</div></div>
          <div class="row"><span class="swatch" style="background:#ffffff"></span><div><b>Moon (phase)</b> â€” synodic phase hand on the top face.</div></div>
          <div class="row"><span class="swatch" style="background:yellow"></span><div><b>Moon (agri)</b> â€” main agricultural/planning hand on the bottom face.</div></div>
          <div class="row"><span class="swatch" style="background:#ffd166"></span><div><b>Lunar Mansions</b> â€” sidereal-moon pointer.</div></div>
          <div class="row"><span class="swatch" style="background:#ff4d4d"></span><div><b>Decans</b> â€” 36 ten-degree sky segments.</div></div>
          <div class="row"><span class="swatch" style="background:#98fb98"></span><div><b>Maya ring</b> â€” 20-day cycle index.</div></div>
          <div class="row"><span class="swatch" style="background:#6ee7ff"></span><div><b>Tepe ring</b> â€” 12-division symbolic cycle.</div></div>
          <div class="row"><span class="swatch" style="background:#ffa500"></span><div><b>Metonic</b> â€” 19-year Moon/Sun calendar resonance.</div></div>
        </div>

        <h3>Top Face â€” Ring Guide</h3>
        <ul>
          <li><b>Degree ring (outer ticks)</b> â€” 0â€“360Â° scale with 30Â° zodiac marks.</li>
          <li><b>Zodiac glyphs</b> â€” 12 signs around the ecliptic.</li>
          <li><b>Tepe symbols</b> â€” 12 pictograms (cultural cycle).</li>
          <li><b>Maya ring (20)</b> â€” 20 day-signs.</li>
          <li><b>Decans (36)</b> â€” 36 ten-degree segments (Egyptian/astrological).</li>
          <li><b>Lunar mansions (28)</b> â€” sidereal lunar stations.</li>
          <li><b>Metonic markers (19)</b> â€” 19-year cycle pegs.</li>
          <li><b>Moon phases</b> â€” ğŸŒ‘ ğŸŒ“ ğŸŒ• ğŸŒ— markers.</li>
        </ul>

        <h3>Bottom Face â€” Ring Guide</h3>
        <ul>
          <li><b>Moon Cycle (8)</b> â€” phase icons.</li>
          <li><b>Moon Days (1â€“29)</b> â€” synodic day number.</li>
          <li><b>Olympiad (4y)</b> â€” four-year cycle.</li>
          <li><b>Agricultural 12</b> â€” month/seasonal labors.</li>
          <li><b>Metonic (19y)</b> â€” lunar-solar calendar repeat.</li>
          <li><b>Saros (â‰ˆ18y11d)</b> â€” eclipse period.</li>
          <li><b>Exeligmos (54y)</b> â€” triple Saros correction.</li>
          <li><b>Mesoamerican 52y</b> â€” Calendar Round.</li>
          <li><b>Native American Days (1â€“365)</b> â€” solar day index.</li>
        </ul>

        <p class="muted">
          <span class="mono">Note:</span> Planetary pointers for Venus/Saturn/etc. are not rendered in this build; the Sun and Moon are the active celestial hands. The colored hands for mansions/decans/Maya/Tepe/Metonic represent non-planetary cycles.
        </p>
      </section>
    </div>
  </div>

<script>
/* ------------------ shared helpers ------------------ */
function dims(canvas){
  const cx = canvas.width/2, cy = canvas.height/2;
  const rMax = Math.min(cx, cy) - 18;
  return { cx, cy, rMax };
}
function setMid(ctx){ ctx.textAlign="center"; ctx.textBaseline="middle"; }
function circle(ctx, cx, cy, r, color="#333", lw=1){
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.stroke(); ctx.lineWidth=1;
}
function deg2rad(deg){ return (deg-90)*Math.PI/180; }
function normDeg(x){ x%=360; return x<0?x+360:x; }
function shortestDelta(a,b){ let d=(b-a+540)%360-180; return d; }
function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }

function dmsStr(angle){
  const a = ((angle%360)+360)%360;
  const d = Math.floor(a);
  const m = Math.round((a-d)*60);
  return `${d}Â° ${m}â€²`;
}
function indexInDiv(angle, divisions){
  const a = ((angle%360)+360)%360;
  const step = 360/divisions;
  const idx = Math.floor(a/step)+1;
  const within = a - Math.floor(a/step)*step;
  return { index: idx, within, step };
}
function moonPhaseName(ageDays){
  const seg = MOON_SYNODIC/8;
  const i = Math.floor(((ageDays%MOON_SYNODIC)+MOON_SYNODIC)%MOON_SYNODIC/seg);
  return ["New Moon","Waxing Crescent","First Quarter","Waxing Gibbous",
          "Full Moon","Waning Gibbous","Last Quarter","Waning Crescent"][i];
}

/* --------- drawing helpers ---------- */
function pointer(ctx, cx, cy, r, angleDeg, color){
  const a = deg2rad(angleDeg);
  const tipX = cx + r*Math.cos(a), tipY = cy + r*Math.sin(a);
  const back = 18, half = 6;
  ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tipX,tipY); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(tipX - back*Math.cos(a) + half*Math.sin(a), tipY - back*Math.sin(a) - half*Math.cos(a));
  ctx.lineTo(tipX - back*Math.cos(a) - half*Math.sin(a), tipY - back*Math.sin(a) + half*Math.cos(a));
  ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
  ctx.lineWidth=1;
}
function labelCenteredOnHand(ctx, cx, cy, r, angleDeg, text, color, perpOffset=12){
  const a = deg2rad(angleDeg);
  const midR = r * 0.52;
  const mx = cx + midR * Math.cos(a);
  const my = cy + midR * Math.sin(a);
  const nx = -Math.sin(a), ny =  Math.cos(a);
  const lx = mx + perpOffset * nx;
  const ly = my + perpOffset * ny;
  ctx.save();
  ctx.font = "13px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.strokeText(text, lx, ly);
  ctx.fillStyle = color; ctx.fillText(text, lx, ly);
  ctx.restore();
}

/* ------------------ time / cycle engine ------------------ */
const TROPICAL_YEAR = 365.2422;
const MOON_SYNODIC = 29.530588;
const MOON_SIDEREAL = 27.321661;
const METONIC = 6939.69;
const SAROS = 6585.321;
const EXELIGMOS = SAROS * 3;
const OLYMPIAD = 1461.0;
const MESOAMERICAN_52Y = 52 * 365.0;
const NATIVE_YEAR = 365.0;

const EPOCH = Date.UTC(2000,0,1,12,0,0);
const NEW_MOON_REF = Date.UTC(2000,0,6,18,14,0);

function daysSince(ms, ref){ return (ms - ref) / 86400000; }
function norm(x,p){ x%=p; return x<0?x+p:x; }

// Simple Sun ecliptic longitude (~1Â°)
function sunEclipticLongitude(dateUTC){
  const n = (dateUTC.getTime() - Date.UTC(2000,0,1,0,0,0)) / 86400000;
  const L = 280.460 + 0.9856474 * n;
  const g = (357.528 + 0.9856003 * n) * Math.PI/180;
  const lambda = L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2*g);
  return normDeg(lambda);
}
function sunZodiacName(lambda){
  const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
  return signs[Math.floor(normDeg(lambda)/30)];
}
function signDegMin(lambda){
  const sign = sunZodiacName(lambda);
  const dTot = normDeg(lambda) % 30;
  const d = Math.floor(dTot);
  const m = Math.round((dTot - d) * 60);
  return {sign, d, m};
}

// JD / GMST / LST (deg)
function julianDay(dateUTC){ return dateUTC.getTime()/86400000 + 2440587.5; }
function gmstDeg(dateUTC){
  const JD = julianDay(dateUTC);
  const T = (JD - 2451545.0)/36525.0;
  let gmst = 280.46061837 + 360.98564736629*(JD-2451545.0) + 0.000387933*T*T - (T*T*T)/38710000.0;
  return normDeg(gmst);
}
function lstDeg(dateUTC, longitudeDeg){ return normDeg(gmstDeg(dateUTC) + longitudeDeg); }

// Parse date
function parseDateFlexible(s){
  if(!s) return null;
  if (s.includes('-')){
    const parts = s.split('-').map(n=>parseInt(n,10));
    if (parts[0] > 31) { const [y,m,d]=parts; if(isFinite(y)&&isFinite(m)&&isFinite(d)) return {y,m,d}; }
    else { const [mm,dd,yy]=parts; if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return {y:yy,m:mm,d:dd}; }
  }
  if(s.includes('/')){
    const [mm,dd,yy] = s.split('/').map(n=>parseInt(n,10));
    if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return { y:yy, m:mm, d:dd };
  }
  return null;
}

// Local Mean Noon UTC
function utcFromLocalMeanNoonYMD(y,m,d, lonDeg){
  const utcNoon = Date.UTC(y, m-1, d, 12, 0, 0);
  return new Date(utcNoon - lonDeg*240000); // 4 min/deg
}

function computeAngles(dateUTC){
  const t = dateUTC.getTime();
  const dMoon = daysSince(t, NEW_MOON_REF);
  const dEpoch = daysSince(t, EPOCH);
  return {
    moon:      normDeg( norm(dMoon, MOON_SYNODIC) / MOON_SYNODIC * 360 ),
    moonDay:   norm(dMoon, MOON_SYNODIC),           // 0..29.53
    mansions:  normDeg(dMoon / MOON_SIDEREAL * 360),
    zodiac:    sunEclipticLongitude(dateUTC),
    decans:    normDeg(dEpoch / TROPICAL_YEAR * 360),
    tepe:      normDeg(dEpoch / TROPICAL_YEAR * 360),
    maya:      normDeg(dEpoch / 20.0 * 360),
    metonic:   normDeg(dEpoch / METONIC * 360),
    saros:     normDeg(dEpoch / SAROS * 360),
    exeligmos: normDeg(dEpoch / EXELIGMOS * 360),
    olympiad:  normDeg(dEpoch / OLYMPIAD * 360),
    meso:      normDeg(dEpoch / MESOAMERICAN_52Y * 360),
    native365: normDeg(dEpoch / NATIVE_YEAR * 360),
  };
}

/* ------------------ Advanced Physics panel logic ------------------ */

// Constants for GR, SR, sidereal drift
const G_CONST = 6.6743e-11;
const C_CONST = 299792458;
const SOLAR_DAY_SEC = 86400;
const SIDEREAL_DAY_SEC = 86164.1;

// Bodies for GR
const GR_BODIES = {
  earth:{ M:5.972e24, r:6.371e6 },
  leo:{   M:5.972e24, r:6.771e6 },   // Earth radius + 400 km
  neutron:{ M:2.0e30, r:1.0e4 }      // toy compact object
};

// Physics panel elements
const srVelInput   = document.getElementById('srVelInput');
const srVelLabel   = document.getElementById('srVelLabel');
const srGammaOut   = document.getElementById('srGammaOut');
const srDtYearsInp = document.getElementById('srDtYears');
const srDtBaseOut  = document.getElementById('srDtBaseOut');
const srDtPrimeOut = document.getElementById('srDtPrimeOut');

const grBodySelect = document.getElementById('grBodySelect');
const grFactorOut  = document.getElementById('grFactorOut');
const grDtPrimeOut = document.getElementById('grDtPrimeOut');

const sidPerDayOut = document.getElementById('sidPerDayOut');
const sidAccumOut  = document.getElementById('sidAccumOut');

const raHoursInp   = document.getElementById('raHours');
const decDegInp    = document.getElementById('decDeg');
const radecXOut    = document.getElementById('radecXOut');
const radecYOut    = document.getElementById('radecYOut');
const radecZOut    = document.getElementById('radecZOut');

const ltDistanceLyInp = document.getElementById('ltDistanceLy');
const ltYearsOut      = document.getElementById('ltYearsOut');
const ltDescOut       = document.getElementById('ltDescOut');

let lastMeta = null; // remembers last date/location for sidereal drift

function secondsToHMS(sec){
  const sign = sec>=0 ? '+' : 'âˆ’';
  const A = Math.abs(sec);
  const h = Math.floor(A/3600);
  const m = Math.floor((A%3600)/60);
  const s = Math.round(A%60);
  const z = n => String(n).padStart(2,'0');
  return `${sign}${z(h)}:${z(m)}:${z(s)}`;
}

// SR + GR update
function updateSRGR(){
  // velocity
  const vFrac = parseFloat(srVelInput.value) || 0;
  srVelLabel.textContent = (vFrac*100).toFixed(1) + "% c";

  const beta2 = Math.max(0, Math.min(0.9999, vFrac))**2;
  const gamma = 1 / Math.sqrt(1 - beta2);
  srGammaOut.textContent = gamma.toFixed(6);

  // interval in years
  let dtYears = parseFloat(srDtYearsInp.value);
  if(!isFinite(dtYears) || dtYears <= 0){
    dtYears = 1.0;
    srDtYearsInp.value = dtYears.toFixed(2);
  }
  srDtBaseOut.textContent = dtYears.toFixed(4) + " years";

  // SR proper time
  const properYears = dtYears * Math.sqrt(1 - beta2);
  srDtPrimeOut.textContent = properYears.toFixed(4) + " years";

  // GR factor
  const bodyKey = grBodySelect.value || "earth";
  const body = GR_BODIES[bodyKey] || GR_BODIES.earth;
  const arg = 1 - (2*G_CONST*body.M)/(body.r*C_CONST*C_CONST);
  if(arg <= 0){
    grFactorOut.textContent  = "N/A";
    grDtPrimeOut.textContent = "inside horizon";
  } else {
    const fac = Math.sqrt(arg);
    grFactorOut.textContent = fac.toExponential(6);
    const grYears = dtYears * fac;
    grDtPrimeOut.textContent = grYears.toFixed(4) + " years";
  }
}

// Sidereal drift update
function updateSiderealDrift(){
  const perDay = SOLAR_DAY_SEC - SIDEREAL_DAY_SEC; // ~235.9 s
  sidPerDayOut.textContent = secondsToHMS(perDay);
  if(!lastMeta || !lastMeta.dateUTC){
    sidAccumOut.textContent = "â€” (set date first)";
    return;
  }
  const days = daysSince(lastMeta.dateUTC.getTime(), EPOCH);
  const driftSec = days * perDay;
  sidAccumOut.textContent = secondsToHMS(driftSec);
}

// RA/Dec â†’ (x,y,z)
function updateRaDecXYZ(){
  const raH = parseFloat(raHoursInp.value);
  const decD = parseFloat(decDegInp.value);
  if(!isFinite(raH) || !isFinite(decD)){
    radecXOut.textContent = "â€”";
    radecYOut.textContent = "â€”";
    radecZOut.textContent = "â€”";
    return;
  }
  const alpha = raH * (Math.PI/12);   // hours â†’ radians
  const delta = decD * (Math.PI/180); // degrees â†’ radians
  const x = Math.cos(delta)*Math.cos(alpha);
  const y = Math.cos(delta)*Math.sin(alpha);
  const z = Math.sin(delta);
  radecXOut.textContent = x.toFixed(4);
  radecYOut.textContent = y.toFixed(4);
  radecZOut.textContent = z.toFixed(4);
}

// Light-time
function updateLightTime(){
  const dLy = parseFloat(ltDistanceLyInp.value);
  if(!isFinite(dLy) || dLy <= 0){
    ltYearsOut.textContent = "â€”";
    ltDescOut.textContent  = "Enter a distance > 0 to see the light-travel time.";
    return;
  }
  const years = dLy; // by definition: 1 ly â‰ˆ light travels for 1 year
  ltYearsOut.textContent = years.toFixed(2) + " years";
  ltDescOut.textContent  = `You see this object as it was about ${years.toFixed(2)} years ago.`;
}

// Physics panel event wiring
srVelInput.addEventListener('input', updateSRGR);
srDtYearsInp.addEventListener('input', updateSRGR);
grBodySelect.addEventListener('change', updateSRGR);
raHoursInp.addEventListener('input', updateRaDecXYZ);
decDegInp.addEventListener('input', updateRaDecXYZ);
ltDistanceLyInp.addEventListener('input', updateLightTime);

// Initialize static parts
updateSRGR();
updateSiderealDrift();
updateRaDecXYZ();
updateLightTime();
/* ------------------ TOP CLOCK ------------------ */
const topCanvas = document.getElementById("cosmicClock");
const tctx = topCanvas.getContext("2d");
const tepeSymbols = ["ğŸ¦‚","ğŸ¦Š","ğŸ¦…","ğŸ‚","ğŸ","ğŸ‡","ğŸº","ğŸŸ","ğŸ¦","ğŸ¦Œ","ğŸ¦ƒ","ğŸ¢"];
const mayaSigns  = ["ğŸŠ","ğŸŒ¬ï¸","ğŸŒŠ","ğŸ”¥","ğŸ¦…","ğŸ","ğŸŒ½","ğŸ¢","ğŸ•·ï¸","ğŸ’","ğŸ•","ğŸŒ¿","ğŸŒ","ğŸŒ‘","ğŸŒ½","ğŸ¦Œ","ğŸŒ´","ğŸ¦‚","ğŸŒ•","ğŸŸ"];
const zodiacIcons = ["â™ˆ","â™‰","â™Š","â™‹","â™Œ","â™","â™","â™","â™","â™‘","â™’","â™“"];

function drawTopClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(topCanvas);
  tctx.clearRect(0,0,topCanvas.width,topCanvas.height);
  setMid(tctx);

  const outer = 0.96*rMax, inner = 0.40*rMax;
  const steps = 7, step = (outer-inner)/steps;
  const R = {
    degRing:  outer,
    mansions: outer - step*1,
    decans :  outer - step*2,
    maya   :  outer - step*3,
    tepe   :  outer - step*4,
    zodiacR:  outer - step*5,
    metonic:  outer - step*6,
    moonPh :  outer - step*7
  };

  // Degree ticks
  circle(tctx, cx, cy, R.degRing, "#444");
  for(let d=0; d<360; d+=5){
    const a=deg2rad(d), major = d%30===0, len = major?14:7;
    const x1=cx+(R.degRing-len)*Math.cos(a), y1=cy+(R.degRing-len)*Math.sin(a);
    const x2=cx+R.degRing*Math.cos(a),      y2=cy+R.degRing*Math.sin(a);
    tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2);
    tctx.strokeStyle="#667085"; tctx.stroke();
    if(major){
      tctx.fillStyle="#aab4c8"; tctx.font="12px Arial";
      tctx.fillText(String(d), cx+(R.degRing-28)*Math.cos(a), cy+(R.degRing-28)*Math.sin(a));
    }
  }
  ["mansions","decans","maya","tepe","zodiacR","metonic"].forEach(k=>circle(tctx,cx,cy,R[k],"#2a3347"));

  // Ring art
  tctx.fillStyle="violet"; tctx.font="22px Arial";
  zodiacIcons.forEach((z,i)=>{ const a=deg2rad(i*30); tctx.fillText(z, cx+R.zodiacR*Math.cos(a), cy+R.zodiacR*Math.sin(a)); });

  tctx.fillStyle="orange";
  for(let i=0;i<19;i++){ const a=deg2rad(i*(360/19)); tctx.fillRect(cx+R.metonic*Math.cos(a)-2, cy+R.metonic*Math.sin(a)-2, 4,4); }

  tctx.fillStyle="cyan"; tctx.font="18px Arial";
  tepeSymbols.forEach((s,i)=>{ const a=deg2rad(i*30); tctx.fillText(s, cx+R.tepe*Math.cos(a), cy+R.tepe*Math.sin(a)); });

  tctx.fillStyle="lime"; tctx.font="16px Arial";
  mayaSigns.forEach((s,i)=>{ const a=deg2rad(i*(360/20)); tctx.fillText(s, cx+R.maya*Math.cos(a), cy+R.maya*Math.sin(a)); });

  tctx.fillStyle="red"; tctx.font="13px Arial";
  for(let i=0;i<36;i++){ const a=deg2rad(i*10); tctx.fillText(String(i+1), cx+R.decans*Math.cos(a), cy+R.decans*Math.sin(a)); }

  tctx.fillStyle="white"; tctx.font="18px Arial";
  ["ğŸŒ‘","ğŸŒ“","ğŸŒ•","ğŸŒ—"].forEach((p,i)=>{ const a=deg2rad(i*90); tctx.fillText(p, cx+R.moonPh*Math.cos(a), cy+R.moonPh*Math.sin(a)); });

  const rot = rotDeg||0;

  // Hands + centered labels
  pointer(tctx,cx,cy,R.degRing, 0, "#9aa0a6");
  labelCenteredOnHand(tctx,cx,cy,R.degRing, 0, "Meridian", "#9aa0a6", 0);

  const aMansions = normDeg(angles.mansions - rot);
  pointer(tctx,cx,cy,R.mansions, aMansions, "#ffd166");
  labelCenteredOnHand(tctx,cx,cy,R.mansions, aMansions, "Lunar Mansions", "#ffd166", 0);

  const aDecans = normDeg(angles.decans - rot);
  pointer(tctx,cx,cy,R.decans, aDecans, "#ff4d4d");
  labelCenteredOnHand(tctx,cx,cy,R.decans, aDecans, "Decans", "#ff4d4d", 0);

  const aMaya = normDeg(angles.maya - rot);
  pointer(tctx,cx,cy,R.maya, aMaya, "#98fb98");
  labelCenteredOnHand(tctx,cx,cy,R.maya, aMaya, "Maya (20)", "#98fb98", 0);

  const aTepe = normDeg(angles.tepe - rot);
  pointer(tctx,cx,cy,R.tepe, aTepe, "#6ee7ff");
  labelCenteredOnHand(tctx,cx,cy,R.tepe, aTepe, "Tepe (12)", "#6ee7ff", 0);

  const aSun = normDeg(angles.zodiac - rot);
  pointer(tctx,cx,cy,R.zodiacR, aSun, "#c084fc");
  labelCenteredOnHand(tctx,cx,cy,R.zodiacR, aSun, "Sun", "#c084fc", 0);

  const aMet = normDeg(angles.metonic - rot);
  pointer(tctx,cx,cy,R.metonic, aMet, "#ffa500");
  labelCenteredOnHand(tctx,cx,cy,R.metonic, aMet, "Metonic", "#ffa500", 0);

  const aMoon = normDeg(angles.moon - rot);
  pointer(tctx,cx,cy,R.moonPh, aMoon, "#ffffff");
  labelCenteredOnHand(tctx,cx,cy,R.moonPh, aMoon, "Moon", "#ffffff", 0);
}

/* ------------------ BOTTOM CLOCK ------------------ */
const bottomCanvas = document.getElementById("bottomClock");
const bctx = bottomCanvas.getContext("2d");

const BASE_NUM_PX = 12.6;

const rings = [
  {label:"Moon Cycle (Phases)", key:"moon",     color:"white",   divisions:8,   symbols:["ğŸŒ‘","ğŸŒ’","ğŸŒ“","ğŸŒ”","ğŸŒ•","ğŸŒ–","ğŸŒ—","ğŸŒ˜"], showNumbers:false, numbersFontPx:BASE_NUM_PX, tickLen:5},
  {label:"Moon Days 1â€“29",      key:"moondays", color:"white",   divisions:29,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:6},
  {label:"Olympiad 4y",         key:"olymp",    color:"blue",    divisions:4,   showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Agricultural 12",     key:"farm",     color:"green",   divisions:12,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Metonic 19y",         key:"meton",    color:"orange",  divisions:19,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Saros 18y+11d",       key:"saros",    color:"red",     divisions:18,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Exeligmos 54y",       key:"exel",     color:"cyan",    divisions:54,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Mesoamerican 52y",    key:"meso",     color:"yellow",  divisions:52,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Native American Days (1â€“365)", key:"native365", color:"#9acd32", divisions:365, showNumbers:true, labelEvery:10, numbersFontPx:11, tickLen:6}
];

function computeLabelEvery(ctx, r, divisions, fontPx, padding=10){
  const radiusForLabels = r - 20;
  const circumference = 2 * Math.PI * Math.max(radiusForLabels, 1);
  ctx.font = `${fontPx}px Arial`;
  const sample = String(divisions);
  const sampleWidth = Math.max(ctx.measureText(sample).width, ctx.measureText("88").width);
  const needed = sampleWidth + padding;
  const maxLabels = Math.max(1, Math.floor(circumference / needed));
  return Math.max(1, Math.ceil(divisions / Math.max(1,maxLabels)));
}

function ringTicksAndNumbers(ctx,cx,cy,r,ring){
  const { divisions, color, showNumbers, symbols, numbersFontPx=BASE_NUM_PX, tickLen=7 } = ring;

  circle(ctx,cx,cy,r,color);
  setMid(ctx);

  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.font=`${numbersFontPx}px Arial`;
  const every = ring.labelEvery ?? computeLabelEvery(ctx, r, divisions, numbersFontPx);

  for(let i=0;i<divisions;i++){
    const a=deg2rad(i*(360/divisions));
    const x1=cx+(r-tickLen)*Math.cos(a), y1=cy+(r-tickLen)*Math.sin(a);
    const x2=cx+(r)*Math.cos(a),         y2=cy+(r)*Math.sin(a);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    const tx=cx+(r-20)*Math.cos(a), ty=cy+(r-20)*Math.sin(a);
    if(symbols){ ctx.fillText(symbols[i%symbols.length], tx, ty); }
    else if(showNumbers){ if(i % every === 0){ ctx.fillText(String(i+1), tx, ty); } }
  }
}

function drawBottomClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(bottomCanvas);
  bctx.clearRect(0,0,bottomCanvas.width,bottomCanvas.height);
  setMid(bctx);

  const inner = 0.18*rMax, outer = 0.95*rMax;
  const step = (outer-inner)/(rings.length-1);
  rings.forEach((ring,i)=> ring.r = inner + i*step);

  rings.forEach(ring => ringTicksAndNumbers(bctx,cx,cy,ring.r,ring));

  const rot = rotDeg||0;

  // Meridian (to outer rim)
  pointer(bctx, cx, cy, rings[rings.length-1].r, 0, "#9aa0a6");
  labelCenteredOnHand(bctx, cx, cy, rings[rings.length-1].r, 0, "Meridian", "#9aa0a6", 0);

  // Long Moon (agri) hand across all rings
  const aMoonAgri = normDeg(angles.moon - rot);
  pointer(bctx, cx, cy, rings[rings.length-1].r, aMoonAgri, "yellow");
  labelCenteredOnHand(bctx, cx, cy, rings[rings.length-1].r, aMoonAgri, "Moon", "yellow", 0);
  bctx.beginPath(); bctx.arc(cx,cy,6,0,Math.PI*2); bctx.fillStyle="yellow"; bctx.fill();

  // Ring-specific pointers
  const aMoonDays = aMoonAgri;
  pointer(bctx, cx, cy, rings[1].r, aMoonDays, rings[1].color);
  labelCenteredOnHand(bctx, cx, cy, rings[1].r, aMoonDays, "Moon Days", rings[1].color, 0);

  const aOlymp = normDeg(angles.olympiad - rot);
  pointer(bctx, cx, cy, rings[2].r, aOlymp, rings[2].color);
  labelCenteredOnHand(bctx, cx, cy, rings[2].r, aOlymp, "Olympiad", rings[2].color, 0);

  const aAgri = normDeg(angles.tepe - rot);
  pointer(bctx, cx, cy, rings[3].r, aAgri, rings[3].color);
  labelCenteredOnHand(bctx, cx, cy, rings[3].r, aAgri, "Agricultural", rings[3].color, 0);

  const aMetB = normDeg(angles.metonic - rot);
  pointer(bctx, cx, cy, rings[4].r, aMetB, rings[4].color);
  labelCenteredOnHand(bctx, cx, cy, rings[4].r, aMetB, "Metonic", rings[4].color, 0);

  const aSaros = normDeg(angles.saros - rot);
  pointer(bctx, cx, cy, rings[5].r, aSaros, rings[5].color);
  labelCenteredOnHand(bctx, cx, cy, rings[5].r, aSaros, "Saros", rings[5].color, 0);

  const aExel = normDeg(angles.exeligmos - rot);
  pointer(bctx, cx, cy, rings[6].r, aExel, rings[6].color);
  labelCenteredOnHand(bctx, cx, cy, rings[6].r, aExel, "Exeligmos", rings[6].color, 0);

  const aMeso = normDeg(angles.meso - rot);
  pointer(bctx, cx, cy, rings[7].r, aMeso, rings[7].color);
  labelCenteredOnHand(bctx, cx, cy, rings[7].r, aMeso, "Mesoamerican", rings[7].color, 0);

  const aNat = normDeg(angles.native365 - rot);
  pointer(bctx, cx, cy, rings[8].r, aNat, rings[8].color);
  labelCenteredOnHand(bctx, cx, cy, rings[8].r, aNat, "Native Days", rings[8].color, 0);
}

/* ------------------ Controller: always visible + animate ------------------ */

let rotCurrent = 0;
let anglesCurrent = {
  moon:0, mansions:0, zodiac:0, decans:0, tepe:0, maya:0, metonic:0,
  saros:0, exeligmos:0, olympiad:0, meso:0, native365:0, moonDay:0
};

function drawFromCurrent(){
  drawTopClock(anglesCurrent, rotCurrent);
  drawBottomClock(anglesCurrent, rotCurrent);
}

let rafId = null;
function animateTo(targetAngles, targetRot, durationMs=1500){
  if(rafId) cancelAnimationFrame(rafId);
  const start = performance.now();
  const startAngles = {...anglesCurrent};
  const startRot = rotCurrent;

  function step(now){
    let t=(now-start)/durationMs; if(t>1) t=1;
    const e=easeInOut(t);
    Object.keys(anglesCurrent).forEach(k=>{
      const a0=startAngles[k]||0, a1=targetAngles[k]||0;
      const d=shortestDelta(a0,a1);
      anglesCurrent[k]=normDeg(a0+d*e);
    });
    const dRot=shortestDelta(startRot,targetRot);
    rotCurrent=normDeg(startRot+dRot*e);

    drawFromCurrent();
    if(t<1) rafId=requestAnimationFrame(step);
  }
  rafId=requestAnimationFrame(step);
}

/* ------------------ Readouts (text under the summary) ------------------ */
const chineseAnimals = [
  {name:"Rat",sym:"ğŸ€"},{name:"Ox",sym:"ğŸ‚"},{name:"Tiger",sym:"ğŸ…"},{name:"Rabbit",sym:"ğŸ‡"},
  {name:"Dragon",sym:"ğŸ‰"},{name:"Snake",sym:"ğŸ"},{name:"Horse",sym:"ğŸ"},{name:"Goat",sym:"ğŸ"},
  {name:"Monkey",sym:"ğŸ’"},{name:"Rooster",sym:"ğŸ“"},{name:"Dog",sym:"ğŸ•"},{name:"Pig",sym:"ğŸ–"}
];

function updateReadouts(A, rot, meta){
  const mans = indexInDiv(A.mansions, 28);
  const dec  = indexInDiv(A.decans,   36);
  const maya = indexInDiv(A.maya,     20);
  const tepe = indexInDiv(A.tepe,     12);
  const met  = indexInDiv(A.metonic,  19);

  const sun = signDegMin(A.zodiac);

  const moonAge = A.moonDay;               // 0..29.53
  const moonDay = Math.floor(moonAge)+1;
  const phaseAng = ((A.moon%360)+360)%360;
  const phaseNm  = moonPhaseName(moonAge);
  const phaseIdx = Math.floor(phaseAng / 45) % 8;
  const phaseSym = rings[0].symbols[phaseIdx];

  // bottom ring indices
  const moonDaysIdx = indexInDiv(A.moon, 29);
  const olymp = indexInDiv(A.olympiad, 4);
  const agri  = indexInDiv(A.tepe, 12);
  const metB  = indexInDiv(A.metonic, 19);
  const sar   = indexInDiv(A.saros, 18);
  const exel  = indexInDiv(A.exeligmos, 54);
  const meso  = indexInDiv(A.meso, 52);
  const nat   = indexInDiv(A.native365, 365);

  const where = meta.haveLon ? ` at lat <b>${meta.lat.toFixed(5)}Â°</b>, lon <b>${meta.lon.toFixed(5)}Â°</b>` : ``;
  const orientTxt = (meta.orient==="noon") ? "Local noon at location."
                    : (meta.orient==="lst") ? "Sidereal (LST at location)."
                    : "Fixed meridian (north up).";

  document.getElementById('readouts').innerHTML = `
    <h3>Top clock â€” dial positions</h3>
    <ul>
      <li><b>Meridian:</b> ${orientTxt} â€¢ rotation <b>${dmsStr(rot)}</b></li>
      <li><b>Sun:</b> <b>${sun.sign} ${sun.d}Â° ${sun.m}â€²</b> (Î»=${dmsStr(A.zodiac)})</li>
      <li><b>Moon (phase):</b> day <b>${moonDay}</b> â€¢ <b>${phaseNm}</b> â€¢ phase angle <b>${dmsStr(phaseAng)}</b></li>
      <li><b>Lunar Mansions (28):</b> station <b>#${mans.index}</b> â€¢ ${dmsStr(mans.within)} into station</li>
      <li><b>Decans (36):</b> decan <b>#${dec.index}</b> â€¢ ${dmsStr(dec.within)} into decan</li>
      <li><b>Maya (20):</b> sign <b>#${maya.index}</b> ${mayaSigns[maya.index-1]} â€¢ ${dmsStr(maya.within)} into sign</li>
      <li><b>Tepe (12):</b> step <b>#${tepe.index}</b> ${tepeSymbols[tepe.index-1]} â€¢ ${dmsStr(tepe.within)} into step</li>
      <li><b>Chinese (12):</b> <b>${chineseAnimals[tepe.index-1].name}</b> ${chineseAnimals[tepe.index-1].sym} â€¢ ${dmsStr(tepe.within)} into animal sector</li>
      <li><b>Metonic (19y):</b> index <b>#${met.index}</b> â€¢ ${dmsStr(met.within)} into segment</li>
    </ul>

    <h3>Bottom clock â€” dial positions</h3>
    <ul>
      <li><b>Meridian:</b> same as above â€¢ rotation <b>${dmsStr(rot)}</b>${where ? ` â€¢ location${where}` : ``}</li>
      <li><b>Moon (agri / 8-phase):</b> day <b>${moonDay}</b> â€¢ <b>${phaseNm}</b> â€¢ symbol <b>${phaseSym}</b> â€¢ phase angle <b>${dmsStr(phaseAng)}</b></li>
      <li><b>Moon Days (1â€“29):</b> day <b>#${moonDaysIdx.index}</b> â€¢ ${dmsStr(moonDaysIdx.within)} into that day</li>
      <li><b>Olympiad (4y):</b> year <b>#${olymp.index}</b> â€¢ ${dmsStr(olymp.within)} into year</li>
      <li><b>Agricultural (12):</b> month/step <b>#${agri.index}</b> â€¢ ${dmsStr(agri.within)} into step</li>
      <li><b>Metonic (19y):</b> index <b>#${metB.index}</b> â€¢ ${dmsStr(metB.within)} into segment</li>
      <li><b>Saros (18y+11d):</b> index <b>#${sar.index}</b> â€¢ ${dmsStr(sar.within)} into segment</li>
      <li><b>Exeligmos (54y):</b> index <b>#${exel.index}</b> â€¢ ${dmsStr(exel.within)} into segment</li>
      <li><b>Mesoamerican (52y):</b> year <b>#${meso.index}</b> â€¢ ${dmsStr(meso.within)} into year</li>
      <li><b>Native American Days (1â€“365):</b> day <b>#${nat.index}</b> â€¢ ${dmsStr(nat.within)} into day</li>
    </ul>
  `;
}

/* ------------------ Input / validation / control ------------------ */
function getInputs(){
  const dateStr = document.getElementById('dateInput').value.trim();
  const latStr  = document.getElementById('latInput').value.trim();
  const lonStr  = document.getElementById('lonInput').value.trim();
  const orient  = document.getElementById('orientSel').value;

  const parts = parseDateFlexible(dateStr);
  if(!parts) return {ok:false, msg:"Please enter a valid <b>date</b> (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)."};

  const {y,m,d}=parts;
  let dateUTC = new Date(Date.UTC(y, m-1, d, 12, 0, 0));
  let haveLon=false, lon=0, lat=0;

  if(lonStr!=="" && latStr!==""){
    lon=parseFloat(lonStr); lat=parseFloat(latStr);
    if(!isFinite(lon)||!isFinite(lat)) return {ok:false, msg:"Latitude/Longitude must be numbers."};
    if(lat<-90||lat>90) return {ok:false, msg:"Latitude must be between -90 and 90Â°."};
    if(lon<-180||lon>180) return {ok:false, msg:"Longitude must be between -180 and 180Â°."};
    haveLon=true;
    dateUTC = utcFromLocalMeanNoonYMD(y,m,d, lon);
  }

  return {ok:true, y,m,d, dateUTC, haveLon, lon, lat, orient};
}

function startClock(){
  const out = document.getElementById('output');
  const res = getInputs();
  if(!res.ok){ out.className="error"; out.innerHTML = res.msg; return; }
  out.className="";

  const A = computeAngles(res.dateUTC);

  // Orientation (rotation)
  let rot = 0;
  if(res.orient === "noon"){
    rot = A.zodiac; // put Sun at 12 oâ€™clock
  }else if(res.orient === "lst" && res.haveLon){
    rot = lstDeg(res.dateUTC, res.lon); // sidereal meridian
  }else{
    rot = 0; // fixed north up
  }

  const s = signDegMin(A.zodiac);
  const md = Math.floor(A.moonDay) + 1;
  const ymd = `${res.y.toString().padStart(4,"0")}-${res.m.toString().padStart(2,"0")}-${res.d.toString().padStart(2,"0")}`;
  const where = res.haveLon ? ` at lat <b>${res.lat.toFixed(5)}Â°</b>, lon <b>${res.lon.toFixed(5)}Â°</b>` : ``;
  const orientTxt = (res.orient==="noon") ? "Local noon at location."
                  : (res.orient==="lst") ? "Sidereal (LST at location)."
                  : "Fixed meridian (north up).";
  out.innerHTML = `Synced for <b>${ymd}</b>${where} â€¢ Sun on zodiac: <b>${s.sign} ${s.d}Â° ${s.m}â€²</b> â€¢ Moon day: <b>${md}</b> â€¢ Orientation: ${orientTxt}`;

  // Remember for sidereal drift
  lastMeta = { ...res };

  animateTo(A, rot, 1500);
  updateReadouts(A, rot, res);
  updateSiderealDrift(); // update sidereal drift for this date
}

function resetClock(){
  if (rafId) cancelAnimationFrame(rafId);
  rotCurrent = 0;
  for (const k in anglesCurrent) anglesCurrent[k] = 0;
  document.getElementById('dateInput').value = "";
  document.getElementById('latInput').value = "";
  document.getElementById('lonInput').value = "";
  document.getElementById('orientSel').value = "north";
  const out = document.getElementById('output');
  out.className=""; out.innerHTML = 'Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.';
  document.getElementById('readouts').innerHTML = "";
  lastMeta = null;
  drawFromCurrent();
  updateSiderealDrift();
}

/* ------------------ Initial draw ------------------ */
drawFromCurrent();
</script>
</body>
</html>
