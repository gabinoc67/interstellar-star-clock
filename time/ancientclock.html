<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ü™ê Cosmic Clock (Dual Panel)</title>
<style>
  :root{ --gap:22px; }
  body{
    margin:0; background:#0a0f1f; color:#fff; font-family:Arial, Helvetica, sans-serif;
    min-height:100vh; display:flex; align-items:flex-start; justify-content:center;
  }
  #container{
    display:flex; align-items:flex-start; justify-content:center; gap:var(--gap);
    padding:18px; max-width:calc(100vw - 18px); overflow:auto; flex-wrap:wrap;
  }

  /* Left controls */
  #infoPanel{ width:420px; text-align:left; line-height:1.6em; }
  #infoPanel h1{ color:gold; font-size:28px; margin:0 0 8px 0; }

  #howto{ font-size:0.95em; color:#cfd8e3; margin:0 0 8px 0; }
  #howto p{ margin:4px 0; }

  label{ display:block; margin:8px 0 4px; font-size:1.05em; }
  input, select{
    width:100%; padding:9px 10px; font-size:1.05em;
    border:1px solid #334155; background:#0f172a; color:#e5e7eb; border-radius:8px;
  }
  .btnRow{ margin-top:10px; display:flex; gap:10px; }
  .btn{
    background:#2563eb; color:#fff; border:none; border-radius:8px; cursor:pointer;
    padding:9px 16px; font-size:1.05em;
  }
  .btn:hover{ background:#1d4ed8; }
  #output{ font-size:1.05em; margin-top:12px; }
  .note{ font-size:0.95em; color:#bbb; margin-top:10px; }
  .error{ color:#ff7b7b; }

  /* Right column: clocks + legend stacked */
  #rightCol{ display:flex; flex-direction:column; gap:var(--gap); align-items:center; }

  /* Canvases */
  canvas{ background:#111; border:2px solid #333; display:block; }
  #cosmicClock, #bottomClock{ width:715px; height:715px; }

  /* Legend panel */
  #legend{
    width:715px;
    background:#0f172a; border:2px solid #333; border-radius:10px;
    padding:14px; color:#dbe2ef; font-size:0.97em;
  }
  #legend h2{ margin:0 0 8px 0; font-size:18px; color:#ffe58a; }
  #legend h3{ margin:12px 0 6px 0; font-size:15px; color:#9ad1ff; }

  .grid{
    display:grid; gap:8px 14px;
    grid-template-columns: 1fr 1fr;
  }
  .row{ display:flex; align-items:flex-start; gap:8px; }
  .swatch{
    width:14px; height:14px; border-radius:3px; margin-top:3px;
    border:1px solid rgba(255,255,255,0.15);
  }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .muted{ color:#a9b4c2; font-size:0.92em; }
</style>
</head>
<body>
  <div id="container">
    <!-- Left controls -->
    <div id="infoPanel">
      <h1>ü™ê Cosmic Clock</h1>

      <div id="howto">
        <p><b>Quick how-to</b>:</p>
        <p><b>Date only</b> ‚Üí draws the geocentric sky for that day with <i>north up</i> (12 o‚Äôclock).</p>
        <p><b>Date + latitude/longitude</b> ‚Üí enables the <b>Orientation</b> menu:
          <i>Local noon</i> puts the Sun at the top for that date/place; <i>Sidereal (LST)</i> aligns the meridian with the local sky; <i>Fixed</i> keeps north up.</p>
        <p><b>Steps</b>: (1) Enter date. (2) Optional: enter lat & lon. (3) Choose orientation. (4) Press <b>Start</b>. (5) <b>Reset</b> clears inputs and zeros all dials.</p>
      </div>

      <label for="dateInput">Date (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)</label>
      <input type="text" id="dateInput" placeholder="e.g. 1987-05-09 or 05/11/1967" />

      <label for="latInput">Latitude (¬∞) ‚Äî optional, for orientation</label>
      <input type="number" id="latInput" step="0.00001" placeholder="e.g. 25.93742" />

      <label for="lonInput">Longitude (¬∞) ‚Äî optional, for orientation</label>
      <input type="number" id="lonInput" step="0.00001" placeholder="e.g. -97.45960" />

      <label for="orientSel">Orientation</label>
      <select id="orientSel">
        <option value="noon">Local noon at location (on that date)</option>
        <option value="lst">Sidereal (LST at location)</option>
        <option value="north" selected>Fixed meridian (true north up)</option>
      </select>

      <div class="btnRow">
        <button class="btn" onclick="startClock()">Start</button>
        <button class="btn" onclick="resetClock()">Reset</button>
      </div>

      <div id="output">Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.</div>
      <div class="note">
        ‚ö†Ô∏è Antikythera-style mechanism. The Moon is the main dial that drives the system.
      </div>
    </div>

    <!-- Right: clocks + legend -->
    <div id="rightCol">
      <canvas id="cosmicClock" width="715" height="715"></canvas>
      <canvas id="bottomClock" width="715" height="715"></canvas>

      <!-- Legend panel -->
      <section id="legend">
        <h2>Legend & Dial Meanings</h2>

        <h3>Hands (pointers)</h3>
        <div class="grid">
          <div class="row"><span class="swatch" style="background:#9aa0a6"></span><div><b>Meridian</b> ‚Äî true-north reference line at 12 o‚Äôclock.</div></div>
          <div class="row"><span class="swatch" style="background:#c084fc"></span><div><b>Sun</b> ‚Äî ecliptic longitude (zodiac position) on the top face.</div></div>
          <div class="row"><span class="swatch" style="background:#ffffff"></span><div><b>Moon (phase)</b> ‚Äî synodic phase hand on the top face.</div></div>
          <div class="row"><span class="swatch" style="background:yellow"></span><div><b>Moon (agri)</b> ‚Äî main agricultural/planning hand on the bottom face.</div></div>
          <div class="row"><span class="swatch" style="background:#ffd166"></span><div><b>Lunar Mansions</b> ‚Äî sidereal-moon pointer.</div></div>
          <div class="row"><span class="swatch" style="background:#ff4d4d"></span><div><b>Decans</b> ‚Äî 36 ten-degree sky segments.</div></div>
          <div class="row"><span class="swatch" style="background:#98fb98"></span><div><b>Maya ring</b> ‚Äî 20-day cycle index.</div></div>
          <div class="row"><span class="swatch" style="background:#6ee7ff"></span><div><b>Tepe ring</b> ‚Äî 12-division symbolic cycle.</div></div>
          <div class="row"><span class="swatch" style="background:#ffa500"></span><div><b>Metonic</b> ‚Äî 19-year Moon/Sun calendar resonance.</div></div>
        </div>

        <h3>Top Face ‚Äî Ring Guide</h3>
        <ul>
          <li><b>Degree ring (outer ticks)</b> ‚Äî 0‚Äì360¬∞ scale with 30¬∞ zodiac marks.</li>
          <li><b>Zodiac glyphs</b> ‚Äî 12 signs around the ecliptic.</li>
          <li><b>Tepe symbols</b> ‚Äî 12 pictograms (cultural cycle).</li>
          <li><b>Maya ring (20)</b> ‚Äî 20 day-signs.</li>
          <li><b>Decans (36)</b> ‚Äî 36 ten-degree segments (Egyptian/astrological).</li>
          <li><b>Lunar mansions (28)</b> ‚Äî sidereal lunar stations.</li>
          <li><b>Metonic markers (19)</b> ‚Äî 19-year cycle pegs.</li>
          <li><b>Moon phases</b> ‚Äî üåë üåì üåï üåó markers.</li>
        </ul>

        <h3>Bottom Face ‚Äî Ring Guide</h3>
        <ul>
          <li><b>Moon Cycle (8)</b> ‚Äî phase icons.</li>
          <li><b>Moon Days (1‚Äì29)</b> ‚Äî synodic day number.</li>
          <li><b>Olympiad (4y)</b> ‚Äî four-year cycle.</li>
          <li><b>Agricultural 12</b> ‚Äî month/seasonal labors.</li>
          <li><b>Metonic (19y)</b> ‚Äî lunar-solar calendar repeat.</li>
          <li><b>Saros (‚âà18y11d)</b> ‚Äî eclipse period.</li>
          <li><b>Exeligmos (54y)</b> ‚Äî triple Saros correction.</li>
          <li><b>Mesoamerican 52y</b> ‚Äî Calendar Round.</li>
          <li><b>Native American Days (1‚Äì365)</b> ‚Äî solar day index.</li>
        </ul>

        <p class="muted">
          <span class="mono">Note:</span> Planetary pointers for Venus/Saturn/etc. are not rendered in this build; the Sun and Moon are the active celestial hands. The colored hands for mansions/decans/Maya/Tepe/Metonic represent non-planetary cycles.
        </p>
      </section>
    </div>
  </div>

<script>
/* ------------------ shared helpers ------------------ */
function dims(canvas){
  const cx = canvas.width/2, cy = canvas.height/2;
  const rMax = Math.min(cx, cy) - 18;
  return { cx, cy, rMax };
}
function setMid(ctx){ ctx.textAlign="center"; ctx.textBaseline="middle"; }
function circle(ctx, cx, cy, r, color="#333", lw=1){
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.stroke(); ctx.lineWidth=1;
}
function deg2rad(deg){ return (deg-90)*Math.PI/180; }
function normDeg(x){ x%=360; return x<0?x+360:x; }
function shortestDelta(a,b){ let d=(b-a+540)%360-180; return d; }
function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }

// Pointed hand
function pointer(ctx, cx, cy, r, angleDeg, color){
  const a = deg2rad(angleDeg);
  const tipX = cx + r*Math.cos(a), tipY = cy + r*Math.sin(a);
  const back = 18, half = 6;
  ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tipX,tipY); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(tipX - back*Math.cos(a) + half*Math.sin(a), tipY - back*Math.sin(a) - half*Math.cos(a));
  ctx.lineTo(tipX - back*Math.cos(a) - half*Math.sin(a), tipY - back*Math.sin(a) + half*Math.cos(a));
  ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
  ctx.lineWidth=1;
}

// Horizontally oriented label, centered along a hand, offset just above the line
function labelCenteredOnHand(ctx, cx, cy, r, angleDeg, text, color, perpOffset=12){
  const a = deg2rad(angleDeg);
  const midR = r * 0.52;                        // center-ish of the line
  const mx = cx + midR * Math.cos(a);
  const my = cy + midR * Math.sin(a);
  const nx = -Math.sin(a), ny =  Math.cos(a);   // unit normal (left of the line)
  const lx = mx + perpOffset * nx;
  const ly = my + perpOffset * ny;

  ctx.save();
  ctx.font = "13px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  // subtle outline for readability
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.strokeText(text, lx, ly);
  ctx.fillStyle = color;
  ctx.fillText(text, lx, ly);
  ctx.restore();
}

/* ------------------ time / cycle engine ------------------ */
const TROPICAL_YEAR = 365.2422;
const MOON_SYNODIC = 29.530588;
const MOON_SIDEREAL = 27.321661;
const METONIC = 6939.69;
const SAROS = 6585.321;
const EXELIGMOS = SAROS * 3;
const OLYMPIAD = 1461.0;
const MESOAMERICAN_52Y = 52 * 365.0;
const NATIVE_YEAR = 365.0;

const EPOCH = Date.UTC(2000,0,1,12,0,0);
const NEW_MOON_REF = Date.UTC(2000,0,6,18,14,0);

function daysSince(ms, ref){ return (ms - ref) / 86400000; }
function norm(x,p){ x%=p; return x<0?x+p:x; }

// Simple Sun ecliptic longitude (~1¬∞)
function sunEclipticLongitude(dateUTC){
  const n = (dateUTC.getTime() - Date.UTC(2000,0,1,0,0,0)) / 86400000;
  const L = 280.460 + 0.9856474 * n;
  const g = (357.528 + 0.9856003 * n) * Math.PI/180;
  const lambda = L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2*g);
  return normDeg(lambda);
}
function sunZodiacName(lambda){
  const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
  return signs[Math.floor(normDeg(lambda)/30)];
}
function signDegMin(lambda){
  const sign = sunZodiacName(lambda);
  const dTot = normDeg(lambda) % 30;
  const d = Math.floor(dTot);
  const m = Math.round((dTot - d) * 60);
  return {sign, d, m};
}

// JD / GMST / LST (deg)
function julianDay(dateUTC){ return dateUTC.getTime()/86400000 + 2440587.5; }
function gmstDeg(dateUTC){
  const JD = julianDay(dateUTC);
  const T = (JD - 2451545.0)/36525.0;
  let gmst = 280.46061837 + 360.98564736629*(JD-2451545.0) + 0.000387933*T*T - (T*T*T)/38710000.0;
  return normDeg(gmst);
}
function lstDeg(dateUTC, longitudeDeg){ return normDeg(gmstDeg(dateUTC) + longitudeDeg); }

// Parse date (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)
function parseDateFlexible(s){
  if(!s) return null;
  if (s.includes('-')){
    const parts = s.split('-').map(n=>parseInt(n,10));
    if (parts[0] > 31) { // YYYY-MM-DD
      const [y,m,d]=parts; if(isFinite(y)&&isFinite(m)&&isFinite(d)) return {y,m,d};
    } else {             // MM-DD-YYYY
      const [mm,dd,yy]=parts; if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return {y:yy,m:mm,d:dd};
    }
  }
  if(s.includes('/')){
    const [mm,dd,yy] = s.split('/').map(n=>parseInt(n,10));
    if(isFinite(mm)&&isFinite(dd)&&isFinite(yy)) return { y:yy, m:mm, d:dd };
  }
  return null;
}

// Build UTC instant at Local Mean Noon for a given longitude
function utcFromLocalMeanNoonYMD(y,m,d, lonDeg){
  const utcNoon = Date.UTC(y, m-1, d, 12, 0, 0);
  return new Date(utcNoon - lonDeg*240000); // 4 min/deg -> ms
}

function computeAngles(dateUTC){
  const t = dateUTC.getTime();
  const dMoon = daysSince(t, NEW_MOON_REF);
  const dEpoch = daysSince(t, EPOCH);
  return {
    moon:      normDeg( norm(dMoon, MOON_SYNODIC) / MOON_SYNODIC * 360 ),
    moonDay:   norm(dMoon, MOON_SYNODIC),           // 0..29.53
    mansions:  normDeg(dMoon / MOON_SIDEREAL * 360),
    zodiac:    sunEclipticLongitude(dateUTC),
    decans:    normDeg(dEpoch / TROPICAL_YEAR * 360),
    tepe:      normDeg(dEpoch / TROPICAL_YEAR * 360),
    maya:      normDeg(dEpoch / 20.0 * 360),
    metonic:   normDeg(dEpoch / METONIC * 360),
    saros:     normDeg(dEpoch / SAROS * 360),
    exeligmos: normDeg(dEpoch / EXELIGMOS * 360),
    olympiad:  normDeg(dEpoch / OLYMPIAD * 360),
    meso:      normDeg(dEpoch / MESOAMERICAN_52Y * 360),
    native365: normDeg(dEpoch / NATIVE_YEAR * 360),
  };
}

/* ------------------ TOP CLOCK ------------------ */
const topCanvas = document.getElementById("cosmicClock");
const tctx = topCanvas.getContext("2d");
const tepeSymbols = ["ü¶Ç","ü¶ä","ü¶Ö","üêÇ","üêç","üêá","üê∫","üêü","üê¶","ü¶å","ü¶É","üê¢"];
const mayaSigns  = ["üêä","üå¨Ô∏è","üåä","üî•","ü¶Ö","üêç","üåΩ","üê¢","üï∑Ô∏è","üêí","üêï","üåø","üåû","üåë","üåΩ","ü¶å","üå¥","ü¶Ç","üåï","üêü"];
const zodiacIcons = ["‚ôà","‚ôâ","‚ôä","‚ôã","‚ôå","‚ôç","‚ôé","‚ôè","‚ôê","‚ôë","‚ôí","‚ôì"];

function drawTopClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(topCanvas);
  tctx.clearRect(0,0,topCanvas.width,topCanvas.height);
  setMid(tctx);

  const outer = 0.96*rMax, inner = 0.40*rMax;
  const steps = 7, step = (outer-inner)/steps;
  const R = {
    degRing:  outer,
    mansions: outer - step*1,
    decans :  outer - step*2,
    maya   :  outer - step*3,
    tepe   :  outer - step*4,
    zodiacR:  outer - step*5,
    metonic:  outer - step*6,
    moonPh :  outer - step*7
  };

  // Degree ring
  circle(tctx, cx, cy, R.degRing, "#444");
  for(let d=0; d<360; d+=5){
    const a=deg2rad(d), major = d%30===0, len = major?14:7;
    const x1=cx+(R.degRing-len)*Math.cos(a), y1=cy+(R.degRing-len)*Math.sin(a);
    const x2=cx+R.degRing*Math.cos(a),      y2=cy+R.degRing*Math.sin(a);
    tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2);
    tctx.strokeStyle="#667085"; tctx.stroke();
    if(major){
      tctx.fillStyle="#aab4c8"; tctx.font="12px Arial";
      tctx.fillText(String(d), cx+(R.degRing-28)*Math.cos(a), cy+(R.degRing-28)*Math.sin(a));
    }
  }
  ["mansions","decans","maya","tepe","zodiacR","metonic"].forEach(k=>circle(tctx,cx,cy,R[k],"#2a3347"));

  // Ring art only (no ring-name text on canvas)
  tctx.fillStyle="violet"; tctx.font="22px Arial";
  zodiacIcons.forEach((z,i)=>{ const a=deg2rad(i*30); tctx.fillText(z, cx+R.zodiacR*Math.cos(a), cy+R.zodiacR*Math.sin(a)); });

  tctx.fillStyle="orange";
  for(let i=0;i<19;i++){ const a=deg2rad(i*(360/19)); tctx.fillRect(cx+R.metonic*Math.cos(a)-2, cy+R.metonic*Math.sin(a)-2, 4,4); }

  tctx.fillStyle="cyan"; tctx.font="18px Arial";
  tepeSymbols.forEach((s,i)=>{ const a=deg2rad(i*30); tctx.fillText(s, cx+R.tepe*Math.cos(a), cy+R.tepe*Math.sin(a)); });

  tctx.fillStyle="lime"; tctx.font="16px Arial";
  mayaSigns.forEach((s,i)=>{ const a=deg2rad(i*(360/20)); tctx.fillText(s, cx+R.maya*Math.cos(a), cy+R.maya*Math.sin(a)); });

  tctx.fillStyle="red"; tctx.font="13px Arial";
  for(let i=0;i<36;i++){ const a=deg2rad(i*10); tctx.fillText(String(i+1), cx+R.decans*Math.cos(a), cy+R.decans*Math.sin(a)); }

  tctx.fillStyle="white"; tctx.font="18px Arial";
  ["üåë","üåì","üåï","üåó"].forEach((p,i)=>{ const a=deg2rad(i*90); tctx.fillText(p, cx+R.moonPh*Math.cos(a), cy+R.moonPh*Math.sin(a)); });

  const rot = rotDeg||0;

  // Hands + centered labels
  pointer(tctx,cx,cy,R.degRing, 0, "#9aa0a6");                                // meridian
  labelCenteredOnHand(tctx,cx,cy,R.degRing, 0, "Meridian", "#9aa0a6", 14);

  const aMansions = normDeg(angles.mansions - rot);
  pointer(tctx,cx,cy,R.mansions, aMansions, "#ffd166");
  labelCenteredOnHand(tctx,cx,cy,R.mansions, aMansions, "Lunar Mansions", "#ffd166", 14);

  const aDecans = normDeg(angles.decans - rot);
  pointer(tctx,cx,cy,R.decans,   aDecans,   "#ff4d4d");
  labelCenteredOnHand(tctx,cx,cy,R.decans, aDecans, "Decans", "#ff4d4d", 14);

  const aMaya = normDeg(angles.maya - rot);
  pointer(tctx,cx,cy,R.maya,     aMaya,     "#98fb98");
  labelCenteredOnHand(tctx,cx,cy,R.maya, aMaya, "Maya (20)", "#98fb98", 14);

  const aTepe = normDeg(angles.tepe - rot);
  pointer(tctx,cx,cy,R.tepe,     aTepe,     "#6ee7ff");
  labelCenteredOnHand(tctx,cx,cy,R.tepe, aTepe, "Tepe (12)", "#6ee7ff", 14);

  const aSun = normDeg(angles.zodiac - rot);
  pointer(tctx,cx,cy,R.zodiacR,  aSun,      "#c084fc"); // Sun
  labelCenteredOnHand(tctx,cx,cy,R.zodiacR, aSun, "Sun", "#c084fc", 14);

  const aMet = normDeg(angles.metonic - rot);
  pointer(tctx,cx,cy,R.metonic,  aMet,      "#ffa500");
  labelCenteredOnHand(tctx,cx,cy,R.metonic, aMet, "Metonic", "#ffa500", 14);

  const aMoon = normDeg(angles.moon - rot);
  pointer(tctx,cx,cy,R.moonPh,   aMoon,     "#ffffff"); // Moon (phase)
  labelCenteredOnHand(tctx,cx,cy,R.moonPh, aMoon, "Moon", "#ffffff", 14);
}

/* ------------------ BOTTOM CLOCK ------------------ */
const bottomCanvas = document.getElementById("bottomClock");
const bctx = bottomCanvas.getContext("2d");

const BASE_NUM_PX = 12.6;
const BASE_LABEL_PX = 13.5;

const rings = [
  {label:"Moon Cycle (Phases)", key:"moon",     color:"white",   divisions:8,   symbols:["üåë","üåí","üåì","üåî","üåï","üåñ","üåó","üåò"], showNumbers:false, numbersFontPx:BASE_NUM_PX, tickLen:5},
  {label:"Moon Days 1‚Äì29",      key:"moondays", color:"white",   divisions:29,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:6},
  {label:"Olympiad 4y",         key:"olymp",    color:"blue",    divisions:4,   showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Agricultural 12",     key:"farm",     color:"green",   divisions:12,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Metonic 19y",         key:"meton",    color:"orange",  divisions:19,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Saros 18y+11d",       key:"saros",    color:"red",     divisions:18,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
  {label:"Exeligmos 54y",       key:"exel",     color:"cyan",    divisions:54,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Mesoamerican 52y",    key:"meso",     color:"yellow",  divisions:52,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
  {label:"Native American Days (1‚Äì365)", key:"native365", color:"#9acd32", divisions:365, showNumbers:true, labelEvery:10, numbersFontPx:11, tickLen:6}
];

function computeLabelEvery(ctx, r, divisions, fontPx, padding=10){
  const radiusForLabels = r - 20;
  const circumference = 2 * Math.PI * Math.max(radiusForLabels, 1);
  const sample = String(divisions);
  ctx.font = `${fontPx}px Arial`;
  const sampleWidth = Math.max(ctx.measureText(sample).width, ctx.measureText("88").width);
  const needed = sampleWidth + padding;
  const maxLabels = Math.max(1, Math.floor(circumference / needed));
  return Math.max(1, Math.ceil(divisions / Math.max(1,maxLabels)));
}

function ringTicksAndNumbers(ctx,cx,cy,r,ring){
  const { divisions, color, showNumbers, symbols, numbersFontPx=BASE_NUM_PX, tickLen=7 } = ring;

  circle(ctx,cx,cy,r,color);
  setMid(ctx);

  // (Names removed from canvas; legend panel shows them)
  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.font=`${numbersFontPx}px Arial`;
  const every = ring.labelEvery ?? computeLabelEvery(ctx, r, divisions, numbersFontPx);

  for(let i=0;i<divisions;i++){
    const a=deg2rad(i*(360/divisions));
    const x1=cx+(r-tickLen)*Math.cos(a), y1=cy+(r-tickLen)*Math.sin(a);
    const x2=cx+(r)*Math.cos(a),         y2=cy+(r)*Math.sin(a);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    const tx=cx+(r-20)*Math.cos(a), ty=cy+(r-20)*Math.sin(a);
    if(symbols){ ctx.fillText(symbols[i%symbols.length], tx, ty); }
    else if(showNumbers){ if(i % every === 0){ ctx.fillText(String(i+1), tx, ty); } }
  }
}

function drawBottomClock(angles, rotDeg){
  const {cx, cy, rMax} = dims(bottomCanvas);
  bctx.clearRect(0,0,bottomCanvas.width,bottomCanvas.height);
  setMid(bctx);

  const inner = 0.18*rMax, outer = 0.95*rMax;
  const step = (outer-inner)/(rings.length-1);
  rings.forEach((ring,i)=> ring.r = inner + i*step);

  rings.forEach(ring => ringTicksAndNumbers(bctx,cx,cy,ring.r,ring));

  const rot = rotDeg||0;

  // Hands + centered labels
  pointer(bctx, cx, cy, rings[rings.length-1].r, 0, "#9aa0a6");                           // meridian
  labelCenteredOnHand(bctx, cx, cy, rings[rings.length-1].r, 0, "Meridian", "#9aa0a6", 12);

  const aMoonAgri = normDeg(angles.moon - rot);
  pointer(bctx, cx, cy, rings[rings.length-1].r, aMoonAgri, "yellow");                     // Moon
  labelCenteredOnHand(bctx, cx, cy, rings[rings.length-1].r, aMoonAgri, "Moon", "yellow", 12);

  bctx.beginPath(); bctx.arc(cx,cy,6,0,Math.PI*2); bctx.fillStyle="yellow"; bctx.fill();
}

/* ------------------ Controller: always visible + animate ------------------ */

let rotCurrent = 0;
let anglesCurrent = {
  moon:0, mansions:0, zodiac:0, decans:0, tepe:0, maya:0, metonic:0,
  saros:0, exeligmos:0, olympiad:0, meso:0, native365:0, moonDay:0
};

function drawFromCurrent(){
  drawTopClock(anglesCurrent, rotCurrent);
  drawBottomClock(anglesCurrent, rotCurrent);
}

let rafId = null;
function animateTo(targetAngles, targetRot, durationMs=1500){
  if(rafId) cancelAnimationFrame(rafId);
  const start = performance.now();
  const startAngles = {...anglesCurrent};
  const startRot = rotCurrent;

  function step(now){
    let t=(now-start)/durationMs; if(t>1) t=1;
    const e=easeInOut(t);
    Object.keys(anglesCurrent).forEach(k=>{
      const a0=startAngles[k]||0, a1=targetAngles[k]||0;
      const d=shortestDelta(a0,a1);
      anglesCurrent[k]=normDeg(a0+d*e);
    });
    const dRot=shortestDelta(startRot,targetRot);
    rotCurrent=normDeg(startRot+dRot*e);

    drawFromCurrent();
    if(t<1) rafId=requestAnimationFrame(step);
  }
  rafId=requestAnimationFrame(step);
}

/* ------------------ Input / validation / control ------------------ */
function getInputs(){
  const dateStr = document.getElementById('dateInput').value.trim();
  const latStr  = document.getElementById('latInput').value.trim();
  const lonStr  = document.getElementById('lonInput').value.trim();
  const orient  = document.getElementById('orientSel').value;

  const parts = parseDateFlexible(dateStr);
  if(!parts) return {ok:false, msg:"Please enter a valid <b>date</b> (YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY)."};

  const {y,m,d}=parts;
  let dateUTC = new Date(Date.UTC(y, m-1, d, 12, 0, 0));
  let haveLon=false, lon=0, lat=0;

  if(lonStr!=="" && latStr!==""){
    lon=parseFloat(lonStr); lat=parseFloat(latStr);
    if(!isFinite(lon)||!isFinite(lat)) return {ok:false, msg:"Latitude/Longitude must be numbers."};
    if(lat<-90||lat>90) return {ok:false, msg:"Latitude must be between -90 and 90¬∞."};
    if(lon<-180||lon>180) return {ok:false, msg:"Longitude must be between -180 and 180¬∞."};
    haveLon=true;
    dateUTC = utcFromLocalMeanNoonYMD(y,m,d, lon); // for local-noon option
  }

  return {ok:true, y,m,d, dateUTC, haveLon, lon, lat, orient};
}

function startClock(){
  const out = document.getElementById('output');
  const res = getInputs();
  if(!res.ok){ out.className="error"; out.innerHTML = res.msg; return; }
  out.className="";

  const A = computeAngles(res.dateUTC);

  // Orientation
  let rot = 0;
  if(res.orient === "noon"){
    rot = A.zodiac; // put Sun at 12 o‚Äôclock
  }else if(res.orient === "lst" && res.haveLon){
    rot = lstDeg(res.dateUTC, res.lon); // sidereal meridian
  }else{
    rot = 0; // fixed north up
  }

  const s = signDegMin(A.zodiac);
  const md = Math.floor(A.moonDay) + 1;
  const ymd = `${res.y.toString().padStart(4,"0")}-${res.m.toString().padStart(2,"0")}-${res.d.toString().padStart(2,"0")}`;
  const where = res.haveLon ? ` at lat <b>${res.lat.toFixed(5)}¬∞</b>, lon <b>${res.lon.toFixed(5)}¬∞</b>` : ``;
  const orientTxt = (res.orient==="noon") ? "Local noon at location."
                  : (res.orient==="lst") ? "Sidereal (LST at location)."
                  : "Fixed meridian (north up).";
  out.innerHTML = `Synced for <b>${ymd}</b>${where} ‚Ä¢ Sun on zodiac: <b>${s.sign} ${s.d}¬∞ ${s.m}‚Ä≤</b> ‚Ä¢ Moon day: <b>${md}</b> ‚Ä¢ Orientation: ${orientTxt}`;

  animateTo(A, rot, 1500);
}

function resetClock(){
  if (rafId) cancelAnimationFrame(rafId);
  rotCurrent = 0;
  for (const k in anglesCurrent) anglesCurrent[k] = 0;
  document.getElementById('dateInput').value = "";
  document.getElementById('latInput').value = "";
  document.getElementById('lonInput').value = "";
  document.getElementById('orientSel').value = "north";
  const out = document.getElementById('output');
  out.className=""; out.innerHTML = 'Clocks are visible. Enter a <b>date</b> (and optional lat/long) and press <b>Start</b> to rotate both faces.';
  drawFromCurrent();
}

/* ------------------ Initial draw ------------------ */
drawFromCurrent();
</script>
</body>
</html>
