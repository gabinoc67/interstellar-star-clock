<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>🪐 Cosmic Clock (Dual Panel)</title>
  <style>
    :root{ --gap:22px; }
    body{
      margin:0; background:#0a0f1f; color:#fff; font-family:Arial, Helvetica, sans-serif;
      min-height:100vh; display:flex; align-items:center; justify-content:center;
    }
    #container{
      display:flex; align-items:flex-start; justify-content:center; gap:var(--gap);
      padding:18px; max-width:calc(100vw - 18px); overflow:auto; flex-wrap:wrap;
    }

    /* Left control panel (20% bigger inputs) */
    #infoPanel{ width:400px; text-align:left; line-height:1.7em; }
    #infoPanel h1{ color:gold; font-size:28px; margin:0 0 12px 0; }
    label{ display:block; margin:8px 0 4px; font-size:1.05em; }
    input{
      width:100%; padding:9px 10px; font-size:1.2em;
      border:1px solid #334155; background:#0f172a; color:#e5e7eb; border-radius:8px;
    }
    .btnRow{ margin-top:10px; display:flex; gap:10px; }
    .btn{
      background:#2563eb; color:#fff; border:none; border-radius:8px; cursor:pointer;
      padding:9px 16px; font-size:1.05em;
    }
    .btn:hover{ background:#1d4ed8; }
    #output{ font-size:1.05em; margin-top:12px; }
    .note{ font-size:0.95em; color:#bbb; margin-top:10px; }

    /* Right clocks column */
    #clocks{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:var(--gap); }

    /* Canvases (+30% from 550 → 715) */
    canvas{ background:#111; border:2px solid #333; display:block; }
    #cosmicClock, #bottomClock{ width:715px; height:715px; }
  </style>
</head>
<body>
  <div id="container">
    <!-- Left: controls -->
    <div id="infoPanel">
      <h1>🪐 Cosmic Clock</h1>

      <label for="dateInput">Birthday</label>
      <input type="date" id="dateInput" placeholder="mm/dd/yyyy" />

      <label for="latInput">Latitude (°)</label>
      <input type="number" id="latInput" step="0.0001" placeholder="e.g. 34.05" />

      <label for="lonInput">Longitude (°)</label>
      <input type="number" id="lonInput" step="0.0001" placeholder="e.g. -118.25" />

      <div class="btnRow">
        <button class="btn" onclick="startClock()">Start</button>
        <button class="btn" onclick="resetClock()">Reset</button>
      </div>

      <div id="output">Enter either a <b>Birthday</b> OR <b>Latitude/Longitude</b>.</div>
      <div class="note">
        ⚠️ Antikythera-style mechanism.<br>
        The Moon is the main dial that drives the system.
      </div>
    </div>

    <!-- Right: stacked clocks -->
    <div id="clocks">
      <canvas id="cosmicClock" width="715" height="715"></canvas>
      <canvas id="bottomClock" width="715" height="715"></canvas>
    </div>
  </div>

  <script>
    /* ------------------ shared helpers ------------------ */
    function dims(canvas){
      const cx = canvas.width/2, cy = canvas.height/2;
      const rMax = Math.min(cx, cy) - 18; // safety margin
      return { cx, cy, rMax };
    }
    function setMid(ctx){ ctx.textAlign="center"; ctx.textBaseline="middle"; }
    function circle(ctx, cx, cy, r, color="#333", lw=1){
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.stroke(); ctx.lineWidth=1;
    }
    function deg2rad(deg){ return (deg-90)*Math.PI/180; }

    // Draw a simple pointed hand
    function pointer(ctx, cx, cy, r, angleDeg, color){
      const a = deg2rad(angleDeg);
      const tipX = cx + r*Math.cos(a), tipY = cy + r*Math.sin(a);
      const back = 18, half = 6;
      ctx.strokeStyle=color; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tipX,tipY); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(tipX - back*Math.cos(a) + half*Math.sin(a), tipY - back*Math.sin(a) - half*Math.cos(a));
      ctx.lineTo(tipX - back*Math.cos(a) - half*Math.sin(a), tipY - back*Math.sin(a) + half*Math.cos(a));
      ctx.closePath(); ctx.fillStyle=color; ctx.fill();
      ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
      ctx.lineWidth=1;
    }

    /* ------------------ time / cycle engine ------------------ */
    // Periods (days)
    const DAY = 1;
    const TROPICAL_YEAR = 365.2422;
    const MOON_SYNODIC = 29.530588;        // Moon phase cycle (main dial)
    const MOON_SIDEREAL = 27.321661;       // For lunar mansions
    const METONIC = 6939.69;               // ≈ 19 years
    const SAROS = 6585.321;                // 18y 11d 8h
    const EXELIGMOS = SAROS * 3;           // 54y
    const OLYMPIAD = 1461.0;               // 4y
    const MESOAMERICAN_52Y = 52 * 365.0;   // Calendar Round (simplified)
    const NATIVE_YEAR = 365.0;

    // Reference epochs
    const EPOCH = Date.UTC(2000,0,1,0,0,0);             // generic epoch
    const NEW_MOON_REF = Date.UTC(2000,0,6,18,14,0);    // known new moon

    function daysSince(ms, ref){ return (ms - ref) / (86400000); }

    // Angle helpers
    function angleFromPeriod(days, period){ return ((days % period + period) % period) / period * 360; }

    // Compute all dial angles for a given Date
    function computeAngles(date){
      const t = date.getTime();

      const dMoon = daysSince(t, NEW_MOON_REF);
      const dEpoch = daysSince(t, EPOCH);

      const moonAngle = angleFromPeriod(dMoon, MOON_SYNODIC);      // main dial
      return {
        moon: moonAngle,                      // phases & "Moon Days"
        mansions: angleFromPeriod(dMoon, MOON_SIDEREAL),
        zodiac: angleFromPeriod(dEpoch, TROPICAL_YEAR),
        decans: angleFromPeriod(dEpoch, TROPICAL_YEAR),
        tepe: angleFromPeriod(dEpoch, TROPICAL_YEAR),
        maya: angleFromPeriod(dEpoch, 20.0),  // 20-day cycle
        metonic: angleFromPeriod(dEpoch, METONIC),
        saros: angleFromPeriod(dEpoch, SAROS),
        exeligmos: angleFromPeriod(dEpoch, EXELIGMOS),
        olympiad: angleFromPeriod(dEpoch, OLYMPIAD),
        meso: angleFromPeriod(dEpoch, MESOAMERICAN_52Y),
        native365: angleFromPeriod(dEpoch, NATIVE_YEAR)
      };
    }

    /* ------------------ TOP CLOCK ------------------ */
    const topCanvas = document.getElementById("cosmicClock");
    const tctx = topCanvas.getContext("2d");

    const tepeSymbols = ["🦂","🦊","🦅","🐂","🐍","🐇","🐺","🐟","🐦","🦌","🦃","🐢"];
    const mayaSigns  = ["🐊","🌬️","🌊","🔥","🦅","🐍","🌽","🐢","🕷️","🐒","🐕","🌿","🌞","🌑","🌽","🦌","🌴","🦂","🌕","🐟"];
    const zodiac     = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];

    function drawTopClock(date){
      const A = computeAngles(date);
      const {cx, cy, rMax} = dims(topCanvas);
      tctx.clearRect(0,0,topCanvas.width,topCanvas.height);
      setMid(tctx);

      const outer = 0.96*rMax, inner = 0.40*rMax;
      const steps = 7, step = (outer-inner)/steps;
      const R = {
        degRing:  outer,
        mansions: outer - step*1,
        decans :  outer - step*2,
        maya   :  outer - step*3,
        tepe   :  outer - step*4,
        zodiac :  outer - step*5,
        metonic:  outer - step*6,
        moonPh :  outer - step*7
      };

      // Degree ring
      circle(tctx, cx, cy, R.degRing, "#444");
      for(let d=0; d<360; d+=5){
        const a=deg2rad(d), major = d%30===0, len = major?14:7;
        const x1=cx+(R.degRing-len)*Math.cos(a), y1=cy+(R.degRing-len)*Math.sin(a);
        const x2=cx+R.degRing*Math.cos(a),      y2=cy+R.degRing*Math.sin(a);
        tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2);
        tctx.strokeStyle="#667085"; tctx.stroke();
        if(major){
          tctx.fillStyle="#aab4c8"; tctx.font="12px Arial";
          tctx.fillText(String(d), cx+(R.degRing-28)*Math.cos(a), cy+(R.degRing-28)*Math.sin(a));
        }
      }

      ["mansions","decans","maya","tepe","zodiac","metonic"].forEach(k=>circle(tctx,cx,cy,R[k],"#2a3347"));

      tctx.fillStyle="violet"; tctx.font="22px Arial";
      zodiac.forEach((z,i)=>{ const a=deg2rad(i*30); tctx.fillText(z, cx+R.zodiac*Math.cos(a), cy+R.zodiac*Math.sin(a)); });

      tctx.fillStyle="orange";
      for(let i=0;i<19;i++){ const a=deg2rad(i*(360/19)); tctx.fillRect(cx+R.metonic*Math.cos(a)-2, cy+R.metonic*Math.sin(a)-2, 4,4); }

      tctx.fillStyle="cyan"; tctx.font="18px Arial";
      tepeSymbols.forEach((s,i)=>{ const a=deg2rad(i*30); tctx.fillText(s, cx+R.tepe*Math.cos(a), cy+R.tepe*Math.sin(a)); });

      tctx.fillStyle="lime"; tctx.font="16px Arial";
      mayaSigns.forEach((s,i)=>{ const a=deg2rad(i*(360/20)); tctx.fillText(s, cx+R.maya*Math.cos(a), cy+R.maya*Math.sin(a)); });

      tctx.fillStyle="red"; tctx.font="13px Arial";
      for(let i=0;i<36;i++){ const a=deg2rad(i*10); tctx.fillText(String(i+1), cx+R.decans*Math.cos(a), cy+R.decans*Math.sin(a)); }

      tctx.fillStyle="yellow"; tctx.font="13px Arial";
      for(let i=0;i<28;i++){ const a=deg2rad(i*(360/28)); tctx.fillText(String(i+1), cx+R.mansions*Math.cos(a), cy+R.mansions*Math.sin(a)); }

      tctx.fillStyle="white"; tctx.font="18px Arial";
      ["🌑","🌓","🌕","🌗"].forEach((p,i)=>{ const a=deg2rad(i*90); tctx.fillText(p, cx+R.moonPh*Math.cos(a), cy+R.moonPh*Math.sin(a)); });

      // Hands — driven by periods (Moon is the master dial)
      const dialColors = { mansions:"#ffd166", decans:"#ff4d4d", maya:"#98fb98", tepe:"#6ee7ff", zodiac:"#c084fc", metonic:"#ffa500", moonPh:"#ffffff" };
      pointer(tctx,cx,cy,R.mansions,A.mansions,dialColors.mansions);
      pointer(tctx,cx,cy,R.decans,  A.decans,  dialColors.decans);
      pointer(tctx,cx,cy,R.maya,    A.maya,    dialColors.maya);
      pointer(tctx,cx,cy,R.tepe,    A.tepe,    dialColors.tepe);
      pointer(tctx,cx,cy,R.zodiac,  A.zodiac,  dialColors.zodiac);
      pointer(tctx,cx,cy,R.metonic, A.metonic, dialColors.metonic);
      pointer(tctx,cx,cy,R.moonPh,  A.moon,    dialColors.moonPh);
    }

    /* ------------------ BOTTOM CLOCK ------------------ */
    const bottomCanvas = document.getElementById("bottomClock");
    const bctx = bottomCanvas.getContext("2d");

    const BASE_NUM_PX = 12.6;
    const BASE_LABEL_PX = 13.5;

    const rings = [
      {label:"Moon Cycle (Phases)", key:"moon",     color:"white",   divisions:8,   symbols:["🌑","🌒","🌓","🌔","🌕","🌖","🌗","🌘"], showNumbers:false, numbersFontPx:BASE_NUM_PX, tickLen:5},
      {label:"Moon Days 1–29",      key:"moondays", color:"white",   divisions:29,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:6},
      {label:"Olympiad 4y",         key:"olymp",    color:"blue",    divisions:4,   showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Agricultural 12",     key:"farm",     color:"green",   divisions:12,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Metonic 19y",         key:"meton",    color:"orange",  divisions:19,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Saros 18y+11d",       key:"saros",    color:"red",     divisions:18,  showNumbers:true, numbersFontPx:BASE_NUM_PX, tickLen:7},
      {label:"Exeligmos 54y",       key:"exel",     color:"cyan",    divisions:54,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Mesoamerican 52y",    key:"meso",     color:"yellow",  divisions:52,  showNumbers:true, numbersFontPx:BASE_NUM_PX*0.90, tickLen:7},
      {label:"Native American Days (1–365)", key:"native365", color:"#9acd32", divisions:365, showNumbers:true, labelEvery:10, numbersFontPx:11, tickLen:6}
    ];

    function computeLabelEvery(ctx, r, divisions, fontPx, padding=10){
      const radiusForLabels = r - 20;
      const circumference = 2 * Math.PI * Math.max(radiusForLabels, 1);
      const sample = String(divisions);
      ctx.font = `${fontPx}px Arial`;
      const sampleWidth = Math.max(ctx.measureText(sample).width, ctx.measureText("88").width);
      const needed = sampleWidth + padding;
      const maxLabels = Math.max(1, Math.floor(circumference / needed));
      return Math.max(1, Math.ceil(divisions / maxLabels));
    }

    function ringTicksAndNumbers(ctx,cx,cy,r,ring){
      const { divisions, color, showNumbers, symbols, numbersFontPx=BASE_NUM_PX, tickLen=7 } = ring;

      circle(ctx,cx,cy,r,color);
      setMid(ctx);
      const labelPx = (ring.key === 'farm') ? BASE_LABEL_PX * 0.90 : BASE_LABEL_PX;
      ctx.fillStyle=color; ctx.font=`${labelPx}px Arial`;
      ctx.fillText(ring.label, cx, cy - r - 13);

      ctx.strokeStyle=color; ctx.fillStyle=color; ctx.font=`${numbersFontPx}px Arial`;

      const every = ring.labelEvery ?? computeLabelEvery(ctx, r, divisions, numbersFontPx);

      for(let i=0;i<divisions;i++){
        const a=deg2rad(i*(360/divisions));
        const x1=cx+(r-tickLen)*Math.cos(a), y1=cy+(r-tickLen)*Math.sin(a);
        const x2=cx+(r)*Math.cos(a),         y2=cy+(r)*Math.sin(a);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

        const tx=cx+(r-20)*Math.cos(a), ty=cy+(r-20)*Math.sin(a);
        if(symbols){ ctx.fillText(symbols[i%symbols.length], tx, ty); }
        else if(showNumbers){ if(i % every === 0){ ctx.fillText(String(i+1), tx, ty); } }
      }
    }

    function drawBottomClock(date){
      const A = computeAngles(date);
      const {cx, cy, rMax} = dims(bottomCanvas);
      bctx.clearRect(0,0,bottomCanvas.width,bottomCanvas.height);
      setMid(bctx);

      const inner = 0.18*rMax, outer = 0.95*rMax;
      const step = (outer-inner)/(rings.length-1);
      rings.forEach((ring,i)=> ring.r = inner + i*step);

      rings.forEach(ring => ringTicksAndNumbers(bctx,cx,cy,ring.r,ring));

      // Single moon-driven arrow from center to outermost ring
      pointer(bctx, cx, cy, rings[rings.length-1].r, A.moon, "yellow");
      // Hub
      bctx.beginPath(); bctx.arc(cx,cy,6,0,Math.PI*2); bctx.fillStyle="yellow"; bctx.fill();
    }

    /* ------------------ draw loop & controls ------------------ */
    let timer = null;

    function draw(date = new Date()){
      drawTopClock(date);
      drawBottomClock(date);
      // status
      const di = document.getElementById('dateInput').value;
      const whenTxt = di ? `for ${di}` : 'for now (live-ready)';
      document.getElementById('output').innerHTML =
        `Mode: <b>Moon main dial</b> (Antikythera-style), drawn ${whenTxt}.`;
    }

    function startClock(){
      // live animation (ignores birthday while running)
      if (timer) clearInterval(timer);
      timer = setInterval(()=> draw(new Date()), 250);  // smooth enough
      draw(new Date());
    }

    function resetClock(){
      if (timer) { clearInterval(timer); timer = null; }
      const di = document.getElementById('dateInput').value;
      if (di){
        // draw the selected day at local noon
        draw(new Date(`${di}T12:00:00`));
      }else{
        draw(new Date());
      }
    }

    // initial render (now)
    resetClock();
  </script>
</body>
</html>
