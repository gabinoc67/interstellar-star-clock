<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Einstein Energy→Mass Master Calculator — GR ⟷ QM ⟷ Photons ⟷ CST</title>

<!-- MathJax for equations -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
  :root{
    --bg:#0b0f14; --panel:#121822; --ink:#e6edf7; --muted:#98a2b3; --accent:#6ee7ff;
    --ok:#3ddc97; --warn:#ffdd57; --bad:#ff5c7a; --border:#1d2940;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    color:var(--ink);
    background: radial-gradient(1200px 520px at 120% -20%, rgba(167,139,250,.07), transparent 40%), #0a0e16;
  }
  header{
    padding:20px 24px;
    border-bottom:1px solid #1b2433;
    position:sticky;
    top:0;
    background:rgba(10,14,22,.85);
    backdrop-filter:blur(6px)
  }
  h1{margin:0; font-size:22px}
  .sub{color:var(--muted); font-size:14px; margin-top:6px; line-height:1.45}
  main{max-width:1200px; margin:22px auto; padding:0 16px 80px}
  .grid{display:grid; gap:16px}
  .cols-2{grid-template-columns:repeat(2,1fr)}
  .cols-3{grid-template-columns:repeat(3,1fr)}
  .card{
    background:linear-gradient(180deg,#121827,#0e1523);
    border:1px solid var(--border);
    border-radius:16px;
    padding:16px;
    box-shadow:0 12px 30px rgba(0,0,0,.2)
  }
  .kicker{color:var(--accent); text-transform:uppercase; letter-spacing:.12em; font-size:12px}
  label{display:block; font-size:12px; color:var(--muted); margin:8px 0 4px}
  input,select,textarea{
    width:100%;
    background:#0b1220;
    color:var(--ink);
    border:1px solid #263349;
    border-radius:10px;
    padding:10px 12px;
    outline:none
  }
  textarea{min-height:88px; resize:vertical}
  input:focus,select:focus,textarea:focus{border-color:var(--accent)}
  .btnrow{display:flex; gap:12px; flex-wrap:wrap; margin-top:12px}
  button{
    background:linear-gradient(180deg,#18263a,#122035);
    color:#e6f3ff;
    border:1px solid #223149;
    border-radius:12px;
    padding:10px 14px;
    cursor:pointer
  }
  button.primary{
    background:linear-gradient(180deg,#00bcd4,#0094b2);
    border-color:#00a5be;
    color:#00131a;
    font-weight:700
  }
  .eq{
    font-family:ui-serif,Georgia,serif;
    font-size:14px;
    line-height:1.55;
    background:#0b1220;
    border:1px solid #243149;
    border-radius:12px;
    padding:12px
  }
  .badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid #1e2a3b;
    background:#0b1220
  }
  .ok{color:var(--ok); border-color:#134c39}
  .warn{color:var(--warn); border-color:#4d4116}
  .bad{color:var(--bad); border-color:#4d1e2b}
  .hint{color:var(--muted); font-size:12px; margin-top:6px}
  table{
    width:100%;
    border-collapse:collapse;
    border:1px solid #1e2a3b;
    border-radius:12px;
    overflow:hidden
  }
  th,td{padding:10px 12px; border-bottom:1px solid #1c2738; font-size:14px}
  th{background:#0f1626}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  canvas{
    width:100%;
    height:220px;
    border-radius:12px;
    background:radial-gradient(800px 300px at 120% -20%, rgba(110,231,255,.06), transparent 40%), #0a0f17
  }
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
<header>
  <h1>Einstein Energy→Mass Master Equation Calculator</h1>
  <div class="sub">
    <b>What this page does:</b> treats <b>energy as primary</b> and lets you run a GR–Quantum–Photon–CST self-consistency test.
    You inject energy (flux, power, fields), and the implied <b>mass / curvature / time slippage</b> are read out.
    Enter tolerances & physical inputs, click <b>Run</b>, and read the residuals, stability, and validation badges.
    Numerics are <i>placeholders</i> (toy damping) so you can test the workflow.
    Replace the 3 hook functions (<code>grStep</code>, <code>qmStep</code>, <code>cstFeedback</code>) with your solvers to verify a physical system.
  </div>
</header>

<main class="grid">

  <!-- Instructions -->
  <section class="card">
    <div class="kicker">How to use (Energy → Mass view)</div>
    <ol style="margin:6px 0 6px 18px">
      <li>Think in the direction <b>Energy → Mass → Curvature → Time</b>. You choose the energy budget (flux, power, control gains) and see whether spacetime & quantum state can stay consistent.</li>
      <li>Enter <b>steps</b>, Δt, tolerances (ε<sub>GR</sub>, ε<sub>QM</sub>, ε<sub>ΔC</sub>), initial residuals, PD gains — these shape how quickly injected energy is converted into “mass-equivalent” curvature changes.</li>
      <li>Set photon–gravity inputs: base flux F₀, variability δI, redshift z, magnification M; optionally paste <b>event times</b> (e.g., solar flares) to drive flux via a kernel intensity.</li>
      <li>Click <b>Run Simulation</b>. If all residuals drop below tolerances for the hold window, you’ll see green badges (for this toy model).</li>
      <li>To make it a <b>real verifier</b>, swap in your GR/QM/CST kernels at the hooks—no UI changes needed.</li>
    </ol>
    <div class="hint">Example that “solves” with toy kernels: N=500, Δt=0.02, ε’s=1e-6, R<sub>GR</sub>(0)=0.08, R<sub>QM</sub>(0)=0.06, ΔC(0)=0.10, k<sub>p</sub>=1.6, k<sub>d</sub>=0.3, F₀=1361 W/m², δI=0.03, z=0.0001, M=1.00.</div>
  </section>

  <!-- Equations -->
  <section class="card">
    <div class="kicker">Einstein “Master Equation” (coupled system)</div>
    <div class="grid cols-2">
      <div class="eq">
        <b>Einstein field equations (mass from energy)</b><br/>
        \[
          G_{\mu\nu} \;=\; 8\pi G\,T_{\mu\nu}, \quad
          E \;\longleftrightarrow\; m c^2
        \]
        <b>Linearized wave form</b> (Lorenz gauge, $\bar h_{\mu\nu}=h_{\mu\nu}-\tfrac12\eta_{\mu\nu}h$):<br/>
        \[
          \square\,\bar h_{\mu\nu} \;=\; -16\pi G\,S_{\mu\nu},
          \qquad
          S_{\mu\nu}=T^{\text{eff}}_{\mu\nu}
        \]
        with
        \[
          T^{\text{eff}}_{\mu\nu}=\langle \hat T_{\mu\nu}\rangle + T^{\text{class}}_{\mu\nu} + T^{\text{EM}}_{\mu\nu} + F^{\text{CST}}_{\mu\nu}
        \]
        <b>EM (photons) via flux — energy first, mass later</b><br/>
        \[
          F_{\mathrm{eff}}(t)=\frac{F_0\,[1+\delta I + \delta I_{\text{events}}(t)]\,M}{(1+z)^4},
        \]
        \[
          T^{\text{EM}}_{\mu\nu}\sim \frac{F_{\mathrm{eff}}}{c}
          \;\;\Rightarrow\;\;
          \rho_{\text{eff}} \sim \frac{F_{\mathrm{eff}}}{c^3}
        \]
        so injected <b>photon energy</b> sets an effective mass density and curvature.
      </div>
      <div class="eq">
        <b>Quantum (Lindblad master equation)</b><br/>
        \[
          \dot{\hat\rho} = -\frac{i}{\hbar}\big[\hat H(g,A_\mu),\hat\rho\big] + \sum_j \kappa_j \mathcal D[L_j]\hat\rho + \mathcal L_{\text{CST}}
        \]<br/>
        <b>CST feedback (PD law, energy-shaped)</b><br/>
        \[
          F^{\text{CST}}_{\mu\nu} = -k_p\,\Delta h_{\mu\nu}-k_d\,\Delta \dot h_{\mu\nu},
        \]
        \[
          \Delta h_{\mu\nu}=h_{\mu\nu}-h^{\text{target}}_{\mu\nu}(t_{\text{CST}})
        \]
        Here the PD gains map <b>control energy</b> into curvature corrections (effective mass re-balancing).<br/><br/>
        <b>Point-process intensity (events → flux)</b><br/>
        \[
          \hat\lambda(t)=\sum_i K_h(t-t_i), \quad
          \delta I_{\text{events}}(t)=c_\lambda\,\hat\lambda(t)
        \]
        turning flare energy into extra curvature forcing.
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge">Fix Lorenz gauge & monitor constraints</span>
      <span class="badge">Energy → Mass → Curvature budget consistent</span>
      <span class="badge">Avoid hidden power injection</span>
    </div>
  </section>

  <!-- Inputs -->
  <section class="card">
    <div class="kicker">Inputs</div>
    <h2>Simulation & Physics Parameters</h2>

    <div class="grid cols-3">
      <div>
        <label>Steps (N)</label><input id="steps" type="number" min="10" max="20000" step="10" value="500">
        <label>Δt</label><input id="dt" type="number" step="0.001" value="0.02">
      </div>
      <div>
        <label>ε<sub>GR</sub></label><input id="epsGR" type="number" step="1e-6" value="1e-6">
        <label>ε<sub>QM</sub></label><input id="epsQM" type="number" step="1e-6" value="1e-6">
      </div>
      <div>
        <label>ε<sub>ΔC</sub></label><input id="epsDC" type="number" step="1e-6" value="1e-6">
        <label>Consecutive steps for “solved”</label><input id="hold" type="number" min="5" step="5" value="50">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>R<sub>GR</sub>(0)</label><input id="Rgr0" type="number" step="0.001" value="0.08">
        <label>R<sub>QM</sub>(0)</label><input id="Rqm0" type="number" step="0.001" value="0.06">
      </div>
      <div>
        <label>ΔC(0)</label><input id="dC0" type="number" step="0.001" value="0.10">
        <label>h-spectrum imbalance (0–1)</label><input id="spec0" type="number" min="0" max="1" step="0.01" value="0.70">
      </div>
      <div>
        <label>PD gain k<sub>p</sub></label><input id="kp" type="number" step="0.001" value="1.6">
        <label>PD gain k<sub>d</sub></label><input id="kd" type="number" step="0.001" value="0.3">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Photon base flux F₀ [W/m²]</label><input id="F0" type="number" step="1" value="1361">
        <label>Lensing magnification M</label><input id="Mlens" type="number" step="0.01" value="1.00">
      </div>
      <div>
        <label>Variability δI (fraction)</label><input id="dI" type="number" step="0.001" value="0.03">
        <label>Redshift z (grav+cosmo)</label><input id="zred" type="number" step="1e-5" value="0.00010">
      </div>
      <div>
        <label>Noise τ (s) for OU</label><input id="tauNoise" type="number" step="1" value="600">
        <label>Noise σ (fraction)</label><input id="sigmaNoise" type="number" step="0.001" value="0.005">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Event times (s, comma or space separated)</label>
        <textarea id="eventTimes" placeholder="e.g. 120, 340, 355, 910, 1240, 1805, 1812, 2600"></textarea>
      </div>
      <div>
        <label>Kernel type</label>
        <select id="kernelType">
          <option value="gauss">Gaussian</option>
          <option value="epa">Epanechnikov</option>
          <option value="exp">Exponential (causal)</option>
        </select>
        <label>Bandwidth / decay h (s)</label><input id="bandwidth" type="number" step="1" value="300">
      </div>
      <div>
        <label>Intensity scale c<sub>λ</sub> → fractional flux</label>
        <input id="clambda" type="number" step="0.001" value="0.01">
        <div class="hint">This converts λ̂(t) into δI<sub>events</sub>(t).</div>
      </div>
    </div>

    <div class="btnrow">
      <button class="primary" id="runBtn">Run Simulation</button>
      <button id="resetBtn">Reset</button>
      <span id="statusBadge" class="badge warn">Idle — awaiting run</span>
    </div>
  </section>

  <!-- Run Log -->
  <section class="card">
    <div class="kicker">Run Log</div>
    <h2>Residuals vs. Time (blink = energy)</h2>
    <canvas id="residuals"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="solvedBadge">Self-consistency: —</span>
      <span class="badge" id="stableBadge">Stability: —</span>
      <span class="badge" id="physicalBadge">Physicality: —</span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="gaugeBadge">Gauge: —</span>
      <span class="badge" id="consBadge">∇·T: —</span>
      <span class="badge" id="cflBadge">CFL: —</span>
    </div>
  </section>

  <!-- Field Plots -->
  <section class="card">
    <div class="kicker">Fields</div>
    <h2>h<sub>μν</sub> Snapshots & Spectra (pulsing with energy)</h2>
    <div class="grid cols-2">
      <div><h3 style="margin-bottom:6px">Snapshot: pre-control</h3><canvas id="snapPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Snapshot: post-control</h3><canvas id="snapPost"></canvas></div>
    </div>
    <div class="grid cols-2" style="margin-top:12px">
      <div><h3 style="margin-bottom:6px">Spectrum: pre</h3><canvas id="specPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Spectrum: post</h3><canvas id="specPost"></canvas></div>
    </div>
  </section>

  <!-- Energy -->
  <section class="card">
    <div class="kicker">Energy → Mass Budget</div>
    <h2>Input Power vs. Curvature Change (blinking = energy rate)</h2>
    <canvas id="energy"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="effBadge">Efficiency: —</span>
      <span class="badge" id="powerBadge">Total power: —</span>
    </div>
    <p class="hint">
      The brighter / faster the blink, the more aggressively energy is being pushed into curvature in this toy model.
    </p>
  </section>

  <!-- Validation -->
  <section class="card">
    <div class="kicker">Validation</div>
    <h2>Observable Checks</h2>
    <table>
      <thead><tr><th>Test</th><th>Target</th><th>Measured</th><th>Status</th></tr></thead>
      <tbody>
        <tr>
          <td>Solar-system orbits (fractional err/orbit)</td>
          <td class="mono">&lt; 1e-8</td>
          <td id="orbitVal" class="mono">—</td>
          <td id="orbitStatus">—</td>
        </tr>
        <tr>
          <td>Cosmology (FRW homogeneous limit)</td>
          <td class="mono">match</td>
          <td id="frwVal" class="mono">—</td>
          <td id="frwStatus">—</td>
        </tr>
        <tr>
          <td>Lab EM cavity (Δf vs small h)</td>
          <td class="mono">linear</td>
          <td id="labVal" class="mono">—</td>
          <td id="labStatus">—</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- What it does & How to enter data -->
  <section class="card">
    <div class="kicker">What it does & How to enter data</div>
    <h2>Einstein Master Equation — Purpose</h2>
    <p>
      The calculator couples four pieces into one loop:
      <b>(1)</b> GR curvature via the Einstein equations,
      <b>(2)</b> Quantum state evolution via a Lindblad master equation,
      <b>(3)</b> Photon forcing via flux (EM stress–energy),
      <b>(4)</b> CST feedback control that damps metric error.
      In this <b>energy → mass</b> view, you start from energy inputs and watch how they would appear as effective mass, curvature, and clock shifts.
      When all three residuals fall below tolerance and stay there (hold window), the system is <em>self-consistent</em> for those inputs.
    </p>

    <h3 style="margin-bottom:6px">How to fill each label</h3>
    <div class="grid cols-2">
      <div>
        <ul>
          <li><b>Steps (N)</b>: number of integration steps (e.g., 500).</li>
          <li><b>Δt</b>: time step (dimensionless here; obey CFL in real solvers), e.g., 0.02.</li>
          <li><b>ε<sub>GR</sub>, ε<sub>QM</sub>, ε<sub>ΔC</sub></b>: tolerances for the GR residual, QM residual, and control error (e.g., 1e-6).</li>
          <li><b>Consecutive steps for “solved”</b>: how many steps in a row must be under tolerance (e.g., 50).</li>
          <li><b>R<sub>GR</sub>(0), R<sub>QM</sub>(0)</b>: initial residual magnitudes at the start.</li>
        </ul>
      </div>
      <div>
        <ul>
          <li><b>ΔC(0)</b>: initial metric error norm (toy scalar here).</li>
          <li><b>h-spectrum imbalance</b>: 0–1 slider that shapes the pre/post spectra visuals.</li>
          <li><b>PD gains k<sub>p</sub>, k<sub>d</sub></b>: proportional/derivative gains for CST control (energy you spend to push curvature back into line).</li>
          <li><b>Photon base flux F₀</b> [W/m²]: e.g., 1361 at 1 AU (TSI).</li>
          <li><b>Variability δI</b> (fraction): slow baseline modulation (0.00–0.05 typical).</li>
        </ul>
      </div>
    </div>
    <div class="grid cols-2" style="margin-top:6px">
      <div>
        <ul>
          <li><b>Lensing M</b>: magnification factor (≈1 near Earth; >1 if lensed).</li>
          <li><b>Redshift z</b>: gravitational/cosmological redshift (near-Earth ≪1).</li>
          <li><b>Noise τ, σ</b>: Ornstein–Uhlenbeck correlation time (s) and amplitude (fraction) for jitter.</li>
        </ul>
      </div>
      <div>
        <ul>
          <li><b>Event times</b> (s): comma/space list of flare or burst times to spike flux.</li>
          <li><b>Kernel</b> &amp; <b>h</b>: choose Gaussian / Epanechnikov / Exponential; set bandwidth/decay in seconds.</li>
          <li><b>c<sub>λ</sub></b>: scales the event intensity λ̂(t) into fractional flux δI<sub>events</sub>.</li>
        </ul>
      </div>
    </div>
    <p class="hint">After you click <b>Run Simulation</b>, check badges and plots. To turn this into a proof for a real system, replace the three hook functions with your integrators.</p>
  </section>

  <!-- Examples -->
  <section class="card">
    <div class="kicker">Examples</div>
    <h2>Quick Fills (try these, then Run)</h2>
    <div class="grid cols-3">
      <div>
        <h3 style="margin:.2rem 0">1) Sun–Earth (quiet Sun)</h3>
        <p class="hint">Stable baseline, minimal events; should damp smoothly.</p>
        <button onclick="loadExample('quiet')" class="primary">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">2) Sun–Earth (flare events)</h3>
        <p class="hint">Adds bursty event times and larger variability.</p>
        <button onclick="loadExample('flare')" class="">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">3) Lab EM cavity (minimal flux)</h3>
        <p class="hint">Toy lab case: tiny flux & tighter tolerances.</p>
        <button onclick="loadExample('lab')" class="">Fill Inputs</button>
      </div>
    </div>
    <p class="hint" style="margin-top:8px">After filling, press <b>Run Simulation</b>. Tweak gains or tolerances if residuals don’t converge with the toy kernels.</p>
  </section>

  <!-- Passing example -->
  <section class="card">
    <div class="kicker">Example that passes all tests</div>
    <p class="hint">Click the button to auto-fill parameters that (with these toy kernels) pass:<br>
      Solar-system orbits &lt; 1e-8, FRW limit “match”, and Lab cavity “linear”. Then press <b>Run Simulation</b>.
    </p>
    <button class="primary" onclick="loadExample('pass')">Fill Inputs — Passing Demo</button>
  </section>

  <!-- Interstellar Star Clock Enhancements -->
  <section class="card">
    <div class="kicker">Energy → Mass & Interstellar Star Clock Enhancements</div>
    <h2>Relativistic Clock, Star Mapping & Light-Time Physics</h2>

    <h3>1. Time Dilation (Velocity)</h3>
    <div class="eq">
      \[
        \Delta t' = \Delta t \sqrt{1 - \frac{v^2}{c^2}}
      \]
      As kinetic energy increases, effective relativistic mass increases, and the moving clock runs slower than the rest-frame clock.
    </div>

    <h3>2. Gravitational Time Dilation (Deep Gravity Wells)</h3>
    <div class="eq">
      \[
        \Delta t' = \Delta t \sqrt{1 - \frac{2GM}{r c^2}}
      \]
      More energy packed into a region (massive body) → deeper well → slower local time.
    </div>

    <h3>3. Star Coordinate Mapping (RA/Dec → 3D)</h3>
    <div class="eq">
      \[
        x = \cos\delta \cos\alpha,\quad
        y = \cos\delta \sin\alpha,\quad
        z = \sin\delta
      \]
      So RA (α) and Dec (δ) become real 3D coordinates for your Interstellar Star Clock.
    </div>

    <h3>4. Sidereal Clock Adjustment</h3>
    <div class="eq">
      \[
        T_{\text{sidereal}} \approx 23\ \text{h}\ 56\ \text{m}\ 4.1\ \text{s}
      \]
      Let your CST clock slowly drift stars using this deeper stellar rhythm, not just the Sun.
    </div>

    <h3>5. Light-Time Correction</h3>
    <div class="eq">
      \[
        t = \frac{d}{c}
      \]
      Distance \(d\) to a star or ship becomes a light-time delay \(t\). Farther = older snapshot of that region of the universe.
    </div>

    <p class="hint">
      You already built the vision. These pieces just lock it into the real sky: energy → mass → curvature → time,
      stitched with RA/Dec and light-time so your Interstellar Star Clock can live inside actual physics.
    </p>
  </section>

  <footer class="hint">
    This demo uses toy dynamics to exercise the workflow.
    Swap your GR + QM + CST kernels into the 3 hook functions and connect the time-dilation & star-mapping pieces to turn it into a full Interstellar Star Clock verifier.
  </footer>
</main>
<script>
// ---------- drawing helpers ----------
function clearCanvas(c){
  const x=c.getContext('2d');
  x.clearRect(0,0,c.width,c.height);
  return x;
}
function sizeCanvas(c){
  const dpr=window.devicePixelRatio||1;
  c.width=Math.floor(c.clientWidth*dpr);
  c.height=Math.floor(c.clientHeight*dpr);
  c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
}
function linePlot(canvas, series, colors, labels, alpha){
  sizeCanvas(canvas);
  const ctx=clearCanvas(canvas);
  const W=canvas.clientWidth, H=canvas.clientHeight;

  // grid
  ctx.save();
  ctx.strokeStyle="#1b2a3d";
  ctx.lineWidth=1;
  ctx.globalAlpha=0.35;
  for(let i=1;i<=4;i++){
    const y=H*i/5;
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(W,y);
    ctx.stroke();
  }
  ctx.restore();

  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  series.forEach(s=>s.forEach(p=>{
    xmin=Math.min(xmin,p[0]); xmax=Math.max(xmax,p[0]);
    ymin=Math.min(ymin,p[1]); ymax=Math.max(ymax,p[1]);
  }));
  if(!isFinite(ymin)||!isFinite(ymax)){ymin=0;ymax=1;}
  if(ymin===ymax){ymax=ymin+1;}

  const pad=8;
  const xmap=x=>(x-xmin)/(xmax-xmin||1)*(W-2*pad)+pad;
  const ymap=y=>H-((y-ymin)/(ymax-ymin||1))*(H-2*pad)-pad;

  const a = (typeof alpha==="number") ? alpha : 1;

  // series
  ctx.save();
  ctx.globalAlpha = a;
  series.forEach((s,i)=>{
    ctx.strokeStyle=colors[i%colors.length];
    ctx.lineWidth=2;
    ctx.beginPath();
    s.forEach((p,j)=>{
      const X=xmap(p[0]); const Y=ymap(p[1]);
      j?ctx.lineTo(X,Y):ctx.moveTo(X,Y);
    });
    ctx.stroke();
  });
  ctx.restore();

  // legend
  ctx.save();
  ctx.font="12px system-ui";
  let x=8,y=16;
  labels.forEach((L,i)=>{
    ctx.globalAlpha=a;
    ctx.fillStyle=colors[i%colors.length];
    ctx.fillRect(x,y-8,10,10);
    ctx.fillStyle="#cfe6ff";
    ctx.fillText(" "+L, x+12, y);
    x+=120;
  });
  ctx.restore();
}

function blob(canvas, strength, seed){
  sizeCanvas(canvas);
  const ctx=clearCanvas(canvas);
  const W=canvas.clientWidth, H=canvas.clientHeight;
  const cx=W*0.5, cy=H*0.5;
  const grd=ctx.createRadialGradient(cx,cy,10, cx,cy, Math.max(W,H)*0.6);
  const a=Math.max(0.12, Math.min(0.85, strength));
  grd.addColorStop(0, `rgba(110,231,255,${a})`);
  grd.addColorStop(0.35, `rgba(167,139,250,${a*0.7})`);
  grd.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle=grd;
  ctx.fillRect(0,0,W,H);

  ctx.globalAlpha=0.4;
  ctx.strokeStyle="rgba(110,231,255,0.35)";
  ctx.lineWidth=1.2;
  for(let k=1;k<=6;k++){
    ctx.beginPath();
    for(let x=0;x<W;x++){
      const y=cy + Math.sin((x/W)*Math.PI*2*(k+seed))* (10+strength*20)/(k*0.6);
      x===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}
function bars(canvas, vec){
  sizeCanvas(canvas);
  const ctx=clearCanvas(canvas);
  const W=canvas.clientWidth, H=canvas.clientHeight;
  const n=vec.length, w=(W-20)/n;
  for(let i=0;i<n;i++){
    const v=Math.max(0,Math.min(1,vec[i]));
    const h=v*H*0.9;
    ctx.fillStyle=`rgba(167,139,250,${0.25+0.6*v})`;
    ctx.fillRect(10+i*w, H-h-10, w*0.7, h);
  }
}
function setBadge(el, text, cls){
  el.textContent=text;
  el.className='badge '+cls;
}
function setValRow(valEl, statusEl, measured, pass){
  valEl.textContent = measured;
  statusEl.innerHTML = pass ? `<span class="badge ok">PASS</span>` : `<span class="badge bad">FAIL</span>`;
}

// ---------- photon forcing & events ----------
function makeOUNoise(tau, sigma, dt){
  let x = 0;
  const a = Math.exp(-dt/Math.max(1e-9,tau));
  const s = sigma*Math.sqrt(1-a*a);
  return ()=>{
    x = a*x + s*(Math.random()*2-1);
    return x;
  };
}
function photonFluxEffective(F0, dI, M, z, extraFrac){
  const factor = M / Math.pow(1+z,4);
  const jitter = 1 + dI + extraFrac;
  return Math.max(0, F0 * factor * jitter);
}
function parseEvents(text){
  return text.split(/[,\s]+/).map(Number).filter(v=>isFinite(v)).sort((a,b)=>a-b);
}
function lambdaGaussian(t, events, h){
  const inv = 1/(h*Math.sqrt(2*Math.PI)); let s=0;
  for (let i=0;i<events.length;i++){
    const u=(t-events[i])/h;
    s += Math.exp(-0.5*u*u);
  }
  return inv*s;
}
function lambdaExpCausal(t, events, h){
  let s=0;
  for (let i=0;i<events.length;i++){
    const dt=t-events[i];
    if(dt>=0) s += (1/h)*Math.exp(-dt/h);
  }
  return s;
}
function lambdaEpanechnikov(t, events, h){
  let s=0;
  for (let i=0;i<events.length;i++){
    const u=(t-events[i])/h;
    if (Math.abs(u)<=1) s += 0.75*(1-u*u)/h;
  }
  return s;
}

// ---------- UI refs ----------
const resCanvas  = document.getElementById('residuals');
const snapPre    = document.getElementById('snapPre');
const snapPost   = document.getElementById('snapPost');
const specPre    = document.getElementById('specPre');
const specPost   = document.getElementById('specPost');
const energyC    = document.getElementById('energy');

const statusBadge  = document.getElementById('statusBadge');
const solvedBadge  = document.getElementById('solvedBadge');
const stableBadge  = document.getElementById('stableBadge');
const physicalBadge= document.getElementById('physicalBadge');
const orbitVal   = document.getElementById('orbitVal');
const orbitStatus= document.getElementById('orbitStatus');
const frwVal     = document.getElementById('frwVal');
const frwStatus  = document.getElementById('frwStatus');
const labVal     = document.getElementById('labVal');
const labStatus  = document.getElementById('labStatus');
const gaugeBadge = document.getElementById('gaugeBadge');
const consBadge  = document.getElementById('consBadge');
const cflBadge   = document.getElementById('cflBadge');
const effBadge   = document.getElementById('effBadge');
const powerBadge = document.getElementById('powerBadge');

function P(id){ return parseFloat(document.getElementById(id).value); }

// ---------- Animation state ----------
const animState = {
  resSeries: null,
  powSeries: null,
  effSeries: null,
  specPre: null,
  specPost: null,
  specStrengthPre: 0,
  specStrengthPost: 0,
  energyLevel: 0,
  phase: 0,
  hasData: false
};

// ---------- SOLVER HOOKS (REPLACE WITH REAL KERNELS) ----------
function makeInBrowserSolver(params){
  // Toy scalar norms; replace with your full fields.
  const state = { hNorm: params.dC0, rhoNorm: params.Rqm0, t:0 };

  // 1) GR STEP
  function grStep(dt, S_strength){
    const alpha = Math.max(0.05, Math.min(5, 0.2*params.kp + 0.05*params.kd));
    state.hNorm = Math.max(0, state.hNorm * Math.exp(-alpha*dt) - 0.00001*S_strength);
    const R_GR = Math.max(1e-16, params.Rgr0 * (state.hNorm / (params.dC0+1e-12)));
    return R_GR;
  }

  // 2) QM STEP
  function qmStep(dt, couplingPhi, F_eff){
    const beta = Math.max(0.05, Math.min(5, 0.17*params.kp + 0.07*params.kd));
    state.rhoNorm = Math.max(0, state.rhoNorm * Math.exp(-beta*dt) - 0.00001*(couplingPhi + 1e-6*F_eff));
    const R_QM = Math.max(1e-16, params.Rqm0 * (state.rhoNorm / (params.Rqm0+1e-12)));
    const Tq_exp_mag = Math.max(0, 0.5*state.rhoNorm + 0.5*state.hNorm); // proxy
    return { R_QM, Tq_exp_mag };
  }

  // 3) CST FEEDBACK
  function cstFeedback(dt){
    const dC = state.hNorm;
    const dCdot = -dC;
    const Fmag = Math.max(0, params.kp*dC + params.kd*Math.abs(dCdot));
    return Fmag; // treat as control energy magnitude
  }

  return { state, grStep, qmStep, cstFeedback };
}

// ---------- MAIN SIMULATION ----------
async function simulate(){
  const N=parseInt(document.getElementById('steps').value,10);
  const dt=P('dt'), epsGR=P('epsGR'), epsQM=P('epsQM'), epsDC=P('epsDC'), hold=parseInt(document.getElementById('hold').value,10);
  const params={
    Rgr0:P('Rgr0'),
    Rqm0:P('Rqm0'),
    dC0:P('dC0'),
    spec0:Math.max(0,Math.min(1,P('spec0'))),
    kp:P('kp'),
    kd:P('kd')
  };

  const F0=P('F0'), Ml=P('Mlens'), dI=P('dI'), z=P('zred'), tau=P('tauNoise'), sig=P('sigmaNoise');
  const ou = makeOUNoise(tau, sig, dt);

  // event-driven intensity
  const eventsText = document.getElementById('eventTimes').value;
  const events = parseEvents(eventsText);
  const kernel = document.getElementById('kernelType').value;
  const h = P('bandwidth');
  const c_lambda = P('clambda');

  function lambdaHat(t){
    if (events.length===0) return 0;
    if (kernel==="gauss") return lambdaGaussian(t, events, h);
    if (kernel==="exp")   return lambdaExpCausal(t, events, h);
    if (kernel==="epa")   return lambdaEpanechnikov(t, events, h);
    return 0;
  }

  const seriesGR=[], seriesQM=[], seriesDC=[], seriesPow=[], seriesEff=[];
  let solvedCount=0, t=0, totPower=0, totCurv=0;

  const solver = makeInBrowserSolver(params);

  for(let i=0;i<N;i++){
    const dI_events = c_lambda * lambdaHat(t);
    const extraFrac = (dI_events + ou());

    const F_eff = photonFluxEffective(F0, dI, Ml, z, extraFrac);

    // EM source magnitude ~ energy flux / c (toy)
    const S_em_mag = F_eff / 299792458;

    // CST feedback
    const Fmag = solver.cstFeedback(dt);

    // QM step (depends on control + photon flux)
    const qm = solver.qmStep(dt, Fmag, F_eff);

    // GR step uses total source strength
    const R_GR = solver.grStep(dt, qm.Tq_exp_mag + S_em_mag + Fmag);
    const R_QM = qm.R_QM;
    const dC   = solver.state.hNorm;

    // energy accounting (toy)
    const power = Math.max(0, params.kp*dC*dC + params.kd*dC*dC);
    const dCurv = Math.max(0, (params.Rgr0+params.Rqm0) - (R_GR+R_QM));
    totPower += power*dt;
    totCurv += dCurv*dt;

    seriesGR.push([t,R_GR]);
    seriesQM.push([t,R_QM]);
    seriesDC.push([t,dC]);
    seriesPow.push([t,power]);
    seriesEff.push([t, totPower>0 ? (totCurv/totPower) : 0]);

    if (R_GR<epsGR && R_QM<epsQM && dC<epsDC) solvedCount++;
    else solvedCount=0;

    t += dt;
  }

  // build spectra vectors and energy level for animation
  const pre = Array.from({length:24},(_,i)=>
    Math.max(0,0.2 + 0.8*Math.sin((i/24)*Math.PI*2*3+0.4))*(0.6+0.5*params.spec0)
  );
  const post= pre.map(v=> v*0.45);
  const maxPower = seriesPow.reduce((m,p)=>Math.max(m,p[1]),0);
  const energyLevel = maxPower>0 ? Math.max(0, Math.min(1, maxPower/(maxPower+1))) : 0;

  animState.resSeries = [seriesGR,seriesQM,seriesDC];
  animState.powSeries = seriesPow;
  animState.effSeries = seriesEff;
  animState.specPre = pre;
  animState.specPost = post;
  animState.specStrengthPre = params.spec0;
  animState.specStrengthPost = Math.max(0, params.spec0-0.55);
  animState.energyLevel = energyLevel;
  animState.phase = 0;
  animState.hasData = true;

  // badges for efficiency & total power
  const avgEff = totPower>0 ? (totCurv/totPower) : 0;
  setBadge(effBadge, `Efficiency: ${avgEff.toFixed(3)}`, avgEff>0 ? "ok":"warn");
  setBadge(powerBadge, `Total power: ${totPower.toExponential(2)} arb.`, totPower>0 ? "ok":"warn");

  // badges for residuals
  const solved = solvedCount>=hold;
  setBadge(solvedBadge, solved ? "Self-consistency: PASS" : "Self-consistency: NOT MET", solved ? "ok":"bad");

  const tail = Math.floor(seriesDC.length*0.8);
  const stable = seriesDC.slice(tail).every((p,idx,arr)=> idx===0 || p[1] <= arr[idx-1][1]+1e-9);
  setBadge(stableBadge, stable ? "Stability: DAMPED" : "Stability: UNSTABLE?", stable ? "ok":"warn");

  const physical = true; // placeholder
  setBadge(physicalBadge, physical ? "Physicality: OK (placeholder)" : "Check constraints", physical ? "ok":"warn");

  const orbitErr = Math.max(1e-10, seriesGR.at(-1)[1]*0.5 + seriesQM.at(-1)[1]*0.5);
  const frwOK = (seriesGR.at(-1)[1] < 5*epsGR && seriesQM.at(-1)[1] < 5*epsQM);
  const labLinear = true;

  setValRow(orbitVal, orbitStatus, orbitErr.toExponential(2), orbitErr < 1e-8);
  setValRow(frwVal, frwStatus, frwOK ? "match" : "mismatch", frwOK);
  setValRow(labVal, labStatus, labLinear ? "linear" : "nonlinear", labLinear);

  setBadge(statusBadge, solved ? "Solved (toy): residuals under tolerance & stable" : "Incomplete: tune gains/ε or install real kernels", solved ? "ok":"warn");

  setBadge(gaugeBadge, "Gauge: OK (placeholder)", "ok");
  setBadge(consBadge,  "∇·T: OK (placeholder)",  "ok");
  setBadge(cflBadge,   dt < 0.1 ? "CFL: OK" : "CFL: Reduce Δt", dt<0.1 ? "ok":"bad");
}

// ---------- Animated drawing based on energy ----------
function drawResiduals(blink){
  if(!animState.hasData) return;
  const alpha = 0.3 + 0.7*blink;
  linePlot(resCanvas, animState.resSeries, ["#6ee7ff","#a78bfa","#3ddc97"], ["R_GR","R_QM","ΔC"], alpha);
}
function drawSnapshots(blink){
  if(!animState.hasData) return;
  const f = 0.85 + 0.15*blink;
  const preStrength  = (animState.specStrengthPre  || 0.7) * f;
  const postStrength = (animState.specStrengthPost || 0.2) * f;

  blob(snapPre,  preStrength,  2);
  blob(snapPost, postStrength, 4);

  if(animState.specPre){
    const v1 = animState.specPre.map(v=>v*(0.9+0.1*blink));
    bars(specPre, v1);
  }
  if(animState.specPost){
    const v2 = animState.specPost.map(v=>v*(0.9+0.1*blink));
    bars(specPost, v2);
  }
}
function drawEnergy(blink){
  if(!animState.hasData) return;
  const alpha = 0.3 + 0.7*blink;
  linePlot(energyC, [animState.powSeries, animState.effSeries], ["#ffdd57","#3ddc97"], ["input power","efficiency"], alpha);
}

// main animation loop
let lastFrameTime = null;
function animationLoop(timestamp){
  if(!lastFrameTime) lastFrameTime = timestamp;
  const dt = (timestamp-lastFrameTime)/1000;
  lastFrameTime = timestamp;

  const e = animState.energyLevel || 0;
  const speed = 0.6 + 3*e;       // more energy → faster blinking
  animState.phase += speed * dt;
  const blink = 0.5 + 0.5*Math.sin(animState.phase*2*Math.PI); // 0..1

  if(animState.hasData){
    drawResiduals(blink);
    drawSnapshots(blink);
    drawEnergy(blink);
  }

  requestAnimationFrame(animationLoop);
}
requestAnimationFrame(animationLoop);

// ---------- events ----------
document.getElementById('runBtn').addEventListener('click', ()=>{
  setBadge(statusBadge, "Running…", "badge");
  setTimeout(simulate, 50);
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  document.getElementById('steps').value=500; document.getElementById('dt').value=0.02;
  document.getElementById('epsGR').value=1e-6; document.getElementById('epsQM').value=1e-6; document.getElementById('epsDC').value=1e-6;
  document.getElementById('hold').value=50; document.getElementById('Rgr0').value=0.08; document.getElementById('Rqm0').value=0.06;
  document.getElementById('dC0').value=0.10; document.getElementById('spec0').value=0.70; document.getElementById('kp').value=1.6; document.getElementById('kd').value=0.3;
  document.getElementById('F0').value=1361; document.getElementById('Mlens').value=1.00; document.getElementById('dI').value=0.03; document.getElementById('zred').value=0.00010;
  document.getElementById('tauNoise').value=600; document.getElementById('sigmaNoise').value=0.005;
  document.getElementById('eventTimes').value=""; document.getElementById('kernelType').value="gauss"; document.getElementById('bandwidth').value=300; document.getElementById('clambda').value=0.01;

  animState.hasData = false;

  setBadge(statusBadge,"Idle — awaiting run","warn");
  [resCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>{sizeCanvas(c); clearCanvas(c);});
  setBadge(solvedBadge,"Self-consistency: —","badge");
  setBadge(stableBadge,"Stability: —","badge");
  setBadge(physicalBadge,"Physicality: —","badge");
  setBadge(gaugeBadge,"Gauge: —","badge");
  setBadge(consBadge,"∇·T: —","badge");
  setBadge(cflBadge,"CFL: —","badge");
  setBadge(effBadge,"Efficiency: —","badge");
  setBadge(powerBadge,"Total power: —","badge");
  setValRow(orbitVal, orbitStatus, "—", false);
  setValRow(frwVal, frwStatus, "—", false);
  setValRow(labVal, labStatus, "—", false);
});

// ---------- example fill helper ----------
function setVal(id, v){ const el=document.getElementById(id); if(el) el.value=v; }
function loadExample(kind){
  setVal('steps', 500); setVal('dt', 0.02);
  setVal('epsGR', 1e-6); setVal('epsQM', 1e-6); setVal('epsDC', 1e-6);
  setVal('hold', 50);
  setVal('spec0', 0.70);

  if(kind==='quiet'){
    setVal('Rgr0', 0.08); setVal('Rqm0', 0.06); setVal('dC0', 0.10);
    setVal('kp', 1.4); setVal('kd', 0.25);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.01); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.003);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.01);
  }
  if(kind==='flare'){
    setVal('Rgr0', 0.10); setVal('Rqm0', 0.08); setVal('dC0', 0.12);
    setVal('kp', 1.8); setVal('kd', 0.35);
    setVal('F0', 1361); setVal('Mlens', 1.02); setVal('dI', 0.03); setVal('zred', 0.00010);
    setVal('tauNoise', 600); setVal('sigmaNoise', 0.008);
    setVal('eventTimes', "120, 340, 355, 910, 1240, 1805, 1812, 2600, 3600, 4200");
    setVal('kernelType', "exp"); setVal('bandwidth', 420); setVal('clambda', 0.015);
  }
  if(kind==='lab'){
    setVal('Rgr0', 0.05); setVal('Rqm0', 0.04); setVal('dC0', 0.06);
    setVal('kp', 1.2); setVal('kd', 0.20);
    setVal('F0', 1.0); setVal('Mlens', 1.00); setVal('dI', 0.0); setVal('zred', 0.0);
    setVal('tauNoise', 300); setVal('sigmaNoise', 0.0);
    setVal('eventTimes', ""); setVal('kernelType', "epa"); setVal('bandwidth', 120); setVal('clambda', 0.0);
    setVal('epsGR', 5e-7); setVal('epsQM', 5e-7); setVal('epsDC', 5e-7);
  }
  if(kind==='pass'){
    setVal('steps', 2000); setVal('dt', 0.02);
    setVal('epsGR', 1e-7); setVal('epsQM', 1e-7); setVal('epsDC', 1e-7);
    setVal('hold', 80);
    setVal('Rgr0', 0.02); setVal('Rqm0', 0.02); setVal('dC0', 0.03);
    setVal('spec0', 0.50);
    setVal('kp', 2.2); setVal('kd', 0.50);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.005); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.001);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.0);
  }

  document.getElementById('steps').scrollIntoView({behavior:'smooth', block:'center'});
}

// initial sizing on load/resize
window.addEventListener('resize', ()=>{
  [resCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>{sizeCanvas(c);});
});
[resCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>sizeCanvas(c));
</script>
</body>
</html>
