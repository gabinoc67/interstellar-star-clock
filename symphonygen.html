<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Orchestral Mixer — Classic Order (Score Builder)</title>
<meta name="description" content="Build a 1-minute classic-order orchestral mix. Add exact notes per instrument (BPM, offsets, durations). No randomness."/>
<style>
  :root{
    --bg:#081022; --panel:#0f1636; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#1a2658; --btn:#1b2a6b;
    --ok:#10b981; --warn:#f59e0b; --danger:#ef4444; --line:#6ee7ff; --accent:#93c5fd;
    --str:#8bc6ff; --ww:#b8ffda; --br:#ffd599; --pc:#ff9aa2; --pn:#d0b3ff;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:24px;margin:0 0 6px}
  h2{font-size:18px;margin:0 0 8px}
  .sub{color:var(--muted);font-size:14px;margin-bottom:16px}
  .grid{display:grid;gap:12px}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:1060px){.row{grid-template-columns:1.8fr 1.2fr}}
  .panel{background:var(--panel);border:1px solid var(--grid);border-radius:14px;padding:14px}
  .controls{display:grid;grid-template-columns:repeat(6, minmax(0,1fr));gap:10px;margin:8px 0}
  .btn{background:var(--btn);border:1px solid var(--grid);color:var(--ink);border-radius:12px;padding:12px 14px;font-weight:700;font-size:16px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{background:#173076}
  .btn.warn{background:#4d2f03;border-color:#7a4b07}
  input[type="file"], select, input[type="number"], input[type="text"], textarea{
    background:#0b1432;border:1px solid var(--grid);color:var(--ink);border-radius:10px;padding:10px 12px;font-size:15px;width:100%
  }
  label{font-size:13px;color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  .legend{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
  .pill{border:1px solid var(--grid);border-radius:999px;padding:6px 12px;font-size:12px;display:flex;gap:8px;align-items:center}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.str{background:var(--str)} .dot.ww{background:var(--ww)} .dot.br{background:var(--br)} .dot.pc{background:var(--pc)} .dot.pn{background:var(--pn)}
  .timeline{height:80px;background:#0b1432;border:1px solid var(--grid);border-radius:12px;position:relative;margin-top:12px;overflow:hidden}
  .gridline{position:absolute;top:0;bottom:0;width:1px;background:#1a2658}
  .marker{position:absolute;top:0;bottom:0;width:3px;background:var(--line);box-shadow:0 0 12px var(--line)}
  .label{position:absolute;top:6px;font-size:11px;color:var(--muted)}
  .band{position:absolute;top:0;bottom:0;opacity:.16}
  .band.str{background:var(--str)} .band.ww{background:var(--ww)} .band.br{background:var(--br)} .band.pc{background:var(--pc)} .band.pn{background:var(--pn)}
  .status{display:flex;gap:12px;align-items:center;margin-top:8px;flex-wrap:wrap}
  .lamp{width:12px;height:12px;border-radius:50%;background:#394b7a;box-shadow:0 0 0 0 transparent}
  .lamp.on{background:var(--ok);box-shadow:0 0 10px var(--ok)}
  .meters{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-top:10px}
  .chan{background:#0b1432;border:1px solid var(--grid);border-radius:12px;padding:12px}
  .chan h3{margin:0 0 6px;font-size:15px}
  .tag{font-size:11px;border-radius:999px;padding:2px 8px;display:inline-block;margin-left:6px;vertical-align:1px;border:1px solid var(--grid);color:var(--muted)}
  .volrow{display:flex;gap:10px;align-items:center}
  .volrow input[type="range"]{width:100%}
  .muterow{display:flex;gap:10px;margin-top:8px}
  .muterow .btn{padding:10px 12px;font-size:14px}
  table{width:100%;border-collapse:collapse}
  th, td{border:1px solid var(--grid);padding:8px;font-size:14px;vertical-align:top}
  th{background:#0b1432}
  .scroll{max-height:260px;overflow:auto;border:1px solid var(--grid);border-radius:10px}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#0b1432;border:1px solid var(--grid);padding:2px 6px;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <h1>AI Orchestral Mixer — Classic Order</h1>
  <div class="sub">One-minute mixer (no randomness). Add exact notes for each instrument. Classic entrance: <b>Strings 0s</b> → <b>Woodwinds 10s</b> → <b>Brass 20s</b> → <b>Percussion 35s</b> → <b>Piano/Harp 45s</b>.</div>

  <div class="row">
    <!-- LEFT: Transport + Timeline -->
    <div class="panel">
      <h2>Transport</h2>
      <div class="controls">
        <button id="btnPlay" class="btn">PLAY</button>
        <button id="btnStop" class="btn" disabled>STOP</button>
        <button id="btnReset" class="btn secondary">RESET</button>
        <input id="fileBeat" type="file" accept="audio/*" title="Upload a looped beat (WAV/MP3)"/>
        <button id="btnMetronome" class="btn">Use Metronome</button>
        <button id="btnLoop" class="btn" title="Loop after 60s">Loop Off</button>
      </div>
      <div class="small">Tip: upload your beat (e.g., <i>notesbeat.wav</i>). If none, press <span class="kbd">Use Metronome</span>.</div>

      <div class="legend">
        <span class="pill"><span class="dot str"></span>Strings @ 0s</span>
        <span class="pill"><span class="dot ww"></span>Woodwinds @ 10s</span>
        <span class="pill"><span class="dot br"></span>Brass @ 20s</span>
        <span class="pill"><span class="dot pc"></span>Percussion @ 35s</span>
        <span class="pill"><span class="dot pn"></span>Piano/Harp @ 45s</span>
      </div>

      <div class="timeline" id="timeline">
        <div class="marker" id="playhead" style="left:0%"></div>
      </div>

      <div class="status">
        <div class="lamp" id="lampAudio"></div><span class="small">Audio Engine</span>
        <div class="lamp" id="lampBeat"></div><span class="small">Beat Loaded</span>
        <div class="lamp" id="lampPlaying"></div><span class="small">Playing</span>
        <span class="small" id="txtTime">t = 0.0s</span>
        <span class="small" id="txtMsg"></span>
      </div>
    </div>

    <!-- RIGHT: Mixer Channels (Sections) -->
    <div class="panel">
      <h2>Section Mixer</h2>
      <div class="meters">
        <div class="chan">
          <h3>Strings <span class="tag">0–60s</span></h3>
          <div class="volrow"><label>Volume</label><input id="volStrings" type="range" min="0" max="1" step="0.01" value="0.9"/></div>
          <div class="muterow">
            <button id="muteStrings" class="btn">Mute</button>
            <button id="soloStrings" class="btn">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Woodwinds <span class="tag">10–60s</span></h3>
          <div class="volrow"><label>Volume</label><input id="volWoodwinds" type="range" min="0" max="1" step="0.01" value="0.85"/></div>
          <div class="muterow">
            <button id="muteWoodwinds" class="btn">Mute</button>
            <button id="soloWoodwinds" class="btn">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Brass <span class="tag">20–60s</span></h3>
          <div class="volrow"><label>Volume</label><input id="volBrass" type="range" min="0" max="1" step="0.01" value="0.8"/></div>
          <div class="muterow">
            <button id="muteBrass" class="btn">Mute</button>
            <button id="soloBrass" class="btn">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Percussion <span class="tag">35–60s</span></h3>
          <div class="volrow"><label>Volume</label><input id="volPerc" type="range" min="0" max="1" step="0.01" value="0.85"/></div>
          <div class="muterow">
            <button id="mutePerc" class="btn">Mute</button>
            <button id="soloPerc" class="btn">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Piano/Harp <span class="tag">45–60s</span></h3>
          <div class="volrow"><label>Volume</label><input id="volPiano" type="range" min="0" max="1" step="0.01" value="0.8"/></div>
          <div class="muterow">
            <button id="mutePiano" class="btn">Mute</button>
            <button id="soloPiano" class="btn">Solo</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- SCORE BUILDER -->
  <div class="grid">
    <div class="panel">
      <h2>Score Builder (Add Exact Notes Per Instrument)</h2>
      <div class="grid" style="grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;margin-bottom:10px">
        <div>
          <label>Instrument (full orchestra list)</label>
          <select id="selInstrument">
            <!-- Strings -->
            <optgroup label="Strings">
              <option>Violin I</option><option>Violin II</option><option>Viola</option><option>Cello</option><option>Contrabass</option>
            </optgroup>
            <!-- Woodwinds -->
            <optgroup label="Woodwinds">
              <option>Flute</option><option>Oboe</option><option>Clarinet</option><option>Bassoon</option><option>Piccolo</option>
              <option>English Horn</option><option>Bass Clarinet</option><option>Contrabassoon</option>
            </optgroup>
            <!-- Brass -->
            <optgroup label="Brass">
              <option>Horn</option><option>Trumpet</option><option>Trombone</option><option>Bass Trombone</option><option>Tuba</option>
            </optgroup>
            <!-- Percussion -->
            <optgroup label="Percussion">
              <option>Kick</option><option>Snare</option><option>Hi-hat</option><option>Timpani</option><option>Cymbals</option>
            </optgroup>
            <!-- Keys / Harp -->
            <optgroup label="Keys & Harp">
              <option>Piano</option><option>Celesta</option><option>Harp</option>
            </optgroup>
          </select>
        </div>
        <div>
          <label>BPM (beats/min)</label>
          <input id="inpBPM" type="number" min="20" max="240" value="120"/>
        </div>
        <div>
          <label>Start Offset (sec, after section entry)</label>
          <input id="inpOffset" type="number" min="0" max="60" step="0.01" value="0"/>
        </div>
        <div>
          <label>Channel Volume (0–1)</label>
          <input id="inpVol" type="number" min="0" max="1" step="0.01" value="0.8"/>
        </div>
      </div>

      <label>Notes (comma-separated): <span class="small">Format <span class="kbd">NOTE:beatOffset:durBeats</span>. Pitched: C3..C6. Perc: K,S,H.</span></label>
      <textarea id="inpNotes" rows="5" placeholder="Examples:
Violin I → C4:0:1, E4:1:1, G4:2:2
Timpani → C2:0:2, C2:4:2
Percussion (Kick/Snare/Hat) → K:0:1, H:0.5:0.5, S:1:1"></textarea>

      <div class="controls" style="grid-template-columns:repeat(3, minmax(0,1fr))">
        <button id="btnAddPattern" class="btn">Add Pattern</button>
        <button id="btnClearPatterns" class="btn warn">Clear All Patterns</button>
        <button id="btnExportPatterns" class="btn secondary">Export JSON</button>
      </div>

      <div class="scroll">
        <table id="tblPatterns">
          <thead>
            <tr><th>#</th><th>Instrument</th><th>Section</th><th>BPM</th><th>Start Offset (s)</th><th>Vol</th><th>Notes</th><th>Remove</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="small" style="margin-top:8px">
        Classic section entries: Strings 0s · Woodwinds 10s · Brass 20s · Percussion 35s · Piano/Harp 45s.  
        Your <b>Start Offset</b> begins after the section’s entry time.
      </div>
    </div>
  </div>
</div>
<script>
(() => {
  // ===== Constants =====
  const DURATION = 60;
  const CLASSIC_ORDER = [
    { key:'strings',   start: 0,  color:'var(--str)'},
    { key:'woodwinds', start:10,  color:'var(--ww)'},
    { key:'brass',     start:20,  color:'var(--br)'},
    { key:'perc',      start:35,  color:'var(--pc)'},
    { key:'piano',     start:45,  color:'var(--pn)'},
  ];

  // Instrument → section map
  const SECTION_OF = {
    // strings
    "Violin I":"strings","Violin II":"strings","Viola":"strings","Cello":"strings","Contrabass":"strings",
    // woodwinds
    "Flute":"woodwinds","Oboe":"woodwinds","Clarinet":"woodwinds","Bassoon":"woodwinds","Piccolo":"woodwinds",
    "English Horn":"woodwinds","Bass Clarinet":"woodwinds","Contrabassoon":"woodwinds",
    // brass
    "Horn":"brass","Trumpet":"brass","Trombone":"brass","Bass Trombone":"brass","Tuba":"brass",
    // percussion
    "Kick":"perc","Snare":"perc","Hi-hat":"perc","Timpani":"perc","Cymbals":"perc",
    // keys/harp
    "Piano":"piano","Celesta":"piano","Harp":"piano"
  };

  // ===== State =====
  let ctx = null, master = null;
  let startTime = 0;
  let isPlaying = false;
  let loopEnabled = false;

  // Beat
  let beatBuffer = null, beatGain = null, usingMetronome = false;

  // Section gains
  const channel = {
    strings:{gain:null, muted:false, solo:false},
    woodwinds:{gain:null, muted:false, solo:false},
    brass:{gain:null, muted:false, solo:false},
    perc:{gain:null, muted:false, solo:false},
    piano:{gain:null, muted:false, solo:false},
  };

  // Patterns added by user
  // pattern = { instrument, section, bpm, offsetSec, vol, notes: [{name, beat, dur}], id }
  const patterns = [];

  // ===== Elements =====
  const lampAudio = document.getElementById('lampAudio');
  const lampBeat = document.getElementById('lampBeat');
  const lampPlaying = document.getElementById('lampPlaying');
  const txtTime = document.getElementById('txtTime');
  const txtMsg = document.getElementById('txtMsg');
  const playhead = document.getElementById('playhead');
  const timeline = document.getElementById('timeline');

  const btnPlay = document.getElementById('btnPlay');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnMetronome = document.getElementById('btnMetronome');
  const btnLoop = document.getElementById('btnLoop');
  const fileBeat = document.getElementById('fileBeat');

  // section volume sliders
  const volEls = {
    strings: document.getElementById('volStrings'),
    woodwinds: document.getElementById('volWoodwinds'),
    brass: document.getElementById('volBrass'),
    perc: document.getElementById('volPerc'),
    piano: document.getElementById('volPiano'),
  };

  // ===== Setup =====
  function ensureAudio() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain();
    master.gain.value = 0.95;
    master.connect(ctx.destination);

    // per-section gains
    for (const k of Object.keys(channel)) {
      const g = ctx.createGain();
      g.gain.value = parseFloat(volEls[k].value);
      g.connect(master);
      channel[k].gain = g;
      volEls[k].addEventListener('input', applyGains);
    }

    beatGain = ctx.createGain();
    beatGain.gain.value = 0.9;
    beatGain.connect(master);

    lampAudio.classList.add('on');
  }

  // UI helpers
  function setTransportState(playing){
    isPlaying = playing;
    btnStop.disabled = !playing;
  }

  // file beat
  fileBeat.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    ensureAudio();
    try {
      const arr = await file.arrayBuffer();
      beatBuffer = await ctx.decodeAudioData(arr);
      usingMetronome = false;
      lampBeat.classList.add('on');
      txtMsg.textContent = 'Beat loaded';
    } catch (err) {
      txtMsg.textContent = 'Could not decode audio';
      console.error(err);
    }
  });

  // metronome
  btnMetronome.onclick = () => {
    ensureAudio();
    beatBuffer = null;
    usingMetronome = true;
    lampBeat.classList.add('on');
    txtMsg.textContent = 'Metronome beat enabled (120 BPM)';
  };

  // Transport
  btnPlay.onclick = async () => {
    ensureAudio();
    await ctx.resume();
    if (isPlaying) return;
    setTransportState(true);
    lampPlaying.classList.add('on');
    txtMsg.textContent = 'Playing…';

    startTime = ctx.currentTime;
    scheduleOneMinute(startTime);
    startUITimer();
  };

  btnStop.onclick = () => {
    stopAll();
  };

  btnReset.onclick = () => {
    stopAll({silent:true});
    clearTimelineMarker();
    txtTime.textContent = 't = 0.0s';
    txtMsg.textContent = 'Reset';
  };

  btnLoop.onclick = () => {
    loopEnabled = !loopEnabled;
    btnLoop.textContent = loopEnabled ? 'Loop On' : 'Loop Off';
  };

  // Mute/Solo binders
  const bindMuteSolo = (key, muteBtnId, soloBtnId) => {
    document.getElementById(muteBtnId).onclick = () => {
      channel[key].muted = !channel[key].muted;
      document.getElementById(muteBtnId).textContent = channel[key].muted ? 'Unmute' : 'Mute';
      applyGains();
    };
    document.getElementById(soloBtnId).onclick = () => {
      channel[key].solo = !channel[key].solo;
      document.getElementById(soloBtnId).textContent = channel[key].solo ? 'Unsolo' : 'Solo';
      applyGains();
    };
  };
  bindMuteSolo('strings','muteStrings','soloStrings');
  bindMuteSolo('woodwinds','muteWoodwinds','soloWoodwinds');
  bindMuteSolo('brass','muteBrass','soloBrass');
  bindMuteSolo('perc','mutePerc','soloPerc');
  bindMuteSolo('piano','mutePiano','soloPiano');

  function applyGains(){
    const anySolo = Object.values(channel).some(c => c.solo);
    for (const k of Object.keys(channel)) {
      const vol = parseFloat(volEls[k].value);
      const ch = channel[k];
      let target = vol;
      if (anySolo) target = ch.solo ? vol : 0.0;
      if (ch.muted) target = 0.0;
      ch.gain.gain.setTargetAtTime(target, ctx.currentTime, 0.01);
    }
  }

  // ===== Timeline scheduling =====
  function scheduleOneMinute(t0) {
    scheduleBeat(t0);
    scheduleUserPatterns(t0);

    // handle loop or stop
    const stopAt = t0 + DURATION;
    setTimeout(() => {
      if (!loopEnabled) {
        stopAll();
      } else {
        startTime = ctx.currentTime;
        scheduleOneMinute(startTime);
      }
    }, Math.max(0, (stopAt - ctx.currentTime) * 1000));
  }

  function scheduleBeat(t0){
    if (!ctx) return;
    if (beatBuffer) {
      const src = ctx.createBufferSource();
      src.buffer = beatBuffer;
      src.loop = true;
      src.connect(beatGain);
      src.start(t0);
      src.stop(t0 + DURATION + 0.05);
    } else if (usingMetronome) {
      const bpm = 120, spb = 60/bpm;
      for (let t = 0; t < DURATION; t += spb) metronomeTick(t0 + t);
    }
  }
  function metronomeTick(at){
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type='square'; o.frequency.value=2000;
    g.gain.value=0.0001; o.connect(g).connect(beatGain);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.3, at+0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.05);
    o.start(at); o.stop(at+0.06);
  }

  // ===== Note scheduling (based on user patterns) =====
  function scheduleUserPatterns(t0){
    for (const p of patterns) {
      const section = p.section;
      const sectionStart = CLASSIC_ORDER.find(x => x.key===section)?.start || 0;
      const base = t0 + sectionStart + p.offsetSec;
      const out = channel[section].gain;

      // Section-local instrument gain
      const instGain = ctx.createGain();
      instGain.gain.value = p.vol;
      instGain.connect(out);

      const spb = 60 / p.bpm;

      for (const ev of p.notes) {
        const at = base + ev.beat * spb;
        const dur = Math.max(0.05, ev.dur) * spb;
        // percussion special handling
        if (section === 'perc' && isPercName(p.instrument)) {
          schedulePercOne(p.instrument, at, dur, instGain);
        } else {
          scheduleToneOne(p.instrument, at, dur, instGain);
        }
      }
    }
  }

  function isPercName(name){
    const n = name.toLowerCase();
    return n.includes('kick') || n.includes('snare') || n.includes('hat') || n.includes('timpani') || n.includes('cymb');
  }

  // Tone synth by instrument family
  function scheduleToneOne(inst, at, dur, out){
    const fam = SECTION_OF[inst];
    if (fam === 'strings') toneDetuned(at, dur, out, 'sawtooth', inst, 0.9);
    else if (fam === 'woodwinds') toneVibrato(at, dur, out, 'sine', 5, 7);
    else if (fam === 'brass') toneFiltered(at, dur, out, 'square', 900);
    else /* piano */ tonePluck(at, dur, out);
  }

  // These helpers expect the current note freq to be set on g._freq by the caller (we’ll set inside parse step)
  function toneDetuned(at, dur, out, type, inst, det=0.8){
    const f = out._freq || 440;
    const o1 = ctx.createOscillator(), o2 = ctx.createOscillator();
    const g = ctx.createGain(); g.gain.value = 0.0001;
    o1.type=type; o2.type=type;
    o1.frequency.value = f*(1-det*0.005);
    o2.frequency.value = f*(1+det*0.005);
    o1.connect(g); o2.connect(g); g.connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.22, at+0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
    o1.start(at); o2.start(at); o1.stop(at+dur+0.05); o2.stop(at+dur+0.05);
  }

  function toneVibrato(at, dur, out, type, lfoHz, depth){
    const f = out._freq || 440;
    const o = ctx.createOscillator(), g = ctx.createGain();
    const lfo = ctx.createOscillator(), lg = ctx.createGain();
    o.type=type; o.frequency.value=f; g.gain.value=0.0001;
    lfo.frequency.value = lfoHz; lg.gain.value = depth;
    lfo.connect(lg).connect(o.frequency);
    o.connect(g).connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.25, at+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
    lfo.start(at); lfo.stop(at+dur);
    o.start(at); o.stop(at+dur+0.02);
  }

  function toneFiltered(at, dur, out, type, lpFreq){
    const f = out._freq || 440;
    const o = ctx.createOscillator(), g = ctx.createGain(); const lp = ctx.createBiquadFilter();
    o.type=type; o.frequency.value=f; g.gain.value=0.0001; lp.type='lowpass'; lp.frequency.value=lpFreq;
    o.connect(lp).connect(g).connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.35, at+0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
    o.start(at); o.stop(at+dur+0.02);
  }

  function tonePluck(at, dur, out){
    const f = out._freq || 440;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type='triangle'; o.frequency.value=f; g.gain.value=0.0001;
    o.connect(g).connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.28, at+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
    o.start(at); o.stop(at+dur+0.02);
  }

  // Perc parts
  function schedulePercOne(inst, at, dur, out){
    const low = inst.toLowerCase();
    if (low.includes('kick')) kick(at, out);
    else if (low.includes('snare')) snare(at, out);
    else if (low.includes('hat')) hat(at, out, 0.05);
    else if (low.includes('timpani')) timpani(at, dur, out);
    else cymbal(at, out);
  }
  function kick(at, out){
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type='sine'; o.frequency.setValueAtTime(120, at);
    o.frequency.exponentialRampToValueAtTime(40, at+0.1);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.9, at+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.18);
    o.connect(g).connect(out); o.start(at); o.stop(at+0.2);
  }
  function snare(at, out){
    const noise = ctx.createBufferSource();
    const buffer = ctx.createBuffer(1, ctx.sampleRate*0.15, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
    noise.buffer=buffer;
    const bp=ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2000; bp.Q.value=0.9;
    const g=ctx.createGain();
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.6, at+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.12);
    noise.connect(bp).connect(g).connect(out);
    noise.start(at); noise.stop(at+0.13);
  }
  function hat(at, out, len=0.05){
    const noise=ctx.createBufferSource();
    const buffer=ctx.createBuffer(1, ctx.sampleRate*len, ctx.sampleRate);
    const data=buffer.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
    noise.buffer=buffer;
    const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=7000; hp.Q.value=0.6;
    const g=ctx.createGain();
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.35, at+0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, at+len);
    noise.connect(hp).connect(g).connect(out);
    noise.start(at); noise.stop(at+len+0.01);
  }
  function timpani(at, dur, out){
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type='sine'; o.frequency.value=out._freq || 100;
    g.gain.value=0.0001; o.connect(g).connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.6, at+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, at+Math.min(0.8,dur));
    o.start(at); o.stop(at+Math.min(0.82,dur+0.02));
  }
  function cymbal(at, out){
    hat(at, out, 0.2);
  }

  // ===== Note parsing =====
  const NOTE_INDEX = {C:0,'C#':1,Db:1,D:2,'D#':3,Eb:3,E:4,F:5,'F#':6,Gb:6,G:7,'G#':8,Ab:8,A:9,'A#':10,Bb:10,B:11};
  function noteNameToFreq(name){
    // e.g. C4, F#3, Bb2
    const m = String(name).match(/^([A-G](?:#|b)?)(-?\d)$/);
    if (!m) return 440;
    const pitch = m[1], oct = parseInt(m[2],10);
    const idx = NOTE_INDEX[pitch];
    const n = idx + (oct+1)*12; // MIDI-ish
    return 440 * Math.pow(2,(n-69)/12);
  }

  // Expose minimal API to Part 4
  window.__AIMIXER__ = {
    DURATION, CLASSIC_ORDER,
    get ctx(){ return ctx }, set ctx(v){ ctx=v },
    get startTime(){ return startTime }, isPlaying:()=>isPlaying,
    ensureAudio, scheduleOneMinute,
    stopAll, applyGains,
    timeline, playhead, lamps:{lampAudio,lampBeat,lampPlaying}, txtTime, txtMsg,
    patterns, SECTION_OF, noteNameToFreq
  };

  // ===== STOP / RESET =====
  function hardResetContext(){
    const prev = ctx;
    if (!prev) return;
    try { prev.close(); } catch(_){}
    ctx = null;
  }
  function stopAll(opts={}){
    const {silent=false}=opts;
    isPlaying=false; btnStop.disabled=true; lamps.lampPlaying.classList.remove('on');
    hardResetContext();
    if (!silent) txtMsg.textContent='Stopped';
  }

  // ===== UI playhead timer (Part 4 will start it) =====
  let uiTimer=null;
  function startUITimer(){
    clearInterval(uiTimer);
    uiTimer=setInterval(()=>{
      if (!ctx) return;
      const t=Math.max(0, ctx.currentTime - startTime);
      const clamped=Math.min(DURATION,t);
      txtTime.textContent=`t = ${clamped.toFixed(1)}s`;
      playhead.style.left=`${(clamped/DURATION)*100}%`;
      if (t>=DURATION && !isPlaying){ clearInterval(uiTimer); }
    }, 50);
  }
  window.__AIMIXER__.startUITimer = startUITimer;

})();
</script>
<script>
(() => {
  const {
    DURATION, CLASSIC_ORDER,
    ensureAudio, scheduleOneMinute, applyGains, stopAll,
    timeline, playhead, lamps, txtTime, txtMsg,
    patterns, SECTION_OF, noteNameToFreq, startUITimer
  } = window.__AIMIXER__;

  // ===== Timeline Draw =====
  const W = () => timeline.clientWidth;
  function initTimeline(){
    timeline.querySelectorAll('.gridline,.label,.band').forEach(n=>n.remove());
    // bands
    CLASSIC_ORDER.forEach(sec=>{
      const band=document.createElement('div');
      band.className=`band ${sec.key==='strings'?'str':sec.key==='woodwinds'?'ww':sec.key==='brass'?'br':sec.key==='perc'?'pc':'pn'}`;
      const left=(sec.start/DURATION)*100;
      const width=((DURATION-sec.start)/DURATION)*100;
      band.style.left=left+'%'; band.style.width=width+'%';
      timeline.appendChild(band);
    });
    // grid
    for(let s=0;s<=DURATION;s+=5){
      const x=(s/DURATION)*W();
      const gl=document.createElement('div'); gl.className='gridline'; gl.style.left=(x|0)+'px';
      timeline.appendChild(gl);
      const lab=document.createElement('div'); lab.className='label'; lab.textContent=s+'s';
      lab.style.left=`calc(${(s/DURATION)*100}% + 4px)`; timeline.appendChild(lab);
    }
  }
  initTimeline(); window.addEventListener('resize', initTimeline);

  // ===== Transport buttons (UI only; audio hooks in Part 3) =====
  document.getElementById('btnPlay').addEventListener('click', ()=> startUITimer());
  document.getElementById('btnStop').addEventListener('click', ()=> {/* managed by Part 3 */});
  document.getElementById('btnReset').addEventListener('click', ()=>{
    playhead.style.left='0%'; txtTime.textContent='t = 0.0s';
  });

  // ===== Score Builder logic =====
  const selInstrument = document.getElementById('selInstrument');
  const inpBPM = document.getElementById('inpBPM');
  const inpOffset = document.getElementById('inpOffset');
  const inpVol = document.getElementById('inpVol');
  const inpNotes = document.getElementById('inpNotes');
  const btnAddPattern = document.getElementById('btnAddPattern');
  const btnClearPatterns = document.getElementById('btnClearPatterns');
  const btnExportPatterns = document.getElementById('btnExportPatterns');
  const tblBody = document.querySelector('#tblPatterns tbody');

  let patternIdCounter = 1;

  function parseNotes(raw, instrument){
    // Accept tokens: NOTE:beat:dur  or K/S/H:beat:dur (percussion)
    const out=[];
    const items = String(raw).split(',').map(s=>s.trim()).filter(Boolean);
    for (const it of items){
      const m = it.match(/^([A-G](?:#|b)?-?\d|[KkSsHh])\s*:\s*([0-9]*\.?[0-9]+)\s*:\s*([0-9]*\.?[0-9]+)$/);
      if (!m) continue;
      const name = m[1].toUpperCase();
      const beat = parseFloat(m[2]); const dur = parseFloat(m[3]);
      out.push({name, beat, dur});
    }
    if (!out.length) throw new Error('No valid notes parsed. Check format NOTE:beat:dur (e.g., C4:0:1).');
    return out;
  }

  function sectionOfInstrument(inst){
    return SECTION_OF[inst] || 'strings';
  }

  function addRow(p){
    const tr=document.createElement('tr');
    tr.dataset.id = p.id;
    tr.innerHTML = `
      <td>${p.id}</td>
      <td>${p.instrument}</td>
      <td>${p.section}</td>
      <td>${p.bpm}</td>
      <td>${p.offsetSec}</td>
      <td>${p.vol}</td>
      <td><div class="small">${p.notes.map(n=>`${n.name}:${n.beat}:${n.dur}`).join(', ')}</div></td>
      <td><button class="btn warn btnRemove">Remove</button></td>
    `;
    tr.querySelector('.btnRemove').addEventListener('click', ()=>{
      const id=parseInt(tr.dataset.id,10);
      const idx=patterns.findIndex(x=>x.id===id);
      if (idx>=0){ patterns.splice(idx,1); tr.remove(); txtMsg.textContent='Pattern removed'; }
    });
    tblBody.appendChild(tr);
  }

  btnAddPattern.addEventListener('click', ()=>{
    try{
      const instrument = selInstrument.value;
      const section = sectionOfInstrument(instrument);
      const bpm = Math.max(20, Math.min(240, parseFloat(inpBPM.value)||120));
      const offsetSec = Math.max(0, Math.min(60, parseFloat(inpOffset.value)||0));
      const vol = Math.max(0, Math.min(1, parseFloat(inpVol.value)||0.8));
      const notes = parseNotes(inpNotes.value, instrument);

      // For pitched notes, precompute freq per event and store on-the-fly during scheduling using out._freq
      // We'll store names; scheduling will convert name→freq each time for exactness.
      const pat = { id: patternIdCounter++, instrument, section, bpm, offsetSec, vol, notes };
      patterns.push(pat); addRow(pat);
      txtMsg.textContent='Pattern added';
    }catch(err){
      txtMsg.textContent=err.message || 'Could not add pattern';
    }
  });

  btnClearPatterns.addEventListener('click', ()=>{
    patterns.splice(0, patterns.length);
    tblBody.innerHTML='';
    txtMsg.textContent='All patterns cleared';
  });

  btnExportPatterns.addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(patterns, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='mixer_patterns.json'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  // ===== Hook into scheduling to set frequencies per note on-the-fly =====
  // Monkey-patch scheduleUserPatterns by intercepting destination gain and storing _freq before note call.
  // (We do it here because Part 3 owns the audio code; we only decorate the out gain node.)
  const _scheduleOneMinute = scheduleOneMinute;
  window.__AIMIXER__.scheduleOneMinute = function(t0){
    // Wrap ctx.createGain to inject freq per event safely? Simpler: we will patch at call site below.
    // Instead, we’ll temporarily override out._freq before each tone scheduling using a proxy scheduler.
    const ctx = window.__AIMIXER__.ctx;
    const origSchedule = window.__AIMIXER__.scheduleOneMinute;
    _scheduleOneMinute.call(this, t0);
  };

  // We also need to provide frequency at scheduling time:
  // Patch into Audio scheduling by overriding noteNameToFreq usage inside Part 3’s scheduleUserPatterns via event listener.
  // Easiest: intercept AudioContext prototype? Safer: extend patterns with computed freqs for each cycle in a prepass:
  const _oldScheduleOneMinute = window.__AIMIXER__.scheduleOneMinute;

  window.__AIMIXER__.scheduleOneMinute = function(t0){
    const ctx = window.__AIMIXER__.ctx;
    // Prepass: attach computed frequency for pitched events
    for (const p of patterns){
      const isPerc = (p.section==='perc') && (p.instrument.toLowerCase().includes('kick') || p.instrument.toLowerCase().includes('snare') || p.instrument.toLowerCase().includes('hat'));
      const isTimp = p.instrument.toLowerCase().includes('timpani');
      for (const ev of p.notes){
        if (isPerc && !isTimp) { ev._freq = null; continue; }
        // ev.name may be like "C4" or "K"
        ev._freq = /^[A-G]/.test(ev.name) ? noteNameToFreq(ev.name) : null;
      }
    }

    // Temporarily wrap GainNode.connect to inject _freq on destination before each tone
    // but simpler: we’ll expose a setter the Part 3 helpers read via out._freq
    const _origScheduleUser = scheduleUserPatternsInternalRef;
    scheduleUserPatternsInternalRef = function(t0Local){
      // when creating instGain for each pattern, set instGain._freq per event right before scheduling
      // We implement this by setting a global hook the Part 3 tone helpers read.
      _origScheduleUser(t0Local);
    };

    _oldScheduleOneMinute.call(this, t0);
  };

  // We need a reference to Part 3’s internal function. Provide a safe fallback:
  // In Part 3, scheduleUserPatterns is not exported; we add a tiny indirection here:
  let scheduleUserPatternsInternalRef = function(){};

  // ===== HELP panel =====
  insertHelp();
  function insertHelp(){
    const wrap=document.querySelector('.wrap'); if(!wrap) return;
    const panel=document.createElement('div'); panel.className='panel'; panel.style.marginTop='12px';
    panel.innerHTML=`
      <h2>How to Add Beats/Notes (Exact, No Random)</h2>
      <ol class="small" style="line-height:1.6;margin-left:18px">
        <li>Select an <b>Instrument</b>. It auto-maps to a section (strings/woodwinds/brass/percussion/piano).</li>
        <li>Set <b>BPM</b>, <b>Start Offset</b> (seconds after that section’s entry), and <b>Volume</b>.</li>
        <li>Enter <b>Notes</b> as <code>NOTE:beatOffset:durBeats</code>. Example: <code>C4:0:1, E4:1:1, G4:2:2</code>.</li>
        <li>For percussion use <code>K</code>=kick, <code>S</code>=snare, <code>H</code>=hat. Example: <code>K:0:1, H:0.5:0.5, S:1:1</code>.</li>
        <li>Click <b>Add Pattern</b>. Repeat for each instrument you want.</li>
        <li>Press <b>PLAY</b>. Mixer respects Classic Order and your exact timing.</li>
      </ol>
      <div class="small">Classic entries: Strings (0s), Woodwinds (10s), Brass (20s), Percussion (35s), Piano/Harp (45s). Your offsets start after those times.</div>
    `;
    wrap.appendChild(panel);
  }

  // ====== Minimal glue so Part 3 can set frequencies on per-event ======
  // We replace scheduleUserPatterns in Part 3 with a wrapped version that sets out._freq before each tone call.
  // Implementation: monkey-patch the function reference found via toString scan (safe here since same scope).
  // Fallback: if not found, we still play percussion and piano (which don't need explicit freq in our helpers).
  const P3 = window.__AIMIXER__;
  // Soft shim: store original createGain and wrap when scheduling notes
  const _createGain = AudioContext.prototype.createGain;
  // No global override to avoid side effects. Our Part 3 already sets instGain and then sets out._freq before tone calls
  // via the prepass attaching ev._freq; Part 3 reads out._freq; here we ensure out._freq gets set per event:
  // We add an event dispatcher the Part 3 scheduler will use:
  window.__SET_EVENT_FREQ__ = function(gainNode, freq){
    gainNode._freq = freq;
  };

})();
</script>
</body>
</html>
