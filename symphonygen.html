<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST — Dual Key Analyzer (60s) + Built-in GM Synth (Real-time Scheduler)</title>
<style>
  :root{
    --bg:#0a0f1f; --ink:#eaf1ff; --muted:#a8b7e3; --panel:#121a33; --line:#6ee7ff; --ok:#10b981; --warn:#f59e0b;
    --grid:#1b254b; --accent:#3b82f6; --danger:#ef4444; --white:#ffffff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid var(--grid);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:18px;margin:0}
  main{max-width:1240px;margin:0 auto;padding:16px;display:grid;grid-template-columns:380px 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:12px;padding:14px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="file"],button,select,input[type="range"]{width:100%;padding:10px;border-radius:10px;border:1px solid var(--grid);background:#0e1733;color:var(--ink)}
  button{cursor:pointer;background:linear-gradient(180deg,#15245a,#0f1b45)}
  button:hover{filter:brightness(1.06)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px dashed var(--grid);border-radius:10px;margin-top:8px}
  .stat b{color:var(--ok)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;white-space:pre;line-height:1.42}
  .scroller{max-height:300px;overflow:auto;border:1px solid var(--grid);border-radius:10px;padding:8px;background:#0c1430}
  canvas{width:100%;height:220px;background:#0c1430;border:1px solid #22306b;border-radius:10px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#0f1c44;border:1px solid var(--grid);font-size:12px;color:var(--muted)}
  .hr{height:1px;background:linear-gradient(90deg,transparent,#2a3a7a,transparent);margin:12px 0}
  .danger{background:#3b1220;border-color:#6b1f35}
  .whiteSquare{width:100%; height:40px; background:var(--white); color:#000; display:flex; align-items:center; justify-content:center;
    border-radius:8px; border:2px solid #ddd; cursor:pointer; user-select:none;}
  .whiteSquare.active{outline:3px solid #4f8cff; font-weight:700}
  .gmGrid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
  .gmItem{border:1px solid var(--grid);border-radius:10px;padding:8px;background:#0b1738;cursor:pointer}
  .gmItem:hover{filter:brightness(1.08)}
  .gmItem .name{font-size:12px;color:#cfe1ff}
  .gmItem .num{font-weight:700;color:#9ad1ff}
  .gmItem .cnt{font-size:12px;color:#9ee6c9}
  .panelTitle{display:flex;align-items:center;justify-content:space-between}
  .btnRow{display:flex;gap:10px;flex-wrap:wrap}
  #status{font-size:12px;color:#9ad1ff;margin-top:8px}
</style>
</head>
<body>
<header>
  <h1>CST — Dual Key Analyzer (60s) + Built-in GM Synth</h1>
  <span class="pill">No downloads • Real-time scheduling • Full-minute playback</span>
</header>

<main>
  <!-- LEFT: Controls & Dual Analyzer -->
  <section class="card">
    <label>Song A — Audio file (MP3/WAV/AAC/OGG)</label>
    <input id="fileA" type="file" accept=".mp3,.wav,.m4a,.aac,.ogg" />
    <div class="row" style="margin-top:10px">
      <button id="analyzeA">Analyze A (first 60s)</button>
      <div class="stat"><span>Key A</span><b id="keyA">–</b></div>
    </div>
    <div class="row">
      <div class="stat"><span>Frames A</span><b id="framesA">–</b></div>
      <div class="stat"><span>BPM A</span><b id="bpmA">–</b></div>
    </div>

    <div class="hr"></div>

    <label>Song B — Audio file (MP3/WAV/AAC/OGG)</label>
    <input id="fileB" type="file" accept=".mp3,.wav,.m4a,.aac,.ogg" />
    <div class="row" style="margin-top:10px">
      <button id="analyzeB">Analyze B (first 60s)</button>
      <div class="stat"><span>Key B</span><b id="keyB">–</b></div>
    </div>
    <div class="row">
      <div class="stat"><span>Frames B</span><b id="framesB">–</b></div>
      <div class="stat"><span>BPM B</span><b id="bpmB">–</b></div>
    </div>

    <div class="hr"></div>
    <div>
      <label>Speed (playback spacing)</label>
      <div class="row">
        <div class="whiteSquare" data-speed="0.8">Slow (0.8×)</div>
        <div class="whiteSquare active" data-speed="1.0">Medium (1.0×)</div>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="whiteSquare" data-speed="1.25">Fast (1.25×)</div>
        <div class="whiteSquare" data-speed="1.5">Very Fast (1.5×)</div>
      </div>
      <div class="row" style="margin-top:10px">
        <div>
          <label>Mix A</label>
          <input id="mixA" type="range" min="0" max="1" step="0.01" value="0.85"/>
        </div>
        <div>
          <label>Mix B</label>
          <input id="mixB" type="range" min="0" max="1" step="0.01" value="0.70"/>
        </div>
      </div>
      <div style="margin-top:8px">
        <label>Master Volume</label>
        <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.75"/>
      </div>
      <div style="margin-top:8px">
        <label style="font-size:12px;color:#a8b7e3"><input id="snapScale" type="checkbox" checked/> Snap detected notes to detected key</label>
      </div>
    </div>

    <div class="hr"></div>
    <div class="btnRow">
      <button id="playBtn">Play (60s)</button>
      <button id="stopBtn" class="danger">Stop</button>
      <button id="resetBtn">Reset</button>
    </div>
    <div id="status">Ready.</div>
  </section>

  <!-- RIGHT: Visuals -->
  <section class="card">
    <label>Piano-roll (Song A + B, time → note)</label>
    <canvas id="roll" width="960" height="240"></canvas>

    <div class="row" style="margin-top:8px">
      <div>
        <label>Preview (A+B) — time, dominant, bass</label>
        <div id="previewList" class="scroller mono"></div>
      </div>
      <div>
        <label>Pitch-class histogram — A</label>
        <div id="histA" class="scroller mono" style="min-height:120px"></div>
      </div>
    </div>

    <div class="hr"></div>
    <div class="panelTitle">
      <label style="margin:0">All GM Instruments (0–127)</label>
      <span class="pill" id="selInfo">Counts update after analyze</span>
    </div>
    <div id="gmGrid" class="gmGrid" style="margin-top:8px"></div>
  </section>
</main>

<script>
/* ========= Helpers ========= */
const NOTE_NAMES=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const MAJOR=[0,2,4,5,7,9,11], MINOR=[0,2,3,5,7,8,10];
function hzToMidi(hz){ return 69 + 12*Math.log2(hz/440); }
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function midiToName(m){ const n=Math.round(m); return NOTE_NAMES[(n%12+12)%12]+(Math.floor(n/12)-1); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function median(vals){ const s=[...vals].sort((a,b)=>a-b); const n=s.length; return n? (n%2? s[(n-1)/2] : 0.5*(s[n/2-1]+s[n/2])):0; }
function keyPc(name){ return NOTE_NAMES.indexOf(name.split(" ")[0]); }
function keyScalePcs(keyName){ const tonic=keyPc(keyName); if (tonic<0) return null; const isMinor=keyName.toLowerCase().includes("minor"); const base=isMinor?MINOR:MAJOR; return base.map(pc=>(pc+tonic+120)%12); }
function snapToScale(midi, pcs){
  if (!pcs) return Math.round(midi);
  const pc=((Math.round(midi)%12)+12)%12;
  if (pcs.includes(pc)) return Math.round(midi);
  for (const d of [1,-1,2,-2]){ const cand=((pc+d)+12)%12; if (pcs.includes(cand)) return Math.round(midi)+d; }
  return Math.round(midi);
}

/* ========= GM labels (UI text only) ========= */
function GMLabel(p){
  const names=[
"0 Acoustic Grand Piano","1 Bright Acoustic Piano","2 Electric Grand Piano","3 Honky-tonk Piano","4 Rhodes Piano","5 Chorused Piano","6 Harpsichord","7 Clavinet",
"8 Celesta","9 Glockenspiel","10 Music Box","11 Vibraphone","12 Marimba","13 Xylophone","14 Tubular Bells","15 Dulcimer",
"16 Hammond Organ","17 Percussive Organ","18 Rock Organ","19 Church Organ","20 Reed Organ","21 Accordion","22 Harmonica","23 Tango Accordion",
"24 Acoustic Nylon Guitar","25 Acoustic Steel Guitar","26 Electric Jazz Guitar","27 Electric Clean Guitar","28 Electric Muted Guitar","29 Overdriven Guitar","30 Distortion Guitar","31 Guitar Harmonics",
"32 Acoustic Bass","33 Electric Bass (Finger)","34 Electric Bass (Pick)","35 Fretless Bass","36 Slap Bass 1","37 Slap Bass 2","38 Synth Bass 1","39 Synth Bass 2",
"40 Violin","41 Viola","42 Cello","43 Contrabass","44 Tremolo Strings","45 Pizzicato Strings","46 Orchestral Harp","47 Timpani",
"48 String Ensemble 1","49 String Ensemble 2","50 Synth Strings 1","51 Synth Strings 2","52 Choir Aahs","53 Voice Oohs","54 Synth Voice","55 Orchestral Hit",
"56 Trumpet","57 Trombone","58 Tuba","59 Muted Trumpet","60 French Horn","61 Brass Section","62 Synth Brass 1","63 Synth Brass 2",
"64 Soprano Sax","65 Alto Sax","66 Tenor Sax","67 Baritone Sax","68 Oboe","69 English Horn","70 Bassoon","71 Clarinet",
"72 Piccolo","73 Flute","74 Recorder","75 Pan Flute","76 Bottle Blow","77 Shakuhachi","78 Whistle","79 Ocarina",
"80 Square Lead","81 Saw Lead","82 Calliope Lead","83 Chiff Lead","84 Charang Lead","85 Voice Lead","86 Fifths Lead","87 Bass Lead",
"88 New Age Pad","89 Warm Pad","90 Polysynth Pad","91 Choir Pad","92 Bowed Pad","93 Metallic Pad","94 Halo Pad","95 Sweep Pad",
"96 Rain","97 Soundtrack","98 Crystal","99 Atmosphere","100 Brightness","101 Goblins","102 Echoes","103 Sci-Fi",
"104 Sitar","105 Banjo","106 Shamisen","107 Koto","108 Kalimba","109 Bagpipe","110 Fiddle","111 Shanai",
"112 Tinkle Bell","113 Agogo","114 Steel Drums","115 Woodblock","116 Taiko Drum","117 Melodic Tom","118 Synth Drum","119 Reverse Cymbal",
"120 Guitar Fret Noise","121 Breath Noise","122 Seashore","123 Bird Tweet","124 Telephone Ring","125 Helicopter","126 Applause","127 Gun Shot"
]; return names[p]||(`#${p}`); }

/* ========= UI refs ========= */
const fileA=document.getElementById('fileA'), fileB=document.getElementById('fileB');
const analyzeA=document.getElementById('analyzeA'), analyzeB=document.getElementById('analyzeB');
const keyAEl=document.getElementById('keyA'), keyBEl=document.getElementById('keyB');
const framesAEl=document.getElementById('framesA'), framesBEl=document.getElementById('framesB');
const bpmAEl=document.getElementById('bpmA'), bpmBEl=document.getElementById('bpmB');
const histAEl=document.getElementById('histA');
const roll=document.getElementById('roll'), rc=roll.getContext('2d');
const previewList=document.getElementById('previewList');
const gmGrid=document.getElementById('gmGrid'), selInfo=document.getElementById('selInfo');
const speedSquares=[...document.querySelectorAll('.whiteSquare')];
const playBtn=document.getElementById('playBtn'), stopBtn=document.getElementById('stopBtn'), resetBtn=document.getElementById('resetBtn');
const snapScaleEl=document.getElementById('snapScale'), mixAEl=document.getElementById('mixA'), mixBEl=document.getElementById('mixB'), masterVolEl=document.getElementById('masterVol');
const statusEl=document.getElementById('status');

/* ========= Analyzer core ========= */
const KS_MAJOR=[6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
const KS_MINOR=[6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];
function correlateKey(h){
  function norm(v){ const n=Math.hypot(...v); return v.map(x=>x/(n||1)); }
  const hh=norm(h); let best={name:"–",score:-1};
  for(let r=0;r<12;r++){
    const cm=KS_MAJOR.map((v,i)=>v*hh[(i+r)%12]).reduce((a,b)=>a+b,0);
    const cn=KS_MINOR.map((v,i)=>v*hh[(i+r)%12]).reduce((a,b)=>a+b,0);
    if (cm>best.score) best={name:`${NOTE_NAMES[r]} major`,score:cm};
    if (cn>best.score) best={name:`${NOTE_NAMES[r]} minor`,score:cn};
  }
  return best.name;
}
function zeroCrossPitch(frame, sr){
  let crossings=0; for(let i=1;i<frame.length;i++){ if ((frame[i-1]<=0 && frame[i]>0) || (frame[i-1]>=0 && frame[i]<0)) crossings++; }
  const freq = (crossings/2) * (sr/frame.length);
  return (freq>40 && freq<2000)? freq : 0;
}
function fftPitch(frame, sr){
  const N=frame.length, step=1;
  let bestF=0,bestP=0;
  for(let hz=60; hz<=1000; hz+=10){
    const w=2*Math.PI*hz/sr; let re=0, im=0;
    for(let n=0;n<N;n+=step){ const phi=w*n; re+=frame[n]*Math.cos(phi); im-=frame[n]*Math.sin(phi); }
    const p=re*re+im*im; if (p>bestP){ bestP=p; bestF=hz; }
  }
  return bestF||0;
}
function autocorrPitch(frame, sr){
  const N=frame.length;
  let mean=0; for(let i=0;i<N;i++) mean+=frame[i]; mean/=N;
  let maxAbs=0;
  for(let i=0;i<N;i++){ frame[i]=(frame[i]-mean)*(0.5-0.5*Math.cos(2*Math.PI*i/(N-1))); maxAbs=Math.max(maxAbs,Math.abs(frame[i])); }
  const clip=0.25*maxAbs;
  if (clip>0){ for(let i=0;i<N;i++){ if (frame[i]> clip) frame[i]-=clip; else if (frame[i]<-clip) frame[i]+=clip; } }
  const minF=50,maxF=1000,minLag=Math.floor(sr/maxF),maxLag=Math.floor(sr/minF); let bestLag=0,best=0;
  for(let lag=minLag; lag<=Math.min(maxLag,N-3); lag++){ let s=0; for(let i=0;i<N-lag;i++) s+=frame[i]*frame[i+lag]; if (s>best){best=s; bestLag=lag;} }
  if (bestLag>0){
    const l=bestLag; const c1=acf(frame,l-1), c2=acf(frame,l), c3=acf(frame,l+1); const denom=(c1-2*c2+c3);
    const shift = denom!==0 ? 0.5*(c1-c3)/denom : 0; const refined=l+shift; const f=sr/refined;
    if (isFinite(f)&&f>20&&f<2000) return f;
  }
  return 0;
  function acf(x,lag){ if (lag<1||lag>=x.length) return 0; let s=0; for(let i=0;i<x.length-lag;i++) s+=x[i]*x[i+lag]; return s; }
}
function estimateBPM(onsets, sr){
  if (onsets.length<3) return 100;
  const diffs=[]; for(let i=1;i<onsets.length;i++){ const dt=(onsets[i]-onsets[i-1])/sr; if (dt>0.18&&dt<2.2) diffs.push(dt); }
  if (!diffs.length) return 100;
  const med=diffs.sort((a,b)=>a-b)[Math.floor(diffs.length/2)];
  let bpm=Math.round(60/med);
  while (bpm<60) bpm*=2; while (bpm>180) bpm=Math.round(bpm/2);
  return bpm;
}

/* ========= State ========= */
let A={events:[], pclass:new Float32Array(12), key:"–", bpm:100};
let B={events:[], pclass:new Float32Array(12), key:"–", bpm:100};
let routed=initRouted(); let selectedProg=40;
function initRouted(){ const m=new Map(); for(let p=0;p<128;p++) m.set(p,[]); return m; }

/* ========= Visuals ========= */
function drawHist(el,h){
  const tot=Array.from(h).reduce((a,b)=>a+b,0)||1; let out="PC  %\n";
  for(let i=0;i<12;i++){ const pct=(h[i]/tot*100).toFixed(1).padStart(5,' '); out+=`${NOTE_NAMES[i].padEnd(2,' ')} ${pct}%\n`; }
  el.textContent=out;
}
function drawRoll(){
  const w=roll.width,h=roll.height; rc.clearRect(0,0,w,h);
  rc.strokeStyle="rgba(110,231,255,0.25)"; for(let i=0;i<=10;i++){ const x=(i/10)*w; rc.beginPath(); rc.moveTo(x,0); rc.lineTo(x,h); rc.stroke(); }
  const minM=36,maxM=84,span=maxM-minM; const yy=m=>h-((m-minM)/span)*h;
  A.events.forEach(e=>{ if(e.m){ const x=(e.t/60)*w; rc.fillStyle="rgba(110,231,255,0.9)"; rc.fillRect(x,yy(e.m)-3,3,6);} if(e.b){ const x=(e.t/60)*w; rc.fillStyle="rgba(16,185,129,0.9)"; rc.fillRect(x,yy(e.b)-4,4,8);} });
  B.events.forEach(e=>{ if(e.m){ const x=(e.t/60)*w; rc.fillStyle="rgba(255,206,86,0.9)"; rc.fillRect(x,yy(e.m)-2,2,4);} if(e.b){ const x=(e.t/60)*w; rc.fillStyle="rgba(255,99,132,0.9)"; rc.fillRect(x,yy(e.b)-3,3,6);} });
}
function renderGMGrid(){
  gmGrid.innerHTML="";
  for(let p=0;p<128;p++){
    const d=document.createElement('div'); d.className="gmItem";
    const cnt=routed.get(p).length;
    d.innerHTML=`<div class="num">#${p}</div><div class="name">${GMLabel(p)}</div><div class="cnt">notes: ${cnt}</div>`;
    d.onclick=()=>{ selectedProg=p; selInfo.textContent=`Instrument #${p} — ${GMLabel(p)} — notes routed: ${cnt}`; };
    gmGrid.appendChild(d);
  }
  selInfo.textContent="Click any tile to see its routed note count.";
}
function renderNotePreview(){
  const lines=[" time     DOM_A   BASS_A    DOM_B   BASS_B"];
  const n=Math.max(A.events.length,B.events.length);
  for(let i=0;i<n;i++){
    const a=A.events[i]||{}, b=B.events[i]||{};
    const t=((a.t??b.t??0)).toFixed(2).padStart(6,' ');
    const ad=a.m?midiToName(a.m).padEnd(5,' '):" --  "; const ab=a.b?midiToName(a.b).padEnd(5,' '):" --  ";
    const bd=b.m?midiToName(b.m).padEnd(5,' '):" --  "; const bb=b.b?midiToName(b.b).padEnd(5,' '):" --  ";
    lines.push(`${t}s   ${ad}   ${ab}    ${bd}   ${bb}`); if (lines.length>400) break;
  }
  previewList.textContent=lines.join("\n");
}

/* ========= WebAudio Core (built-in synth) ========= */
let AUDIO={ctx:null, master:null, comp:null, speed:1.0};
function ensureAudio(){
  if (!AUDIO.ctx){
    const ctx=new (window.AudioContext||window.webkitAudioContext)();
    const comp=ctx.createDynamicsCompressor(); comp.threshold.value=-18; comp.knee.value=9; comp.ratio.value=3; comp.attack.value=0.005; comp.release.value=0.25;
    const master=ctx.createGain(); master.gain.value=parseFloat(masterVolEl.value||"0.75");
    comp.connect(master); master.connect(ctx.destination);
    AUDIO.ctx=ctx; AUDIO.comp=comp; AUDIO.master=master;
  }
  AUDIO.master.gain.value=parseFloat(masterVolEl.value||"0.75");
  return AUDIO.ctx;
}
async function resumeAudio(){
  const ctx=ensureAudio();
  if (ctx.state === 'suspended') { try { await ctx.resume(); } catch(e){} }
  return ctx;
}

/* Lightweight instrument preset */
function presetFor(program, midi, isBass){
  if (isBass || midi<=52) return {wave:'sawtooth', lpHz:420, q:0.9, a:0.004, d:0.06, s:0.6, r:0.08, vib:0};
  if (program>=40 && program<=49) return {wave:'triangle', lpHz:2600, q:0.7, a:0.008, d:0.18, s:0.7, r:0.2, vib:4.5};
  if (program>=56 && program<=63) return {wave:'square', lpHz:1800, q:0.8, a:0.003, d:0.14, s:0.55, r:0.13, vib:3.0};
  if (program>=68 && program<=79) return {wave:'sine', lpHz:2400, q:0.6, a:0.004, d:0.10, s:0.65, r:0.14, vib:5.5};
  if (program<=7) return {wave:'triangle', lpHz:3200, q:0.7, a:0.003, d:0.12, s:0.65, r:0.08, vib:0.6};
  if (program>=48 && program<=55) return {wave:'triangle', lpHz:2600, q:0.8, a:0.006, d:0.22, s:0.7, r:0.25, vib:0.7};
  return {wave:'sawtooth', lpHz:2200, q:0.9, a:0.004, d:0.16, s:0.6, r:0.18, vib:0.4};
}
function startNote(program, midi, when, dur, gainVal, isBass){
  const ctx=ensureAudio();
  const f=midiToHz(midi);
  const p=presetFor(program, midi, isBass);

  const osc=ctx.createOscillator(); osc.type=p.wave; osc.frequency.setValueAtTime(f, when);
  if (p.vib>0){
    const lfo=ctx.createOscillator(); const lfoGain=ctx.createGain();
    lfo.type='sine'; lfo.frequency.setValueAtTime(5.2, when); lfoGain.gain.setValueAtTime(p.vib, when);
    lfo.connect(lfoGain); lfoGain.connect(osc.frequency); lfo.start(when); lfo.stop(when+dur+p.r+0.3);
  }
  const biq=ctx.createBiquadFilter(); biq.type='lowpass';
  const baseCut=p.lpHz * Math.min(1.8, Math.max(0.6, midi/80));
  biq.frequency.setValueAtTime(baseCut, when); biq.Q.setValueAtTime(p.q, when);

  const amp=ctx.createGain();
  const a=p.a, d=p.d, s=p.s, r=p.r;
  amp.gain.setValueAtTime(0, when);
  amp.gain.linearRampToValueAtTime(gainVal, when+a);
  amp.gain.linearRampToValueAtTime(gainVal*s, when+a+d);
  amp.gain.setValueAtTime(gainVal*s, when+dur);
  amp.gain.linearRampToValueAtTime(0.0005, when+dur+r);

  osc.connect(biq); biq.connect(amp); amp.connect(AUDIO.comp);

  osc.start(when);
  osc.stop(when+dur+r+0.05);
}

/* ========= Routing rules ========= */
function routeEvent(t,midi,isBass,src){
  function push(p){ routed.get(p).push({t, midi, src}); }
  if (isBass || midi<=52){ [32].forEach(push); return; }            // single program to reduce CPU
  if (midi>=53 && midi<=72){ [41].forEach(push); return; }          // viola midrange
  [40].forEach(push);                                               // violin for highs
}
function rerouteAll(){
  routed=initRouted();
  A.events.forEach(ev=>{ if(ev.m) routeEvent(ev.t,ev.m,false,'A'); if(ev.b) routeEvent(ev.t,ev.b,true,'A'); });
  B.events.forEach(ev=>{ if(ev.m) routeEvent(ev.t,ev.m,false,'B'); if(ev.b) routeEvent(ev.t,ev.b,true,'B'); });
}

/* ========= Build schedule (quantize + density cap) ========= */
function buildSchedule(){
  const sch=[];
  function addSide(side){
    const evs=(side==='A'?A.events:B.events);
    const bpm=(side==='A'?A.bpm:B.bpm)||100;
    const spb=60/bpm, grid=Math.max(0.1, spb/4);
    const lastByPitch=new Map();
    let perSecond=0, lastSec=-1;
    for (const e of evs){
      if (!e.m && !e.b) continue;
      const tQ=Math.max(0,Math.min(60,Math.round(e.t/grid)*grid));
      const sec=Math.floor(tQ);
      if (sec!==lastSec){ perSecond=0; lastSec=sec; }
      const add=(m,isBass)=>{
        if (!m) return;
        const last=lastByPitch.get(m)||-999;
        if (tQ-last<0.06) return;
        if (perSecond>14) return; // hard cap events/sec to keep CPU low
        lastByPitch.set(m,tQ); perSecond++;
        sch.push({t:tQ, midi:Math.round(m), src:side, isBass});
      };
      add(e.m,false); add(e.b,true);
    }
  }
  addSide('A'); addSide('B');
  return sch.filter(x=>x.t>=0&&x.t<60).sort((a,b)=>a.t-b.t);
}

/* ========= One program per note ========= */
function programFor(midi,isBass){
  if (isBass || midi<=52) return 32;      // acoustic bass
  if (midi>=53 && midi<=72) return 41;    // viola
  return 40;                              // violin
}

/* ========= Real-time scheduler (fixes 3s playback cutoff) ========= */
let playing=false, sch=[], schIndex=0, schedTimer=null, startAudio=0, startPerf=0;
const LOOKAHEAD=0.25;           // seconds of audio time to schedule ahead
const TICK_MS=25;               // scheduler tick

function schedulerTick(){
  const ctx=AUDIO.ctx;
  const speed=AUDIO.speed||1.0;
  const nowA=ctx.currentTime;
  const horizon=nowA + LOOKAHEAD;

  while (schIndex<sch.length){
    const e=sch[schIndex];
    const when = startAudio + (e.t)*(1/speed);
    if (when > horizon) break;

    const dur = (e.midi<=52? 0.55:0.35) * (1/speed);
    const mixA=parseFloat(mixAEl.value||"0.85"), mixB=parseFloat(mixBEl.value||"0.7");
    const vel = (e.midi<=52? 0.95:0.80) * (e.src==='A'? mixA : mixB);
    startNote(programFor(e.midi,e.isBass), e.midi, when, dur, vel, e.isBass);
    schIndex++;
  }

  // stop when finished
  if (schIndex>=sch.length){
    clearInterval(schedTimer); schedTimer=null; playing=false;
    status("Finished.");
  }
}

async function play(){
  await resumeAudio();
  stopPlayback(); // clear any previous run

  sch=buildSchedule();
  if (!sch.length){
    status("No detected notes; generating fallback…");
    const fb=generateFallback(); A.events=fb.A; B.events=fb.B;
    rerouteAll(); drawRoll(); renderGMGrid(); renderNotePreview();
    sch=buildSchedule();
  }
  if (!sch.length){ status("Still no notes."); alert("No notes yet. Analyze A and/or B first."); return; }

  playing=true; schIndex=0;
  const ctx=AUDIO.ctx;
  startAudio=ctx.currentTime + 0.06;
  startPerf=performance.now()/1000;

  // start scheduler
  schedTimer=setInterval(schedulerTick, TICK_MS);
  status("Playing…");
}
function stopPlayback(){
  if (schedTimer){ clearInterval(schedTimer); schedTimer=null; }
  playing=false; schIndex=sch.length;
  status("Stopped.");
}

/* ========= Fallback generator ========= */
function generateFallback(){
  function build(side){
    const key = (side==='A'?A.key:B.key);
    const pcs = keyScalePcs(key) || MAJOR;
    const tonicPc = pcs[0];
    const tonicMidi = 60 + tonicPc;         // C4-based tonic
    const bassTonic = 36 + tonicPc;         // C2-based tonic
    const bpm = (side==='A'?A.bpm:B.bpm)||100;
    const spb = 60/bpm;
    const grid = Math.max(0.125, spb/2);    // 1/8 baseline
    const out=[];
    for (let t=0; t<60; t+=grid){
      const step = Math.floor((t/grid)) % pcs.length;
      const m = tonicMidi + (pcs[step] - tonicPc);
      const b = (step%2===0)? bassTonic : bassTonic+5;
      out.push({t, m, b});
    }
    return out;
  }
  return { A: build('A'), B: build('B') };
}

/* ========= Analysis (3-stage pitch + guaranteed content) ========= */
async function analyze(file, side){
  if (!file){ alert(`Choose audio for Song ${side}.`); return; }
  const arrBuf=await file.arrayBuffer();

  const liveCtx=new (window.AudioContext||window.webkitAudioContext)();
  let buf; try{ buf=await liveCtx.decodeAudioData(arrBuf.slice(0)); } catch(e){ alert("Could not decode audio."); return; }
  const sr=buf.sampleRate, ch=buf.numberOfChannels, mono=new Float32Array(buf.length);
  for(let c=0;c<ch;c++){ const d=buf.getChannelData(c); for(let i=0;i<d.length;i++) mono[i]=(mono[i]||0)+d[i]/ch; }

  const frame=4096, hop=2048, total=mono.length, maxS=Math.min(total,Math.floor(sr*60));
  const out=[], pclass=new Float32Array(12), onsets=[];
  let prevE=0;

  for(let st=0; st+frame<=maxS; st+=hop){
    const fr=mono.subarray(st,st+frame).slice();
    let E=0; for(let i=0;i<fr.length;i++) E+=fr[i]*fr[i];
    const dE=E-prevE; prevE=E; if (dE>0.08) onsets.push(st);

    let f0=autocorrPitch(fr.slice(),sr);
    if (!f0) f0=zeroCrossPitch(fr,sr);
    if (!f0) f0=fftPitch(fr,sr);

    let m=0,b=0;
    if (f0>0){
      m=clamp(Math.round(hzToMidi(f0)),24,96);
      if (f0<=220) b=clamp(Math.round(hzToMidi(f0)),28,72);
      if (m) pclass[((m%12)+12)%12]+=1;
    }
    out.push({t:st/sr, m, b});
  }

  // median smoothing
  function smooth(list,key){ const half=2; const arr=list.map(e=>e[key]||0), sm=[];
    for(let i=0;i<arr.length;i++){ const wnd=[]; for(let k=Math.max(0,i-half); k<=Math.min(arr.length-1,i+half); k++) if(arr[k]) wnd.push(arr[k]);
      sm[i]=wnd.length?Math.round(median(wnd)):0; }
    for(let i=0;i<list.length;i++) list[i][key]=sm[i];
  }
  smooth(out,'m'); smooth(out,'b');

  // key + snap
  const smh=new Float32Array(12);
  for(let i=0;i<12;i++){ const a=pclass[(i+11)%12], b_=pclass[i], c=pclass[(i+1)%12]; smh[i]=(a+2*b_+c)/4; }
  let keyName=correlateKey(Array.from(smh));
  if (keyName==="–") keyName="C major";
  const pcs=keyScalePcs(keyName);
  if (snapScaleEl.checked){ for (const e of out){ if(e.m) e.m=snapToScale(e.m,pcs); if(e.b) e.b=snapToScale(e.b,pcs); } }

  const bpm=estimateBPM(onsets,sr);

  // Guarantee content
  const meaningful = out.filter(e=>e.m||e.b).length;
  if (meaningful < 8){
    const fb = generateFallback();
    if (side==='A'){ A={events:fb.A, pclass, key:keyName, bpm}; }
    else{ B={events:fb.B, pclass, key:keyName, bpm}; }
  } else {
    if (side==='A'){ A={events:out, pclass, key:keyName, bpm}; }
    else{ B={events:out, pclass, key:keyName, bpm}; }
  }

  // UI updates
  if (side==='A'){ framesAEl.textContent=String(out.length); keyAEl.textContent=keyName; bpmAEl.textContent=`${bpm}`; drawHist(histAEl, A.pclass); }
  else{ framesBEl.textContent=String(out.length); keyBEl.textContent=keyName; bpmBEl.textContent=`${bpm}`; }

  rerouteAll(); drawRoll(); renderGMGrid(); renderNotePreview();
  status(`Analyzed ${side}.`);
}

/* ========= Wire up ========= */
analyzeA.onclick=()=>analyze(fileA.files?.[0],'A');
analyzeB.onclick=()=>analyze(fileB.files?.[0],'B');
speedSquares.forEach(sq=>{ sq.onclick=()=>{ speedSquares.forEach(x=>x.classList.remove('active')); sq.classList.add('active'); AUDIO.speed=parseFloat(sq.dataset.speed)||1.0; }; });
document.getElementById('masterVol').oninput=()=>{ ensureAudio(); AUDIO.master.gain.value=parseFloat(masterVolEl.value); };
mixAEl.oninput=()=>{ rerouteAll(); renderGMGrid(); };
mixBEl.oninput=()=>{ rerouteAll(); renderGMGrid(); };
playBtn.onclick=()=>play();
stopBtn.onclick=()=>stopPlayback();
resetBtn.onclick=()=>{
  stopPlayback();
  A={events:[],pclass:new Float32Array(12),key:"–",bpm:100};
  B={events:[],pclass:new Float32Array(12),key:"–",bpm:100};
  keyAEl.textContent='–'; keyBEl.textContent='–'; framesAEl.textContent='–'; framesBEl.textContent='–'; bpmAEl.textContent='–'; bpmBEl.textContent='–';
  histAEl.textContent=''; previewList.textContent='';
  routed=initRouted(); renderGMGrid(); drawRoll(); fileA.value=""; fileB.value="";
  status("Ready.");
};

/* ========= Init ========= */
(function init(){ renderGMGrid(); drawRoll(); AUDIO.speed=1.0; })();
</script>
</body>
</html>
