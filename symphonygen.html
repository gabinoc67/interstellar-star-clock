<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Orchestral Mixer — Classic Order (1-Minute)</title>
<meta name="description" content="A 1-minute, classic-order orchestral mixer: strings → woodwinds → brass → percussion → piano. Upload a beat, then layer sections with a fixed timeline."/>
<style>
  :root{
    --bg:#081022; --panel:#0f1636; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#1a2658; --btn:#15235a;
    --ok:#10b981; --warn:#f59e0b; --danger:#ef4444; --line:#6ee7ff; --accent:#93c5fd;
    --str:#8bc6ff; --ww:#b8ffda; --br:#ffd599; --pc:#ff9aa2; --pn:#d0b3ff;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 6px}
  .sub{color:var(--muted);font-size:13px;margin-bottom:16px}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:960px){.row{grid-template-columns:2fr 1fr}}

  .panel{background:var(--panel);border:1px solid var(--grid);border-radius:14px;padding:12px}
  .controls{display:grid;grid-template-columns:repeat(6, minmax(0,1fr));gap:8px;margin:8px 0}
  .controls button,.controls input[type="file"]{background:var(--btn);border:1px solid var(--grid);color:var(--ink);border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer}
  .controls button:disabled{opacity:.5;cursor:not-allowed}
  .small{font-size:12px;color:var(--muted)}
  .meters{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:10px}
  .chan{background:#0b1432;border:1px solid var(--grid);border-radius:12px;padding:10px}
  .chan h3{margin:0 0 6px;font-size:14px}
  .tag{font-size:11px;border-radius:999px;padding:2px 8px;display:inline-block;margin-left:6px;vertical-align:1px;border:1px solid var(--grid);color:var(--muted)}
  .volrow{display:flex;gap:8px;align-items:center}
  .volrow input[type="range"]{width:100%}
  .muterow{display:flex;gap:8px;margin-top:6px}
  .muterow button{flex:1}

  .legend{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
  .pill{border:1px solid var(--grid);border-radius:999px;padding:4px 10px;font-size:12px;display:flex;gap:8px;align-items:center}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.str{background:var(--str)} .dot.ww{background:var(--ww)} .dot.br{background:var(--br)} .dot.pc{background:var(--pc)} .dot.pn{background:var(--pn)}

  .timeline{height:68px;background:#0b1432;border:1px solid var(--grid);border-radius:12px;position:relative;margin-top:12px;overflow:hidden}
  .gridline{position:absolute;top:0;bottom:0;width:1px;background:#1a2658}
  .marker{position:absolute;top:0;bottom:0;width:2px;background:var(--line);box-shadow:0 0 10px var(--line)}
  .label{position:absolute;top:4px;font-size:10px;color:var(--muted)}
  .band{position:absolute;top:0;bottom:0;opacity:.14}
  .band.str{background:var(--str)} .band.ww{background:var(--ww)} .band.br{background:var(--br)} .band.pc{background:var(--pc)} .band.pn{background:var(--pn)}
  .status{display:flex;gap:10px;align-items:center;margin-top:6px}
  .lamp{width:10px;height:10px;border-radius:50%;background:#394b7a;box-shadow:0 0 0 0 transparent}
  .lamp.on{background:var(--ok);box-shadow:0 0 10px var(--ok)}
  .warn{color:var(--warn)}
  .err{color:var(--danger)}
</style>
</head>
<body>
<div class="wrap">
  <h1>AI Orchestral Mixer — Classic Order</h1>
  <div class="sub">Fixed 1-minute entrance timeline: <b>Strings (0s)</b> → <b>Woodwinds (10s)</b> → <b>Brass (20s)</b> → <b>Percussion (35s)</b> → <b>Piano (45s)</b>.</div>

  <div class="row">
    <!-- LEFT: Transport + Timeline -->
    <div class="panel">
      <div class="controls">
        <button id="btnPlay">PLAY</button>
        <button id="btnStop" disabled>STOP</button>
        <button id="btnReset">RESET</button>
        <input id="fileBeat" type="file" accept="audio/*"/>
        <button id="btnMetronome">Use Metronome</button>
        <button id="btnLoop" title="Loop after 60s">Loop Off</button>
      </div>
      <div class="small">Tip: upload your beat (e.g., <i>notesbeat.wav</i>). If none, press “Use Metronome”.</div>

      <div class="legend">
        <span class="pill"><span class="dot str"></span>Strings @ 0s</span>
        <span class="pill"><span class="dot ww"></span>Woodwinds @ 10s</span>
        <span class="pill"><span class="dot br"></span>Brass @ 20s</span>
        <span class="pill"><span class="dot pc"></span>Percussion @ 35s</span>
        <span class="pill"><span class="dot pn"></span>Piano @ 45s</span>
      </div>

      <div class="timeline" id="timeline">
        <!-- Bands (section active windows) injected by JS -->
        <!-- Grid & labels injected by JS -->
        <div class="marker" id="playhead" style="left:0%"></div>
      </div>

      <div class="status">
        <div class="lamp" id="lampAudio"></div><span class="small">Audio Engine</span>
        <div class="lamp" id="lampBeat"></div><span class="small">Beat Loaded</span>
        <div class="lamp" id="lampPlaying"></div><span class="small">Playing</span>
        <span class="small" id="txtTime">t = 0.0s</span>
        <span class="small" id="txtMsg"></span>
      </div>
    </div>

    <!-- RIGHT: Mixer Channels -->
    <div class="panel">
      <div class="meters">
        <div class="chan">
          <h3>Strings <span class="tag">0–60s</span></h3>
          <div class="volrow"><label class="small">Vol</label><input id="volStrings" type="range" min="0" max="1" step="0.01" value="0.8"/></div>
          <div class="muterow">
            <button id="muteStrings">Mute</button>
            <button id="soloStrings">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Woodwinds <span class="tag">10–60s</span></h3>
          <div class="volrow"><label class="small">Vol</label><input id="volWoodwinds" type="range" min="0" max="1" step="0.01" value="0.7"/></div>
          <div class="muterow">
            <button id="muteWoodwinds">Mute</button>
            <button id="soloWoodwinds">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Brass <span class="tag">20–60s</span></h3>
          <div class="volrow"><label class="small">Vol</label><input id="volBrass" type="range" min="0" max="1" step="0.01" value="0.65"/></div>
          <div class="muterow">
            <button id="muteBrass">Mute</button>
            <button id="soloBrass">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Percussion <span class="tag">35–60s</span></h3>
          <div class="volrow"><label class="small">Vol</label><input id="volPerc" type="range" min="0" max="1" step="0.01" value="0.75"/></div>
          <div class="muterow">
            <button id="mutePerc">Mute</button>
            <button id="soloPerc">Solo</button>
          </div>
        </div>
        <div class="chan">
          <h3>Piano <span class="tag">45–60s</span></h3>
          <div class="volrow"><label class="small">Vol</label><input id="volPiano" type="range" min="0" max="1" step="0.01" value="0.7"/></div>
          <div class="muterow">
            <button id="mutePiano">Mute</button>
            <button id="soloPiano">Solo</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
(() => {
  // ------ Constants ------
  const DURATION = 60; // seconds
  const CLASSIC_ORDER = [
    { key:'strings',   start: 0,  color:'var(--str)'},
    { key:'woodwinds', start:10,  color:'var(--ww)'},
    { key:'brass',     start:20,  color:'var(--br)'},
    { key:'perc',      start:35,  color:'var(--pc)'},
    { key:'piano',     start:45,  color:'var(--pn)'},
  ];

  // ------ State ------
  let ctx = null;
  let master = null;
  let startTime = 0;          // audioContext time at PLAY
  let timer = null;           // UI interval
  let isPlaying = false;
  let loopEnabled = false;

  // Beat buffer / metronome flag
  let beatBuffer = null;
  let beatGain = null;
  let usingMetronome = false;

  // Solo/mute
  const channel = {
    strings: {gain:null, muted:false, solo:false},
    woodwinds:{gain:null, muted:false, solo:false},
    brass:{gain:null, muted:false, solo:false},
    perc:{gain:null, muted:false, solo:false},
    piano:{gain:null, muted:false, solo:false},
  };

  // ------ Elements ------
  const lampAudio = document.getElementById('lampAudio');
  const lampBeat = document.getElementById('lampBeat');
  const lampPlaying = document.getElementById('lampPlaying');
  const txtTime = document.getElementById('txtTime');
  const txtMsg = document.getElementById('txtMsg');
  const playhead = document.getElementById('playhead');
  const timeline = document.getElementById('timeline');

  const btnPlay = document.getElementById('btnPlay');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnMetronome = document.getElementById('btnMetronome');
  const btnLoop = document.getElementById('btnLoop');
  const fileBeat = document.getElementById('fileBeat');

  // Volume sliders
  const volEls = {
    strings: document.getElementById('volStrings'),
    woodwinds: document.getElementById('volWoodwinds'),
    brass: document.getElementById('volBrass'),
    perc: document.getElementById('volPerc'),
    piano: document.getElementById('volPiano'),
  };

  // Mute/Solo
  const bindMuteSolo = (key, muteBtnId, soloBtnId) => {
    document.getElementById(muteBtnId).onclick = () => {
      channel[key].muted = !channel[key].muted;
      document.getElementById(muteBtnId).textContent = channel[key].muted ? 'Unmute' : 'Mute';
      applyGains();
    };
    document.getElementById(soloBtnId).onclick = () => {
      channel[key].solo = !channel[key].solo;
      document.getElementById(soloBtnId).textContent = channel[key].solo ? 'Unsolo' : 'Solo';
      applyGains();
    };
  };
  bindMuteSolo('strings','muteStrings','soloStrings');
  bindMuteSolo('woodwinds','muteWoodwinds','soloWoodwinds');
  bindMuteSolo('brass','muteBrass','soloBrass');
  bindMuteSolo('perc','mutePerc','soloPerc');
  bindMuteSolo('piano','mutePiano','soloPiano');

  // ------ Init Audio Graph ------
  function ensureAudio() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    // Create per-channel gains
    for (const k of Object.keys(channel)) {
      const g = ctx.createGain();
      g.gain.value = parseFloat(volEls[k].value);
      g.connect(master);
      channel[k].gain = g;
      volEls[k].addEventListener('input', () => applyGains());
    }

    beatGain = ctx.createGain();
    beatGain.gain.value = 0.9;
    beatGain.connect(master);

    lampAudio.classList.add('on');
  }

  // ------ Beat Loading ------
  fileBeat.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    ensureAudio();
    try {
      const arr = await file.arrayBuffer();
      beatBuffer = await ctx.decodeAudioData(arr);
      usingMetronome = false;
      lampBeat.classList.add('on');
      txtMsg.textContent = 'Beat loaded';
    } catch (err) {
      txtMsg.textContent = 'Could not decode audio';
      console.error(err);
    }
  });

  // ------ Metronome (fallback beat) ------
  btnMetronome.onclick = () => {
    ensureAudio();
    beatBuffer = null;
    usingMetronome = true;
    lampBeat.classList.add('on');
    txtMsg.textContent = 'Metronome beat enabled (120 BPM)';
  };

  // ------ Transport ------
  btnPlay.onclick = async () => {
    ensureAudio();
    await ctx.resume();
    if (isPlaying) return; // do not stop on Play; only STOP stops

    isPlaying = true;
    startTime = ctx.currentTime;
    scheduleOneMinute(startTime);

    // UI
    btnStop.disabled = false;
    lampPlaying.classList.add('on');
    txtMsg.textContent = 'Playing…';

    // timeline UI
    startUITimer();
  };

  btnStop.onclick = () => {
    stopAll();
  };

  btnReset.onclick = () => {
    stopAll({silent:true});
    clearTimelineMarker();
    txtTime.textContent = 't = 0.0s';
    txtMsg.textContent = 'Reset';
  };

  btnLoop.onclick = () => {
    loopEnabled = !loopEnabled;
    btnLoop.textContent = loopEnabled ? 'Loop On' : 'Loop Off';
  };

  // ------ Gain logic (mute/solo) ------
  function applyGains() {
    const anySolo = Object.values(channel).some(c => c.solo);
    for (const k of Object.keys(channel)) {
      const vol = parseFloat(volEls[k].value);
      const ch = channel[k];
      let target = vol;
      if (anySolo) {
        target = ch.solo ? vol : 0.0;
      } else if (ch.muted) {
        target = 0.0;
      }
      if (ch.gain) ch.gain.gain.setTargetAtTime(target, ctx.currentTime, 0.01);
    }
  }

  // ------ Scheduling Core ------
  function scheduleOneMinute(t0) {
    // Schedule beat (either buffer loop or metronome clicks)
    scheduleBeat(t0);

    // Schedule sections by classic order
    scheduleStrings(t0 + 0);
    scheduleWoodwinds(t0 + 10);
    scheduleBrass(t0 + 20);
    schedulePerc(t0 + 35);
    schedulePiano(t0 + 45);

    // Auto-stop or loop handler
    const stopAt = t0 + DURATION;
    const endTimer = setTimeout(() => {
      if (!loopEnabled) {
        stopAll();
      } else {
        // loop: reschedule seamlessly from exact boundary
        startTime = ctx.currentTime;
        scheduleOneMinute(startTime);
      }
    }, Math.max(0, (stopAt - ctx.currentTime) * 1000));
  }

  // ------ Beat scheduling ------
  function scheduleBeat(t0) {
    if (!ctx) return;
    if (beatBuffer) {
      // Use uploaded buffer, loop over the minute
      const src = ctx.createBufferSource();
      src.buffer = beatBuffer;
      src.loop = true;
      src.connect(beatGain);
      src.start(t0);
      src.stop(t0 + DURATION + 0.05);
    } else if (usingMetronome) {
      // Simple 120 BPM — tick on quarter notes (every 0.5s)
      const bpm = 120, spb = 60/bpm; // 0.5 sec
      for (let t = 0; t < DURATION; t += spb) {
        metronomeTick(t0 + t);
      }
    }
  }

  function metronomeTick(at) {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'square';
    osc.frequency.value = 2000;
    g.gain.value = 0.0001;
    osc.connect(g).connect(beatGain);
    const a = g.gain;
    a.setValueAtTime(0.0001, at);
    a.exponentialRampToValueAtTime(0.3, at + 0.001);
    a.exponentialRampToValueAtTime(0.0001, at + 0.05);
    osc.start(at);
    osc.stop(at + 0.06);
  }

  // ------ Section Patterns (simple musical placeholders) ------
  // Helper to play a short tone burst with ADSR-ish envelope.
  function toneAt(at, freq, outGain, type='sine', dur=0.35) {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.value = 0.0001;
    osc.connect(g).connect(outGain);

    const A = 0.01, D = 0.12, S = 0.15, R = 0.12;
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.6, at + A);
    g.gain.exponentialRampToValueAtTime(0.2, at + A + D);
    g.gain.setTargetAtTime(0.2, at + A + D, S);
    g.gain.exponentialRampToValueAtTime(0.0001, at + dur + R);

    osc.start(at);
    osc.stop(at + dur + R + 0.02);
  }

  // Strings: pad-like (detuned saws + lowpass)
  function scheduleStrings(t0) {
    const g = ctx.createGain(); g.gain.value = 0.8; g.connect(channel.strings.gain);
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1800; lp.Q.value = 0.5;
    g.disconnect(); g.connect(lp).connect(channel.strings.gain);

    // Simple arpeggio over minute (every 2s)
    const scale = [220, 246.94, 277.18, 293.66, 329.63, 369.99, 415.30]; // A minor-ish
    for (let s = 0; s < DURATION; s += 2) {
      const f = scale[(s/2)%scale.length|0];
      // two detuned saws per note
      detunedSaw(t0 + s, f*0.5, lp, 1.6);
    }
  }
  function detunedSaw(at, f, dest, dur=1.6){
    const o1 = ctx.createOscillator(), o2 = ctx.createOscillator();
    const g = ctx.createGain(); g.gain.value = 0.12;
    o1.type='sawtooth'; o2.type='sawtooth';
    o1.frequency.value = f * 0.995;
    o2.frequency.value = f * 1.005;
    o1.connect(g); o2.connect(g); g.connect(dest);
    // gentle fade
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.12, at+0.08);
    g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
    o1.start(at); o2.start(at);
    o1.stop(at+dur+0.05); o2.stop(at+dur+0.05);
  }

  // Woodwinds: sine + slight vibrato (every 3s)
  function scheduleWoodwinds(t0) {
    const scale = [440,493.88,523.25,587.33,659.25,698.46,783.99]; // A major-ish
    for (let s = 0; s < DURATION-10; s += 3) {
      const f = scale[(s/3)%scale.length|0];
      windNote(t0 + s, f, channel.woodwinds.gain);
    }
  }
  function windNote(at, f, out) {
    const osc = ctx.createOscillator();
    const g = ctx.createGain(); g.gain.value = 0.0001;
    const lfo = ctx.createOscillator(); const lfoG = ctx.createGain();
    lfo.frequency.value = 5; lfoG.gain.value = 6; // vibrato depth
    lfo.connect(lfoG); lfoG.connect(osc.frequency);
    osc.type='sine'; osc.frequency.value = f;
    osc.connect(g).connect(out);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.4, at+0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.35);
    lfo.start(at); lfo.stop(at+0.4);
    osc.start(at); osc.stop(at+0.4);
  }

  // Brass: square + lowpass “stabs” (every 4s)
  function scheduleBrass(t0) {
    const seq = [220, 277.18, 349.23, 293.66, 329.63];
    for (let s = 0; s < DURATION-20; s += 4) {
      const f = seq[(s/4)%seq.length|0];
      brassHit(t0 + s, f, channel.brass.gain);
    }
  }
  function brassHit(at, f, out){
    const osc = ctx.createOscillator();
    const g = ctx.createGain(); g.gain.value = 0.0001;
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 900;
    osc.type='square'; osc.frequency.value = f;
    osc.connect(lp).connect(g).connect(out);
    // punch
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.7, at+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.3);
    osc.start(at); osc.stop(at+0.32);
  }

  // Percussion: synthesized kick+snare patterns (every beat @ 120BPM starting 35s)
  function schedulePerc(t0) {
    const bpm = 120, spb = 60/bpm; // 0.5s
    let step = 0;
    for (let t = 0; t < DURATION-35; t += spb) {
      const at = t0 + t;
      if (step % 4 === 0) kick(at);        // beat 1
      if (step % 4 === 2) snare(at);       // beat 3
      // hats
      hat(at + 0.25*spb);
      step++;
    }
  }
  function kick(at){
    const osc = ctx.createOscillator(), g = ctx.createGain();
    osc.type='sine'; osc.frequency.setValueAtTime(120, at);
    osc.frequency.exponentialRampToValueAtTime(40, at+0.1);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.9, at+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.2);
    osc.connect(g).connect(channel.perc.gain);
    osc.start(at); osc.stop(at+0.21);
  }
  function snare(at){
    const noise = ctx.createBufferSource();
    const buffer = ctx.createBuffer(1, ctx.sampleRate*0.2, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
    noise.buffer = buffer;
    const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.8;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.6, at+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.12);
    noise.connect(bp).connect(g).connect(channel.perc.gain);
    noise.start(at); noise.stop(at+0.13);
  }
  function hat(at){
    const noise = ctx.createBufferSource();
    const buffer = ctx.createBuffer(1, ctx.sampleRate*0.05, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
    noise.buffer = buffer;
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; hp.Q.value=0.5;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, at);
    g.gain.exponentialRampToValueAtTime(0.3, at+0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, at+0.05);
    noise.connect(hp).connect(g).connect(channel.perc.gain);
    noise.start(at); noise.stop(at+0.06);
  }

  // Piano: short triad plucks (every 2.5s)
  function schedulePiano(t0) {
    const roots = [261.63,293.66,329.63,349.23,392.00]; // C D E F G
    for (let s=0; s < DURATION-45; s += 2.5) {
      const r = roots[(s/2.5)%roots.length|0];
      triad(t0 + s, r, channel.piano.gain);
    }
  }
  function triad(at, root, out){
    toneAt(at, root, out, 'triangle', 0.28);
    toneAt(at+0.01, root*1.2599, out, 'triangle', 0.28); // +M3
    toneAt(at+0.02, root*1.4983, out, 'triangle', 0.28); // +P5
  }

  // ------ Public helpers for Part 4 ------
  window.__AIMIXER__ = {
    DURATION, CLASSIC_ORDER,
    get ctx(){ return ctx },
    get startTime(){ return startTime },
    isPlaying: () => isPlaying,
    ensureAudio, scheduleOneMinute, stopAll, applyGains,
    timeline, playhead, lamps: {lampAudio,lampBeat,lampPlaying}, txtTime, txtMsg
  };
})();
</script>
<script>
(() => {
  const {
    DURATION, CLASSIC_ORDER,
    ensureAudio, scheduleOneMinute, applyGains, stopAll,
    timeline, playhead, lamps, txtTime, txtMsg
  } = window.__AIMIXER__;

  // Draw timeline grid and section bands once
  const W = () => timeline.clientWidth;
  function initTimeline() {
    // Clear
    timeline.querySelectorAll('.gridline,.label,.band').forEach(n=>n.remove());

    // Bands (active windows)
    CLASSIC_ORDER.forEach(sec => {
      const band = document.createElement('div');
      band.className = `band ${sec.key==='strings'?'str':sec.key==='woodwinds'?'ww':sec.key==='brass'?'br':sec.key==='perc'?'pc':'pn'}`;
      const left = (sec.start / DURATION) * 100;
      const width = ((DURATION - sec.start) / DURATION) * 100;
      band.style.left = left + '%';
      band.style.width = width + '%';
      timeline.appendChild(band);
    });

    // Vertical grid (every 5s)
    for (let s=0; s<=DURATION; s+=5) {
      const x = (s / DURATION) * W();
      const gl = document.createElement('div');
      gl.className = 'gridline';
      gl.style.left = (x|0) + 'px';
      timeline.appendChild(gl);

      const lab = document.createElement('div');
      lab.className = 'label';
      lab.textContent = s + 's';
      lab.style.left = `calc(${(s/DURATION)*100}% + 4px)`;
      timeline.appendChild(lab);
    }
  }
  initTimeline();
  window.addEventListener('resize', initTimeline);

  // Transport status polling
  let uiTimer = null;
  function startUITimer() {
    clearInterval(uiTimer);
    uiTimer = setInterval(() => {
      const ctx = window.__AIMIXER__.ctx;
      if (!ctx) return;
      const t = Math.max(0, ctx.currentTime - window.__AIMIXER__.startTime);
      const clamped = Math.min(DURATION, t);
      txtTime.textContent = `t = ${clamped.toFixed(1)}s`;
      playhead.style.left = `${(clamped / DURATION) * 100}%`;
      // Auto lamp off at end when not looping
      if (t >= DURATION && !window.__AIMIXER__.isPlaying()) {
        lamps.lampPlaying.classList.remove('on');
        clearInterval(uiTimer);
      }
    }, 50);
  }

  // StopAll implementation (kills scheduled audio by resetting context)
  function hardResetContext() {
    const prev = window.__AIMIXER__.ctx;
    if (!prev) return;
    try { prev.close(); } catch(_) {}
    window.__AIMIXER__.ctx = null;
  }

  // Expose stopAll to Part 3
  window.__AIMIXER__.stopAll = function(opts={}){
    const {silent=false} = opts;
    clearInterval(uiTimer);
    lamps.lampPlaying.classList.remove('on');
    hardResetContext(); // simplest reliable way to stop all scheduled nodes
    if (!silent) txtMsg.textContent = 'Stopped';
    // Re-init will happen on next PLAY
  }

  // Hook transport buttons created in Part 2 (after DOM ready)
  document.getElementById('btnPlay').addEventListener('click', () => {
    startUITimer();
  });
  document.getElementById('btnStop').addEventListener('click', () => {
    // UI button state is managed inside Part 3
  });
  document.getElementById('btnReset').addEventListener('click', () => {
    playhead.style.left = '0%';
    txtTime.textContent = 't = 0.0s';
  });

  // ---------- HELP / EXPLANATION PANEL (ADDED) ----------
  function insertHelp() {
    const wrap = document.querySelector('.wrap');
    if (!wrap) return;

    const panel = document.createElement('div');
    panel.className = 'panel';
    panel.style.marginTop = '12px';

    panel.innerHTML = `
      <h2 style="margin:0 0 6px;font-size:18px;">How the Mixer Symphony Works (Classic Order, 1 Minute)</h2>
      <div class="small" style="margin-bottom:10px">
        This system is a <b>timed mixer</b>, not a composer: it schedules five sections on a fixed 60-second grid and lets you mix them in real time.
        The order is <b>Strings (0s)</b> → <b>Woodwinds (10s)</b> → <b>Brass (20s)</b> → <b>Percussion (35s)</b> → <b>Piano (45s)</b>.
      </div>

      <details open style="margin:8px 0">
        <summary><b>1) Quick Start</b></summary>
        <ol class="small" style="margin:6px 0 0 18px;line-height:1.5">
          <li>Click <b>Use Metronome</b> for a built-in 120 BPM guide, or <b>Upload</b> your own beat in the file slot.</li>
          <li>Press <b>PLAY</b>. The marker on the timeline sweeps from 0s → 60s.</li>
          <li>At <b>0s</b> strings begin; then each section enters at its labeled second. Use the <b>Mute/Solo</b> buttons and <b>Volume</b> sliders per section.</li>
          <li>Optional: toggle <b>Loop On</b> to repeat after 60s. Use <b>STOP</b> to halt and <b>RESET</b> to clear the playhead to 0s.</li>
        </ol>
      </details>

      <details style="margin:8px 0">
        <summary><b>2) What “MIDI-style” means here</b></summary>
        <div class="small" style="margin-top:6px;line-height:1.5">
          We’re using the Web Audio API to synthesize notes on a <b>time grid</b>, similar to triggering MIDI notes at precise times.
          Each section schedules short tones/chords at specific timestamps (e.g., every 2s for strings, every 3s for woodwinds).
          <br/><br/>
          <b>Where patterns live (Part 3):</b>
          <ul style="margin:6px 0 0 18px">
            <li><code>scheduleStrings(t0)</code> — pad/arpeggio every ~2s</li>
            <li><code>scheduleWoodwinds(t0)</code> — melodic bleeps every ~3s</li>
            <li><code>scheduleBrass(t0)</code> — short stabs every ~4s</li>
            <li><code>schedulePerc(t0)</code> — kick/snare/hat at 120 BPM from 35s</li>
            <li><code>schedulePiano(t0)</code> — triad plucks every ~2.5s</li>
          </ul>
          Each function uses helpers like <code>toneAt</code>, <code>detunedSaw</code>, <code>brassHit</code>, <code>kick/snare/hat</code>, and <code>triad</code>.
        </div>
      </details>

      <details style="margin:8px 0">
        <summary><b>3) Adding Your Own Beats to Instruments (precise steps)</b></summary>
        <div class="small" style="margin-top:6px;line-height:1.55">
          There are two ways to add beats:
          <ol style="margin:6px 0 0 18px">
            <li><b>External beat (audio file)</b> — for any drum loop or click:
              <ul style="margin:6px 0 0 18px">
                <li>Use the file input to load a WAV/MP3. The engine decodes it and loops it under the mix for the full minute.</li>
                <li>This audio is routed through the <code>beatGain</code> node (see Part 3: “Beat Loading” and <code>scheduleBeat</code>).</li>
              </ul>
            </li>
            <li><b>Internal beats (per-instrument triggers)</b> — for kick/snare/hat or custom rhythmic notes:
              <ul style="margin:6px 0 0 18px">
                <li>Open Part 3 and edit <code>schedulePerc(t0)</code>. By default, it runs at <b>120 BPM</b> (<code>spb = 0.5s</code>) and triggers:
                  <ul style="margin:4px 0 0 18px">
                    <li><b>Kick</b> on steps 0,4,8,… (<code>step % 4 === 0</code>)</li>
                    <li><b>Snare</b> on steps 2,6,10,… (<code>step % 4 === 2</code>)</li>
                    <li><b>Hi-hat</b> on the off-beat (<code>+ 0.25*spb</code>)</li>
                  </ul>
                </li>
                <li>To change the rhythm, replace the modulo rules with a <b>pattern array</b>. Example (4/4 over one bar):
<pre style="white-space:pre-wrap;background:#0b1432;border:1px solid #1a2658;border-radius:8px;padding:8px;margin-top:6px">
const bpm = 120, spb = 60 / bpm;             // seconds per beat
const bars = 8;                               // how many bars to run (fills the minute)
const stepsPerBeat = 2;                       // 8th notes
const stepsPerBar = 4 * stepsPerBeat;         // 4/4
const kickPat  = [1,0,0,0,  0,0,0,0];         // 8 steps per bar
const snarePat = [0,0,1,0,  0,0,1,0];
const hatPat   = [0,1,0,1,  0,1,0,1];

for (let bar = 0; bar &lt; bars; bar++) {
  for (let i = 0; i &lt; stepsPerBar; i++) {
    const at = t0 + (bar * stepsPerBar + i) * (spb / stepsPerBeat);
    if (kickPat[i])  kick(at);
    if (snarePat[i]) snare(at);
    if (hatPat[i])   hat(at);
  }
}
</pre>
                </li>
                <li>For other sections (strings/woodwinds/brass/piano), switch their timing to BPM-based like above, or keep second-based loops. You trigger musical “beats” by calling their note helpers at your step times.</li>
              </ul>
            </li>
          </ol>
          <b>Important:</b> the Mixer schedules sections at their <b>entry seconds</b> (0s/10s/20s/35s/45s). Your custom beat code should live inside the corresponding <code>scheduleXxx(t0)</code> so it starts after that section’s entry.
        </div>
      </details>

      <details style="margin:8px 0">
        <summary><b>4) Mapping Seconds ↔ Beats (exact math)</b></summary>
        <div class="small" style="margin-top:6px;line-height:1.55">
          If your BPM is <code>B</code>, seconds per beat is <code>spb = 60 / B</code>.<br/>
          A step grid with <code>stepsPerBeat</code> (e.g., 2 for 8th notes) has step duration <code>spb / stepsPerBeat</code>.<br/>
          At section entry <code>t0</code>:
<pre style="white-space:pre-wrap;background:#0b1432;border:1px solid #1a2658;border-radius:8px;padding:8px;margin-top:6px">
const B = 120;
const spb = 60 / B;
const stepsPerBeat = 4; // 16th notes
const stepDur = spb / stepsPerBeat;

for (let step=0; step&lt;totalSteps; step++) {
  const at = t0 + step * stepDur; // exact timestamp for this step
  // trigger note/drum at "at"
}
</pre>
        </div>
      </details>

      <details style="margin:8px 0">
        <summary><b>5) Mixing & Gain Structure</b></summary>
        <div class="small" style="margin-top:6px;line-height:1.55">
          Each section has its own gain node. <b>Solo</b> makes only that section audible; <b>Mute</b> silences it. Moving a volume slider updates the target gain with a short smoothing constant (<code>setTargetAtTime(..., 0.01)</code>) to avoid clicks.
        </div>
      </details>

      <details style="margin:8px 0">
        <summary><b>6) Developer Notes (where to edit)</b></summary>
        <div class="small" style="margin-top:6px;line-height:1.55">
          <ul style="margin:0 0 0 18px">
            <li><b>Change entry times</b>: Part 3, <code>scheduleOneMinute</code> calls to <code>scheduleStrings/…</code>. Also adjust the bands in Part 4’s <code>CLASSIC_ORDER</code> rendering.</li>
            <li><b>Swap to MIDI input</b>: replace tone helpers with a MIDI parser that triggers <code>AudioContext</code> nodes at the parsed timestamps.</li>
            <li><b>Use your own drum samples</b>: in <code>kick/snare/hat</code>, replace synthesized nodes with decoded sample buffers routed to <code>channel.perc.gain</code>.</li>
          </ul>
        </div>
      </details>
    `;

    wrap.appendChild(panel);
  }
  insertHelp();

})();
</script>
</body>
</html>
