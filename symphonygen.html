<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI 1-Minute Symphony â€” Stable Player (CSV A/B, Panic, BPM, Offset)</title>
<style>
  :root{
    --bg:#0b1222;--panel:#111a34;--ink:#eaf0ff;--muted:#a7b7e6;--border:#213067;
    --btn:#162455;--btnH:#1d2e6e;--good:#7bffb1;--warn:#ffd37a;--bad:#ff8c8c
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1080px;margin:0 auto;padding:16px}
  h1{margin:0 0 8px;font-size:1.4rem}
  .sub{color:var(--muted);margin:0 0 14px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
  textarea{width:100%;min-height:140px;background:#0c1633;color:var(--ink);border:1px solid var(--border);border-radius:10px;padding:10px;font-family:ui-monospace,Consolas,monospace}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:0 0 auto}
  label{font-size:.92rem;color:var(--muted)}
  input[type="number"], input[type="range"]{
    background:#0c1633;color:var(--ink);border:1px solid var(--border);border-radius:10px;padding:6px 8px
  }
  .btn{background:var(--btn);border:1px solid var(--border);color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
  .btn:hover{background:var(--btnH)}
  .btn.bad{border-color:#5b1f1f;background:#3a0f0f}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:#0c1633;color:var(--muted);font-size:.85rem}
  .status{font-weight:600}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .small{font-size:.85rem;color:var(--muted)}
  .mono{font-family:ui-monospace,Consolas,monospace}
</style>
</head>
<body>
  <div class="wrap">
    <h1>AI 1-Minute Symphony â€” Stable CSV Player</h1>
    <p class="sub">Two lanes (A/B). Clean envelopes, limiter, and a **real panic**. Paste CSV below (<span class="mono">t,midi,vel,dur</span>).</p>

    <div class="grid">
      <div class="card">
        <h3>CSV A</h3>
        <textarea id="csvA" placeholder="t,midi,vel,dur
0.00,60,0.8,0.50
0.50,64,0.8,0.50
1.00,67,0.8,0.50"></textarea>
        <div class="row" style="margin-top:8px">
          <span class="pill">Lane A enabled</span>
        </div>
      </div>

      <div class="card">
        <h3>CSV B</h3>
        <textarea id="csvB" placeholder="t,midi,vel,dur
2.00,55,0.7,0.50
2.50,59,0.7,0.50
3.00,62,0.7,0.50"></textarea>
        <div class="row" style="margin-top:8px">
          <label>Delay B start (sec)</label>
          <input id="delayB" type="number" step="0.1" value="2.0" style="width:90px" />
          <span class="small">Use this to start CSV-B a few seconds after A.</span>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="row" style="gap:18px">
        <button id="btnPlay" class="btn">â–¶ Play</button>
        <button id="btnStop" class="btn">â–  Stop</button>
        <button id="btnPanic" class="btn bad">ðŸ§¯ Panic</button>

        <label for="bpm">BPM scale</label>
        <input id="bpm" type="range" min="40" max="200" value="90" />
        <span id="bpmVal" class="pill">90 BPM</span>

        <label for="gain">Master</label>
        <input id="gain" type="range" min="0" max="1" step="0.01" value="0.75" />
        <span id="gainVal" class="pill">0.75</span>

        <span>Poly cap: <span id="poly" class="pill">12 voices</span></span>
        <span>Status: <span id="status" class="status ok">Idle</span></span>
      </div>
      <p class="small" style="margin-top:10px">
        CSV headers optional; unknown columns ignored. If you previously used **A(16)/B(16) chairs**, this engine keeps the sound light and stable.
      </p>
    </div>
    <script>
    // ---------- Utilities ----------
    const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
    const midiToHz = m => 440 * Math.pow(2,(m-69)/12);

    function parseCSV(txt){
      const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const out=[];
      for(const ln of lines){
        if (/^[a-z]/i.test(ln)) continue; // skip header
        const [t,midi,vel,dur] = ln.split(/,|\s+/).map(Number);
        if (Number.isFinite(t) && Number.isFinite(midi)){
          out.push({
            t: Math.max(0, t),
            midi: clamp(Math.round(midi),0,127),
            vel: Number.isFinite(vel) ? clamp(vel,0,1) : 0.8,
            dur: Number.isFinite(dur) ? Math.max(0.03, dur) : 0.4
          });
        }
      }
      // ensure time ascending
      out.sort((a,b)=>a.t-b.t);
      return out;
    }

    // ---------- Stable Audio Engine ----------
    const Engine = (()=>{
      let actx=null, master=null, comp=null, dcBlock=null, lpf=null;
      let lookahead=0.08, tick=null;
      const activeVoices=new Set();
      let startT=0, playHead=0, playing=false;
      const maxPoly=12;

      function ensureContext(){
        if (actx) return;
        actx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive', sampleRate: 48000 });
        // DC blocker (HPF ~30 Hz)
        dcBlock = actx.createBiquadFilter(); dcBlock.type='highpass'; dcBlock.frequency.value=30;
        // Gentle low-pass to tame harshness (~7.5 kHz)
        lpf = actx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=7500; lpf.Q.value=0.5;
        // Soft limiter
        comp = actx.createDynamicsCompressor();
        comp.threshold.value = -24; comp.knee.value=18; comp.ratio.value=6;
        comp.attack.value=0.003; comp.release.value=0.1;
        master = actx.createGain(); master.gain.value = parseFloat(document.getElementById('gain').value);
        // wiring
        dcBlock.connect(lpf).connect(comp).connect(master).connect(actx.destination);
      }

      function setMasterGain(v){ if(master) master.gain.setTargetAtTime(v, actx.currentTime, 0.01); }

      function makeVoice(freq, vel){
        // Simple band-limited-ish tri+sine mix + gentle filter per-voice
        const now = actx.currentTime;
        const g = actx.createGain(); g.gain.value = 0;

        const osc1 = actx.createOscillator(); osc1.type='triangle'; osc1.frequency.setValueAtTime(freq, now);
        const osc2 = actx.createOscillator(); osc2.type='sine';     osc2.frequency.setValueAtTime(freq*2, now);

        const vcf = actx.createBiquadFilter(); vcf.type='lowpass'; vcf.frequency.value = Math.min(12000, 1200 + vel*2800); vcf.Q.value=0.4;

        // small noise layer to soften edges (very low)
        const noise = actx.createBufferSource();
        const nbuf = actx.createBuffer(1, 2048, actx.sampleRate);
        const data = nbuf.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.002;
        noise.buffer=nbuf; noise.loop=true;

        // connect
        osc1.connect(vcf); osc2.connect(vcf); noise.connect(vcf);
        vcf.connect(g).connect(dcBlock);

        // anti-click ADSR
        const A=0.005, D=0.03, S=0.7*vel, R=0.08+0.1*(1-vel); // short, musical
        const peak = clamp(0.9*vel, 0, 0.9);
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(peak, now + A);
        g.gain.linearRampToValueAtTime(S, now + A + D);

        osc1.start(now); osc2.start(now); noise.start(now);

        return {
          stop(at){
            const t = Math.max(at, actx.currentTime);
            // smooth release
            g.gain.cancelScheduledValues(t);
            g.gain.setTargetAtTime(0.0001, t, R);
            const kill = t + R*4 + 0.05;
            osc1.stop(kill); osc2.stop(kill); noise.stop(kill);
            // cleanup later
            const killer = setTimeout(()=>{
              try{
                osc1.disconnect(); osc2.disconnect(); noise.disconnect();
                vcf.disconnect(); g.disconnect();
              }catch(_){}
              activeVoices.delete(vo);
            }, (kill - actx.currentTime)*1000 + 50);
            return killer;
          }
        };
      }

      function scheduleNote(ev, t0){
        if (activeVoices.size >= maxPoly) return; // skip to keep stable
        const when = t0 + ev.t;
        if (when < actx.currentTime - 0.02) return; // late
        const freq = midiToHz(ev.midi);
        const v = makeVoice(freq, ev.vel);
        activeVoices.add(v);
        // safety duration (ensures we wonâ€™t get stuck)
        const stopAt = when + Math.max(0.03, ev.dur);
        v.stop(stopAt);
      }

      function start(eventsA, eventsB, delayB, bpmScale){
        ensureContext();
        playing=true;
        startT = actx.currentTime;
        playHead = 0;

        // Map source times by BPM scale: scaled_t = t * 90 / bpm
        const base=90; const scale = base/Math.max(40,Math.min(200,bpmScale));
        const A = eventsA.map(e=>({...e,t:e.t*scale, dur:e.dur*scale}));
        const B = eventsB.map(e=>({...e,t:delayB + e.t*scale, dur:e.dur*scale}));

        // simple streaming scheduler
        const all = [A,B];
        let idx=[0,0];

        const step = ()=>{
          if (!playing) return;
          const now=actx.currentTime;
          const horizon = now + lookahead;
          for(let lane=0; lane<2; lane++){
            const arr = all[lane], i0 = idx[lane]||0;
            let i=i0;
            while(i < arr.length && (startT + arr[i].t) < horizon){
              scheduleNote(arr[i], startT);
              i++;
            }
            idx[lane]=i;
          }
          // auto stop when finished
          const done = idx[0]>=(A.length)||A.length===0;
          const doneB= idx[1]>=(B.length)||B.length===0;
          if (done && doneB){
            stop(false);
            setStatus('Done', 'ok');
            return;
          }
        };
        tick = setInterval(step, 25);
        setStatus('Playingâ€¦', 'ok');
      }

      function stop(updateStatus=true){
        playing=false;
        if (tick){ clearInterval(tick); tick=null; }
        // stop all voices
        activeVoices.forEach(v=>v.stop(actx.currentTime));
        activeVoices.clear();
        updateStatus && setStatus('Stopped', 'warn');
      }

      function panic(){
        // hard reset everything
        try{ stop(false); }catch(_){}
        if (actx){
          try{ master.disconnect(); comp.disconnect(); lpf.disconnect(); dcBlock.disconnect(); }catch(_){}
          try{ actx.close(); }catch(_){}
        }
        actx=null; master=null; comp=null; dcBlock=null; lpf=null;
        setStatus('Panic â€” audio reset', 'bad');
      }

      function polycap(){ return maxPoly; }

      return { start, stop, panic, setMasterGain, polycap };
    })();

    function setStatus(msg, kind='ok'){
      const el=document.getElementById('status');
      el.textContent = msg;
      el.classList.remove('ok','warn','bad');
      el.classList.add(kind);
    }
    </script>
    <script>
      const $ = sel=>document.querySelector(sel);

      const elCSV_A = $('#csvA');
      const elCSV_B = $('#csvB');
      const elDelayB = $('#delayB');
      const elBPM = $('#bpm');
      const elBPMVal = $('#bpmVal');
      const elGain = $('#gain');
      const elGainVal = $('#gainVal');
      const elPoly = $('#poly');

      elPoly.textContent = `${Engine.polycap()} voices`;

      function readInputs(){
        const A = parseCSV(elCSV_A.value);
        const B = parseCSV(elCSV_B.value);
        const delayB = parseFloat(elDelayB.value)||0;
        const bpm = parseInt(elBPM.value,10);
        return {A,B,delayB,bpm};
      }

      elBPM.addEventListener('input', ()=> elBPMVal.textContent = `${elBPM.value} BPM`);
      elGain.addEventListener('input', ()=> { elGainVal.textContent = elGain.value; Engine.setMasterGain(parseFloat(elGain.value)); });

      $('#btnPlay').addEventListener('click', ()=>{
        const {A,B,delayB,bpm} = readInputs();
        if (!A.length && !B.length){ setStatus('No notes to play', 'warn'); return; }
        setStatus('Primingâ€¦','ok');
        Engine.start(A,B,delayB,bpm);
      });

      $('#btnStop').addEventListener('click', ()=>{
        Engine.stop();
      });

      $('#btnPanic').addEventListener('click', ()=>{
        Engine.panic();
      });

      // Guard against AudioContext auto-suspend muting
      document.addEventListener('visibilitychange', ()=>{
        if (document.visibilityState==='visible'){
          // touching gain nudges context when resumed later
          try{ Engine.setMasterGain(parseFloat(elGain.value)); }catch(_){}
        }
      });
    </script>
  </div>
</body>
</html>
