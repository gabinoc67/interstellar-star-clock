<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST Astrodumus — 1-Minute Symphony (Mozart Templates, Fixed Palette)</title>
<meta name="description" content="CST-synced 1-minute symphony generator that follows Mozart-style movement plans (fast–slow–fast) using K-templates. Minimal UI; fixed orchestral palette."/>
<style>
  :root{--bg:#080e22;--panel:#0f1636;--ink:#e9f1ff;--muted:#9fb2e4;--grid:#1a2658;--btn:#15235a;--accent:#9bd1ff;--bar:#13226b}
  *{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:18px}
  h1{margin:0 0 6px;font-size:1.35rem} p.sub{margin:0 0 14px;color:var(--muted)}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.25);overflow:hidden}
  .pad{padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  button{background:var(--btn);color:var(--ink);border:1px solid #273a8a;border-radius:12px;padding:10px 14px;cursor:pointer}
  button:hover{filter:brightness(1.08)}
  .status{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:10px}
  .status>div{background:#0b1333;border:1px solid var(--grid);border-radius:10px;padding:10px;min-height:54px}
  .tiny{font-size:.85rem;color:var(--muted)}
  .movetable{margin:10px 14px 16px;border-collapse:collapse;width:calc(100% - 28px)}
  .movetable th,.movetable td{border:1px solid var(--grid);padding:6px 8px;font-size:.9rem}
  .movetable th{background:#0d1540;color:#cfe0ff;font-weight:600}
  .movetable td b{color:var(--accent)}
  canvas{width:100%;height:260px;display:block;background:linear-gradient(180deg,#0b1536,#0b1230)}
  #tip{position:fixed;left:-9999px;top:-9999px;background:#0b1333;border:1px solid #1a2658;border-radius:8px;padding:6px 8px;font-size:12px;color:#e9f1ff;pointer-events:none;z-index:9999}
  .hint{color:#a8b8ee;font-size:.85rem;margin:8px 14px 14px}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST “Astrodumus” — 1-Minute Symphony (Mozart Movement Templates)</h1>
  <p class="sub">Follows a classical fast–slow–fast plan inspired by Mozart (K.385, K.525, K.550). Fixed orchestral palette for clarity.</p>

  <section class="card">
    <div class="pad">
      <div class="row">
        <button id="gen">Generate 1-Minute Symphony</button>
        <button id="play">▶ Play</button>
        <button id="reset">⟲ Reset</button>
        <button id="export">⬇ Download WAV</button>
      </div>

      <div class="status">
        <div><b>BPM (avg)</b><div id="bpmOut" class="tiny">–</div></div>
        <div><b>Key</b><div id="keyOut" class="tiny" title="">–</div></div>
        <div><b>Template</b><div id="tmplOut" class="tiny">–</div></div>
        <div><b>Length</b><div id="lenOut" class="tiny">–</div></div>
      </div>
    </div>
    <canvas id="timeline" title="Timeline: movements, instruments & notes"></canvas>
    <div class="hint" id="hint">Tip: Each piece compresses a symphonic plan (e.g., Allegro → Andante → Presto) into ~60 seconds.</div>
    <table class="movetable" id="movetable" aria-label="Movement Plan"></table>
  </section>
</div>

<div id="tip"></div>

<script>
/* ========== Time & Seed (CST) ========== */
function nowCSTParts(){
  const fmt=new Intl.DateTimeFormat('en-US',{timeZone:'America/Chicago',year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',hour12:false});
  const p=Object.fromEntries(fmt.formatToParts(new Date()).map(x=>[x.type,x.value]));
  return {Y:p.year,M:p.month,D:p.day,h:p.hour,m:p.minute};
}
function makeCSTSeed(){ const t=nowCSTParts(); return `${t.Y}${t.M}${t.D}${t.h}${t.m}`; }
function hash32(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i); h=(h*16777619)>>>0;} return h>>>0; }
function rngFromSeed(n){ let s=n>>>0||1; return function(){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)/4294967296; } }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ========== MIDI helpers ========== */
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function midiToName(m){
  const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const n=Math.round(m); const name=names[(n%12+12)%12]; const oct=Math.floor(n/12)-1;
  return name+oct;
}

/* ========== Harmony ========== */
const KEYROOTS={C:0,G:7,D:2,A:9,E:4,F:5,Bb:10,Eb:3,Ab:8};
const MODES={ionian:[0,2,4,5,7,9,11],aeolian:[0,2,3,5,7,8,10],dorian:[0,2,3,5,7,9,10],mixolydian:[0,2,4,5,7,9,10]};
function scaleFor(key,mode){ return MODES[mode].map(s=>s+KEYROOTS[key]); }
function degToMidi(base,scale,deg){ const L=scale.length; const oct=Math.floor(deg/L); const idx=((deg%L)+L)%L; return base+oct*12+(scale[idx]-scale[0]); }

/* ========== Style Profiles (phrase/step probabilities) ========== */
const Profiles = {
  Mozart:{ step:[30,30,15,10,10,5], rhythm:0.55, cad:[0.30,0.50,0.20] },
  Bach:{ step:[35,25,12,12,10,6],  rhythm:0.60, cad:[0.35,0.40,0.25] },
  Beethoven:{ step:[28,26,14,16,10,6], rhythm:0.50, cad:[0.25,0.45,0.30] },
  Debussy:{ step:[22,22,16,16,14,10], rhythm:0.48, cad:[0.20,0.40,0.40] },
  FilmScore:{ step:[24,24,16,18,12,6], rhythm:0.52, cad:[0.22,0.40,0.38] }
};
const ProfileNames = Object.keys(Profiles);
function mixProfiles(weights){
  const sum=weights.reduce((a,b)=>a+b,0)||1, W=weights.map(v=>v/sum);
  const blend={step:Array(6).fill(0), rhythm:0, cad:[0,0,0]};
  ProfileNames.forEach((name,i)=>{
    const p=Profiles[name], k=W[i];
    p.step.forEach((v,j)=>blend.step[j]+=k*v);
    blend.rhythm+=k*p.rhythm; blend.cad=blend.cad.map((v,j)=>v+k*p.cad[j]);
  });
  return blend;
}

/* ========== Fixed Orchestral Palette (keep it coherent) ========== */
const BANKS = { SymphonyCore: ['strings','woods','brass','harp','glock','abass','perc'] };
function orchForFixed(maxParts=6){ return BANKS.SymphonyCore.filter(i=>i!=='perc').slice(0,maxParts); }
function roleOf(inst){
  if(inst==='abass') return 'bass';
  if(inst==='strings') return 'bed';
  if(inst==='harp' || inst==='glock') return 'sparkle';
  if(inst==='woods' || inst==='brass') return 'lead';
  return 'other';
}

/* ========== Mozart Movement Templates (compressed to ~1 minute) ========== */
const K_TEMPLATES = [
  { code:'K.385', title:'Symphony No.35 “Haffner” (compacted)',
    plan:[
      {name:'I Allegro', meter:4, bpm:[116,138], key:'D', mode:'ionian', share:0.40, feel:'fast'},
      {name:'II Andante', meter:4, bpm:[72,88],   key:'G', mode:'ionian', share:0.22, feel:'slow'},
      {name:'IV Presto',  meter:4, bpm:[148,168], key:'D', mode:'ionian', share:0.38, feel:'fast'}
    ]
  },
  { code:'K.525', title:'Eine kleine Nachtmusik (compacted)',
    plan:[
      {name:'I Allegro',          meter:4, bpm:[120,140], key:'G',  mode:'ionian',    share:0.38, feel:'fast'},
      {name:'III Menuetto: Allegretto', meter:3, bpm:[104,120], key:'G',  mode:'ionian',    share:0.24, feel:'medium'},
      {name:'IV Rondo: Presto',   meter:4, bpm:[150,168], key:'G',  mode:'ionian',    share:0.38, feel:'fast'}
    ]
  },
  { code:'K.550', title:'Symphony No.40 in G minor (compacted)',
    plan:[
      {name:'I Molto allegro', meter:4, bpm:[132,160], key:'G',  mode:'aeolian', share:0.40, feel:'fast'},
      {name:'II Andante',      meter:4, bpm:[72,90],   key:'Eb', mode:'ionian',  share:0.22, feel:'slow'},
      {name:'IV Allegro assai',meter:4, bpm:[132,158], key:'G',  mode:'aeolian', share:0.38, feel:'fast'}
    ]
  }
];

/* Map “feel” to density/dissonance & dynamics behavior */
const FEEL = {
  fast:   {dens:0.68, diss:0.18},
  medium: {dens:0.58, diss:0.16},
  slow:   {dens:0.42, diss:0.12}
};

/* ========== Audio Engine ========== */
let ACTX=null, master=null, sendRev=null; const BUS={}; let scheduled=[], playing=false;
function ensureAudio(){
  if(ACTX) return;
  ACTX=new (window.AudioContext||window.webkitAudioContext)();
  master=ACTX.createGain(); master.gain.value=0.9; master.connect(ACTX.destination);
  // Simple Schroeder-ish reverb
  const sum=ACTX.createGain(); sum.connect(master);
  const delays=[0.0297,0.0371,0.0411,0.0437], gains=[0.805,0.827,0.783,0.764];
  for(let i=0;i<4;i++){ const d=ACTX.createDelay(1); d.delayTime.value=delays[i]; const g=ACTX.createGain(); g.gain.value=gains[i]; d.connect(g); g.connect(d); g.connect(sum); }
  sendRev=ACTX.createGain(); sendRev.gain.value=0.23; sendRev.connect(sum);
}
async function unlockAudio(){ ensureAudio(); try{ await ACTX.resume(); }catch(e){} }

function makeBus(level,pan=0){
  const g=ACTX.createGain(); g.gain.value=level;
  const p=ACTX.createStereoPanner?ACTX.createStereoPanner():null;
  if(p){ p.pan.value=pan; g.connect(p); p.connect(master); } else { g.connect(master); }
  const send=ACTX.createGain(); send.gain.value=0.0; g.connect(send); send.connect(sendRev);
  return {g,send};
}
function env(g,t0,a,d,sus,hold,rel,vel){
  const t1=t0+a, t2=t1+d, t3=t2+hold, t4=t3+rel;
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(vel,t1);
  g.gain.linearRampToValueAtTime(vel*sus,t2);
  g.gain.setValueAtTime(vel*sus,t3);
  g.gain.linearRampToValueAtTime(0,t4);
  return t4;
}

/* Patches */
const Patches = {
  strings:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200;
    const g=ACTX.createGain(); const end=env(g,t,0.08,0.5,0.8,Math.max(0.05,d-0.4),0.3,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.strings.g); g.connect(BUS.strings.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  woods:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=env(g,t,0.03,0.22,0.55,Math.max(0.05,d-0.25),0.2,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.woods.g); g.connect(BUS.woods.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  brass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
    const g=ACTX.createGain(); const end=env(g,t,0.02,0.25,0.6,Math.max(0.05,d-0.3),0.25,v*0.8);
    o.connect(f); f.connect(g); g.connect(BUS.brass.g); g.connect(BUS.brass.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  harp:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.22,0.35,0.01,0.4,v*0.7);
    o.connect(g); g.connect(BUS.harp.g); g.connect(BUS.harp.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  glock:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=env(g,t,0.001,0.4,0.25,0.02,0.8,v*0.6);
    o.connect(g); g.connect(BUS.glock.g); g.connect(BUS.glock.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  abass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.01,0.3,0.5,Math.max(0.05,d-0.25),0.25,v*0.7);
    o.connect(g); g.connect(BUS.abass.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); }
};
/* Simple synth drums */
const Drums = {
  kickAt:(t,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(130,t); o.frequency.exponentialRampToValueAtTime(40,t+0.12);
    const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.9,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(BUS.perc.g); o.start(t); o.stop(t+0.2); },
  snareAt:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.2,ACTX.sampleRate); const d=b.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i]=Math.random()*2-1; } s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ACTX.createGain();
    g.gain.setValueAtTime(v*0.5,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2); s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.2); },
  hatAt:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.08,ACTX.sampleRate); const d=b.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i]=Math.random()*2-1; } s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ACTX.createGain();
    g.gain.setValueAtTime(v*0.25,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.08); s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.08); },
  cymbalAt:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*1.5,ACTX.sampleRate); const d=b.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*0.6; } s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=4000; const g=ACTX.createGain();
    g.gain.setValueAtTime(v*0.3,t); g.gain.exponentialRampToValueAtTime(0.0001,t+1.5); s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+1.5); }
};

/* ========== Composition Helpers ========== */
const MAX_VOICES=5;
function barsForSeconds(bpm, secs, beatsPerBar){ // 4/4 or 3/4
  return Math.max(8, Math.round(secs*bpm/(60*beatsPerBar))*beatsPerBar);
}
function styleWeightsFixed(){
  const k=0.5; // tilt slightly toward classical clarity
  return ProfileNames.map(name=>{
    if(['Mozart','Bach','Beethoven'].includes(name)) return (1-k)*1 + k*0.7;
    if(name==='FilmScore') return 0.45 + 0.9*k;
    if(name==='Debussy')  return 0.3 + 0.7*k;
    return 1;
  });
}
function pick(r,arr,wts){ const sum=wts.reduce((a,b)=>a+b,0)||1; let x=r()*sum; for(let i=0;i<arr.length;i++){ if((x-=wts[i])<=0) return arr[i]; } return arr[arr.length-1]; }

/* Compose one movement into events starting at time T0 */
function composeMovement(rnd, opts){
  const {seconds, bpm, meter, key, mode, feel, startTime, profileBlend} = opts;
  const pool=orchForFixed(6);
  const scale=scaleFor(key, mode);
  const base=60;
  const beat=60/bpm, grid=4, step=beat/grid;
  const totalSteps = Math.round(seconds/step);
  const bars=barsForSeconds(bpm, seconds, meter);
  const cad=profileBlend.cad, stepWeights=profileBlend.step;

  const dens = FEEL[feel].dens, diss = FEEL[feel].diss;

  const events=[], drums=[];
  const slotStarts=new Map(), slotRoles=new Map();
  let deg=0, t=startTime;

  function slotKey(time){ return Math.round((time-startTime)/step); }
  function canPlace(inst,time){
    const k=slotKey(time);
    const c=slotStarts.get(k)||0; if(c>=MAX_VOICES) return false;
    const rs=slotRoles.get(k)||new Set(); const r=roleOf(inst);
    if(r==='bass'&&rs.has('bass'))return false;
    if(r==='bed' &&rs.has('bed')) return false;
    if(r==='sparkle'&&rs.has('sparkle'))return false;
    if(r==='lead'&&rs.has('lead')) return false;
    return true;
  }
  function mark(inst,time){
    const k=slotKey(time);
    slotStarts.set(k,(slotStarts.get(k)||0)+1);
    const rs=slotRoles.get(k)||new Set(); const r=roleOf(inst);
    if(r!=='other') rs.add(r); slotRoles.set(k,rs);
  }
  function leadStep(){
    const sizes=[1,2,3,4,5,7];
    const sz=pick(rnd,sizes,stepWeights);
    const dir=rnd()<0.55?1:-1;
    deg=clamp(deg+dir*sz,-10,10);
    return deg;
  }
  function dynAt(norm){
    // shaped per feel
    const A={
      fast:(x)=>0.58+0.30*Math.sin(2*Math.PI*x),
      medium:(x)=>0.52+0.28*Math.sin(1.6*Math.PI*x),
      slow:(x)=>0.45+0.35*Math.sin(1.1*Math.PI*x)
    };
    return clamp(A[feel](norm),0.15,1.0);
  }

  for(let s=0;s<totalSteps;s++){
    const local = s*step;
    const inBar = Math.floor((local/beat))%meter;     // 0..(meter-1)
    const at8   = (s%2===0);
    const atTri = (s%3===0);
    const down  = (inBar===0);
    const left  = (meter - inBar);
    let place=false;

    if(down && rnd()<0.98) place=true; else
    if(at8 && rnd()<dens) place=true; else
    if(atTri && rnd()<dens*0.35) place=true;

    if(left<=1 && rnd()<cad[2]) place=true;
    else if(left<=2 && rnd()<cad[1]) place=true;
    else if(left<=3 && rnd()<cad[0]) place=true;

    const norm = (local)/(seconds||1e-6);

    if(place){
      const d=leadStep();
      const lead=degToMidi(base+12,scale,d);
      const dur= step*( rnd()<0.2?4 : rnd()<0.5?2 : 1 );
      const instLead = pool[Math.floor(rnd()*pool.length)];
      const tt = startTime + local;
      if(canPlace(instLead, tt)){
        events.push({inst:instLead,time:tt,dur,midi:lead,vel:(0.65+0.35*rnd())*dynAt(norm),name:midiToName(lead)});
        mark(instLead, tt);
      }
      // light partner tone
      if(rnd()<(0.10 + diss*0.6)){
        const ivs = (feel==='fast')?[3,4,7,9,10]:[3,4,7,2];
        const iv = ivs[Math.floor(rnd()*ivs.length)];
        const inst2 = pool[Math.floor(rnd()*pool.length)];
        const t2 = tt + step*0.02;
        if(canPlace(inst2,t2)){
          events.push({inst:inst2,time:t2,dur:dur*0.95,midi:lead+iv,vel:0.55*dynAt(norm),name:midiToName(lead+iv)});
          mark(inst2,t2);
        }
      }
      // bed chords (strings) longer on slow/medium
      const hold = beat*(feel==='slow'?4:(rnd()<0.5?2:4));
      const root=degToMidi(base,scale, Math.round(d/2));
      const chord=[0,4,7];
      for(const iv of chord){
        if(canPlace('strings', tt)){
          events.push({inst:'strings',time:tt,dur:hold,midi:root+iv,vel:0.34*dynAt(norm),name:midiToName(root+iv)});
          mark('strings', tt);
        }
      }
      if(rnd()<0.30 && canPlace('strings', tt)){
        events.push({inst:'strings',time:tt,dur:hold,midi:root+10,vel:0.26*dynAt(norm),name:midiToName(root+10)});
        mark('strings', tt);
      }
    }

    // Bass
    if(down || (at8 && rnd()<0.22)){
      const bd=Math.round(deg/3);
      const bass=degToMidi(base-24,scale,bd);
      const dur= beat*(rnd()<0.5?1:2);
      const tt = startTime + local;
      if(canPlace('abass', tt)){
        events.push({inst:'abass',time:tt,dur:dur,midi:bass,vel:0.6*dynAt(norm),name:midiToName(bass)});
        mark('abass', tt);
        if(rnd()<0.35 && canPlace('abass', tt+step*2)){
          events.push({inst:'abass',time:tt+step*2,dur:dur,midi:bass+7,vel:0.52*dynAt(norm),name:midiToName(bass+7)});
          mark('abass', tt+step*2);
        }
      }
    }

    // Sparkle arpeggios
    if((feel!=='fast' || rnd()<0.1) && at8 && rnd()<0.12){
      const root=degToMidi(base+5, scale, Math.round(deg/2));
      const seq=[0,4,7,12];
      const inst = rnd()<0.6 ? 'harp' : 'glock';
      const tt0 = startTime + local;
      seq.forEach((iv,i)=>{
        const tt = tt0 + i*(step*0.5);
        if(canPlace(inst, tt)){
          events.push({inst,time:tt,dur:step*0.5,midi:root+iv,vel:0.44*dynAt(norm),name:midiToName(root+iv)});
          mark(inst, tt);
        }
      });
    }

    // Drums feel
    const dE = (feel==='fast')?0.8 : (feel==='medium'?0.55:0.25);
    const tt = startTime + local;
    if(rnd()<dE){
      if(down) drums.push({type:'kick',time:tt,vel:0.9*dynAt(norm)});
      if((meter===4 && (inBar===2)) || (meter===3 && inBar===1)) drums.push({type:'snare',time:tt+step*2,vel:0.6*dynAt(norm)});
      if(at8 && rnd()<0.7) drums.push({type:'hat',time:tt,vel:0.25*dynAt(norm)});
      if((meter===4 && (inBar===3)) || (meter===3 && inBar===2)) if(rnd()<0.10) drums.push({type:'cym',time:tt,vel:0.32*dynAt(norm)});
    }
  }
  return {events, drums};
}

/* Compose whole 1-minute piece from a K-template */
function composeK(rnd){
  // pick template
  const tmpl = K_TEMPLATES[Math.floor(rnd()*K_TEMPLATES.length)];
  const totalSeconds = 60.0;
  const weights = styleWeightsFixed();
  const blend = mixProfiles(weights);

  let t0=0;
  const parts=[];
  const allEvents=[], allDrums=[];
  let avgBpm=0, bpmAcc=0;

  tmpl.plan.forEach(mv=>{
    const secs = totalSeconds*mv.share;
    const bpm = Math.round(mv.bpm[0] + rnd()*(mv.bpm[1]-mv.bpm[0]));
    bpmAcc += bpm*secs/totalSeconds;
    const {events, drums} = composeMovement(rnd, {
      seconds:secs, bpm, meter:mv.meter, key:mv.key, mode:mv.mode, feel:mv.feel,
      startTime:t0, profileBlend:blend
    });
    allEvents.push(...events); allDrums.push(...drums);
    parts.push({name:mv.name, meter:mv.meter, bpm, seconds:secs, start:t0, end:t0+secs});
    t0 += secs;
  });

  const keyLabel = tmpl.plan[0].key + ' ' + (tmpl.plan[0].mode==='aeolian'?'minor':'major');
  return {
    events: allEvents, drums: allDrums,
    seconds: totalSeconds,
    bpm: Math.round(bpmAcc), key: keyLabel,
    template: tmpl.code+' — '+tmpl.title,
    movements: parts
  };
}

/* ========== Scheduler & UI ========== */
const $=id=>document.getElementById(id);
const TLM=$('timeline'); const CTX=TLM.getContext('2d'); const TIP=$('tip');

function initBuses(){ ['strings','woods','brass','harp','glock','abass','perc'].forEach((k,i)=>{ BUS[k]=BUS[k]||makeBus(k==='perc'?0.95:0.72,(i%2?0.12:-0.12)); }); }

function drawTimeline(score){
  const dpr=window.devicePixelRatio||1; const W=TLM.clientWidth*dpr, H=TLM.clientHeight*dpr; TLM.width=W; TLM.height=H; CTX.clearRect(0,0,W,H);
  const colors={strings:'#ffddb0',woods:'#c8ffc8',brass:'#ffd1d1',harp:'#ffe7f3',glock:'#e9ffbe',abass:'#ffd3a3',perc:'#b0b9c9'};
  const rows=['strings','woods','brass','harp','glock','abass','perc']; const rh=H/rows.length;
  // movement bands
  score.movements.forEach((mv,i)=>{
    const x0=(mv.start/score.seconds)*W, x1=(mv.end/score.seconds)*W;
    CTX.fillStyle=i%2? '#0b1436':'#0b1330';
    CTX.fillRect(x0,0,x1-x0,H);
    CTX.fillStyle='#8fb4ff'; CTX.font=`${12*dpr}px system-ui,Segoe UI,Arial`;
    CTX.fillText(`${mv.name}  ${mv.bpm} BPM  ${mv.meter}/4`, x0+6, 14*dpr);
  });
  // bar grid (coarse)
  CTX.strokeStyle="#1b2a66"; CTX.lineWidth=1;
  const beats=Math.max(1, Math.round(score.seconds/(60/ (score.bpm||100))));
  for(let i=0;i<=beats;i++){ const x=i*(W/beats); CTX.beginPath(); CTX.moveTo(x,0); CTX.lineTo(x,H); CTX.stroke(); }

  function rx(t){ return (t/score.seconds)*W; }
  score.events.forEach(e=>{ const ri=rows.indexOf(e.inst); if(ri<0) return; const x=rx(e.time), w=(e.dur/score.seconds)*W, y=ri*rh+rh*0.22, h=rh*0.56; CTX.fillStyle=colors[e.inst]||'#eee'; CTX.fillRect(x,y,Math.max(1.5,w),h); });
  score.drums.forEach(d=>{ const ri=rows.indexOf('perc'); const x=rx(d.time), y=ri*rh+rh*0.1; CTX.fillStyle=colors.perc; CTX.fillRect(x,y,Math.max(2,W/500),rh*0.8); });
}

function eventAtTime(score, t){
  let best=null, bestDur=1e9;
  for(const e of score.events){ if(t>=e.time && t<=e.time+e.dur){ if(e.dur<bestDur){ best=e; bestDur=e.dur; } } }
  return best;
}
TLM.addEventListener('mousemove',(ev)=>{
  if(!state.score) return;
  const rect=TLM.getBoundingClientRect(); const x=(ev.clientX-rect.left)/rect.width; const t=x*state.score.seconds;
  const e=eventAtTime(state.score,t);
  if(e){ TIP.textContent=`${e.inst} — ${e.name} (${Math.round(midiToHz(e.midi))} Hz)`; TIP.style.left=(ev.clientX+12)+'px'; TIP.style.top=(ev.clientY+12)+'px'; }
  else{ TIP.style.left='-9999px'; TIP.style.top='-9999px'; }
});
TLM.addEventListener('mouseleave',()=>{ TIP.style.left='-9999px'; TIP.style.top='-9999px'; });

function stopAll(){
  if(!playing) return; playing=false;
  const now=ACTX?ACTX.currentTime:0;
  scheduled.forEach(n=>{ try{ if(n.g){ n.g.gain.cancelScheduledValues(now); n.g.gain.linearRampToValueAtTime(0, now+0.05); } (n.o||[]).forEach(o=>{ try{o.stop(now+0.06);}catch(e){} }); }catch(e){} });
  scheduled.length=0;
}

/* Build movement table */
function renderMovementTable(info){
  const el=$('movetable');
  const rows = info.movements.map((m,i)=>`<tr><td>${i+1}</td><td><b>${m.name}</b></td><td>${m.bpm} BPM</td><td>${m.meter}/4</td><td>${m.seconds.toFixed(1)} s</td></tr>`).join('');
  el.innerHTML = `<tr><th>#</th><th>Movement</th><th>Tempo</th><th>Meter</th><th>Section Length</th></tr>${rows}`;
}

/* ===== Offline WAV render (unchanged synth) ===== */
async function renderWav(score){
  await unlockAudio();
  const sr=44100, len=score.seconds+2;
  const ctx=new OfflineAudioContext(2, Math.ceil(len*sr), sr);
  const master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination);
  const send=ctx.createGain(); send.gain.value=0.25; const d=ctx.createDelay(1); d.delayTime.value=0.04; const g=ctx.createGain(); g.gain.value=0.6; d.connect(g); g.connect(d);
  const sum=ctx.createGain(); d.connect(sum); sum.connect(master); send.connect(d);
  function mkBus(level){ const g=ctx.createGain(); g.gain.value=level; g.connect(master); const s=ctx.createGain(); s.gain.value=0.2; g.connect(s); s.connect(send); return {g}; }
  const B={}; ['strings','woods','brass','harp','glock','abass','perc'].forEach(k=>B[k]=mkBus(k==='perc'?0.9:0.7));
  function hz(m){ return 440*Math.pow(2,(m-69)/12); }
  function ev(g,t0,a,d,s,hold,rel,vel){ const t1=t0+a,t2=t1+d,t3=t2+hold,t4=t3+rel; g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(vel,t1); g.gain.linearRampToValueAtTime(vel*s,t2); g.gain.setValueAtTime(vel*s,t3); g.gain.linearRampToValueAtTime(0,t4); }
  function osc(type,f){ const o=ctx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
  function add(inst,m,when,dur,vel){
    const addOsc=(type,f,a,d,s,h,r,v,bus)=>{ const o=osc(type,f),g=ctx.createGain(); ev(g,when,a,d,s,h,r,vel*v); o.connect(g); g.connect(B[bus].g); o.start(when); o.stop(when+a+d+h+r+0.02); };
    if(inst==='strings'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200; const g=ctx.createGain();
      ev(g,when,0.08,0.5,0.8,Math.max(0.05,dur-0.4),0.3,0.6*vel); o.connect(f); f.connect(g); g.connect(B.strings.g); o.start(when); o.stop(when+dur+0.6); }
    else if(inst==='woods'){ const o=osc('square',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400; const g=ctx.createGain();
      ev(g,when,0.03,0.22,0.55,Math.max(0.05,dur-0.25),0.2,0.6*vel); o.connect(f); f.connect(g); g.connect(B.woods.g); o.start(when); o.stop(when+dur+0.3); }
    else if(inst==='brass'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800; const g=ctx.createGain();
      ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,0.8*vel); o.connect(f); f.connect(g); g.connect(B.brass.g); o.start(when); o.stop(when+dur+0.4); }
    else if(inst==='harp') addOsc('triangle',hz(m),0.002,0.22,0.35,0.01,0.4,0.7,'harp');
    else if(inst==='glock') addOsc('sine',hz(m)*2,0.001,0.4,0.25,0.02,0.8,0.6,'glock');
    else if(inst==='abass') addOsc('triangle',hz(m),0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,0.7,'abass');
  }
  // schedule
  score.events.forEach(e=>add(e.inst,e.midi,e.time+0.05,e.dur,e.vel));
  score.drums.forEach(d=>{
    if(d.type==='kick'){ const o=osc('sine',130); o.frequency.setValueAtTime(130,d.time); o.frequency.exponentialRampToValueAtTime(40,d.time+0.12);
      const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.9,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.18); o.connect(g); g.connect(B.perc.g); o.start(d.time); o.stop(d.time+0.2); }
    if(d.type==='snare'){ const s=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*0.2,ctx.sampleRate); const ch=b.getChannelData(0);
      for(let i=0;i<ch.length;i++) ch[i]=Math.random()*2-1; s.buffer=b; const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ctx.createGain();
      g.gain.setValueAtTime(d.vel*0.5,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.2); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+0.2); }
    if(d.type==='hat'){ const s=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*0.08,ctx.sampleRate); const ch=b.getChannelData(0);
      for(let i=0;i<ch.length;i++) ch[i]=Math.random()*2-1; s.buffer=b; const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ctx.createGain();
      g.gain.setValueAtTime(d.vel*0.25,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.08); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+0.08); }
    if(d.type==='cym'){ const s=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*1.5,ctx.sampleRate); const ch=b.getChannelData(0);
      for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*0.6; s.buffer=b; const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=4000; const g=ctx.createGain();
      g.gain.setValueAtTime(d.vel*0.3,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+1.5); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+1.5); }
  });
  const buf=await ctx.startRendering();

  // WAV encode
  function interleave(L,R){ const out=new Float32Array(L.length+R.length); for(let i=0,j=0;i<L.length;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; } return out; }
  function f32To16(view,off,data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); s=s<0?s*0x8000:s*0x7FFF; view.setInt16(off,s,true);} }
  function w(view,off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i,str.charCodeAt(i)); }
  const L=buf.getChannelData(0), R=buf.getChannelData(1), inter=interleave(L,R);
  const ab=new ArrayBuffer(44+inter.length*2), dv=new DataView(ab);
  w(dv,0,'RIFF'); dv.setUint32(4,36+inter.length*2,true); w(dv,8,'WAVE'); w(dv,12,'fmt '); dv.setUint32(16,16,true);
  dv.setUint16(20,1,true); dv.setUint16(22,2,true); dv.setUint32(24,sr,true); dv.setUint32(28,sr*4,true);
  dv.setUint16(32,4,true); dv.setUint16(34,16,true); w(dv,36,'data'); dv.setUint32(40,inter.length*2,true);
  f32To16(dv,44,inter);
  return new Blob([dv],{type:'audio/wav'});
}

/* ===== Controls & State ===== */
let state={score:null};

function updateStatus(sc){
  $('bpmOut').textContent=Math.round(sc.bpm);
  $('lenOut').textContent=sc.seconds.toFixed(1)+' s (~1:00)';
  $('keyOut').textContent=sc.key;
  $('tmplOut').textContent=sc.template;
  // movement table
  renderMovementTable(sc);
  // tooltip of first notes
  const firstNames=sc.events.slice(0,120).map(e=>e.name).filter(Boolean);
  $('keyOut').title='First notes: '+firstNames.slice(0,20).join(', ');
}
function clearStatus(){
  ['bpmOut','lenOut','keyOut','tmplOut'].forEach(id=>$(id).textContent='–');
  $('keyOut').title=''; $('movetable').innerHTML='';
}

const TLM_CANVAS=$('timeline'); const CTX2=TLM_CANVAS.getContext('2d');

$('gen').addEventListener('click', async ()=>{
  await unlockAudio(); ensureAudio(); initBuses();
  const rnd=rngFromSeed(hash32(makeCSTSeed()));
  state.score=composeK(rnd);
  drawTimeline(state.score);
  updateStatus(state.score);
});

$('play').addEventListener('click', async ()=>{
  await unlockAudio(); ensureAudio(); initBuses();
  if(!state.score) $('gen').click();
  if(playing) return;
  const start=ACTX.currentTime+0.25; playing=true; scheduled.length=0;
  const score=state.score; const jitter=12/1000;

  const playMap={strings:Patches.strings, woods:Patches.woods, brass:Patches.brass, harp:Patches.harp, glock:Patches.glock, abass:Patches.abass};
  score.events.forEach(ev=>{ const when=start+ev.time+(Math.random()*2-1)*jitter; const fn=playMap[ev.inst]; if(fn) fn(ev.midi,when,ev.dur,clamp(ev.vel,0,1)); });
  score.drums.forEach(d=>{ const t=start+d.time+(Math.random()*2-1)*jitter*0.5;
    if(d.type==='kick') Drums.kickAt(t,d.vel);
    if(d.type==='snare') Drums.snareAt(t,d.vel);
    if(d.type==='hat') Drums.hatAt(t,d.vel);
    if(d.type==='cym') Drums.cymbalAt(t,d.vel);
  });
  setTimeout(()=>stopAll(), (score.seconds+1.6)*1000);
});

$('reset').addEventListener('click', ()=>{
  stopAll();
  state.score=null;
  clearStatus();
  const dpr=window.devicePixelRatio||1; TLM.width=TLM.clientWidth*dpr; TLM.height=TLM.clientHeight*dpr; CTX.clearRect(0,0,TLM.width,TLM.height);
  TIP.style.left='-9999px'; TIP.style.top='-9999px';
});

$('export').addEventListener('click', async ()=>{
  if(!state.score) $('gen').click();
  const blob=await renderWav(state.score);
  const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`CST_Astrodumus_${state.score.template.replace(/\s+/g,'_')}_1min.wav`; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),5000);
});

/* Auto-unlock on first pointer (mobile-safe) */
window.addEventListener('pointerdown', unlockAudio, {once:true});
</script>
</body>
</html>
