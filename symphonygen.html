<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST LIVE Symphony ‚Äî 1-Minute Orchestral Follower (Single Composer ‚Ä¢ Notes/Audio Influence)</title>
<meta name="description" content="Upload notes or audio, analyze structure, then render a coherent 1-minute symphonic version with CST timing, emotions, movements, and a single composer style."/>
<style>
  :root{
    --bg:#081022; --panel:#0f1636; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#1a2658; --btn:#15235a;
    --ok:#153560; --warn:#5b3d00; --border:#274a9a; --live:#10b981; --line:#ffd54a;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:18px}
  h1{margin:0 0 6px;font-size:1.35rem}
  p.sub{margin:0 0 12px;color:var(--muted)}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.25);overflow:hidden;margin-bottom:12px}
  .pad{padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{background:var(--btn);color:var(--ink);border:1px solid var(--border);border-radius:12px;padding:10px 14px;cursor:pointer;transition:.2s}
  button:disabled{opacity:.55;cursor:not-allowed}
  button:hover:not(:disabled){filter:brightness(1.08)}
  #live.live-on{background:var(--live);border-color:#0a8f68;color:#062a20;box-shadow:0 0 0 3px rgba(16,185,129,.25), 0 0 18px rgba(16,185,129,.35)}
  #live.live-on::after{content:" ‚óè"; font-weight:900}
  .status{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-top:10px}
  .status>div{background:#0b1333;border:1px solid var(--grid);border-radius:10px;padding:10px;min-height:54px}
  .tiny{font-size:.85rem;color:var(--muted)}
  .cols{display:grid;grid-template-columns:1.15fr .85fr;gap:12px}
  .secTitle{font-weight:600;margin:6px 0 8px}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;align-items:center}
  .kv label{color:var(--muted)}
  input[type="range"]{width:100%}
  select, input[type="text"]{background:#0b1333;border:1px solid var(--grid);color:var(--ink);border-radius:10px;padding:8px 10px}
  #msg{display:none;margin-left:8px;padding:6px 10px;border-radius:10px;border:1px solid var(--border)}
  .panelTitle{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .instGrid{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .instRow{display:flex;align-items:center;gap:8px;padding:6px 8px;background:#0b1333;border:1px solid var(--grid);border-radius:10px}
  .instRow label{flex:1}
  .tag{font-size:.75rem;color:#cde;border:1px solid #2a3f8f;border-radius:8px;padding:1px 8px}
  .help{background:#0b1333;border:1px solid var(--grid);border-radius:10px;padding:10px}
  .note{font-size:.85rem;color:#c9d6ff}

  .lineWrap{margin-bottom:10px}
  #playline{width:100%;height:8px;display:block;background:#0b1333;border:1px solid var(--grid);border-radius:999px}

  #export.btn-wav{font-weight:600; letter-spacing:.2px; display:inline-flex; align-items:center; gap:10px;
    padding:12px 16px; border-radius:14px; transform:translateZ(0);}
  #export.btn-wav .icon{display:inline-flex} #export.btn-wav .txt{white-space:nowrap}

  .mixRow{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .inlineBtns{display:flex;gap:8px;align-items:center}
  #willPlay{display:grid;grid-template-columns:1fr 1fr;gap:6px 14px}

  #timeline{width:100%;height:260px;display:block;background:linear-gradient(180deg,#0b1536,#0b1230)}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST LIVE Symphony ‚Äî 1-Minute Orchestral Follower</h1>
  <div class="lineWrap"><canvas id="playline" title="0 ‚Üí 60 seconds progress"></canvas></div>
  <p class="sub">Upload <b>Audio</b> or <b>Composer Notes</b> ‚Üí Analyze ‚Üí Generate ‚Üí <b>LIVE ‚Äî PLAY</b>. Use a single composer style.</p>

  <section class="card">
    <div class="pad">
      <div class="row">
        <!-- Audio path -->
        <input id="fileAudio" type="file" accept="audio/*"/>
        <button id="analyzeAudio" title="Analyze first 60s of audio">Analyze Audio</button>

        <!-- Notes path -->
        <input id="fileNotes" type="file" accept=".txt,.json"/>
        <button id="analyzeNotes" title="Analyze uploaded note patterns (.txt/.json)">Analyze Notes</button>

        <!-- Playback -->
        <button id="live" disabled>LIVE ‚Äî PLAY</button>
        <button id="stop">Stop</button>
        <button id="reset">Reset</button>

        <!-- Generation -->
        <button id="genCompose" title="Generate 60s composition (no uploads)">Generate (Compose)</button>
        <button id="genFromNotes" title="Generate using analyzed notes">Generate (Use Notes)</button>
        <button id="genFromAudio" title="Generate using analyzed audio">Generate (Use Music)</button>

        <!-- Export / Print / Save -->
        <button id="export" class="btn-wav" title="Render the 1-minute symphony to WAV and download">
          <span class="icon" aria-hidden="true">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 3a1 1 0 011 1v8.586l2.293-2.293a1 1 0 111.414 1.414l-4.007 4.007a1 1 0 01-1.414 0L7.279 11.707A1 1 0 018.693 10.293L11 12.586V4a1 1 0 011-1z"/>
              <path d="M5 14a1 1 0 011-1h12a1 1 0 011 1v4.5A2.5 2.5 0 0116.5 21h-9A2.5 2.5 0 015 18.5V14z"/>
            </svg>
          </span>
          <span class="txt">Download WAV</span>
        </button>

        <button id="printNotes" title="Print the 60s score">üñ®Ô∏è Print Notes</button>
        <button id="saveSel">üíæ Save Selection</button>
        <button id="selfTest" title="Run quick wiring checks">üß™ Self-Test</button>
        <span id="msg"></span>
      </div>

      <div class="status">
        <div><b>BPM</b><div id="bpm" class="tiny">‚Äì</div></div>
        <div><b>Length</b><div id="len" class="tiny">‚Äì</div></div>
        <div><b>Cadence</b><div id="cadOut" class="tiny">Random</div></div>
        <div><b>Emotion</b><div id="emoOut" class="tiny">Auto</div></div>
        <div><b>Composer</b><div id="compOut" class="tiny">Mozart</div></div>
        <div><b>Will Play</b><div id="willPlay" class="tiny" style="min-height:54px"></div></div>
      </div>
    </div>
    <canvas id="timeline" title="Timeline of instruments & notes"></canvas>
  </section>
  <section class="card">
    <div class="pad cols">
      <div>
        <div class="panelTitle">
          <div class="secTitle">Orchestration (Select/Deselect)</div>
          <div class="row">
            <button id="allOn">All On</button>
            <button id="allOff">All Off</button>
          </div>
        </div>
        <div id="instList" class="instGrid"></div>
      </div>

      <div>
        <div class="secTitle">Composer & Influence</div>
        <div class="kv">
          <label for="composer">Composer</label>
          <select id="composer"></select>

          <label>Actions</label>
          <div class="inlineBtns">
            <button id="btnExplainNotes">How to format notes</button>
          </div>
        </div>

        <div class="secTitle" style="margin-top:12px">Form, Emotion, Movements & Equations</div>
        <div class="kv">
          <label for="cadence">Cadence</label>
          <select id="cadence">
            <option value="random">Random (safe)</option>
            <option value="I-IV-V-I">I‚ÄìIV‚ÄìV‚ÄìI</option>
            <option value="I-vi-IV-V">I‚Äìvi‚ÄìIV‚ÄìV</option>
            <option value="ii-V-I">ii‚ÄìV‚ÄìI</option>
            <option value="I-V-vi-IV">I‚ÄìV‚Äìvi‚ÄìIV</option>
            <option value="authentic">Authentic (V‚ÄìI)</option>
            <option value="plagal">Plagal (IV‚ÄìI)</option>
            <option value="half">Half (‚Üí V)</option>
            <option value="phrygian_half">Phrygian Half (iv6‚ÄìV)</option>
            <option value="deceptive">Deceptive (V‚Äìvi)</option>
            <option value="custom">Custom‚Ä¶</option>
          </select>

          <label for="cadenceCustom">Custom (I, IV, V or 0..11)</label>
          <input id="cadenceCustom" class="mono" placeholder="I, IV, V, I" disabled/>

          <label for="pace">Pace</label>
          <select id="pace">
            <option value="calm">Calm</option>
            <option value="medium" selected>Medium</option>
            <option value="urgent">Urgent</option>
          </select>

          <label for="movement">Symphony Movement</label>
          <select id="movement">
            <option value="I">I ‚Äî Allegro</option>
            <option value="II">II ‚Äî Andante</option>
            <option value="III">III ‚Äî Scherzo</option>
            <option value="IV" selected>IV ‚Äî Finale</option>
          </select>

          <label for="tempoFactor">Tempo Factors</label>
          <select id="tempoFactor">
            <option value="intent" selected>Composer‚Äôs intent</option>
            <option value="structure">Movement structure</option>
            <option value="performance">Performance choices</option>
            <option value="exceptions">Exceptions</option>
          </select>

          <label for="emotion">Emotion</label>
          <select id="emotion">
            <option value="auto" selected>Auto (from audio)</option>
            <option value="happy">Happy</option>
            <option value="sad">Sad</option>
            <option value="angry">Angry</option>
            <option value="spooky">Spooky</option>
            <option value="calm">Calm</option>
          </select>

          <label for="emoInt">Emotion intensity</label>
          <div><input id="emoInt" type="range" min="0" max="1" step="0.05" value="0.6"/><div class="tiny">= <span id="emoIntVal">0.60</span></div></div>

          <label for="swing">Swing (1=straight)</label>
          <div><input id="swing" type="range" min="1.00" max="1.50" step="0.01" value="1.10"/><div class="tiny">= <span id="swingVal">1.10</span></div></div>

          <label for="dotTri">Dotted/Tri tilt</label>
          <div><input id="dotTri" type="range" min="-0.4" max="0.6" step="0.05" value="0.30"/><div class="tiny">= <span id="dotTriVal">0.30</span></div></div>

          <label>Voices per beat</label>
          <div>
            <input id="vmin" type="range" min="1" max="6" step="1" value="1"/> <span class="tiny" id="vminVal">1</span><br/>
            <input id="vmax" type="range" min="2" max="8" step="1" value="4"/> <span class="tiny" id="vmaxVal">4</span>
            <div class="tiny">range: <span id="vb">1‚Äì4</span></div>
          </div>

          <label for="bassDepth">Bass depth</label>
          <div><input id="bassDepth" type="range" min="0.8" max="1.8" step="0.05" value="1.15"/><div class="tiny">= <span id="bassDepthVal">1.15</span></div></div>

          <label for="toneBias">Tone bias (high ‚Üî low)</label>
          <div><input id="toneBias" type="range" min="-1" max="1" step="0.1" value="0"/><div class="tiny">= <span id="toneBiasVal">0.0</span></div></div>

          <label for="percAmt">Percussion amount</label>
          <div><input id="percAmt" type="range" min="0" max="1" step="0.05" value="0.4"/><div class="tiny">= <span id="percAmtVal">0.40</span></div></div>
        </div>

        <div class="help" style="margin-top:10px">
          <b>Notes</b>
          <ul class="note">
            <li><b>Single composer</b> only. The chosen composer shapes melodic motion.</li>
            <li><b>Generate</b> builds notes; then <b>LIVE ‚Äî PLAY</b> plays them. <b>üñ®Ô∏è Print Notes</b> prints the 60s score.</li>
            <li>Notes upload: <code>.txt</code> with <i>time_s,pitch_midi,dur_s</i> per line, or <code>.json</code> with <code>{notes:[{time,midi,dur},‚Ä¶]}</code>.</li>
          </ul>
        </div>
      </div>
    </div>
  </section>
<script>
/* ======= Small DOM helpers ======= */
const $ = (id)=>document.getElementById(id);
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function setMsg(t,kind='ok'){ const el=$('msg'); if(!el) return; el.style.display='inline-block'; el.textContent=t; el.style.background = kind==='warn' ? '#5b3d00' : '#153560'; el.style.borderColor = kind==='warn' ? '#ffb84d' : '#274a9a'; }
function clearMsg(){ const el=$('msg'); if(!el) return; el.style.display='none'; }
function setLiveOn(on){ const b=$('live'); if(!b) return; if(on){ b.classList.add('live-on'); } else { b.classList.remove('live-on'); } }

/* ======= Top line (60s progress) ======= */
const LINE = $('playline'); const LCTX = LINE.getContext('2d');
let rafId=null, playStart=0, playLen=60, lineActive=false, playTimer=null;
const MAX_ANALYZE_SECONDS = 60, MAX_PLAY_SECONDS=60;

function drawLine(p){
  const dpr=window.devicePixelRatio||1, W=LINE.clientWidth*dpr, H=LINE.clientHeight*dpr;
  LINE.width=W; LINE.height=H; LCTX.clearRect(0,0,W,H);
  LCTX.fillStyle='#0b1333'; LCTX.fillRect(0,0,W,H);
  LCTX.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--line')||'#ffd54a';
  LCTX.fillRect(0,0,Math.max(0,Math.min(W, W*p)),H);
}
function startLine(seconds){ playLen = Math.max(1, Math.min(MAX_PLAY_SECONDS, seconds||MAX_PLAY_SECONDS)); playStart=performance.now(); lineActive=true; loopLine(); }
function stopLine(){ lineActive=false; if(rafId) cancelAnimationFrame(rafId); drawLine(0); }
function loopLine(){
  if(!lineActive) return;
  const t=(performance.now()-playStart)/1000, p=t/playLen;
  drawLine(p);
  if(t>=Math.min(playLen, MAX_PLAY_SECONDS)){ lineActive=false; try{ stopAll(); }catch(e){} return; }
  rafId=requestAnimationFrame(loopLine);
}

/* ======= Composers ======= */
const COMPOSERS = [
  'Mozart','Beethoven','Bach','Haydn','Schubert','Chopin','Brahms','Tchaikovsky',
  'Debussy','Ravel','Stravinsky','Vivaldi','Handel','Schumann','Liszt','Mahler',
  'Prokofiev','Shostakovich','Rachmaninoff','Williams','Zimmer'
];
const composerHookSingle = {
  Mozart: (root)=>[0,4,7,12],
  Beethoven:(root)=>[0,7,12],
  Bach:   (root)=>[0,4,7,11],
  Haydn:  (root)=>[0,5,9],
  Schubert:(root)=>[0,3,7,12],
  Chopin: (root)=>[0,4,8,12],
  Brahms: (root)=>[0,4,7,9],
  Tchaikovsky:(root)=>[0,2,7,12],
  Debussy:(root)=>[0,2,4,7,9],
  Ravel:  (root)=>[0,5,10],
  Stravinsky:(root)=>[0,1,5,7,11],
  Vivaldi:(root)=>[0,7,12,19],
  Handel: (root)=>[0,4,7,12],
  Schumann:(root)=>[0,3,7,10],
  Liszt:  (root)=>[0,7,12,19],
  Mahler: (root)=>[0,4,7,9,12],
  Prokofiev:(root)=>[0,1,7,12],
  Shostakovich:(root)=>[0,1,6,7,12],
  Rachmaninoff:(root)=>[0,4,7,11,12],
  Williams:(root)=>[0,4,7,12,14],
  Zimmer: (root)=>[0,7,14,21]
};

/* ======= Orchestra ======= */
const ORCH = [
  {name:'violin', type:'bowed', role:'lead'},
  {name:'viola', type:'bowed', role:'counter'},
  {name:'cello', type:'bowed', role:'bed'},
  {name:'double_bass', label:'Double Bass', type:'bass', role:'bass'},
  {name:'harp', type:'pluck', role:'sparkle'},
  {name:'flute', type:'reed', role:'lead'},
  {name:'alto_flute', label:'Alto Flute', type:'reed', role:'bed'},
  {name:'piccolo', type:'reed', role:'sparkle'},
  {name:'oboe', type:'reed', role:'lead'},
  {name:'english_horn', label:'English Horn', type:'reed', role:'counter'},
  {name:'clarinet', type:'reed', role:'counter'},
  {name:'bass_clarinet', label:'Bass Clarinet', type:'reed', role:'bed'},
  {name:'bassoon', type:'reed', role:'bed'},
  {name:'contrabassoon', label:'Contrabassoon', type:'reed', role:'bass'},
  {name:'horn', label:'French Horn', type:'brass', role:'bed'},
  {name:'trumpet', type:'brass', role:'lead'},
  {name:'cornet', type:'brass', role:'lead'},
  {name:'trombone', type:'brass', role:'counter'},
  {name:'bass_trombone', label:'Bass Trombone', type:'brass', role:'bass'},
  {name:'tuba', type:'brass', role:'bass'},
  {name:'euphonium', type:'brass', role:'bed'},
  {name:'timpani', type:'perc', role:'perc'},
  {name:'snare', type:'perc', role:'perc'},
  {name:'bass_drum', label:'Bass Drum', type:'perc', role:'perc'},
  {name:'cymbals', type:'perc', role:'perc'},
  {name:'triangle', type:'perc', role:'perc'},
  {name:'tambourine', type:'perc', role:'perc'},
  {name:'tam_tam', label:'Tam-tam', type:'perc', role:'perc'},
  {name:'xylophone', type:'pluck', role:'sparkle'},
  {name:'glockenspiel', type:'bell', role:'sparkle'},
  {name:'chimes', type:'bell', role:'sparkle'},
  {name:'vibraphone', type:'bell', role:'sparkle'},
  {name:'marimba', type:'pluck', role:'sparkle'},
  {name:'piano', type:'pluck', role:'bed'},
  {name:'celesta', type:'pluck', role:'sparkle'},
  {name:'harpsichord', type:'pluck', role:'sparkle'},
  {name:'organ', type:'organ', role:'bed'},
  {name:'saxophone', type:'reed', role:'counter'}
];
const ORCH_MASTER = ORCH.map(i=>i.name);
function labelOf(inst){ return inst?.label || (inst?.name||'').replace(/_/g,' ').replace(/\b\w/g,m=>m.toUpperCase()); }
function getType(instName){ const meta = ORCH.find(i=>i.name===instName); return meta?meta.type:'bowed'; }
function getRole(instName){ const meta = ORCH.find(i=>i.name===instName); return meta?meta.role:'bed'; }

/* ======= Unlock schedule (role ‚Üí earliest time in seconds) ======= */
const UNLOCK_SCHEDULE = {
  lead: 0,            // Strings/lead at t=0
  bed: 6,             // Winds/Horns pads at t=6
  counter: 12,        // Brass/trombone lines at t=12
  bass: 18,           // Low brass/basses at t=18
  perc: 24,           // Percussion at t=24
  sparkle: 30         // Celesta/Glock/Harp/etc at t=30
};

/* ======= Selection & persistence ======= */
let INST_SELECTION = {}; // name -> bool
const LS_KEY='cst_orch_selection_singleComposer_v2';

function saveAllSelections(){
  const data={
    inst:INST_SELECTION,
    cadence:$('cadence').value, cadenceCustom:$('cadenceCustom').value,
    pace:$('pace').value, movement:$('movement').value, tempoFactor:$('tempoFactor').value,
    emotion:$('emotion').value, emoInt:$('emoInt').value,
    swing:$('swing').value, dotTri:$('dotTri').value,
    vmin:$('vmin').value, vmax:$('vmax').value,
    bassDepth:$('bassDepth').value, toneBias:$('toneBias').value, percAmt:$('percAmt').value,
    composer:$('composer').value
  };
  localStorage.setItem(LS_KEY, JSON.stringify(data));
  setMsg('All selections saved.');
}
function loadAllSelections(){
  try{
    const raw=localStorage.getItem(LS_KEY); if(!raw) return;
    const d=JSON.parse(raw)||{};
    INST_SELECTION=d.inst||INST_SELECTION;
    ['cadence','cadenceCustom','pace','movement','tempoFactor','emotion','emoInt','swing','dotTri','vmin','vmax','bassDepth','toneBias','percAmt','composer'].forEach(id=>{
      if($(id) && d[id]!=null){ $(id).value = d[id]; }
    });
    if($('cadence').value==='custom'){ $('cadenceCustom').disabled=false; }
    if(d.composer) $('compOut').textContent=d.composer;
  }catch(e){}
}

/* ======= UI builders ======= */
function buildComposerDropdown(){
  const c=$('composer'); if(!c) return; c.innerHTML='';
  COMPOSERS.forEach(name=>{ const o=document.createElement('option'); o.value=name; o.textContent=name; c.appendChild(o); });
  if(!c.value) c.value='Mozart';
  $('compOut').textContent = c.value;
}
function buildInstList(){
  const box = $('instList'); if(!box) return; box.innerHTML='';
  ORCH.forEach(inst=>{
    if(!INST_SELECTION.hasOwnProperty(inst.name)) INST_SELECTION[inst.name]=true;
    const row=document.createElement('div'); row.className='instRow';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked = !!INST_SELECTION[inst.name];
    cb.addEventListener('change', ()=>{ INST_SELECTION[inst.name]=cb.checked; updateWillPlayListFromSelection(); });
    const lbl=document.createElement('label'); lbl.textContent=labelOf(inst);
    const tag=document.createElement('span'); tag.className='tag'; tag.textContent = inst.role;
    row.appendChild(cb); row.appendChild(lbl); row.appendChild(tag);
    box.appendChild(row);
  });
}
function selectAll(v=true){ ORCH_MASTER.forEach(n=>INST_SELECTION[n]=v); buildInstList(); updateWillPlayListFromSelection(); if(!v) setMsg('All instruments disabled.','warn'); else setMsg('All instruments enabled.'); }
function updateWillPlayListFromSelection(){
  const box=$('willPlay'); if(!box) return;
  const allowed = ORCH.filter(i=>INST_SELECTION[i.name]).map(i=> labelOf(i));
  box.innerHTML = allowed.map(n=>`<div>${n}</div>`).join('');
}

/* ======= Timeline canvas ======= */
const TLM = document.getElementById('timeline'); 
const CTX = TLM ? TLM.getContext('2d') : null;
function drawTimeline(score){
  if(!TLM || !CTX || !score) return;
  const dpr=window.devicePixelRatio||1; 
  const W=TLM.clientWidth*dpr, H=TLM.clientHeight*dpr; 
  TLM.width=W; TLM.height=H; CTX.clearRect(0,0,W,H);

  const labelW = Math.floor(140*dpr);
  const areaW = W - labelW;

  const rows = Array.from(new Set(score.events.map(e=>e.inst)));
  if(!rows.length){ return; }
  const rh = H/rows.length;
  const colors = {}; rows.forEach((r,i)=>colors[r]=`hsl(${(i*47)%360} 70% 72%)`);

  CTX.fillStyle='#cfe3ff'; CTX.font=`${Math.max(10,Math.floor(12*dpr))}px system-ui,Segoe UI,Roboto,Arial`;
  rows.forEach((name,i)=>{
    const y = i*rh + rh*0.6;
    CTX.fillText((labelOf(ORCH.find(x=>x.name===name)||{name})), 8*dpr, y);
    CTX.strokeStyle="#1b2a66"; CTX.lineWidth=1; CTX.beginPath(); CTX.moveTo(labelW, i*rh); CTX.lineTo(W, i*rh); CTX.stroke();
  });

  CTX.strokeStyle="#1b2a66"; CTX.lineWidth=1;
  const beats = Math.max(1, Math.round(score.seconds/(60/score.bpm)));
  for(let i=0;i<=beats;i++){ 
    const x=labelW + i*(areaW/beats); 
    CTX.beginPath(); CTX.moveTo(x,0); CTX.lineTo(x,H); CTX.stroke(); 
  }
  const rx = t => labelW + (t/score.seconds)*areaW;

  score.events.forEach(e=>{
    const ri=rows.indexOf(e.inst); if(ri<0) return; 
    const y=ri*rh+rh*0.2, h=rh*0.6;
    if(e.type==='perc'){
      const x=rx(e.time);
      CTX.strokeStyle=colors[e.inst]; 
      CTX.lineWidth=Math.max(1, dpr);
      CTX.beginPath(); CTX.moveTo(x, y); CTX.lineTo(x, y+h); CTX.stroke();
    }else{
      const x=rx(e.time), w=Math.max(1.5,(e.dur/score.seconds)*areaW);
      CTX.fillStyle=colors[e.inst]; 
      CTX.fillRect(x,y,w,h);
    }
  });
}

/* ======= Audio scaffolding ======= */
let ACTX=null, master=null, BUS={}, scheduled=[], playing=false;
function ensureAudio(){ if(ACTX) return; ACTX = new (window.AudioContext||window.webkitAudioContext)(); master = ACTX.createGain(); master.gain.value=0.9; master.connect(ACTX.destination); }
async function unlockAudio(){ ensureAudio(); try{ await ACTX.resume(); }catch(e){} }
function makeBus(level,pan=0){ const g=ACTX.createGain(); g.gain.value=level; const p=ACTX.createStereoPanner?ACTX.createStereoPanner():null; if(p){ p.pan.value=pan; g.connect(p); p.connect(master); } else { g.connect(master); } return {g}; }
function stopAll(){
  if(playTimer){ clearTimeout(playTimer); playTimer=null; }
  if(!playing) { stopLine(); setLiveOn(false); return; }
  playing=false; setLiveOn(false); stopLine();
  const now=ACTX?ACTX.currentTime:0;
  scheduled.forEach(n=>{ try{
    if(n.g){ n.g.gain.cancelScheduledValues(now); n.g.gain.linearRampToValueAtTime(0, now+0.05); }
    (n.o||[]).forEach(o=>{ try{o.stop(now+0.06);}catch(e){} });
  }catch(e){} });
  scheduled.length=0;
}
function initBuses(){ ORCH_MASTER.forEach((k,i)=>{ BUS[k]=BUS[k]||makeBus(0.7,(i%2?0.08:-0.08)); }); }

/* ======= Simple synth patches (kept lightweight) ======= */
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function envGain(g,t0,a,d,sus,hold,rel,amp){
  const t1=t0+a, t2=t1+d, t3=t2+hold, t4=t3+rel;
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(amp,t1);
  g.gain.linearRampToValueAtTime(amp*sus,t2);
  g.gain.setValueAtTime(amp*sus,t3);
  g.gain.linearRampToValueAtTime(0,t4);
  return t4;
}
const PATCH = {
  bowed:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200;
    const g=ACTX.createGain(); const end=envGain(g,when,0.04,0.45,0.8,Math.max(0.05,dur-0.4),0.3,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  reed:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=envGain(g,when,0.03,0.22,0.55,Math.max(0.05,dur-0.25),0.2,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  brass:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
    const g=ACTX.createGain(); const end=envGain(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  pluck:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.002,0.22,0.35,0.01,0.4,vel*0.6);
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  bell:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.002,0.6,0.3,0.02,1.2,vel*0.6);
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  organ:(bus,m,when,dur,vel)=>{ const o1=ACTX.createOscillator(), o2=ACTX.createOscillator(); o1.type='sine'; o2.type='sine';
    o1.frequency.value=midiToHz(m); o2.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=envGain(g,when,0.05,0.5,0.85,Math.max(0.05,dur-0.45),0.35,vel*0.55);
    o1.connect(g); o2.connect(g); g.connect(BUS[bus].g); o1.start(when); o2.start(when); o1.stop(end); o2.stop(end); scheduled.push({o:[o1,o2],g,end}); },
  bass:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,vel*0.65*(+$('bassDepth').value));
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  // Perc
  k:(t,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(130,t); o.frequency.exponentialRampToValueAtTime(40,t+0.12); const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.6,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(BUS['bass_drum']?.g || master); o.start(t); o.stop(t+0.2); },
  s:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.2,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.35,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2); s.connect(f); f.connect(g); g.connect(BUS['snare']?.g || master); s.start(t); s.stop(t+0.2); },
  h:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.08,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.18,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.08); s.connect(f); s.connect(g); g.connect(BUS['cymbals']?.g || BUS['triangle']?.g || master); s.start(t); s.stop(t+0.08); }
};

/* ======= WAV export (offline synth) ‚Äî kept concise ======= */
async function renderWav(score){
  await unlockAudio();
  const sr=44100, len = Math.min(MAX_PLAY_SECONDS, (score && score.seconds) ? score.seconds : MAX_PLAY_SECONDS) + 2;
  const ctx=new OfflineAudioContext(2, Math.ceil(len*sr), sr);
  const master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination);
  const B={}; ORCH_MASTER.forEach(n=>{ const g=ctx.createGain(); g.gain.value=0.8; g.connect(master); B[n]={g}; });
  function hz(m){ return 440*Math.pow(2,(m-69)/12); }
  function ev(g,t0,a,d,s,hold,rel,amp){ const t1=t0+a,t2=t1+d,t3=t2+hold,t4=t3+rel; g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(amp,t1); g.gain.linearRampToValueAtTime(amp*s,t2); g.gain.setValueAtTime(amp*s,t3); g.gain.linearRampToValueAtTime(0,t4); }
  function osc(type,f){ const o=ctx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
  function noiseBuf(dur){ const b=ctx.createBuffer(1, Math.max(1,Math.floor(ctx.sampleRate*dur)), ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return b; }
  function add(inst,type,m,when,dur,vel,extra){
    if(type==='perc'){
      if(extra==='k'){ const o=osc('sine',130); const g=ctx.createGain(); o.frequency.setValueAtTime(130,when); o.frequency.exponentialRampToValueAtTime(40,when+0.12); g.gain.setValueAtTime(vel*0.6,when); g.gain.exponentialRampToValueAtTime(0.0001,when+0.18); o.connect(g); g.connect(B[inst]?.g || master); o.start(when); o.stop(when+0.2); }
      else if(extra==='s'){ const s=ctx.createBufferSource(); s.buffer=noiseBuf(0.2); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ctx.createGain(); g.gain.setValueAtTime(vel*0.35,when); g.gain.exponentialRampToValueAtTime(0.0001,when+0.2); s.connect(f); f.connect(g); g.connect(B[inst]?.g || master); s.start(when); s.stop(when+0.2); }
      else { const s=ctx.createBufferSource(); s.buffer=noiseBuf(0.08); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ctx.createGain(); g.gain.setValueAtTime(vel*0.18,when); g.gain.exponentialRampToValueAtTime(0.0001,when+0.08); s.connect(f); f.connect(g); g.connect(B[inst]?.g || master); s.start(when); s.stop(when+0.08); }
      return;
    }
    const g=ctx.createGain();
    if(type==='bowed' || type==='reed'){
      const o=osc(type==='reed'?'square':'sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value= type==='reed'?2400:2200; ev(g,when, type==='reed'?0.03:0.04, type==='reed'?0.22:0.45, type==='reed'?0.55:0.8,Math.max(0.05,dur-(type==='reed'?0.25:0.4)), type==='reed'?0.2:0.3, vel*0.55); o.connect(f); f.connect(g);
      g.connect(B[inst].g); o.start(when); o.stop(when+Math.max(0.4,dur));
    } else if(type==='brass'){
      const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800; ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.55); o.connect(f); f.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+Math.max(0.4,dur));
    } else if(type==='pluck'){
      const o=osc('triangle',hz(m)); ev(g,when,0.002,0.22,0.35,0.01,0.4,vel*0.6); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+0.5);
    } else if(type==='bell'){
      const o=osc('sine',hz(m)); ev(g,when,0.002,0.6,0.3,0.02,1.2,vel*0.6); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+1.1);
    } else if(type==='organ'){
      const o1=osc('sine',hz(m)),o2=osc('sine',hz(m)*2); ev(g,when,0.05,0.5,0.85,Math.max(0.05,dur-0.45),0.35,vel*0.55); o1.connect(g); o2.connect(g); g.connect(B[inst].g); o1.start(when); o2.start(when); o1.stop(when+Math.max(0.6,dur)); o2.stop(when+Math.max(0.6,dur));
    } else if(type==='bass'){
      const o=osc('triangle',hz(m)); ev(g,when,0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,vel*0.65*(+$('bassDepth').value)); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+0.35);
    }
  }
  // schedule (no unlock shifts in export, keep as composed)
  score.events.forEach(e=> add(e.inst,e.type,e.midi, e.time+0.05, e.dur, e.vel, e.perc));
  const buf=await ctx.startRendering();

  // WAV packing
  function interleave(L,R){ const out=new Float32Array(L.length+R.length); for(let i=0,j=0;i<L.length;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; } return out; }
  function f32To16(view,off,data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); s=s<0?s*0x8000:s*0x7FFF; view.setInt16(off,s,true);} }
  function w(view,off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i,str.charCodeAt(i)); }
  const L=buf.getChannelData(0), R=buf.getChannelData(1), inter=interleave(L,R);
  const ab=new ArrayBuffer(44+inter.length*2), dv=new DataView(ab);
  w(dv,0,'RIFF'); dv.setUint32(4,36+inter.length*2,true); w(dv,8,'WAVE'); w(dv,12,'fmt '); dv.setUint32(16,16,true);
  dv.setUint16(20,1,true); dv.setUint16(22,2,true); dv.setUint32(24,buf.sampleRate,true); dv.setUint32(28,buf.sampleRate*4,true);
  dv.setUint16(32,4,true); dv.setUint16(34,16,true); w(dv,36,'data'); dv.setUint32(40,inter.length*2,true);
  f32To16(dv,44,inter);
  return new Blob([dv],{type:'audio/wav'});
}
function downloadWavBlob(blob, filename='CST_LIVE_Symphony.wav'){
  try{
    const navAny = (navigator);
    if (navAny && typeof navAny.msSaveOrOpenBlob === 'function'){ navAny.msSaveOrOpenBlob(blob, filename); return; }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.rel = 'noopener'; a.style.display = 'none';
    document.body.appendChild(a);
    requestAnimationFrame(()=>{ a.click(); setTimeout(()=>{ try{ document.body.removeChild(a);}catch(e){} try{ URL.revokeObjectURL(url);}catch(e){} }, 1200); });
  }catch(err){ console.error('downloadWavBlob error:', err); setMsg('Could not start download. Try again after Analyze/LIVE.', 'warn'); }
}

/* ======= Print helpers ======= */
function midiToName(n){
  const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const pitch=((n%12)+12)%12, oct=Math.floor(n/12)-1;
  return names[pitch]+oct;
}
function printScore(score){
  if(!score || !score.events || !score.events.length){ setMsg('Nothing to print ‚Äî generate first.','warn'); return; }
  const nowCST = new Intl.DateTimeFormat('en-US',{timeZone:'America/Chicago',dateStyle:'medium',timeStyle:'medium'}).format(new Date());
  const rows = score.events.slice().sort((a,b)=>a.time-b.time)
    .map(e=>{
      const lab = labelOf(ORCH.find(x=>x.name===e.inst)||{name:e.inst});
      const pitch = e.type==='perc' ? e.perc.toUpperCase() : `${midiToName(e.midi)} (${e.midi})`;
      return `<tr><td>${e.time.toFixed(2)}s</td><td>${lab}</td><td>${e.inst}</td><td>${pitch}</td><td>${e.type==='perc'?'‚Äî':e.dur.toFixed(2)+'s'}</td><td>${e.vel.toFixed(2)}</td></tr>`;
    }).join('');
  const w=window.open('','_blank','width=1000,height=800');
  w.document.write(`
    <html><head><title>60s Notes ‚Äî CST LIVE Symphony</title>
      <style>
        body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:20px}
        h1{margin:0 0 6px}
        .meta{color:#555;margin-bottom:12px}
        table{width:100%;border-collapse:collapse}
        th,td{border:1px solid #bbb;padding:6px 8px;text-align:left;font-size:13px}
        th{background:#eee}
      </style>
    </head><body>
      <h1>Generated Notes (60 seconds)</h1>
      <div class="meta">BPM: ${score.bpm} ‚Ä¢ Length: ${score.seconds.toFixed(1)}s ‚Ä¢ Printed (CST): ${nowCST}</div>
      <table>
        <thead><tr><th>Time</th><th>Instrument</th><th>ID</th><th>Pitch</th><th>Duration</th><th>Velocity</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
      <script>window.print();<\/script>
    </body></html>
  `);
  w.document.close();
}

/* ======= Analysis (audio & notes) ‚Äî lightweight ======= */
let SOURCEBUF=null;
async function decodeFileToBuffer(file){ await unlockAudio(); const ab=await file.arrayBuffer(); return await ACTX.decodeAudioData(ab); }
function monoMixFirstMinute(buf){
  const maxSamp=Math.min(buf.length, Math.floor(buf.sampleRate*MAX_ANALYZE_SECONDS));
  const ch0=buf.getChannelData(0).slice(0,maxSamp);
  if(buf.numberOfChannels===1) return new Float32Array(ch0);
  const ch1=buf.getChannelData(1);
  const out=new Float32Array(maxSamp);
  for(let i=0;i<maxSamp;i++) out[i]=0.5*(ch0[i]+ch1[i]);
  return out;
}
async function energyEnvelopeAsync(x, win=2048, hop=1024, onProgress=null){
  const out=[]; let i=0; const N=x.length; const chunk=256*hop;
  while(i+win<=N){
    const end=Math.min(i+chunk, N-win);
    for(; i<=end; i+=hop){
      let s=0; for(let k=0;k<win;k++){ const v=x[i+k]; s+=v*v; }
      out.push(Math.sqrt(s/win));
    }
    if(onProgress) onProgress(out.length/(N/hop));
    await new Promise(r=>setTimeout(r,0));
  }
  return {env:out, hop};
}
function autocorrTempo(env, sr, hop){
  const fps=sr/hop; const minBPM=40, maxBPM=200;
  const minLag=Math.round(fps*60/maxBPM), maxLag=Math.round(fps*60/minBPM);
  let bestLag=minLag, bestVal=-1;
  for(let L=minLag; L<=maxLag; L++){
    let s=0; for(let i=0;i+L<env.length;i++) s += env[i]*env[i+L];
    if(s>bestVal){ bestVal=s; bestLag=L; }
  }
  const bpm=60*fps/bestLag; return Math.max(40, Math.min(200, bpm));
}
function peakPickBeats(env, sr, hop, bpm, hard=60){
  const fps=sr/hop, spb=fps*60/bpm; const beats=[]; let n=0;
  while(true){
    const center=Math.round(n*spb); if(center>=env.length) break;
    const r=Math.round(0.25*spb); let bestI=center,bestV=-1;
    for(let k=center-r; k<=center+r; k++){ if(k<0||k>=env.length) continue; const v=env[k]; if(v>bestV){bestV=v; bestI=k;} }
    const t=bestI/fps; if(t>hard) break;
    beats.push(bestI);
    n++;
  }
  return beats.map(i=>i/fps);
}

/* Notes parse */
let ANALYZED_NOTES = {motifs:[], bpm:null, seconds:null};
async function parseNotesFile(file){
  const text = await file.text();
  if(file.name.toLowerCase().endsWith('.json')){
    try{
      const obj = JSON.parse(text);
      const notes = Array.isArray(obj.notes)? obj.notes : [];
      return notes.filter(n=> typeof n.time==='number' && typeof n.midi==='number' && typeof n.dur==='number');
    }catch(e){ setMsg('JSON parse failed. Expect {notes:[{time,midi,dur},...]}.','warn'); return []; }
  }
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const out=[];
  for(const ln of lines){
    const m=ln.split(/[, \t]+/);
    if(m.length>=3){
      const t=+m[0], p=+m[1], d=+m[2];
      if(Number.isFinite(t)&&Number.isFinite(p)&&Number.isFinite(d)) out.push({time:t,midi:p,dur:d});
    }
  }
  return out;
}

/* ======= Features & helpers ======= */
function spectralFeatures(envSeries){
  const N=envSeries.length; if(N===0) return {arousal:0.5, brightness:0.5};
  const mean = envSeries.reduce((a,b)=>a+b,0)/N;
  const varc = envSeries.reduce((a,b)=>a+(b-mean)*(b-mean),0)/N;
  const arousal = clamp(Math.sqrt(varc)*1.8, 0, 1);
  let diff=0; for(let i=1;i<N;i++) diff += Math.abs(envSeries[i]-envSeries[i-1]);
  const brightness = clamp(diff/(N*0.02), 0, 1);
  return {arousal, brightness};
}
function pickEquationModes(){ const opts=['phi','fourier','prime']; return [...opts].sort(()=>Math.random()-0.5).slice(0,1+Math.floor(Math.random()*2)); }
function eqPhaseCST(modes, beatPeriod){
  let phase = 0; const now = new Intl.DateTimeFormat('en-US',{timeZone:'America/Chicago',second:'2-digit'}).format(new Date());
  const sec = parseInt(now,10)||0; if(modes.includes('phi')) phase += 0.618; phase += (sec%10)/100; return (phase%1)*beatPeriod;
}
function chordFromDegree(deg){
  const map={'I':0,'ii':2,'iii':4,'IV':5,'V':7,'vi':9,'VII':11};
  let root = map[deg];
  if(root===undefined){ const n=parseInt(deg,10); root = isNaN(n)?0:((n%12)+12)%12; }
  return [root,(root+4)%12,(root+7)%12];
}
function cadenceList(name, custom){
  if(name==='I-IV-V-I') return ['I','IV','V','I'];
  if(name==='I-vi-IV-V') return ['I','vi','IV','V'];
  if(name==='ii-V-I') return ['ii','V','I','I'];
  if(name==='I-V-vi-IV') return ['I','V','vi','IV'];
  if(name==='authentic') return ['V','I','V','I'];
  if(name==='plagal') return ['IV','I','IV','I'];
  if(name==='half') return ['I','IV','ii','V'];
  if(name==='phrygian_half') return ['ii','V','ii','V'];
  if(name==='deceptive') return ['V','vi','IV','V'];
  if(name==='custom'){ if(!custom) return ['I','IV','V','I']; return custom.split(/[,\s]+/).filter(Boolean); }
  return ['I','IV','V','I'];
}
function emotionProfile(kind, intensity, autoFeat){
  const base = {
    leadGain:1, bedGain:1, bassGain:1, sparkGain:1, percGain:0.4,
    leadSet:['violin','flute','trumpet'],
    bedSet:['cello','horn','piano','organ'],
    bassSet:['double_bass','tuba','bass_trombone','contrabassoon'],
    sparkSet:['glockenspiel','celesta','harp','piccolo','chimes'],
    accentStrong:false, staccato:false, lowBias:0, highBias:0
  };
  const k = kind; const t = clamp(intensity,0,1);
  if(k==='auto'){
    const a = autoFeat?.arousal ?? 0.5, b = autoFeat?.brightness ?? 0.5;
    if(a>0.6 && b>0.55) return emotionProfile('happy', t);
    if(a>0.6 && b<0.45) return emotionProfile('angry', t);
    if(a<0.4 && b<0.45) return emotionProfile('sad', t);
    if(b<0.35) return emotionProfile('spooky', t);
    return emotionProfile('calm', t);
  }
  const out = JSON.parse(JSON.stringify(base));
  if(k==='happy'){ out.leadSet=['flute','violin','trumpet','clarinet']; out.sparkSet=['glockenspiel','celesta','chimes','harp','piccolo','vibraphone']; out.leadGain=1+0.2*t; out.sparkGain=1+0.35*t; out.percGain=0.35+0.3*t; out.highBias=0.3*t; out.accentStrong=true; }
  else if(k==='sad'){ out.leadSet=['oboe','viola','cello','english_horn']; out.bedSet=['piano','cello','horn','clarinet']; out.sparkSet=['harp','celesta']; out.bassSet=['double_bass','contrabassoon']; out.bedGain=1+0.15*t; out.bassGain=1+0.1*t; out.sparkGain=1-0.2*t; out.percGain=0.15; out.lowBias=0.25*t; }
  else if(k==='angry'){ out.leadSet=['trumpet','trombone','horn','saxophone']; out.bedSet=['trombone','horn','organ']; out.bassSet=['tuba','bass_trombone','double_bass']; out.sparkSet=['cymbals','tam_tam']; out.leadGain=1+0.35*t; out.bedGain=1+0.2*t; out.bassGain=1+0.25*t; out.sparkGain=1+0.2*t; out.percGain=0.5+0.4*t; out.lowBias=0.2*t; out.staccato=true; out.accentStrong=true; }
  else if(k==='spooky'){ out.leadSet=['bass_clarinet','bassoon','viola','alto_flute']; out.bedSet=['cello','piano','horn']; out.bassSet=['contrabassoon','double_bass']; out.sparkSet=['tam_tam','triangle','marimba','vibraphone']; out.bassGain=1+0.2*t; out.percGain=0.25+0.25*t; out.lowBias=0.35*t; out.highBias=-0.2*t; }
  else if(k==='calm'){ out.leadSet=['clarinet','flute','violin','alto_flute']; out.bedSet=['harp','cello','piano','horn']; out.bassSet=['double_bass']; out.sparkSet=['celesta','harp','glockenspiel','vibraphone']; out.bedGain=1+0.1*t; out.percGain=0.15; out.highBias=0.1*t; }
  return out;
}
const REG = { lead:72, bed:60, bass:36, spark:79 };

/* ======= Score generator ======= */
function generateScore(params){
  let { bpm, totalSecs, energyArr, cadenceNames, swingBase, dotTri, vmin, vmax,
        bassDepth, modes, emotionKind, emoIntensity, toneBias, percAmt,
        pace, movement, tempoFactor, eqApproach, composer='Mozart',
        motifs=[], ensureAll=true } = params;

  totalSecs = Math.min(MAX_PLAY_SECONDS, Math.max(1, totalSecs || MAX_PLAY_SECONDS));
  const hook = (root)=> (composerHookSingle[composer] || composerHookSingle['Mozart'])(root);
  const features = spectralFeatures(energyArr||[]);
  const emo = emotionProfile(emotionKind, emoIntensity, features);

  let paceScale = pace==='calm'? 1.12 : pace==='urgent'? 0.9 : 1.0;
  if(movement==='II') paceScale *= 1.18; if(movement==='III') paceScale *= 0.98; if(movement==='IV') paceScale *= 0.92;
  if(tempoFactor==='structure') paceScale *= 0.97;
  if(tempoFactor==='performance') paceScale *= (0.95 + Math.random()*0.1);
  if(tempoFactor==='exceptions') paceScale *= (0.9 + Math.random()*0.2);

  let randPush = 0.0, densityPush=1.0;
  if(eqApproach==='finite'){ randPush = -0.2; densityPush=0.95; }
  if(eqApproach==='infinite'){ randPush = +0.25; densityPush=1.1; }

  const beatPeriod0 = 60/Math.max(40,Math.min(200,bpm));
  const beatPeriod = beatPeriod0*paceScale;
  const beatsPerBar=4;
  const cstOffset = eqPhaseCST(modes, beatPeriod);
  const totalBeats = Math.max(1, Math.floor(totalSecs/beatPeriod));
  const totalBars = Math.max(1, Math.floor(totalBeats/beatsPerBar));

  function cadenceListFromUI(){
    let cadName=$('cadence').value||'I-IV-V-I';
    if(!cadName || cadName==='random') cadName = ['I-IV-V-I','I-vi-IV-V','ii-V-I','I-V-vi-IV','authentic','plagal','half','deceptive'][Math.floor(Math.random()*8)];
    if(cadName!=='custom') $('cadence').value=cadName;
    const cadCustom=$('cadenceCustom').value.trim()||'';
    const cadenceSeq=cadenceList(cadName, cadCustom);
    $('cadOut').textContent=(cadName==='custom'?(cadCustom||'Custom'):cadName).replace(/_/g,' ').replace(/-/g,'‚Äì');
    return cadenceSeq;
  }
  cadenceNames = cadenceNames || cadenceListFromUI();

  const barChords = Array.from({length: totalBars}, (_,b)=> chordFromDegree(cadenceNames[b % cadenceNames.length]));

  const allowedNames = ORCH.filter(i=>INST_SELECTION[i.name]).map(i=>i.name);
  if(!allowedNames.length) return {events:[],bpm,totalSecs, seconds:totalSecs};

  function pickFromSet(setNames, fallbackRole){
    const filt = setNames.filter(n=>allowedNames.includes(n));
    if(filt.length) return filt[Math.floor(Math.random()*filt.length)];
    const rolePick = ORCH.filter(i=>allowedNames.includes(i.name) && i.role===fallbackRole);
    if(rolePick.length) return rolePick[Math.floor(Math.random()*rolePick.length)].name;
    return allowedNames[Math.floor(Math.random()*allowedNames.length)];
  }

  const events=[]; const last={lead:null,bass:null,bed:null,spark:null};
  const cadenceGain = 0.70;
  const emoGain = { lead:emo.leadGain, bed:emo.bedGain, bass:emo.bassGain, spark:emo.sparkGain };

  const motifSteps = motifs.map(m=>m.step || 0);

  for(let b=0;b<totalBeats;b++){
    const bar = Math.floor(b/beatsPerBar);
    const inBar = b % beatsPerBar;
    const chord = barChords[Math.min(bar, barChords.length-1)];
    const [root, third, fifth] = chord;

    const tBeat = b*beatPeriod + cstOffset;
    const E = (energyArr && energyArr.length) ? energyArr[Math.min(energyArr.length-1, b)] : 0.5;

    let V = clamp(Math.round(+$('vmin').value + (+$('vmax').value - +$('vmin').value)*E*densityPush), 1, 8);
    if(Math.random()<Math.max(0,randPush)) V = Math.min(8, V+1);
    if((pickEquationModes()).includes('prime')){ const isPrime = (n)=>{ if(n<2) return false; for(let k=2;k*k<=n;k++) if(n%k===0) return false; return true; }; if(isPrime(b)) V = Math.max(1, V-1); }

    let swing = +$('swing').value;
    if((pickEquationModes()).includes('fourier')) swing = clamp(1.0 + 0.25*Math.sin(2*Math.PI*(b/16)), 1.0, 1.5);
    const toneShift = Math.round( ((emo.highBias||0) - (emo.lowBias||0) + (+$('toneBias').value)*0.6) * 6 );

    const want=[];
    if(V>=1) want.push('lead');
    if(V>=2) want.push('bass');
    if(V>=3) want.push('bed');
    if(V>=4) want.push(Math.random()<0.6?'spark':'counter');
    if(V>=5) want.push('counter');

    const motifStep = motifSteps.length? motifSteps[b % motifSteps.length] : 0;

    // Lead (melody)
    if(want.includes('lead')){
      const inst = pickFromSet(emo.leadSet, 'lead');
      const prev=last.lead;
      const chordTones=[root,third,fifth,(root+2)%12,(root+9)%12];
      const target = (prev==null ? REG.lead+root : prev);
      let best=REG.lead+root+motifStep, bestDist=1e9;
      for(const ct of chordTones){ for(let k=-2;k<=2;k++){
        const m=REG.lead + (ct+12*k) + toneShift + motifStep;
        const d=Math.abs(m-target); if(d<bestDist){bestDist=d; best=m;}
      } }
      const e8 = beatPeriod/2;
      const dLong = (swing/(swing+1))*e8, dShort=(1/(swing+1))*e8;
      const useSwing = (swing>1.02) && (inBar%2===0);
      let dur = (useSwing ? (Math.random()<0.5? dLong: dShort) : (Math.random()<0.3? e8 : beatPeriod));
      dur += (+$('dotTri').value)*(Math.random()<0.5 ? 0.5*e8 : -1/6*beatPeriod);
      dur = Math.max(0.24, dur);
      // Polyphonic hook
      const rels = (composerHookSingle[composer]||composerHookSingle.Mozart)(0);
      rels.slice(0, 3 + Math.floor(Math.random()*2)).forEach((interval,idx)=>{
        const vel = (idx===0?0.68:0.48) * emoGain.lead;
        events.push({inst, type:getType(inst), time:tBeat+(idx?0.02*idx:0), dur:dur, midi:best + interval, vel});
      });
      last.lead=best;
    }

    // Bass
    if(want.includes('bass')){
      const inst = pickFromSet(emo.bassSet, 'bass');
      const prev=last.bass;
      const bassCand = Math.random()<0.75 ? root : fifth;
      let m = REG.bass + bassCand + toneShift + (motifStep%12);
      if(prev!=null){ const opts=[m,m-12,m+12]; m = opts.reduce((a,b)=> Math.abs(b-prev)<Math.abs(a-prev)?b:a, opts[0]); }
      const dur = beatPeriod*(Math.random()<0.6?1:2);
      events.push({inst, type:getType(inst), time:tBeat, dur:dur, midi:m, vel:0.58*(+$('bassDepth').value)*emoGain.bass});
      last.bass=m;
    }

    // Bed chords
    if(want.includes('bed')){
      const inst = pickFromSet(emo.bedSet, 'bed');
      const base = REG.bed + root + toneShift;
      [0,4,7].forEach(iv=>{
        const dd = beatPeriod*(Math.random()<0.5?2:4);
        events.push({inst, type:getType(inst), time:tBeat, dur:dd, midi:base+iv, vel:0.40*cadenceGain*emoGain.bed});
      });
      last.bed=base+4;
    }

    // Sparkle / Counter
    if(want.includes('spark') || want.includes('counter')){
      const isSpark = want.includes('spark');
      if(isSpark){
        const inst = pickFromSet(emo.sparkSet, 'sparkle');
        const base = REG.spark + root + toneShift;
        [0,4,7,12].forEach((iv,i)=>{ const tt=tBeat+i*(beatPeriod/4); events.push({inst, type:getType(inst), time:tt, dur:beatPeriod/4, midi:base+iv, vel:0.48*emoGain.spark}); });
      }else{
        const inst = pickFromSet(emo.leadSet.concat(['viola','clarinet']), 'counter');
        const step=Math.random()<0.5?2:-2;
        events.push({inst, type:getType(inst), time:tBeat+0.02, dur:beatPeriod, midi:(last.lead??(72+root+toneShift))+step, vel:0.52*emoGain.lead});
      }
    }

    // Percussion
    const P = (+$('percAmt').value)*emo.percGain;
    if(INST_SELECTION['bass_drum'] && inBar===0 && Math.random()<0.95)
      events.push({inst:'bass_drum', type:'perc', perc:'k', time:tBeat, dur:0, midi:0, vel:0.35+0.35*E*P});
    if(INST_SELECTION['snare'] && inBar===2)
      events.push({inst:'snare', type:'perc', perc:'s', time:tBeat+0.02, dur:0, midi:0, vel:0.22+0.18*E*P});
    if((INST_SELECTION['triangle']||INST_SELECTION['cymbals']) && Math.random()<0.25){
      const which = INST_SELECTION['cymbals'] ? 'cymbals' : 'triangle';
      events.push({inst:which, type:'perc', perc:'h', time:tBeat+0.01, dur:0, midi:0, vel:0.12+0.12*E*P});
    }
  }

  /* Ensure every enabled instrument appears at least once */
  if(ensureAll){
    const used = new Set(events.map(e=>e.inst));
    const allowed = allowedNames;
    const gap = totalSecs / Math.max(1, allowed.length);
    allowed.forEach((name, idx)=>{
      if(used.has(name)) return;
      const t = Math.min(totalSecs-0.5, idx*gap + 0.1);
      const role = (ORCH.find(i=>i.name===name)?.role)||'bed';
      let midi = (role==='lead')? REG.lead : (role==='bass')? REG.bass : (role==='sparkle')? REG.spark : REG.bed;
      const vel = 0.45, dur = 0.35;
      if(getType(name)==='perc'){ events.push({inst:name, type:'perc', perc:'h', time:t, dur:0, midi:0, vel:0.12}); }
      else { events.push({inst:name, type:getType(name), time:t, dur, midi, vel}); }
    });
  }

  events.sort((a,b)=>a.time-b.time);
  return {events, bpm, seconds: totalSecs};
}

/* ======= Global state ======= */
let ANALYSIS = {bpm:null,seconds:null,beats:[],energy:[]}, SCORE=null;

/* ======= Build UI and wire events ======= */
function firstVals(){ 
  $('live').setAttribute('disabled','disabled');
  ['swing','dotTri','vmin','vmax','bassDepth','emoInt','toneBias','percAmt'].forEach(id=>{ const el=$(id); if(el && el.value==null) el.value = el.getAttribute('value'); });
  (function update(){ 
    try{
      $('swingVal').textContent=(+$('swing').value).toFixed(2);
      $('dotTriVal').textContent=(+$('dotTri').value).toFixed(2);
      $('vminVal').textContent=$('vmin').value; $('vmaxVal').textContent=$('vmax').value;
      $('vb').textContent=`${$('vmin').value}‚Äì${$('vmax').value}`;
      $('bassDepthVal').textContent=(+$('bassDepth').value).toFixed(2);
      $('emoIntVal').textContent=(+$('emoInt').value).toFixed(2);
      $('toneBiasVal').textContent=(+$('toneBias').value).toFixed(1);
      $('percAmtVal').textContent=(+$('percAmt').value).toFixed(2);
    }catch(e){}
  })();
}

/* Value listeners */
['swing','dotTri','vmin','vmax','bassDepth','emoInt','toneBias','percAmt'].forEach(id=>{
  const el=$(id); if(el) el.addEventListener('input',()=>{ 
    try{
      if($('swingVal')) $('swingVal').textContent=(+$('swing').value).toFixed(2);
      if($('dotTriVal')) $('dotTriVal').textContent=(+$('dotTri').value).toFixed(2);
      if($('vminVal')) $('vminVal').textContent=$('vmin').value;
      if($('vmaxVal')) $('vmaxVal').textContent=$('vmax').value;
      if($('vb')) $('vb').textContent=`${$('vmin').value}‚Äì${$('vmax').value}`;
      if($('bassDepthVal')) $('bassDepthVal').textContent=(+$('bassDepth').value).toFixed(2);
      if($('emoIntVal')) $('emoIntVal').textContent=(+$('emoInt').value).toFixed(2);
      if($('toneBiasVal')) $('toneBiasVal').textContent=(+$('toneBias').value).toFixed(1);
      if($('percAmtVal')) $('percAmtVal').textContent=(+$('percAmt').value).toFixed(2);
    }catch(e){}
    setMsg('Settings changed ‚Äî press LIVE or Generate to apply.'); 
  });
});
if($('cadence')) $('cadence').addEventListener('change',()=>{
  const isC=$('cadence').value==='custom'; $('cadenceCustom').disabled=!isC;
  $('cadOut').textContent=isC?'Custom':$('cadence').value.replace(/_/g,' ').replace(/-/g,'‚Äì');
  setMsg('Cadence changed ‚Äî press LIVE or Generate to apply.');
});
if($('cadenceCustom')) $('cadenceCustom').addEventListener('input',()=>{ if($('cadence').value==='custom'){ $('cadOut').textContent='Custom'; setMsg('Custom cadence updated ‚Äî press LIVE or Generate.'); } });
if($('emotion')) $('emotion').addEventListener('change',()=>{ $('emoOut').textContent=$('emotion').value.replace(/\b\w/g,m=>m.toUpperCase()); setMsg('Emotion changed ‚Äî press LIVE or Generate.'); });
if($('composer')) $('composer').addEventListener('change', ()=>{ $('compOut').textContent=$('composer').value; setMsg('Composer changed ‚Äî press Generate/LIVE to apply.'); });

/* All On/Off/Save */
if($('allOn')) $('allOn').addEventListener('click',()=>{ selectAll(true); });
if($('allOff')) $('allOff').addEventListener('click',()=>{ selectAll(false); });
if($('saveSel')) $('saveSel').addEventListener('click', saveAllSelections);

/* Explain notes */
if($('btnExplainNotes')) $('btnExplainNotes').addEventListener('click', ()=>{
  alert(
`Format a .txt like:
0.00,60,0.50
0.50,62,0.50
1.00,64,0.50
(time_seconds, MIDI_pitch, duration_seconds)

Or a .json:
{"notes":[{"time":0.00,"midi":60,"dur":0.50}, {"time":0.50,"midi":62,"dur":0.50}]}
`
  );
});

/* Analyze Audio */
if($('analyzeAudio')) $('analyzeAudio').addEventListener('click', async ()=>{
  clearMsg(); setLiveOn(false); stopAll(); stopLine();
  const f=$('fileAudio')?.files?.[0];
  if(!f){ setMsg('Choose an audio file first.','warn'); return; }
  $('live')?.setAttribute('disabled','disabled'); $('live').textContent='LIVE ‚Äî WAIT (Analyzing Audio...)';
  try{
    await unlockAudio(); initBuses();
    randomize20();

    const buf = await decodeFileToBuffer(f); SOURCEBUF=buf;
    const mono = monoMixFirstMinute(buf);
    const sr = buf.sampleRate;

    const {env,hop} = await energyEnvelopeAsync(mono,2048,1024,(p)=>{ setMsg(`Analyzing audio‚Ä¶ ${Math.round(p*100)}%`); });
    const bpm = autocorrTempo(env,sr,hop);
    const beats = peakPickBeats(env,sr,hop,bpm,MAX_ANALYZE_SECONDS);
    const seconds = Math.min(MAX_ANALYZE_SECONDS, buf.duration);
    const fps=sr/hop;
    const beatEnergy = beats.map(t=>{ const idx=Math.max(0,Math.min(env.length-1, Math.round(t*fps))); return env[idx]; });
    const maxE = beatEnergy.reduce((a,b)=>Math.max(a,b),0.0001);
    const E = beatEnergy.map(x=> clamp(x/maxE,0,1));
    ANALYSIS={bpm:Math.round(bpm),seconds,beats,energy:E};
    $('bpm').textContent = Math.round(bpm);
    $('len').textContent = seconds.toFixed(1)+' s';
    setMsg('Audio analyzed ‚Äî now Generate (Use Music) or LIVE after generating.');
    $('live')?.removeAttribute('disabled');
  }catch(err){ console.error(err); setMsg('Analyze Audio failed. Try another file.','warn'); }
  finally{ $('live').textContent='LIVE ‚Äî PLAY'; }
});

/* Analyze Notes */
if($('analyzeNotes')) $('analyzeNotes').addEventListener('click', async ()=>{
  clearMsg();
  const f=$('fileNotes')?.files?.[0];
  if(!f){ setMsg('Choose a notes file (.txt/.json) first.','warn'); return; }
  try{
    randomize20();
    const notes = await parseNotesFile(f);
    if(!notes.length){ setMsg('No notes parsed. Check format.','warn'); return; }
    const steps=[];
    for(let i=1;i<notes.length;i++){ const prev=notes[i-1].midi|0, cur=notes[i].midi|0; steps.push(cur-prev); }
    const secs = Math.min(MAX_PLAY_SECONDS, (notes.length? (notes[notes.length-1].time + notes[notes.length-1].dur) : 60));
    const estBpm = 110;
    ANALYZED_NOTES = {motifs: steps.map(s=>({step:s})), bpm: estBpm, seconds: Math.max(10, secs)};
    $('bpm').textContent = estBpm;
    $('len').textContent = ANALYZED_NOTES.seconds.toFixed(1)+' s';
    setMsg('Notes analyzed ‚Äî now Generate (Use Notes).');
    $('live')?.removeAttribute('disabled');
  }catch(err){ console.error(err); setMsg('Analyze Notes failed. Check file format.','warn'); }
});

/* Defaults */
function defaultBpm(){
  const pace = $('pace').value, mv=$('movement').value;
  let bpm = (pace==='calm'? 92 : pace==='urgent'? 138 : 110);
  if(mv==='II') bpm -= 12; if(mv==='IV') bpm += 8;
  return clamp(bpm, 60, 180);
}
function randomize20(){
  ORCH_MASTER.forEach(n=>INST_SELECTION[n]=false);
  const pool=[...ORCH_MASTER];
  for(let i=pool.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }
  pool.slice(0, Math.min(20, pool.length)).forEach(n=>INST_SELECTION[n]=true);
  buildInstList(); updateWillPlayListFromSelection();
}

/* Build params */
function buildParamsBase(bpm, seconds, energy){
  return {
    bpm, totalSecs: seconds, energyArr: energy,
    cadenceNames: null,
    swingBase:+$('swing').value, dotTri:+$('dotTri').value,
    vmin:+$('vmin').value, vmax:+$('vmax').value,
    bassDepth:+$('bassDepth').value, modes: pickEquationModes(),
    emotionKind: $('emotion').value, emoIntensity:+$('emoInt').value,
    toneBias:+$('toneBias').value, percAmt:+$('percAmt').value,
    pace:$('pace').value, movement:$('movement').value, tempoFactor:$('tempoFactor').value,
    eqApproach:'focus', composer: $('composer').value
  };
}

/* Generate: compose */
if($('genCompose')) $('genCompose').addEventListener('click', ()=>{
  saveAllSelections();
  const bpm = defaultBpm();
  const seconds = 60;
  const beats = Math.floor(seconds/(60/bpm));
  const energy = Array.from({length:beats}, ()=>0.5);
  SCORE = generateScore(buildParamsBase(bpm, seconds, energy));
  if(!SCORE.events.length){ setMsg('No playable events (maybe no instruments selected).','warn'); return; }
  drawTimeline(SCORE); updateWillPlayListFromSelection();
  setMsg('Generated from scratch. Press LIVE ‚Äî PLAY to listen, or üñ®Ô∏è Print Notes.');
  $('live').removeAttribute('disabled');
});

/* Generate: notes */
if($('genFromNotes')) $('genFromNotes').addEventListener('click', ()=>{
  saveAllSelections();
  if(!ANALYZED_NOTES.motifs.length){ setMsg('Analyze Notes first.','warn'); return; }
  const bpm = ANALYZED_NOTES.bpm || defaultBpm();
  const seconds = Math.min(60, ANALYZED_NOTES.seconds||60);
  const beats = Math.floor(seconds/(60/bpm));
  const energy = Array.from({length:beats}, ()=>0.5);
  const params = {...buildParamsBase(bpm, seconds, energy), motifs: ANALYZED_NOTES.motifs};
  SCORE = generateScore(params);
  if(!SCORE.events.length){ setMsg('No playable events (maybe no instruments selected).','warn'); return; }
  drawTimeline(SCORE); updateWillPlayListFromSelection();
  setMsg('Generated using uploaded notes. Press LIVE ‚Äî PLAY to listen, or üñ®Ô∏è Print Notes.');
  $('live').removeAttribute('disabled');
});

/* Generate: audio */
if($('genFromAudio')) $('genFromAudio').addEventListener('click', ()=>{
  saveAllSelections();
  if(!ANALYSIS.bpm){ setMsg('Analyze Audio first.','warn'); return; }
  SCORE = generateScore(buildParamsBase(ANALYSIS.bpm, ANALYSIS.seconds, ANALYSIS.energy));
  if(!SCORE.events.length){ setMsg('No playable events (maybe no instruments selected).','warn'); return; }
  drawTimeline(SCORE); updateWillPlayListFromSelection();
  setMsg('Generated using uploaded music. Press LIVE ‚Äî PLAY to listen, or üñ®Ô∏è Print Notes.');
  $('live').removeAttribute('disabled');
});

/* ======= LIVE playback with unlock schedule ======= */
function playScore(score){
  if(playing) return;
  if (score && typeof score.seconds === 'number') score.seconds = Math.min(score.seconds, MAX_PLAY_SECONDS);

  const start=ACTX.currentTime+0.2; playing=true; setLiveOn(true);
  startLine(Math.min(MAX_PLAY_SECONDS, score.seconds)); scheduled.length=0;
  if(playTimer){ clearTimeout(playTimer); }
  playTimer=setTimeout(()=>{ stopAll(); }, Math.max(0, (score.seconds*1000)+120));

  score.events.forEach(ev=>{
    const baseWhen = start + ev.time;
    const role = getRole(ev.inst);
    const unlockSec = UNLOCK_SCHEDULE[role] ?? 0;
    const when = start + Math.max(ev.time, unlockSec); // shift earlier notes to unlock time
    const t=ev.type;
    if(t==='perc'){
      if(ev.perc==='k') PATCH.k(when, ev.vel);
      else if(ev.perc==='s') PATCH.s(when, ev.vel);
      else PATCH.h(when, ev.vel);
      return;
    }
    if(t==='bowed') PATCH.bowed(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='reed') PATCH.reed(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='brass') PATCH.brass(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='pluck') PATCH.pluck(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='bell') PATCH.bell(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='organ') PATCH.organ(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else if(t==='bass') PATCH.bass(ev.inst, ev.midi, when, ev.dur, ev.vel);
    else PATCH.bowed(ev.inst, ev.midi, when, ev.dur, ev.vel);
  });
}

/* Buttons */
if($('live')) $('live').addEventListener('click', async ()=>{
  if($('live').hasAttribute('disabled')) return;
  await unlockAudio(); initBuses();
  if(!SCORE){
    const bpm = defaultBpm(), seconds=60, beats=Math.floor(seconds/(60/bpm));
    const energy = Array.from({length:beats}, ()=>0.5);
    SCORE = generateScore(buildParamsBase(bpm,seconds,energy));
  }
  if(!SCORE || !SCORE.events.length){ setMsg('Nothing to play. Use Generate first.','warn'); return; }
  drawTimeline(SCORE);
  updateWillPlayListFromSelection();
  playScore(SCORE);
  clearMsg();
});
if($('stop')) $('stop').addEventListener('click', ()=>{ stopAll(); clearMsg(); });
if($('reset')) $('reset').addEventListener('click', ()=>{
  stopAll(); SCORE=null; SOURCEBUF=null; ANALYSIS={bpm:null,seconds:null,beats:[],energy:[]}; ANALYZED_NOTES={motifs:[],bpm:null,seconds:null};
  if($('fileAudio')) $('fileAudio').value=""; if($('fileNotes')) $('fileNotes').value="";
  $('bpm').textContent='‚Äì'; $('len').textContent='‚Äì';
  $('live').setAttribute('disabled','disabled'); $('live').textContent='LIVE ‚Äî PLAY'; setLiveOn(false);
  randomize20();
  $('cadence').value='random'; $('cadenceCustom').value=''; $('cadenceCustom').disabled=true;
  $('composer').value='Mozart'; $('compOut').textContent='Mozart';
  clearMsg(); drawLine(0); updateWillPlayListFromSelection();
  if(CTX && TLM){ const dpr=window.devicePixelRatio||1; TLM.width=TLM.clientWidth*dpr; TLM.height=TLM.clientHeight*dpr; CTX.clearRect(0,0,TLM.width,TLM.height); }
});
if($('export')) $('export').addEventListener('click', async ()=>{
  if(!SCORE){ setMsg('Nothing to export. Generate then LIVE first.','warn'); return; }
  try{
    setMsg('Rendering WAV‚Ä¶ your browser will start a download when it‚Äôs ready.');
    const blob=await renderWav(SCORE);
    const bpmSafe = (SCORE?.bpm ? `${SCORE.bpm}` : (ANALYSIS?.bpm?`${ANALYSIS.bpm}`:'UNK'));
    downloadWavBlob(blob, `CST_LIVE_Symphony_${bpmSafe}BPM_1min.wav`);
  }catch(err){
    console.error('Export failed:', err);
    setMsg('Export failed. Try Analyze/Generate ‚Üí LIVE, then export again.','warn');
  }
});
if($('printNotes')) $('printNotes').addEventListener('click', ()=> printScore(SCORE));

/* ======= Self-Test button ======= */
if($('selfTest')){
  $('selfTest').addEventListener('click', ()=>{
    const results = [];
    const ok = (name, cond) => results.push(`${cond?'‚úÖ':'‚ùå'} ${name}`);
    try{
      ok('Composer dropdown exists', !!$('composer'));
      ok('Composer options populated', ($('composer')?.options?.length||0) > 5);
      ok('Orchestration list exists', !!$('instList'));
      ok('At least 10 instruments rendered', (document.querySelectorAll('#instList .instRow')?.length||0) >= 10);
      ok('All On button', !!$('allOn'));
      ok('All Off button', !!$('allOff'));
      ok('Will Play panel', !!$('willPlay'));
      ok('Generate (Compose)', !!$('genCompose'));
      ok('Generate (Use Music)', !!$('genFromAudio'));
      ok('Generate (Use Notes)', !!$('genFromNotes'));
      ok('LIVE ‚Äî PLAY', !!$('live'));
      ok('Stop', !!$('stop'));
      ok('Reset', !!$('reset'));
      ok('Unlock schedule present', Array.isArray(Object.keys(UNLOCK_SCHEDULE)) && Object.keys(UNLOCK_SCHEDULE).length>=3);
      // localStorage check
      try{
        const key=LS_KEY; const before = localStorage.getItem(key);
        localStorage.setItem(key, before ?? '{"_test":"ok"}'); const after = localStorage.getItem(key);
        ok('localStorage writable', !!after); if(before===null) localStorage.removeItem(key);
      }catch(e){ ok('localStorage writable', false); }
      alert(results.join('\n'));
    }catch(err){
      alert('Self-Test failed to run. Open console for details.'); 
      console.error(err);
    }
  });
}

/* ======= Init ======= */
window.addEventListener('pointerdown', unlockAudio, {once:true});
ensureAudio(); initBuses();
buildComposerDropdown();
loadAllSelections();
buildInstList();
updateWillPlayListFromSelection();
firstVals();

/* Keep audio ready on visibility resume */
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') unlockAudio(); });
</script>
</div>
</body>
</html>
