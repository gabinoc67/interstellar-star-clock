<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST — 60s Audio→CSV Notes + Dual CSV Player</title>
<style>
  :root{
    --bg:#0a0f1f; --ink:#eaf1ff; --muted:#a8b7e3; --panel:#121a33; --grid:#1b254b;
    --accent:#3b82f6; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid var(--grid);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:18px;margin:0}
  main{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:380px 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:12px;padding:14px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="file"],button,input[type="range"]{width:100%;padding:10px;border-radius:10px;border:1px solid var(--grid);background:#0e1733;color:var(--ink)}
  button{cursor:pointer;background:linear-gradient(180deg,#15245a,#0f1b45)}
  button:hover{filter:brightness(1.06)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px dashed var(--grid);border-radius:10px;margin-top:8px}
  .stat b{color:var(--ok)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;font-size:12px;white-space:pre;line-height:1.42}
  .scroller{max-height:280px;overflow:auto;border:1px solid var(--grid);border-radius:10px;padding:8px;background:#0c1430}
  .hr{height:1px;background:linear-gradient(90deg,transparent,#2a3a7a,transparent);margin:12px 0}
  .whiteSquare{width:100%; height:38px; background:#fff; color:#000; display:flex; align-items:center; justify-content:center;
    border-radius:8px; border:2px solid #ddd; cursor:pointer; user-select:none;}
  .whiteSquare.active{outline:3px solid #4f8cff; font-weight:700}
  canvas{width:100%;height:240px;background:#0c1430;border:1px solid #22306b;border-radius:10px}
  .danger{background:#3b1220;border-color:#6b1f35}
  #status{font-size:12px;color:#9ad1ff;margin-top:8px}
  small.hint{display:block;color:#a8b7e3;margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>CST — Audio→CSV Notes (60s) + Dual CSV Player</h1>
  <span style="font-size:12px;color:#9ad1ff">No external soundfonts • Real-time scheduler • Simple CSV t,m,b</span>
</header>

<main>
  <!-- LEFT: Controls -->
  <section class="card">
    <label style="font-weight:600">CSV Panel — Analyze audio then export CSV (60s)</label>
    <div class="row3" style="margin-top:6px">
      <button id="btnLoadAudio">1) Load Audio (MP3/WAV/AAC/OGG)</button>
      <button id="btnAnalyze">2) Analyze 60s</button>
      <button id="btnExport">3) Export CSV (60s)</button>
    </div>
    <input id="audioFile" type="file" accept=".mp3,.wav,.m4a,.aac,.ogg" style="display:none"/>
    <div class="row" style="margin-top:8px">
      <div class="stat"><span>Detected Key</span><b id="detKey">–</b></div>
      <div class="stat"><span>Detected BPM</span><b id="detBPM">–</b></div>
    </div>
    <small class="hint">CSV columns: <b>t,m,b</b> → time(sec), dominant MIDI, bass MIDI (0 if none).</small>

    <div class="hr"></div>
    <label style="font-weight:600">Load CSV to A / B</label>
    <div class="row">
      <div>
        <input id="csvA" type="file" accept=".csv"/>
        <button id="btnLoadA" style="margin-top:6px">Load CSV → A</button>
      </div>
      <div>
        <input id="csvB" type="file" accept=".csv"/>
        <button id="btnLoadB" style="margin-top:6px">Load CSV → B</button>
      </div>
    </div>

    <div class="hr"></div>
    <label>Speed</label>
    <div class="row">
      <div class="whiteSquare" data-speed="0.8">Slow (0.8×)</div>
      <div class="whiteSquare active" data-speed="1.0">Medium (1.0×)</div>
    </div>
    <div class="row" style="margin-top:8px">
      <div class="whiteSquare" data-speed="1.25">Fast (1.25×)</div>
      <div class="whiteSquare" data-speed="1.5">Very Fast (1.5×)</div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Mix A</label>
        <input id="mixA" type="range" min="0" max="1" step="0.01" value="0.85"/>
      </div>
      <div>
        <label>Mix B</label>
        <input id="mixB" type="range" min="0" max="1" step="0.01" value="0.70"/>
      </div>
    </div>

    <div style="margin-top:8px">
      <label>Master Volume</label>
      <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.75"/>
    </div>

    <div class="hr"></div>
    <div class="row">
      <button id="playBtn">Play (60s)</button>
      <button id="stopBtn" class="danger">Stop</button>
    </div>
    <button id="resetBtn" style="margin-top:8px">Reset</button>
    <div id="status">Ready.</div>
  </section>

  <!-- RIGHT: Visuals -->
  <section class="card">
    <label>Piano-roll (A + B, time → note)</label>
    <canvas id="roll" width="960" height="240"></canvas>

    <div class="row" style="margin-top:8px">
      <div>
        <label>Preview (A+B) — time, dominant, bass</label>
        <div id="previewList" class="scroller mono"></div>
      </div>
      <div>
        <label>Pitch-class histogram — from last analysis</label>
        <div id="hist" class="scroller mono" style="min-height:120px"></div>
      </div>
    </div>
  </section>
</main>

<script>
/* ============ Utilities ============ */
const NOTE=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const MAJOR=[0,2,4,5,7,9,11], MINOR=[0,2,3,5,7,8,10];
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const midiHz=m=>440*Math.pow(2,(m-69)/12);
const midiName=m=>NOTE[(m%12+12)%12]+(Math.floor(m/12)-1);
const median=a=>{const s=[...a].sort((x,y)=>x-y),n=s.length;return n?(n%2?s[(n-1)/2]:(s[n/2-1]+s[n/2])/2):0};
function pcsFor(key){const t=NOTE.indexOf(key.split(" ")[0]);if(t<0)return null;const minor=/minor/i.test(key);const base=minor?MINOR:MAJOR;return base.map(pc=>(pc+t+120)%12)}
function snap(m,pcs){if(!pcs)return Math.round(m); const pc=(Math.round(m)%12+12)%12; if(pcs.includes(pc))return Math.round(m);
  for(const d of [1,-1,2,-2]){const c=(pc+d+12)%12; if(pcs.includes(c)) return Math.round(m)+d;} return Math.round(m);}

/* ============ UI refs ============ */
const $=id=>document.getElementById(id);
const btnLoadAudio=$('btnLoadAudio'), btnAnalyze=$('btnAnalyze'), btnExport=$('btnExport'), audioFile=$('audioFile');
const detKey=$('detKey'), detBPM=$('detBPM');
const csvA=$('csvA'), csvB=$('csvB'), btnLoadA=$('btnLoadA'), btnLoadB=$('btnLoadB');
const playBtn=$('playBtn'), stopBtn=$('stopBtn'), resetBtn=$('resetBtn');
const mixAEl=$('mixA'), mixBEl=$('mixB'), masterVolEl=$('masterVol');
const speedSquares=[...document.querySelectorAll('.whiteSquare')];
const statusEl=$('status'), roll=$('roll'), rc=roll.getContext('2d');
const previewList=$('previewList'), histEl=$('hist');

/* ============ State ============ */
let A={events:[]};  // array of {t,m,b}
let B={events:[]};
let LAST_ANALYSIS={events:[], key:"–", bpm:100, pclass:new Float32Array(12)};
let AUDIO={ctx:null, master:null, comp:null, speed:1.0};
let sch=[], idx=0, timer=null, t0=0;
const LOOKAHEAD=0.25, TICK=25;

/* ============ Status helper ============ */
function setStatus(s){ statusEl.textContent=s; }

/* ============ Audio (built-in synth) ============ */
function getAudio(){
  if(!AUDIO.ctx){
    const ctx=new (window.AudioContext||window.webkitAudioContext)();
    const comp=ctx.createDynamicsCompressor(); comp.threshold.setValueAtTime(-18,ctx.currentTime);
    const master=ctx.createGain(); master.gain.setValueAtTime(parseFloat(masterVolEl.value||"0.75"), ctx.currentTime);
    comp.connect(master); master.connect(ctx.destination);
    AUDIO={ctx,comp,master,speed:1.0};
  }
  AUDIO.master.gain.value=parseFloat(masterVolEl.value||"0.75");
  return AUDIO.ctx;
}
async function resume(){ const ctx=getAudio(); if(ctx.state==='suspended'){ try{await ctx.resume();}catch(_){} } return ctx; }

function preset(midi,isBass){
  if(isBass||midi<=52) return {wave:'sawtooth', lp:480, q:0.9, a:0.004, d:0.06, s:0.6, r:0.08};
  if(midi<=72)       return {wave:'triangle', lp:2200, q:0.7, a:0.006, d:0.16, s:0.7, r:0.18};
  return               {wave:'square',   lp:2600, q:0.7, a:0.004, d:0.14, s:0.6, r:0.16};
}
function playNote(midi,when,dur,gain,isBass){
  const ctx=getAudio(); const p=preset(midi,isBass);
  const osc=ctx.createOscillator(); osc.type=p.wave; osc.frequency.setValueAtTime(midiHz(midi),when);
  const biq=ctx.createBiquadFilter(); biq.type='lowpass'; biq.frequency.setValueAtTime(p.lp,when); biq.Q.setValueAtTime(p.q,when);
  const amp=ctx.createGain(); amp.gain.setValueAtTime(0,when);
  amp.gain.linearRampToValueAtTime(gain,when+p.a);
  amp.gain.linearRampToValueAtTime(gain*p.s,when+p.a+p.d);
  amp.gain.setValueAtTime(gain*p.s, when+dur);
  amp.gain.linearRampToValueAtTime(0.0005, when+dur+p.r);
  osc.connect(biq); biq.connect(amp); amp.connect(AUDIO.comp);
  osc.start(when); osc.stop(when+dur+p.r+0.05);
}

/* ============ Build schedule from CSV events ============ */
function scheduleFrom(events, side){
  // quantize to stable grid derived from an assumed bpm (we’ll use 100 if unknown)
  const bpm=100; const spb=60/bpm, grid=Math.max(0.1, spb/4);
  const out=[]; const last=new Map(); let perSec=0, s=-1;
  for(const e of events){
    const tQ=Math.max(0,Math.min(60, Math.round(e.t/grid)*grid));
    const sec=Math.floor(tQ); if(sec!==s){perSec=0;s=sec;}
    const add=(m,isBass)=>{
      if(!m) return; const L=last.get(m)||-999; if(tQ-L<0.06) return; if(perSec>14) return;
      last.set(m,tQ); perSec++; out.push({t:tQ,midi:Math.round(m), isBass, side});
    };
    add(e.m||0,false); add(e.b||0,true);
  }
  return out.sort((a,b)=>a.t-b.t);
}
function buildSchedule(){ return [...scheduleFrom(A.events,'A'), ...scheduleFrom(B.events,'B')].sort((a,b)=>a.t-b.t); }

/* ============ Scheduler ============ */
function tick(){
  const ctx=AUDIO.ctx, now=ctx.currentTime, horizon=now+LOOKAHEAD, speed=AUDIO.speed||1.0;
  while(idx<sch.length){
    const e=sch[idx]; const when=t0 + e.t*(1/speed); if(when>horizon) break;
    const dur=(e.midi<=52?0.55:0.35)*(1/speed);
    const sideGain=(e.side==='B'? parseFloat(mixBEl.value||"0.7") : parseFloat(mixAEl.value||"0.85"));
    const vel=(e.midi<=52?0.95:0.8)*sideGain;
    playNote(e.midi, when, dur, vel, e.isBass);
    idx++;
  }
  if(idx>=sch.length){ clearInterval(timer); timer=null; setStatus("Finished."); }
}
async function doPlay(){
  await resume();
  stopAll();
  if(!A.events.length && !B.events.length){ alert("Load a CSV into A and/or B first."); return; }
  sch=buildSchedule();
  if(!sch.length){ alert("CSV had no notes within 0–60s."); return; }
  const ctx=AUDIO.ctx;
  t0=ctx.currentTime+0.06; idx=0; timer=setInterval(tick,TICK);
  setStatus("Playing…");
}
function stopAll(){ if(timer){clearInterval(timer); timer=null;} idx=sch.length; setStatus("Stopped."); }

/* ============ CSV helpers ============ */
function parseCSV(text){
  // expects header with t,m,b (order flexible); ignores extra columns; skips blanks
  const lines=text.replace(/\r/g,'').trim().split('\n');
  if(!lines.length) return [];
  const hdr=lines[0].split(',').map(s=>s.trim().toLowerCase());
  const ti=hdr.indexOf('t'), mi=hdr.indexOf('m'), bi=hdr.indexOf('b');
  if(ti<0 || mi<0 || bi<0) throw new Error("CSV must have headers: t,m,b");
  const out=[];
  for(let i=1;i<lines.length;i++){
    const row=lines[i].split(',').map(s=>s.trim());
    if(!row.length||row.every(x=>x==="")) continue;
    const t=parseFloat(row[ti]||"0"); const m=parseInt(row[mi]||"0",10); const b=parseInt(row[bi]||"0",10);
    if(Number.isFinite(t) && t>=0 && t<=60){ out.push({t, m: (m|0), b: (b|0)}); }
  }
  return out.sort((a,b)=>a.t-b.t);
}
function toCSV(events){
  const rows=["t,m,b"];
  for(const e of events){ rows.push(`${e.t.toFixed(3)},${e.m|0},${e.b|0}`); }
  return rows.join("\n");
}
function downloadCSV(name, text){
  const blob=new Blob([text],{type:"text/csv"}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ============ Piano roll + preview ============ */
function drawRoll(){
  const w=roll.width,h=roll.height; rc.clearRect(0,0,w,h);
  rc.strokeStyle="rgba(110,231,255,0.25)";
  for(let i=0;i<=10;i++){const x=i/10*w; rc.beginPath(); rc.moveTo(x,0); rc.lineTo(x,h); rc.stroke();}
  const minM=36,maxM=84,span=maxM-minM; const yy=m=>h-((m-minM)/span)*h;
  (A.events||[]).forEach(e=>{ if(e.m){ const x=e.t/60*w; rc.fillStyle="rgba(110,231,255,0.9)"; rc.fillRect(x,yy(e.m)-3,3,6);} if(e.b){ const x=e.t/60*w; rc.fillStyle="rgba(16,185,129,0.9)"; rc.fillRect(x,yy(e.b)-4,4,8);} });
  (B.events||[]).forEach(e=>{ if(e.m){ const x=e.t/60*w; rc.fillStyle="rgba(255,206,86,0.9)"; rc.fillRect(x,yy(e.m)-2,2,4);} if(e.b){ const x=e.t/60*w; rc.fillStyle="rgba(255,99,132,0.9)"; rc.fillRect(x,yy(e.b)-3,3,6);} });
}
function renderPreview(){
  const lines=[" time     DOM_A   BASS_A    DOM_B   BASS_B"];
  const tset=new Set([...A.events.map(e=>e.t), ...B.events.map(e=>e.t)]);
  const times=[...tset].sort((a,b)=>a-b).filter(t=>t<=60);
  for(const t of times){
    const a=A.events.find(e=>Math.abs(e.t-t)<1e-6)||{};
    const b=B.events.find(e=>Math.abs(e.t-t)<1e-6)||{};
    const ts=t.toFixed(2).padStart(6,' ');
    const ad=a.m?midiName(a.m).padEnd(5,' '):" --  "; const ab=a.b?midiName(a.b).padEnd(5,' '):" --  ";
    const bd=b.m?midiName(b.m).padEnd(5,' '):" --  "; const bb=b.b?midiName(b.b).padEnd(5,' '):" --  ";
    lines.push(`${ts}s   ${ad}   ${ab}    ${bd}   ${bb}`);
    if(lines.length>400) break;
  }
  previewList.textContent=lines.join("\n");
}

/* ============ Analysis (audio → LAST_ANALYSIS.events, key, bpm) ============ */
const KS_MAJ=[6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
const KS_MIN=[6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];
function correlate(h){
  const n=Math.hypot(...h)||1, hh=h.map(x=>x/n); let best={name:"C major",score:-1};
  for(let r=0;r<12;r++){
    const maj=KS_MAJ.reduce((s,v,i)=>s+v*hh[(i+r)%12],0);
    const min=KS_MIN.reduce((s,v,i)=>s+v*hh[(i+r)%12],0);
    if(maj>best.score) best={name:`${NOTE[r]} major`,score:maj};
    if(min>best.score) best={name:`${NOTE[r]} minor`,score:min};
  }
  return best.name;
}
function zcPitch(frame,sr){
  let c=0; for(let i=1;i<frame.length;i++){const a=frame[i-1],b=frame[i]; if((a<=0&&b>0)||(a>=0&&b<0))c++;}
  const f=(c/2)*(sr/frame.length); return (f>40&&f<2000)?f:0;
}
function acPitch(frame,sr){
  const N=frame.length; let mean=0; for(let i=0;i<N;i++)mean+=frame[i]; mean/=N;
  for(let i=0;i<N;i++) frame[i]=(frame[i]-mean)*(0.5-0.5*Math.cos(2*Math.PI*i/(N-1)));
  const minF=60,maxF=1000,minLag=Math.floor(sr/maxF),maxLag=Math.floor(sr/minF); let bestLag=0,best=0;
  for(let lag=minLag;lag<=Math.min(maxLag,N-2);lag++){let s=0;for(let i=0;i<N-lag;i++)s+=frame[i]*frame[i+lag]; if(s>best){best=s;bestLag=lag;}}
  return bestLag? sr/bestLag : 0;
}
function estBPM(onsets,sr){
  if(onsets.length<3) return 100;
  const dif=[]; for(let i=1;i<onsets.length;i++){const dt=(onsets[i]-onsets[i-1])/sr; if(dt>0.18&&dt<2.2) dif.push(dt);}
  if(!dif.length) return 100; const m=dif.sort((a,b)=>a-b)[Math.floor(dif.length/2)];
  let bpm=Math.round(60/m); while(bpm<60) bpm*=2; while(bpm>180) bpm=Math.round(bpm/2); return bpm;
}
function drawHist(el,h){const tot=Array.from(h).reduce((a,b)=>a+b,0)||1; let out="PC  %\n";
  for(let i=0;i<12;i++){ const pct=(h[i]/tot*100).toFixed(1).padStart(5,' '); out+=`${NOTE[i].padEnd(2,' ')} ${pct}%\n`; } el.textContent=out;}

async function analyzeAudio(file){
  if(!file){ alert("Choose an audio file first."); return; }
  setStatus("Decoding audio…");
  const arr=await file.arrayBuffer();
  const ctx=new (window.AudioContext||window.webkitAudioContext)();
  const buf=await ctx.decodeAudioData(arr.slice(0));
  const sr=buf.sampleRate, ch=buf.numberOfChannels, mono=new Float32Array(buf.length);
  for(let c=0;c<ch;c++){const d=buf.getChannelData(c); for(let i=0;i<d.length;i++) mono[i]=(mono[i]||0)+d[i]/ch;}

  const frame=4096, hop=2048, maxS=Math.min(mono.length, sr*60);
  const events=[], pc=new Float32Array(12), on=[];
  let prevE=0;

  setStatus("Analyzing 60s…");
  for(let st=0; st+frame<=maxS; st+=hop){
    const fr=mono.subarray(st,st+frame);
    let E=0; for(let i=0;i<fr.length;i++) E+=fr[i]*fr[i];
    const dE=E-prevE; prevE=E; if(dE>0.08) on.push(st);

    let f=acPitch(fr.slice(),sr); if(!f) f=zcPitch(fr,sr);
    let m=0,b=0;
    if(f){ m=clamp(Math.round(69+12*Math.log2(f/440)),24,96); if(f<=220) b=clamp(Math.round(69+12*Math.log2(f/440)),28,72); pc[(m%12+12)%12]++; }
    events.push({t:st/sr, m, b});
  }

  // median smoothing
  const smooth=(list,key)=>{const half=2,a=list.map(e=>e[key]||0),sm=[];
    for(let i=0;i<a.length;i++){const w=[]; for(let k=Math.max(0,i-half);k<=Math.min(a.length-1,i+half);k++) if(a[k]) w.push(a[k]);
      sm[i]=w.length?Math.round(median(w)):0;} for(let i=0;i<list.length;i++) list[i][key]=sm[i];};
  smooth(events,'m'); smooth(events,'b');

  // key / snap (optional – keep raw for export, but we’ll snap lightly to increase musicality)
  const key=correlate(Array.from(pc)); const pcs=pcsFor(key);
  for(const e of events){ if(e.m) e.m=snap(e.m,pcs); if(e.b) e.b=snap(e.b,pcs); }

  const bpm=estBPM(on,sr);

  LAST_ANALYSIS={events, key, bpm, pclass:pc};
  detKey.textContent=key; detBPM.textContent=String(bpm);
  drawHist(histEl, pc);
  setStatus("Analysis complete. Click Export CSV to download.");
}

/* ============ Wire-up ============ */
btnLoadAudio.addEventListener('click', ()=>audioFile.click());
btnAnalyze.addEventListener('click', ()=>analyzeAudio(audioFile.files?.[0]));
btnExport.addEventListener('click', ()=>{
  if(!LAST_ANALYSIS.events.length){ alert("Analyze an audio file first."); return; }
  const csv=toCSV(LAST_ANALYSIS.events.filter(e=>e.t>=0 && e.t<=60));
  downloadCSV("notes_60s.csv", csv);
});

btnLoadA.addEventListener('click', async ()=>{
  const f=csvA.files?.[0]; if(!f){ alert("Select a CSV for A."); return; }
  const text=await f.text(); try{ A.events=parseCSV(text); }catch(e){ alert(e.message); return; }
  drawRoll(); renderPreview(); setStatus(`Loaded ${A.events.length} notes into A.`);
});
btnLoadB.addEventListener('click', async ()=>{
  const f=csvB.files?.[0]; if(!f){ alert("Select a CSV for B."); return; }
  const text=await f.text(); try{ B.events=parseCSV(text); }catch(e){ alert(e.message); return; }
  drawRoll(); renderPreview(); setStatus(`Loaded ${B.events.length} notes into B.`);
});

speedSquares.forEach(sq=>sq.addEventListener('click', ()=>{
  speedSquares.forEach(x=>x.classList.remove('active'));
  sq.classList.add('active'); AUDIO.speed=parseFloat(sq.dataset.speed)||1.0;
}));
masterVolEl.addEventListener('input', ()=>{ getAudio(); AUDIO.master.gain.value=parseFloat(masterVolEl.value); });

playBtn.addEventListener('click', doPlay);
stopBtn.addEventListener('click', stopAll);
resetBtn.addEventListener('click', ()=>{
  stopAll(); A={events:[]}; B={events:[]}; LAST_ANALYSIS={events:[], key:"–", bpm:100, pclass:new Float32Array(12)};
  detKey.textContent='–'; detBPM.textContent='–'; histEl.textContent=''; previewList.textContent='';
  drawRoll(); setStatus("Ready.");
});

/* ============ Init ============ */
(function init(){
  drawRoll();
  setStatus("Ready.");
})();
</script>
</body>
</html>
