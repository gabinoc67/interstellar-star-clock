<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST Astrodumus — LIVE Orchestrator (Alternating Symphony • Up to 20 Instruments)</title>
<meta name="description" content="Upload a song, detect its tempo & beats, and perform a symphonic remake with alternating sections (1–20 instruments), following your song’s rhythm. Includes LIVE button and full reset."/>
<style>
  :root{
    --bg:#081024;--panel:#0e1634;--ink:#e9f1ff;--muted:#a2b4e8;--grid:#1a2660;--btn:#162760;
    --accent:#9bd1ff;--ok:#3fe6a0;--warn:#ffb86b;--liveOff:#222b5a;--liveOn:#00d27a;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:18px}
  h1{margin:0 0 6px;font-size:1.35rem}
  p.sub{margin:0 0 14px;color:var(--muted)}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.25);overflow:hidden}
  .pad{padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{background:var(--btn);color:var(--ink);border:1px solid #273a8a;border-radius:12px;padding:10px 14px;cursor:pointer}
  button:hover{filter:brightness(1.08)}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{accent-color:#5ea0ff}
  .status{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-top:10px}
  .status>div{background:#0b1333;border:1px solid var(--grid);border-radius:10px;padding:10px;min-height:54px}
  .tiny{font-size:.85rem;color:var(--muted)}
  canvas{width:100%;height:160px;display:block;background:linear-gradient(180deg,#0b1536,#0b1230)}
  #timeline{height:260px;margin-top:6px}

  /* BIG LIVE BUTTON */
  .liveWrap{display:flex;justify-content:center;align-items:center;padding:16px 14px 6px;gap:10px}
  #liveBtn{
    flex:1;
    height:110px; border-radius:20px; border:2px solid #10206a;
    background:linear-gradient(180deg,var(--liveOff),#111a44);
    box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.04);
    color:#cfe7ff; font-weight:900; font-size:48px; letter-spacing:6px;
    display:flex; align-items:center; justify-content:center; user-select:none;
    cursor:not-allowed; position:relative; transition:transform .08s ease, filter .12s ease;
  }
  #liveBtn.ready{
    cursor:pointer; background:linear-gradient(180deg,#0ccf7c,var(--liveOn));
    color:#08221a; border-color:#0a9c5e; text-shadow:0 1px 0 rgba(255,255,255,.35);
    box-shadow:0 12px 40px rgba(3,210,122,.35), inset 0 0 0 2px rgba(255,255,255,.08);
  }
  #liveBtn.playing{
    background:linear-gradient(180deg,#10e08a,#06c776);
    box-shadow:0 14px 42px rgba(3,210,122,.5), inset 0 0 0 2px rgba(255,255,255,.1);
  }
  #liveSub{
    position:absolute; bottom:10px; font-size:14px; letter-spacing:1.2px; opacity:.85
  }
  .tag{display:inline-block;padding:2px 8px;border:1px solid var(--grid);border-radius:999px;background:#0b1436;color:#cfe0ff;font-size:.8rem}
  .pill{display:inline-block;padding:4px 8px;border:1px solid #243170;border-radius:999px;background:#0b1436;color:#a8b8ee;font-size:.8rem}
  .roleLegend{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST “Astrodumus” — LIVE Orchestrator (Alternating Symphony)</h1>
  <p class="sub">Upload a song → Analyze → when the big <b>LIVE</b> button turns green, click it. The orchestra follows your song’s tempo & onsets and alternates between up to 20 instruments (not everybody plays at once).</p>

  <section class="card">
    <div class="pad">
      <div class="row">
        <input id="file" type="file" accept="audio/*"/>
        <button id="analyze">Analyze Uploaded Song</button>
        <button id="resetAll">⟲ Reset (remove song)</button>
        <button id="export" disabled>⬇ Download Orchestral WAV</button>
        <span id="loaded" class="tag">No file loaded</span>
      </div>

      <div class="status">
        <div><b>Detected BPM</b><div id="bpmOut" class="tiny">–</div></div>
        <div><b>Beats</b><div id="beatsOut" class="tiny">–</div></div>
        <div><b>Length</b><div id="lenOut" class="tiny">–</div></div>
        <div><b>Voices (dynamic)</b><div id="voicesOut" class="tiny">–</div></div>
        <div><b>Roles Active</b><div id="rolesOut" class="tiny">–</div></div>
        <div><b>Palette</b><div id="paletteOut" class="tiny">Auto-rotate by energy</div></div>
      </div>

      <div class="roleLegend">
        <span class="pill">Lead: strings/woods/brass/piano</span>
        <span class="pill">Bed: strings/pad/choir</span>
        <span class="pill">Sparkle: harp/glock/celesta/vibes/marimba/bells/tubular</span>
        <span class="pill">Bass: abass/sbass/timp (low)</span>
        <span class="pill">Perc: light orchestral (derived)</span>
      </div>
    </div>

    <div class="liveWrap">
      <div id="liveBtn"><span>LIVE</span><div id="liveSub">Load & Analyze to Enable</div></div>
    </div>

    <canvas id="wave" title="Waveform + detected beats"></canvas>
    <canvas id="timeline" title="Alternating orchestral events — locked to your song"></canvas>

  </section>
</div>

<script>
/* ===== Mini helpers ===== */
const $=id=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function hash32(n){ // deterministic but simple
  let x = (n|0) ^ 0x9e3779b9;
  x = Math.imul(x ^ (x>>>16), 0x21f0aaad);
  x = Math.imul(x ^ (x>>>15), 0x735a2d97);
  return (x ^ (x>>>15))>>>0;
}
function pickDet(arr, seed){ return arr[ seed % arr.length ]; }

/* ===== Global State ===== */
let SRC_ARRAYBUF=null, ANALYSIS=null, SCORE=null;
let ACTX=null, master=null, sendRev=null; const BUS={}; let scheduled=[], playing=false;

/* ===== UI state ===== */
function setReady(isReady){
  const live=$('liveBtn');
  if(isReady){
    live.classList.add('ready');
    $('liveSub').textContent='CLICK TO PLAY';
    $('export').disabled=false;
  }else{
    live.classList.remove('ready'); live.classList.remove('playing');
    $('liveSub').textContent='Load & Analyze to Enable';
    $('export').disabled=true;
  }
  $('voicesOut').textContent='–';
  $('rolesOut').textContent='–';
}
function clearCanvases(){
  const wave=$('wave').getContext('2d'), tl=$('timeline').getContext('2d');
  [wave,tl].forEach(ctx=>{
    const c=ctx.canvas, dpr=window.devicePixelRatio||1;
    c.width=c.clientWidth*dpr; c.height=c.clientHeight*dpr; ctx.clearRect(0,0,c.width,c.height);
  });
}

/* ===== Drawing ===== */
function drawWaveform(canvas, pcm, sr, beatsSec){
  const ctx=canvas.getContext('2d');
  const dpr=window.devicePixelRatio||1; const W=canvas.clientWidth*dpr, H=canvas.clientHeight*dpr; canvas.width=W; canvas.height=H;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#0b1436'; ctx.fillRect(0,0,W,H);
  // waveform
  ctx.strokeStyle='#96b7ff'; ctx.lineWidth=1;
  ctx.beginPath();
  const step=Math.max(1, Math.floor(pcm.length/W));
  const mid=H/2, scale=H*0.45;
  for(let x=0, i=0; x<W; x++, i+=step){
    let min=1e9, max=-1e9;
    for(let j=0;j<step && i+j<pcm.length;j++){
      const v=pcm[i+j];
      if(v<min)min=v; if(v>max)max=v;
    }
    ctx.moveTo(x, mid+min*scale); ctx.lineTo(x, mid+max*scale);
  }
  ctx.stroke();
  // beats
  if(beatsSec && beatsSec.length){
    ctx.strokeStyle='#1b2a66';
    for(const t of beatsSec){
      const x = (t/ (pcm.length/sr)) * W;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    ctx.strokeStyle='#ffd38a'; ctx.lineWidth=1.5;
    beatsSec.forEach((t,idx)=>{
      if(idx%4===0){ const x=(t/(pcm.length/sr))*W; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    });
  }
}
function drawTimeline(canvas, score){
  const ctx=canvas.getContext('2d');
  const dpr=window.devicePixelRatio||1; const W=canvas.clientWidth*dpr, H=canvas.clientHeight*dpr; canvas.width=W; canvas.height=H;
  ctx.clearRect(0,0,W,H);
  const rows=['piano','strings','woods','brass','pad','choir','harp','glock','celesta','vibraphone','marimba','bells','tubular','abass','sbass','timp','perc'];
  const colors={piano:'#b8e1ff',strings:'#ffddb0',woods:'#c8ffc8',brass:'#ffd1d1',pad:'#b8fff6',choir:'#d9c5ff',harp:'#ffe7f3',glock:'#e9ffbe',celesta:'#d6f0ff',vibraphone:'#c9ffe9',marimba:'#ffe4be',bells:'#fff0b8',tubular:'#fff6d0',abass:'#ffd3a3',sbass:'#ffc2e0',timp:'#eac2ff',perc:'#b0b9c9'};
  const rh=H/rows.length;
  ctx.strokeStyle="#1b2a66"; ctx.lineWidth=1;
  for(let i=0;i<=16;i++){ const x=i*(W/16); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  function rx(t){ return (t/score.seconds)*W; }
  score.events.forEach(e=>{
    const ri=rows.indexOf(e.inst); if(ri<0) return;
    const x=rx(e.time), w=(e.dur/score.seconds)*W, y=ri*rh+rh*0.22, h=rh*0.56;
    ctx.fillStyle=colors[e.inst]||'#eee'; ctx.fillRect(x,y,Math.max(1.5,w),h);
  });
}

/* ===== Audio Engine (synth colors) ===== */
function ensureAudio(){
  if(ACTX) return;
  ACTX=new (window.AudioContext||window.webkitAudioContext)();
  master=ACTX.createGain(); master.gain.value=0.9; master.connect(ACTX.destination);
  const sum=ACTX.createGain(); sum.connect(master);
  const delays=[0.0297,0.0371,0.0411,0.0437], gains=[0.805,0.827,0.783,0.764];
  for(let i=0;i<4;i++){ const d=ACTX.createDelay(1); d.delayTime.value=delays[i]; const g=ACTX.createGain(); g.gain.value=gains[i]; d.connect(g); g.connect(d); g.connect(sum); }
  sendRev=ACTX.createGain(); sendRev.gain.value=0.22; sendRev.connect(sum);
}
async function unlockAudio(){ ensureAudio(); try{ await ACTX.resume(); }catch(e){} }
function makeBus(level,pan=0){
  const g=ACTX.createGain(); g.gain.value=level;
  const p=ACTX.createStereoPanner?ACTX.createStereoPanner():null;
  if(p){ p.pan.value=pan; g.connect(p); p.connect(master); } else { g.connect(master); }
  const send=ACTX.createGain(); send.gain.value=0.0; g.connect(send); send.connect(sendRev);
  return {g,send};
}
function env(g,t0,a,d,sus,hold,rel,vel){
  const t1=t0+a, t2=t1+d, t3=t2+hold, t4=t3+rel;
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(vel,t1);
  g.gain.linearRampToValueAtTime(vel*sus,t2);
  g.gain.setValueAtTime(vel*sus,t3);
  g.gain.linearRampToValueAtTime(0,t4);
  return t4;
}
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
const BUS_LIST=['piano','strings','woods','brass','pad','choir','harp','glock','celesta','vibraphone','marimba','bells','tubular','abass','sbass','timp','perc'];
function initBuses(){ BUS_LIST.forEach((k,i)=>{ BUS[k]=BUS[k]||makeBus(0.72,(i%2?0.12:-0.12)); }); }

/* Patches — lightweight synth approximations */
const Patches = {
  piano:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=4800;
    const g=ACTX.createGain(); const end=env(g,t,0.005,0.18,0.35,Math.max(0.02,d-0.2),0.25,v*0.8);
    o.connect(f); f.connect(g); g.connect(BUS.piano.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  pad:(m,t,d,v)=>{ const o1=ACTX.createOscillator(), o2=ACTX.createOscillator(); o1.type='sawtooth'; o2.type='triangle';
    o1.frequency.value=midiToHz(m)*0.999; o2.frequency.value=midiToHz(m)*1.001;
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=env(g,t,0.4,1.8,0.7,Math.max(0.3,d-1.2),1.5,v*0.4);
    o1.connect(f); o2.connect(f); f.connect(g); g.connect(BUS.pad.g); g.connect(BUS.pad.send);
    o1.start(t); o2.start(t); o1.stop(end); o2.stop(end); scheduled.push({o:[o1,o2],g,end}); },
  strings:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200;
    const g=ACTX.createGain(); const end=env(g,t,0.08,0.5,0.8,Math.max(0.05,d-0.4),0.3,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.strings.g); g.connect(BUS.strings.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  choir:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const lfo=ACTX.createOscillator(); lfo.frequency.value=5.5; const lg=ACTX.createGain(); lg.gain.value=6; lfo.connect(lg); lg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.2,0.8,0.6,Math.max(0.15,d-0.8),1.0,v*0.55);
    o.connect(g); g.connect(BUS.choir.g); g.connect(BUS.choir.send);
    o.start(t); lfo.start(t); o.stop(end); lfo.stop(end); scheduled.push({o:[o,lfo],g,end}); },
  brass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
    const g=ACTX.createGain(); const end=env(g,t,0.02,0.25,0.6,Math.max(0.05,d-0.3),0.25,v*0.8);
    o.connect(f); f.connect(g); g.connect(BUS.brass.g); g.connect(BUS.brass.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  woods:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=env(g,t,0.03,0.22,0.55,Math.max(0.05,d-0.25),0.2,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.woods.g); g.connect(BUS.woods.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  harp:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.22,0.35,0.01,0.4,v*0.7);
    o.connect(g); g.connect(BUS.harp.g); g.connect(BUS.harp.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  glock:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=env(g,t,0.001,0.4,0.25,0.02,0.8,v*0.6);
    o.connect(g); g.connect(BUS.glock.g); g.connect(BUS.glock.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  celesta:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=env(g,t,0.003,0.18,0.3,0.02,0.7,v*0.6);
    o.connect(g); g.connect(BUS.celesta.g); g.connect(BUS.celesta.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  vibraphone:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const lfo=ACTX.createOscillator(); lfo.frequency.value=6; const lg=ACTX.createGain(); lg.gain.value=10; lfo.connect(lg); lg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.5,0.5,0.1,0.9,v*0.55);
    o.connect(g); g.connect(BUS.vibraphone.g); g.connect(BUS.vibraphone.send);
    o.start(t); lfo.start(t); o.stop(end); lfo.stop(end); scheduled.push({o:[o,lfo],g,end}); },
  marimba:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.35,0.35,0.02,0.6,v*0.7);
    o.connect(g); g.connect(BUS.marimba.g); g.connect(BUS.marimba.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  bells:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const fm=ACTX.createOscillator(); fm.frequency.value=880; const fg=ACTX.createGain(); fg.gain.value=30; fm.connect(fg); fg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.001,0.8,0.2,0.02,1.6,v*0.7);
    o.connect(g); g.connect(BUS.bells.g); g.connect(BUS.bells.send);
    o.start(t); fm.start(t); o.stop(end); fm.stop(end); scheduled.push({o:[o,fm],g,end}); },
  tubular:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m)/2;
    const g=ACTX.createGain(); const end=env(g,t,0.005,1.2,0.8,0.3,2.2,v*0.7);
    o.connect(g); g.connect(BUS.tubular.g); g.connect(BUS.tubular.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  abass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.01,0.3,0.5,Math.max(0.05,d-0.25),0.25,v*0.7);
    o.connect(g); g.connect(BUS.abass.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  sbass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900;
    const g=ACTX.createGain(); const end=env(g,t,0.02,0.25,0.6,Math.max(0.05,d-0.3),0.25,v*0.7);
    o.connect(f); f.connect(g); g.connect(BUS.sbass.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  timp:(m,t,d,v)=>{ // pitched, short boom
    const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(midiToHz(m)/2,t);
    const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.8,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.8);
    o.connect(g); g.connect(BUS.timp.g); o.start(t); o.stop(t+0.82); scheduled.push({o:[o],g,end:t+0.82}); }
};

/* ===== Load & simple analysis (onsets + BPM + beat grid) ===== */
$('file').addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  SRC_ARRAYBUF = await f.arrayBuffer();
  $('loaded').textContent = `Loaded: ${f.name}`;
  $('loaded').style.borderColor = '#2f7fff';
  setReady(false); ANALYSIS=null; SCORE=null; clearCanvases();
  $('bpmOut').textContent='–'; $('beatsOut').textContent='–'; $('lenOut').textContent='–';
});

$('analyze').addEventListener('click', async ()=>{
  if(!SRC_ARRAYBUF){ alert('Choose an audio file first.'); return; }
  ensureAudio();
  const ctx = new OfflineAudioContext(1, 44100*480, 44100); // up to 8 minutes mono
  let audioBuf;
  try { audioBuf = await ctx.decodeAudioData(SRC_ARRAYBUF.slice(0)); }
  catch(e){ alert('Decode failed. Try a different file.'); return; }
  const sr = audioBuf.sampleRate;
  const pcm = audioBuf.getChannelData(0);

  // Quick flux onset detection
  const diff = new Float32Array(pcm.length);
  for(let i=1;i<pcm.length;i++) diff[i] = pcm[i] - pcm[i-1]*0.97;

  const hop=512, win=1024;
  const flux=[]; let prevBins=new Float32Array(64);
  for(let i=0;i+win<diff.length;i+=hop){
    const seg=diff.subarray(i,i+win);
    const bins=new Float32Array(64);
    const step=Math.max(1, Math.floor(seg.length/64));
    let idx=0; for(let b=0;b<64;b++){ let s=0,n=0; for(let k=0;k<step && idx<seg.length;k++){ s+=seg[idx]*seg[idx]; n++; idx++; } bins[b]=Math.sqrt(s/(n||1)); }
    let fval=0; for(let b=0;b<64;b++){ const d=bins[b]-prevBins[b]; if(d>0) fval+=d; } flux.push(fval); prevBins=bins;
  }
  const fmax=Math.max(...flux,1e-9); for(let i=0;i<flux.length;i++) flux[i]/=fmax;
  const thr=new Float32Array(flux.length); const THW=16;
  for(let i=0;i<thr.length;i++){ let s=0,c=0; for(let j=-THW;j<=THW;j++){ const k=i+j; if(k>=0 && k<thr.length){ s+=flux[k]; c++; }} thr[i]=(s/(c||1))*0.9; }
  const onsets=[];
  for(let i=2;i<flux.length-2;i++){
    const v=flux[i]-thr[i];
    if(v>0 && v>flux[i-1]-thr[i-1] && v>flux[i+1]-thr[i+1]) onsets.push(i);
  }
  const frameSec=hop/sr;
  const onsetsSec = onsets.map(f=>f*frameSec);

  // BPM histogram 60–180
  const BPM_MIN=60, BPM_MAX=180; const hist=new Float32Array(BPM_MAX+1);
  for(let i=1;i<onsetsSec.length;i++){
    const d=onsetsSec[i]-onsetsSec[i-1]; if(d<=0) continue;
    let bpm=60/d; while(bpm>BPM_MAX) bpm/=2; while(bpm<BPM_MIN) bpm*=2;
    const bi=Math.round(bpm); if(bi>=BPM_MIN && bi<=BPM_MAX) hist[bi]+=1;
  }
  let bestBPM=120, bestVal=-1; for(let b=BPM_MIN;b<=BPM_MAX;b++){ if(hist[b]>bestVal){ bestVal=hist[b]; bestBPM=b; } }

  // Align a phase to maximize onset hits on the beat grid
  const beats=[];
  if(onsetsSec.length){
    const beatLen=60/bestBPM; const T=pcm.length/sr;
    let bestPhase=0, bestMatches=-1;
    for(let k=0;k<24;k++){
      const phase=(k/24)*beatLen; let m=0;
      for(let tt=phase; tt<T; tt+=beatLen){
        for(const o of onsetsSec){ if(Math.abs(o-tt)<0.04){ m++; break; } }
      }
      if(m>bestMatches){ bestMatches=m; bestPhase=phase; }
    }
    for(let tt=bestPhase; tt<pcm.length/sr; tt+=beatLen) beats.push(tt);
  }

  ANALYSIS = { sr, pcm, lengthSec: pcm.length/sr, onsetsSec, beatsSec:beats, bpm:bestBPM, flux, frameSec };
  $('bpmOut').textContent = bestBPM ? `${bestBPM} BPM` : '–';
  $('beatsOut').textContent = beats.length ? `${beats.length}` : '–';
  $('lenOut').textContent = `${ANALYSIS.lengthSec.toFixed(2)} s`;
  drawWaveform($('wave'), pcm, sr, beats);

  // Build alternating orchestral score (no randomness; deterministic by beat index)
  SCORE = buildAlternatingScore(ANALYSIS);
  drawTimeline($('timeline'), SCORE);
  setReady(true);
});

/* ===== Alternating orchestra logic =====
   - Up to 20 instruments available; we select a subset per beat based on energy.
   - Voices per beat vary with energy (2..6 typical, capped).
   - Roles per beat: bass (0/1), bed (0/1), lead (0/1-2), sparkle (0/1), optional pad/choir on downbeats.
   - Instrument choice is deterministic per beat via hash(beatIndex + role).
   - Phrases: every 4 beats we gently rotate the active palette to keep it musical.
*/
const ROSTER = {
  lead:    ['strings','woods','brass','piano'],
  bed:     ['strings','pad','choir'],
  sparkle: ['harp','glock','celesta','vibraphone','marimba','bells','tubular'],
  bass:    ['abass','sbass','timp']
};
const ALL_INSTR = ['piano','strings','woods','brass','pad','choir','harp','glock','celesta','vibraphone','marimba','bells','tubular','abass','sbass','timp','perc'];

function degToMidi(base,deg){ return base+deg; }
function near(list, t, win){ for(const x of list){ if(Math.abs(x-t)<win) return true; } return false; }

function buildAlternatingScore(analysis){
  const beats=analysis.beatsSec, T=analysis.lengthSec, bpm=analysis.bpm;
  const events=[]; if(!beats || beats.length<4) return {events, seconds:T};
  const meter=4;
  const base=60; // C4-ish
  const chordRoots=[0,5,7,0]; // I–IV–V–I in C (stable cadence)
  const beatDur = 60/bpm;

  // Energy per beat from flux around that time
  function energyAtBeatIdx(i){
    const t=beats[i]; const fIdx=Math.round(t/analysis.frameSec);
    let s=0,c=0; for(let k=-2;k<=2;k++){ const kk=fIdx+k; if(kk>=0 && kk<analysis.flux.length){ s+=analysis.flux[kk]; c++; } }
    return s/(c||1);
  }

  // Dynamic voice/balance based on energy
  function planRoles(i){
    const E=clamp(energyAtBeatIdx(i), 0, 1); // 0..~1
    const voices = Math.round(lerp(2, 6, E)); // typical 2..6
    // base activations
    const active = {bass:false, bed:false, lead:0, sparkle:false};
    // bass on downbeats & medium/high energy
    active.bass = (i%meter===0) || (E>0.35 && i%2===0);
    // bed on every bar, lighter sustain in low energy
    active.bed  = (i%meter===0) || (E>0.6);
    // lead count scales with energy
    active.lead = (E>0.65?2:1);
    // sparkle on upbeat or midpoints
    active.sparkle = (E>0.25) && (i%2===1 || (i%meter===2));
    // enforce voice budget
    let count = (active.bass?1:0) + (active.bed?1:0) + active.lead + (active.sparkle?1:0);
    while(count>voices){
      if(active.sparkle){ active.sparkle=false; count--; continue; }
      if(active.lead>1){ active.lead=1; count--; continue; }
      if(active.bed && E<0.5){ active.bed=false; count--; continue; }
      if(active.bass && E<0.4){ active.bass=false; count--; continue; }
      break;
    }
    return {E,voices,active};
  }

  // Instrument selection per role, deterministic but rotating by phrase
  function chooseInstr(role, i){
    const phrase=Math.floor(i/meter); // every 4 beats
    const seed = hash32(i*131 + phrase*7331 + role.length*97);
    const pool = ROSTER[role];
    // phrase tilt: rotate start index
    const idx = seed % pool.length;
    return pool[idx];
  }

  const nearOnsetWin=Math.min(0.05, beatDur*0.3);
  const add = (inst,time,dur,midi,vel)=>events.push({inst,time,dur,midi,vel});

  for(let i=0;i<beats.length;i++){
    const t=beats[i], tNext=beats[i+1] ?? (t+beatDur);
    const hold = Math.max(beatDur*0.95, 0.15);
    const plan=planRoles(i);

    // chord context
    const barIdx=Math.floor(i/meter);
    const root = chordRoots[barIdx%chordRoots.length];

    // BED: sustained strings/pad/choir alternating by phrase
    if(plan.active.bed){
      const bedInst = chooseInstr('bed', i); // strings/pad/choir
      const bedHold = (i%meter===0) ? Math.min(beatDur*4, (beats[i+4]??(t+beatDur*4))-t) : hold*1.5;
      // triad + light color tone sometimes
      [0,4,7].forEach(iv=> add(bedInst, t, bedHold, degToMidi(base, root+iv), 0.34));
      if((i%meter===0) && (hash32(i)&3)===0){ add(bedInst, t, bedHold, degToMidi(base, root+10), 0.26); }
    }

    // BASS: abass/sbass/timp alternating
    if(plan.active.bass){
      const bInst=chooseInstr('bass', i);
      const bDur = (i%meter===0)?Math.min(beatDur*1.2, tNext-t):hold;
      add(bInst, t, bDur, degToMidi(base, root-24), 0.62);
      if((hash32(i)>>1)&1){ add(bInst, t+hold*0.5, Math.min(hold, tNext-(t+hold*0.5)), degToMidi(base, root-17), 0.50); }
    }

    // LEAD: rotate strings/woods/brass/piano; place at onset or beat
    const leadCount = plan.active.lead;
    const leadTimes = [];
    if(near(analysis.onsetsSec, t, nearOnsetWin)) leadTimes.push(t);
    const mid=t + (tNext-t)/2;
    if(near(analysis.onsetsSec, mid, nearOnsetWin)) leadTimes.push(mid);
    if(leadTimes.length===0) leadTimes.push(t);

    for(let k=0;k<leadCount;k++){
      const lt = leadTimes[k%leadTimes.length];
      const inst = chooseInstr('lead', i+k);
      const dur = Math.min(hold, tNext-lt);
      // simple melodic degrees around chord
      const motif = [0,7,4,12]; // root, fifth, third, octave
      const iv = motif[(hash32(i+k)>>2)%motif.length];
      add(inst, lt, dur, degToMidi(base, root+12+iv), 0.66);
    }

    // SPARKLE: alternating arps with harp/glock/celesta/vibes/marimba/bells/tubular
    if(plan.active.sparkle){
      const inst = chooseInstr('sparkle', i);
      const steps = 4; const stepDur=(tNext-t)/steps;
      const seq=[0,4,7,12];
      for(let s=0;s<steps;s++){
        const tt=t + s*stepDur;
        const iv=seq[(s + ((hash32(i)>>3)&1))%seq.length];
        add(inst, tt, stepDur*0.92, degToMidi(base, root+12+iv), 0.44);
      }
    }

    // update UI counters from first few beats
    if(i<8){
      const rolesActive = Object.entries(plan.active).filter(([k,v])=>k==='lead'?v>0:v).map(([k])=>k);
      $('voicesOut').textContent = (parseInt($('voicesOut').textContent)||0) + (rolesActive.length + (plan.active.lead>1?1:0));
      $('rolesOut').textContent = rolesActive.join(', ');
    }
  }

  return {events, seconds:T};
}

/* ===== Playback via LIVE ===== */
function stopAll(){
  if(!playing) return; playing=false;
  $('liveBtn').classList.remove('playing');
  const now=ACTX?ACTX.currentTime:0;
  scheduled.forEach(n=>{ try{ if(n.g){ n.gain.cancelScheduledValues(now); n.gain.linearRampToValueAtTime(0, now+0.05); } (n.o||[]).forEach(o=>{ try{o.stop(now+0.06);}catch(e){} }); }catch(e){} });
  scheduled.length=0;
}
function startPlay(){
  if(!SCORE) return;
  const start=ACTX.currentTime+0.25; playing=true; scheduled.length=0;
  $('liveBtn').classList.add('playing');
  const playMap={
    piano:Patches.piano, strings:Patches.strings, woods:Patches.woods, brass:Patches.brass,
    pad:Patches.pad, choir:Patches.choir, harp:Patches.harp, glock:Patches.glock,
    celesta:Patches.celesta, vibraphone:Patches.vibraphone, marimba:Patches.marimba,
    bells:Patches.bells, tubular:Patches.tubular, abass:Patches.abass, sbass:Patches.sbass, timp:Patches.timp
  };
  const jitter=0; // exact lock
  SCORE.events.forEach(ev=>{
    const when=start+ev.time+(Math.random()*2-1)*jitter;
    const fn=playMap[ev.inst]; if(fn) fn(ev.midi,when,ev.dur,clamp(ev.vel,0,1));
  });
  setTimeout(()=>stopAll(), (SCORE.seconds+1.5)*1000);
}
$('liveBtn').addEventListener('click', async ()=>{
  if(!$('liveBtn').classList.contains('ready')) return;
  await unlockAudio(); ensureAudio(); initBuses();
  if(playing){ stopAll(); return; }
  startPlay();
});

/* ===== Export WAV (orchestral only) ===== */
$('export').addEventListener('click', async ()=>{
  if(!SCORE){ alert('Analyze first.'); return; }
  await unlockAudio();
  const sr=44100, len=SCORE.seconds+2;
  const ctx=new OfflineAudioContext(2, Math.ceil(len*sr), sr);
  const master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination);
  const send=ctx.createGain(); send.gain.value=0.25; const d=ctx.createDelay(1); d.delayTime.value=0.04; const g=ctx.createGain(); g.gain.value=0.6; d.connect(g); g.connect(d);
  const sum=ctx.createGain(); d.connect(sum); sum.connect(master); send.connect(d);
  function mkBus(level){ const g=ctx.createGain(); g.gain.value=level; g.connect(master); const s=ctx.createGain(); s.gain.value=0.2; g.connect(s); s.connect(send); return {g}; }
  const B={}; BUS_LIST.forEach(k=>B[k]=mkBus(0.72));
  function hz(m){ return 440*Math.pow(2,(m-69)/12); }
  function ev(g,t0,a,d,s,hold,rel,vel){ const t1=t0+a,t2=t1+d,t3=t2+hold,t4=t3+rel; g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(vel,t1); g.gain.linearRampToValueAtTime(vel*s,t2); g.gain.setValueAtTime(vel*s,t3); g.gain.linearRampToValueAtTime(0,t4); }
  function osc(type,f){ const o=ctx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
  function addInst(inst,m,when,dur,vel){
    const addOsc=(type,f,a,d,s,h,r,v,bus)=>{ const o=osc(type,f),g=ctx.createGain(); ev(g,when,a,d,s,h,r,vel*v); o.connect(g); g.connect(B[bus].g); o.start(when); o.stop(when+a+d+h+r+0.02); };
    if(inst==='piano') addOsc('triangle',hz(m),0.005,0.18,0.35,Math.max(0.02,dur-0.2),0.25,0.8,'piano');
    else if(inst==='pad'){ const o1=osc('sawtooth',hz(m)*0.999),o2=osc('triangle',hz(m)*1.001),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400; const g=ctx.createGain();
      g.gain.setValueAtTime(0,when); g.gain.linearRampToValueAtTime(0.4*vel,when+0.4); g.gain.linearRampToValueAtTime(0.28*vel,when+0.4+1.8); g.gain.setValueAtTime(0.28*vel,when+Math.max(0.3,dur-1.2)+0.4+1.8); g.gain.linearRampToValueAtTime(0,when+Math.max(0.3,dur-1.2)+0.4+1.8+1.5);
      o1.connect(f); o2.connect(f); f.connect(g); g.connect(B.pad.g); o1.start(when); o2.start(when); o1.stop(when+dur+2.8); o2.stop(when+dur+2.8); }
    else if(inst==='strings'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200; const g=ctx.createGain();
      ev(g,when,0.08,0.5,0.8,Math.max(0.05,dur-0.4),0.3,0.6*vel); o.connect(f); f.connect(g); g.connect(B.strings.g); o.start(when); o.stop(when+dur+0.6); }
    else if(inst==='choir') addOsc('triangle',hz(m),0.2,0.8,0.6,Math.max(0.15,dur-0.8),1.0,0.55,'choir');
    else if(inst==='brass'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800; const g=ctx.createGain();
      ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,0.8*vel); o.connect(f); f.connect(g); g.connect(B.brass.g); o.start(when); o.stop(when+dur+0.4); }
    else if(inst==='woods'){ const o=osc('square',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400; const g=ctx.createGain();
      ev(g,when,0.03,0.22,0.55,Math.max(0.05,dur-0.25),0.2,0.6*vel); o.connect(f); f.connect(g); g.connect(B.woods.g); o.start(when); o.stop(when+dur+0.3); }
    else if(inst==='harp') addOsc('triangle',hz(m),0.002,0.22,0.35,0.01,0.4,0.7,'harp');
    else if(inst==='glock') addOsc('sine',hz(m)*2,0.001,0.4,0.25,0.02,0.8,0.6,'glock');
    else if(inst==='celesta') addOsc('square',hz(m)*2,0.003,0.18,0.3,0.02,0.7,0.6,'celesta');
    else if(inst==='vibraphone') addOsc('sine',hz(m),0.002,0.5,0.5,0.1,0.9,0.55,'vibraphone');
    else if(inst==='marimba') addOsc('triangle',hz(m),0.002,0.35,0.35,0.02,0.6,0.7,'marimba');
    else if(inst==='bells') addOsc('sine',hz(m),0.001,0.8,0.2,0.02,1.6,0.7,'bells');
    else if(inst==='tubular') addOsc('sine',hz(m)/2,0.005,1.2,0.8,0.3,2.2,0.7,'tubular');
    else if(inst==='abass') addOsc('triangle',hz(m),0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,0.7,'abass');
    else if(inst==='sbass'){ const o=osc('square',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900; const g=ctx.createGain();
      ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,0.7*vel); o.connect(f); f.connect(g); g.connect(B.sbass.g); o.start(when); o.stop(when+dur+0.3); }
    else if(inst==='timp'){ const o=osc('sine',hz(m)/2), g=ctx.createGain(); g.gain.setValueAtTime(vel*0.8,when); g.gain.exponentialRampToValueAtTime(0.0001,when+0.8); o.connect(g); g.connect(B.timp.g); o.start(when); o.stop(when+0.82); }
  }
  SCORE.events.forEach(e=>addInst(e.inst,e.midi,e.time+0.05,e.dur,e.vel));

  const buf=await ctx.startRendering();
  function interleave(L,R){ const out=new Float32Array(L.length+R.length); for(let i=0,j=0;i<L.length;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; } return out; }
  function f32To16(view,off,data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); s=s<0?s*0x8000:s*0x7FFF; view.setInt16(off,s,true);} }
  function w(view,off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i,str.charCodeAt(i)); }
  const L=buf.getChannelData(0), R=buf.getChannelData(1), inter=interleave(L,R);
  const ab=new ArrayBuffer(44+inter.length*2), dv=new DataView(ab);
  w(dv,0,'RIFF'); dv.setUint32(4,36+inter.length*2,true); w(dv,8,'WAVE'); w(dv,12,'fmt '); dv.setUint32(16,16,true);
  dv.setUint16(20,1,true); dv.setUint16(22,2,true); dv.setUint32(24,sr,true); dv.setUint32(28,sr*4,true);
  dv.setUint16(32,4,true); dv.setUint16(34,16,true); w(dv,36,'data'); dv.setUint32(40,inter.length*2,true);
  f32To16(dv,44,inter);
  const blob=new Blob([dv],{type:'audio/wav'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download='CST_LIVE_Alternating_Symphony_From_Upload.wav'; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),5000);
});

/* ===== Reset (remove uploaded song, clear analysis & canvases) ===== */
$('resetAll').addEventListener('click', ()=>{
  stopAll();
  $('file').value='';
  SRC_ARRAYBUF=null; ANALYSIS=null; SCORE=null;
  $('loaded').textContent='No file loaded';
  $('bpmOut').textContent='–'; $('beatsOut').textContent='–'; $('lenOut').textContent='–';
  $('voicesOut').textContent='–'; $('rolesOut').textContent='–';
  setReady(false); clearCanvases();
});

/* Mobile-friendly auto-unlock */
window.addEventListener('pointerdown', unlockAudio, {once:true});
</script>
</body>
</html>
