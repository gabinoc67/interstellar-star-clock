<script>
/* ========= Helpers & UX ========= */
const $ = (id)=>document.getElementById(id);
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function setMsg(t,kind='ok'){ const el=$('msg'); if(!el) return; el.style.display='inline-block'; el.textContent=t; el.style.background = kind==='warn' ? '#5b3d00' : '#153560'; el.style.borderColor = kind==='warn' ? '#ffb84d' : '#274a9a'; }
function clearMsg(){ const el=$('msg'); if(!el) return; el.style.display='none'; }

/* ========= Canvas ========= */
const TLM = document.getElementById('timeline'); 
const CTX = TLM ? TLM.getContext('2d') : null;
function drawTimeline(score){
  if(!TLM || !CTX || !score) return;
  const dpr=window.devicePixelRatio||1; const W=TLM.clientWidth*dpr, H=TLM.clientHeight*dpr; 
  TLM.width=W; TLM.height=H; CTX.clearRect(0,0,W,H);
  const rows = Array.from(new Set(score.events.map(e=>e.inst))).concat(['perc']);
  const rh = H/rows.length;
  const colors = {}; rows.forEach((r,i)=>colors[r]=`hsl(${(i*47)%360} 70% 72%)`);
  CTX.strokeStyle="#1b2a66"; CTX.lineWidth=1;
  const beats = Math.max(1, Math.round(score.seconds/(60/score.bpm)));
  for(let i=0;i<=beats;i++){ const x=i*(W/beats); CTX.beginPath(); CTX.moveTo(x,0); CTX.lineTo(x,H); CTX.stroke(); }
  const rx = t => (t/score.seconds)*W;
  score.events.forEach(e=>{
    const ri=rows.indexOf(e.inst); if(ri<0) return; 
    const x=rx(e.time), w=(e.dur/score.seconds)*W, y=ri*rh+rh*0.2, h=rh*0.6; 
    CTX.fillStyle=colors[e.inst]; CTX.fillRect(x,y,Math.max(1.5,w),h);
  });
}

/* ========= Audio Engine ========= */
let ACTX=null, master=null, BUS={}, scheduled=[], playing=false;
function ensureAudio(){ if(ACTX) return; ACTX = new (window.AudioContext||window.webkitAudioContext)(); master = ACTX.createGain(); master.gain.value=0.9; master.connect(ACTX.destination); }
async function unlockAudio(){ ensureAudio(); try{ await ACTX.resume(); }catch(e){} }
function makeBus(level,pan=0){ const g=ACTX.createGain(); g.gain.value=level; const p=ACTX.createStereoPanner?ACTX.createStereoPanner():null; if(p){ p.pan.value=pan; g.connect(p); p.connect(master); } else { g.connect(master); } return {g}; }
function stopAll(){ if(!playing) return; playing=false; const now=ACTX?ACTX.currentTime:0; scheduled.forEach(n=>{ try{ if(n.g){ n.g.gain.cancelScheduledValues(now); n.g.gain.linearRampToValueAtTime(0, now+0.05); } (n.o||[]).forEach(o=>{ try{o.stop(now+0.06);}catch(e){} }); }catch(e){} }); scheduled.length=0; }

/* ========= Orchestra Registry (≈30) ========= */
const ORCH = [
  // Strings
  {name:'violin', type:'bowed', role:'lead'},
  {name:'viola', type:'bowed', role:'counter'},
  {name:'cello', type:'bowed', role:'bed'},
  {name:'double_bass', label:'Double Bass', type:'bass', role:'bass'},
  {name:'harp', type:'pluck', role:'sparkle'},

  // Woodwinds
  {name:'flute', type:'reed', role:'lead'},
  {name:'piccolo', type:'reed', role:'sparkle'},
  {name:'oboe', type:'reed', role:'lead'},
  {name:'english_horn', label:'English Horn', type:'reed', role:'counter'},
  {name:'clarinet', type:'reed', role:'counter'},
  {name:'eb_clarinet', label:'E♭ Clarinet', type:'reed', role:'sparkle'},
  {name:'bass_clarinet', label:'Bass Clarinet', type:'reed', role:'bed'},
  {name:'bassoon', type:'reed', role:'bed'},
  {name:'contrabassoon', type:'reed', role:'bass'},

  // Brass
  {name:'horn', label:'French Horn', type:'brass', role:'bed'},
  {name:'trumpet', type:'brass', role:'lead'},
  {name:'cornet', type:'brass', role:'lead'},
  {name:'trombone', type:'brass', role:'counter'},
  {name:'bass_trombone', label:'Bass Trombone', type:'brass', role:'bass'},
  {name:'tuba', type:'brass', role:'bass'},
  {name:'euphonium', type:'brass', role:'bed'},

  // Percussion
  {name:'timpani', type:'perc', role:'perc'},
  {name:'snare', type:'perc', role:'perc'},
  {name:'bass_drum', label:'Bass Drum', type:'perc', role:'perc'},
  {name:'cymbals', type:'perc', role:'perc'},
  {name:'triangle', type:'perc', role:'perc'},
  {name:'tambourine', type:'perc', role:'perc'},
  {name:'tam_tam', label:'Tam-tam', type:'perc', role:'perc'},
  {name:'xylophone', type:'pluck', role:'sparkle'},
  {name:'glockenspiel', type:'bell', role:'sparkle'},
  {name:'chimes', type:'bell', role:'sparkle'},
  {name:'marimba', type:'pluck', role:'sparkle'},

  // Keyboards / Other
  {name:'piano', type:'pluck', role:'bed'},
  {name:'celesta', type:'pluck', role:'sparkle'},
  {name:'harpsichord', type:'pluck', role:'sparkle'},
  {name:'organ', type:'organ', role:'bed'},
  {name:'saxophone', type:'reed', role:'counter'}
];
const ORCH_MASTER = ORCH.map(i=>i.name);
function labelOf(inst){ return inst?.label || (inst?.name||'').replace(/_/g,' ').replace(/\b\w/g,m=>m.toUpperCase()); }

/* ========= Instrument Selection (UI + Persistence on demand) ========= */
let INST_SELECTION = {}; // name -> bool
const LS_KEY='cst_orch_selection_v2';
function loadSelection(){ try{ const s=localStorage.getItem(LS_KEY); if(s){ INST_SELECTION=JSON.parse(s); } }catch(e){} }
function saveSelection(){ localStorage.setItem(LS_KEY, JSON.stringify(INST_SELECTION)); setMsg('Instrument selection saved.'); }
function buildInstList(){
  const box = $('instList'); if(!box) return; box.innerHTML='';
  ORCH.forEach(inst=>{
    if(!INST_SELECTION.hasOwnProperty(inst.name)) INST_SELECTION[inst.name]=true;
    const row=document.createElement('div'); row.className='instRow';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked = !!INST_SELECTION[inst.name];
    cb.addEventListener('change', ()=>{ INST_SELECTION[inst.name]=cb.checked; });
    const lbl=document.createElement('label'); lbl.textContent=labelOf(inst);
    const tag=document.createElement('span'); tag.className='tag'; tag.textContent = inst.role;
    row.appendChild(cb); row.appendChild(lbl); row.appendChild(tag);
    box.appendChild(row);
  });
}
function selectAll(v=true){ ORCH_MASTER.forEach(n=>INST_SELECTION[n]=v); buildInstList(); if(!v) setMsg('All instruments disabled. Enable a few to play.','warn'); else setMsg('All instruments enabled.'); }

/* Random 20 instruments on each Analyze/Reset (even for same song) */
function randomize20(){
  ORCH_MASTER.forEach(n=>INST_SELECTION[n]=false);
  const pool=[...ORCH_MASTER];
  for(let i=pool.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }
  const pick = pool.slice(0, Math.min(20, pool.length));
  pick.forEach(n=>INST_SELECTION[n]=true);
  buildInstList();
}

/* ========= WebAudio Patches ========= */
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function envGain(g,t0,a,d,sus,hold,rel,amp){
  const t1=t0+a, t2=t1+d, t3=t2+hold, t4=t3+rel;
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(amp,t1);
  g.gain.linearRampToValueAtTime(amp*sus,t2);
  g.gain.setValueAtTime(amp*sus,t3);
  g.gain.linearRampToValueAtTime(0,t4);
  return t4;
}
const PATCH = {
  bowed:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200;
    const g=ACTX.createGain(); const end=envGain(g,when,0.04,0.45,0.8,Math.max(0.05,dur-0.4),0.3,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  reed:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=envGain(g,when,0.03,0.22,0.55,Math.max(0.05,dur-0.25),0.2,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  brass:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
    const g=ACTX.createGain(); const end=envGain(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.55);
    o.connect(f); f.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  pluck:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.002,0.22,0.35,0.01,0.4,vel*0.6);
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  bell:(bus,m,when,dur,vel)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.002,0.6,0.3,0.02,1.2,vel*0.6);
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  organ:(bus,m,when,dur,vel)=>{ const o1=ACTX.createOscillator(), o2=ACTX.createOscillator(); o1.type='sine'; o2.type='sine';
    o1.frequency.value=midiToHz(m); o2.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=envGain(g,when,0.05,0.5,0.85,Math.max(0.05,dur-0.45),0.35,vel*0.55);
    o1.connect(g); o2.connect(g); g.connect(BUS[bus].g); o1.start(when); o2.start(when); o1.stop(end); o2.stop(end); scheduled.push({o:[o1,o2],g,end}); },
  bass:(bus,m,when,dur,vel,depth=1)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=envGain(g,when,0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,vel*0.65*depth);
    o.connect(g); g.connect(BUS[bus].g); o.start(when); o.stop(end); scheduled.push({o:[o],g,end}); },
  // Perc
  k:(t,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(130,t); o.frequency.exponentialRampToValueAtTime(40,t+0.12); const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.6,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(BUS.perc.g); o.start(t); o.stop(t+0.2); },
  s:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.2,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.35,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2); s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.2); },
  h:(t,v)=>{ const s=ACTX.createBufferSource(); const b=ACTX.createBuffer(1,ACTX.sampleRate*0.08,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.18,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.08); s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.08); }
};
function initBuses(){ ORCH_MASTER.forEach((k,i)=>{ BUS[k]=BUS[k]||makeBus(k==='perc'?0.7:0.7,(i%2?0.08:-0.08)); }); }

/* ========= Analysis (chunked to avoid freezing) ========= */
const MAX_ANALYZE_SECONDS=60;
let SOURCEBUF=null;
async function decodeFileToBuffer(file){ await unlockAudio(); const ab=await file.arrayBuffer(); return await ACTX.decodeAudioData(ab); }
function monoMixFirstMinute(buf){
  const maxSamp=Math.min(buf.length, Math.floor(buf.sampleRate*MAX_ANALYZE_SECONDS));
  const ch0=buf.getChannelData(0).slice(0,maxSamp);
  if(buf.numberOfChannels===1) return new Float32Array(ch0);
  const ch1=buf.getChannelData(1);
  const out=new Float32Array(maxSamp);
  for(let i=0;i<maxSamp;i++) out[i]=0.5*(ch0[i]+ch1[i]);
  return out;
}
/* Chunked RMS envelope to keep UI responsive */
async function energyEnvelopeAsync(x, win=2048, hop=1024, onProgress=null){
  const out=[]; let i=0; const N=x.length; const chunk=256*hop;
  while(i+win<=N){
    const end=Math.min(i+chunk, N-win);
    for(; i<=end; i+=hop){
      let s=0; for(let k=0;k<win;k++){ const v=x[i+k]; s+=v*v; }
      out.push(Math.sqrt(s/win));
    }
    if(onProgress) onProgress(out.length/(N/hop));
    await new Promise(r=>setTimeout(r,0)); // yield
  }
  return {env:out, hop};
}
function autocorrTempo(env, sr, hop){
  const fps=sr/hop; const minBPM=40, maxBPM=200;
  const minLag=Math.round(fps*60/maxBPM), maxLag=Math.round(fps*60/minBPM);
  let bestLag=minLag, bestVal=-1;
  for(let L=minLag; L<=maxLag; L++){
    let s=0; for(let i=0;i+L<env.length;i++) s += env[i]*env[i+L];
    if(s>bestVal){ bestVal=s; bestLag=L; }
  }
  const bpm=60*fps/bestLag; return Math.max(40, Math.min(200, bpm));
}
function peakPickBeats(env, sr, hop, bpm, hard=60){
  const fps=sr/hop, spb=fps*60/bpm; const beats=[]; let n=0;
  while(true){
    const center=Math.round(n*spb); if(center>=env.length) break;
    const r=Math.round(0.25*spb); let bestI=center,bestV=-1;
    for(let k=center-r; k<=center+r; k++){ if(k<0||k>=env.length) continue; const v=env[k]; if(v>bestV){bestV=v; bestI=k;} }
    const t=bestI/fps; if(t>hard) break;
    beats.push(bestI); n++;
  }
  return beats.map(i=>i/fps);
}

/* ========= Harmony / Cadence ========= */
function chordFromDegree(deg){
  const map={'I':0,'ii':2,'iii':4,'IV':5,'V':7,'vi':9,'VII':11};
  let root = map[deg];
  if(root===undefined){ const n=parseInt(deg,10); root = isNaN(n)?0:((n%12)+12)%12; }
  return [root,(root+4)%12,(root+7)%12];
}
function cadenceList(name, custom){
  if(name==='I-IV-V-I') return ['I','IV','V','I'];
  if(name==='I-vi-IV-V') return ['I','vi','IV','V'];
  if(name==='ii-V-I') return ['ii','V','I','I'];
  if(name==='I-V-vi-IV') return ['I','V','vi','IV'];
  if(name==='custom'){ if(!custom) return ['I','IV','V','I']; return custom.split(/[,\s]+/).filter(Boolean); }
  return ['I','IV','V','I'];
}
/* Random cadence preset (soft choice) */
const CADENCE_PRESETS=['I-IV-V-I','I-vi-IV-V','ii-V-I','I-V-vi-IV'];
function pickRandomCadence(){ return CADENCE_PRESETS[Math.floor(Math.random()*CADENCE_PRESETS.length)]; }

/* ========= Equations Mode (subtle shaping) =========
   One or two picked each run:
   - phi: CST phase uses φ (~0.618) fraction of beat
   - fourier: add mild sinus swing
   - prime: skip accents on prime indices for airy feel
*/
function pickEquationModes(){
  const opts=['phi','fourier','prime'];
  const shuffled=[...opts].sort(()=>Math.random()-0.5);
  return shuffled.slice(0, 1 + Math.floor(Math.random()*2)); // 1 or 2
}

/* ========= Score Generator ========= */
function eqPhaseCST(modes, beatPeriod){
  let phase = 0;
  const now = new Intl.DateTimeFormat('en-US',{timeZone:'America/Chicago',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false})
              .formatToParts(new Date()).reduce((a,p)=>{a[p.type]=p.value; return a;},{});
  const sec = parseInt(now.second||'0',10);
  if(modes.includes('phi')) phase += 0.618; // φ
  phase += (sec%10)/100; // tiny live CST drift
  return (phase%1)*beatPeriod;
}
function generateScore(params){
  const { bpm, totalSecs, energyArr, cadenceNames, swingBase, dotTri, vmin, vmax, bassDepth, modes } = params;
  const beatPeriod = 60/bpm, beatsPerBar=4;
  const cstOffset = eqPhaseCST(modes, beatPeriod);
  const totalBeats = Math.max(1, Math.floor(totalSecs/beatPeriod));
  const totalBars = Math.max(1, Math.floor(totalBeats/beatsPerBar));
  const barChords = Array.from({length: totalBars}, (_,b)=> chordFromDegree(cadenceNames[b % cadenceNames.length]));

  // pickers
  const allowedNames = ORCH.filter(i=>INST_SELECTION[i.name]).map(i=>i.name);
  if(!allowedNames.length) return {events:[],bpm,totalSecs};
  function pickByRole(role){
    const c = ORCH.filter(i=>allowedNames.includes(i.name) && i.role===role);
    if(!c.length) return null;
    return c[Math.floor(Math.random()*c.length)];
  }

  // registers
  const REG = { lead:72, bed:60, bass:36, spark:79 };
  const events=[]; const last={lead:null,bass:null,bed:null,spark:null};
  const cadenceGain = 0.75; // softer cadence chords overall

  for(let b=0;b<totalBeats;b++){
    const bar = Math.floor(b/beatsPerBar);
    const inBar = b % beatsPerBar;
    const chord = barChords[Math.min(bar, barChords.length-1)];
    const [root, third, fifth] = chord;

    const tBeat = b*beatPeriod + cstOffset;
    const E = energyArr.length ? energyArr[Math.min(energyArr.length-1, b)] : 0.5;
    let V = clamp(Math.round(vmin + (vmax - vmin)*E), 1, 8);

    // “prime” mode: thin texture on prime indices (2,3,5,7,11…)
    if(modes.includes('prime')){
      const isPrime = (n)=>{ if(n<2) return false; for(let k=2;k*k<=n;k++) if(n%k===0) return false; return true; };
      if(isPrime(b)) V = Math.max(1, V-1);
    }

    const want=[];
    if(V>=1) want.push('lead');
    if(V>=2) want.push('bass');
    if(V>=3) want.push('bed');
    if(V>=4) want.push(Math.random()<0.6?'spark':'counter');
    if(V>=5) want.push('counter');

    // variable swing (fourier mode adds a mild sinus variation)
    let swing = swingBase;
    if(modes.includes('fourier')){
      swing = clamp(1.0 + 0.25*Math.sin(2*Math.PI*(b/16)), 1.0, 1.5);
    }

    // Lead
    if(want.includes('lead')){
      const inst = pickByRole('lead') || pickByRole('counter') || pickByRole('bed') || ORCH.find(i=>i.name==='violin');
      const prev=last.lead;
      const chordTones=[root,third,fifth,(root+2)%12,(root+9)%12];
      const target = (prev==null ? REG.lead+root : prev);
      // choose nearest chord tone
      let best=REG.lead+root, bestDist=1e9;
      for(const ct of chordTones){ for(let k=-2;k<=2;k++){ const m=REG.lead + (ct+12*k); const d=Math.abs(m-target); if(d<bestDist){bestDist=d; best=m;} } }
      const e8 = beatPeriod/2;
      const dLong = (swing/(swing+1))*e8, dShort=(1/(swing+1))*e8;
      const useSwing = (swing>1.02) && (inBar%2===0);
      const baseDur = useSwing ? (Math.random()<0.5? dLong: dShort) : (Math.random()<0.3? e8 : beatPeriod);
      const dur = baseDur + (dotTri)*(Math.random()<0.5 ? 0.5*e8 : -1/6*beatPeriod);
      events.push({inst:inst.name, type:inst.type, time:tBeat, dur:Math.max(0.12,dur), midi:best, vel:0.68});
      last.lead=best;
    }

    // Bass (always gentle)
    if(want.includes('bass')){
      const inst = pickByRole('bass') || {name:'double_bass', type:'bass'};
      const prev=last.bass;
      const bassCand = Math.random()<0.75 ? root : fifth;
      let m = REG.bass + bassCand;
      if(prev!=null){ const opts=[m,m-12,m+12]; m = opts.reduce((a,b)=> Math.abs(b-prev)<Math.abs(a-prev)?b:a, opts[0]); }
      const dur = beatPeriod*(Math.random()<0.6?1:2);
      events.push({inst:inst.name, type:inst.type, time:tBeat, dur:dur, midi:m, vel:0.58*bassDepth});
      last.bass=m;
    }

    // Cadence bed chords (softer with cadenceGain)
    if(want.includes('bed')){
      const inst = pickByRole('bed') || {name:'cello', type:'bowed'};
      const base = REG.bed + root;
      [0,4,7].forEach(iv=>{
        const dd = beatPeriod*(Math.random()<0.5?2:4);
        events.push({inst:inst.name, type:inst.type, time:tBeat, dur:dd, midi:base+iv, vel:0.40*cadenceGain});
      });
      last.bed=base+4;
    }

    // Sparkle / Counter
    if(want.includes('spark') || want.includes('counter')){
      const isSpark = want.includes('spark');
      const inst = isSpark ? (pickByRole('sparkle') || {name:'glockenspiel', type:'bell'})
                           : (pickByRole('counter') || pickByRole('lead') || {name:'viola', type:'bowed'});
      if(isSpark){
        const base = 79 + root;
        [0,4,7,12].forEach((iv,i)=>{ const tt=tBeat+i*(beatPeriod/4); events.push({inst:inst.name, type:inst.type, time:tt, dur:beatPeriod/4, midi:base+iv, vel:0.48}); });
        last.spark=base+12;
      }else{
        const prev=last.lead ?? (72+root);
        const step=Math.random()<0.5?2:-2;
        events.push({inst:inst.name, type:inst.type, time:tBeat+0.02, dur:beatPeriod, midi:prev+step, vel:0.52});
      }
    }

    // Light perc scaffold (very low so cadence isn’t loud)
    if(INST_SELECTION['timpani'] || INST_SELECTION['snare'] || INST_SELECTION['bass_drum']){
      if(inBar===0 && INST_SELECTION['bass_drum']) PATCH.k(tBeat, 0.35+0.25*E);
      if(inBar===2 && INST_SELECTION['snare']) PATCH.s(tBeat+0.02, 0.25+0.15*E);
      if(Math.random()<0.2 && (INST_SELECTION['triangle']||INST_SELECTION['cymbals'])) PATCH.h(tBeat+0.01, 0.15+0.1*E);
    }
  }

  return {events, bpm, seconds: totalSecs};
}

/* ========= Playback ========= */
function playScore(score){
  if(playing) return; // LIVE never toggles stop
  const start=ACTX.currentTime+0.2; playing=true; scheduled.length=0;
  score.events.forEach(ev=>{
    const w = start + ev.time;
    const t=ev.type;
    if(t==='bowed' || t==='reed') PATCH.bowed(ev.inst, ev.midi, w, ev.dur, ev.vel);
    else if(t==='brass') PATCH.brass(ev.inst, ev.midi, w, ev.dur, ev.vel);
    else if(t==='pluck') PATCH.pluck(ev.inst, ev.midi, w, ev.dur, ev.vel);
    else if(t==='bell') PATCH.bell(ev.inst, ev.midi, w, ev.dur, ev.vel);
    else if(t==='organ') PATCH.organ(ev.inst, ev.midi, w, ev.dur, ev.vel);
    else if(t==='bass') PATCH.bass(ev.inst, ev.midi, w, ev.dur, ev.vel, +$('bassDepth').value);
    else PATCH.bowed(ev.inst, ev.midi, w, ev.dur, ev.vel);
  });
}

/* ========= Offline Render (WAV) ========= */
async function renderWav(score){
  await unlockAudio();
  const sr=44100, len=score.seconds+2;
  const ctx=new OfflineAudioContext(2, Math.ceil(len*sr), sr);
  const master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination);
  const B={}; ORCH_MASTER.forEach(n=>{ const g=ctx.createGain(); g.gain.value=0.8; g.connect(master); B[n]={g}; });
  function hz(m){ return 440*Math.pow(2,(m-69)/12); }
  function ev(g,t0,a,d,s,hold,rel,amp){ const t1=t0+a,t2=t1+d,t3=t2+hold,t4=t3+rel; g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(amp,t1); g.gain.linearRampToValueAtTime(amp*s,t2); g.gain.setValueAtTime(amp*s,t3); g.gain.linearRampToValueAtTime(0,t4); }
  function osc(type,f){ const o=ctx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
  function add(inst,type,m,when,dur,vel){
    if(type==='bowed' || type==='reed'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200; const g=ctx.createGain(); ev(g,when,0.04,0.45,0.8,Math.max(0.05,dur-0.4),0.3,vel*0.55); o.connect(f); f.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+dur+0.6); }
    else if(type==='brass'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800; const g=ctx.createGain(); ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.55); o.connect(f); f.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+dur+0.4); }
    else if(type==='pluck'){ const o=osc('triangle',hz(m)); const g=ctx.createGain(); ev(g,when,0.002,0.22,0.35,0.01,0.4,vel*0.6); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+dur+0.5); }
    else if(type==='bell'){ const o=osc('sine',hz(m)); const g=ctx.createGain(); ev(g,when,0.002,0.6,0.3,0.02,1.2,vel*0.6); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+dur+1.1); }
    else if(type==='organ'){ const o1=osc('sine',hz(m)),o2=osc('sine',hz(m)*2); const g=ctx.createGain(); ev(g,when,0.05,0.5,0.85,Math.max(0.05,dur-0.45),0.35,vel*0.55); o1.connect(g); o2.connect(g); g.connect(B[inst].g); o1.start(when); o2.start(when); o1.stop(when+dur+0.6); o2.stop(when+dur+0.6); }
    else if(type==='bass'){ const o=osc('triangle',hz(m)); const g=ctx.createGain(); ev(g,when,0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,vel*0.65*(+$('bassDepth').value)); o.connect(g); g.connect(B[inst].g); o.start(when); o.stop(when+dur+0.35); }
  }
  score.events.forEach(e=> add(e.inst,e.type,e.midi, e.time+0.05, e.dur, e.vel));
  const buf=await ctx.startRendering();
  // WAV
  function interleave(L,R){ const out=new Float32Array(L.length+R.length); for(let i=0,j=0;i<L.length;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; } return out; }
  function f32To16(view,off,data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); s=s<0?s*0x8000:s*0x7FFF; view.setInt16(off,s,true);} }
  function w(view,off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i,str.charCodeAt(i)); }
  const L=buf.getChannelData(0), R=buf.getChannelData(1), inter=interleave(L,R);
  const ab=new ArrayBuffer(44+inter.length*2), dv=new DataView(ab);
  w(dv,0,'RIFF'); dv.setUint32(4,36+inter.length*2,true); w(dv,8,'WAVE'); w(dv,12,'fmt '); dv.setUint32(16,16,true);
  dv.setUint16(20,1,true); dv.setUint16(22,2,true); dv.setUint32(24,buf.sampleRate,true); dv.setUint32(28,buf.sampleRate*4,true);
  dv.setUint16(32,4,true); dv.setUint16(34,16,true); w(dv,36,'data'); dv.setUint32(40,inter.length*2,true);
  f32To16(dv,44,inter);
  return new Blob([dv],{type:'audio/wav'});
}

/* ========= UI Bindings ========= */
let ANALYSIS = {bpm:null,seconds:null,beats:[],energy:[]}, SCORE=null;
function updateVals(){
  if($('swingVal')) $('swingVal').textContent=(+$('swing').value).toFixed(2);
  if($('dotTriVal')) $('dotTriVal').textContent=(+$('dotTri').value).toFixed(2);
  if($('vminVal')) $('vminVal').textContent=$('vmin').value;
  if($('vmaxVal')) $('vmaxVal').textContent=$('vmax').value;
  if($('vb')) $('vb').textContent=`${$('vmin').value}–${$('vmax').value}`;
  if($('bassDepthVal')) $('bassDepthVal').textContent=(+$('bassDepth').value).toFixed(2);
}
['swing','dotTri','vmin','vmax','bassDepth'].forEach(id=>{
  const el=$(id); if(el) el.addEventListener('input',()=>{ updateVals(); setMsg('Settings changed — press LIVE to apply.'); });
});
if($('cadence')) $('cadence').addEventListener('change',()=>{
  const isC=$('cadence').value==='custom'; if($('cadenceCustom')) $('cadenceCustom').disabled=!isC;
  if($('cadOut')) $('cadOut').textContent=isC?'Custom':$('cadence').value.replace(/-/g,'–');
  setMsg('Cadence changed — press LIVE to apply.');
});
if($('cadenceCustom')) $('cadenceCustom').addEventListener('input',()=>{ if($('cadence').value==='custom'){ if($('cadOut')) $('cadOut').textContent='Custom'; setMsg('Custom cadence updated — press LIVE to apply.'); } });

/* Buttons */
if($('allOn')) $('allOn').addEventListener('click',()=>{ selectAll(true); });
if($('allOff')) $('allOff').addEventListener('click',()=>{ selectAll(false); });
if($('saveSel')) $('saveSel').addEventListener('click', saveSelection);

if($('analyze')) $('analyze').addEventListener('click', async ()=>{
  clearMsg();
  const f=$('file')?.files?.[0];
  if(!f){ setMsg('Please choose an audio file first.','warn'); return; }
  $('live')?.setAttribute('disabled','disabled'); if($('live')) $('live').textContent='LIVE — WAIT (Analyzing...)';

  try{
    await unlockAudio(); initBuses();
    // Randomize a fresh 20-instrument set every Analyze (as requested)
    randomize20();

    const buf = await decodeFileToBuffer(f); SOURCEBUF=buf;
    const mono = monoMixFirstMinute(buf);
    const sr = buf.sampleRate;

    // Progress UI (no freeze)
    const {env,hop} = await energyEnvelopeAsync(mono,2048,1024,(p)=>{ setMsg(`Analyzing… ${Math.round(p*100)}%`); });
    const bpm = autocorrTempo(env,sr,hop);
    const beats = peakPickBeats(env,sr,hop,bpm,MAX_ANALYZE_SECONDS);
    const seconds = Math.min(MAX_ANALYZE_SECONDS, buf.duration);
    const beatEnergy = beats.map(t=>{ const fps=sr/hop; const idx=Math.max(0,Math.min(env.length-1, Math.round(t*fps))); return env[idx]; });
    const maxE = beatEnergy.reduce((a,b)=>Math.max(a,b),0.0001);
    const E = beatEnergy.map(x=> clamp(x/maxE,0,1));
    ANALYSIS={bpm:Math.round(bpm),seconds,beats,energy:E};
    if($('bpm')) $('bpm').textContent = Math.round(bpm);
    if($('len')) $('len').textContent = seconds.toFixed(1)+' s';
    setMsg(seconds<buf.duration?'Using first 60 seconds. Analysis complete — press LIVE.':'Analysis complete — press LIVE.');
    $('live')?.removeAttribute('disabled');
  }catch(err){ console.error(err); setMsg('Analyze failed. Try another file.','warn'); }
  finally{ if($('live')) $('live').textContent='LIVE — PLAY'; }
});

if($('live')) $('live').addEventListener('click', async ()=>{
  if($('live').hasAttribute('disabled')) return;
  await unlockAudio(); initBuses();
  if(!ANALYSIS.bpm){ setMsg('Analyze first, then LIVE.','warn'); return; }
  if(playing){ setMsg('Already playing. Press Stop to silence; or change settings and press LIVE to regenerate.'); return; }

  // Random cadence preset on LIVE if user hasn't changed it since reset
  let cadName=$('cadence')?.value||'I-IV-V-I';
  if(!cadName || cadName==='random') cadName = pickRandomCadence();
  if(cadName!=='custom' && $('cadence')) $('cadence').value=cadName;
  const cadCustom=$('cadenceCustom')?.value.trim()||'';
  const cadenceSeq=cadenceList(cadName, cadCustom);
  if($('cadOut')) $('cadOut').textContent=(cadName==='custom'?(cadCustom||'Custom'):cadName).replace(/-/g,'–');

  // Modes (equations)
  const modes = pickEquationModes();

  const params = {
    bpm: ANALYSIS.bpm,
    totalSecs: ANALYSIS.seconds,
    energyArr: ANALYSIS.energy,
    cadenceNames: cadenceSeq,
    swingBase:+($('swing')?.value||1.0),
    dotTri:+($('dotTri')?.value||0.3),
    vmin:+($('vmin')?.value||1),
    vmax:+($('vmax')?.value||4),
    bassDepth:+($('bassDepth')?.value||1.15),
    modes
  };
  SCORE = generateScore(params);
  if(!SCORE || !SCORE.events.length){ setMsg('No playable events (maybe no instruments selected).','warn'); return; }
  drawTimeline(SCORE);

  // Update "Will Play"
  const list=$('willPlay'); if(list){ list.innerHTML=''; const used=Array.from(new Set(SCORE.events.map(e=>e.inst))); used.forEach(n=>{ const d=document.createElement('div'); d.textContent=labelOf(ORCH.find(i=>i.name===n)||{name:n}); list.appendChild(d); }); }

  playScore(SCORE);
  clearMsg();
});

if($('stop')) $('stop').addEventListener('click', ()=>{ stopAll(); clearMsg(); });

if($('reset')) $('reset').addEventListener('click', ()=>{
  stopAll(); SCORE=null; SOURCEBUF=null; ANALYSIS={bpm:null,seconds:null,beats:[],energy:[]};
  if($('file')) $('file').value="";
  if($('bpm')) $('bpm').textContent='–';
  if($('len')) $('len').textContent='–';
  if($('live')) { $('live').setAttribute('disabled','disabled'); $('live').textContent='LIVE — PLAY'; }
  // Random 20 instruments again on Reset
  randomize20();
  // Random cadence preset default (visual)
  if($('cadence')) $('cadence').value = pickRandomCadence();
  if($('cadenceCustom')) $('cadenceCustom').value='';
  clearMsg();
  if(CTX && TLM){ const dpr=window.devicePixelRatio||1; TLM.width=TLM.clientWidth*dpr; TLM.height=TLM.clientHeight*dpr; CTX.clearRect(0,0,TLM.width,TLM.height); }
});

/* Export */
if($('export')) $('export').addEventListener('click', async ()=>{
  if(!SCORE){ setMsg('Nothing to export. Press LIVE first.','warn'); return; }
  const blob=await renderWav(SCORE); const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`CST_LIVE_Symphony_${ANALYSIS.bpm}BPM_1min.wav`; a.click(); setTimeout(()=>URL.revokeObjectURL(url),5000);
});

/* ========= Init ========= */
window.addEventListener('pointerdown', unlockAudio, {once:true});
ensureAudio(); initBuses(); loadSelection(); buildInstList(); updateVals();
// Disable LIVE until analysis completes
if($('live')) $('live').setAttribute('disabled','disabled');
// Friendly watchdog: if browser suspends audio, resume on visibility
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') unlockAudio(); });

</script>
</body>
</html>
