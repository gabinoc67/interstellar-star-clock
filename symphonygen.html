<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST — Key & Bass Note Analyzer (No Libraries)</title>
<style>
  :root{
    --bg:#0a0f1f; --ink:#eaf1ff; --muted:#a8b7e3; --panel:#121a33; --line:#6ee7ff; --ok:#10b981; --warn:#f59e0b;
    --grid:#1b254b; --accent:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid var(--grid);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:18px;margin:0}
  main{max-width:1100px;margin:0 auto;padding:16px;display:grid;grid-template-columns:320px 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:12px;padding:14px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="file"],button,select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--grid);background:#0e1733;color:var(--ink)}
  button{cursor:pointer;background:linear-gradient(180deg,#15245a,#0f1b45)}
  button:hover{filter:brightness(1.06)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px dashed var(--grid);border-radius:10px;margin-top:8px}
  .stat b{color:var(--ok)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;white-space:pre;line-height:1.425}
  .scroller{max-height:320px;overflow:auto;border:1px solid var(--grid);border-radius:10px;padding:8px;background:#0c1430}
  canvas{width:100%;height:220px;background:#0c1430;border:1px solid #22306b;border-radius:10px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#0f1c44;border:1px solid var(--grid);font-size:12px;color:var(--muted)}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend span{font-size:12px}
  .k{color:#fff;background:#12326a;border:1px solid #274a9a}
  .keys{display:grid;grid-template-columns:repeat(6,1fr);gap:6px;margin-top:8px}
  .keys div{padding:6px 8px;border:1px solid var(--grid);border-radius:8px;text-align:center}
</style>
</head>
<body>
<header>
  <h1>Key & Bass Analyzer</h1>
  <span class="pill">No libs • WebAudio + autocorrelation</span>
</header>

<main>
  <section class="card">
    <label>Audio file (MP3 / WAV)</label>
    <input id="file" type="file" accept=".mp3,.wav,.m4a,.aac,.ogg" />
    <div class="row" style="margin-top:10px">
      <button id="analyzeBtn">Analyze</button>
      <button id="exportBtn" title="Export CSV of time,dominant,bass">Export CSV</button>
    </div>

    <div class="stat"><span>Estimated Key</span><b id="keyOut">–</b></div>
    <div class="stat"><span>Tempo (rough)</span><b id="bpmOut">–</b></div>
    <div class="stat"><span>Frames analyzed</span><b id="framesOut">–</b></div>

    <div class="legend">
      <span class="pill">Dominant note track</span>
      <span class="pill">Bass note emphasis (≤ 200 Hz)</span>
      <span class="pill">Key from pitch-class histogram</span>
    </div>
    <p class="hint">Tip: this is monophonic/“dominant” note tracking. Mixed songs are polyphonic, so this tracks the strongest pitch per frame and “leans bass” below 200&nbsp;Hz.</p>
  </section>

  <section class="card">
    <label>Piano-roll (time → note)</label>
    <canvas id="roll" width="960" height="260"></canvas>
    <div class="row" style="margin-top:8px">
      <div>
        <label>Detected notes (time, dominant, bass)</label>
        <div id="list" class="scroller mono"></div>
      </div>
      <div>
        <label>Pitch-class histogram (C..B)</label>
        <div id="hist" class="keys mono"></div>
      </div>
    </div>
    <div class="hint">If you need real instrument separation (true piano vs. bass lines), you’ll want a source-separation model (e.g., Spleeter/MDX) which is too heavy to bundle here.</div>
  </section>
</main>

<script>
(() => {
  const fileEl = document.getElementById('file');
  const analyzeBtn = document.getElementById('analyzeBtn');
  const exportBtn  = document.getElementById('exportBtn');
  const keyOut = document.getElementById('keyOut');
  const bpmOut = document.getElementById('bpmOut');
  const framesOut = document.getElementById('framesOut');
  const listEl = document.getElementById('list');
  const histEl = document.getElementById('hist');
  const roll = document.getElementById('roll'), rc = roll.getContext('2d');

  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

  // Krumhansl-Schmuckler (normalized) key profiles (C major / C minor)
  const KS_MAJOR = [6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
  const KS_MINOR = [6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];

  function hzToMidi(hz){ return 69 + 12*Math.log2(hz/440); }
  function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
  function midiToName(m){
    const n = Math.round(m);
    const name = NOTE_NAMES[(n % 12 + 12)%12];
    const oct = Math.floor(n/12) - 1;
    return `${name}${oct}`;
  }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  function autocorrPitch(frame, sampleRate){
    // Center-clip & window then ACF; simple, robust for dominant pitch
    // Returns frequency in Hz or 0 if no clear peak
    const N = frame.length;
    // Hann window & mean remove
    let mean=0; for(let i=0;i<N;i++) mean += frame[i]; mean/=N;
    let maxAbs=0;
    for(let i=0;i<N;i++){
      frame[i] = (frame[i]-mean) * (0.5 - 0.5*Math.cos(2*Math.PI*i/(N-1)));
      maxAbs = Math.max(maxAbs, Math.abs(frame[i]));
    }
    const clip = 0.3*maxAbs;
    if (clip>0){
      for(let i=0;i<N;i++){
        if (frame[i]> clip) frame[i]-=clip;
        else if (frame[i]<-clip) frame[i]+=clip;
        else frame[i]=0;
      }
    }
    // ACF
    const minF=50, maxF=1000; // pitch search band
    const minLag = Math.floor(sampleRate/maxF);
    const maxLag = Math.floor(sampleRate/minF);
    let bestLag=0, best=0;
    for(let lag=minLag; lag<=Math.min(maxLag, N-3); lag++){
      let sum=0;
      for(let i=0;i<N-lag;i++) sum += frame[i]*frame[i+lag];
      if (sum>best){best=sum; bestLag=lag;}
    }
    if (bestLag>0){
      // Parabolic refine
      const l=bestLag;
      const c1 = acfAtLag(frame,l-1), c2=acfAtLag(frame,l), c3=acfAtLag(frame,l+1);
      let shift = 0;
      const denom = (c1 - 2*c2 + c3);
      if (denom !== 0) shift = 0.5*(c1 - c3)/denom;
      const refined = l + shift;
      const freq = sampleRate / refined;
      if (isFinite(freq) && freq>20 && freq<2000) return freq;
    }
    return 0;
    function acfAtLag(x, lag){
      if (lag<1 || lag>=x.length) return 0;
      let s=0;
      for(let i=0;i<x.length-lag;i++) s += x[i]*x[i+lag];
      return s;
    }
  }

  function estimateBPM(peaks, sr){
    // very rough: histogram inter-onset intervals in 0.2..2.0 s → BPM 30..300
    if (peaks.length<3) return 0;
    const diffs=[];
    for(let i=1;i<peaks.length;i++){
      const dt = (peaks[i]-peaks[i-1])/sr;
      if (dt>0.2 && dt<2.0) diffs.push(dt);
    }
    if (!diffs.length) return 0;
    const med = diffs.sort((a,b)=>a-b)[Math.floor(diffs.length/2)];
    let bpm = Math.round(60/med);
    // fold to 60..180
    while (bpm<60) bpm*=2;
    while (bpm>180) bpm=Math.round(bpm/2);
    return bpm;
  }

  function correlateKey(pitchClassHist){
    // Try all 12 rotations for major/minor; pick max correlation
    function corr(a,b){ let s=0; for(let i=0;i<12;i++) s+=a[i]*b[i]; return s; }
    function norm(v){ const n=Math.hypot(...v); return v.map(x=>x/(n||1)); }
    const h = norm(pitchClassHist);
    let best={name:"–",score:-1};
    for(let r=0;r<12;r++){
      const maj = KS_MAJOR.map((v,i)=>v * h[(i+r)%12]);
      const min = KS_MINOR.map((v,i)=>v * h[(i+r)%12]);
      const cMaj = maj.reduce((a,b)=>a+b,0);
      const cMin = min.reduce((a,b)=>a+b,0);
      if (cMaj>best.score) best={name:`${NOTE_NAMES[r]} major`, score:cMaj};
      if (cMin>best.score) best={name:`${NOTE_NAMES[r]} minor`, score:cMin};
    }
    return best.name;
  }

  function drawRoll(events, durationSec){
    rc.clearRect(0,0,roll.width,roll.height);
    // grid
    rc.strokeStyle = "rgba(110,231,255,0.25)";
    rc.lineWidth = 1;
    for(let i=0;i<=10;i++){
      const x = (i/10)*roll.width;
      rc.beginPath(); rc.moveTo(x,0); rc.lineTo(x,roll.height); rc.stroke();
    }
    // note lane mapping: MIDI 36..84
    const minM=36, maxM=84, span=maxM-minM;
    function yForMidi(m){ return roll.height - ((m-minM)/span)*roll.height; }

    // draw dominant notes (cyan) & bass (lime accents)
    events.forEach(ev=>{
      const x = (ev.t/durationSec)*roll.width;
      if (ev.midi){
        rc.fillStyle = "rgba(110,231,255,0.85)";
        const y = yForMidi(ev.midi);
        rc.fillRect(x, y-3, 3, 6);
      }
      if (ev.bassMidi){
        rc.fillStyle = "rgba(16,185,129,0.9)";
        const yb = yForMidi(ev.bassMidi);
        rc.fillRect(x, yb-4, 4, 8);
      }
    });
  }

  analyzeBtn.onclick = async () => {
    const f = fileEl.files?.[0];
    if (!f){ alert("Choose an audio file first."); return; }

    keyOut.textContent = "…";
    bpmOut.textContent = "…";
    framesOut.textContent = "…";
    listEl.textContent = "";
    histEl.innerHTML = "";

    const arrBuf = await f.arrayBuffer();
    const ac = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100*120, 44100); // up to 120s
    let audioBuf;
    try{
      audioBuf = await ac.decodeAudioData(arrBuf.slice(0));
    }catch(e){
      alert("Could not decode audio. Try a WAV/MP3.");
      return;
    }
    const sr = audioBuf.sampleRate;
    const ch = audioBuf.numberOfChannels;
    const mono = new Float32Array(audioBuf.length);
    // downmix
    for(let c=0;c<ch;c++){
      const data = audioBuf.getChannelData(c);
      for(let i=0;i<data.length;i++) mono[i] = (mono[i]||0) + data[i]/ch;
    }
    // analysis params
    const frameSize = 4096;
    const hop = 2048; // ~46ms @44.1k
    const total = mono.length;
    const durationSec = total/sr;

    const events = [];
    const pclass = new Float32Array(12);
    const onsetPeaks = [];

    // simple energy onset detection to estimate BPM
    let prevE = 0;
    for(let start=0; start+frameSize<=total; start+=hop){
      const frame = mono.subarray(start, start+frameSize).slice(); // local copy (windowing modifies it)
      // Energy for rough onsets
      let e=0; for(let i=0;i<frame.length;i++) e += frame[i]*frame[i];
      const de = e - prevE; prevE = e;
      if (de>0.1) onsetPeaks.push(start);

      const f0 = autocorrPitch(frame, sr); // Hz
      let midi = 0, name = "", pc = -1;
      if (f0>0){
        const m = hzToMidi(f0);
        midi = clamp(Math.round(m), 24, 100);
        name = midiToName(m);
        pc = ((Math.round(m)%12)+12)%12;
        pclass[pc] += 1;
      }

      // “bass” hint: if strong low freq content exists, bias to ≤ 200 Hz fundamental
      let bassMidi = 0;
      if (f0>20 && f0<=200){
        const mb = clamp(Math.round(hzToMidi(f0)), 20, 80);
        bassMidi = mb;
      }

      const t = start/sr;
      events.push({t, midi, name, bassMidi});
    }

    // Key
    const keyName = estimateKeySmoothed(pclass);
    keyOut.textContent = keyName;

    // Frames
    framesOut.textContent = events.length.toString();

    // BPM rough
    const bpm = estimateBPM(onsetPeaks, sr);
    bpmOut.textContent = bpm ? `${bpm} BPM` : "–";

    // Histogram UI
    const sum = Array.from(pclass).reduce((a,b)=>a+b,0) || 1;
    histEl.innerHTML = "";
    for(let i=0;i<12;i++){
      const pct = (pclass[i]/sum*100).toFixed(1);
      const div = document.createElement('div');
      div.textContent = `${NOTE_NAMES[i]} ${pct}%`;
      histEl.appendChild(div);
    }

    // List UI
    const lines = [];
    for (const ev of events){
      const ts = ev.t.toFixed(2).padStart(6,' ');
      const dn = ev.midi ? midiToName(ev.midi) : "--";
      const bn = ev.bassMidi ? midiToName(ev.bassMidi) : "--";
      lines.push(`${ts}s    dom:${dn.padEnd(4,' ')}    bass:${bn}`);
    }
    listEl.textContent = lines.join("\n");

    drawRoll(events, durationSec);

    // CSV export
    exportBtn.onclick = () => {
      const header = "time_s,dominant_midi,dominant_name,bass_midi,bass_name\n";
      const body = events.map(ev=>{
        const dName = ev.midi? midiToName(ev.midi) : "";
        const bName = ev.bassMidi? midiToName(ev.bassMidi) : "";
        return `${ev.t.toFixed(4)},${ev.midi||""},${dName},${ev.bassMidi||""},${bName}`;
      }).join("\n");
      const blob = new Blob([header+body],{type:"text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href=url; a.download="analysis.csv"; a.click();
      URL.revokeObjectURL(url);
    };

    function estimateKeySmoothed(hist){
      // smooth histogram a little (neighbor average) and correlate
      const sm = new Float32Array(12);
      for(let i=0;i<12;i++){
        const a = hist[(i+11)%12], b = hist[i], c = hist[(i+1)%12];
        sm[i] = (a + 2*b + c)/4;
      }
      return correlateKey(Array.from(sm));
    }
  };
})();
</script>
</body>
</html>
