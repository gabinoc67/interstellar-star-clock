<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST — CSV Dual Player with Musicalize (Quantize • Swing • Key • Reverb)</title>
<style>
  :root{
    --bg:#0a0f1f; --ink:#eaf1ff; --muted:#a8b7e3; --panel:#121a33; --grid:#1b254b;
    --accent:#3b82f6; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid var(--grid);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:18px;margin:0}
  main{max-width:1260px;margin:0 auto;padding:16px;display:grid;grid-template-columns:400px 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:12px;padding:14px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="file"],button,input[type="range"],select,input[type="number"]{width:100%;padding:10px;border-radius:10px;border:1px solid var(--grid);background:#0e1733;color:var(--ink)}
  button{cursor:pointer;background:linear-gradient(180deg,#15245a,#0f1b45)}
  button:hover{filter:brightness(1.06)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px dashed var(--grid);border-radius:10px;margin-top:8px}
  .stat b{color:var(--ok)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;font-size:12px;white-space:pre;line-height:1.42}
  .scroller{max-height:280px;overflow:auto;border:1px solid var(--grid);border-radius:10px;padding:8px;background:#0c1430}
  .hr{height:1px;background:linear-gradient(90deg,transparent,#2a3a7a,transparent);margin:12px 0}
  .whiteSquare{width:100%; height:38px; background:#fff; color:#000; display:flex; align-items:center; justify-content:center;
    border-radius:8px; border:2px solid #ddd; cursor:pointer; user-select:none;}
  .whiteSquare.active{outline:3px solid #4f8cff; font-weight:700}
  canvas{width:100%;height:240px;background:#0c1430;border:1px solid #22306b;border-radius:10px}
  .danger{background:#3b1220;border-color:#6b1f35}
  #status{font-size:12px;color:#9ad1ff;margin-top:8px}
  small.hint{display:block;color:#a8b7e3;margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>CST — CSV Dual Player with Musicalize</h1>
  <span style="font-size:12px;color:#9ad1ff">Quantize • Swing • Key Snap • Humanize • Reverb • Stereo Spread</span>
</header>

<main>
  <!-- LEFT: CSV + Musicalize controls -->
  <section class="card">
    <label style="font-weight:600">Load CSV to A / B</label>
    <div class="row">
      <div>
        <input id="csvA" type="file" accept=".csv"/>
        <button id="btnLoadA" style="margin-top:6px">Load CSV → A</button>
      </div>
      <div>
        <input id="csvB" type="file" accept=".csv"/>
        <button id="btnLoadB" style="margin-top:6px">Load CSV → B</button>
      </div>
    </div>
    <small class="hint">CSV columns: <b>t,m,b</b> (seconds, dominant MIDI, bass MIDI). 0 means “no note”.</small>

    <div class="hr"></div>
    <label style="font-weight:600">Musicalize (applied at Play)</label>
    <div class="row">
      <div>
        <label>BPM</label>
        <input id="bpm" type="number" min="40" max="200" step="1" value="100"/>
      </div>
      <div>
        <label>Quantize</label>
        <select id="quant">
          <option value="0.5">1/2</option>
          <option value="0.333">1/3</option>
          <option value="0.25">1/4 (quarter)</option>
          <option value="0.125">1/8</option>
          <option value="0.0625" selected>1/16</option>
        </select>
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <div>
        <label>Swing (0–60%)</label>
        <input id="swing" type="range" min="0" max="0.6" step="0.01" value="0.12"/>
      </div>
      <div>
        <label>Humanize (ms)</label>
        <input id="human" type="number" min="0" max="40" step="1" value="8"/>
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <div>
        <label>Key</label>
        <select id="keyRoot"></select>
      </div>
      <div>
        <label>Mode</label>
        <select id="keyMode">
          <option value="major" selected>Major</option>
          <option value="minor">Minor</option>
        </select>
      </div>
    </div>

    <div class="hr"></div>
    <label>Speed (global)</label>
    <div class="row">
      <div class="whiteSquare" data-speed="0.8">Slow (0.8×)</div>
      <div class="whiteSquare active" data-speed="1.0">Medium (1.0×)</div>
    </div>
    <div class="row" style="margin-top:8px">
      <div class="whiteSquare" data-speed="1.25">Fast (1.25×)</div>
      <div class="whiteSquare" data-speed="1.5">Very Fast (1.5×)</div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Mix A</label>
        <input id="mixA" type="range" min="0" max="1" step="0.01" value="0.85"/>
      </div>
      <div>
        <label>Mix B</label>
        <input id="mixB" type="range" min="0" max="1" step="0.01" value="0.70"/>
      </div>
    </div>
    <div style="margin-top:8px">
      <label>Master Volume</label>
      <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.75"/>
    </div>
    <div class="row" style="margin-top:8px">
      <div>
        <label>Reverb Mix</label>
        <input id="reverbMix" type="range" min="0" max="1" step="0.01" value="0.18"/>
      </div>
      <div>
        <label>Stereo Spread</label>
        <input id="spread" type="range" min="0" max="1" step="0.01" value="0.5"/>
      </div>
    </div>

    <div class="hr"></div>
    <div class="row">
      <button id="playBtn">Play (60s)</button>
      <button id="stopBtn" class="danger">Stop</button>
    </div>
    <button id="resetBtn" style="margin-top:8px">Reset</button>
    <div id="status">Ready.</div>
  </section>

  <!-- RIGHT: Visuals -->
  <section class="card">
    <label>Piano-roll (A + B, time → note)</label>
    <canvas id="roll" width="960" height="240"></canvas>

    <div class="row" style="margin-top:8px">
      <div>
        <label>Preview (A+B) — time, dominant, bass</label>
        <div id="previewList" class="scroller mono"></div>
      </div>
      <div>
        <label>Tips</label>
        <div class="scroller mono" style="min-height:120px">
Adjust these if it feels chaotic:
• Set BPM to match song feel (try 90–120).
• Quantize 1/8 for calmer; 1/16 for busier.
• Swing 10–20% adds groove; 0% = straight.
• Pick the correct key and mode (Major/Minor).
• Reduce Stereo Spread if it feels “phasey”.
• Reverb Mix 10–25% for glue.
• Humanize 5–12 ms for life; 0 ms = robotic.
        </div>
      </div>
    </div>
  </section>
</main>

<script>
/* ===== Utilities ===== */
const NOTE=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const MAJOR=[0,2,4,5,7,9,11], MINOR=[0,2,3,5,7,8,10];
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const midiHz=m=>440*Math.pow(2,(m-69)/12);
const midiName=m=>NOTE[(m%12+12)%12]+(Math.floor(m/12)-1);
function pcsFor(root, mode){const r=NOTE.indexOf(root); const base=(mode==='minor')?MINOR:MAJOR; return base.map(pc=>(pc+r+120)%12);}
function snapToScale(m, pcs){ if(!m) return 0; const pc=((m%12)+12)%12; if(pcs.includes(pc)) return m;
  for(const d of [1,-1,2,-2]){ const cand=((pc+d)+12)%12; if(pcs.includes(cand)) return m+d; } return m; }

/* ===== UI refs ===== */
const $=id=>document.getElementById(id);
const csvA=$('csvA'), csvB=$('csvB'), btnLoadA=$('btnLoadA'), btnLoadB=$('btnLoadB');
const bpmEl=$('bpm'), quantEl=$('quant'), swingEl=$('swing'), humanEl=$('human'), keyRootEl=$('keyRoot'), keyModeEl=$('keyMode');
const playBtn=$('playBtn'), stopBtn=$('stopBtn'), resetBtn=$('resetBtn');
const mixAEl=$('mixA'), mixBEl=$('mixB'), masterVolEl=$('masterVol'), reverbMixEl=$('reverbMix'), spreadEl=$('spread');
const speedSquares=[...document.querySelectorAll('.whiteSquare')];
const statusEl=$('status'), roll=$('roll'), rc=roll.getContext('2d');
const previewList=$('previewList');

/* ===== State ===== */
let A={events:[]}, B={events:[]};
let AUDIO={ctx:null, master:null, comp:null, convolver:null, wet:null, dry:null, panA:null, panB:null, speed:1.0};
let sch=[], idx=0, timer=null, t0=0;
const LOOKAHEAD=0.25, TICK=25;

/* ===== Status helper ===== */
const setStatus = (s)=> statusEl.textContent=s;

/* ===== Audio chain (soft + reverb + pan) ===== */
function getAudio(){
  if(!AUDIO.ctx){
    const ctx=new (window.AudioContext||window.webkitAudioContext)();

    const comp=ctx.createDynamicsCompressor(); comp.threshold.value=-20; comp.ratio.value=3; comp.attack.value=0.005; comp.release.value=0.2;

    const dry=ctx.createGain(), wet=ctx.createGain();
    dry.gain.value=1; wet.gain.value=parseFloat(reverbMixEl.value||"0.18");

    const convolver=ctx.createConvolver(); convolver.buffer=makeHallIR(ctx); // generated IR

    const panA=new StereoPanner(ctx, -0.4); // custom simple panner below
    const panB=new StereoPanner(ctx,  0.4);

    // master
    const master=ctx.createGain(); master.gain.value=parseFloat(masterVolEl.value||"0.75");

    // route: each voice -> (pan) -> dry & wet -> comp -> master -> dest
    const merger=ctx.createGain(); // attach voices to this
    merger.connect(panA.input); // left branch default
    merger.connect(panB.input); // right branch default (we'll route per side)
    // pan nodes go to dry & wet
    panA.output.connect(dry); panB.output.connect(dry);
    panA.output.connect(convolver); panB.output.connect(convolver);
    convolver.connect(wet);

    dry.connect(comp); wet.connect(comp);
    comp.connect(master); master.connect(ctx.destination);

    AUDIO={ctx,comp,master,convolver,wet,dry,panA,panB,merger, speed:1.0};
  }
  AUDIO.master.gain.value=parseFloat(masterVolEl.value||"0.75");
  AUDIO.wet.gain.value=parseFloat(reverbMixEl.value||"0.18");
  const spread=parseFloat(spreadEl.value||"0.5");
  AUDIO.panA.setPan(-0.15 - 0.35*spread);
  AUDIO.panB.setPan( 0.15 + 0.35*spread);
  return AUDIO.ctx;
}
async function resume(){ const ctx=getAudio(); if(ctx.state==='suspended'){ try{await ctx.resume();}catch(_){} } return ctx; }

/* ===== Simple stereo panner (crossfade) ===== */
function StereoPanner(ctx, pan){
  const input=ctx.createGain(), left=ctx.createGain(), right=ctx.createGain(), merger=ctx.createChannelMerger(2);
  input.connect(left); input.connect(right);
  left.connect(merger,0,0); right.connect(merger,0,1);
  function setPan(p){ const L=clamp(0.5 - p/2, 0, 1), R=clamp(0.5 + p/2, 0, 1); left.gain.setValueAtTime(L, ctx.currentTime); right.gain.setValueAtTime(R, ctx.currentTime); }
  setPan(pan||0);
  return {input, output:merger, setPan};
}

/* ===== Make a small hall IR (Schroeder-ish) ===== */
function makeHallIR(ctx){
  const len=ctx.sampleRate*2.2, ir=ctx.createBuffer(2, len, ctx.sampleRate);
  for(let ch=0; ch<2; ch++){
    const d=ir.getChannelData(ch);
    let x=0; // simple noise + decays
    for(let i=0;i<len;i++){
      const n=(Math.random()*2-1)*0.5;
      const t=i/ctx.sampleRate;
      const decay=Math.exp(-t*1.6);
      x = 0.3*n + 0.7*x;
      d[i] = x*decay;
    }
  }
  return ir;
}

/* ===== Synth (very soft envelopes/filters) ===== */
function preset(midi,isBass){
  if(isBass||midi<=52) return {wave:'sine',     lp:520,  q:0.7, a:0.006, d:0.08, s:0.75, r:0.12};
  if(midi<=72)        return {wave:'triangle', lp:2200, q:0.7, a:0.008, d:0.18, s:0.70, r:0.20};
  return                {wave:'sine',     lp:2600, q:0.6, a:0.006, d:0.16, s:0.68, r:0.18};
}
function voice(side){ return side==='B' ? AUDIO.panB.input : AUDIO.panA.input; }
function playNote(midi,when,dur,gain,isBass,side){
  const ctx=getAudio(); const p=preset(midi,isBass);
  const osc=ctx.createOscillator(); osc.type=p.wave; osc.frequency.setValueAtTime(midiHz(midi),when);
  const biq=ctx.createBiquadFilter(); biq.type='lowpass'; biq.frequency.setValueAtTime(p.lp,when); biq.Q.setValueAtTime(p.q,when);
  const amp=ctx.createGain(); amp.gain.setValueAtTime(0,when);
  amp.gain.linearRampToValueAtTime(gain,when+p.a);
  amp.gain.linearRampToValueAtTime(gain*p.s,when+p.a+p.d);
  amp.gain.setValueAtTime(gain*p.s, when+dur);
  amp.gain.linearRampToValueAtTime(0.0003, when+dur+p.r);
  osc.connect(biq); biq.connect(amp); amp.connect(voice(side));
  osc.start(when); osc.stop(when+dur+p.r+0.05);
}

/* ===== CSV helpers ===== */
function parseCSV(text){
  const lines=text.replace(/\r/g,'').trim().split('\n'); if(!lines.length) return [];
  const hdr=lines[0].split(',').map(s=>s.trim().toLowerCase());
  const ti=hdr.indexOf('t'), mi=hdr.indexOf('m'), bi=hdr.indexOf('b');
  if(ti<0||mi<0||bi<0) throw new Error("CSV must have headers: t,m,b");
  const out=[];
  for(let i=1;i<lines.length;i++){
    const row=lines[i].split(',').map(s=>s.trim());
    if(!row.length) continue;
    const t=parseFloat(row[ti]||"0"); const m=parseInt(row[mi]||"0",10); const b=parseInt(row[bi]||"0",10);
    if(Number.isFinite(t) && t>=0 && t<=60) out.push({t, m:(m|0), b:(b|0)});
  }
  return out.sort((a,b)=>a.t-b.t);
}

/* ===== Loaders ===== */
btnLoadA.addEventListener('click', async ()=>{
  const f=csvA.files?.[0]; if(!f){ alert("Select CSV for A"); return; }
  try{ A.events=parseCSV(await f.text()); }catch(e){ alert(e.message); return; }
  drawRoll(); renderPreview(); setStatus(`A: ${A.events.length} events loaded`);
});
btnLoadB.addEventListener('click', async ()=>{
  const f=csvB.files?.[0]; if(!f){ alert("Select CSV for B"); return; }
  try{ B.events=parseCSV(await f.text()); }catch(e){ alert(e.message); return; }
  drawRoll(); renderPreview(); setStatus(`B: ${B.events.length} events loaded`);
});

/* ===== Musicalize pass ===== */
function musicalize(events, side){
  if(!events?.length) return [];
  const BPM = parseFloat(bpmEl.value||"100");
  const beat = 60/ clamp(BPM,40,200);
  const qDiv = parseFloat(quantEl.value||"0.0625");     // fraction of whole note (1 = whole, 0.25 = quarter)
  const grid = beat * 4 * qDiv;                         // since 1 whole = 4 beats
  const swing = parseFloat(swingEl.value||"0");
  const human = parseFloat(humanEl.value||"0")/1000;
  const pcs = pcsFor(keyRootEl.value, keyModeEl.value);

  // quantize + swing + snap + density + velocity shaping
  const lastByPitch = new Map();
  const perSecCap = 10;
  let lastSec=-1, perSec=0;

  const out=[];
  for(const e of events){
    let t = Math.max(0, Math.min(60, e.t));
    // quantize to grid
    let q = Math.round(t/grid)*grid;
    // swing (push odd 8ths forward)
    if (grid <= beat/2 + 1e-6){       // only meaningful at 1/8 or finer
      const pos = Math.round(q/grid);
      if (pos % 2 === 1){ q += swing * grid * 0.5; }
    }
    q = clamp(q, 0, 60);

    const sec = Math.floor(q);
    if (sec!==lastSec){ perSec=0; lastSec=sec; }

    // snap to scale
    const m = e.m? snapToScale(e.m, pcs) : 0;
    const b = e.b? snapToScale(e.b, pcs) : 0;

    // density guard
    const push = (midi,isBass)=>{
      if(!midi) return;
      const last=lastByPitch.get(midi)||-999;
      if (q-last < 0.08) return;
      if (perSec >= perSecCap) return;
      lastByPitch.set(midi,q); perSec++;

      // humanize timing
      const jitter = (Math.random()*2-1) * human;
      const tH = clamp(q + jitter, 0, 60);

      // duration & velocity
      const dur = (isBass? 0.42:0.28);
      const base = isBass? 0.9 : 0.75;
      const height = midi/127;
      const vel = clamp(base * (0.9 + 0.2*(height-0.5)), 0.25, 1.0);

      out.push({t:tH, midi:Math.round(midi), dur, vel, isBass, side});
    };
    push(m,false); push(b,true);
  }
  return out.sort((a,b)=>a.t-b.t);
}

/* ===== Build schedule from A+B after musicalize ===== */
function buildSchedule(){
  const a = musicalize(A.events,'A');
  const b = musicalize(B.events,'B');
  return [...a, ...b].sort((x,y)=>x.t-y.t);
}

/* ===== Scheduler ===== */
let idxNote=0, timerID=null, startAudio=0;
function tick(){
  const ctx=AUDIO.ctx, now=ctx.currentTime, horizon=now+LOOKAHEAD, speed=AUDIO.speed||1.0;
  while(idxNote<sch.length){
    const e=sch[idxNote];
    const when = startAudio + e.t*(1/speed);
    if(when>horizon) break;
    const gainSide = (e.side==='B')? parseFloat(mixBEl.value||"0.7") : parseFloat(mixAEl.value||"0.85");
    playNote(e.midi, when, e.dur*(1/speed), e.vel*gainSide, e.isBass, e.side);
    idxNote++;
  }
  if(idxNote>=sch.length){ clearInterval(timerID); timerID=null; setStatus("Finished."); }
}
async function play(){
  await resume();
  stopAll();
  if(!A.events.length && !B.events.length){ alert("Load a CSV into A and/or B first."); return; }
  sch = buildSchedule();
  if(!sch.length){ alert("No schedulable notes in 0–60s."); return; }
  const ctx=AUDIO.ctx;
  startAudio = ctx.currentTime + 0.06;
  idxNote = 0;
  timerID = setInterval(tick, TICK);
  setStatus("Playing…");
}
function stopAll(){ if(timerID){ clearInterval(timerID); timerID=null; } idxNote=sch?.length||0; setStatus("Stopped."); }

/* ===== Visuals ===== */
function drawRoll(){
  const w=roll.width,h=roll.height; rc.clearRect(0,0,w,h);
  rc.strokeStyle="rgba(110,231,255,0.25)";
  for(let i=0;i<=10;i++){const x=i/10*w; rc.beginPath(); rc.moveTo(x,0); rc.lineTo(x,h); rc.stroke();}
  const minM=36,maxM=84,span=maxM-minM; const yy=m=>h-((m-minM)/span)*h;
  (A.events||[]).forEach(e=>{ if(e.m){ const x=e.t/60*w; rc.fillStyle="rgba(110,231,255,0.9)"; rc.fillRect(x,yy(e.m)-3,3,6);} if(e.b){ const x=e.t/60*w; rc.fillStyle="rgba(16,185,129,0.9)"; rc.fillRect(x,yy(e.b)-4,4,8);} });
  (B.events||[]).forEach(e=>{ if(e.m){ const x=e.t/60*w; rc.fillStyle="rgba(255,206,86,0.9)"; rc.fillRect(x,yy(e.m)-2,2,4);} if(e.b){ const x=e.t/60*w; rc.fillStyle="rgba(255,99,132,0.9)"; rc.fillRect(x,yy(e.b)-3,3,6);} });
}
function renderPreview(){
  const lines=[" time     DOM_A   BASS_A    DOM_B   BASS_B"];
  const tset=new Set([...A.events.map(e=>e.t), ...B.events.map(e=>e.t)]);
  const times=[...tset].sort((a,b)=>a-b).filter(t=>t<=60);
  for(const t of times){
    const a=A.events.find(e=>Math.abs(e.t-t)<1e-6)||{};
    const b=B.events.find(e=>Math.abs(e.t-t)<1e-6)||{};
    const ts=t.toFixed(2).padStart(6,' ');
    const ad=a.m?midiName(a.m).padEnd(5,' '):" --  "; const ab=a.b?midiName(a.b).padEnd(5,' '):" --  ";
    const bd=b.m?midiName(b.m).padEnd(5,' '):" --  "; const bb=b.b?midiName(b.b).padEnd(5,' '):" --  ";
    lines.push(`${ts}s   ${ad}   ${ab}    ${bd}   ${bb}`); if(lines.length>400) break;
  }
  previewList.textContent=lines.join("\n");
}

/* ===== Wire up ===== */
playBtn.addEventListener('click', play);
stopBtn.addEventListener('click', stopAll);
resetBtn.addEventListener('click', ()=>{
  stopAll(); A={events:[]}; B={events:[]}; drawRoll(); previewList.textContent=''; setStatus("Ready.");
});
speedSquares.forEach(sq=>sq.addEventListener('click', ()=>{
  speedSquares.forEach(x=>x.classList.remove('active'));
  sq.classList.add('active'); AUDIO.speed=parseFloat(sq.dataset.speed)||1.0;
}));
masterVolEl.addEventListener('input', ()=>{ getAudio(); AUDIO.master.gain.value=parseFloat(masterVolEl.value); });
reverbMixEl.addEventListener('input', ()=>{ getAudio(); AUDIO.wet.gain.value=parseFloat(reverbMixEl.value); });
spreadEl.addEventListener('input', ()=>{ getAudio(); }); // recompute pan

/* ===== Init ===== */
(function init(){
  // fill key dropdown
  NOTE.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; if(n==='C') o.selected=true; keyRootEl.appendChild(o); });
  drawRoll(); setStatus("Ready.");
})();
</script>
</body>
</html>
