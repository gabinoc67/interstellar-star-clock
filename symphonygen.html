<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST Astrodumus ‚Äî 3-Minute Symphony (One-Button, Random Emotion)</title>
<meta name="description" content="CST-synced 3-minute symphony generator with a broad instrument palette. One button. Random emotion per generation. Web Audio only."/>
<style>
  :root{
    --bg:#080e22;--panel:#0f1636;--ink:#e9f1ff;--muted:#9fb2e4;--accent:#8cc2ff;--grid:#1a2658;
    --ok:#1d5f46;--warn:#6a5720;--btn:#15235a;
  }
  *{box-sizing:border-box}html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:18px}
  h1{margin:0 0 6px;font-size:1.4rem}
  p.sub{margin:0 0 14px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:14px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.25);overflow:hidden}
  .pad{padding:14px}
  h2{margin:0 0 8px;font-size:1.05rem}
  .row{display:grid;grid-template-columns:150px 1fr auto;gap:8px;align-items:center}
  label{color:var(--muted)}
  input[type="range"]{width:100%}
  .pill{display:inline-block;background:#0e234d;color:#bdd3ff;font-size:.78rem;padding:3px 8px;border-radius:999px}
  .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  button{background:var(--btn);color:var(--ink);border:1px solid #273a8a;border-radius:12px;padding:10px 14px;cursor:pointer}
  button:hover{filter:brightness(1.08)}
  .ok{background:var(--ok);border-color:#2f8c6a}
  .warn{background:var(--warn);border-color:#a48632}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .status{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .status>div{background:#0b1333;border:1px solid var(--grid);border-radius:10px;padding:10px}
  .tiny{font-size:.85rem;color:var(--muted)}
  canvas{width:100%;height:260px;display:block;background:linear-gradient(180deg,#0b1536,#0b1230)}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0e2144;border:1px solid #253a7a;border-radius:6px;padding:2px 6px}
  details{margin-top:14px}
  details summary{cursor:pointer;color:#cfe0ff}
  ul{margin:8px 0 0 18px}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST ‚ÄúAstrodumus‚Äù ‚Äî 3-Minute Symphony (One Button)</h1>
  <p class="sub">Broad orchestra (strings, choir, brass, woods, pianos/keys, pads, plucks, bells/mallets, basses, drums). Random emotion per generation. CST time locks seed & tempo.</p>

  <div class="grid">
    <section class="card">
      <div class="pad">
        <h2>Controls</h2>
        <div class="row">
          <label>Style Tilt</label>
          <input id="style" type="range" min="0" max="100" value="55"/>
          <span class="pill"><span id="styleVal">55</span>% classic ‚Üí modern</span>
        </div>
        <div class="row">
          <label>Polyphony (max parts)</label>
          <input id="poly" type="range" min="4" max="18" value="12"/>
          <span class="pill"><span id="polyVal">12</span> parts</span>
        </div>
        <div class="row">
          <label>Humanize (ms)</label>
          <input id="human" type="range" min="0" max="40" value="12"/>
          <span class="pill"><span id="humanVal">12</span> ms</span>
        </div>
        <div class="row">
          <label>Seed</label>
          <input id="seed" type="text" placeholder="blank = CST auto seed" class="mono"/>
          <button id="dice" title="Randomize seed">üé≤</button>
        </div>
        <div class="row">
          <label>CST Lock</label>
          <div class="pill">On</div>
          <span class="tiny">Seed=BPM derived from America/Chicago minute</span>
        </div>
        <div class="btns">
          <button id="gen" class="ok">Generate 3-Minute Symphony</button>
          <button id="play">‚ñ∂ Play</button>
          <button id="stop">‚ñ† Stop</button>
          <button id="export" class="warn">‚¨á Export WAV</button>
        </div>

        <div class="status">
          <div>
            <div><b>CST Seed</b>: <span id="seedOut" class="mono">‚Äì</span></div>
            <div><b>BPM</b>: <span id="bpmOut">‚Äì</span></div>
            <div><b>Length</b>: <span id="lenOut">‚Äì</span></div>
          </div>
          <div>
            <div><b>Emotion</b>: <span id="emoOut">‚Äì</span></div>
            <div><b>Voices</b>: <span id="voicesOut">‚Äì</span></div>
            <div><b>Events</b>: <span id="evOut">‚Äì</span></div>
          </div>
          <div>
            <div><b>Key</b>: <span id="keyOut">‚Äì</span></div>
            <div><b>Export</b>: <span id="expOut" class="tiny">not started</span></div>
            <div><b>CST</b>: <span id="cstOut">‚Äì</span></div>
          </div>
        </div>
      </div>
      <canvas id="timeline" title="Timeline of instruments & notes"></canvas>
    </section>

    <aside class="card">
      <div class="pad">
        <h2>How it works (short)</h2>
        <ul>
          <li><b>Experience Profiles (7):</b> five canonical style profiles (Mozart, Bach, Beethoven, Chopin, Debussy) + two modern archetypes (FilmScore, JazzHarmony). No melodies are copied‚Äîonly abstract probability hints.</li>
          <li><b>Emotion Macro-Curves (6):</b> happy, sad, anger, fear, scary, heavenly. <u>Randomly selected</u> on each generation. The curve shapes mode, density, dissonance, dynamics, and orchestration weights.</li>
          <li><b>CST Sync:</b> Seed = <span class="kbd">YYYYMMDDHHmm</span> in America/Chicago; BPM = <span class="kbd">66 + (minute%18)*4</span>. Everyone at the same minute hears the same piece.</li>
          <li><b>Equation-Mix:</b> <span class="kbd">p_mix = Œ£ w·µ¢¬∑p·µ¢ / Œ£ w·µ¢</span> blends the 7 profiles for pitch steps, chord choices, rhythm density, & cadential pull.</li>
          <li><b>Emergent ‚Äúnew‚Äù notes:</b> Controlled two-note overlaps (3rds/6ths, occasional 2nds/‚ô≠9s) create perceptual combination-tones‚Äîan ‚Äúextra‚Äù color you can hear without chaos.</li>
          <li><b>Orchestra:</b> strings, choir, brass (trumpet/trombone/horn), woodwinds (flute/oboe/clarinet/bassoon), piano/celesta, pads, plucks/harp, bells & mallets (glock, vibraphone, marimba, tubular), basses (acoustic/synth), drums (kick/snare/hats/toms/cymbals).</li>
        </ul>
        <details>
          <summary>More details</summary>
          <ul>
            <li><b>Grid:</b> 4/4, 16th grid + triplet hints. Harmony lands cadences at bar ends to stay coherent.</li>
            <li><b>3 minutes:</b> bars computed from BPM so the result stays ~180s.</li>
            <li><b>Humanize:</b> small random timing offsets so it breathes.</li>
          </ul>
        </details>
      </div>
    </aside>
  </div>

  <details class="card">
    <summary class="pad"><b>Exact instrument list this build can synthesize (Web Audio, no samples)</b></summary>
    <div class="pad tiny">
      Piano, Celesta, Pad (lush), Strings (ensemble), Choir (ooh), Brass (trumpet/trombone/horn patch family), Woodwinds (flute, oboe, clarinet, bassoon flavors), Harp/Pluck, Bells, Glockenspiel, Vibraphone, Marimba, Tubular Bells, Synth Lead, Acoustic Bass, Synth Bass, Kick, Snare, Hi-Hat, Toms, Cymbal swell.  
      <br/>You can extend this list later with more patches or sampled instruments if desired.
    </div>
  </details>
</div>

<script>
/* ===== Time & Seed ===== */
function nowCSTParts(){
  const fmt=new Intl.DateTimeFormat('en-US',{timeZone:'America/Chicago',year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',hour12:false});
  const p=Object.fromEntries(fmt.formatToParts(new Date()).map(x=>[x.type,x.value]));
  return {Y:p.year,M:p.month,D:p.day,h:p.hour,m:p.minute};
}
function makeCSTSeed(){ const t=nowCSTParts(); return `${t.Y}${t.M}${t.D}${t.h}${t.m}`; }
function hash32(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i); h=(h*16777619)>>>0;} return h>>>0; }
function rngFromSeed(n){ let s=n>>>0||1; return function(){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)/4294967296; } }

/* ===== Harmony Helpers ===== */
const KEYROOTS={C:0,G:7,D:2,A:9,E:4,F:5,Bb:10,Eb:3,Ab:8};
const MODES={ionian:[0,2,4,5,7,9,11],aeolian:[0,2,3,5,7,8,10],dorian:[0,2,3,5,7,9,10],mixolydian:[0,2,4,5,7,9,10],whole:[0,2,4,6,8,10],octa:[0,2,3,5,6,8,9,11]};
function scaleFor(key,mode){ return MODES[mode].map(s=>s+KEYROOTS[key]); }
function degToMidi(base,scale,deg){ const L=scale.length; const oct=Math.floor(deg/L); const idx=((deg%L)+L)%L; return base+oct*12+(scale[idx]-scale[0]); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function pick(r,arr,wts){ const sum=wts.reduce((a,b)=>a+b,0)||1; let t=r()*sum; for(let i=0;i<arr.length;i++){ if((t-=wts[i])<=0) return arr[i]; } return arr[arr.length-1]; }

/* ===== Experience (Style) Profiles: 7 ===== */
const Profiles = {
  Mozart:{ step:[30,30,15,10,10,5], rhythm:0.55, cad:[0.30,0.50,0.20] },
  Bach:{ step:[35,25,12,12,10,6],  rhythm:0.60, cad:[0.35,0.40,0.25] },
  Beethoven:{ step:[28,26,14,16,10,6], rhythm:0.50, cad:[0.25,0.45,0.30] },
  Chopin:{ step:[26,26,14,12,14,8], rhythm:0.62, cad:[0.28,0.37,0.35] },
  Debussy:{ step:[22,22,16,16,14,10], rhythm:0.48, cad:[0.20,0.40,0.40] },
  FilmScore:{ step:[24,24,16,18,12,6], rhythm:0.52, cad:[0.22,0.40,0.38] },
  JazzHarmony:{ step:[22,24,14,18,14,8], rhythm:0.58, cad:[0.24,0.38,0.38] }
};
const ProfileNames = Object.keys(Profiles);

/* ===== Emotion Macro-Curves (6) ‚Äî randomly chosen each generation ===== */
const EMO = {
  heavenly:{ key:"C", modes:["ionian","mixolydian","dorian"], bpm:[64,76], dens:0.55, diss:0.15,
             inst:{choir:1.0,strings:0.9,pad:0.9,bells:0.7,harp:0.6,piano:0.4,woods:0.4,brass:0.3} },
  happy:{ key:"G", modes:["ionian","mixolydian"], bpm:[92,112], dens:0.62, diss:0.18,
          inst:{strings:0.9,piano:0.8,woods:0.7,bells:0.5,brass:0.4,pad:0.4,harp:0.3,choir:0.3} },
  sad:{ key:"D", modes:["aeolian","dorian"], bpm:[58,72], dens:0.48, diss:0.22,
        inst:{strings:1.0,piano:0.8,harp:0.6,choir:0.5,pad:0.5,woods:0.4,bells:0.2,brass:0.2} },
  anger:{ key:"A", modes:["dorian","aeolian"], bpm:[112,132], dens:0.70, diss:0.30,
          inst:{brass:1.0,strings:0.85,piano:0.6,woods:0.4,pad:0.3,choir:0.25,bells:0.2,harp:0.15} },
  fear:{ key:"E", modes:["aeolian","octa"], bpm:[60,72], dens:0.35, diss:0.28,
         inst:{pad:1.0,woods:0.7,strings:0.6,choir:0.5,bells:0.3,harp:0.3,piano:0.25,brass:0.2} },
  scary:{ key:"F", modes:["octa","whole","aeolian"], bpm:[52,66], dens:0.28, diss:0.36,
          inst:{pad:1.0,choir:0.9,strings:0.5,woods:0.4,bells:0.35,harp:0.2,piano:0.2,brass:0.15} }
};
const EMO_NAMES = Object.keys(EMO);

/* ===== Audio Engine ===== */
let ACTX=null, master=null, sendRev=null; const BUS={}; let scheduled=[], playing=false;
function ensureAudio(){
  if(ACTX) return;
  ACTX=new (window.AudioContext||window.webkitAudioContext)();
  master=ACTX.createGain(); master.gain.value=0.9; master.connect(ACTX.destination);
  // Simple multi-comb reverb (Schroeder-ish)
  const combs=[], delays=[0.0297,0.0371,0.0411,0.0437], gains=[0.805,0.827,0.783,0.764];
  const sum=ACTX.createGain(); sum.connect(master);
  for(let i=0;i<4;i++){ const d=ACTX.createDelay(1); d.delayTime.value=delays[i]; const g=ACTX.createGain(); g.gain.value=gains[i]; d.connect(g); g.connect(d); g.connect(sum); combs.push({d,g}); }
  sendRev=ACTX.createGain(); sendRev.gain.value=0.25; combs.forEach(c=>sendRev.connect(c.d));
}
function makeBus(level,pan=0){
  const g=ACTX.createGain(); g.gain.value=level;
  const p=ACTX.createStereoPanner?ACTX.createStereoPanner():null;
  if(p){ p.pan.value=pan; g.connect(p); p.connect(master); } else { g.connect(master); }
  const send=ACTX.createGain(); send.gain.value=0.0; g.connect(send); send.connect(sendRev);
  return {g,send};
}
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function env(g,t0,a,d,sus,hold,rel,vel){
  const t1=t0+a, t2=t1+d, t3=t2+hold, t4=t3+rel;
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(vel,t1);
  g.gain.linearRampToValueAtTime(vel*sus,t2);
  g.gain.setValueAtTime(vel*sus,t3);
  g.gain.linearRampToValueAtTime(0,t4);
  return t4;
}

/* ===== Patches (broad family) ===== */
const Patches = {
  // Keys & pads
  piano:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=4800;
    const g=ACTX.createGain(); const end=env(g,t,0.005,0.18,0.35,Math.max(0.01,d-0.2),0.25,v*0.8);
    o.connect(f); f.connect(g); g.connect(BUS.piano.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  celesta:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.003,0.12,0.25,0.02,0.5,v*0.7); o.connect(g); g.connect(BUS.celesta.g); g.connect(BUS.celesta.send); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  pad:(m,t,d,v)=>{ const o1=ACTX.createOscillator(), o2=ACTX.createOscillator(); o1.type='sawtooth'; o2.type='triangle';
    o1.frequency.value=midiToHz(m)*0.999; o2.frequency.value=midiToHz(m)*1.001;
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2600;
    const g=ACTX.createGain(); const end=env(g,t,0.4,1.8,0.7,Math.max(0.2,d-1.2),1.5,v*0.4);
    o1.connect(f); o2.connect(f); f.connect(g); g.connect(BUS.pad.g); g.connect(BUS.pad.send);
    o1.start(t); o2.start(t); o1.stop(end); o2.stop(end); scheduled.push({o:[o1,o2],g,end}); },
  // Strings & choir
  strings:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200;
    const g=ACTX.createGain(); const end=env(g,t,0.08,0.5,0.8,Math.max(0.05,d-0.4),0.3,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.strings.g); g.connect(BUS.strings.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  choir:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const lfo=ACTX.createOscillator(); lfo.frequency.value=5.5; const lg=ACTX.createGain(); lg.gain.value=6; lfo.connect(lg); lg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.2,0.8,0.6,Math.max(0.15,d-0.8),1.0,v*0.55);
    o.connect(g); g.connect(BUS.choir.g); g.connect(BUS.choir.send);
    o.start(t); lfo.start(t); o.stop(end); lfo.stop(end); scheduled.push({o:[o,lfo],g,end}); },
  // Brass & woods
  brass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sawtooth'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
    const g=ACTX.createGain(); const end=env(g,t,0.02,0.25,0.6,Math.max(0.05,d-0.3),0.25,v*0.8);
    o.connect(f); f.connect(g); g.connect(BUS.brass.g); g.connect(BUS.brass.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  woods:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
    const g=ACTX.createGain(); const end=env(g,t,0.03,0.22,0.55,Math.max(0.05,d-0.25),0.2,v*0.6);
    o.connect(f); f.connect(g); g.connect(BUS.woods.g); g.connect(BUS.woods.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  // Plucks & mallets
  harp:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.22,0.35,0.01,0.4,v*0.7);
    o.connect(g); g.connect(BUS.harp.g); g.connect(BUS.harp.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  bells:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const fm=ACTX.createOscillator(); fm.frequency.value=880; const fg=ACTX.createGain(); fg.gain.value=30; fm.connect(fg); fg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.001,0.8,0.2,0.02,1.6,v*0.7);
    o.connect(g); g.connect(BUS.bells.g); g.connect(BUS.bells.send);
    o.start(t); fm.start(t); o.stop(end); fm.stop(end); scheduled.push({o:[o,fm],g,end}); },
  glock:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m)*2;
    const g=ACTX.createGain(); const end=env(g,t,0.001,0.4,0.25,0.02,0.8,v*0.6);
    o.connect(g); g.connect(BUS.glock.g); g.connect(BUS.glock.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  vibraphone:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m);
    const lfo=ACTX.createOscillator(); lfo.frequency.value=6; const lg=ACTX.createGain(); lg.gain.value=10; lfo.connect(lg); lg.connect(o.frequency);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.5,0.5,0.1,0.9,v*0.55);
    o.connect(g); g.connect(BUS.vibes.g); g.connect(BUS.vibes.send);
    o.start(t); lfo.start(t); o.stop(end); lfo.stop(end); scheduled.push({o:[o,lfo],g,end}); },
  marimba:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.002,0.35,0.35,0.02,0.6,v*0.7);
    o.connect(g); g.connect(BUS.marimba.g); g.connect(BUS.marimba.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  tubular:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(m)/2;
    const g=ACTX.createGain(); const end=env(g,t,0.005,1.2,0.8,0.3,2.2,v*0.7);
    o.connect(g); g.connect(BUS.tubular.g); g.connect(BUS.tubular.send);
    o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  // Bass
  abass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='triangle'; o.frequency.value=midiToHz(m);
    const g=ACTX.createGain(); const end=env(g,t,0.01,0.3,0.5,Math.max(0.05,d-0.25),0.25,v*0.7);
    o.connect(g); g.connect(BUS.abass.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  sbass:(m,t,d,v)=>{ const o=ACTX.createOscillator(); o.type='square'; o.frequency.value=midiToHz(m);
    const f=ACTX.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900;
    const g=ACTX.createGain(); const end=env(g,t,0.02,0.25,0.6,Math.max(0.05,d-0.3),0.25,v*0.7);
    o.connect(f); f.connect(g); g.connect(BUS.sbass.g); o.start(t); o.stop(end); scheduled.push({o:[o],g,end}); },
  // Drums
  kickAt:(t,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(130,t); o.frequency.exponentialRampToValueAtTime(40,t+0.12);
    const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.9,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g); g.connect(BUS.perc.g); o.start(t); o.stop(t+0.2); },
  snareAt:(t,v)=>{ const b=ACTX.createBuffer(1,ACTX.sampleRate*0.2,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++){d[i]=Math.random()*2-1;}
    const s=ACTX.createBufferSource(); s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.5,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2);
    s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.2); },
  hatAt:(t,v)=>{ const b=ACTX.createBuffer(1,ACTX.sampleRate*0.08,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++){d[i]=Math.random()*2-1;}
    const s=ACTX.createBufferSource(); s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.25,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.08);
    s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+0.08); },
  tomAt:(t,v)=>{ const o=ACTX.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(180,t); o.frequency.exponentialRampToValueAtTime(120,t+0.12);
    const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.5,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.25); o.connect(g); g.connect(BUS.perc.g); o.start(t); o.stop(t+0.26); },
  cymbalAt:(t,v)=>{ const b=ACTX.createBuffer(1,ACTX.sampleRate*1.5,ACTX.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++){d[i]=(Math.random()*2-1)*0.6;}
    const s=ACTX.createBufferSource(); s.buffer=b; const f=ACTX.createBiquadFilter(); f.type='highpass'; f.frequency.value=4000; const g=ACTX.createGain(); g.gain.setValueAtTime(v*0.3,t); g.gain.exponentialRampToValueAtTime(0.0001,t+1.5);
    s.connect(f); f.connect(g); g.connect(BUS.perc.g); s.start(t); s.stop(t+1.5); }
};

/* ===== Composition ===== */
function computeBPM(){ const t=nowCSTParts(); return 66 + (parseInt(t.m,10)%18)*4; } // 66..138
function barsFor3min(bpm){ return Math.max(24, Math.round(180*bpm/240)); } // ~3:00

function mixProfiles(weights){
  const sum=weights.reduce((a,b)=>a+b,0)||1, W=weights.map(v=>v/sum);
  const blend={step:Array(6).fill(0), rhythm:0, cad:[0,0,0]};
  ProfileNames.forEach((name,i)=>{
    const p=Profiles[name], k=W[i];
    p.step.forEach((v,j)=>blend.step[j]+=k*v);
    blend.rhythm+=k*p.rhythm; blend.cad=blend.cad.map((v,j)=>v+k*p.cad[j]);
  });
  return blend;
}
function styleWeights(tilt){ // 0 classic ‚Üí 100 modern
  const k=tilt/100;
  return ProfileNames.map(name=>{
    if(['Mozart','Bach','Beethoven','Chopin','Debussy'].includes(name)) return (1-k)*1 + k*0.6;
    if(name==='FilmScore') return 0.5 + 1.0*k;
    if(name==='JazzHarmony') return 0.4 + 1.0*k;
    return 1;
  });
}
function orchFor(emotion, style, poly){
  // base weights from emotion, then tilt classic‚Üímodern
  const base={...EMO[emotion].inst};
  // add extended instruments with small base if missing
  const extra={piano:0.3,celesta:0.3,pad:0.3,harp:0.3,bells:0.25,glock:0.2,vibraphone:0.2,marimba:0.2,tubular:0.15,abass:0.4,sbass:0.4,brass:0.3,woods:0.3,strings:0.6,choir:0.6};
  Object.keys(extra).forEach(k=>{ base[k]=(base[k]||0)+extra[k]*0.6; });
  // style tilt
  const modernBoost=style/100;
  base.pad += 0.3*modernBoost; base.brass += 0.25*modernBoost; base.piano += 0.2*modernBoost; base.bells += 0.15*modernBoost; base.sbass += 0.2*modernBoost;
  base.choir *= (1-0.1*modernBoost); base.strings *= (1-0.05*modernBoost); base.woods *= (1-0.05*modernBoost); base.harp *= (1-0.08*modernBoost);
  // normalize and pick top N
  const entries=Object.entries(base).filter(([k,v])=>v>0).sort((a,b)=>b[1]-a[1]);
  return entries.slice(0, poly).map(([name])=>name);
}

function compose(opts){
  const rnd=opts.rnd;
  const emo = EMO_NAMES[Math.floor(rnd()*EMO_NAMES.length)]; // random emotion
  const profWeights = styleWeights(opts.style);
  const blend = mixProfiles(profWeights);
  const profNamesUsed = ProfileNames; // for display
  const profile = EMO[emo];

  const bpm=computeBPM();
  const bars=barsFor3min(bpm);
  const beat=60/bpm, grid=4, step=beat/grid, total=bars*4*grid;
  const mode = profile.modes[Math.floor(rnd()*profile.modes.length)];
  const scale=scaleFor(profile.key, mode);
  const base=60; // middle C

  const pool=orchFor(emo, opts.style, opts.poly); // instruments selected this run
  const events=[]; const DRUM=[]; let deg=0; let t=0;

  function leadStep(){
    const sizes=[1,2,3,4,5,7];
    const sz=pick(rnd, sizes, blend.step);
    const dir=rnd()<0.55?1:-1;
    deg=clamp(deg+dir*sz,-10,10);
    return deg;
  }
  function dynAt(norm){ // simple emotive curve
    const A={heavenly:(x)=>0.5+0.45*Math.sin(x*Math.PI),
             happy:(x)=>0.55+0.35*Math.sin(2*Math.PI*x),
             sad:(x)=>0.45+0.40*Math.sin(Math.PI*x),
             anger:(x)=>0.65+0.30*Math.sin(3*Math.PI*x),
             fear:(x)=>0.40+0.35*Math.sin(1.7*Math.PI*x),
             scary:(x)=>0.42+0.38*Math.sin(1.2*Math.PI*x)};
    return clamp(A[emo](norm),0.15,1.0);
  }

  for(let s=0;s<total;s++){
    const inBar=s%(4*grid), down=(inBar===0), at8=(s%2===0), atTri=(s%3===0);
    let place=false;
    if(down && rnd()<0.98) place=true;
    else if(at8 && rnd()<profile.dens) place=true;
    else if(atTri && rnd()<profile.dens*0.35) place=true;

    const left=(4*grid-inBar);
    if(left<=grid && rnd()<blend.cad[2]) place=true;
    else if(left<=2*grid && rnd()<blend.cad[1]) place=true;
    else if(left<=3*grid && rnd()<blend.cad[0]) place=true;

    const norm=t/(bars*4*beat);
    if(place){
      const d=leadStep();
      const lead=degToMidi(base+12,scale,d);
      const dur= step*( rnd()<0.2?4 : rnd()<0.5?2 : 1 );
      const instLead = pool[Math.floor(rnd()*pool.length)];
      events.push({inst:instLead,time:t,dur,midi:lead,vel:(0.65+0.35*rnd())*dynAt(norm)});
      // polytonal sparkle
      if(rnd()< (0.12 + profile.diss*0.5)){
        const intervals = (emo==='scary'||emo==='fear') ? [1,2,10] : [3,4,7,9,10,2];
        const iv = intervals[Math.floor(rnd()*intervals.length)];
        const inst2 = pool[Math.floor(rnd()*pool.length)];
        events.push({inst:inst2,time:t+step*0.02,dur:dur*0.95,midi:lead+iv,vel:0.55*dynAt(norm)});
      }
      // harmony pad/strings
      if(rnd()<0.9){
        const root=degToMidi(base,scale, Math.round(d/2));
        const chord=[0,4,7];
        const hold= beat*(rnd()<0.5?2:4);
        const instH = pool.includes('pad')?'pad': (pool.includes('strings')?'strings': 'pad');
        chord.forEach(iv=> events.push({inst:instH,time:t,dur:hold,midi:root+iv,vel:0.35*dynAt(norm)}));
        if(rnd()<0.35) events.push({inst:instH,time:t,dur:hold,midi:root+10,vel:0.28*dynAt(norm)});
        if(rnd()<0.2 && profile.diss>0.2) events.push({inst:instH,time:t,dur:hold,midi:root+14,vel:0.22*dynAt(norm)});
      }
    }
    // bass
    if(down || (at8 && rnd()<0.2)){
      const bd=Math.round(deg/3);
      const bass=degToMidi(base-24,scale,bd);
      const dur= beat*(rnd()<0.5?1:2);
      const instB = pool.includes('abass')?'abass':(pool.includes('sbass')?'sbass':'abass');
      events.push({inst:instB,time:t,dur,midi:bass,vel:0.6*dynAt(norm)});
      if(rnd()<0.35) events.push({inst:instB,time:t+step*2,dur:dur,midi:bass+7,vel:0.5*dynAt(norm)});
    }
    // arps
    if((emo==='heavenly'||emo==='happy'||emo==='sad') && at8 && rnd()<0.12){
      const root=degToMidi(base+5, scale, Math.round(deg/2));
      const seq=[0,4,7,12]; const inst= pool.includes('harp')?'harp':(pool.includes('celesta')?'celesta':'piano');
      seq.forEach((iv,i)=> events.push({inst,time:t+i*(step*0.5),dur:step*0.5,midi:root+iv,vel:0.45*dynAt(norm)}));
    }
    // drums (coherence)
    const dE = {heavenly:0.25,happy:0.65,sad:0.2,anger:0.9,fear:0.35,scary:0.25}[emo];
    if(rnd()<dE){
      if(down) DRUM.push({type:'kick',time:t,vel:0.9*dynAt(norm)});
      if(inBar===2 || inBar===8) DRUM.push({type:'snare',time:t+step*2,vel:0.6*dynAt(norm)});
      if(at8 && rnd()<0.7) DRUM.push({type:'hat',time:t,vel:0.25*dynAt(norm)});
      if(down && rnd()<0.15) DRUM.push({type:'tom',time:t+step,vel:0.5*dynAt(norm)});
      if(left===grid && rnd()<0.12) DRUM.push({type:'cym',time:t,vel:0.35*dynAt(norm)});
    }

    t+=step;
  }

  return {events, drums:DRUM, bpm, seconds: bars*4*beat, key:`${profile.key} ${mode}`, emotion:emo, pool, profiles:profNamesUsed};
}

/* ===== Scheduler / Renderer / UI ===== */
const $=id=>document.getElementById(id);
const TLM=$('timeline'); const CTX=TLM.getContext('2d');
function drawTimeline(score){
  const dpr=window.devicePixelRatio||1; const W=TLM.clientWidth*dpr, H=TLM.clientHeight*dpr;
  TLM.width=W; TLM.height=H; CTX.clearRect(0,0,W,H);
  const colors={piano:'#b8e1ff',celesta:'#d6f0ff',pad:'#b8fff6',strings:'#ffddb0',choir:'#d9c5ff',brass:'#ffd1d1',woods:'#c8ffc8',harp:'#ffe7f3',bells:'#fff0b8',glock:'#e9ffbe',vibraphone:'#c9ffe9',marimba:'#ffe4be',tubular:'#fff6d0',abass:'#ffd3a3',sbass:'#ffc2e0',perc:'#b0b9c9'};
  const rows=['piano','celesta','pad','strings','choir','brass','woods','harp','bells','glock','vibraphone','marimba','tubular','abass','sbass','perc'];
  const rh=H/rows.length;
  // grid
  CTX.strokeStyle="#1b2a66"; CTX.lineWidth=1;
  const beats=Math.round(score.seconds/(60/score.bpm));
  for(let i=0;i<=beats;i++){ const x=i*(W/beats); CTX.beginPath(); CTX.moveTo(x,0); CTX.lineTo(x,H); CTX.stroke(); }
  // draw pitched
  function rx(t){ return (t/score.seconds)*W; }
  score.events.forEach(e=>{
    const ri=rows.indexOf(e.inst); if(ri<0) return;
    const x=rx(e.time), w=(e.dur/score.seconds)*W, y=ri*rh+rh*0.2, h=rh*0.6;
    CTX.fillStyle=colors[e.inst]||'#eee'; CTX.fillRect(x,y,Math.max(1.5,w),h);
  });
  // drums row
  score.drums.forEach(d=>{
    const ri=rows.indexOf('perc'); const x=rx(d.time), y=ri*rh+rh*0.1;
    CTX.fillStyle=colors.perc; CTX.fillRect(x,y,Math.max(2,W/500),rh*0.8);
  });
}

function schedule(score, humanMs){
  ensureAudio();
  // init busses once
  ['piano','celesta','pad','strings','choir','brass','woods','harp','bells','glock','vibraphone','marimba','tubular','abass','sbass','perc'].forEach((k,i)=>{
    BUS[k]=BUS[k]||makeBus(k==='perc'?0.9:0.7, (i%2?0.15:-0.15));
  });
  const start=ACTX.currentTime+0.2, jitter=(humanMs||0)/1000;
  playing=true; scheduled.length=0;

  // map pitched by name
  const playMap={
    piano:Patches.piano, celesta:Patches.celesta, pad:Patches.pad, strings:Patches.strings, choir:Patches.choir,
    brass:Patches.brass, woods:Patches.woods, harp:Patches.harp, bells:Patches.bells, glock:Patches.glock,
    vibraphone:Patches.vibraphone, marimba:Patches.marimba, tubular:Patches.tubular, abass:Patches.abass, sbass:Patches.sbass
  };

  score.events.forEach(ev=>{
    const when=start+ev.time+(Math.random()*2-1)*jitter;
    const fn=playMap[ev.inst]; if(fn) fn(ev.midi,when,ev.dur,clamp(ev.vel,0,1));
  });

  // drums
  score.drums.forEach(d=>{
    const t=start+d.time+(Math.random()*2-1)*jitter*0.5;
    if(d.type==='kick') Patches.kickAt(t,d.vel);
    if(d.type==='snare') Patches.snareAt(t,d.vel);
    if(d.type==='hat') Patches.hatAt(t,d.vel);
    if(d.type==='tom') Patches.tomAt(t,d.vel);
    if(d.type==='cym') Patches.cymbalAt(t,d.vel);
  });

  setTimeout(()=>stopAll(), (score.seconds+1.5)*1000);
}
function stopAll(){
  if(!playing) return; playing=false;
  const now=ACTX?ACTX.currentTime:0;
  scheduled.forEach(n=>{ try{
    if(n.g){ n.g.gain.cancelScheduledValues(now); n.g.gain.linearRampToValueAtTime(0, now+0.05); }
    (n.o||[]).forEach(o=>{ try{o.stop(now+0.06);}catch(e){} });
  }catch(e){} });
  scheduled.length=0;
}

/* Offline render to WAV (compact version) */
async function renderWav(score){
  ensureAudio();
  const sr=44100, len=score.seconds+2;
  const ctx=new OfflineAudioContext(2, Math.ceil(len*sr), sr);
  const master=ctx.createGain(); master.gain.value=0.9; master.connect(ctx.destination);
  const send=ctx.createGain(); send.gain.value=0.25;
  const d=ctx.createDelay(1); d.delayTime.value=0.04; const g=ctx.createGain(); g.gain.value=0.6; d.connect(g); g.connect(d);
  const sum=ctx.createGain(); d.connect(sum); sum.connect(master); send.connect(d);
  function mkBus(level){ const g=ctx.createGain(); g.gain.value=level; g.connect(master); const s=ctx.createGain(); s.gain.value=0.2; g.connect(s); s.connect(send); return {g}; }
  const B={}; ['piano','celesta','pad','strings','choir','brass','woods','harp','bells','glock','vibraphone','marimba','tubular','abass','sbass','perc'].forEach(k=>B[k]=mkBus(k==='perc'?0.9:0.7));
  function hz(m){ return 440*Math.pow(2,(m-69)/12); }
  function ev(g,t0,a,d,s,hold,rel,vel){ const t1=t0+a,t2=t1+d,t3=t2+hold,t4=t3+rel; g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(vel,t1); g.gain.linearRampToValueAtTime(vel*s,t2); g.gain.setValueAtTime(vel*s,t3); g.gain.linearRampToValueAtTime(0,t4); return t4; }
  function osc(type,f){ const o=ctx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
  function add(inst,m,when,dur,vel){
    let end=when+dur+0.2;
    if(inst==='piano'){ const o=osc('triangle',hz(m)),g=ctx.createGain(); end=ev(g,when,0.005,0.18,0.35,Math.max(0.01,dur-0.2),0.25,vel*0.8); o.connect(g); g.connect(B.piano.g); o.start(when); o.stop(end); }
    else if(inst==='celesta'){ const o=osc('square',hz(m)),g=ctx.createGain(); end=ev(g,when,0.003,0.12,0.25,0.02,0.5,vel*0.7); o.connect(g); g.connect(B.celesta.g); o.start(when); o.stop(end); }
    else if(inst==='pad'){ const o1=osc('sawtooth',hz(m)*0.999),o2=osc('triangle',hz(m)*1.001),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2600; const g=ctx.createGain(); end=ev(g,when,0.4,1.8,0.7,Math.max(0.2,dur-1.2),1.5,vel*0.4); o1.connect(f);o2.connect(f);f.connect(g);g.connect(B.pad.g); o1.start(when);o2.start(when);o1.stop(end);o2.stop(end); }
    else if(inst==='strings'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2200; const g=ctx.createGain(); end=ev(g,when,0.08,0.5,0.8,Math.max(0.05,dur-0.4),0.3,vel*0.6); o.connect(f); f.connect(g); g.connect(B.strings.g); o.start(when); o.stop(end); }
    else if(inst==='choir'){ const o=osc('triangle',hz(m)),g=ctx.createGain(); end=ev(g,when,0.2,0.8,0.6,Math.max(0.15,dur-0.8),1.0,vel*0.55); o.connect(g); g.connect(B.choir.g); o.start(when); o.stop(end); }
    else if(inst==='brass'){ const o=osc('sawtooth',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800; const g=ctx.createGain(); end=ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.8); o.connect(f); f.connect(g); g.connect(B.brass.g); o.start(when); o.stop(end); }
    else if(inst==='woods'){ const o=osc('square',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400; const g=ctx.createGain(); end=ev(g,when,0.03,0.22,0.55,Math.max(0.05,dur-0.25),0.2,vel*0.6); o.connect(f); f.connect(g); g.connect(B.woods.g); o.start(when); o.stop(end); }
    else if(inst==='harp'){ const o=osc('triangle',hz(m)),g=ctx.createGain(); end=ev(g,when,0.002,0.22,0.35,0.01,0.4,vel*0.7); o.connect(g); g.connect(B.harp.g); o.start(when); o.stop(end); }
    else if(inst==='bells'){ const o=osc('sine',hz(m)),g=ctx.createGain(); end=ev(g,when,0.001,0.8,0.2,0.02,1.6,vel*0.7); o.connect(g); g.connect(B.bells.g); o.start(when); o.stop(end); }
    else if(inst==='glock'){ const o=osc('sine',hz(m)*2),g=ctx.createGain(); end=ev(g,when,0.001,0.4,0.25,0.02,0.8,vel*0.6); o.connect(g); g.connect(B.glock.g); o.start(when); o.stop(end); }
    else if(inst==='vibraphone'){ const o=osc('sine',hz(m)),g=ctx.createGain(); end=ev(g,when,0.002,0.5,0.5,0.1,0.9,vel*0.55); o.connect(g); g.connect(B.vibraphone.g); o.start(when); o.stop(end); }
    else if(inst==='marimba'){ const o=osc('triangle',hz(m)),g=ctx.createGain(); end=ev(g,when,0.002,0.35,0.35,0.02,0.6,vel*0.7); o.connect(g); g.connect(B.marimba.g); o.start(when); o.stop(end); }
    else if(inst==='tubular'){ const o=osc('sine',hz(m)/2),g=ctx.createGain(); end=ev(g,when,0.005,1.2,0.8,0.3,2.2,vel*0.7); o.connect(g); g.connect(B.tubular.g); o.start(when); o.stop(end); }
    else if(inst==='abass'){ const o=osc('triangle',hz(m)),g=ctx.createGain(); end=ev(g,when,0.01,0.3,0.5,Math.max(0.05,dur-0.25),0.25,vel*0.7); o.connect(g); g.connect(B.abass.g); o.start(when); o.stop(end); }
    else if(inst==='sbass'){ const o=osc('square',hz(m)),f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900; const g=ctx.createGain(); end=ev(g,when,0.02,0.25,0.6,Math.max(0.05,dur-0.3),0.25,vel*0.7); o.connect(f); f.connect(g); g.connect(B.sbass.g); o.start(when); o.stop(end); }
  }
  score.events.forEach(e=>add(e.inst,e.midi,e.time+0.05,e.dur,e.vel));
  // drums
  function noiseBuf(dur){ const b=ctx.createBuffer(1,ctx.sampleRate*dur,ctx.sampleRate); const ch=b.getChannelData(0); for(let i=0;i<ch.length;i++){ ch[i]=Math.random()*2-1; } return b; }
  score.drums.forEach(d=>{
    if(d.type==='kick'){ const o=osc('sine',130); o.frequency.setValueAtTime(130,d.time); o.frequency.exponentialRampToValueAtTime(40,d.time+0.12); const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.9,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.18); o.connect(g); g.connect(B.perc.g); o.start(d.time); o.stop(d.time+0.2); }
    if(d.type==='snare'){ const s=ctx.createBufferSource(); s.buffer=noiseBuf(0.2); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1800; const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.5,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.2); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+0.2); }
    if(d.type==='hat'){ const s=ctx.createBufferSource(); s.buffer=noiseBuf(0.08); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000; const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.25,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.08); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+0.08); }
    if(d.type==='tom'){ const o=osc('sine',180); o.frequency.exponentialRampToValueAtTime(120,d.time+0.12); const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.5,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+0.25); o.connect(g); g.connect(B.perc.g); o.start(d.time); o.stop(d.time+0.26); }
    if(d.type==='cym'){ const s=ctx.createBufferSource(); s.buffer=noiseBuf(1.5); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=4000; const g=ctx.createGain(); g.gain.setValueAtTime(d.vel*0.3,d.time); g.gain.exponentialRampToValueAtTime(0.0001,d.time+1.5); s.connect(f); f.connect(g); g.connect(B.perc.g); s.start(d.time); s.stop(d.time+1.5); }
  });

  const buf=await ctx.startRendering();
  // WAV encode
  function interleave(L,R){ const out=new Float32Array(L.length+R.length); for(let i=0,j=0;i<L.length;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; } return out; }
  function f32To16(view,off,data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); s=s<0?s*0x8000:s*0x7FFF; view.setInt16(off,s,true);} }
  function w(view,off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i,str.charCodeAt(i)); }
  const L=buf.getChannelData(0), R=buf.getChannelData(1), inter=interleave(L,R);
  const bytes=44+inter.length*2, ab=new ArrayBuffer(bytes), dv=new DataView(ab);
  w(dv,0,'RIFF'); dv.setUint32(4,36+inter.length*2,true); w(dv,8,'WAVE'); w(dv,12,'fmt '); dv.setUint32(16,16,true);
  dv.setUint16(20,1,true); dv.setUint16(22,2,true); dv.setUint32(24,sr,true); dv.setUint32(28,sr*4,true);
  dv.setUint16(32,4,true); dv.setUint16(34,16,true); w(dv,36,'data'); dv.setUint32(40,inter.length*2,true);
  f32To16(dv,44,inter);
  return new Blob([dv],{type:'audio/wav'});
}

/* ===== Glue / UI ===== */
const state={score:null, rnd:null, seedOut:''};
function updateVals(){ $('styleVal').textContent=$('style').value; $('polyVal').textContent=$('poly').value; $('humanVal').textContent=$('human').value; }
['style','poly','human'].forEach(id=>$(id).addEventListener('input',updateVals));
$('dice').addEventListener('click',()=>{ $('seed').value=(Math.random().toString(36).slice(2,8)+Math.random().toString(36).slice(2,8)).toUpperCase(); });

function makeRNG(){
  const s = $('seed').value.trim() || makeCSTSeed();
  state.seedOut=s; return rngFromSeed(hash32(s));
}

$('gen').addEventListener('click', ()=>{
  const rnd=makeRNG();
  const sc=compose({
    rnd, style:parseInt($('style').value,10)||50,
    poly:parseInt($('poly').value,10)||12
  });
  state.score=sc;
  $('seedOut').textContent=state.seedOut;
  $('bpmOut').textContent=Math.round(sc.bpm);
  $('lenOut').textContent=sc.seconds.toFixed(1)+' s (~3:00)';
  $('emoOut').textContent=sc.emotion;
  $('voicesOut').textContent=sc.pool.join(', ');
  $('evOut').textContent=sc.events.length + ' + ' + sc.drums.length + ' drums';
  $('keyOut').textContent=sc.key;
  const t=nowCSTParts(); $('cstOut').textContent=`${t.Y}-${t.M}-${t.D} ${t.h}:${t.m} CST`;
  drawTimeline(sc);
});

$('play').addEventListener('click', ()=>{
  if(!state.score) $('gen').click();
  if(playing) return;
  schedule(state.score, parseInt($('human').value,10)||12);
});
$('stop').addEventListener('click', ()=> stopAll());
$('export').addEventListener('click', async ()=>{
  if(!state.score) $('gen').click();
  $('expOut').textContent='rendering...';
  const blob=await renderWav(state.score);
  const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`CST_Astrodumus_${state.seedOut}_${state.score.emotion}.wav`; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),5000);
  $('expOut').textContent='WAV ready (downloaded)';
});

/* autogen on load */
window.addEventListener('load',()=>$('gen').click());
</script>
</body>
</html>
