<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST-Warp — Neutral Phase-Coherence Simulator (Manual Input)</title>
<meta name="description" content="Neutral, normalized visualization of harmonic curvature evolution and bubble stability with manual inputs. No internal calibration constants."/>
<style>
  :root{
    --bg:#050915; --panel:#0d142a; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#172047; --btn:#15235a;
    --ok:#10b981; --warn:#f59e0b; --accent:#6ee7ff; --line:#8fd6ff; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid #1f2c66;background:linear-gradient(180deg,#081022,#060b1a)}
  h1{margin:0;font-size:18px;letter-spacing:.3px}
  .sub{color:var(--muted);font-size:12px;margin-top:4px}
  .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;max-width:1400px;margin:14px auto;padding:0 12px}
  .panel{background:var(--panel);border:1px solid #233270;border-radius:14px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:#bcd3ff}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{background:var(--btn);color:var(--ink);border:1px solid #2a3f86;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{filter:brightness(1.08)}
  button:active{transform:translateY(1px)}
  .danger{background:#3a1620;border-color:#7e2438}
  .ok{background:#0d2a23;border-color:#1e7f65}
  .warn{background:#2e240c;border-color:#6a5417}
  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;padding:8px;border-radius:10px;border:1px solid #2a3f86;background:#0b1431;color:var(--ink);font-size:13px
  }
  textarea{min-height:140px;resize:vertical}
  .small{font-size:11px;color:var(--muted)}
  .flag{display:inline-block;padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;margin-left:6px;font-size:11px;color:#a7c1ff}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  canvas{display:block;width:100%;height:auto;border-radius:12px;border:1px solid #233270;background:radial-gradient(1200px 800px at 50% 50%, #0b1431 0%, #070e22 60%, #040915 100%)}
  .meter{height:12px;background:#0a142c;border:1px solid #1e3276;border-radius:999px;overflow:hidden}
  .meter > span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#4ade80,#22d3ee);transition:width .2s}
  .kv{display:flex;justify-content:space-between;font-size:12px;margin-top:6px}
  footer{padding:10px 14px;color:#9fb2e4;font-size:11px;text-align:center;opacity:.9}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
  .caps{letter-spacing:.08em;text-transform:uppercase}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{font-size:11px;padding:4px 8px;border:1px solid #2a3f86;border-radius:999px;color:#cfe1ff;background:#0c1531aa}
  .note{font-size:11px;color:#b9c9ff;line-height:1.4;margin-top:6px}
  .pass{color:#10b981}
  .fail{color:#ef9999}
  .soft{opacity:.85}
</style>
</head>
<body>
<header>
  <h1>CST-Warp — Neutral Phase-Coherence Simulator
    <span class="flag">Normalized / Dimensionless</span>
    <span class="flag">No Internal Calibration Constants</span>
  </h1>
  <div class="sub">Manual inputs for harmonic curvature & bubble stability. Coherence-based PASS/FAIL.</div>
</header>

<div class="wrap">
  <!-- Manual Inputs -->
  <section class="panel" id="controls">
    <h2>Manual Inputs</h2>

    <div class="row" style="margin-bottom:6px;">
      <button id="btnStart" class="ok">Start</button>
      <button id="btnStop">Stop</button>
      <button id="btnReset" class="warn">Reset</button>
      <button id="btnFrame">Capture Frame (PNG)</button>
    </div>

    <div class="row" style="margin-bottom:8px;">
      <button id="btnLoadPass" title="Load a preset that typically passes the stability band">Load Example — PASS</button>
      <button id="btnLoadFail" class="danger" title="Load a preset that typically fails">Load Example — FAIL</button>
      <button id="btnApply" class="ok" title="Apply all numeric inputs & seeds">Apply Inputs</button>
    </div>

    <label>Simulation Speed (dimensionless time scale, e.g., 1.0)
      <input id="speed" type="number" step="0.01" value="1.00" />
    </label>

    <label>Bubble Count (ignored if explicit seeds provided)
      <input id="bubbleCount" type="number" step="1" value="48" />
    </label>

    <label>Field Diffusion σ (px; Gaussian envelope width; try 60–90)
      <input id="sigma" type="number" step="1" value="72" />
    </label>

    <label>Resonance Threshold (normalized 0–1; typical 0.58–0.66)
      <input id="resThresh" type="number" step="0.01" value="0.62" />
    </label>

    <label>Sampling Resolution (heatmap engine grid; 100–260 good balance)
      <input id="gridRes" type="number" step="10" value="180" />
    </label>

    <label>Palette
      <select id="palette">
        <option value="ice">Ice (neutral)</option>
        <option value="magma">Magma</option>
        <option value="viridis">Viridis</option>
        <option value="firefly">Firefly</option>
      </select>
    </label>

    <div class="chips">
      <span class="chip"><input id="chkHeat" type="checkbox" checked> Heatmap Overlay</span>
      <span class="chip"><input id="chkContours" type="checkbox"> Curvature Contours</span>
      <span class="chip"><input id="chkTrails" type="checkbox" checked> Bubble Trails</span>
      <span class="chip"><input id="chkNormalize" type="checkbox" checked> Normalize Field</span>
      <span class="chip"><input id="chkStamp" type="checkbox" checked> Watermark / Legend</span>
    </div>

    <label style="margin-top:10px;">Stability Band (Coherence Fraction)
      <div class="row">
        <input id="stableMin" type="number" step="0.01" value="0.22" title="Lower bound for PASS" />
        <input id="stableMax" type="number" step="0.01" value="0.38" title="Upper bound for PASS" />
      </div>
      <div class="small soft">PASS if coherence fraction ∈ [min, max]. You can tune this for your neutral comparison protocol.</div>
    </label>

    <label style="margin-top:12px;">Bubble Seeds (optional; overrides Bubble Count)
      <textarea id="seedBox" placeholder="Enter JSON array or CSV-like rows:
x,y,r,f,phase,driftX,driftY,hue
200,180,80,0.032,0.0,0.25,-0.10,210
... OR ...
[{&quot;x&quot;:200,&quot;y&quot;:180,&quot;r&quot;:80,&quot;f&quot;:0.032,&quot;phase&quot;:0.0,&quot;driftX&quot;:0.25,&quot;driftY&quot;:-0.10,&quot;hue&quot;:210}, ...]"></textarea>
      <div class="small">Fields: x,y in px; r in px; f (base frequency, 0.02–0.06 typical); phase (rad); driftX, driftY (px/step, small); hue (0–360).</div>
    </label>

    <div class="note">
      Patent/Framework Notice: The CST-Warp model (harmonic field integration + curvature synchronization + frequency–energy coherence)
      is part of a patented combined theoretical framework. This neutral simulator shows dimensionless, proportional geometry only.
    </div>
  </section>

  <!-- Visualization -->
  <section class="panel">
    <h2>Visualization & Stability</h2>
    <div class="grid">
      <div>
        <canvas id="view" width="1100" height="680"></canvas>
      </div>
      <div>
        <div class="caps small" style="margin-bottom:6px;">Coherence Gauge (normalized)</div>
        <div class="meter"><span id="meterBar"></span></div>
        <div class="kv mono">
          <span>⟨avg⟩: <span id="avgVal">0.000</span></span>
          <span>peak: <span id="peakVal">0.000</span></span>
        </div>

        <div class="kv mono" style="margin-top:10px;">
          <span>coherence fraction ≥ thr: <span id="fracVal">0.000</span></span>
          <span>Status: <strong id="statusVal" class="fail">FAIL</strong></span>
        </div>

        <label style="margin-top:14px;">Legend</label>
        <ul class="small" style="line-height:1.5;margin-top:6px;color:#c7d8ff">
          <li>Colored rings = harmonic bubbles (dimensionless oscillators)</li>
          <li>Heatmap = normalized superposition field (Σ Gaussians × phase)</li>
          <li>Coherence fraction = fraction of field ≥ threshold</li>
          <li>PASS if fraction lies in the stability band</li>
        </ul>

        <label style="margin-top:10px;">Manual Input Examples</label>
        <div class="small mono" style="line-height:1.45">
          <div class="soft">CSV rows (recommended for quick edits):</div>
          x,y,r,f,phase,driftX,driftY,hue<br/>
          220,200,84,0.031,0.00,0.22,-0.10,210<br/>
          520,420,92,0.029,1.57,-0.18,0.14,260<br/>
          860,240,76,0.033,3.14,0.15,0.08,190
          <div class="soft" style="margin-top:6px;">JSON array (copy/paste from scripts):</div>
          [{ "x":220,"y":200,"r":84,"f":0.031,"phase":0,"driftX":0.22,"driftY":-0.10,"hue":210 }, ...]
        </div>

        <div class="note" style="margin-top:10px;">
          Tip: To increase coherence, cluster radii (r) near a common band (±10%) and keep base frequencies (f) narrowly distributed
          (e.g., 0.028–0.034), with small counter-drifts. Raise σ slightly (e.g., 70–85) and set threshold around 0.60–0.64.
        </div>
      </div>
    </div>
  </section>
</div>

<footer>
  © 2025 CST-Warp (Neutral Visualization). Proportional geometry only — no calibration constants disclosed.
</footer>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  // UI elements
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnFrame = document.getElementById('btnFrame');
  const btnApply = document.getElementById('btnApply');
  const btnLoadPass = document.getElementById('btnLoadPass');
  const btnLoadFail = document.getElementById('btnLoadFail');

  const speed = document.getElementById('speed');
  const bubbleCount = document.getElementById('bubbleCount');
  const sigma = document.getElementById('sigma');
  const resThresh = document.getElementById('resThresh');
  const gridRes = document.getElementById('gridRes');
  const paletteSel = document.getElementById('palette');

  const chkHeat = document.getElementById('chkHeat');
  const chkContours = document.getElementById('chkContours');
  const chkTrails = document.getElementById('chkTrails');
  const chkNormalize = document.getElementById('chkNormalize');
  const chkStamp = document.getElementById('chkStamp');

  const stableMin = document.getElementById('stableMin');
  const stableMax = document.getElementById('stableMax');

  const meterBar = document.getElementById('meterBar');
  const avgVal = document.getElementById('avgVal');
  const peakVal = document.getElementById('peakVal');
  const fracVal = document.getElementById('fracVal');
  const statusVal = document.getElementById('statusVal');

  const seedBox = document.getElementById('seedBox');

  // Offscreen buffer for heatmap
  let gridW = 180, gridH = 0;
  const gridCanvas = document.createElement('canvas');
  const gridCtx = gridCanvas.getContext('2d', { willReadFrequently: true });

  // Simulation state
  let t = 0, raf = null, running = false;
  let bubbles = [];

  // Color maps
  const palettes = {
    ice: v => `rgba(${(120+100*v)|0},${(170+80*v)|0},255,${Math.min(1,0.15+0.85*v)})`,
    magma: v => `rgba(${(30+225*v)|0},${(10+80*v)|0},${(30+50*v)|0},${Math.min(1,0.18+0.82*v)})`,
    viridis: v => `rgba(${(68+110*v)|0},${(1+190*v)|0},${(84+90*v)|0},${Math.min(1,0.18+0.82*v)})`,
    firefly: v => `rgba(${(120+100*v)|0},${(220+35*v)|0},${(60+180*v)|0},${Math.min(1,0.12+0.88*v)})`
  };

  function resizeGrid(){
    gridW = clampInt(parseInt(gridRes.value,10), 80, 400);
    gridH = Math.round(gridW * (canvas.height/canvas.width));
    gridCanvas.width = gridW;
    gridCanvas.height = gridH;
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function clampInt(v,min,max){ return Math.max(min, Math.min(max, v|0)); }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const g = ctx.createRadialGradient(canvas.width/2,canvas.height/2,10,canvas.width/2,canvas.height/2, Math.hypot(canvas.width,canvas.height)/1.2);
    g.addColorStop(0,'#0b1431');
    g.addColorStop(0.6,'#08122a');
    g.addColorStop(1,'#050915');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function step(dt){
    const spd = parseFloat(speed.value)||1;
    t += dt * spd;

    for(const b of bubbles){
      b.x += (b.driftX||0) * spd;
      b.y += (b.driftY||0) * spd;
      if(b.x < 0 || b.x > canvas.width) b.driftX = -(b.driftX||0);
      if(b.y < 0 || b.y > canvas.height) b.driftY = -(b.driftY||0);
    }
  }

  function drawBubbles(){
    const trails = chkTrails.checked;
    for(const b of bubbles){
      const pulse = Math.sin(t*(b.f||0.03) + (b.phase||0));
      const radius = (b.r||60) + pulse*10;
      ctx.beginPath();
      const hue = (b.hue==null? 200 : b.hue);
      ctx.strokeStyle = `hsla(${hue},100%,60%,${trails?0.5:0.9})`;
      ctx.lineWidth = 1.5 + (pulse+1)*1.0;
      ctx.arc(b.x||0, b.y||0, radius, 0, Math.PI*2);
      ctx.stroke();

      if(trails){
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${hue},100%,60%,0.18)`;
        ctx.lineWidth = 1;
        ctx.arc(b.x||0, b.y||0, radius*1.18, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  // Heatmap compute: sum of Gaussian contributions with phase modulation
  function drawHeatmap(){
    resizeGrid();
    const img = gridCtx.createImageData(gridW, gridH);
    const data = img.data;
    const s = clamp(parseFloat(sigma.value)||72, 4, 400);
    const s2 = 2*s*s;

    let maxField = 0, sumField = 0, overCount = 0;
    const thr = clamp(parseFloat(resThresh.value)||0.62, 0, 1);
    const normalize = chkNormalize.checked;

    // First pass: find peak (for normalization when enabled)
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - (b.x||0), dy = y - (b.y||0);
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);
          const ph = Math.sin(t*(b.f||0.03) + (b.phase||0));
          F += env * (0.5 + 0.5*ph);
        }
        if(F>maxField) maxField = F;
      }
    }

    // Second pass: render & metrics
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - (b.x||0), dy = y - (b.y||0);
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);
          const ph = Math.sin(t*(b.f||0.03) + (b.phase||0));
          F += env * (0.5 + 0.5*ph);
        }
        const val = normalize ? (maxField>0 ? F/maxField : 0) : F;
        sumField += val;
        if(val >= thr) overCount++;

        const c = Math.max(0, Math.min(1, val));
        const rgba = palettes[paletteSel.value](c);
        const m = rgba.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        const idx = (gy*gridW + gx)*4;
        data[idx]   = parseInt(m[1],10);
        data[idx+1] = parseInt(m[2],10);
        data[idx+2] = parseInt(m[3],10);
        data[idx+3] = Math.round(parseFloat(m[4]) * 255);
      }
    }
    gridCtx.putImageData(img,0,0);

    if(chkHeat.checked){
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(gridCanvas, 0, 0, canvas.width, canvas.height);
    }

    // Metrics and PASS/FAIL
    const avg = sumField / (gridW*gridH);
    const peak = normalize ? 1 : (maxField||0);
    const frac = overCount / (gridW*gridH);

    avgVal.textContent = avg.toFixed(3);
    peakVal.textContent = (normalize?1:peak).toFixed(3);
    fracVal.textContent = frac.toFixed(3);
    meterBar.style.width = (Math.min(1, avg)*100).toFixed(1) + '%';

    const minBand = Math.max(0, parseFloat(stableMin.value)||0.22);
    const maxBand = Math.min(1, parseFloat(stableMax.value)||0.38);
    const pass = (frac >= minBand && frac <= maxBand);
    statusVal.textContent = pass ? 'PASS' : 'FAIL';
    statusVal.className = pass ? 'pass' : 'fail';
  }

  function drawContours(){
    if(!chkContours.checked) return;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#6ee7ff';
    ctx.lineWidth = 0.75;
    const levels = 8;
    const s = clamp(parseFloat(sigma.value)||72, 4, 400);
    for(let i=0;i<levels;i++){
      const L = (i+1)/ (levels+1);
      for(const b of bubbles){
        const pulse = Math.sin(t*(b.f||0.03) + (b.phase||0));
        const base = (b.r||60) + pulse*10;
        const rr = base + L*s*0.9;
        ctx.beginPath();
        ctx.arc(b.x||0, b.y||0, rr, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function waterMark(){
    if(!chkStamp.checked) return;
    const pad = 10;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#a9c7ff';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
    ctx.fillText('CST-Warp Neutral Field Frame — Normalized / Dimensionless', pad, canvas.height - 22);
    ctx.fillStyle = '#86b2ff';
    ctx.fillText('Harmonic Curvature + Bubble Stability • Proportional resonance check • No calibration constants', pad, canvas.height - 8);
    ctx.restore();
  }

  function render(dt){
    clearCanvas();
    drawHeatmap();
    drawContours();
    drawBubbles();
    waterMark();
    step(dt);
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    render(dt);
    if(running) raf = requestAnimationFrame(loop);
  }

  // Capture
  function capturePNG(label='neutral_frame'){
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url;
    a.download = `${label}_${ts}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Seeds: parsing helpers
  function parseSeeds(text){
    if(!text || !text.trim()) return null;
    // Try JSON first
    try {
      const arr = JSON.parse(text);
      if(Array.isArray(arr)) return sanitizeSeeds(arr);
    } catch(e){}
    // Fallback: CSV-like lines
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
    // optional header?
    const hasHeader = /x\s*,\s*y\s*,\s*r\s*,\s*f/i.test(lines[0]||'');
    const start = hasHeader ? 1 : 0;
    const out = [];
    for(let i=start;i<lines.length;i++){
      const parts = lines[i].split(/\s*,\s*/);
      if(parts.length < 3) continue;
      const [x,y,r,f,phase,driftX,driftY,hue] = parts.map(v=>Number(v));
      out.push({ x:+x||0, y:+y||0, r:+r||60, f:(+f||0.03), phase:(+phase||0), driftX:(+driftX||0), driftY:(+driftY||0), hue:(isFinite(+hue)?+hue:200) });
    }
    return sanitizeSeeds(out);
  }

  function sanitizeSeeds(arr){
    const W = canvas.width, H = canvas.height;
    return arr.map(b=>({
      x: clamp(+b.x||0, 0, W),
      y: clamp(+b.y||0, 0, H),
      r: clamp(+b.r||60, 5, Math.max(W,H)),
      f: clamp(+b.f||0.03, 0.005, 0.2),
      phase: +b.phase||0,
      driftX: clamp(+b.driftX||0, -2, 2),
      driftY: clamp(+b.driftY||0, -2, 2),
      hue: clamp(+b.hue??200, 0, 360)
    }));
  }

  function createRandomBubbles(n){
    const arr = [];
    for(let i=0;i<n;i++){
      const f = 0.028 + Math.random()*0.008; // narrow band helps stability
      const phase = Math.random()*Math.PI*2;
      const r = 70 + (Math.random()*20-10);  // clustered radii
      const driftX = (Math.random()*2-1)*0.25;
      const driftY = (Math.random()*2-1)*0.25;
      arr.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r, phase, f,
        driftX, driftY,
        hue: 190 + Math.random()*120
      });
    }
    return arr;
  }

  function applyInputs(){
    const seeds = parseSeeds(seedBox.value);
    if(seeds && seeds.length){
      bubbles = seeds;
    } else {
      const n = clampInt(parseInt(bubbleCount.value,10)||48, 1, 400);
      bubbles = createRandomBubbles(n);
    }
    render(0.016);
  }

  // Presets
  function loadPass(){
    speed.value = '1.00';
    sigma.value = '78';
    resThresh.value = '0.62';
    gridRes.value = '180';
    paletteSel.value = 'ice';
    stableMin.value = '0.22';
    stableMax.value = '0.38';
    seedBox.value =
`x,y,r,f,phase,driftX,driftY,hue
220,200,84,0.031,0.00,0.22,-0.10,210
420,360,88,0.030,1.05,-0.18,0.14,230
680,290,82,0.032,2.10,0.16,0.12,205
860,240,80,0.029,3.14,0.12,0.10,190
300,480,86,0.030,4.00,-0.14,-0.12,260
540,180,78,0.031,2.45,0.10,-0.16,240
940,460,85,0.029,1.70,-0.10,0.10,215
120,520,83,0.032,0.60,0.12,0.08,255`;
    applyInputs();
  }

  function loadFail(){
    speed.value = '1.00';
    sigma.value = '40';           // too tight
    resThresh.value = '0.70';     // threshold too high
    gridRes.value = '180';
    paletteSel.value = 'magma';
    stableMin.value = '0.22';
    stableMax.value = '0.38';
    seedBox.value =
`x,y,r,f,phase,driftX,driftY,hue
150,150,40,0.020,0.00,0.60,0.60,10
400,500,160,0.090,0.50,-0.80,-0.40,30
900,300,20,0.150,1.50,1.20,-1.20,300`;
    applyInputs();
  }

  // Controls
  function start(){
    if(running) return;
    running = true;
    last = performance.now();
    raf = requestAnimationFrame(loop);
  }
  function stop(){
    running = false;
    if(raf){ cancelAnimationFrame(raf); raf = null; }
  }
  function reset(){
    stop();
    t = 0;
    applyInputs();
  }

  btnStart.addEventListener('click', start);
  btnStop.addEventListener('click', stop);
  btnReset.addEventListener('click', reset);
  btnFrame.addEventListener('click', ()=>capturePNG('neutral_frame'));
  btnApply.addEventListener('click', ()=>{ applyInputs(); });

  btnLoadPass.addEventListener('click', loadPass);
  btnLoadFail.addEventListener('click', loadFail);

  // Immediate visual updates on toggles / minor options
  [paletteSel, chkHeat, chkContours, chkTrails, chkNormalize, chkStamp].forEach(el=>{
    el.addEventListener('input', ()=>render(0.016));
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ e.preventDefault(); running ? stop() : start(); }
    if(e.key==='r'){ reset(); }
    if(e.key==='c'){ capturePNG('neutral_frame'); }
  });

  // Init
  function init(){
    resizeGrid();
    loadPass();        // start with a passing neutral example
    render(0.016);
  }
  init();
})();
</script>
</body>
</html>
