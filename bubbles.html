<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST-Warp — Neutral Phase-Coherence Simulator (Curvature + Harmonic Bubble Stability)</title>
<meta name="description" content="Neutral, normalized visualization of harmonic curvature evolution and bubble stability for proportional resonance comparison. No internal calibration constants."/>
<style>
  :root{
    --bg:#050915; --panel:#0d142a; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#172047; --btn:#15235a;
    --ok:#10b981; --warn:#f59e0b; --accent:#6ee7ff; --line:#8fd6ff; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid #1f2c66;background:linear-gradient(180deg,#081022,#060b1a)}
  h1{margin:0;font-size:18px;letter-spacing:.3px}
  .sub{color:var(--muted);font-size:12px;margin-top:4px}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:12px;max-width:1400px;margin:14px auto;padding:0 12px}
  .panel{background:var(--panel);border:1px solid #233270;border-radius:14px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:#bcd3ff}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{background:var(--btn);color:var(--ink);border:1px solid #2a3f86;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  button:active{transform:translateY(1px)}
  .danger{background:#3a1620;border-color:#7e2438}
  .ok{background:#0d2a23;border-color:#1e7f65}
  .warn{background:#2e240c;border-color:#6a5417}
  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="range"]{width:100%}
  .small{font-size:11px;color:var(--muted)}
  .flag{display:inline-block;padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;margin-left:6px;font-size:11px;color:#a7c1ff}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  canvas{display:block;width:100%;height:auto;border-radius:12px;border:1px solid #233270;background:radial-gradient(1200px 800px at 50% 50%, #0b1431 0%, #070e22 60%, #040915 100%)}
  .meter{height:12px;background:#0a142c;border:1px solid #1e3276;border-radius:999px;overflow:hidden}
  .meter > span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#4ade80,#22d3ee);transition:width .2s}
  .kv{display:flex;justify-content:space-between;font-size:12px;margin-top:6px}
  footer{padding:10px 14px;color:#9fb2e4;font-size:11px;text-align:center;opacity:.9}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
  .caps{letter-spacing:.08em;text-transform:uppercase}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{font-size:11px;padding:4px 8px;border:1px solid #2a3f86;border-radius:999px;color:#cfe1ff;background:#0c1531aa}
  .note{font-size:11px;color:#b9c9ff;line-height:1.4;margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>CST-Warp — Neutral Phase-Coherence Simulator
    <span class="flag">Normalized / Dimensionless</span>
    <span class="flag">No Internal Calibration Constants</span>
  </h1>
  <div class="sub">Visualize harmonic curvature evolution & bubble stability for proportional resonance comparison.</div>
</header>

<div class="wrap">
  <!-- Controls -->
  <section class="panel" id="controls">
    <h2>Controls</h2>
    <div class="row">
      <button id="btnStart" class="ok">Start</button>
      <button id="btnStop">Stop</button>
      <button id="btnReset" class="warn">Reset</button>
      <button id="btnFrame">Capture Frame (PNG)</button>
      <button id="btnAuto3">Auto-Capture 3 Frames</button>
    </div>

    <label>Simulation Speed
      <input id="speed" type="range" min="0.25" max="3" value="1" step="0.05">
      <div class="kv"><span class="small">0.25×</span><span class="small">1×</span><span class="small">3×</span></div>
    </label>

    <label>Bubble Count
      <input id="bubbleCount" type="range" min="8" max="120" value="48" step="1">
      <div class="kv"><span class="small">8</span><span class="small">120</span></div>
    </label>

    <label>Field Diffusion (σ)
      <input id="sigma" type="range" min="8" max="160" value="72" step="1">
      <div class="kv"><span class="small">tight</span><span class="small">broad</span></div>
    </label>

    <label>Resonance Threshold (normalized)
      <input id="resThresh" type="range" min="0.1" max="0.9" value="0.62" step="0.01">
      <div class="kv"><span class="small">sparse</span><span class="small">dense</span></div>
    </label>

    <div class="chips">
      <span class="chip"><input id="chkHeat" type="checkbox" checked> Heatmap Overlay</span>
      <span class="chip"><input id="chkContours" type="checkbox"> Curvature Contours</span>
      <span class="chip"><input id="chkTrails" type="checkbox" checked> Bubble Trails</span>
      <span class="chip"><input id="chkNormalize" type="checkbox" checked> Normalize Field</span>
      <span class="chip"><input id="chkStamp" type="checkbox" checked> Watermark / Legend</span>
    </div>

    <div class="note">
      Patent/Framework Notice: The CST-Warp model (harmonic field integration + curvature synchronization + frequency–energy coherence) is part of a patented combined theoretical framework. This neutral simulator shows dimensionless, proportional geometry only.
    </div>
  </section>

  <!-- Visualization -->
  <section class="panel">
    <h2>Visualization</h2>
    <div class="grid">
      <div>
        <canvas id="view" width="1100" height="680"></canvas>
      </div>
      <div>
        <div class="caps small" style="margin-bottom:6px;">Coherence Gauge (normalized)</div>
        <div class="meter"><span id="meterBar"></span></div>
        <div class="kv mono">
          <span>⟨resonance⟩: <span id="avgVal">0.000</span></span>
          <span>peak: <span id="peakVal">0.000</span></span>
        </div>

        <label style="margin-top:14px;">Sampling Resolution (heatmap engine)
          <input id="gridRes" type="range" min="80" max="320" value="180" step="10">
          <div class="kv"><span class="small">faster</span><span class="small">sharper</span></div>
        </label>

        <label>Palette
          <select id="palette">
            <option value="ice">Ice (neutral)</option>
            <option value="magma">Magma</option>
            <option value="viridis">Viridis</option>
            <option value="firefly">Firefly</option>
          </select>
        </label>

        <div class="note">
          Frames are suitable as “neutral geometry” images: capture at t₀, t₁, t₂ for proportional resonance checks.
        </div>

        <div class="caps small" style="margin-top:14px;">Legend</div>
        <ul class="small" style="line-height:1.5;margin-top:6px;color:#c7d8ff">
          <li>Colored rings = harmonic bubbles (dimensionless oscillators)</li>
          <li>Heatmap = normalized superposition field (Σ Gaussians × phase)</li>
          <li>Coherence gauge = average field above threshold</li>
          <li>No absolute units, only ratios and normalized magnitudes</li>
        </ul>
      </div>
    </div>
  </section>
</div>

<footer>
  © 2025 CST-Warp (Neutral Visualization). Proportional geometry only — no calibration constants disclosed.
</footer>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  // UI elements
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnFrame = document.getElementById('btnFrame');
  const btnAuto3 = document.getElementById('btnAuto3');

  const speed = document.getElementById('speed');
  const bubbleCount = document.getElementById('bubbleCount');
  const sigma = document.getElementById('sigma');
  const resThresh = document.getElementById('resThresh');
  const gridRes = document.getElementById('gridRes');
  const paletteSel = document.getElementById('palette');

  const chkHeat = document.getElementById('chkHeat');
  const chkContours = document.getElementById('chkContours');
  const chkTrails = document.getElementById('chkTrails');
  const chkNormalize = document.getElementById('chkNormalize');
  const chkStamp = document.getElementById('chkStamp');

  const meterBar = document.getElementById('meterBar');
  const avgVal = document.getElementById('avgVal');
  const peakVal = document.getElementById('peakVal');

  // Offscreen buffer for heatmap
  let gridW = 180, gridH = 0;
  const gridCanvas = document.createElement('canvas');
  const gridCtx = gridCanvas.getContext('2d', { willReadFrequently: true });

  // Simulation state
  let t = 0, raf = null, running = false;
  let bubbles = [];
  let seed = Math.random() * 1e9;

  function rand(){ // stable-ish PRNG for repeatability across resets
    // xorshift32
    let x = (seed |= 0) || 123456789;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    seed = x;
    return ((x >>> 0) / 4294967296);
  }

  function createBubbles(n){
    bubbles = [];
    for(let i=0;i<n;i++){
      const fx = 0.02 + rand()*0.05;      // base frequency (dimensionless)
      const phase = rand()*Math.PI*2;
      const r = 20 + rand()*110;          // base ring radius (px)
      const speedX = (rand()*2-1)*0.6;    // drift
      const speedY = (rand()*2-1)*0.6;
      bubbles.push({
        x: rand()*canvas.width,
        y: rand()*canvas.height,
        r, phase, f: fx,
        driftX: speedX, driftY: speedY,
        hue: 190 + rand()*120
      });
    }
  }

  // Color maps
  const palettes = {
    ice: v => {
      // v in [0,1]
      const r = 120 + 100*v;
      const g = 170 + 80*v;
      const b = 255;
      return `rgba(${r|0},${g|0},${b|0},${Math.min(1, 0.15 + 0.85*v)})`;
    },
    magma: v => {
      const r = 30 + 225*v;
      const g = 10 + 80*v;
      const b = 30 + 50*v;
      return `rgba(${r|0},${g|0},${b|0},${Math.min(1, 0.18 + 0.82*v)})`;
    },
    viridis: v => {
      const r = 68 + 110*v;
      const g = 1 + 190*v;
      const b = 84 + 90*v;
      return `rgba(${r|0},${g|0},${b|0},${Math.min(1, 0.18 + 0.82*v)})`;
    },
    firefly: v => {
      const r = 120 + 100*v;
      const g = 220 + 35*v;
      const b = 60 + 180*v;
      return `rgba(${r|0},${g|0},${b|0},${Math.min(1, 0.12 + 0.88*v)})`;
    }
  };

  function resizeGrid(){
    gridW = parseInt(gridRes.value,10);
    gridH = Math.round(gridW * (canvas.height/canvas.width));
    gridCanvas.width = gridW;
    gridCanvas.height = gridH;
  }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = ctx.createRadialGradient(canvas.width/2,canvas.height/2,10,canvas.width/2,canvas.height/2, Math.hypot(canvas.width,canvas.height)/1.2);
    ctx.fillStyle.addColorStop?.(0,'#0b1431');
    ctx.fillStyle.addColorStop?.(0.6,'#08122a');
    ctx.fillStyle.addColorStop?.(1,'#050915');
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function step(dt){
    const spd = parseFloat(speed.value);
    t += dt * spd;

    // move bubbles (slow drift) and bounce at edges
    for(const b of bubbles){
      b.x += b.driftX * spd;
      b.y += b.driftY * spd;
      if(b.x < 0 || b.x > canvas.width) b.driftX *= -1;
      if(b.y < 0 || b.y > canvas.height) b.driftY *= -1;
    }
  }

  function drawBubbles(){
    const trails = chkTrails.checked;
    for(const b of bubbles){
      const pulse = Math.sin(t*b.f + b.phase);
      const radius = b.r + pulse*10;
      ctx.beginPath();
      ctx.strokeStyle = `hsla(${b.hue},100%,60%,${trails?0.5:0.9})`;
      ctx.lineWidth = 1.5 + (pulse+1)*1.0;
      ctx.arc(b.x, b.y, radius, 0, Math.PI*2);
      ctx.stroke();

      if(trails){
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${b.hue},100%,60%,0.18)`;
        ctx.lineWidth = 1;
        ctx.arc(b.x, b.y, radius*1.18, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  // Heatmap compute: sum of Gaussian contributions with phase modulation
  function drawHeatmap(){
    resizeGrid();
    const img = gridCtx.createImageData(gridW, gridH);
    const data = img.data;
    const s = parseFloat(sigma.value);
    const s2 = 2*s*s;
    let maxField = 0, sumField = 0, overCount = 0;

    // Pre-read threshold and normalization choice
    const thr = parseFloat(resThresh.value);
    const normalize = chkNormalize.checked;

    // Compute field
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - b.x, dy = y - b.y;
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);          // Gaussian envelope
          const ph = Math.sin(t*b.f + b.phase);    // phase
          F += env * (0.5 + 0.5*ph);               // keep ≥ 0
        }
        maxField = Math.max(maxField, F);
      }
    }

    // second pass to render with optional normalization
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - b.x, dy = y - b.y;
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);
          const ph = Math.sin(t*b.f + b.phase);
          F += env * (0.5 + 0.5*ph);
        }
        const val = normalize ? (maxField>0 ? F/maxField : 0) : F;
        sumField += val;
        if(val >= thr) overCount++;

        const c = Math.max(0, Math.min(1, val));
        const rgba = palettes[paletteSel.value](c);
        // parse rgba to numbers:
        const m = rgba.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        const idx = (gy*gridW + gx)*4;
        data[idx]   = parseInt(m[1],10);
        data[idx+1] = parseInt(m[2],10);
        data[idx+2] = parseInt(m[3],10);
        data[idx+3] = Math.round(parseFloat(m[4]) * 255);
      }
    }
    gridCtx.putImageData(img,0,0);

    // blit scaled to main canvas
    if(chkHeat.checked){
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(gridCanvas, 0, 0, canvas.width, canvas.height);
    }

    // metrics
    const avg = sumField / (gridW*gridH);
    const peak = normalize ? 1 : (maxField||0);
    avgVal.textContent = avg.toFixed(3);
    peakVal.textContent = (normalize?1:peak).toFixed(normalize?3:3);
    meterBar.style.width = (Math.min(1, avg)*100).toFixed(1) + '%';
  }

  function drawContours(){
    if(!chkContours.checked) return;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#6ee7ff';
    ctx.lineWidth = 0.75;
    const levels = 8;
    const s = parseFloat(sigma.value);
    for(let i=0;i<levels;i++){
      const L = (i+1)/ (levels+1);
      // simple marching-like concentric rings from each bubble as a proxy contour
      for(const b of bubbles){
        const pulse = Math.sin(t*b.f + b.phase);
        const base = b.r + pulse*10;
        const rr = base + L*s*0.9;
        ctx.beginPath();
        ctx.arc(b.x, b.y, rr, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function waterMark(){
    if(!chkStamp.checked) return;
    const pad = 10;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#a9c7ff';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
    ctx.fillText('CST-Warp Neutral Field Frame — Normalized / Dimensionless', pad, canvas.height - 22);
    ctx.fillStyle = '#86b2ff';
    ctx.fillText('Harmonic Curvature + Bubble Stability • For proportional resonance comparison • No calibration constants', pad, canvas.height - 8);
    ctx.restore();
  }

  function render(dt){
    clearCanvas();
    drawHeatmap();
    drawContours();
    drawBubbles();
    waterMark();
    step(dt);
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000); // clamp large jumps
    last = now;
    render(dt);
    if(running) raf = requestAnimationFrame(loop);
  }

  // Capture utilities
  function capturePNG(label='frame'){
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url;
    a.download = `${label}_${ts}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  async function autoThree(){
    // capture t0, t1, t2 (Δt ≈ 1/3 of a normalized spin)
    const prev = running;
    if(!prev){ start(); await delay(200); }
    capturePNG('neutral_t0');
    await delay(600);
    capturePNG('neutral_t1');
    await delay(600);
    capturePNG('neutral_t2');
    if(!prev) stop();
  }
  const delay = (ms)=>new Promise(r=>setTimeout(r,ms));

  // Controls
  function start(){
    if(running) return;
    running = true;
    last = performance.now();
    raf = requestAnimationFrame(loop);
  }
  function stop(){
    running = false;
    if(raf){ cancelAnimationFrame(raf); raf = null; }
  }
  function reset(){
    stop();
    t = 0;
    seed = Math.random()*1e9;           // new seed -> new layout on each reset
    createBubbles(parseInt(bubbleCount.value,10));
    render(0.016);
  }

  // Wire events
  btnStart.addEventListener('click', start);
  btnStop.addEventListener('click', stop);
  btnReset.addEventListener('click', reset);
  btnFrame.addEventListener('click', ()=>capturePNG('neutral_frame'));
  btnAuto3.addEventListener('click', autoThree);

  bubbleCount.addEventListener('input', ()=>{ createBubbles(parseInt(bubbleCount.value,10)); });
  [sigma, resThresh, gridRes, paletteSel, chkHeat, chkContours, chkTrails, chkNormalize, chkStamp].forEach(el=>{
    el.addEventListener('input', ()=>render(0.016));
  });
  speed.addEventListener('input', ()=>{ /* live */ });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ e.preventDefault(); running ? stop() : start(); }
    if(e.key==='r'){ reset(); }
    if(e.key==='c'){ capturePNG('neutral_frame'); }
  });

  // Init
  function init(){
    resizeGrid();
    createBubbles(parseInt(bubbleCount.value,10));
    render(0.016);
  }
  init();

})();
</script>
</body>
</html>
