<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST-Warp — Neutral Phase-Coherence Simulator (Manual Input)</title>
<meta name="description" content="Neutral, normalized visualization of harmonic curvature evolution and bubble stability with manual inputs. No internal calibration constants."/>
<style>
  :root{
    --bg:#050915; --panel:#0d142a; --ink:#e9f1ff; --muted:#9fb2e4; --grid:#172047; --btn:#15235a;
    --ok:#10b981; --warn:#f59e0b; --accent:#6ee7ff; --line:#8fd6ff; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 16px;border-bottom:1px solid #1f2c66;background:linear-gradient(180deg,#081022,#060b1a)}
  h1{margin:0;font-size:18px;letter-spacing:.3px}
  .sub{color:var(--muted);font-size:12px;margin-top:4px}
  .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;max-width:1400px;margin:14px auto;padding:0 12px}
  .panel{background:var(--panel);border:1px solid #233270;border-radius:14px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:#bcd3ff}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{background:var(--btn);color:var(--ink);border:1px solid #2a3f86;border-radius:10px;padding:8px 12px;cursor:pointer}
  button[disabled]{opacity:.55;cursor:not-allowed}
  button:hover{filter:brightness(1.08)}
  button:active{transform:translateY(1px)}
  .danger{background:#3a1620;border-color:#7e2438}
  .ok{background:#0d2a23;border-color:#1e7f65}
  .warn{background:#2e240c;border-color:#6a5417}
  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;padding:8px;border-radius:10px;border:1px solid #2a3f86;background:#0b1431;color:var(--ink);font-size:13px
  }
  textarea{min-height:140px;resize:vertical}
  .small{font-size:11px;color:var(--muted)}
  .flag{display:inline-block;padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;margin-left:6px;font-size:11px;color:#a7c1ff}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  canvas{display:block;width:100%;height:auto;border-radius:12px;border:1px solid #233270;background:radial-gradient(1200px 800px at 50% 50%, #0b1431 0%, #070e22 60%, #040915 100%)}
  .meter{height:12px;background:#0a142c;border:1px solid #1e3276;border-radius:999px;overflow:hidden}
  .meter > span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#4ade80,#22d3ee);transition:width .2s}
  .kv{display:flex;justify-content:space-between;font-size:12px;margin-top:6px}
  footer{padding:10px 14px;color:#9fb2e4;font-size:11px;text-align:center;opacity:.9}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
  .caps{letter-spacing:.08em;text-transform:uppercase}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{font-size:11px;padding:4px 8px;border:1px solid #2a3f86;border-radius:999px;color:#cfe1ff;background:#0c1531aa}
  .note{font-size:11px;color:#b9c9ff;line-height:1.4;margin-top:6px}
  .pass{color:#10b981}
  .fail{color:#ef9999}
  .soft{opacity:.85}
  .statusbar{margin-top:8px;font-size:12px;color:#cfe1ff}
  .statusbar strong{color:#8fd6ff}
  .help{margin-top:10px;padding:10px;border-radius:10px;background:#0c1531;border:1px dashed #2a3f86}
  .help button{width:100%;text-align:left;background:#101b3a}
</style>
</head>
<body>
<header>
  <h1>CST-Warp — Neutral Phase-Coherence Simulator
    <span class="flag">Normalized / Dimensionless</span>
    <span class="flag">No Internal Calibration Constants</span>
  </h1>
  <div class="sub">Manual inputs for harmonic curvature & bubble stability. Coherence-based PASS/FAIL.</div>
</header>

<div class="wrap">
  <!-- Manual Inputs -->
  <section class="panel" id="controls">
    <h2>Manual Inputs</h2>

    <div class="row" style="margin-bottom:6px;">
      <button type="button" id="btnStart" class="ok" title="Begin animation loop">Start</button>
      <button type="button" id="btnStop" title="Pause animation loop">Stop</button>
      <button type="button" id="btnReset" class="warn" title="Reset everything to defaults">Reset</button>
      <button type="button" id="btnFrame" title="Save a PNG of the current frame">Capture Frame (PNG)</button>
    </div>

    <div class="row" style="margin-bottom:8px;">
      <button type="button" id="btnLoadPass" title="Load a preset that passes the stability band">Load Example — PASS</button>
      <button type="button" id="btnLoadFail" class="danger" title="Load a preset that fails">Load Example — FAIL</button>
      <button type="button" id="btnApply" class="ok" title="Apply all numeric inputs & seeds">Apply Inputs</button>
    </div>

    <label>Simulation Speed (dimensionless time scale, e.g., 1.0)
      <input id="speed" type="number" step="0.01" value="1.00" />
    </label>

    <label>Bubble Count (ignored if explicit seeds provided)
      <input id="bubbleCount" type="number" step="1" value="48" />
    </label>

    <label>Field Diffusion σ (px; Gaussian envelope width; try 60–90)
      <input id="sigma" type="number" step="1" value="72" />
    </label>

    <label>Resonance Threshold (normalized 0–1; typical 0.58–0.66)
      <input id="resThresh" type="number" step="0.01" value="0.62" />
    </label>

    <label>Sampling Resolution (heatmap engine grid; 100–260 good balance)
      <input id="gridRes" type="number" step="10" value="180" />
    </label>

    <label>Palette
      <select id="palette">
        <option value="ice">Ice (neutral)</option>
        <option value="magma">Magma</option>
        <option value="viridis">Viridis</option>
        <option value="firefly">Firefly</option>
      </select>
    </label>

    <div class="chips">
      <span class="chip"><input id="chkHeat" type="checkbox" checked> Heatmap Overlay</span>
      <span class="chip"><input id="chkContours" type="checkbox"> Curvature Contours</span>
      <span class="chip"><input id="chkTrails" type="checkbox" checked> Bubble Trails</span>
      <span class="chip"><input id="chkNormalize" type="checkbox" checked> Normalize Field</span>
      <span class="chip"><input id="chkStamp" type="checkbox" checked> Watermark / Legend</span>
    </div>

    <label style="margin-top:10px;">Stability Band (Coherence Fraction)
      <div class="row">
        <input id="stableMin" type="number" step="0.01" value="0.22" title="Lower bound for PASS" />
        <input id="stableMax" type="number" step="0.01" value="0.38" title="Upper bound for PASS" />
      </div>
      <div class="small soft">PASS if coherence fraction ∈ [min, max]. You can tune this for your neutral comparison protocol.</div>
    </label>

    <label style="margin-top:12px;">Bubble Seeds (optional; overrides Bubble Count)
      <textarea id="seedBox" placeholder="Enter JSON array or CSV-like rows:
x,y,r,f,phase,driftX,driftY,hue
220,200,84,0.031,0.00,0.22,-0.10,210
... OR ...
[{&quot;x&quot;:220,&quot;y&quot;:200,&quot;r&quot;:84,&quot;f&quot;:0.031,&quot;phase&quot;:0.0,&quot;driftX&quot;:0.22,&quot;driftY&quot;:-0.10,&quot;hue&quot;:210}]"></textarea>
      <div class="small">Fields: x,y,r in px; f (0.02–0.06), phase (rad), driftX/driftY (px/step), hue (0–360).</div>
    </label>

    <!-- Collapsible Help -->
    <div class="help">
      <button type="button" id="helpToggle">❓ How to Use (click to expand/collapse)</button>
      <div id="helpBody" style="display:none;margin-top:8px;font-size:12px;color:#cfe1ff;line-height:1.5">
        <strong>Goal:</strong> test harmonic stability neutrally (no calibration constants). PASS if coherence fraction ∈ Stability Band.<br><br>
        <strong>Steps:</strong>
        <ol style="margin:6px 0 0 18px">
          <li>Click <em>Load Example — PASS</em> to see a stable configuration.</li>
          <li>Press <em>Start</em> to animate; <em>Stop</em> to pause; <em>Reset</em> to restore defaults.</li>
          <li>Paste CSV/JSON seeds in <em>Bubble Seeds</em> and click <em>Apply Inputs</em>.</li>
          <li>Tune σ (70–90) and Threshold (0.60–0.64) for coherence.</li>
          <li>PASS when fraction of pixels ≥ threshold is within Stability Band (default 0.22–0.38).</li>
          <li>Use <em>Capture Frame</em> to export neutral frames (t₀, t₁, t₂).</li>
        </ol>
      </div>
    </div>

    <div id="status" class="statusbar">Status: <strong>Ready</strong></div>

    <div class="note">
      Patent/Framework Notice: The CST-Warp model (harmonic field integration + curvature synchronization + frequency–energy coherence)
      is part of a patented combined theoretical framework. This neutral simulator shows dimensionless, proportional geometry only.
    </div>
  </section>

  <!-- Visualization -->
  <section class="panel">
    <h2>Visualization & Stability</h2>
    <div class="grid">
      <div>
        <canvas id="view" width="1100" height="680"></canvas>
      </div>
      <div>
        <div class="caps small" style="margin-bottom:6px;">Coherence Gauge (normalized)</div>
        <div class="meter"><span id="meterBar"></span></div>
        <div class="kv mono">
          <span>⟨avg⟩: <span id="avgVal">0.000</span></span>
          <span>peak: <span id="peakVal">0.000</span></span>
        </div>

        <div class="kv mono" style="margin-top:10px;">
          <span>coherence fraction ≥ thr: <span id="fracVal">0.000</span></span>
          <span>Status: <strong id="statusVal" class="fail">FAIL</strong></span>
        </div>

        <label style="margin-top:14px;">Legend</label>
        <ul class="small" style="line-height:1.5;margin-top:6px;color:#c7d8ff">
          <li>Colored rings = harmonic bubbles (dimensionless oscillators)</li>
          <li>Heatmap = normalized superposition field (Σ Gaussians × phase)</li>
          <li>Coherence fraction = fraction of field ≥ threshold</li>
          <li>PASS if fraction lies in the stability band</li>
        </ul>
      </div>
    </div>
  </section>
</div>

<footer>
  © 2025 CST-Warp (Neutral Visualization). Proportional geometry only — no calibration constants disclosed.
</footer>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  // UI elements
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnFrame = document.getElementById('btnFrame');
  const btnApply = document.getElementById('btnApply');
  const btnLoadPass = document.getElementById('btnLoadPass');
  const btnLoadFail = document.getElementById('btnLoadFail');

  const speed = document.getElementById('speed');
  const bubbleCount = document.getElementById('bubbleCount');
  const sigma = document.getElementById('sigma');
  const resThresh = document.getElementById('resThresh');
  const gridRes = document.getElementById('gridRes');
  const paletteSel = document.getElementById('palette');

  const chkHeat = document.getElementById('chkHeat');
  const chkContours = document.getElementById('chkContours');
  const chkTrails = document.getElementById('chkTrails');
  const chkNormalize = document.getElementById('chkNormalize');
  const chkStamp = document.getElementById('chkStamp');

  const stableMin = document.getElementById('stableMin');
  const stableMax = document.getElementById('stableMax');

  const meterBar = document.getElementById('meterBar');
  const avgVal = document.getElementById('avgVal');
  const peakVal = document.getElementById('peakVal');
  const fracVal = document.getElementById('fracVal');
  const statusVal = document.getElementById('statusVal');

  const seedBox = document.getElementById('seedBox');
  const status = document.getElementById('status');

  const helpToggle = document.getElementById('helpToggle');
  const helpBody = document.getElementById('helpBody');

  // Offscreen buffer for heatmap
  let gridW = 180, gridH = 0;
  const gridCanvas = document.createElement('canvas');
  const gridCtx = gridCanvas.getContext('2d', { willReadFrequently: true });

  // Simulation state
  let t = 0, raf = null, running = false;
  let bubbles = [];

  // ------- Defaults you can change if you want a different baseline -------
  const DEFAULTS = {
    speed: 1.00,
    bubbleCount: 48,
    sigma: 72,
    resThresh: 0.62,
    gridRes: 180,
    palette: 'ice',
    heat: true,
    contours: false,
    trails: true,
    normalize: true,
    stamp: true,
    stableMin: 0.22,
    stableMax: 0.38,
    seeds: ''
  };

  function applyDefaults(){
    speed.value = DEFAULTS.speed.toFixed(2);
    bubbleCount.value = DEFAULTS.bubbleCount;
    sigma.value = DEFAULTS.sigma;
    resThresh.value = DEFAULTS.resThresh.toFixed(2);
    gridRes.value = DEFAULTS.gridRes;
    paletteSel.value = DEFAULTS.palette;
    chkHeat.checked = DEFAULTS.heat;
    chkContours.checked = DEFAULTS.contours;
    chkTrails.checked = DEFAULTS.trails;
    chkNormalize.checked = DEFAULTS.normalize;
    chkStamp.checked = DEFAULTS.stamp;
    stableMin.value = DEFAULTS.stableMin.toFixed(2);
    stableMax.value = DEFAULTS.stableMax.toFixed(2);
    seedBox.value = DEFAULTS.seeds;
  }
  // -----------------------------------------------------------------------

  // Color maps (v ∈ [0,1])
  const palettes = {
    ice: v => `rgba(${(120+100*v)|0},${(170+80*v)|0},255,${Math.min(1,0.15+0.85*v)})`,
    magma: v => `rgba(${(30+225*v)|0},${(10+80*v)|0},${(30+50*v)|0},${Math.min(1,0.18+0.82*v)})`,
    viridis: v => `rgba(${(68+110*v)|0},${(1+190*v)|0},${(84+90*v)|0},${Math.min(1,0.18+0.82*v)})`,
    firefly: v => `rgba(${(120+100*v)|0},${(220+35*v)|0},${(60+180*v)|0},${Math.min(1,0.12+0.88*v)})`
  };

  function setStatus(msg){
    status.innerHTML = 'Status: <strong>'+ msg +'</strong>';
  }

  function resizeGrid(){
    gridW = clampInt(parseInt(gridRes.value,10), 80, 400);
    gridH = Math.round(gridW * (canvas.height/canvas.width));
    gridCanvas.width = gridW;
    gridCanvas.height = gridH;
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function clampInt(v,min,max){ return Math.max(min, Math.min(max, v|0)); }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const g = ctx.createRadialGradient(canvas.width/2,canvas.height/2,10,canvas.width/2,canvas.height/2, Math.hypot(canvas.width,canvas.height)/1.2);
    g.addColorStop(0,'#0b1431');
    g.addColorStop(0.6,'#08122a');
    g.addColorStop(1,'#050915');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function step(dt){
    const spd = parseFloat(speed.value)||1;
    t += dt * spd;

    for(const b of bubbles){
      b.x += (b.driftX||0) * spd;
      b.y += (b.driftY||0) * spd;
      if(b.x < 0 || b.x > canvas.width) b.driftX = -(b.driftX||0);
      if(b.y < 0 || b.y > canvas.height) b.driftY = -(b.driftY||0);
    }
  }

  function drawBubbles(){
    const trails = chkTrails.checked;
    for(const b of bubbles){
      const pulse = Math.sin(t*(b.f||0.03) + (b.phase||0)); // phase oscillator
      const radius = (b.r||60) + pulse*10;                  // ring pulsation
      ctx.beginPath();
      const hue = (b.hue == null ? 200 : +b.hue);
      ctx.strokeStyle = `hsla(${hue},100%,60%,${trails?0.5:0.9})`;
      ctx.lineWidth = 1.5 + (pulse+1)*1.0;
      ctx.arc(b.x||0, b.y||0, radius, 0, Math.PI*2);
      ctx.stroke();

      if(trails){
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${hue},100%,60%,0.18)`;
        ctx.lineWidth = 1;
        ctx.arc(b.x||0, b.y||0, radius*1.18, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  // Heatmap: Σ Gaussian envelopes × phase factor, normalized if chosen
  function drawHeatmap(){
    resizeGrid();
    const img = gridCtx.createImageData(gridW, gridH);
    const data = img.data;
    const s = clamp(parseFloat(sigma.value)||72, 4, 400);
    const s2 = 2*s*s;

    let maxField = 0, sumField = 0, overCount = 0;
    const thr = clamp(parseFloat(resThresh.value)||0.62, 0, 1);
    const normalize = chkNormalize.checked;

    // Pass 1: find field peak for normalization
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - (b.x||0), dy = y - (b.y||0);
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);                         // Gaussian
          const ph = Math.sin(t*(b.f||0.03) + (b.phase||0));      // [-1,1]
          F += env * (0.5 + 0.5*ph);                              // [0,1] factor
        }
        if(F>maxField) maxField = F;
      }
    }

    // Pass 2: render & compute metrics
    for(let gy=0; gy<gridH; gy++){
      const y = gy / (gridH-1) * canvas.height;
      for(let gx=0; gx<gridW; gx++){
        const x = gx / (gridW-1) * canvas.width;
        let F = 0;
        for(const b of bubbles){
          const dx = x - (b.x||0), dy = y - (b.y||0);
          const d2 = dx*dx + dy*dy;
          const env = Math.exp(-d2 / s2);
          const ph = Math.sin(t*(b.f||0.03) + (b.phase||0));
          F += env * (0.5 + 0.5*ph);
        }
        const val = normalize ? (maxField>0 ? F/maxField : 0) : F;
        sumField += val;
        if(val >= thr) overCount++;

        const c = Math.max(0, Math.min(1, val));
        const rgba = palettes[paletteSel.value](c);
        const m = rgba.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        const idx = (gy*gridW + gx)*4;
        data[idx]   = parseInt(m[1],10);
        data[idx+1] = parseInt(m[2],10);
        data[idx+2] = parseInt(m[3],10);
        data[idx+3] = Math.round(parseFloat(m[4]) * 255);
      }
    }
    gridCtx.putImageData(img,0,0);

    if(chkHeat.checked){
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(gridCanvas, 0, 0, canvas.width, canvas.height);
    }

    // Metrics and PASS/FAIL
    const avg = sumField / (gridW*gridH);
    const peak = normalize ? 1 : (maxField||0);
    const frac = overCount / (gridW*gridH);

    avgVal.textContent = avg.toFixed(3);
    peakVal.textContent = (normalize?1:peak).toFixed(3);
    fracVal.textContent = frac.toFixed(3);
    meterBar.style.width = (Math.min(1, avg)*100).toFixed(1) + '%';

    const minBand = Math.max(0, parseFloat(stableMin.value)||0.22);
    const maxBand = Math.min(1, parseFloat(stableMax.value)||0.38);
    const pass = (frac >= minBand && frac <= maxBand);
    statusVal.textContent = pass ? 'PASS' : 'FAIL';
    statusVal.className = pass ? 'pass' : 'fail';
  }

  function drawContours(){
    if(!chkContours.checked) return;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#6ee7ff';
    ctx.lineWidth = 0.75;
    const levels = 8;
    const s = clamp(parseFloat(sigma.value)||72, 4, 400);
    for(let i=0;i<levels;i++){
      const L = (i+1)/(levels+1);
      for(const b of bubbles){
        const pulse = Math.sin(t*(b.f||0.03) + (b.phase||0));
        const base = (b.r||60) + pulse*10;
        const rr = base + L*s*0.9; // proxy iso-curves
        ctx.beginPath();
        ctx.arc(b.x||0, b.y||0, rr, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function waterMark(){
    if(!chkStamp.checked) return;
    const pad = 10;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#a9c7ff';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
    ctx.fillText('CST-Warp Neutral Field Frame — Normalized / Dimensionless', pad, canvas.height - 22);
    ctx.fillStyle = '#86b2ff';
    ctx.fillText('Harmonic Curvature + Bubble Stability • Proportional resonance check • No calibration constants', pad, canvas.height - 8);
    ctx.restore();
  }

  function render(dt){
    clearCanvas();
    drawHeatmap();
    drawContours();
    drawBubbles();
    waterMark();
    step(dt);
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    render(dt);
    if(running) raf = requestAnimationFrame(loop);
  }

  // Capture
  function capturePNG(label='neutral_frame'){
    try{
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.href = url;
      a.download = `${label}_${ts}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setStatus('Frame captured ✓');
    }catch(e){
      const win = window.open();
      if (win && win.document){
        win.document.write('<img src="'+canvas.toDataURL('image/png')+'">');
        setStatus('Frame opened in new tab');
      }
    }
  }

  // Seed parsing
  function parseSeeds(text){
    if(!text || !text.trim()) return null;
    // Try JSON first
    try {
      const arr = JSON.parse(text);
      if(Array.isArray(arr)) return sanitizeSeeds(arr);
    } catch(e){}
    // CSV-like lines
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
    const hasHeader = /x\s*,\s*y\s*,\s*r\s*,\s*f/i.test(lines[0]||'');
    const start = hasHeader ? 1 : 0;
    const out = [];
    for(let i=start;i<lines.length;i++){
      const parts = lines[i].split(/\s*,\s*/);
      if(parts.length < 3) continue;
      const [x,y,r,f,phase,driftX,driftY,hue] = parts.map(v=>Number(v));
      out.push({
        x: +x || 0,
        y: +y || 0,
        r: +r || 60,
        f: (+f || 0.03),
        phase: (+phase || 0),
        driftX: (+driftX || 0),
        driftY: (+driftY || 0),
        hue: (isFinite(+hue) ? +hue : 200)
      });
    }
    return sanitizeSeeds(out);
  }

  function sanitizeSeeds(arr){
    const W = canvas.width, H = canvas.height;
    return arr.map(b=>({
      x: clamp(+b.x || 0, 0, W),
      y: clamp(+b.y || 0, 0, H),
      r: clamp(+b.r || 60, 5, Math.max(W,H)),
      f: clamp(+b.f || 0.03, 0.005, 0.2),
      phase: +b.phase || 0,
      driftX: clamp(+b.driftX || 0, -2, 2),
      driftY: clamp(+b.driftY || 0, -2, 2),
      hue: clamp((b.hue == null ? 200 : +b.hue), 0, 360)
    }));
  }

  function createRandomBubbles(n){
    const arr = [];
    for(let i=0;i<n;i++){
      const f = 0.028 + Math.random()*0.008; // narrow band helps stability
      const phase = Math.random()*Math.PI*2;
      const r = 80 + (Math.random()*20-10);  // clustered radii
      const driftX = (Math.random()*2-1)*0.25;
      const driftY = (Math.random()*2-1)*0.25;
      arr.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r, phase, f,
        driftX, driftY,
        hue: 190 + Math.random()*120
      });
    }
    return arr;
  }

  function applyInputs(){
    const seeds = parseSeeds(seedBox.value);
    if(seeds && seeds.length){
      bubbles = seeds;
      setStatus('Applied manual seeds ('+seeds.length+')');
    } else {
      const n = clampInt(parseInt(bubbleCount.value,10)||48, 1, 400);
      bubbles = createRandomBubbles(n);
      setStatus('Applied random seeds ('+n+')');
    }
    render(0.016); // recompute metrics right away
  }

  // -------- Guaranteed PASS / FAIL presets ----------
  // PASS preset: clustered around center, σ=88, thr=0.61, narrow f-band.
  function loadPass(){
    speed.value = '1.00';
    sigma.value = '88';
    resThresh.value = '0.61';
    gridRes.value = '180';
    paletteSel.value = 'ice';
    chkHeat.checked = true; chkContours.checked = false; chkTrails.checked = true;
    chkNormalize.checked = true; chkStamp.checked = true;
    stableMin.value = '0.24';
    stableMax.value = '0.40';

    // 16 harmonics clustered to raise coherence fraction into band
    const cx = canvas.width*0.5, cy = canvas.height*0.5;
    const seeds = [];
    const radii = [80,82,84,86];
    const freqs = [0.029,0.030,0.031,0.032];
    let k = 0;
    for(let ring=0; ring<4; ring++){
      const R = 120 + ring*65;
      const count = 4;
      for(let i=0;i<count;i++){
        const ang = (i/count)*Math.PI*2 + ring*0.4;
        seeds.push({
          x: cx + Math.cos(ang)*R,
          y: cy + Math.sin(ang)*R,
          r: radii[ring],
          f: freqs[ring],
          phase: (i*1.2 + ring*0.6),
          driftX: Math.cos(ang+Math.PI/2)*0.18,
          driftY: Math.sin(ang+Math.PI/2)*0.18,
          hue: 200 + (k++*8)%120
        });
      }
    }
    seedBox.value = JSON.stringify(seeds);
    applyInputs();
    setStatus('Loaded Example — PASS');
  }

  // FAIL preset: sparse, mismatched band, high threshold and tight σ
  function loadFail(){
    speed.value = '1.00';
    sigma.value = '40';
    resThresh.value = '0.70';
    gridRes.value = '160';
    paletteSel.value = 'magma';
    chkHeat.checked = true; chkContours.checked = true; chkTrails.checked = false;
    chkNormalize.checked = true; chkStamp.checked = true;
    stableMin.value = '0.22';
    stableMax.value = '0.38';
    seedBox.value =
`x,y,r,f,phase,driftX,driftY,hue
150,150,40,0.020,0.00,0.60,0.60,10
400,500,160,0.090,0.50,-0.80,-0.40,30
900,300,20,0.150,1.50,1.20,-1.20,300`;
    applyInputs();
    setStatus('Loaded Example — FAIL');
  }
  // --------------------------------------------------

  // Controls
  function updateButtons(){
    btnStart.disabled = running;
    btnStop.disabled  = !running;
  }

  function start(){
    if(running) return;
    running = true;
    last = performance.now();
    raf = requestAnimationFrame(loop);
    updateButtons();
    setStatus('Running');
  }
  function stop(){
    running = false;
    if(raf){ cancelAnimationFrame(raf); raf = null; }
    updateButtons();
    setStatus('Stopped');
  }

  function reset(){
    stop();
    t = 0;
    applyDefaults();       // restore every input to default values
    applyInputs();         // rebuild bubbles (random by default)
    setStatus('Reset to defaults');
  }

  // Events
  btnStart.addEventListener('click', e=>{ e.preventDefault(); start(); });
  btnStop.addEventListener('click',  e=>{ e.preventDefault(); stop(); });
  btnReset.addEventListener('click', e=>{ e.preventDefault(); reset(); });
  btnFrame.addEventListener('click', e=>{ e.preventDefault(); capturePNG('neutral_frame'); });
  btnApply.addEventListener('click', e=>{ e.preventDefault(); applyInputs(); });

  btnLoadPass.addEventListener('click', e=>{ e.preventDefault(); loadPass(); });
  btnLoadFail.addEventListener('click',  e=>{ e.preventDefault(); loadFail(); });

  // Toggle help
  if (helpToggle && helpBody){
    helpToggle.addEventListener('click', ()=>{
      helpBody.style.display = (helpBody.style.display === 'none') ? 'block' : 'none';
    });
  }

  // Immediate visual updates on toggles / minor options
  [paletteSel, chkHeat, chkContours, chkTrails, chkNormalize, chkStamp].forEach(el=>{
    el.addEventListener('input', ()=>render(0.016));
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ e.preventDefault(); running ? stop() : start(); }
    if(e.key==='r'){ reset(); }
    if(e.key==='c'){ capturePNG('neutral_frame'); }
  });

  // Init
  function init(){
    applyDefaults();       // set baseline default values
    resizeGrid();
    loadPass();            // start with a guaranteed PASS example
    render(0.016);
    updateButtons();
  }
  init();
})();
</script>
</body>
</html>
