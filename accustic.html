<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FOBAS + AEWFC — Warp Field Breach Arrest (CST-Synced)</title>
<style>
  :root{
    --bg:#070a12; --panel:#0d1322; --ink:#e8eefc; --muted:#a7b4d1; --accent:#6ee7ff;
    --ok:#3ae89a; --warn:#ffd166; --bad:#ff6b8b; --ring:#7ad3ff; --em:#7effc4; --photon:#ffd1a3; --ion:#a3b2ff;
    --border:#1e2a45;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:radial-gradient(1400px 900px at 70% 10%,#0b1220 0%,#070a12 60%,#060910 100%);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:14px 18px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0b1220,#0a111d)}
  h1{margin:0;font-weight:700;font-size:20px;letter-spacing:.3px}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;padding:14px;align-items:start}
  .card{background:linear-gradient(180deg,#0c1424,#0b1320);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .panel{padding:14px}
  .row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;margin:8px 0}
  .row label{font-size:13px;color:var(--muted)}
  .row input[type="range"]{width:190px}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  button{background:#101a2c;border:1px solid var(--border);color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer}
  button:hover{border-color:#2c3e66}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .pill{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:#0c1424;color:var(--muted)}
  .readouts{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
  .metric{background:#0c1424;border:1px solid var(--border);border-radius:10px;padding:10px}
  .metric .k{font-size:11px;color:var(--muted)}
  .metric .v{font-size:18px;font-weight:700;margin-top:2px}
  .status{font-weight:700}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .small{font-size:12px;color:var(--muted)}
  .ex{line-height:1.55}
  a{color:var(--accent);text-decoration:none}
  footer{padding:10px 14px;color:var(--muted);font-size:12px}

  /* Callout labels */
  .overlay{position:absolute;pointer-events:none}
  .call{position:absolute;padding:6px 8px;border-radius:8px;background:#0e1630d0;border:1px solid #22345c;font-size:12px}
  .blink{animation:blink 1s linear infinite}
  @keyframes blink{0%{opacity:.65}50%{opacity:1}100%{opacity:.65}}

  /* Tiny wave indicators in labels */
  .wavebar{display:inline-block;width:54px;height:8px;vertical-align:middle;border-radius:6px;background:linear-gradient(90deg,#2a3d61,#3c558a)}
  .wavebar::after{content:"";display:block;height:100%;border-radius:6px;background:rgba(110,231,255,.9);width:20%;animation:wb 1.2s linear infinite}
  @keyframes wb{0%{margin-left:0}100%{margin-left:80%}}

  /* Gauges */
  .gauge{position:relative;height:10px;background:#0f1a33;border:1px solid #23335a;border-radius:8px;overflow:hidden}
  .gauge>span{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(90deg,#65ffc7,#6ee7ff);width:0%}
</style>
</head>
<body>
<header>
  <h1>FOBAS + AEWFC — CST-Synced Warp Field Breach Arrest Demonstration</h1>
</header>

<div class="wrap">
  <!-- Controls & HUD -->
  <div class="card panel">
    <div class="row"><label>Warp Factor</label><input id="warp" type="range" min="0" max="10" step="0.1" value="5"></div>
    <div class="row"><label>EM Field Strength</label><input id="em" type="range" min="0" max="1" step="0.01" value="0.70"></div>
    <div class="row"><label>Noise (HF) Amplitude</label><input id="amp" type="range" min="0" max="1" step="0.01" value="0.70"></div>
    <div class="row"><label>Noise Frequency</label><input id="freq" type="range" min="0.05" max="3.0" step="0.01" value="1.0"></div>
    <div class="row"><label>Plasma Makeup Rate</label><input id="plasma" type="range" min="0" max="1" step="0.01" value="0.60"></div>
    <div class="row"><label>CST Phase Sync (%)</label><input id="cst" type="range" min="0" max="100" step="1" value="85"></div>
    <div class="row"><label>Particle Flux</label><input id="flux" type="range" min="0" max="1" step="0.01" value="0.55"></div>

    <div class="btnrow">
      <button id="start">Start</button>
      <button id="stop">Stop</button>
      <button id="reset">Reset</button>
      <button id="demo">DEMO (5 min)</button>
      <button id="breachL">Breach ⟵ Port</button>
      <button id="breachR">Breach ⟶ Starboard</button>
      <button id="breachN">Breach ⬆ Fore</button>
      <button id="breachS">Breach ⬇ Aft</button>
      <button id="heal">Seal Patch</button>
    </div>

    <div class="legend">
      <span class="pill">EM Bubble</span>
      <span class="pill">Noise (HF) Rings</span>
      <span class="pill">Plasma Window at Breach</span>
      <span class="pill">Photons/Ions</span>
    </div>

    <div class="readouts">
      <div class="metric">
        <div class="k">Shield Power</div>
        <div class="gauge"><span id="gPower"></span></div>
        <div class="v" id="powerV">0%</div>
      </div>
      <div class="metric">
        <div class="k">Compression (ΔP Hold)</div>
        <div class="gauge"><span id="gComp"></span></div>
        <div class="v" id="compV">0%</div>
      </div>
      <div class="metric">
        <div class="k">Leak Mass Flow</div>
        <div class="gauge"><span id="gLeak"></span></div>
        <div class="v" id="leakV">0.00 kg/s</div>
      </div>
      <div class="metric">
        <div class="k">Status</div>
        <div class="v status" id="status">Idle</div>
      </div>
    </div>

    <div class="ex" style="margin-top:10px">
      <strong>What this shows</strong>: The ship projects an <em>EM warp bubble</em> (green shell). 
      <em>Noise</em> (HF acoustic-like modes in plasma) appears as blue rings whose blink rate increases with amplitude/frequency. 
      <em>Plasma Window</em> sheets across any breach to hold pressure. 
      When a breach occurs, the controller <em>vectors</em> the EM pressure and raises noise + plasma on that side, reducing leak mass flow and keeping ΔP until a patch is installed.
      CST phase-sync locks timing so the composite field remains stiff while under warp.
    </div>
    <div class="small" style="margin-top:8px">Credit: <strong>Gabino Casanova</strong> — Interstellar Star Clock • AEWFC + FOBAS (CST-Synced).</div>
  </div>

  <!-- Scene -->
  <div class="card" style="position:relative;overflow:hidden">
    <canvas id="scene" width="1280" height="720" aria-label="FOBAS/AEWFC Simulation"></canvas>

    <!-- Overlay labels with tiny wave bars that speed up with power -->
    <div class="overlay" id="overlay">
      <div class="call" id="labEM" style="left:40px;top:28px">EM Bubble <span class="wavebar" id="wbEM"></span></div>
      <div class="call" id="labNoise" style="left:210px;top:28px">Noise (HF) <span class="wavebar" id="wbNoise"></span></div>
      <div class="call" id="labPlasma" style="left:360px;top:28px">Plasma Makeup <span class="wavebar" id="wbPlasma"></span></div>
      <div class="call" id="labPhotons" style="left:540px;top:28px">Photon/Ion Flow <span class="wavebar" id="wbPhot"></span></div>
      <div class="call" id="labCST" style="left:740px;top:28px">CST Sync <span class="wavebar" id="wbCST"></span></div>
      <div class="call" id="labBreach" style="right:20px;top:28px">Breach Control <span class="wavebar" id="wbBreach"></span></div>
    </div>
  </div>
</div>

<footer>
  DEMO timeline: 0–60s ramp up • 60–150s cruise • 150s breach event • auto-vector/boost • 300s patch seals and ramp-down.
  The “sound” here represents driven oscillatory modes in a magnetized plasma/field shell, phase-locked by CST.
</footer>

<script>
/* ==============================================
   FOBAS + AEWFC Demo
   - Central ship and EM bubble
   - Noise rings (blink faster with amp/freq)
   - Photons/Ions particles
   - Breach + Plasma Window with vector steering
   - 5-minute demo timeline
   ============================================== */
const cv = document.getElementById('scene');
const ctx = cv.getContext('2d');

const ui = {
  warp:  document.getElementById('warp'),
  em:    document.getElementById('em'),
  amp:   document.getElementById('amp'),
  freq:  document.getElementById('freq'),
  plasma:document.getElementById('plasma'),
  cst:   document.getElementById('cst'),
  flux:  document.getElementById('flux'),
  start: document.getElementById('start'),
  stop:  document.getElementById('stop'),
  reset: document.getElementById('reset'),
  demo:  document.getElementById('demo'),
  breachL:document.getElementById('breachL'),
  breachR:document.getElementById('breachR'),
  breachN:document.getElementById('breachN'),
  breachS:document.getElementById('breachS'),
  heal:  document.getElementById('heal'),
  gPower:document.getElementById('gPower'),
  gComp: document.getElementById('gComp'),
  gLeak: document.getElementById('gLeak'),
  powerV:document.getElementById('powerV'),
  compV: document.getElementById('compV'),
  leakV: document.getElementById('leakV'),
  status:document.getElementById('status'),
  wbEM:  document.getElementById('wbEM'),
  wbNoise:document.getElementById('wbNoise'),
  wbPlasma:document.getElementById('wbPlasma'),
  wbPhot:document.getElementById('wbPhot'),
  wbCST: document.getElementById('wbCST'),
  wbBreach:document.getElementById('wbBreach'),
};

let running = false;
let t = 0;              // ms
let demoMode = false;
let demoStart = 0;
const DEMO_MS = 5*60*1000; // 5 minutes

// Ship
const ship = { x: cv.width/2, y: cv.height/2, r: 16 };

// Particles (photons/ions)
let particles = [];
function spawnParticles(){
  const flux = parseFloat(ui.flux.value);
  const n = 2 + Math.floor(flux * 12);
  for(let i=0;i<n;i++){
    const side = Math.floor(Math.random()*4);
    let x,y,vx,vy;
    const sp = 0.6 + Math.random()*1.2 + parseFloat(ui.warp.value)/7;
    if(side===0){ x=Math.random()*cv.width; y=-12; }
    else if(side===1){ x=cv.width+12; y=Math.random()*cv.height; }
    else if(side===2){ x=Math.random()*cv.width; y=cv.height+12; }
    else { x=-12; y=Math.random()*cv.height; }
    const dx = ship.x-x, dy = ship.y-y, mag = Math.hypot(dx,dy)||1;
    vx = dx/mag * sp; vy = dy/mag * sp;
    const type = Math.random()<0.5?'photon':'ion';
    particles.push({x,y,vx,vy,life: 8+Math.random()*14, type});
  }
}

// Breach model
let breach = { active:false, nx:0, ny:0, side:"", plasmaLevel:0, leak:0 };

// Helpers
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a+(b-a)*t; }

function harmonicMatch(){
  const warp = parseFloat(ui.warp.value);
  const freq = parseFloat(ui.freq.value);
  const target = (warp*0.35)+0.25;
  const diff = Math.abs(freq-target);
  return clamp(1 - diff/1.4, 0, 1);
}

function stability(){
  const em  = parseFloat(ui.em.value);
  const amp = parseFloat(ui.amp.value);
  const cst = parseFloat(ui.cst.value)/100;
  const hm  = harmonicMatch();
  const s = Math.pow(0.6*em + 0.4*amp, 1.2) * (0.55+0.45*cst) * (0.5+0.5*hm);
  return clamp(s,0,1);
}

function shieldPower(){
  const s = stability();
  const plasma = parseFloat(ui.plasma.value);
  const warp = parseFloat(ui.warp.value)/10;
  return clamp(0.35*s + 0.35*plasma + 0.3*warp, 0, 1);
}

function compressionHold(){
  // ΔP effectiveness increases with stability; reduced by leak when breach active
  const s = stability();
  let eff = s;
  if(breach.active){
    eff *= clamp(1 - breach.leak*0.8, 0, 1);
  }
  return clamp(eff,0,1);
}

function updateGauges(){
  const P = Math.round(shieldPower()*100);
  const C = Math.round(compressionHold()*100);
  const leakVal = breach.active ? (0.2 + (1 - stability())*0.6)*(1 - breach.plasmaLevel*0.8) : 0;
  breach.leak = clamp(leakVal, 0, 1);

  ui.gPower.style.width = P + "%";
  ui.powerV.textContent = P + "%";
  ui.gComp.style.width = C + "%";
  ui.compV.textContent = C + "%";
  ui.gLeak.style.width = Math.round(breach.leak*100) + "%";
  ui.leakV.textContent = (breach.leak*2.0).toFixed(2) + " kg/s";

  // Status text
  if(!breach.active){
    ui.status.className = "v status " + (C>75?"ok": (C>40?"warn":"bad"));
    ui.status.textContent = (C>75?"Crew-Safe":"Standby") + " — ΔP " + C + "%";
  }else{
    const txt = (C>70?"Crew-Safe":"Holding") + " — Breach " + breach.side;
    const cls = (C>70?"ok": (C>40?"warn":"bad"));
    ui.status.className = "v status " + cls;
    ui.status.textContent = txt + " ("+ (100 - Math.round(breach.leak*100)) + "% sealed)";
  }

  // Speed up overlay wavebars according to each channel
  const speedEM = 0.6 + parseFloat(ui.em.value);
  const speedNoise = 0.6 + parseFloat(ui.amp.value)*parseFloat(ui.freq.value)/3;
  const speedPlasma = 0.6 + parseFloat(ui.plasma.value);
  const speedPhot = 0.6 + parseFloat(ui.flux.value);
  const speedCST = 0.6 + parseFloat(ui.cst.value)/100;
  const speedBreach = 0.6 + (breach.active? (0.4 + breach.plasmaLevel*0.8):0.2);

  for(const [el,spd] of [[ui.wbEM,speedEM],[ui.wbNoise,speedNoise],[ui.wbPlasma,speedPlasma],[ui.wbPhot,speedPhot],[ui.wbCST,speedCST],[ui.wbBreach,speedBreach]]){
    el.style.setProperty("--wbspd", spd.toString());
    // hack: scale animation by transform
    el.style.filter = `saturate(${1+spd*0.6}) brightness(${0.9+spd*0.2})`;
  }
}

function drawBackground(){
  ctx.fillStyle = '#060914';
  ctx.fillRect(0,0,cv.width,cv.height);
  // subtle parallax stars
  for(let i=0;i<140;i++){
    const x = (i*97 + (t*0.035)) % cv.width;
    const y = (i*53 + (t*0.02)) % cv.height;
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#98a7de';
    ctx.fillRect(x,y,1,1);
  }
  ctx.globalAlpha = 1;
}

function drawShip(){
  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.beginPath();
  ctx.arc(0,0, ship.r, 0, Math.PI*2);
  const grad = ctx.createRadialGradient(0,0,2,0,0,ship.r);
  grad.addColorStop(0,'#e8f2ff');
  grad.addColorStop(1,'#95a9ff');
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.restore();
}

function drawEMBubble(){
  const em = parseFloat(ui.em.value);
  const baseR = 120 + em*140;
  const phase = t*0.05;
  // Glow layers
  for(let i=0;i<5;i++){
    ctx.beginPath();
    const r = baseR + i*3 + Math.sin(phase + i*0.6)*2;
    ctx.arc(ship.x, ship.y, r, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(126,255,196,${0.12 - i*0.015})`;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  // Main shell
  ctx.beginPath();
  ctx.arc(ship.x, ship.y, baseR + Math.sin(phase)*6, 0, Math.PI*2);
  ctx.strokeStyle = 'rgba(126,255,196,0.4)';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Vector bias if breach active (thicker on that side)
  if(breach.active){
    const bias = 0.7 + stability()*0.9;
    const bx = ship.x + breach.nx*(baseR+6);
    const by = ship.y + breach.ny*(baseR+6);
    ctx.beginPath();
    ctx.arc(ship.x, ship.y, baseR + 10, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(126,255,196,0.2)';
    ctx.lineWidth = 10*bias;
    ctx.setLineDash([14,10]);
    ctx.stroke();
    ctx.setLineDash([]);
    // Direction arrow
    ctx.beginPath();
    ctx.moveTo(bx,by);
    ctx.lineTo(bx + breach.nx*24, by + breach.ny*24);
    ctx.strokeStyle = 'rgba(126,255,196,0.8)';
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  return baseR;
}

function drawNoiseRings(baseR){
  const amp = parseFloat(ui.amp.value);
  const freq = parseFloat(ui.freq.value);
  const rings = 7;
  const blink = 300 - Math.min(260, amp*freq*180); // faster blink with power
  const on = ((t % (blink*2)) < blink);
  ctx.globalAlpha = on ? 0.9 : 0.4;
  for(let i=0;i<rings;i++){
    const spread = 28 + i*22;
    const r = baseR + spread + Math.sin(t*freq*0.12 + i*0.8)*(10 + amp*24);
    ctx.beginPath();
    ctx.arc(ship.x, ship.y, r, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(122,211,255,0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([8,8]);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  ctx.globalAlpha = 1;
}

function drawPlasmaWindow(){
  if(!breach.active) return;
  // A glowing diaphragm across the breach normal
  const len = 180 + parseFloat(ui.plasma.value)*220;
  const thick = 6 + breach.plasmaLevel*18;
  const cx = ship.x + breach.nx* (130);
  const cy = ship.y + breach.ny* (130);
  const ang = Math.atan2(breach.ny, breach.nx);
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(ang + Math.PI/2);
  const grad = ctx.createLinearGradient(-len/2,0,len/2,0);
  grad.addColorStop(0,'rgba(110,231,255,0.05)');
  grad.addColorStop(0.5,`rgba(124,255,210,${0.25+breach.plasmaLevel*0.35})`);
  grad.addColorStop(1,'rgba(110,231,255,0.05)');
  ctx.fillStyle = grad;
  ctx.fillRect(-len/2, -thick/2, len, thick);

  // Ripple showing HF drive
  const nWaves = 8;
  ctx.beginPath();
  for(let i=0;i<=nWaves;i++){
    const x = -len/2 + (i/nWaves)*len;
    const y = Math.sin((i/nWaves)*Math.PI*4 + t*0.02*parseFloat(ui.freq.value))* (thick*0.45 + breach.plasmaLevel*4);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = 'rgba(124,255,210,0.9)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();
}

function interactParticles(baseR){
  for(const p of particles){
    // Basic motion
    p.x += p.vx; p.y += p.vy; p.life -= 0.02;
    // Deflect/absorb near bubble
    const dx = p.x - ship.x, dy = p.y - ship.y;
    const d = Math.hypot(dx,dy);
    const s = stability();
    const effR = baseR*(0.9 + 0.2*s);
    if(d < effR){
      // repel outward + color shift
      const nx = dx/(d||1), ny = dy/(d||1);
      const speed = Math.hypot(p.vx,p.vy);
      const boost = 1.0 + 0.4*s;
      p.vx = nx*boost*speed; p.vy = ny*boost*speed;
      p.type = 'ion';
    }

    // Plasma window across breach: absorb if crossing sheet
    if(breach.active){
      // distance to line through (cx,cy) normal to breach vector
      const cx = ship.x + breach.nx* (130);
      const cy = ship.y + breach.ny* (130);
      const nx = breach.nx, ny = breach.ny;
      const dist = Math.abs((p.x-cx)*nx + (p.y-cy)*ny);
      const along = Math.abs((p.x-cx)*(-ny) + (p.y-cy)*(nx));
      const len = 180 + parseFloat(ui.plasma.value)*220;
      const thick = 6 + breach.plasmaLevel*18;
      if(along < len/2 && dist < thick/2){
        // Absorb with probability based on plasma level
        if(Math.random() < (0.6*breach.plasmaLevel + 0.2*stability())){
          p.life = 0;
        }else{
          // reflect
          const vn = p.vx*nx + p.vy*ny;
          p.vx -= 2*vn*nx; p.vy -= 2*vn*ny;
        }
      }
    }
  }
  particles = particles.filter(p=>p.life>0 && p.x>-40 && p.x<cv.width+40 && p.y>-40 && p.y<cv.height+40);
}

function drawParticles(){
  for(const p of particles){
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.type==='photon'?1.5:2.2, 0, Math.PI*2);
    ctx.fillStyle = (p.type==='photon') ? 'rgba(255,210,163,0.9)' : 'rgba(163,178,255,0.9)';
    ctx.fill();
  }
}

function step(dt){
  t += dt;
  if(Math.random() < 0.7) spawnParticles();

  // Breach controller: raise plasmaLevel and bias field toward breach
  if(breach.active){
    const target = clamp(0.35 + stability()*0.6, 0, 1);
    breach.plasmaLevel = lerp(breach.plasmaLevel, target, 0.03);
    // Auto boost EM + Noise slightly
    const em = parseFloat(ui.em.value);
    const amp = parseFloat(ui.amp.value);
    ui.em.value = clamp(em + 0.0025, 0, 1);
    ui.amp.value = clamp(amp + 0.0020, 0, 1);
  }else{
    breach.plasmaLevel = lerp(breach.plasmaLevel, 0, 0.03);
  }

  // Demo timeline (5 minutes)
  if(demoMode){
    const elapsed = t - demoStart;
    const s = clamp(elapsed/DEMO_MS, 0, 1);
    // 0-60s ramp
    const ramp = clamp(elapsed/60000, 0, 1);
    // 60-150s cruise minor oscillation
    const osc = 0.02*Math.sin(elapsed*0.0008);
    if(elapsed < 60000){
      ui.em.value = 0.4 + 0.4*ramp;
      ui.amp.value = 0.35 + 0.45*ramp;
      ui.plasma.value = 0.3 + 0.5*ramp;
      ui.freq.value = 0.7 + 0.5*ramp;
      ui.cst.value = Math.round(70 + 20*ramp);
      ui.warp.value = 3 + 5*ramp;
    }else if(elapsed < 150000){
      ui.em.value = clamp(parseFloat(ui.em.value)+osc,0,1);
      ui.amp.value = clamp(parseFloat(ui.amp.value)-osc,0,1);
      ui.plasma.value = clamp(parseFloat(ui.plasma.value)+osc,0,1);
    }else if(elapsed < 300000){
      // breach at 150s; hold and fight leak, then heal near the end
      if(!breach.active) triggerBreach("Starboard", 1, 0);
      if(elapsed > 285000){ // last 15s auto-heal
        healBreach();
      }
    }else{
      demoMode = false;
    }
  }
}

function render(){
  drawBackground();
  drawShip();
  const baseR = drawEMBubble();
  drawNoiseRings(baseR);
  drawPlasmaWindow();
  drawParticles();
  updateGauges();

  // On-screen connector lines from labels to scene
  ctx.save();
  ctx.strokeStyle = 'rgba(160,190,250,0.5)';
  ctx.lineWidth = 1;
  // EM: to bubble
  ctx.beginPath(); ctx.moveTo(90,60); ctx.lineTo(ship.x- baseR-20, ship.y); ctx.stroke();
  // Noise: to rings
  ctx.beginPath(); ctx.moveTo(270,60); ctx.lineTo(ship.x, ship.y - (baseR+70)); ctx.stroke();
  // Plasma: to breach sheet (or near bubble if idle)
  ctx.beginPath(); ctx.moveTo(430,60);
  const px = breach.active ? ship.x + breach.nx*130 : ship.x + 10;
  const py = breach.active ? ship.y + breach.ny*130 : ship.y + baseR + 40;
  ctx.lineTo(px, py); ctx.stroke();
  // Photons: to incoming stream
  ctx.beginPath(); ctx.moveTo(615,60); ctx.lineTo(cv.width-60, cv.height/2); ctx.stroke();
  // CST: to ship center
  ctx.beginPath(); ctx.moveTo(820,60); ctx.lineTo(ship.x, ship.y); ctx.stroke();
  // Breach: to breach location
  ctx.beginPath(); ctx.moveTo(cv.width-140,60);
  ctx.lineTo(px,py); ctx.stroke();
  ctx.restore();
}

function loop(now){
  if(!loop.last) loop.last = now;
  const dt = now - loop.last; loop.last = now;
  if(running){ step(dt); render(); }
  else { render(); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Controls
ui.start.addEventListener('click', ()=>{ running=true; });
ui.stop.addEventListener('click', ()=>{ running=false; });
ui.reset.addEventListener('click', ()=>{
  t=0; running=false; demoMode=false; particles=[]; breach.active=false; breach.leak=0; ui.status.textContent='Idle';
});
ui.demo.addEventListener('click', ()=>{
  running=true; demoMode=true; demoStart=t; particles=[]; breach.active=false; breach.leak=0;
  ui.status.textContent='DEMO running (5 min)…';
});

function triggerBreach(side, nx, ny){
  breach.active = true; breach.side = side; breach.nx = nx; breach.ny = ny; breach.leak=1; breach.plasmaLevel=0.2;
  ui.status.textContent = 'Breach ' + side + ' — Vectoring fields';
  // Blink breach label faster
  document.getElementById('labBreach').classList.add('blink');
}
function healBreach(){
  breach.active = false; breach.leak=0; breach.plasmaLevel=0;
  document.getElementById('labBreach').classList.remove('blink');
  ui.status.textContent = 'Patch sealed — Ramp down';
}
ui.breachL.addEventListener('click', ()=>{ running=true; triggerBreach("Port", -1, 0); });
ui.breachR.addEventListener('click', ()=>{ running=true; triggerBreach("Starboard", 1, 0); });
ui.breachN.addEventListener('click', ()=>{ running=true; triggerBreach("Fore", 0, -1); });
ui.breachS.addEventListener('click', ()=>{ running=true; triggerBreach("Aft", 0, 1); });
ui.heal.addEventListener('click', healBreach);
</script>
</body>
</html>
