<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cash Five 300-Draw Streak & Probability Coach — 1,200 Samples + 10 & 60-Ticket Generators</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --chip:#1e2a59;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:16px;
  }
  h1{
    margin:6px 0 4px;
    font-size:1.6rem;
  }
  .tagline{
    margin:0 0 12px;
    color:var(--muted);
    font-size:0.9rem;
  }
  section{
    background:var(--panel);
    border:1px solid var(--grid);
    border-radius:10px;
    padding:12px;
    margin-top:14px;
  }
  h2{
    margin:0 0 8px;
    font-size:1.05rem;
  }
  label{
    font-size:0.85rem;
    color:var(--muted);
    display:block;
    margin-bottom:4px;
  }
  textarea{
    width:100%;
    min-height:90px;
    background:#070c19;
    color:var(--ink);
    border:1px solid var(--grid);
    border-radius:8px;
    padding:8px;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.8rem;
    resize:vertical;
    white-space:pre;
  }
  textarea.small{
    min-height:70px;
  }
  .hint{
    font-size:0.75rem;
    color:var(--muted);
    margin:4px 0 8px;
  }
  .btn-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin:8px 0;
  }
  button{
    border:none;
    border-radius:999px;
    padding:7px 14px;
    font-size:0.85rem;
    cursor:pointer;
    background:var(--chip);
    color:var(--ink);
  }
  button.primary{
    background:var(--accent);
    color:#050816;
    font-weight:600;
  }
  button:disabled{
    opacity:0.55;
    cursor:not-allowed;
  }
  .summary{
    margin-top:8px;
    padding:8px;
    border-radius:8px;
    background:#0c1630;
    border:1px dashed var(--grid);
    font-size:0.8rem;
  }
  .summary strong{
    color:var(--accent);
  }
  .pill-row{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    margin-top:4px;
  }
  .pill{
    font-size:0.7rem;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--grid);
    background:#0a142b;
    color:var(--muted);
  }
  .pill.good{
    border-color:var(--good);
    color:var(--good);
  }
  .pill.bad{
    border-color:var(--bad);
    color:var(--bad);
  }
  .spread{
    margin-top:6px;
    font-size:0.75rem;
    color:var(--muted);
  }
  .spread.tight{color:var(--bad);}
  .spread.loose{color:var(--warn);}
  .spread.balanced{color:var(--good);}
  .footer-note{
    margin-top:12px;
    font-size:0.72rem;
    color:var(--muted);
  }

  /* Stats table for streak/gap model */
  .scroll-table{
    max-height:260px;
    overflow:auto;
    border-radius:8px;
    border:1px solid var(--grid);
    padding:6px 8px;
    background:#050815;
    font-size:0.78rem;
    margin-top:6px;
  }
  table{
    width:100%;
    border-collapse:collapse;
  }
  th,td{
    padding:3px 4px;
    text-align:right;
    border-bottom:1px solid #1b2550;
  }
  th{
    position:sticky;
    top:0;
    background:#080f23;
    z-index:1;
  }
  .tag-badge{
    font-size:0.7rem;
    padding:1px 6px;
    border-radius:999px;
    background:#1e293b;
  }
  .tag-hot{ background:rgba(127,255,177,0.12); color:var(--good); }
  .tag-late{ background:rgba(255,211,122,0.12); color:var(--warn); }
  .tag-run{ background:rgba(143,180,255,0.12); color:var(--accent); }
</style>
</head>
<body>
<div class="wrap">
  <h1>Cash Five 300-Draw Streak &amp; Probability Coach</h1>
  <p class="tagline">
    Texas Cash Five mode — numbers 1–35, 5 numbers per ticket. Paste up to 300 official draws → build frequency, gap/recency &amp; streak model →
    generate 1,200 sample tickets → test 360 internal draws with your 6 machine tests → generate 10 model tickets and one final 60-ticket batch.
  </p>

  <!-- PANEL 1: OFFICIAL DRAWS (UP TO 300) + 1,200-SAMPLE ENGINE + STREAK/GAP MODEL -->
  <section>
    <h2>1. Official draws (up to 300) → 1,200-sample engine + streak/gap model</h2>

    <label for="lastDraws60">Official Cash Five winning draws (oldest → newest)</label>
    <textarea id="lastDraws60" placeholder="Example (one line per draw, 5 numbers, 1–35):&#10;03 12 24 29 35&#10;01 05 18 21 30&#10;... paste up to your last 300 official draws"></textarea>
    <div class="hint">
      Each line = 5 numbers, 1–35, separated by spaces or commas. You can paste 60, 100, 300, etc.
      The engine will:
      (1) build the pool from these draws,
      (2) compute frequency, gap/recency, and streaks (3-in-a-row or more),
      (3) compute a combined weight/score for each number,
      and (4) generate 1,200 sample tickets.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="analyzeAndSample()">Analyze draws &amp; generate 1,200 sample tickets</button>
      <button onclick="clearAll()">Reset everything</button>
    </div>

    <label for="bulkTickets">1,200 generated sample tickets (1 ticket per line)</label>
    <textarea id="bulkTickets" class="small" placeholder="Click &quot;Analyze draws &amp; generate 1,200 sample tickets&quot; to see the list here."></textarea>

    <div id="bulkStats" class="summary">
      Waiting for data: paste your official draws and run the analysis to see pool size, frequency statistics,
      probability bands, and the streak/gap model.
    </div>

    <div class="summary">
      <strong>Number probability bands (inside official-draw universe)</strong>
      <div id="scoreBands" class="pill-row">
        <span class="pill">No probabilities yet — run Panel 1 first.</span>
      </div>
    </div>

    <div class="summary">
      <strong>Streak / gap / recency model — top-weight numbers (for next draw)</strong>
      <div id="modelTopNumbers" class="pill-row">
        <span class="pill">Run analysis to see the top-weight numbers.</span>
      </div>
    </div>
  </section>

  <!-- PANEL 1B: FULL NUMBER STATS TABLE -->
  <section>
    <h2>1b. Full number stats (freq, gap/recency, streaks, score)</h2>
    <div class="hint">
      For each number 1–35:
      frequency in the window, last seen (draw index), recency (gap since last hit),
      max streak in a row, number of runs ≥ 3, and the combined score used by the generators.
    </div>
    <div class="scroll-table">
      <table id="statsTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Freq</th>
            <th>Last</th>
            <th>Rec</th>
            <th>MaxRun</th>
            <th>Runs≥3</th>
            <th>Score</th>
            <th style="text-align:left;">Tags</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- PANEL 2: COMPARE YOUR 60 GENERATED TICKETS -->
  <section>
    <h2>2. Compare your 60 generated tickets vs official draws &amp; 1,200 samples</h2>

    <label for="simTickets">Your 60 generated tickets (1 ticket per line)</label>
    <textarea id="simTickets" placeholder="Paste the 60 tickets you generated/played (5 numbers per line, 1–35)."></textarea>
    <div class="hint">
      The simulator will compute how your 60 tickets line up with:
      (a) the official-draw frequencies, and (b) the 1,200-sample frequencies.
      This shows how far your play deviates from the probabilities in the chosen window.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="compare60()">Compare distributions (official vs 1,200 vs your 60)</button>
    </div>

    <div id="compareStats" class="summary">
      After running Panel 1, paste your 60 tickets here and click
      <strong>Compare distributions</strong> to see deviations and top over-used / under-used numbers.
    </div>
  </section>

  <!-- PANEL 3: 10-TICKET GENERATOR USING STREAK/GAP WEIGHTS + ANTI-OVERUSE MEMORY -->
  <section>
    <h2>3. Generate 10 tickets using weight + gap/recency + streak model</h2>

    <div class="hint">
      Uses the combined score from Panel 1 (frequency + lateness/gap + streak strength).
      A memory system tracks how often each number has been used in past generations and penalizes over-used numbers,
      so under-used numbers get a boost and the shape stays closer to the model.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="generate10()">Generate 10 tickets (streak/gap-weighted with correction)</button>
    </div>

    <label for="tenTicketsOut">10-ticket output (model-based play candidates)</label>
    <textarea id="tenTicketsOut" class="small" placeholder="Run Panel 1 first, then click &quot;Generate 10 tickets&quot;."></textarea>

    <div id="spreadDiag" class="spread">
      Spread diagnostic will appear here (tight / balanced / loose) after generation.
    </div>

    <div class="footer-note">
      ⚠️ This simulator cannot defeat true lottery randomness. It only keeps your 10-ticket patterns inside the
      statistical shape of your official draws (frequency, gap/recency, streaks), while automatically reducing
      extreme over-weight / under-weight of individual numbers across many runs.
    </div>
  </section>

  <!-- PANEL 4: 6 TEST DRAWS → 360 INTERNAL DRAWS → FINAL 60-TICKET BATCH -->
  <section>
    <h2>4. 6 test draws → 360-draw analyzer → final 60-ticket batch</h2>
    <div class="hint">
      Step 1: Paste the last 6 (or so) Cash Five machine test draws (Test #1–#6).<br>
      Step 2: The engine will generate 360 internal tickets (6 × 60) using the streak/gap model from Panel 1.<br>
      Step 3: It compares test-draw hot numbers &amp; pairs vs the 360 and the 1,200 samples.<br>
      Step 4: Use the adjusted weights to generate ONE final batch of 60 tickets to consider for purchase.
    </div>

    <label for="testDrawsInput">Last machine test draws (example: 6 test lines, 5 numbers per line)</label>
    <textarea id="testDrawsInput" class="small" placeholder="Example (one line per test draw, 5 numbers, 1–35):&#10;03 08 12 19 25&#10;02 10 14 21 33&#10;01 07 11 18 29&#10;04 15 20 26 31&#10;05 09 16 23 34&#10;06 13 17 22 30"></textarea>

    <div class="btn-row">
      <button class="primary" onclick="analyzeTestsAnd360()">Analyze tests &amp; generate 360 internal tickets</button>
    </div>

    <label for="test360Out">360 internal tickets (6 × 60) — analysis only</label>
    <textarea id="test360Out" class="small" placeholder="After analyzing tests, the 360 internal tickets will appear here (not for buying, for pattern checking)."></textarea>

    <div id="test360Stats" class="summary">
      After you paste the 6 test draws and run the analysis, you will see:
      (1) hot numbers in tests, (2) how often they appear in 360 draws and 1,200 samples, and
      (3) repeated test pairs.
    </div>

    <div class="btn-row">
      <button class="primary" onclick="generateFinal60()">Generate final 60 official tickets</button>
      <button onclick="printFinal60()">Print final 60 (browser print)</button>
    </div>

    <label for="final60Out">Final 60-ticket batch (model + tests + 360 analysis)</label>
    <textarea id="final60Out" class="small" placeholder="After running Panel 1 and Panel 4, click &quot;Generate final 60 official tickets&quot; to see them here."></textarea>

    <div class="footer-note">
      ⚠️ The 60-ticket batch still follows true lottery randomness. This panel only tunes weights based on:
      official draws → streak/gap model → 1,200 samples → your 6 machine tests → 360 internal draws.
      It does NOT guarantee wins; it only organizes your 60 numbers around the patterns you care about (hot numbers and pairs).
    </div>
  </section>
<script>
  const MAX_N = 35;              // Cash Five: numbers 1–35
  const NUM_PER_TICKET = 5;      // Cash Five: 5 numbers per ticket
  const SAMPLE_TICKETS = 1200;   // 1,200 sample tickets
  const TEST360_TICKETS = 360;   // 6 × 60 internal analysis tickets

  // Global state
  let poolNumbers = [];                        // numbers that appear in the official draws window
  let officialFreq = Array(MAX_N+1).fill(0);   // frequency in official draws
  let sampleFreq   = Array(MAX_N+1).fill(0);   // frequency in 1,200 generated tickets
  let combinedScores = null;                   // streak/gap-based weights for generator
  let usageCounts = Array(MAX_N+1).fill(0);    // how many times each number has been used in generated 10-ticket sets

  // Streak/gap model arrays
  let lastSeen   = Array(MAX_N+1).fill(-1);
  let recency    = Array(MAX_N+1).fill(0);
  let maxRun     = Array(MAX_N+1).fill(0);
  let runs3Plus  = Array(MAX_N+1).fill(0);
  let modelScore = Array(MAX_N+1).fill(0);

  // Extra state for 6 tests + 360 internal draws + final 60
  let freqTest   = Array(MAX_N+1).fill(0);     // frequency in the pasted test draws
  let freq360    = Array(MAX_N+1).fill(0);     // frequency in the 360 internal tickets
  let testPairs  = {};                         // repeated pairs from test draws
  let lastFinal60Tickets = [];                 // last generated batch of 60 tickets

  function parseTickets(raw){
    const lines = raw.split(/[\r\n]+/).map(l=>l.trim()).filter(l=>l.length>0);
    const tickets = [];
    for(const line of lines){
      const nums = line
        .replace(/,/g,' ')
        .replace(/-/g,' ')
        .split(/\s+/)
        .map(x=>parseInt(x,10))
        .filter(n=>Number.isFinite(n) && n>=1 && n<=MAX_N);
      if(nums.length === NUM_PER_TICKET){
        const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);
        if(uniq.length === NUM_PER_TICKET) tickets.push(uniq);
      }
    }
    return tickets;
  }

  function weightedPickFromPool(scores,pool,used){
    let total=0;
    for(const n of pool){
      if(!used.has(n)) total += Math.max(scores[n] || 0, 0);
    }
    if(total<=0){
      const candidates = pool.filter(n=>!used.has(n));
      return candidates[Math.floor(Math.random()*candidates.length)];
    }
    let r = Math.random()*total;
    for(const n of pool){
      if(used.has(n)) continue;
      const w = Math.max(scores[n] || 0, 0);
      r -= w;
      if(r<=0) return n;
    }
    const candidates = pool.filter(n=>!used.has(n));
    return candidates[0];
  }

  // Generic ticket generator with uniqueness protection
  function generateTickets(numTickets, scores){
    const tickets = [];
    const seen = new Set();
    let attempts = 0;
    const maxAttempts = numTickets * 40;

    while(tickets.length < numTickets && attempts < maxAttempts){
      attempts++;
      const used = new Set();
      while(used.size < NUM_PER_TICKET){
        const n = weightedPickFromPool(scores, poolNumbers, used);
        used.add(n);
      }
      const ticket = Array.from(used).sort((a,b)=>a-b);
      const key = ticket.join('-');
      if(!seen.has(key)){
        seen.add(key);
        tickets.push(ticket);
      }
    }
    return tickets;
  }

  function analyzeAndSample(){
    const raw = document.getElementById('lastDraws60').value;
    const bulkEl = document.getElementById('bulkTickets');
    const statsEl = document.getElementById('bulkStats');
    const scoreBandsEl = document.getElementById('scoreBands');

    const draws = parseTickets(raw);
    if(draws.length === 0){
      statsEl.innerHTML = 'Please paste your official Cash Five draws (up to 300) before running the analysis.';
      return;
    }

    const D = draws.length;

    // Build pool and official frequencies
    poolNumbers = [];
    const poolSet = new Set();
    officialFreq = Array(MAX_N+1).fill(0);
    for(const d of draws){
      for(const n of d){
        poolSet.add(n);
        officialFreq[n]++;
      }
    }
    poolNumbers = Array.from(poolSet).sort((a,b)=>a-b);

    if(poolNumbers.length < NUM_PER_TICKET){
      statsEl.innerHTML = 'Need at least 5 distinct numbers across the official draws to build a valid pool.';
      bulkEl.value = '';
      return;
    }

    // Official probabilities p_off
    const totalOfficialNums = D * NUM_PER_TICKET;
    const pOff = Array(MAX_N+1).fill(0);
    for(let n=1;n<=MAX_N;n++){
      pOff[n] = officialFreq[n] > 0 ? officialFreq[n]/totalOfficialNums : 0;
    }

    // Generate 1,200 sample tickets from pool using p_off as weights
    const lines = [];
    sampleFreq = Array(MAX_N+1).fill(0);

    for(let t=0;t<SAMPLE_TICKETS;t++){
      const used = new Set();
      while(used.size < NUM_PER_TICKET){
        const num = weightedPickFromPool(pOff,poolNumbers,used);
        used.add(num);
        sampleFreq[num]++;
      }
      const ticket = Array.from(used).sort((a,b)=>a-b);
      lines.push(ticket.map(n=>String(n).padStart(2,'0')).join(' '));
    }
    bulkEl.value = lines.join('\n');

    // Build streak/gap model (freq, lastSeen, recency, maxRun, runs≥3, score)
    buildStreakGapModel(draws);

    // For the generator, use the model score (freq + gap + streak), not just p_off
    combinedScores = Array(MAX_N+1).fill(0);
    for(let n=1;n<=MAX_N;n++){
      combinedScores[n] = modelScore[n];
    }

    // Stats summary for sample distribution
    const totalSampleNums = SAMPLE_TICKETS * NUM_PER_TICKET;

    let minOff=Infinity,maxOff=-Infinity,minSamp=Infinity,maxSamp=-Infinity;
    for(const n of poolNumbers){
      const fOff = officialFreq[n];
      const fSamp = sampleFreq[n];
      if(fOff<minOff) minOff=fOff;
      if(fOff>maxOff) maxOff=fOff;
      if(fSamp<minSamp) minSamp=fSamp;
      if(fSamp>maxSamp) maxSamp=fSamp;
    }
    const avgOff  = totalOfficialNums / poolNumbers.length;
    const avgSamp = totalSampleNums / poolNumbers.length;

    statsEl.innerHTML =
      `Draw window size: <strong>${D}</strong> draws · Pool size: <strong>${poolNumbers.length}</strong> unique numbers.<br>` +
      `Official draws: total numbers = ${totalOfficialNums}, average per pool number ≈ ${avgOff.toFixed(2)} ` +
      `(min ${minOff}, max ${maxOff}).<br>` +
      `1,200 sample tickets: total numbers = ${totalSampleNums}, average per pool number ≈ ${avgSamp.toFixed(2)} ` +
      `(min ${minSamp}, max ${maxSamp}).<br>` +
      `<em>Streak/gap model and generators now use the combined score (frequency + gap/recency + streaks).</em>`;

    // Probability bands based on p_off
    scoreBandsEl.innerHTML = '';
    const vals = poolNumbers.map(n=>pOff[n]);
    const maxVal = Math.max(...vals);
    const minVal = Math.min(...vals);
    const span = maxVal - minVal || 1;
    const bands = {low:0,mid:0,high:0};

    for(const n of poolNumbers){
      const norm = (pOff[n]-minVal)/span;
      if(norm < 0.33) bands.low++;
      else if(norm < 0.66) bands.mid++;
      else bands.high++;
    }

    scoreBandsEl.innerHTML =
      `<span class="pill bad">Low-prob: ${bands.low}</span>
       <span class="pill">Mid-prob: ${bands.mid}</span>
       <span class="pill good">High-prob: ${bands.high}</span>`;

    // Reset usage memory so new runs start fresh
    usageCounts = Array(MAX_N+1).fill(0);

    // Render streak/gap model outputs (top numbers + stats table)
    renderModelOutputs(D);
  }

  function buildStreakGapModel(draws){
    const D = draws.length;

    // presence[n][d] = true if n appears in draw d
    const presence = Array(MAX_N+1).fill(null).map(()=>Array(D).fill(false));
    for(let d=0; d<D; d++){
      const set = new Set(draws[d]);
      for(const n of set){
        if(n>=1 && n<=MAX_N){
          presence[n][d] = true;
        }
      }
    }

    lastSeen  = Array(MAX_N+1).fill(-1);
    recency   = Array(MAX_N+1).fill(0);
    maxRun    = Array(MAX_N+1).fill(0);
    runs3Plus = Array(MAX_N+1).fill(0);

    for(let n=1; n<=MAX_N; n++){
      let last = -1;
      let currentRun = 0;
      let maxR = 0;
      let runs3 = 0;

      for(let d=0; d<D; d++){
        if(presence[n][d]){
          last = d;
          currentRun++;
        }else{
          if(currentRun >= 3) runs3++;
          if(currentRun > maxR) maxR = currentRun;
          currentRun = 0;
        }
      }
      // tail streak
      if(currentRun >= 3) runs3++;
      if(currentRun > maxR) maxR = currentRun;

      lastSeen[n] = last;
      if(last === -1){
        recency[n] = D;  // never seen in this window
      }else{
        recency[n] = (D - 1) - last;
      }
      maxRun[n] = maxR;
      runs3Plus[n] = runs3;
    }

    // Score: combine normalized freq, lateness, streak strength
    modelScore = Array(MAX_N+1).fill(0);
    const freq = officialFreq;

    const maxFreq = Math.max(...freq.slice(1));
    const maxRec  = Math.max(...recency.slice(1));
    const maxRunGlobal = Math.max(...maxRun.slice(1));

    for(let n=1; n<=MAX_N; n++){
      if(!poolNumbers.includes(n)){
        modelScore[n] = 0;
        continue;
      }
      const freqNorm = maxFreq > 0 ? freq[n]/maxFreq : 0;
      const lateNorm = maxRec  > 0 ? recency[n]/maxRec : 0;
      const runNorm  = maxRunGlobal > 0 ? maxRun[n]/maxRunGlobal : 0;
      // You can tweak weights (0.5, 0.4, 0.1)
      const s = 0.5*freqNorm + 0.4*lateNorm + 0.1*runNorm;
      modelScore[n] = s;
    }
  }

  function renderModelOutputs(D){
    const topEl = document.getElementById('modelTopNumbers');
    const statsBody = document.querySelector('#statsTable tbody');

    // Build rows
    const rows = [];
    for(let n=1; n<=MAX_N; n++){
      rows.push({
        n,
        freq: officialFreq[n],
        last: lastSeen[n],
        rec: recency[n],
        maxRun: maxRun[n],
        runs3: runs3Plus[n],
        score: modelScore[n]
      });
    }

    // Top-weight numbers by score
    const sortedByScore = rows.slice().sort((a,b)=>b.score - a.score);
    const topCount = 15;
    const top = sortedByScore.filter(r=>r.score>0).slice(0, topCount);

    topEl.innerHTML = '';
    if(top.length === 0){
      topEl.innerHTML = '<span class="pill">No positive scores yet (check your draws input).</span>';
    }else{
      top.forEach((r,idx)=>{
        const pill = document.createElement('span');
        pill.className = 'pill';
        pill.innerHTML = `<strong>${r.n}</strong> #${idx+1} · score ${r.score.toFixed(3)} · freq ${r.freq} · rec ${r.rec}`;
        topEl.appendChild(pill);
      });
    }

    // Stats table: sort by number
    statsBody.innerHTML = '';
    const maxFreq = Math.max(...officialFreq.slice(1));
    const maxRec  = Math.max(...recency.slice(1));
    const maxRunGlobal = Math.max(...maxRun.slice(1));

    const rowsByN = rows.slice().sort((a,b)=>a.n - b.n);
    rowsByN.forEach(r=>{
      const tr = document.createElement('tr');

      const tags = [];
      if(r.freq === maxFreq && maxFreq>0) tags.push('<span class="tag-badge tag-hot">hottest</span>');
      else if(r.freq >= Math.max(3, Math.round(maxFreq*0.7))) tags.push('<span class="tag-badge tag-hot">hot</span>');
      if(r.rec === maxRec && maxRec>0) tags.push('<span class="tag-badge tag-late">latest</span>');
      else if(r.rec >= Math.max(5, Math.round(maxRec*0.7))) tags.push('<span class="tag-badge tag-late">late</span>');
      if(r.maxRun >= 3) tags.push(`<span class="tag-badge tag-run">run×${r.maxRun}</span>`);

      tr.innerHTML = `
        <td>${r.n}</td>
        <td>${r.freq}</td>
        <td>${r.last === -1 ? '—' : r.last}</td>
        <td>${r.rec}</td>
        <td>${r.maxRun}</td>
        <td>${r.runs3}</td>
        <td>${r.score.toFixed(3)}</td>
        <td style="text-align:left;">${tags.join(' ')}</td>
      `;
      statsBody.appendChild(tr);
    });
  }

  function compare60(){
    const statsEl = document.getElementById('compareStats');
    if(poolNumbers.length === 0 || !combinedScores){
      statsEl.innerHTML = 'Run Panel 1 first (analyze draws & generate 1,200 samples) before comparing.';
      return;
    }

    const draws = parseTickets(document.getElementById('lastDraws60').value);
    if(draws.length === 0){
      statsEl.innerHTML = 'Your official draws are missing. Paste them again in Panel 1 and rerun.';
      return;
    }

    const simTickets = parseTickets(document.getElementById('simTickets').value);
    if(simTickets.length === 0){
      statsEl.innerHTML = 'Paste your 60 generated tickets and try again.';
      return;
    }

    const freqOfficial = officialFreq.slice(); // already computed
    const freqSample   = sampleFreq.slice();   // already computed
    const freqSim      = Array(MAX_N+1).fill(0);

    let outsidePoolSim = 0;
    for(const t of simTickets){
      for(const n of t){
        freqSim[n]++;
        if(!poolNumbers.includes(n)) outsidePoolSim++;
      }
    }

    const totalOfficial = draws.length * NUM_PER_TICKET;
    const totalSample   = SAMPLE_TICKETS * NUM_PER_TICKET;
    const totalSim      = simTickets.length * NUM_PER_TICKET;

    let sumDevOffSample = 0;
    let sumDevOffSim    = 0;
    for(const n of poolNumbers){
      const pOff  = totalOfficial ? freqOfficial[n]/totalOfficial : 0;
      const pSamp = totalSample   ? freqSample[n]/totalSample     : 0;
      const pSim  = totalSim      ? freqSim[n]/totalSim           : 0;
      sumDevOffSample += Math.abs(pOff - pSamp);
      sumDevOffSim    += Math.abs(pOff - pSim);
    }
    const avgDevOffSample = sumDevOffSample / poolNumbers.length;
    const avgDevOffSim    = sumDevOffSim    / poolNumbers.length;

    const diffs = [];
    for(const n of poolNumbers){
      const pOff = totalOfficial ? freqOfficial[n]/totalOfficial : 0;
      const pSim = totalSim      ? freqSim[n]/totalSim           : 0;
      diffs.push({ n, pOff, pSim, diff: pSim - pOff });
    }
    diffs.sort((a,b)=>Math.abs(b.diff) - Math.abs(a.diff));
    const topOver  = diffs.filter(x=>x.diff>0).slice(0,5);
    const topUnder = diffs.filter(x=>x.diff<0).slice(0,5);

    function fmtPercent(x){ return (x*100).toFixed(2)+'%'; }

    let overText = topOver.length ? topOver.map(x =>
      `${String(x.n).padStart(2,'0')} → you: ${fmtPercent(x.pSim)}, official: ${fmtPercent(x.pOff)}`
    ).join('<br>') : 'None (no numbers strongly over-used).';

    let underText = topUnder.length ? topUnder.map(x =>
      `${String(x.n).padStart(2,'0')} → you: ${fmtPercent(x.pSim)}, official: ${fmtPercent(x.pOff)}`
    ).join('<br>') : 'None (no numbers strongly under-used).';

    statsEl.innerHTML =
      `Compared distributions on <strong>${poolNumbers.length}</strong> pool numbers (official-draw universe).<br>` +
      `Average absolute deviation (official vs 1,200 sample): <strong>${fmtPercent(avgDevOffSample)}</strong><br>` +
      `Average absolute deviation (official vs your 60 tickets): <strong>${fmtPercent(avgDevOffSim)}</strong><br>` +
      `<em>Lower deviation means staying closer to the probabilities in your window.</em><br><br>` +
      `Numbers outside pool used in your 60 tickets: <strong>${outsidePoolSim}</strong> (these never appeared in the official window).<br><br>` +
      `<strong>Most over-used numbers in your 60 vs official draws:</strong><br>${overText}<br><br>` +
      `<strong>Most under-used numbers in your 60 vs official draws:</strong><br>${underText}`;
  }

  function generate10(){
    const outEl = document.getElementById('tenTicketsOut');
    const spreadEl = document.getElementById('spreadDiag');

    if(poolNumbers.length === 0 || !combinedScores){
      outEl.value = '';
      spreadEl.className = 'spread';
      spreadEl.textContent = 'Run Panel 1 first (analyze draws & generate 1,200 samples).';
      return;
    }

    const tickets = [];
    const gapsAll = [];

    // Effective scores with anti-overuse correction:
    // effectiveScore = baseScore / (1 + usageCounts[n]/K)
    const K = 10; // controls strength of correction: higher K = softer penalty
    const effectiveScores = Array(MAX_N+1).fill(0);
    for(const n of poolNumbers){
      const base = combinedScores[n] || 0.000001;
      const penalty = 1 + (usageCounts[n] / K);
      effectiveScores[n] = base / penalty;
    }

    for(let t=0;t<10;t++){
      const used = new Set();
      while(used.size < NUM_PER_TICKET){
        const n = weightedPickFromPool(effectiveScores,poolNumbers,used);
        used.add(n);
        usageCounts[n]++; // memory: penalize this number in future generations
      }
      const ticket = Array.from(used).sort((a,b)=>a-b);
      tickets.push(ticket);

      for(let i=1;i<ticket.length;i++){
        gapsAll.push(ticket[i]-ticket[i-1]);
      }
    }

    outEl.value = tickets
      .map(t=>t.map(n=>String(n).padStart(2,'0')).join(' '))
      .join('\n');

    if(gapsAll.length){
      let sum=0,minG=Infinity,maxG=-Infinity;
      for(const g of gapsAll){
        sum+=g;
        if(g<minG) minG=g;
        if(g>maxG) maxG=g;
      }
      const avg = sum/gapsAll.length;
      const label = avg<4 ? 'tight' : avg>8 ? 'loose' : 'balanced';
      spreadEl.className = 'spread '+label;
      spreadEl.textContent =
        `Spread avg gap ${avg.toFixed(2)} (${minG}-${maxG}) → ${label}`;
    }else{
      spreadEl.className = 'spread';
      spreadEl.textContent = 'Spread diagnostic will appear here (tight / balanced / loose) after generation.';
    }
  }

  // PANEL 4: tests → 360 → final 60

  function analyzeTestsAnd360(){
    const testsRaw = document.getElementById('testDrawsInput').value;
    const out360 = document.getElementById('test360Out');
    const statsEl = document.getElementById('test360Stats');

    if(poolNumbers.length === 0 || !combinedScores){
      statsEl.innerHTML = 'Run Panel 1 first (official draws → 1,200-sample engine) before analyzing tests.';
      return;
    }

    const testDraws = parseTickets(testsRaw);
    if(testDraws.length === 0){
      statsEl.innerHTML = 'Paste the last machine test draws (e.g., 6 lines, 5 numbers each) and try again.';
      out360.value = '';
      return;
    }

    // Count test frequencies
    freqTest = Array(MAX_N+1).fill(0);
    for(const d of testDraws){
      for(const n of d){
        freqTest[n]++;
      }
    }

    // Find hot test numbers (appear ≥ 2 times)
    const hotTestNums = [];
    for(let n=1;n<=MAX_N;n++){
      if(freqTest[n] >= 2) hotTestNums.push({n,count:freqTest[n]});
    }

    // Find repeated test pairs (appear ≥ 2 times)
    testPairs = {};
    const pairCounts = {};
    for(const d of testDraws){
      const arr = d.slice().sort((a,b)=>a-b);
      for(let i=0;i<arr.length;i++){
        for(let j=i+1;j<arr.length;j++){
          const key = arr[i]+'-'+arr[j];
          pairCounts[key] = (pairCounts[key] || 0) + 1;
        }
      }
    }
    for(const key in pairCounts){
      if(pairCounts[key] >= 2){
        testPairs[key] = pairCounts[key];
      }
    }

    // Generate 360 internal tickets using combinedScores (no self-feedback)
    freq360 = Array(MAX_N+1).fill(0);
    const tickets360 = generateTickets(TEST360_TICKETS, combinedScores);

    const lines = tickets360.map(t=>t.map(n=>String(n).padStart(2,'0')).join(' '));
    out360.value = lines.join('\n');

    for(const t of tickets360){
      for(const n of t){
        freq360[n]++;
      }
    }

    // Stats: how do hot test numbers look in 360 and 1,200 samples?
    const total360Nums = TEST360_TICKETS * NUM_PER_TICKET;
    const total1200Nums = SAMPLE_TICKETS * NUM_PER_TICKET;

    function fmtPercent(x){ return (x*100).toFixed(2)+'%'; }

    let hotNumsText = hotTestNums.length
      ? hotTestNums.map(h=>{
          const n = h.n;
          const cTest = h.count;
          const pTest = cTest / (testDraws.length*NUM_PER_TICKET);
          const p360  = total360Nums ? freq360[n]/total360Nums : 0;
          const p1200 = total1200Nums ? sampleFreq[n]/total1200Nums : 0;
          return `#${String(n).padStart(2,'0')} → tests: ${cTest}× (${fmtPercent(pTest)}), 360: ${fmtPercent(p360)}, 1,200: ${fmtPercent(p1200)}`;
        }).join('<br>')
      : 'No numbers appeared 2× or more in the test draws.';

    let pairText = Object.keys(testPairs).length
      ? Object.keys(testPairs).map(k=>{
          const c = testPairs[k];
          return `${k.replace('-', ' & ')} → repeats in tests: ${c}×`;
        }).join('<br>')
      : 'No pairs repeated 2× or more in the test draws.';

    statsEl.innerHTML =
      `Test draws loaded: <strong>${testDraws.length}</strong> lines.<br>` +
      `<strong>Hot test numbers (appear ≥ 2× in tests):</strong><br>${hotNumsText}<br><br>` +
      `<strong>Repeated pairs in tests (appear ≥ 2×):</strong><br>${pairText}<br><br>` +
      `<em>360 internal tickets were generated using the streak/gap model. These are for pattern checking only, not direct play.</em>`;
  }

  function generateFinal60(){
    const finalOut = document.getElementById('final60Out');
    const statsEl = document.getElementById('test360Stats');

    if(poolNumbers.length === 0 || !combinedScores){
      finalOut.value = '';
      statsEl.innerHTML = 'Run Panel 1 first (official draws → 1,200-sample engine) before generating the final 60.';
      return;
    }

    // Build adjusted scores:
    // base = combinedScores (freq + gap + streak from official draws)
    // small boost if:
    //  - number is hot in tests (freqTest[n] ≥ 2)
    //  - number appears often in 360 internal draws
    const adjusted = Array(MAX_N+1).fill(0);

    const max360 = Math.max(...freq360.slice(1));
    for(let n=1;n<=MAX_N;n++){
      if(!poolNumbers.includes(n)){
        adjusted[n] = 0;
        continue;
      }
      let s = combinedScores[n] || 0.000001;

      // Boost for hot test numbers
      if(freqTest[n] >= 2){
        // 15% boost if it appears at least 2× in tests
        s *= 1.15;
      }

      // Boost for overlap with 360 analysis distribution
      if(max360 > 0 && freq360[n] > 0){
        const ratio360 = freq360[n] / max360; // 0..1
        // Up to +10% additional boost if it is strong in 360 distribution
        s *= (1 + 0.10 * ratio360);
      }

      adjusted[n] = s;
    }

    // Generate one batch of 60 tickets using adjusted scores
    const tickets60 = generateTickets(60, adjusted);
    lastFinal60Tickets = tickets60;

    finalOut.value = tickets60
      .map(t=>t.map(n=>String(n).padStart(2,'0')).join(' '))
      .join('\n');

    statsEl.innerHTML +=
      `<br><strong>Final 60-ticket batch generated.</strong> ` +
      `Weights used: official Cash Five streak/gap model + test hot numbers + 360 internal distribution. ` +
      `This does <em>not</em> change true lotto odds, but lines up your 60 tickets with your chosen patterns.`;
  }

  function printFinal60(){
    // Simple browser print hook; user can print the page and cut the 60-ticket block.
    window.print();
  }

  function clearAll(){
    document.getElementById('lastDraws60').value = '';
    document.getElementById('bulkTickets').value = '';
    document.getElementById('simTickets').value = '';
    document.getElementById('tenTicketsOut').value = '';
    document.getElementById('testDrawsInput').value = '';
    document.getElementById('test360Out').value = '';
    document.getElementById('final60Out').value = '';

    document.getElementById('bulkStats').innerHTML =
      'Waiting for data: paste your official draws and run the analysis to see pool size, frequency statistics, ' +
      'probability bands, and the streak/gap model.';
    document.getElementById('scoreBands').innerHTML =
      '<span class="pill">No probabilities yet — run Panel 1 first.</span>';
    document.getElementById('modelTopNumbers').innerHTML =
      '<span class="pill">Run analysis to see the top-weight numbers.</span>';
    document.querySelector('#statsTable tbody').innerHTML = '';
    document.getElementById('compareStats').innerHTML =
      'After running Panel 1, paste your 60 tickets here and click ' +
      '<strong>Compare distributions</strong> to see deviations and top over-used / under-used numbers.';
    document.getElementById('spreadDiag').className = 'spread';
    document.getElementById('spreadDiag').textContent =
      'Spread diagnostic will appear here (tight / balanced / loose) after generation.';
    document.getElementById('test360Stats').innerHTML =
      'After you paste the 6 test draws and run the analysis, you will see: ' +
      '(1) hot numbers in tests, (2) how often they appear in 360 draws and 1,200 samples, and ' +
      '(3) repeated test pairs.';

    poolNumbers = [];
    officialFreq = Array(MAX_N+1).fill(0);
    sampleFreq   = Array(MAX_N+1).fill(0);
    combinedScores = null;
    usageCounts = Array(MAX_N+1).fill(0);

    lastSeen   = Array(MAX_N+1).fill(-1);
    recency    = Array(MAX_N+1).fill(0);
    maxRun     = Array(MAX_N+1).fill(0);
    runs3Plus  = Array(MAX_N+1).fill(0);
    modelScore = Array(MAX_N+1).fill(0);

    freqTest   = Array(MAX_N+1).fill(0);
    freq360    = Array(MAX_N+1).fill(0);
    testPairs  = {};
    lastFinal60Tickets = [];
  }
</script>
</body>
</html>
