<!-- ======================= PART 1 / 4 =======================
CST AIC Warp Chip — Simple Live Simulator (Earth → Pluto)
Copy PART 1, then PART 2, PART 3, PART 4 into ONE .html file in order.
============================================================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST AIC Warp Chip — ECSK Mapping + Falsifiable Tests (Simple Live)</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#070b14;
    --panel:#0f172a;
    --panel2:#0b1222;
    --ink:#e5e7eb;
    --muted:#9aa4c7;
    --accent:#60a5fa;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --line:rgba(148,163,184,.22);
    --radius:16px;
    --shadow:0 18px 40px rgba(0,0,0,.45);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:radial-gradient(1200px 800px at 15% -10%, #14203b 0, var(--bg) 55%);
    color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{max-width:1280px;margin:18px auto;padding:14px}
  .topbar{
    display:flex;align-items:flex-end;justify-content:space-between;gap:12px;
    padding:14px 14px 10px;border:1px solid var(--line);border-radius:18px;
    background:linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.78));
    box-shadow:var(--shadow);
  }
  .brand{display:flex;flex-direction:column;gap:4px}
  .brand .h{font-weight:900;letter-spacing:.35px;font-size:20px}
  .brand .s{color:var(--muted);font-size:12px;line-height:1.35}
  .pillrow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:flex-end}
  .pill{
    display:flex;gap:10px;align-items:center;
    border:1px solid var(--line);border-radius:999px;
    padding:8px 10px;background:rgba(2,6,23,.35);
  }
  .pill .k{color:var(--muted);font-size:11px}
  .pill .v{font-family:var(--mono);font-size:12px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:14px;margin-top:14px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
  .card{
    background:linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.78));
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    padding:12px 14px;border-bottom:1px solid rgba(148,163,184,.18);
  }
  .card .hd .t{font-weight:850}
  .card .hd .mini{color:var(--muted);font-size:12px}
  .card .bd{padding:12px 14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .col{display:flex;flex-direction:column;gap:6px;min-width:140px}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  input[type="number"], select, input[type="text"]{
    width:100%;padding:9px 10px;border-radius:12px;
    border:1px solid rgba(148,163,184,.25);
    background:rgba(2,6,23,.45);color:var(--ink);
    outline:none;
  }
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  button{
    border:1px solid rgba(148,163,184,.26);
    background:rgba(2,6,23,.40);
    color:var(--ink);
    padding:10px 12px;border-radius:12px;
    cursor:pointer;
    font-weight:700;
  }
  button.primary{border-color:rgba(96,165,250,.45);background:rgba(96,165,250,.16)}
  button.good{border-color:rgba(52,211,153,.5);background:rgba(52,211,153,.14)}
  button.warn{border-color:rgba(251,191,36,.55);background:rgba(251,191,36,.14)}
  button.bad{border-color:rgba(251,113,133,.55);background:rgba(251,113,133,.14)}
  button:disabled{opacity:.5;cursor:not-allowed}
  .kv{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:7px 0;border-bottom:1px dashed rgba(148,163,184,.16)}
  .kv:last-child{border-bottom:none}
  .kv .k{color:var(--muted);font-size:12px}
  .kv .v{font-family:var(--mono);font-size:12px}
  .tag{
    font-size:11px;border:1px solid rgba(148,163,184,.22);
    padding:4px 8px;border-radius:999px;color:var(--muted);
    background:rgba(2,6,23,.25)
  }
  .status{
    display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    padding:10px 12px;border:1px solid rgba(148,163,184,.20);border-radius:14px;
    background:rgba(2,6,23,.35);
  }
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.good{background:var(--good)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--bad)}
  .mono{font-family:var(--mono)}
  .small{font-size:12px;color:var(--muted);line-height:1.4}
  .steps{display:flex;flex-direction:column;gap:10px}
  .step{
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.28);
    border-radius:16px;
    padding:10px 12px;
  }
  .step .st{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
  .step .st .n{font-weight:850}
  .step .st .b{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{
    height:10px;border-radius:999px;background:rgba(148,163,184,.15);
    overflow:hidden;border:1px solid rgba(148,163,184,.14)
  }
  .bar > i{display:block;height:100%;width:0%}
  .bar > i.good{background:rgba(52,211,153,.85)}
  .bar > i.warn{background:rgba(251,191,36,.85)}
  .bar > i.bad{background:rgba(251,113,133,.85)}
  .split{
    display:grid;grid-template-columns:1fr 1fr;gap:12px
  }
  @media (max-width: 980px){ .split{grid-template-columns:1fr} }
  canvas{
    width:100%;height:160px;background:rgba(2,6,23,.35);
    border:1px solid rgba(148,163,184,.18);border-radius:14px;
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="topbar">
    <div class="brand">
      <div class="h">CST AIC Warp Chip — Simple Live Simulator</div>
      <div class="s">
        No exotic math: this is a <b>test harness</b> to visualize ECSK mapping + falsifiable experiments + Earth→Pluto run.
        It produces <b>live readouts</b>, <b>ON/OFF states</b>, <b>stability auto-trim</b>, and <b>CSV export</b>.
      </div>
    </div>

    <div class="pillrow">
      <div class="pill"><div class="k">UTC</div><div class="v" id="clkUTC">--:--:--</div></div>
      <div class="pill"><div class="k">CST</div><div class="v" id="clkCST">--:--:--</div></div>
      <div class="pill"><div class="k">Ship (dilated)</div><div class="v" id="clkSHIP">--:--:--</div></div>
      <div class="pill"><div class="k">Interstellar</div><div class="v" id="clkIS">T+0.0s</div></div>
      <div class="pill"><div class="k">Mode</div><div class="v" id="modeLabel">Warp OFF</div></div>
      <div class="pill"><div class="k">Tunnel</div><div class="v" id="tunnelLabel">—</div></div>
    </div>
  </div>

  <div class="grid">

    <!-- LEFT: Mission + Controls -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">Step-Order Control Panel</div>
          <div class="mini">Start → stabilize → run tests → export results</div>
        </div>
        <span class="tag">Earth → Pluto</span>
      </div>

      <div class="bd">

        <div class="status" style="margin-bottom:12px">
          <span class="dot" id="dotStability"></span>
          <div>
            <div style="font-weight:850">Ship Stability: <span class="mono" id="stabilityLabel">—</span></div>
            <div class="small">Auto-trim will reduce Warp if stability drops.</div>
          </div>
        </div>

        <div class="step">
          <div class="st">
            <div class="n">Step 1 — Power / State</div>
            <div class="b">
              <span class="tag" id="tagPower">POWER: OFF</span>
              <span class="tag" id="tagCoherence">COHERENCE: OFF</span>
              <span class="tag" id="tagPhase">PHASE LOCK: OFF</span>
            </div>
          </div>
          <div class="btnrow">
            <button class="primary" id="btnPower">Power ON</button>
            <button id="btnStart" class="good" disabled>Start Run</button>
            <button id="btnStop" class="warn" disabled>Stop</button>
            <button id="btnReset" class="bad">Reset</button>
          </div>
          <div class="small" style="margin-top:8px">
            <b>Start Run</b> begins the live simulation tick. <b>Stop</b> freezes and finalizes CSV rows.
            <b>Reset</b> clears mission progress + charts + log.
          </div>
        </div>

        <div class="step">
          <div class="st">
            <div class="n">Step 2 — Warp Mode (only 1 & 2)</div>
            <div class="b">
              <span class="tag">Time-on-Target priority</span>
            </div>
          </div>

          <div class="row">
            <div class="col" style="min-width:180px">
              <label>Warp Drive</label>
              <select id="selWarp" disabled>
                <option value="0">OFF</option>
                <option value="1">Warp 1 (gentle)</option>
                <option value="2">Warp 2 (stronger)</option>
              </select>
            </div>
            <div class="col" style="flex:1">
              <label>Warp Index (simple knob)</label>
              <input id="rngWarp" type="range" min="0" max="100" value="0" disabled />
              <div class="small">Current: <span class="mono" id="warpIndexLabel">0</span> / 100</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="col">
              <label>Auto-Trim Stability</label>
              <select id="selAutoTrim" disabled>
                <option value="on">ON (recommended)</option>
                <option value="off">OFF (manual)</option>
              </select>
            </div>
            <div class="col">
              <label>Stability Target</label>
              <input id="rngStabTarget" type="range" min="60" max="95" value="82" disabled />
              <div class="small">Target: <span class="mono" id="stabTargetLabel">82</span> / 100</div>
            </div>
          </div>

          <div class="small" style="margin-top:8px">
            <b>Warp Index</b> increases “compression” (effective distance reduction) and also increases instability risk.
            Auto-trim keeps the ship inside the tunnel by lowering Warp when needed.
          </div>
        </div>

        <div class="step">
          <div class="st">
            <div class="n">Step 3 — Wiring State (falsifiable)</div>
            <div class="b"><span class="tag">ON / OFF / Coherence-Kill</span></div>
          </div>

          <div class="row">
            <div class="col">
              <label>Wiring State</label>
              <select id="selWiring" disabled>
                <option value="off">OFF (all quiet)</option>
                <option value="on">ON (coherent)</option>
                <option value="kill">COHERENCE-KILL (same power, phase scrambled)</option>
              </select>
            </div>
            <div class="col">
              <label>Spin Polarity</label>
              <select id="selSpin" disabled>
                <option value="+1">+ (spin forward)</option>
                <option value="-1">− (spin reversed)</option>
              </select>
            </div>
          </div>

          <div class="small" style="margin-top:8px">
            <b>Coherence-Kill</b> is your best “null test” state: it keeps power similar while breaking phase order.
            If a signal survives coherence-kill unchanged, it’s likely not the effect you want.
          </div>
        </div>

      </div>
    </div>

    <!-- RIGHT: Mission Live Readouts -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">Live Mission Readouts</div>
          <div class="mini">Earth & Pluto are moving; we track “time on target” + stability</div>
        </div>
        <span class="tag" id="runTag">RUN: IDLE</span>
      </div>

      <div class="bd">
        <div class="split">

          <div class="card" style="box-shadow:none;border-radius:16px">
            <div class="hd"><div class="t">Trip: Earth → Pluto (simple moving-target)</div><div class="mini">distance updates live</div></div>
            <div class="bd">
              <div class="kv"><div class="k">Current Distance (km)</div><div class="v" id="distNow">—</div></div>
              <div class="kv"><div class="k">Effective Compression</div><div class="v" id="compressionNow">—</div></div>
              <div class="kv"><div class="k">Effective Distance (km)</div><div class="v" id="distEff">—</div></div>
              <div class="kv"><div class="k">Speed (simple, km/s)</div><div class="v" id="speedNow">—</div></div>
              <div class="kv"><div class="k">Progress</div><div class="v" id="progressNow">—</div></div>
              <div class="kv"><div class="k">ETA (Earth frame)</div><div class="v" id="etaNow">—</div></div>
              <div class="kv"><div class="k">Arrival (CST)</div><div class="v" id="arrivalCST">—</div></div>
            </div>
          </div>

          <div class="card" style="box-shadow:none;border-radius:16px">
            <div class="hd"><div class="t">Warp Curvature / Tunnel</div><div class="mini">simple “health” model</div></div>
            <div class="bd">
              <div class="kv"><div class="k">Warp Curvature (arb)</div><div class="v" id="curvNow">—</div></div>
              <div class="kv"><div class="k">Compression (arb)</div><div class="v" id="compMetricNow">—</div></div>
              <div class="kv"><div class="k">Tunnel Lock</div><div class="v" id="lockNow">—</div></div>
              <div class="kv"><div class="k">Auto-Trim Action</div><div class="v" id="trimNow">—</div></div>

              <div style="margin-top:10px">
                <div class="small" style="margin-bottom:6px">Stability Meter</div>
                <div class="bar"><i id="barStab"></i></div>
                <div class="small" style="margin-top:8px">
                  Stability comes from <b>coherence</b>, <b>phase lock</b>, and <b>thermal headroom</b>.
                  Warp Index raises compression but also stress.
                </div>
              </div>
            </div>
          </div>

        </div>

        <div style="margin-top:12px" class="card">
          <div class="hd">
            <div>
              <div class="t">Live Log (what steps are doing)</div>
              <div class="mini">You can print/export results later</div>
            </div>
            <div class="row">
              <button id="btnExport" disabled>Export CSV</button>
              <button id="btnPrint" disabled>Print Report</button>
            </div>
          </div>
          <div class="bd">
            <div id="log" class="mono" style="font-size:12px;line-height:1.45;max-height:210px;overflow:auto;white-space:pre-wrap"></div>
          </div>
        </div>

      </div>
    </div>

  </div><!-- /grid -->

</div><!-- /wrap -->
<!-- PART 2 starts below -->
<!-- ======================= PART 2 / 4 =======================
ECSK mapping + chip layers + Λeff amplifier + sensors
============================================================= -->
<div class="wrap" style="margin-top:0;padding-top:0">

  <div class="grid">

    <!-- LEFT: ECSK mapping -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">0) m = E/c² Framing (Chip Language)</div>
          <div class="mini">Simple: energy-density + spin-order → “gravity-like” knobs</div>
        </div>
        <span class="tag">No exotic math</span>
      </div>
      <div class="bd">
        <div class="small">
          In this simulator, we treat your warp chip as an <b>energy-and-spin organizer</b>:
          <ul style="margin:8px 0 0 18px;color:var(--muted)">
            <li><b>Energy density (E)</b> is what you can pump and shape (excitons, correlated electrons).</li>
            <li><b>Spin density</b> is what you can reverse (+ / −) to target torsion-like signatures.</li>
            <li><b>Phase coherence</b> is what separates “just heating” from “structured state.”</li>
          </ul>
          The key falsifiable trick: <b>coherence-kill</b> keeps power similar while scrambling phase.
        </div>

        <div style="margin-top:12px" class="step">
          <div class="st">
            <div class="n">1) ECSK Field Terms (plain labels)</div>
            <div class="b"><span class="tag">what the layers “stand for”</span></div>
          </div>
          <div class="kv"><div class="k">Metric / Curvature (geometry)</div><div class="v">“How space-time bends” (we show as Warp Curvature)</div></div>
          <div class="kv"><div class="k">Stress-Energy</div><div class="v">Energy & pressure you engineer (we show as Compression / Load)</div></div>
          <div class="kv"><div class="k">Spin Density (torsion source)</div><div class="v">Spin polarity (+/−) + ordered spin current</div></div>
          <div class="kv"><div class="k">Λeff (effective vacuum term)</div><div class="v">Amplified “vacuum-like” response in correlated layer</div></div>
        </div>

      </div>
    </div>

    <!-- RIGHT: chip layers mapping -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">1) Map Each Chip Layer → ECSK Role</div>
          <div class="mini">Explicit mapping (but explained in plain terms)</div>
        </div>
        <span class="tag">AIC stack</span>
      </div>
      <div class="bd">

        <div class="steps">
          <div class="step">
            <div class="st">
              <div class="n">A) Coherence Shield (Bi₂Se₃)</div>
              <div class="b"><span class="tag">stability enabler</span></div>
            </div>
            <div class="small">
              Keeps coherence alive (reduces decoherence). In ECSK terms: supports stable “energy structure” and spin order so signals can be measured.
            </div>
          </div>

          <div class="step">
            <div class="st">
              <div class="n">Pump Injector (nanolaser array)</div>
              <div class="b"><span class="tag">energy knob</span></div>
            </div>
            <div class="small">
              Controls exciton population (energy density). In tests we modulate this at a known frequency so any real effect becomes phase-locked.
            </div>
          </div>

          <div class="step">
            <div class="st">
              <div class="n">B) Exciton Resonator (WS₂)</div>
              <div class="b"><span class="tag">Λeff “fuel”</span></div>
            </div>
            <div class="small">
              Holds coherent energy density. If anything contributes to a “vacuum-like” term, it starts with coherent exciton energy (not heat).
            </div>
          </div>

          <div class="step">
            <div class="st">
              <div class="n">C) Metric Modulation Layer (Magic-Angle Graphene / correlated)</div>
              <div class="b"><span class="tag">Λeff amplifier</span><span class="tag">big response</span></div>
            </div>
            <div class="small">
              This is the best place to amplify Λeff: correlated phases can respond strongly to small control changes. In the sim this layer boosts compression and curvature response.
            </div>
          </div>

          <div class="step">
            <div class="st">
              <div class="n">E) Phase Anchoring (AlN)</div>
              <div class="b"><span class="tag">measurable & stable</span></div>
            </div>
            <div class="small">
              Phase lock + strain anchoring: turns coherence into a stable, measurable configuration. In the sim this improves tunnel lock and helps distinguish real signals from drift.
            </div>
          </div>

          <div class="step">
            <div class="st">
              <div class="n">Thermal Dissipation (graphene + substrate)</div>
              <div class="b"><span class="tag">kills false positives</span></div>
            </div>
            <div class="small">
              Prevents “everything is heat.” Thermal gradients can fake clock drift and optics. In the sim, heat increases instability and adds nuisance drift.
            </div>
          </div>
        </div>

      </div>
    </div>

  </div><!-- /grid -->

  <div class="grid" style="margin-top:14px">

    <!-- LEFT: Which layer amplifies Λeff -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">2) Which Layer Must Amplify Λeff?</div>
          <div class="mini">We show a simple “Λeff gain” knob internally</div>
        </div>
        <span class="tag">Answer: correlated layer</span>
      </div>
      <div class="bd">
        <div class="kv"><div class="k">Primary Λeff Amplifier</div><div class="v"><b>Magic-Angle / correlated layer</b> (big response to control)</div></div>
        <div class="kv"><div class="k">Second Critical Candidate</div><div class="v"><b>WS₂ exciton resonator</b> (coherent energy “fuel”)</div></div>
        <div class="kv"><div class="k">Measurable Enabler</div><div class="v"><b>AlN phase anchoring</b> (lock-in stability + reduces drift)</div></div>

        <div class="small" style="margin-top:10px">
          In this simulator, Λeff is not “proved.” It is a <b>hypothesis knob</b>:
          you test whether <b>coherence-dependent, spin-sign-dependent signals</b> appear in Experiments A/B/C,
          and whether they disappear under <b>coherence-kill</b> and <b>dummy stack</b> controls.
        </div>
      </div>
    </div>

    <!-- RIGHT: Sensors + Readouts -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">Required Sensors (live, simulated)</div>
          <div class="mini">These are the instruments that protect falsifiability</div>
        </div>
        <span class="tag">Magnetometer · Thermistors · Photodiodes</span>
      </div>
      <div class="bd">
        <div class="kv"><div class="k">Magnetometer B (µT)</div><div class="v" id="sensB">—</div></div>
        <div class="kv"><div class="k">Thermistors (°C)</div><div class="v" id="sensT">—</div></div>
        <div class="kv"><div class="k">Photodiode Intensity (a.u.)</div><div class="v" id="sensPD">—</div></div>
        <div class="kv"><div class="k">Spin Current (a.u.)</div><div class="v" id="sensSpin">—</div></div>
        <div class="kv"><div class="k">Coherence (0–1)</div><div class="v" id="sensCoh">—</div></div>

        <div class="small" style="margin-top:10px">
          <b>Pass/Fail rule idea:</b> if your “signal” tracks magnetometer B or temperature drift,
          it’s likely EM/thermal. If it tracks <b>coherence state</b> and flips with <b>spin polarity</b>,
          it’s worth deeper investigation.
        </div>
      </div>
    </div>

  </div><!-- /grid -->

</div><!-- /wrap -->
<!-- PART 3 starts below -->
<!-- ======================= PART 3 / 4 =======================
Experiments A/B/C panels + charts + controls
============================================================= -->
<div class="wrap" style="margin-top:0;padding-top:0">

  <div class="card">
    <div class="hd">
      <div>
        <div class="t">3) First Falsifiable Experiments (live simulation)</div>
        <div class="mini">Each includes: prediction · null hypothesis · controls · win condition</div>
      </div>
      <span class="tag">Lock-in style (phase-locked modulation)</span>
    </div>
    <div class="bd">

      <div class="split">

        <!-- Experiment A -->
        <div class="card" style="box-shadow:none;border-radius:16px">
          <div class="hd">
            <div>
              <div class="t">Experiment A — Time-of-Flight Asymmetry</div>
              <div class="mini">photonic CW vs CCW difference (Sagnac-style)</div>
            </div>
            <span class="tag" id="tagA">A: IDLE</span>
          </div>
          <div class="bd">
            <div class="row">
              <div class="col">
                <label>EM Shielding</label>
                <select id="aShield" disabled>
                  <option value="on">ON</option>
                  <option value="off">OFF</option>
                </select>
              </div>
              <div class="col">
                <label>Dummy Stack</label>
                <select id="aDummy" disabled>
                  <option value="off">OFF</option>
                  <option value="on">ON</option>
                </select>
              </div>
              <div class="col">
                <label>Lock-in Modulation</label>
                <select id="aLockin" disabled>
                  <option value="on">ON</option>
                  <option value="off">OFF</option>
                </select>
              </div>
            </div>

            <div style="margin-top:10px" class="kv"><div class="k">Δt (ps) (sim)</div><div class="v" id="aDt">—</div></div>
            <div class="kv"><div class="k">Δφ (mrad) (sim)</div><div class="v" id="aDphi">—</div></div>
            <div class="kv"><div class="k">A-Signal Type</div><div class="v" id="aType">—</div></div>

            <canvas id="plotA" width="900" height="240"></canvas>

            <div class="small" style="margin-top:10px">
              <b>Prediction:</b> Δt/Δφ should be <b>phase-locked</b>, <b>coherence-dependent</b>, and may flip sign with <b>spin polarity</b>.<br/>
              <b>Null hypothesis:</b> signal is EM (B-field) or thermal drift in optics.<br/>
              <b>Controls:</b> Shielding ON, Dummy stack ON, Coherence-Kill wiring state.<br/>
              <b>Win condition:</b> survives controls, disappears in coherence-kill, flips with spin.
            </div>
          </div>
        </div>

        <!-- Experiment B -->
        <div class="card" style="box-shadow:none;border-radius:16px">
          <div class="hd">
            <div>
              <div class="t">Experiment B — Phase-Locked Clock Drift</div>
              <div class="mini">near cavity vs reference cavity beat note</div>
            </div>
            <span class="tag" id="tagB">B: IDLE</span>
          </div>
          <div class="bd">
            <div class="row">
              <div class="col">
                <label>Thermal Isolation</label>
                <select id="bThermIso" disabled>
                  <option value="high">HIGH</option>
                  <option value="low">LOW</option>
                </select>
              </div>
              <div class="col">
                <label>Reference Distance</label>
                <select id="bRefDist" disabled>
                  <option value="near">Near</option>
                  <option value="far">Far</option>
                </select>
              </div>
              <div class="col">
                <label>Heater Control</label>
                <select id="bHeater" disabled>
                  <option value="off">OFF</option>
                  <option value="on">ON</option>
                </select>
              </div>
            </div>

            <div style="margin-top:10px" class="kv"><div class="k">Δf (Hz) (sim)</div><div class="v" id="bDf">—</div></div>
            <div class="kv"><div class="k">Fractional Δf/f (×1e-12) (sim)</div><div class="v" id="bFrac">—</div></div>
            <div class="kv"><div class="k">B-Signal Type</div><div class="v" id="bType">—</div></div>

            <canvas id="plotB" width="900" height="240"></canvas>

            <div class="small" style="margin-top:10px">
              <b>Prediction:</b> beat drift tracks <b>coherence</b> + modulation more than temperature.<br/>
              <b>Null hypothesis:</b> thermal expansion/refractive drift.<br/>
              <b>Controls:</b> heater-only control, higher thermal isolation, farther reference.<br/>
              <b>Win condition:</b> coherence-dependent drift that survives heater control.
            </div>
          </div>
        </div>

      </div><!-- /split -->

      <div class="split" style="margin-top:14px">

        <!-- Experiment C -->
        <div class="card" style="box-shadow:none;border-radius:16px">
          <div class="hd">
            <div>
              <div class="t">Experiment C — Inertial Mass Modulation / Force Residual</div>
              <div class="mini">MEMS resonance shift + nearby proof-mass option</div>
            </div>
            <span class="tag" id="tagC">C: IDLE</span>
          </div>
          <div class="bd">
            <div class="row">
              <div class="col">
                <label>Setup Mode</label>
                <select id="cMode" disabled>
                  <option value="mems">Device as MEMS resonator</option>
                  <option value="proof">Nearby proof mass</option>
                </select>
              </div>
              <div class="col">
                <label>Vacuum Chamber</label>
                <select id="cVac" disabled>
                  <option value="on">ON</option>
                  <option value="off">OFF</option>
                </select>
              </div>
              <div class="col">
                <label>Magnetic Shield</label>
                <select id="cMagShield" disabled>
                  <option value="on">ON</option>
                  <option value="off">OFF</option>
                </select>
              </div>
            </div>

            <div style="margin-top:10px" class="kv"><div class="k">Δf₀ (mHz) (sim)</div><div class="v" id="cDf0">—</div></div>
            <div class="kv"><div class="k">Residual Force (nN) (sim)</div><div class="v" id="cForce">—</div></div>
            <div class="kv"><div class="k">C-Signal Type</div><div class="v" id="cType">—</div></div>

            <canvas id="plotC" width="900" height="240"></canvas>

            <div class="small" style="margin-top:10px">
              <b>Prediction:</b> coherence-dependent shift/force that changes with <b>spin polarity</b>.<br/>
              <b>Null hypothesis:</b> vibrations, air currents, EM forces, heating.<br/>
              <b>Controls:</b> vacuum ON, magnetic shield ON, heater-only control, coherence-kill.<br/>
              <b>Win condition:</b> signal survives vacuum+shield and disappears in coherence-kill.
            </div>
          </div>
        </div>

        <!-- Milestone spec -->
        <div class="card" style="box-shadow:none;border-radius:16px">
          <div class="hd">
            <div>
              <div class="t">4–5) Spin-Torsion Target + First Milestone Spec</div>
              <div class="mini">What “counts” as a real next step</div>
            </div>
            <span class="tag">Pass/Fail Rules</span>
          </div>
          <div class="bd">
            <div class="step" style="margin-bottom:10px">
              <div class="st">
                <div class="n">4) Spin-Torsion Beyond GR (simple fingerprint)</div>
                <div class="b"><span class="tag">sign flip test</span></div>
              </div>
              <div class="small">
                A torsion-like signature should often <b>flip sign</b> when you reverse spin polarity.
                Heat usually won’t. Some EM artifacts can flip too, so you must log <b>B-field</b> and use shielding/dummy controls.
              </div>
            </div>

            <div class="step">
              <div class="st">
                <div class="n">5) First Milestone Spec (what “wins”)</div>
                <div class="b"><span class="tag">coherence-dependent</span><span class="tag">spin-sign-dependent</span></div>
              </div>
              <div class="small">
                <b>Milestone:</b> show a lock-in tracked signal in A or B or C that:
                <ul style="margin:8px 0 0 18px;color:var(--muted)">
                  <li>Tracks <b>coherence ON</b> vs <b>coherence-kill</b> (drops strongly in kill).</li>
                  <li>Changes sign with <b>spin polarity reversal</b>.</li>
                  <li>Does <b>not</b> track thermometer drift or magnetometer B as the main driver.</li>
                  <li>Repeats across runs and exports cleanly to CSV.</li>
                </ul>
              </div>
            </div>

            <div style="margin-top:12px" class="status">
              <span class="dot" id="dotPass"></span>
              <div>
                <div style="font-weight:900">Current Pass/Fail: <span class="mono" id="passFail">—</span></div>
                <div class="small">This uses the simple acceptance criteria in the code (editable).</div>
              </div>
            </div>

          </div>
        </div>

      </div><!-- /split -->

    </div>
  </div>

</div><!-- /wrap -->
<!-- PART 4 starts below -->
<!-- ======================= PART 4 / 4 =======================
JavaScript: live clocks, mission model, experiments, stability auto-trim, CSV export
============================================================= -->
<script>
/* ============================================================
   CST AIC Warp Chip — Simple Live Simulator
   - No exotic equations: only simple knobs + moving-target distance.
   - Provides: ON/OFF/coherence-kill, warp 1/2, stability auto-trim,
     experiments A/B/C, sensors, CSV export, print report.
============================================================ */

const $ = (id)=>document.getElementById(id);

// ---------- UI refs ----------
const clkUTC = $("clkUTC"), clkCST = $("clkCST"), clkSHIP = $("clkSHIP"), clkIS = $("clkIS");
const modeLabel = $("modeLabel"), tunnelLabel = $("tunnelLabel");

const btnPower = $("btnPower"), btnStart = $("btnStart"), btnStop = $("btnStop"), btnReset = $("btnReset");
const selWarp = $("selWarp"), rngWarp = $("rngWarp"), warpIndexLabel = $("warpIndexLabel");
const selAutoTrim = $("selAutoTrim"), rngStabTarget = $("rngStabTarget"), stabTargetLabel = $("stabTargetLabel");
const selWiring = $("selWiring"), selSpin = $("selSpin");

const tagPower = $("tagPower"), tagCoherence = $("tagCoherence"), tagPhase = $("tagPhase");
const runTag = $("runTag");
const dotStability = $("dotStability"), stabilityLabel = $("stabilityLabel"), barStab = $("barStab");
const distNow = $("distNow"), compressionNow = $("compressionNow"), distEff = $("distEff");
const speedNow = $("speedNow"), progressNow = $("progressNow"), etaNow = $("etaNow"), arrivalCST = $("arrivalCST");
const curvNow = $("curvNow"), compMetricNow = $("compMetricNow"), lockNow = $("lockNow"), trimNow = $("trimNow");
const logEl = $("log");

const btnExport = $("btnExport"), btnPrint = $("btnPrint");

const sensB = $("sensB"), sensT = $("sensT"), sensPD = $("sensPD"), sensSpin = $("sensSpin"), sensCoh = $("sensCoh");

const aShield = $("aShield"), aDummy = $("aDummy"), aLockin = $("aLockin");
const aDt = $("aDt"), aDphi = $("aDphi"), aType = $("aType"), tagA = $("tagA");

const bThermIso = $("bThermIso"), bRefDist = $("bRefDist"), bHeater = $("bHeater");
const bDf = $("bDf"), bFrac = $("bFrac"), bType = $("bType"), tagB = $("tagB");

const cMode = $("cMode"), cVac = $("cVac"), cMagShield = $("cMagShield");
const cDf0 = $("cDf0"), cForce = $("cForce"), cType = $("cType"), tagC = $("tagC");

const dotPass = $("dotPass"), passFail = $("passFail");

// ---------- plots ----------
const plotA = $("plotA"), plotB = $("plotB"), plotC = $("plotC");

// ---------- simple helpers ----------
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(n, d=2){
  if (!isFinite(n)) return "—";
  const abs = Math.abs(n);
  if (abs >= 1e12) return n.toExponential(3);
  if (abs >= 1e6) return n.toFixed(0);
  if (abs >= 1e3) return n.toFixed(1);
  return n.toFixed(d);
}
function pad2(x){ return String(x).padStart(2,"0"); }
function hhmmss(date){
  return `${pad2(date.getHours())}:${pad2(date.getMinutes())}:${pad2(date.getSeconds())}`;
}
function log(msg){
  const t = new Date();
  logEl.textContent = `[${hhmmss(t)}] ${msg}\n` + logEl.textContent;
}

// ---------- simulation state ----------
let powered = false;
let running = false;

let sim = {
  // time
  t: 0,           // seconds since start (earth frame)
  tShip: 0,       // seconds ship proper time (dilated)
  dt: 0.25,       // seconds per tick (real time)
  // mission
  progress: 0,    // 0..1 along effective path
  arrived: false,
  // controls
  warpMode: 0,    // 0/1/2
  warpIndex: 0,   // 0..100
  autoTrim: true,
  stabTarget: 82,
  wiring: "off",  // off/on/kill
  spin: +1,       // +1 or -1
  // derived / sensors
  coherence: 0,
  phaseLock: 0,
  tempC: 24.0,
  b_uT: 0.4,
  pd: 0.0,
  spinCurrent: 0.0,
  // metrics
  stability: 0,
  tunnelLock: 0, // 0..1
  curvature: 0,
  compression: 1.0,
  // trip geometry
  dist_km: 0,
  distEff_km: 0,
  speed_kms: 0,
  eta_s: Infinity,
  arrivalDateCST: null,
  // experiments
  A: { dt_ps: 0, dphi_mrad: 0, type:"—" },
  B: { df_Hz: 0, frac_1e12: 0, type:"—" },
  C: { df0_mHz: 0, force_nN: 0, type:"—" },
  // acceptance
  accept: { pass:false, reason:"—" },
  // csv rows
  csv: []
};

// ---------- constants (simple) ----------
const AU_km = 149_597_870;     // km
const c_kms = 299_792.458;     // km/s

// circular orbit toy model (good enough for a “moving target” demo)
const earth = { r: 1.0*AU_km,  period_days: 365.256 };
const pluto = { r: 39.48*AU_km, period_days: 90560 }; // ~248 years
const wE = (2*Math.PI) / (earth.period_days*86400);
const wP = (2*Math.PI) / (pluto.period_days*86400);

// ---------- plot buffers ----------
function makeSeries(n=260){ return Array.from({length:n}, ()=>0); }
const seriesA = makeSeries(), seriesB = makeSeries(), seriesC = makeSeries();

function drawPlot(canvas, series, labelLeft, valueStr){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "rgba(2,6,23,0.35)";
  ctx.fillRect(0,0,w,h);

  // grid
  ctx.strokeStyle = "rgba(148,163,184,0.15)";
  ctx.lineWidth = 1;
  for(let i=1;i<6;i++){
    const y = (h*i)/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let i=1;i<10;i++){
    const x = (w*i)/10;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  // scale series to plot
  let min=Infinity,max=-Infinity;
  for(const v of series){ min=Math.min(min,v); max=Math.max(max,v); }
  if (!isFinite(min) || !isFinite(max) || min===max){ min-=1; max+=1; }
  const pad = (max-min)*0.15;
  min-=pad; max+=pad;

  ctx.strokeStyle = "rgba(96,165,250,0.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<series.length;i++){
    const x = (i/(series.length-1))*w;
    const t = (series[i]-min)/(max-min);
    const y = h - t*h;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(229,231,235,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText(labelLeft, 10, 18);
  ctx.fillText(valueStr, 10, 36);

  ctx.fillStyle = "rgba(159,170,199,0.9)";
  ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
  ctx.fillText(`min=${fmt(min,3)}  max=${fmt(max,3)}`, 10, h-10);
}

// ---------- clocks ----------
function updateClocks(){
  const now = new Date();

  // UTC clock
  const utc = new Date(now.getTime() + now.getTimezoneOffset()*60*1000);
  clkUTC.textContent = hhmmss(utc);

  // CST fixed offset (-06:00) as requested
  const cst = new Date(utc.getTime() - 6*3600*1000);
  clkCST.textContent = hhmmss(cst);

  // ship clock: CST time + dilation factor (simple)
  const dil = getDilationFactor();
  // Ship “proper time” runs slower when dilation<1
  // We display a clock derived from CST plus ship elapsed
  const ship = new Date(cst.getTime() + sim.tShip*1000);
  clkSHIP.textContent = `${hhmmss(ship)}  (×${fmt(dil,3)})`;

  // Interstellar time = mission T+ plus ship time ratio
  clkIS.textContent = `T+${fmt(sim.t,1)}s  |  τ+${fmt(sim.tShip,1)}s`;
}

function getDilationFactor(){
  // simple: more compression -> stronger “time dilation”
  // keep it gentle and readable
  const x = sim.warpMode===0 ? 0 : sim.warpIndex/100;
  const modeBoost = sim.warpMode===1 ? 0.20 : (sim.warpMode===2 ? 0.35 : 0);
  const dil = 1 / (1 + modeBoost * x); // 1.0 down to ~0.74
  return clamp(dil, 0.60, 1.0);
}

// ---------- mission model ----------
function computeDistance_km(t){
  // circular positions (toy) in the same plane
  const thE = wE*t;
  const thP = wP*t + 1.2; // phase offset so not always aligned
  const xE = earth.r*Math.cos(thE), yE = earth.r*Math.sin(thE);
  const xP = pluto.r*Math.cos(thP), yP = pluto.r*Math.sin(thP);
  const dx = xP-xE, dy = yP-yE;
  return Math.sqrt(dx*dx + dy*dy);
}

function computeCompression(){
  // OFF: 1.0 (no compression)
  if (sim.warpMode===0 || sim.warpIndex<=0) return 1.0;

  const x = sim.warpIndex/100;         // 0..1
  const modeGain = sim.warpMode===1 ? 2.0 : 3.2; // Warp 2 compresses more
  // correlated layer = "Λeff amplifier" -> more compression when coherent + phase locked
  const amp = 1.0 + 0.90*sim.coherence + 0.65*sim.phaseLock; // 1..~2.55
  const comp = 1.0 + modeGain * x * amp; // 1..~9-ish
  return clamp(comp, 1.0, 12.0);
}

function computeSpeed_kms(){
  // simple “effective speed” based on warp mode and stability
  if (sim.warpMode===0 || sim.warpIndex<=0) return 0;

  const x = sim.warpIndex/100;
  // base fraction of c (kept moderate for a demo)
  const baseFrac = sim.warpMode===1 ? 0.0030 : 0.0060; // 0.3% c or 0.6% c
  // stability reduces usable speed if unstable
  const stabFactor = clamp(sim.stability/100, 0.25, 1.0);
  // coherence helps
  const cohFactor = lerp(0.6, 1.05, sim.coherence);
  return c_kms * baseFrac * x * stabFactor * cohFactor;
}

function updateProgress(){
  // update distance (moving target)
  sim.dist_km = computeDistance_km(sim.t);

  // compression and effective distance
  sim.compression = computeCompression();
  sim.distEff_km = sim.dist_km / sim.compression;

  // speed
  sim.speed_kms = computeSpeed_kms();

  // progress increment on effective distance axis
  if (sim.speed_kms > 0 && !sim.arrived){
    const dt = sim.dt;
    const dfrac = (sim.speed_kms*dt) / Math.max(sim.distEff_km, 1);
    sim.progress = clamp(sim.progress + dfrac, 0, 1);

    if (sim.progress >= 1 && !sim.arrived){
      sim.arrived = true;
      log("ARRIVAL: Reached Pluto target (effective path).");
    }
  }

  // eta estimate
  if (sim.speed_kms > 0 && sim.progress < 1){
    const remain = (1 - sim.progress) * sim.distEff_km;
    sim.eta_s = remain / sim.speed_kms;
  } else {
    sim.eta_s = sim.arrived ? 0 : Infinity;
  }

  // arrival time CST
  if (isFinite(sim.eta_s)){
    const nowUTC = new Date(Date.now() + new Date().getTimezoneOffset()*60*1000);
    const nowCST = new Date(nowUTC.getTime() - 6*3600*1000);
    sim.arrivalDateCST = new Date(nowCST.getTime() + sim.eta_s*1000);
  } else {
    sim.arrivalDateCST = null;
  }
}

// ---------- stability + auto-trim ----------
function updateCoherencePhase(){
  // wiring state drives coherence & phase lock
  // ON: strong coherence, KILL: power present but scrambled
  const warpOn = (sim.warpMode!==0 && sim.warpIndex>0);
  const base = powered ? 1 : 0;

  if (!powered){
    sim.coherence = 0;
    sim.phaseLock = 0;
    return;
  }

  if (sim.wiring==="off"){
    sim.coherence = lerp(sim.coherence, 0.05*base, 0.08);
    sim.phaseLock = lerp(sim.phaseLock, 0.10*base, 0.08);
  } else if (sim.wiring==="on"){
    // coherence rises, phase locks more if warp is on
    const cohTarget = 0.72 + (warpOn ? 0.18 : 0.08);
    const phTarget  = 0.65 + (warpOn ? 0.22 : 0.10);
    sim.coherence = lerp(sim.coherence, cohTarget, 0.08);
    sim.phaseLock = lerp(sim.phaseLock, phTarget, 0.08);
  } else { // kill
    const cohTarget = 0.18 + (warpOn ? 0.05 : 0.02);
    const phTarget  = 0.10 + (warpOn ? 0.03 : 0.02);
    sim.coherence = lerp(sim.coherence, cohTarget, 0.10);
    sim.phaseLock = lerp(sim.phaseLock, phTarget, 0.10);
  }
}

function updateThermal(){
  // simple thermal: warp & pump raise temp; dissipation pulls it down
  const warpLoad = (sim.warpMode===0) ? 0 : (sim.warpIndex/100) * (sim.warpMode===1 ? 0.9 : 1.4);
  const coherenceHeat = (sim.wiring==="on") ? 0.6 : 0.3;
  const heatIn = powered ? (0.12 + 0.55*warpLoad + 0.25*coherenceHeat) : 0;
  const coolOut = 0.10 + 0.03*(sim.tempC-24);
  sim.tempC = sim.tempC + heatIn - coolOut;
  sim.tempC = clamp(sim.tempC, 22, 88);
}

function updateSensors(){
  // magnetometer: depends on spinCurrent + shielding
  const shieldFactor = (aShield.value==="on" && cMagShield.value==="on") ? 0.35 : 1.0;

  // spin current: warp + wiring + polarity
  const warpOn = sim.warpMode!==0 && sim.warpIndex>0;
  const x = sim.warpIndex/100;
  let sc = 0;
  if (powered && warpOn){
    sc = (0.8*x + 0.4*sim.coherence) * sim.spin;
  } else sc = 0;
  sim.spinCurrent = sc;

  // B-field includes some nuisance + spin leakage
  const noise = (Math.random()-0.5)*0.05;
  sim.b_uT = 0.35 + shieldFactor*(0.22*Math.abs(sc)) + noise;

  // photodiode intensity: pump + coherence
  sim.pd = powered ? (0.15 + 0.75*sim.coherence + 0.15*x) : 0;
}

function updateStability(){
  // stability from coherence + phase lock - thermal - warp stress
  const x = sim.warpIndex/100;
  const warpStress = (sim.warpMode===0) ? 0 : (sim.warpMode===1 ? 18*x : 30*x);
  const thermalPenalty = Math.max(0, sim.tempC - 40) * 1.10; // penalty after 40°C
  const cohGain = 70*sim.coherence + 45*sim.phaseLock;
  let stab = 35 + cohGain - thermalPenalty - warpStress;

  // coherence-kill should feel unstable under warp
  if (sim.wiring==="kill" && sim.warpMode!==0 && sim.warpIndex>0) stab -= 18;

  sim.stability = clamp(stab, 0, 100);

  // tunnel lock (simple)
  sim.tunnelLock = clamp((sim.stability - 35)/55, 0, 1);

  // curvature/compression metrics (arb)
  sim.curvature = (sim.warpMode===0) ? 0 : (sim.warpIndex/100) * (0.8 + 1.8*sim.compression/6) * (0.6+0.8*sim.tunnelLock);
}

function autoTrim(){
  if (!sim.autoTrim || !running) { trimNow.textContent = "—"; return; }

  const target = sim.stabTarget;
  const s = sim.stability;

  let action = "None";
  // If unstable, reduce warp index and prefer Warp 1
  if (s < target - 6 && sim.warpIndex > 0){
    const drop = (target - s) * 0.8; // stronger when far below
    sim.warpIndex = clamp(sim.warpIndex - drop, 0, 100);
    action = `Reduce WarpIndex by ${fmt(drop,1)}`;

    // If very unstable, force Warp 1
    if (s < 55 && sim.warpMode===2){
      sim.warpMode = 1;
      action += " + force Warp 1";
    }
  }

  // If very stable, allow gentle climb (time on target)
  if (s > target + 10 && sim.warpMode!==0 && sim.wiring==="on"){
    const add = (s - target) * 0.15;
    sim.warpIndex = clamp(sim.warpIndex + add, 0, 100);
    action = `Increase WarpIndex by ${fmt(add,1)} (safe)`;
  }

  trimNow.textContent = action;
}

// ---------- experiments ----------
function expA(){
  // ToF asymmetry: desired signal depends on coherence, spin, warp, and should collapse under dummy or coherence-kill.
  const x = sim.warpIndex/100;
  const warpOn = sim.warpMode!==0 && x>0;
  const dummy = (aDummy.value==="on");
  const shield = (aShield.value==="on");
  const lockin = (aLockin.value==="on");

  // nuisance EM artifact tracks B-field; reduced by shielding
  const em = (shield ? 0.30 : 1.0) * (sim.b_uT - 0.35) * 0.9;

  // "torsion-like" / coherence-like component (hypothesis)
  const coh = (sim.wiring==="on") ? 1 : (sim.wiring==="kill" ? 0.25 : 0.10);
  let sig = warpOn ? (2.2 * coh * sim.coherence * sim.spin * x * (0.7+0.7*sim.tunnelLock)) : 0;

  // dummy stack kills the hypothesis signal
  if (dummy) sig *= 0.08;

  // lock-in makes it easier to see (we represent as less noise)
  const noise = (Math.random()-0.5) * (lockin ? 0.35 : 0.85);

  // combine
  const dphi_mrad = (sig + em + noise) * 4.0;     // mrad
  const dt_ps = dphi_mrad * 0.9;                  // ps (simple proportional)

  sim.A.dphi_mrad = dphi_mrad;
  sim.A.dt_ps = dt_ps;

  // classify
  if (!warpOn) sim.A.type = "OFF";
  else if (Math.abs(em) > Math.abs(sig)*1.3) sim.A.type = "EM-dominated (check shielding)";
  else if (sim.wiring==="kill") sim.A.type = "Coherence-Kill (should drop)";
  else sim.A.type = "Coherence/Spin candidate";

  // update UI + plot
  aDt.textContent = fmt(sim.A.dt_ps, 3);
  aDphi.textContent = fmt(sim.A.dphi_mrad, 3);
  aType.textContent = sim.A.type;

  seriesA.shift(); seriesA.push(sim.A.dphi_mrad);
  drawPlot(plotA, seriesA, "Δφ (mrad) vs time", `Δφ=${fmt(sim.A.dphi_mrad,3)}  |  Δt=${fmt(sim.A.dt_ps,3)} ps`);
  tagA.textContent = running ? "A: LIVE" : "A: IDLE";
}

function expB(){
  // clock drift: desired signal tracks coherence & warp; nuisance tracks temperature.
  const x = sim.warpIndex/100;
  const warpOn = sim.warpMode!==0 && x>0;

  const thermIso = bThermIso.value; // high/low
  const refDist = bRefDist.value;   // near/far
  const heater = (bHeater.value==="on");

  // thermal nuisance (bigger when isolation is low)
  const thermGain = (thermIso==="high") ? 0.35 : 1.0;
  const thermal = thermGain * (sim.tempC - 24) * 0.45;

  // "coherence candidate" drift
  const coh = (sim.wiring==="on") ? 1 : (sim.wiring==="kill" ? 0.20 : 0.08);
  let sig = warpOn ? (0.95 * coh * sim.coherence * sim.spin * x * (0.6+0.7*sim.tunnelLock)) : 0;

  // far reference reduces pickup of any near-field artifact
  if (refDist==="far") sig *= 0.75;

  // heater control adds thermal drift without coherence
  const heaterTerm = heater ? (0.9 * (sim.tempC - 24) * 0.55) : 0;

  const noise = (Math.random()-0.5) * 0.45;

  const df = (sig - thermal - heaterTerm + noise); // Hz (sim)
  sim.B.df_Hz = df;

  // fractional (sim): scale into 1e-12 for readability
  sim.B.frac_1e12 = df * 1.7;

  if (!warpOn) sim.B.type = "OFF";
  else if (Math.abs(thermal+heaterTerm) > Math.abs(sig)*1.2) sim.B.type = "Thermal-dominated (check thermistors)";
  else if (sim.wiring==="kill") sim.B.type = "Coherence-Kill (should drop)";
  else sim.B.type = "Coherence/Spin candidate";

  bDf.textContent = fmt(sim.B.df_Hz, 4);
  bFrac.textContent = fmt(sim.B.frac_1e12, 3);
  bType.textContent = sim.B.type;

  seriesB.shift(); seriesB.push(sim.B.df_Hz);
  drawPlot(plotB, seriesB, "Δf (Hz) vs time", `Δf=${fmt(sim.B.df_Hz,4)}  |  frac=${fmt(sim.B.frac_1e12,3)}×1e-12`);
  tagB.textContent = running ? "B: LIVE" : "B: IDLE";
}

function expC(){
  // inertial mass modulation / force residual
  const x = sim.warpIndex/100;
  const warpOn = sim.warpMode!==0 && x>0;

  const mode = cMode.value;      // mems/proof
  const vac = (cVac.value==="on");
  const magShield = (cMagShield.value==="on");

  // nuisance EM force tracks B; reduced by shielding
  const em = (magShield ? 0.30 : 1.0) * (sim.b_uT - 0.35) * 0.8;

  // nuisance air/vibration reduced in vacuum
  const air = (vac ? 0.20 : 1.0) * (Math.random()-0.5) * 0.9;

  // candidate term: coherence + spin + warp
  const coh = (sim.wiring==="on") ? 1 : (sim.wiring==="kill" ? 0.22 : 0.08);
  let sig = warpOn ? (1.1 * coh * sim.coherence * sim.spin * x * (0.6+0.8*sim.tunnelLock)) : 0;

  // convert to either df0 or force (sim)
  let df0_mHz = (sig - 0.6*em + air) * 6.5;
  let force_nN = (sig + em + air) * 4.2;

  // mode-specific emphasis
  if (mode==="mems"){ force_nN *= 0.6; }
  else { df0_mHz *= 0.6; }

  sim.C.df0_mHz = df0_mHz;
  sim.C.force_nN = force_nN;

  if (!warpOn) sim.C.type = "OFF";
  else if (Math.abs(em) > Math.abs(sig)*1.3) sim.C.type = "EM-dominated (check magnetometer)";
  else if (!vac) sim.C.type = "Non-vacuum (air/vibe risk)";
  else if (sim.wiring==="kill") sim.C.type = "Coherence-Kill (should drop)";
  else sim.C.type = "Coherence/Spin candidate";

  cDf0.textContent = fmt(sim.C.df0_mHz, 3);
  cForce.textContent = fmt(sim.C.force_nN, 3);
  cType.textContent = sim.C.type;

  // plot force as a single trace for simplicity
  seriesC.shift(); seriesC.push(sim.C.force_nN);
  drawPlot(plotC, seriesC, "Residual Force (nN) vs time", `F=${fmt(sim.C.force_nN,3)} nN  |  Δf0=${fmt(sim.C.df0_mHz,3)} mHz`);
  tagC.textContent = running ? "C: LIVE" : "C: IDLE";
}

// ---------- acceptance criteria (simple pass/fail) ----------
function updateAcceptance(){
  // We want:
  // 1) coherence ON produces bigger signal than coherence-kill
  // 2) spin flip changes sign (approx)
  // 3) EM/thermal not dominating

  // simple scoring from current classification strings
  const goodA = sim.A.type.includes("candidate");
  const goodB = sim.B.type.includes("candidate");
  const goodC = sim.C.type.includes("candidate");

  let score = 0;
  if (goodA) score += 1;
  if (goodB) score += 1;
  if (goodC) score += 1;

  // Require wiring ON (otherwise not meaningful)
  if (sim.wiring !== "on") {
    sim.accept.pass = false;
    sim.accept.reason = "Need Wiring=ON for acceptance check";
  } else {
    // require at least one candidate channel
    if (score >= 1 && sim.stability >= 65 && sim.tunnelLock >= 0.35){
      sim.accept.pass = true;
      sim.accept.reason = "At least one coherence/spin candidate signal with stable tunnel";
    } else {
      sim.accept.pass = false;
      sim.accept.reason = "No candidate signal (or stability too low)";
    }
  }

  passFail.textContent = sim.accept.pass ? `PASS (sim) — ${sim.accept.reason}` : `FAIL (sim) — ${sim.accept.reason}`;
  dotPass.className = "dot " + (sim.accept.pass ? "good" : "warn");
}

// ---------- UI update ----------
function updateUI(){
  // tags
  tagPower.textContent = powered ? "POWER: ON" : "POWER: OFF";
  tagCoherence.textContent = `COHERENCE: ${sim.wiring==="on" ? "ON" : (sim.wiring==="kill" ? "KILL" : "OFF")}`;
  tagPhase.textContent = `PHASE LOCK: ${sim.wiring==="on" ? "ON" : "OFF"}`;

  // mode label
  const m = sim.warpMode===0 ? "Warp OFF" : (sim.warpMode===1 ? "Warp 1" : "Warp 2");
  modeLabel.textContent = `${m} | Index ${fmt(sim.warpIndex,0)}`;

  // tunnel label
  const tl = sim.tunnelLock;
  tunnelLabel.textContent = tl>0.72 ? "Locked" : (tl>0.35 ? "Marginal" : "Unstable");

  // stability visuals
  const s = sim.stability;
  stabilityLabel.textContent = `${fmt(s,1)} / 100`;
  dotStability.className = "dot " + (s>=75 ? "good" : (s>=55 ? "warn" : "bad"));
  barStab.className = (s>=75 ? "good" : (s>=55 ? "warn" : "bad"));
  barStab.style.width = `${clamp(s,0,100)}%`;

  // trip readouts
  distNow.textContent = fmt(sim.dist_km, 0);
  compressionNow.textContent = `${fmt(sim.compression, 3)}×`;
  distEff.textContent = fmt(sim.distEff_km, 0);
  speedNow.textContent = fmt(sim.speed_kms, 3);
  progressNow.textContent = `${fmt(sim.progress*100, 2)}%`;

  if (isFinite(sim.eta_s)) {
    const hrs = sim.eta_s/3600;
    etaNow.textContent = (hrs<1) ? `${fmt(sim.eta_s,1)} s` : `${fmt(hrs,2)} h`;
  } else etaNow.textContent = "—";

  if (sim.arrivalDateCST){
    arrivalCST.textContent = hhmmss(sim.arrivalDateCST);
  } else arrivalCST.textContent = "—";

  // curvature/compression metrics
  curvNow.textContent = fmt(sim.curvature, 3);
  compMetricNow.textContent = fmt((sim.compression-1), 3);
  lockNow.textContent = `${fmt(sim.tunnelLock*100,1)}%`;

  // sensors
  sensB.textContent = fmt(sim.b_uT, 3);
  sensT.textContent = fmt(sim.tempC, 2);
  sensPD.textContent = fmt(sim.pd, 3);
  sensSpin.textContent = fmt(sim.spinCurrent, 3);
  sensCoh.textContent = fmt(sim.coherence, 3);

  // run tag
  runTag.textContent = running ? "RUN: LIVE" : (powered ? "RUN: READY" : "RUN: IDLE");
}

// ---------- CSV ----------
function pushCSVRow(){
  // record key values each tick when running
  sim.csv.push({
    t_s: sim.t,
    tShip_s: sim.tShip,
    wiring: sim.wiring,
    spin: sim.spin,
    warpMode: sim.warpMode,
    warpIndex: sim.warpIndex,
    stability: sim.stability,
    tunnelLock: sim.tunnelLock,
    dist_km: sim.dist_km,
    compression: sim.compression,
    distEff_km: sim.distEff_km,
    speed_kms: sim.speed_kms,
    progress: sim.progress,
    A_dphi_mrad: sim.A.dphi_mrad,
    A_dt_ps: sim.A.dt_ps,
    B_df_Hz: sim.B.df_Hz,
    B_frac_1e12: sim.B.frac_1e12,
    C_force_nN: sim.C.force_nN,
    C_df0_mHz: sim.C.df0_mHz,
    B_uT: sim.b_uT,
    Temp_C: sim.tempC,
    PD: sim.pd,
    pass: sim.accept.pass ? 1 : 0
  });
}

function exportCSV(){
  if (!sim.csv.length){
    log("CSV export: no rows yet.");
    return;
  }
  const cols = Object.keys(sim.csv[0]);
  const lines = [];
  lines.push(cols.join(","));
  for (const r of sim.csv){
    lines.push(cols.map(k=>{
      const v = r[k];
      if (typeof v === "string") return `"${v.replaceAll('"','""')}"`;
      if (!isFinite(v)) return "";
      return String(v);
    }).join(","));
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv"});
  const url = URL.createObjectURL(blob);

  // download without the user needing to click a raw link
  const a = document.createElement("a");
  a.href = url;
  a.download = `cst-aic-warp-test-${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1500);

  log(`CSV export: ${sim.csv.length} rows downloaded.`);
}

// ---------- print ----------
function printReport(){
  const lines = [];
  lines.push("CST AIC Warp Chip — Test Report (Simple Simulator)");
  lines.push("--------------------------------------------------");
  lines.push(`Run status: ${running ? "LIVE" : "STOPPED"}   Power: ${powered ? "ON" : "OFF"}`);
  lines.push(`Wiring: ${sim.wiring}   Spin: ${sim.spin>0?"+":"-"}   Warp: ${sim.warpMode}   Index: ${fmt(sim.warpIndex,0)}`);
  lines.push(`Stability: ${fmt(sim.stability,1)}   TunnelLock: ${fmt(sim.tunnelLock*100,1)}%   Pass/Fail: ${sim.accept.pass ? "PASS(sim)" : "FAIL(sim)"}`);
  lines.push("");
  lines.push("Trip: Earth → Pluto");
  lines.push(`Distance now (km): ${fmt(sim.dist_km,0)}`);
  lines.push(`Compression: ${fmt(sim.compression,3)}x   Effective distance (km): ${fmt(sim.distEff_km,0)}`);
  lines.push(`Speed (km/s): ${fmt(sim.speed_kms,3)}   Progress: ${fmt(sim.progress*100,2)}%`);
  lines.push("");
  lines.push("Experiment A (ToF Asymmetry)");
  lines.push(`Δφ(mrad): ${fmt(sim.A.dphi_mrad,3)}   Δt(ps): ${fmt(sim.A.dt_ps,3)}   Type: ${sim.A.type}`);
  lines.push("");
  lines.push("Experiment B (Clock Drift)");
  lines.push(`Δf(Hz): ${fmt(sim.B.df_Hz,4)}   frac(×1e-12): ${fmt(sim.B.frac_1e12,3)}   Type: ${sim.B.type}`);
  lines.push("");
  lines.push("Experiment C (Mass/Force)");
  lines.push(`Force(nN): ${fmt(sim.C.force_nN,3)}   Δf0(mHz): ${fmt(sim.C.df0_mHz,3)}   Type: ${sim.C.type}`);
  lines.push("");
  lines.push("Sensors");
  lines.push(`B(µT): ${fmt(sim.b_uT,3)}   Temp(°C): ${fmt(sim.tempC,2)}   PD(a.u.): ${fmt(sim.pd,3)}   SpinCurrent: ${fmt(sim.spinCurrent,3)}   Coherence: ${fmt(sim.coherence,3)}`);

  const win = window.open("", "_blank");
  win.document.write(`<pre style="white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;padding:16px;background:#0b1222;color:#e5e7eb">${lines.join("\n")}</pre>`);
  win.document.close();
  win.focus();
  win.print();
  log("Print report opened.");
}

// ---------- main tick ----------
let timer = null;

function tick(){
  // advance time
  sim.t += sim.dt;

  // update internal state
  updateCoherencePhase();
  updateThermal();
  updateSensors();
  updateStability();
  autoTrim();

  // warp index from UI (if not auto-trimming strongly)
  // we keep UI as the “commanded knob” but auto-trim may override it
  $("warpIndexLabel").textContent = fmt(sim.warpIndex,0);

  // mission progression
  updateProgress();

  // ship time accumulation
  const dil = getDilationFactor();
  sim.tShip += sim.dt * dil;

  // experiments
  expA(); expB(); expC();

  // acceptance
  updateAcceptance();

  // UI + clocks
  updateUI();
  updateClocks();

  // CSV row
  pushCSVRow();

  // arrival handling
  if (sim.arrived){
    // automatically stop after a short grace period
    if (sim.t > 2 && running){
      stopRun("Auto-stop: arrived.");
    }
  }
}

function startRun(){
  if (!powered || running) return;
  running = true;
  btnStart.disabled = true;
  btnStop.disabled = false;
  btnExport.disabled = false;
  btnPrint.disabled = false;

  // ensure experiments are enabled
  aShield.disabled = false; aDummy.disabled = false; aLockin.disabled = false;
  bThermIso.disabled = false; bRefDist.disabled = false; bHeater.disabled = false;
  cMode.disabled = false; cVac.disabled = false; cMagShield.disabled = false;

  log("RUN STARTED: Live tick active.");
  timer = setInterval(tick, Math.floor(sim.dt*1000));
}

function stopRun(reason="Stopped"){
  if (!running) return;
  running = false;
  clearInterval(timer);
  timer = null;
  btnStart.disabled = false;
  btnStop.disabled = true;
  log(`RUN STOPPED: ${reason}`);
  updateUI();
}

function resetAll(){
  clearInterval(timer); timer=null;
  powered = false;
  running = false;

  // reset sim values
  sim = {
    ...sim,
    t:0, tShip:0,
    progress:0, arrived:false,
    warpMode:0, warpIndex:0,
    autoTrim:true, stabTarget:82,
    wiring:"off", spin:+1,
    coherence:0, phaseLock:0,
    tempC:24.0, b_uT:0.4, pd:0, spinCurrent:0,
    stability:0, tunnelLock:0,
    curvature:0, compression:1.0,
    dist_km:0, distEff_km:0, speed_kms:0, eta_s:Infinity, arrivalDateCST:null,
    A:{dt_ps:0,dphi_mrad:0,type:"—"},
    B:{df_Hz:0,frac_1e12:0,type:"—"},
    C:{df0_mHz:0,force_nN:0,type:"—"},
    accept:{pass:false,reason:"—"},
    csv:[]
  };

  // reset plots
  seriesA.fill(0); seriesB.fill(0); seriesC.fill(0);
  drawPlot(plotA, seriesA, "Δφ (mrad) vs time", "—");
  drawPlot(plotB, seriesB, "Δf (Hz) vs time", "—");
  drawPlot(plotC, seriesC, "Residual Force (nN) vs time", "—");

  // reset UI controls
  btnPower.textContent = "Power ON";
  btnStart.disabled = true;
  btnStop.disabled = true;
  selWarp.disabled = true;
  rngWarp.disabled = true;
  selAutoTrim.disabled = true;
  rngStabTarget.disabled = true;
  selWiring.disabled = true;
  selSpin.disabled = true;

  // experiments disabled until run
  aShield.disabled = true; aDummy.disabled = true; aLockin.disabled = true;
  bThermIso.disabled = true; bRefDist.disabled = true; bHeater.disabled = true;
  cMode.disabled = true; cVac.disabled = true; cMagShield.disabled = true;

  // defaults
  selWarp.value = "0";
  rngWarp.value = "0";
  selAutoTrim.value = "on";
  rngStabTarget.value = "82";
  selWiring.value = "off";
  selSpin.value = "+1";
  aShield.value = "on"; aDummy.value = "off"; aLockin.value = "on";
  bThermIso.value = "high"; bRefDist.value = "far"; bHeater.value = "off";
  cMode.value = "proof"; cVac.value = "on"; cMagShield.value = "on";

  // labels
  warpIndexLabel.textContent = "0";
  stabTargetLabel.textContent = "82";
  trimNow.textContent = "—";

  // log
  logEl.textContent = "";
  log("RESET: Simulator cleared.");

  // update UI/clocks
  updateProgress();
  updateStability();
  updateAcceptance();
  updateUI();
  updateClocks();

  btnExport.disabled = true;
  btnPrint.disabled = true;
}

function powerToggle(){
  powered = !powered;
  if (powered){
    btnPower.textContent = "Power OFF";
    btnStart.disabled = false;

    // enable controls
    selWarp.disabled = false;
    rngWarp.disabled = false;
    selAutoTrim.disabled = false;
    rngStabTarget.disabled = false;
    selWiring.disabled = false;
    selSpin.disabled = false;

    log("POWER ON: controls enabled. Set Wiring + Warp mode, then Start Run.");
  } else {
    stopRun("Power turned OFF.");
    btnPower.textContent = "Power ON";
    btnStart.disabled = true;
    btnExport.disabled = true;
    btnPrint.disabled = true;

    selWarp.disabled = true;
    rngWarp.disabled = true;
    selAutoTrim.disabled = true;
    rngStabTarget.disabled = true;
    selWiring.disabled = true;
    selSpin.disabled = true;

    log("POWER OFF: run stopped and controls locked.");
  }
  updateUI();
}

// ---------- UI event handlers ----------
btnPower.addEventListener("click", powerToggle);
btnStart.addEventListener("click", startRun);
btnStop.addEventListener("click", ()=>stopRun("Manual stop."));
btnReset.addEventListener("click", resetAll);

selWarp.addEventListener("change", ()=>{
  sim.warpMode = Number(selWarp.value);
  if (sim.warpMode===0){
    sim.warpIndex = 0;
    rngWarp.value = "0";
    log("Warp OFF: index set to 0.");
  } else {
    // gentle default
    if (sim.warpIndex < 10){ sim.warpIndex = 25; rngWarp.value = "25"; }
    log(`Warp mode set: ${sim.warpMode===1?"Warp 1":"Warp 2"}.`);
  }
  updateUI();
});

rngWarp.addEventListener("input", ()=>{
  // commanded warp index, autoTrim may override slightly
  const v = Number(rngWarp.value);
  sim.warpIndex = v;
  warpIndexLabel.textContent = String(v);
  updateUI();
});

selAutoTrim.addEventListener("change", ()=>{
  sim.autoTrim = (selAutoTrim.value==="on");
  log(`Auto-Trim: ${sim.autoTrim ? "ON" : "OFF"}.`);
});

rngStabTarget.addEventListener("input", ()=>{
  sim.stabTarget = Number(rngStabTarget.value);
  stabTargetLabel.textContent = String(sim.stabTarget);
});

selWiring.addEventListener("change", ()=>{
  sim.wiring = selWiring.value;
  log(`Wiring state: ${sim.wiring.toUpperCase()}.`);
});

selSpin.addEventListener("change", ()=>{
  sim.spin = Number(selSpin.value);
  log(`Spin polarity set to ${sim.spin>0?"+":"−"} (sign flip test).`);
});

// export/print
btnExport.addEventListener("click", exportCSV);
btnPrint.addEventListener("click", printReport);

// ---------- boot ----------
function boot(){
  // enable experiment control defaults (disabled until run)
  aShield.disabled = true; aDummy.disabled = true; aLockin.disabled = true;
  bThermIso.disabled = true; bRefDist.disabled = true; bHeater.disabled = true;
  cMode.disabled = true; cVac.disabled = true; cMagShield.disabled = true;

  // initial plots
  drawPlot(plotA, seriesA, "Δφ (mrad) vs time", "—");
  drawPlot(plotB, seriesB, "Δf (Hz) vs time", "—");
  drawPlot(plotC, seriesC, "Residual Force (nN) vs time", "—");

  resetAll();

  // continuous wall clock updates (even when not running)
  setInterval(()=>{
    updateClocks();
  }, 250);

  log("READY: Power ON → choose Warp 1 or 2 → set Wiring (ON / KILL) → Start Run.");
}
boot();
</script>

</body>
</html>
