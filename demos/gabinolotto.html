<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lotto Sum-Up + Frequency + Even/Odd Pattern — Simulation</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111826; --panel2:#0f1622; --text:#e7eefc; --muted:#9fb0cf;
      --line:#22304a; --good:#2ee59d; --warn:#ffcf5a; --bad:#ff6b6b; --accent:#6aa7ff;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0; background:linear-gradient(180deg,#070a0f, #0b0f14 30%, #070a0f);
      color:var(--text); font-family:var(--sans);
      -webkit-print-color-adjust: exact; print-color-adjust: exact;
    }
    .wrap{max-width:1250px; margin:0 auto; padding:18px;}
    h1{font-size:20px; margin:0 0 10px 0; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:13px; margin-bottom:14px; line-height:1.35}
    .grid{display:grid; grid-template-columns: 1.15fr .85fr; gap:14px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
    .card{
      background:rgba(17,24,38,.9);
      border:1px solid rgba(34,48,74,.85);
      border-radius:16px;
      box-shadow: 0 18px 45px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;
      background:linear-gradient(180deg, rgba(26,38,60,.9), rgba(17,24,38,.2));
      border-bottom:1px solid rgba(34,48,74,.85);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card .hd .t{font-weight:800; font-size:14px;}
    .card .hd .s{font-size:12px; color:var(--muted)}
    .card .bd{padding:14px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .row + .row{margin-top:10px;}
    .btn{
      border:1px solid rgba(34,48,74,.95);
      background:linear-gradient(180deg, rgba(106,167,255,.22), rgba(106,167,255,.08));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:.2px;
      transition:transform .06s ease, filter .2s ease;
      user-select:none;
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{
      background:linear-gradient(180deg, rgba(159,176,207,.16), rgba(159,176,207,.06));
      font-weight:750;
    }
    .btn.danger{
      background:linear-gradient(180deg, rgba(255,107,107,.20), rgba(255,107,107,.08));
    }
    .btn:disabled{opacity:.55; cursor:not-allowed; filter:saturate(.6);}
    .pill{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(34,48,74,.9);
      color:var(--muted);
      background:rgba(15,22,34,.6);
      white-space:nowrap;
    }
    .input{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(34,48,74,.95);
      background:rgba(15,22,34,.65);
      color:var(--text);
      outline:none;
      font-family:var(--mono);
      font-size:13px;
    }
    .mini{width:160px;}
    .label{font-size:12px; color:var(--muted); margin-bottom:6px;}
    .draws{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:10px;
      align-items:start;
    }
    .drawTag{
      border:1px solid rgba(34,48,74,.9);
      background:rgba(15,22,34,.55);
      border-radius:12px;
      padding:10px 10px;
      font-weight:900;
      color:#d8e6ff;
      text-align:center;
    }
    .hint{color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35}
    table{width:100%; border-collapse:collapse; font-size:12px;}
    th,td{border-bottom:1px solid rgba(34,48,74,.7); padding:8px 8px; text-align:left; vertical-align:top;}
    th{color:#cfe0ff; font-size:12px;}
    .mono{font-family:var(--mono)}
    .right{text-align:right}
    .good{color:var(--good); font-weight:900}
    .warn{color:var(--warn); font-weight:900}
    .bad{color:var(--bad); font-weight:900}
    .muted{color:var(--muted)}
    .hr{height:1px; background:rgba(34,48,74,.85); margin:12px 0;}
    .progressWrap{
      width:100%;
      height:10px;
      background:rgba(15,22,34,.7);
      border:1px solid rgba(34,48,74,.85);
      border-radius:999px;
      overflow:hidden;
    }
    .bar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(46,229,157,.8), rgba(106,167,255,.8));
      transition:width .08s linear;
    }
    .resultsGroup{
      border:1px solid rgba(34,48,74,.75);
      background:rgba(15,22,34,.45);
      border-radius:14px;
      padding:10px;
      margin-top:10px;
    }
    .kbd{
      font-family:var(--mono);
      padding:2px 6px;
      border:1px solid rgba(34,48,74,.9);
      border-radius:8px;
      background:rgba(15,22,34,.65);
      color:#d8e6ff;
      font-size:11px;
    }
    .smallNote{font-size:11px; color:var(--muted); line-height:1.35}
    .twoCol{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 640px){ .twoCol{grid-template-columns:1fr;} }

    /* Print: show only results + computed tables nicely */
    @media print{
      .noPrint{display:none !important;}
      body{background:#fff; color:#000;}
      .card{box-shadow:none; border:1px solid #ccc; background:#fff;}
      .pill{border:1px solid #ccc; background:#f5f5f5; color:#333;}
      th{color:#000;}
      .muted{color:#444;}
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Sum-Up + Frequency + Even/Odd Pattern — “Last 5 or 10 Draws” Generator</h1>
  <div class="sub">
    Enter your last <span class="kbd">5</span> or <span class="kbd">10</span> draws (6/54). This evaluates:
    <b>Sum</b>, <b>Total Frequency</b>, and <b>Even/Odd split</b>. Then it generates new sets that:
    (1) match one of the target sums from your last draws, and
    (2) match the most frequent even/odd pattern you had (example: <b>3 even / 3 odd</b>).
  </div>

  <div class="grid">

    <!-- LEFT -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">1) Enter Last Draws (choose 5 or 10)</div>
          <div class="s">Paste like: <span class="kbd">10 20 33 34 36 40</span> (spaces or commas)</div>
        </div>
        <div class="pill">Range 1–54 • Pick 6</div>
      </div>

      <div class="bd">
        <div class="row noPrint">
          <span class="pill">How many draws are you entering?</span>
          <select id="drawCount" class="input mini" style="width:160px">
            <option value="5" selected>5 draws</option>
            <option value="10">10 draws</option>
          </select>
          <span class="pill" id="statusPill">Enter draws → Compute</span>
        </div>

        <div id="drawInputs" class="draws" style="margin-top:10px"></div>

        <div class="row noPrint" style="margin-top:12px">
          <button class="btn" id="btnCompute">Compute Sum + Frequency + Even/Odd</button>
          <button class="btn secondary" id="btnFillExample" title="Fill example draws">Fill Example</button>
          <button class="btn danger" id="btnClear">Clear</button>
        </div>

        <div class="hint noPrint">
          Rules: numbers 1–54, <b>no duplicates inside a draw</b>, exactly 6 numbers per draw.
        </div>

        <div class="hr noPrint"></div>

        <div class="twoCol noPrint">
          <div>
            <div class="label">Weight boost for numbers seen in your last draws</div>
            <input class="input" id="alpha" type="number" step="0.1" min="0" max="3" value="1.0" />
            <div class="smallNote">Final weight = baseFrequency × (1 + alpha × recentCount)</div>
          </div>
          <div>
            <div class="label">Even/Odd rule used for generation</div>
            <select id="evenoddMode" class="input">
              <option value="most_frequent" selected>Use MOST frequent pattern from last draws</option>
              <option value="manual">Manual choose pattern below</option>
            </select>
            <div class="smallNote">Example “3 even / 3 odd” if that’s your most common split.</div>
          </div>
        </div>

        <div class="row noPrint" style="align-items:flex-end">
          <div style="flex:1; min-width:220px">
            <div class="label">Manual even count (only if mode = Manual)</div>
            <select id="manualEven" class="input">
              <option value="0">0 even / 6 odd</option>
              <option value="1">1 even / 5 odd</option>
              <option value="2">2 even / 4 odd</option>
              <option value="3" selected>3 even / 3 odd</option>
              <option value="4">4 even / 2 odd</option>
              <option value="5">5 even / 1 odd</option>
              <option value="6">6 even / 0 odd</option>
            </select>
          </div>
          <div style="flex:1; min-width:220px">
            <div class="label">Attempts per generated set (more = stronger constraints)</div>
            <input class="input" id="attemptsPerSet" type="number" min="2000" step="1000" value="60000" />
            <div class="smallNote">This searches for sets that match BOTH sum and even/odd pattern.</div>
          </div>
        </div>

        <div class="row noPrint" style="align-items:flex-end">
          <div style="flex:1; min-width:220px">
            <div class="label">Generate how many sets?</div>
            <input class="input" id="howMany" type="number" min="1" max="50" value="20" />
          </div>
          <div style="flex:1; min-width:220px">
            <div class="label">Seed (optional, repeatable runs)</div>
            <input class="input" id="seed" type="text" placeholder="leave blank for random" />
          </div>
        </div>

        <div class="row noPrint" style="margin-top:12px">
          <button class="btn" id="btnGenerate" disabled>Generate 20 Lottery Sets</button>
          <button class="btn secondary" id="btnPrint" disabled>Print Lottery Numbers</button>
          <button class="btn secondary" id="btnExportCSV" disabled>Export CSV</button>
        </div>

        <div class="row noPrint" style="margin-top:10px">
          <div style="flex:1">
            <div class="progressWrap"><div class="bar" id="bar"></div></div>
            <div class="smallNote" id="progText">Progress: 0%</div>
          </div>
        </div>

      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="t">2) Evaluation + Generated Sets</div>
          <div class="s">Targets = sums from your last draws + most frequent even/odd pattern</div>
        </div>
        <div class="pill" id="rulePill">Rule: —</div>
      </div>

      <div class="bd">
        <div class="label">Computed Draws (Sum / Frequency / Even-Odd)</div>
        <div id="computedTable" class="muted">Nothing computed yet.</div>

        <div class="hr"></div>

        <div class="label">Generated Lottery Sets</div>
        <div id="results" class="muted">Run generator to see 20 sets.</div>

        <div class="smallNote" style="margin-top:12px">
          ⚠️ Lottery draws are random. Your method can help you stay consistent with patterns (sum and even/odd balance),
          but it cannot guarantee wins.
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/** ============================================================
 *  Base frequency table (Number -> Times Drawn)
 *  From your prior “Lotto Formula.xlsx” values used earlier.
 *  ============================================================ */
const BASE_FREQ = {
  1:325,2:318,3:317,4:347,5:350,6:308,7:325,8:350,9:327,10:331,11:305,12:327,13:306,14:328,15:343,16:352,17:323,18:315,
  19:350,20:331,21:318,22:332,23:335,24:338,25:314,26:318,27:318,28:321,29:314,30:327,31:331,32:321,33:321,34:309,
  35:324,36:306,37:318,38:329,39:258,40:327,41:318,42:329,43:269,44:321,45:258,46:269,47:255,48:252,49:266,50:331,
  51:257,52:257,53:251,54:180
};

const STORAGE_KEY = "lotto_sumup_evenodd_v2";

const drawInputs = document.getElementById('drawInputs');
const statusPill = document.getElementById('statusPill');
const rulePill = document.getElementById('rulePill');
const computedTable = document.getElementById('computedTable');
const resultsEl = document.getElementById('results');

const btnCompute = document.getElementById('btnCompute');
const btnGenerate = document.getElementById('btnGenerate');
const btnPrint = document.getElementById('btnPrint');
const btnExportCSV = document.getElementById('btnExportCSV');
const bar = document.getElementById('bar');
const progText = document.getElementById('progText');

const drawCountEl = document.getElementById('drawCount');
const alphaEl = document.getElementById('alpha');
const evenoddModeEl = document.getElementById('evenoddMode');
const manualEvenEl = document.getElementById('manualEven');
const attemptsPerSetEl = document.getElementById('attemptsPerSet');
const howManyEl = document.getElementById('howMany');
const seedEl = document.getElementById('seed');

let computed = null;     // computed object
let lastGenerated = null;

function setStatus(msg, kind="neutral"){
  statusPill.textContent = msg;
  statusPill.style.borderColor = "rgba(34,48,74,.9)";
  statusPill.style.color = "var(--muted)";
  if(kind==="good"){
    statusPill.style.borderColor = "rgba(46,229,157,.55)";
    statusPill.style.color = "var(--good)";
  } else if(kind==="bad"){
    statusPill.style.borderColor = "rgba(255,107,107,.55)";
    statusPill.style.color = "var(--bad)";
  } else if(kind==="warn"){
    statusPill.style.borderColor = "rgba(255,207,90,.55)";
    statusPill.style.color = "var(--warn)";
  }
}

function parseSixNumbers(text){
  const parts = (text || "")
    .replace(/[|;]/g, " ")
    .split(/[\s,]+/g)
    .map(s => s.trim())
    .filter(Boolean);
  return parts.map(p => Number(p)).filter(n => Number.isFinite(n));
}

function validateDraw(nums){
  const errs = [];
  if(nums.length !== 6) errs.push("must contain exactly 6 numbers");
  const uniq = new Set(nums);
  if(uniq.size !== nums.length) errs.push("cannot contain duplicates");
  for(const n of nums){
    if(!Number.isInteger(n)) errs.push("all values must be integers");
    if(n < 1 || n > 54) errs.push("all numbers must be 1–54");
  }
  return errs;
}

function sum(nums){ return nums.reduce((a,b)=>a+b,0); }
function freqTotal(nums){ return nums.reduce((a,n)=>a + (BASE_FREQ[n] || 0), 0); }

function evenCount(nums){
  let ev = 0;
  for(const n of nums) if(n % 2 === 0) ev++;
  return ev;
}
function oddCount(nums){ return 6 - evenCount(nums); }

function makeRecentCount(draws){
  const rc = {};
  for(const d of draws){
    for(const n of d.nums) rc[n] = (rc[n] || 0) + 1;
  }
  return rc;
}
function makeWeights(alpha, recentCount){
  const w = {};
  for(let n=1;n<=54;n++){
    const base = BASE_FREQ[n] || 1;
    const boost = 1 + alpha * (recentCount[n] || 0);
    w[n] = base * boost;
  }
  return w;
}

function mostFrequentEvenPattern(draws){
  // returns evenCount (0..6) and a histogram
  const hist = Array(7).fill(0);
  for(const d of draws){
    hist[d.even] += 1;
  }
  let bestEven = 3;
  let bestCount = -1;
  for(let e=0;e<=6;e++){
    if(hist[e] > bestCount){
      bestCount = hist[e];
      bestEven = e;
    }
  }
  return { bestEven, hist };
}

function renderComputed(draws, uniqueTargets, patternInfo){
  const { bestEven, hist } = patternInfo;

  let histLine = hist.map((c,e)=> `${e}E/${6-e}O:${c}`).join(" • ");

  let html = `<table>
    <thead>
      <tr>
        <th>Draw</th>
        <th class="mono">Numbers</th>
        <th class="right">Sum</th>
        <th class="right">Even/Odd</th>
        <th class="right">Total Frequency</th>
      </tr>
    </thead>
    <tbody>`;

  for(const d of draws){
    html += `<tr>
      <td><b>${d.label}</b></td>
      <td class="mono">${d.nums.join(" ")}</td>
      <td class="right"><span class="good">${d.sum}</span></td>
      <td class="right"><span class="warn">${d.even}E/${d.odd}O</span></td>
      <td class="right"><span class="warn">${d.freq}</span></td>
    </tr>`;
  }
  html += `</tbody></table>
    <div class="hint">
      Target sums (unique): ${
        uniqueTargets.map(t=>`<span class="kbd">${t}</span>`).join(" ")
      }
      <div style="margin-top:6px">
        Even/Odd histogram: <span class="mono muted">${histLine}</span><br/>
        Most frequent pattern: <span class="kbd">${bestEven} even / ${6-bestEven} odd</span>
      </div>
    </div>`;
  computedTable.innerHTML = html;
}

// Seeded RNG helpers
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function makeRng(seedStr){
  if(!seedStr) return Math.random;
  const seed = xmur3(seedStr)();
  return mulberry32(seed);
}

// Weighted pick without replacement
function weightedPickWithoutReplacement(weights, rng, k=6){
  const picked = [];
  const used = new Set();
  const items = [];
  for(let n=1;n<=54;n++) items.push([n, weights[n] || 1]);

  for(let i=0;i<k;i++){
    let total = 0;
    for(const [n,w] of items) if(!used.has(n)) total += w;
    let r = rng() * total;
    let chosen = null;
    for(const [n,w] of items){
      if(used.has(n)) continue;
      r -= w;
      if(r <= 0){ chosen = n; break; }
    }
    if(chosen === null){
      for(const [n,_w] of items){ if(!used.has(n)){ chosen = n; break; } }
    }
    used.add(chosen);
    picked.push(chosen);
  }
  picked.sort((a,b)=>a-b);
  return picked;
}

function comboKey(nums){ return nums.join("-"); }
function scoreCombo(nums, weights){ return nums.reduce((a,n)=>a + (weights[n]||0), 0); }

function saveDraft(){
  const count = Number(drawCountEl.value);
  const payload = { drawCount: count };
  for(let i=0;i<count;i++){
    payload[`draw_${i}`] = (document.getElementById(`draw_${i}`).value || "").trim();
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
}
function loadDraft(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const payload = JSON.parse(raw);
    if(payload.drawCount) drawCountEl.value = String(payload.drawCount);
  }catch(e){}
}

function buildInputs(){
  const count = Number(drawCountEl.value);
  drawInputs.innerHTML = "";
  for(let i=0;i<count;i++){
    const tag = document.createElement('div');
    tag.className = 'drawTag';
    tag.textContent = `Draw ${i+1}`;
    const box = document.createElement('div');
    const inp = document.createElement('input');
    inp.className = 'input';
    inp.id = `draw_${i}`;
    inp.placeholder = "e.g., 10 20 33 34 36 40";
    inp.autocomplete = "off";
    inp.spellcheck = false;
    inp.addEventListener('input', () => { saveDraft(); });
    box.appendChild(inp);
    drawInputs.appendChild(tag);
    drawInputs.appendChild(box);
  }

  // load saved values for this count
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const payload = JSON.parse(raw);
      for(let i=0;i<count;i++){
        const v = payload[`draw_${i}`];
        if(typeof v === "string") document.getElementById(`draw_${i}`).value = v;
      }
    }
  }catch(e){}
}

loadDraft();
buildInputs();

drawCountEl.addEventListener('change', () => {
  // reset computed state when changing count
  computed = null;
  lastGenerated = null;
  btnGenerate.disabled = true;
  btnPrint.disabled = true;
  btnExportCSV.disabled = true;
  resultsEl.innerHTML = "Run generator to see 20 sets.";
  computedTable.innerHTML = "Nothing computed yet.";
  rulePill.textContent = "Rule: —";
  setStatus("Updated draw count. Enter draws → Compute.", "neutral");

  // clear stored draw lines beyond new count
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    const payload = raw ? JSON.parse(raw) : {};
    payload.drawCount = Number(drawCountEl.value);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){}

  buildInputs();
});

// Buttons
document.getElementById('btnClear').addEventListener('click', () => {
  const count = Number(drawCountEl.value);
  for(let i=0;i<count;i++){
    const el = document.getElementById(`draw_${i}`);
    if(el) el.value = "";
  }
  localStorage.removeItem(STORAGE_KEY);

  computed = null;
  lastGenerated = null;
  btnGenerate.disabled = true;
  btnPrint.disabled = true;
  btnExportCSV.disabled = true;
  computedTable.innerHTML = "Nothing computed yet.";
  resultsEl.innerHTML = "Run generator to see 20 sets.";
  rulePill.textContent = "Rule: —";
  bar.style.width = "0%";
  progText.textContent = "Progress: 0%";
  setStatus("Cleared.", "neutral");
});

document.getElementById('btnFillExample').addEventListener('click', () => {
  // Example fills for 10; if user is on 5, it uses first 5
  const examples = [
    "10 20 33 34 36 40",
    "10 19 21 33 35 54",
    "7 33 34 37 42 46",
    "6 31 33 42 44 45",
    "12 26 32 37 39 45",
    "8 15 19 26 38 49",
    "4 12 17 21 31 52",
    "7 18 24 27 35 44",
    "1 11 20 29 34 54",
    "5 14 23 30 36 41"
  ];
  const count = Number(drawCountEl.value);
  for(let i=0;i<count;i++){
    document.getElementById(`draw_${i}`).value = examples[i] || "";
  }
  saveDraft();
  setStatus("Example filled. Click Compute.", "warn");
});

btnCompute.addEventListener('click', () => {
  resultsEl.innerHTML = "Run generator to see 20 sets.";
  lastGenerated = null;
  btnPrint.disabled = true;
  btnExportCSV.disabled = true;

  const count = Number(drawCountEl.value);
  const draws = [];
  const errors = [];

  for(let i=0;i<count;i++){
    const raw = document.getElementById(`draw_${i}`).value;
    const nums = parseSixNumbers(raw);
    const errs = validateDraw(nums);
    if(errs.length){
      errors.push(`Draw ${i+1}: ${errs.join(", ")}`);
    }else{
      const sorted = nums.slice().sort((a,b)=>a-b);
      draws.push({
        label: `Draw ${i+1}`,
        nums: sorted,
        sum: sum(sorted),
        freq: freqTotal(sorted),
        even: evenCount(sorted),
        odd: 6 - evenCount(sorted)
      });
    }
  }

  if(errors.length){
    setStatus("Fix input errors.", "bad");
    computedTable.innerHTML = `<div class="muted"><b class="bad">Input errors:</b><ul>${
      errors.map(e=>`<li>${e}</li>`).join("")
    }</ul></div>`;
    computed = null;
    btnGenerate.disabled = true;
    rulePill.textContent = "Rule: —";
    return;
  }

  const alpha = Number(alphaEl.value || 0);
  const recentCount = makeRecentCount(draws);
  const weights = makeWeights(alpha, recentCount);

  // targets: unique sums from last draws
  const targets = Array.from(new Set(draws.map(d=>d.sum))).sort((a,b)=>a-b);

  const pat = mostFrequentEvenPattern(draws);

  renderComputed(draws, targets, pat);

  computed = { draws, targets, weights, alpha, recentCount, pattern: pat };
  setStatus(`Computed OK • Targets: ${targets.join(", ")} • Most common: ${pat.bestEven}E/${6-pat.bestEven}O`, "good");

  // update rule pill
  const mode = evenoddModeEl.value;
  const manualEven = Number(manualEvenEl.value);
  const chosenEven = (mode === "manual") ? manualEven : pat.bestEven;
  rulePill.textContent = `Rule: Sum ∈ {${targets.join(", ")}} • Even/Odd = ${chosenEven}E/${6-chosenEven}O`;

  btnGenerate.disabled = false;
});

evenoddModeEl.addEventListener('change', () => {
  if(!computed) return;
  const mode = evenoddModeEl.value;
  const chosenEven = (mode === "manual") ? Number(manualEvenEl.value) : computed.pattern.bestEven;
  rulePill.textContent = `Rule: Sum ∈ {${computed.targets.join(", ")}} • Even/Odd = ${chosenEven}E/${6-chosenEven}O`;
});
manualEvenEl.addEventListener('change', () => {
  if(!computed) return;
  if(evenoddModeEl.value !== "manual") return;
  const chosenEven = Number(manualEvenEl.value);
  rulePill.textContent = `Rule: Sum ∈ {${computed.targets.join(", ")}} • Even/Odd = ${chosenEven}E/${6-chosenEven}O`;
});

// Generator: make N sets that match (sum target) AND (evenCount target)
btnGenerate.addEventListener('click', async () => {
  if(!computed){
    setStatus("Compute first.", "bad");
    return;
  }

  const targets = computed.targets;
  const weights = computed.weights;

  const mode = evenoddModeEl.value;
  const targetEven = (mode === "manual") ? Number(manualEvenEl.value) : computed.pattern.bestEven;
  const targetOdd = 6 - targetEven;

  const howMany = Math.max(1, Math.min(50, Number(howManyEl.value || 20)));
  const attemptsPerSet = Math.max(2000, Number(attemptsPerSetEl.value || 60000));
  const seedStr = (seedEl.value || "").trim();

  const rng = makeRng(seedStr ? `${seedStr}|${Date.now()}` : "");

  btnGenerate.disabled = true;
  btnCompute.disabled = true;
  btnPrint.disabled = true;
  btnExportCSV.disabled = true;

  setStatus("Generating…", "warn");
  resultsEl.innerHTML = `<div class="muted">Working…</div>`;
  bar.style.width = "0%";
  progText.textContent = "Progress: 0%";

  // We generate unique combos (avoid duplicates)
  const made = [];
  const seen = new Set();

  const totalWork = howMany * attemptsPerSet;
  let done = 0;

  // For variety: randomly choose one of the target sums per set (weighted by frequency of occurrence in your inputs)
  const sumCounts = {};
  for(const d of computed.draws) sumCounts[d.sum] = (sumCounts[d.sum]||0)+1;
  const sumChoices = targets.slice();
  const sumWeights = sumChoices.map(s => sumCounts[s] || 1);

  function weightedChoice(arr, wts){
    let total=0; for(const w of wts) total += w;
    let r = rng() * total;
    for(let i=0;i<arr.length;i++){
      r -= wts[i];
      if(r <= 0) return arr[i];
    }
    return arr[arr.length-1];
  }

  const chunk = 3000;

  for(let i=0;i<howMany;i++){
    const targetSum = weightedChoice(sumChoices, sumWeights);

    let best = null; // best matching candidate by score
    for(let a=0; a<attemptsPerSet; a++){
      const nums = weightedPickWithoutReplacement(weights, rng, 6);
      const s = sum(nums);
      const ev = evenCount(nums);

      if(s === targetSum && ev === targetEven){
        const key = comboKey(nums);
        if(!seen.has(key)){
          const sc = scoreCombo(nums, weights);
          if(!best || sc > best.score){
            best = { nums, sum:s, even:ev, odd:6-ev, score:sc, targetSum };
          }
        }
      }

      done++;
      if(done % chunk === 0){
        const pct = Math.round((done / totalWork) * 100);
        bar.style.width = pct + "%";
        progText.textContent = `Progress: ${pct}% • Set ${i+1}/${howMany} • Searching sum=${targetSum} • Rule=${targetEven}E/${targetOdd}O`;
        await new Promise(r => setTimeout(r, 0));
      }
    }

    // If nothing found for this set, we relax by keeping "closest sum" that still matches even/odd
    if(!best){
      let closest = null;
      let bestDelta = Infinity;
      for(let t=0; t<Math.min(4000, attemptsPerSet); t++){
        const nums = weightedPickWithoutReplacement(weights, rng, 6);
        const ev = evenCount(nums);
        if(ev !== targetEven) continue;
        const s = sum(nums);
        const delta = Math.abs(s - targetSum);
        const sc = scoreCombo(nums, weights) - delta * 20; // penalize far sums
        if(delta < bestDelta || (delta === bestDelta && (!closest || sc > closest.score))){
          bestDelta = delta;
          closest = { nums, sum:s, even:ev, odd:6-ev, score:sc, targetSum, relaxed:true, delta };
        }
      }
      best = closest;
    }

    if(best){
      const key = comboKey(best.nums);
      if(!seen.has(key)){
        seen.add(key);
        made.push(best);
      }else{
        // If duplicate, allow it only if we are short: try one more small search
        // (keeps things simple)
        for(let t=0; t<2000; t++){
          const nums = weightedPickWithoutReplacement(weights, rng, 6);
          if(sum(nums) === best.targetSum && evenCount(nums) === targetEven){
            const k = comboKey(nums);
            if(!seen.has(k)){
              seen.add(k);
              made.push({
                nums, sum: sum(nums), even: targetEven, odd: targetOdd,
                score: scoreCombo(nums, weights), targetSum: best.targetSum
              });
              break;
            }
          }
        }
      }
    }
  }

  // sort by score desc (best first)
  made.sort((a,b)=>b.score - a.score);

  lastGenerated = { targetEven, targetOdd, sets: made };

  renderGenerated(made, targetEven, targetOdd);

  bar.style.width = "100%";
  progText.textContent = "Progress: 100% • Done";
  setStatus(`Done • Generated ${made.length} sets`, "good");

  btnGenerate.disabled = false;
  btnCompute.disabled = false;
  btnPrint.disabled = false;
  btnExportCSV.disabled = false;
});

function renderGenerated(sets, targetEven, targetOdd){
  if(!sets || !sets.length){
    resultsEl.innerHTML = `<div class="muted">No sets generated (try more attempts per set).</div>`;
    return;
  }

  let html = `<div class="resultsGroup">
    <div class="row" style="justify-content:space-between">
      <div><b>Rule used:</b> <span class="kbd">${targetEven} even / ${targetOdd} odd</span></div>
      <div class="pill">Total sets: ${sets.length}</div>
    </div>
    <div class="hr"></div>
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th class="mono">Numbers</th>
          <th class="right">Sum</th>
          <th class="right">Even/Odd</th>
          <th class="right">Target Sum</th>
          <th class="right">Score</th>
          <th class="right">Note</th>
        </tr>
      </thead>
      <tbody>`;

  sets.forEach((s, idx) => {
    const note = s.relaxed ? `closest (Δ=${s.delta})` : "";
    html += `<tr>
      <td><b>${idx+1}</b></td>
      <td class="mono">${s.nums.join(" ")}</td>
      <td class="right"><span class="good">${s.sum}</span></td>
      <td class="right"><span class="warn">${s.even}E/${s.odd}O</span></td>
      <td class="right">${s.targetSum}</td>
      <td class="right"><span class="warn">${Math.round(s.score)}</span></td>
      <td class="right" style="color:var(--muted)">${note}</td>
    </tr>`;
  });

  html += `</tbody></table>
  </div>`;

  resultsEl.innerHTML = html;
}

// Print button
btnPrint.addEventListener('click', () => {
  if(!lastGenerated || !lastGenerated.sets || !lastGenerated.sets.length) return;
  window.print();
});

// Export CSV
btnExportCSV.addEventListener('click', () => {
  if(!lastGenerated || !lastGenerated.sets || !lastGenerated.sets.length) return;
  const rows = [];
  rows.push(["rank","n1","n2","n3","n4","n5","n6","sum","even","odd","target_sum","score","note"].join(","));
  lastGenerated.sets.forEach((s, idx) => {
    rows.push([
      idx+1, ...s.nums, s.sum, s.even, s.odd, s.targetSum, Math.round(s.score),
      (s.relaxed ? `closest_delta_${s.delta}` : "")
    ].join(","));
  });
  const csv = rows.join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `lotto_evenodd_sum_matches_${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// Initial UI state
setStatus("Enter draws → Compute.", "neutral");
resultsEl.innerHTML = "Run generator to see 20 sets.";
rulePill.textContent = "Rule: —";
</script>
</body>
</html>
