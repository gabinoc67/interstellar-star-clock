<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>6/54 Sum-Up Simulator (155–175 • Balanced 2/2/2 • Full-History Top Numbers)</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:18px;background:#0b0f14;color:#e8eef7}
    h1{font-size:18px;margin:0 0 8px}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin:10px 0}
    .card{background:#121a24;border:1px solid #223044;border-radius:14px;padding:12px;min-width:320px;flex:1}
    label{display:block;font-size:12px;opacity:.85;margin:8px 0 4px}
    input,select{width:100%;padding:10px;border-radius:10px;border:1px solid #2a3b56;background:#0b0f14;color:#e8eef7}
    button{padding:10px 12px;border-radius:12px;border:1px solid #2a3b56;background:#1b2a3f;color:#e8eef7;cursor:pointer}
    button:hover{filter:brightness(1.08)}
    button:disabled{opacity:.55;cursor:not-allowed}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid #223044;border-radius:12px;padding:10px;margin:0;min-height:240px}
    .muted{opacity:.75;font-size:12px;line-height:1.35}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b0f14;border:1px solid #223044;font-size:12px;margin-right:6px;margin-bottom:6px}
    .good{color:#6ee7b7}
    .warn{color:#fbbf24}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width: 900px){ .grid2{grid-template-columns:1fr} }

    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid #223044;padding:6px 6px;text-align:left}
    th{opacity:.85}
    .split{display:grid;grid-template-columns:1.1fr .9fr;gap:12px}
    @media (max-width: 980px){ .split{grid-template-columns:1fr} }

    /* Print styling */
    @media print{
      body{background:#fff;color:#000;margin:12mm}
      .card{background:#fff;border:1px solid #ddd}
      button, input, label, select, .muted, .pill { display:none !important; }
      pre{border:1px solid #ddd;background:#fff;color:#000}
      h1{color:#000}
      table{color:#000}
      th,td{border-bottom:1px solid #ddd}
    }
  </style>
</head>
<body>
  <h1>6/54 Sum-Up Simulator (Target Sum 155–175 • Balanced 2/2/2 • Full-History “Hot Numbers” Weighted)</h1>

  <div class="muted">
    <span class="pill">Low: <b>1–18</b> (pick 2)</span>
    <span class="pill">Mid: <b>19–36</b> (pick 2)</span>
    <span class="pill">High: <b>37–54</b> (pick 2)</span>
    <span class="pill">Target Sum: <b>155–175</b></span>
    <div style="margin-top:8px">
      This uses <b>full-history frequency weights</b> (since the beginning) and optional <b>pair co-occurrence bonus</b>.
      It does <b>not</b> change true lottery odds.
    </div>
  </div>

  <div class="row split">
    <div class="card">
      <div class="grid2">
        <div>
          <label>Iterations (more = stronger search)</label>
          <input id="iters" type="number" value="300000" min="1000" step="1000" />
        </div>
        <div>
          <label>Pair synergy strength (0 = off)</label>
          <input id="pairStrength" type="number" value="0.25" min="0" max="2" step="0.05" />
        </div>
        <div>
          <label>Target Sum Min</label>
          <input id="sumMin" type="number" value="155" min="21" max="315" step="1" />
        </div>
        <div>
          <label>Target Sum Max</label>
          <input id="sumMax" type="number" value="175" min="21" max="315" step="1" />
        </div>
        <div>
          <label>Number Pool</label>
          <select id="poolMode">
            <option value="top20">Use Top 20 only (hot numbers)</option>
            <option value="all">Use all 1–54 (weighted)</option>
          </select>
        </div>
        <div>
          <label>Output Mode</label>
          <select id="outputMode">
            <option value="top5">Top 5</option>
            <option value="top10">Top 10</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="runBtn">Run Simulation</button>
        <button id="showBestBtn">Show Current Best</button>
        <button id="gen10Btn">Generate 10 Sets</button>
        <button id="printBtn">Print</button>
      </div>

      <div id="status" class="muted">
        Tip: “Top 20 only” gives more repeats but stronger “hot number” bias. Use “All 1–54” for more variety.
      </div>
    </div>

    <div class="card">
      <div class="muted" style="margin-bottom:8px">
        <b class="good">Output:</b> Balanced sets within your target sum,
        scored by <b>full-history weights</b> + optional <b>pair synergy</b>.
      </div>
      <pre id="out"></pre>
    </div>
  </div>

  <div class="row">
    <div class="card">
      <div class="muted" style="margin-bottom:8px">
        <b class="good">Top 20 numbers since the beginning</b> (highest frequency)
      </div>
      <div style="overflow:auto">
        <table id="top20Table"></table>
      </div>
      <div class="muted" style="margin-top:8px">
        Note: Using “Top 20 only” means every pick must come from these hot numbers (still 2/2/2 balanced).
      </div>
    </div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  /* ============================================================
     FULL-HISTORY (since-the-beginning) frequencies.
     These are taken from your "lottery draw since begining.xlsx".
     Total draws = 2190 (13140 numbers total).
     We use Laplace smoothing: p(n) = (count+1)/(total+54)
     ============================================================ */

  const TOP20 = [
    {n: 8,  c: 275},
    {n: 31, c: 271},
    {n: 15, c: 270},
    {n: 19, c: 268},
    {n: 26, c: 268},
    {n: 49, c: 266},
    {n: 38, c: 265},
    {n: 21, c: 265},
    {n: 4,  c: 264},
    {n: 17, c: 261},
    {n: 12, c: 261},
    {n: 52, c: 257},
    {n: 35, c: 257},
    {n: 27, c: 256},
    {n: 24, c: 254},
    {n: 7,  c: 253},
    {n: 44, c: 252},
    {n: 34, c: 252},
    {n: 29, c: 251},
    {n: 18, c: 251},
  ];

  // Full-history counts for every number 1..54 (derived from file).
  const FULL_COUNTS = {
    "1":227,"2":225,"3":225,"4":264,"5":246,"6":240,"7":253,"8":275,"9":242,"10":238,"11":240,"12":261,
    "13":232,"14":239,"15":270,"16":245,"17":261,"18":251,"19":268,"20":232,"21":265,"22":235,"23":244,
    "24":254,"25":245,"26":268,"27":256,"28":236,"29":251,"30":249,"31":271,"32":233,"33":235,"34":252,
    "35":257,"36":240,"37":241,"38":265,"39":237,"40":244,"41":242,"42":235,"43":243,"44":252,"45":232,
    "46":238,"47":239,"48":235,"49":266,"50":237,"51":243,"52":257,"53":247,"54":236
  };

  const TOTAL_NUMBERS = 13140; // 2190 draws * 6 numbers
  const SMOOTH_DEN = TOTAL_NUMBERS + 54;

  // Laplace-smoothed probability weights for 1..54
  const WEIGHTS = (() => {
    const w = {};
    for(let i=1;i<=54;i++){
      const c = FULL_COUNTS[String(i)] ?? 0;
      w[String(i)] = (c + 1) / SMOOTH_DEN;
    }
    return w;
  })();

  /* ============================================================
     Pair co-occurrence bonus (top pairs across full history).
     These are NOT probabilities. Just repeat counts for scoring.
     ============================================================ */
  const PAIR_BONUS = {
    "14-26":41,"15-38":39,"8-26":39,"8-15":38,"7-44":37,"37-38":37,"15-24":37,"34-36":37,"10-21":37,"8-34":37,
    "29-35":36,"21-38":36,"15-31":36,"8-31":36,"4-21":36,"24-31":35,"8-38":35,"26-31":35,"19-26":35,"12-31":35,
    "15-49":35,"4-8":35,"4-15":35,"31-38":35,"4-31":34,"17-31":34,"15-26":34,"7-31":34,"19-31":34,"21-31":34,
    "8-49":34,"26-38":34,"15-21":34,"8-24":33,"15-19":33,"12-15":33,"21-26":33,"26-49":33,"31-49":33,"19-38":33,
    "12-26":33,"8-19":33,"8-21":33,"15-35":33,"31-35":32,"19-49":32,"24-26":32,"12-17":32,"8-52":32,"31-52":32,
    "24-38":32,"15-44":32,"26-35":32,"21-49":32,"7-15":32,"4-26":31,"17-26":31,"26-52":31,"38-49":31,"21-35":31,
    "19-21":31,"15-52":31,"7-26":31,"12-38":31,"26-44":31
  };

  // Buckets
  const LOW_ALL  = range(1,18);
  const MID_ALL  = range(19,36);
  const HIGH_ALL = range(37,54);

  // Top20 pool broken into buckets for balanced picking
  const TOP20_SET = new Set(TOP20.map(x => x.n));
  const LOW_TOP  = LOW_ALL.filter(n => TOP20_SET.has(n));
  const MID_TOP  = MID_ALL.filter(n => TOP20_SET.has(n));
  const HIGH_TOP = HIGH_ALL.filter(n => TOP20_SET.has(n));

  // UI
  const itersEl = document.getElementById("iters");
  const pairEl = document.getElementById("pairStrength");
  const sumMinEl = document.getElementById("sumMin");
  const sumMaxEl = document.getElementById("sumMax");
  const poolModeEl = document.getElementById("poolMode");
  const outputModeEl = document.getElementById("outputMode");

  const runBtn = document.getElementById("runBtn");
  const showBestBtn = document.getElementById("showBestBtn");
  const gen10Btn = document.getElementById("gen10Btn");
  const printBtn = document.getElementById("printBtn");
  const outEl = document.getElementById("out");
  const statusEl = document.getElementById("status");

  // Render Top20 table
  (function renderTop20(){
    const t = document.getElementById("top20Table");
    let html = "<thead><tr><th>Rank</th><th>Number</th><th>Times Drawn</th><th>Bucket</th></tr></thead><tbody>";
    TOP20.forEach((x, idx) => {
      const b = (x.n <= 18) ? "Low (1–18)" : (x.n <= 36) ? "Mid (19–36)" : "High (37–54)";
      html += `<tr><td>${idx+1}</td><td><b>${x.n}</b></td><td>${x.c}</td><td>${b}</td></tr>`;
    });
    html += "</tbody>";
    t.innerHTML = html;
  })();

  function range(a,b){
    const out=[];
    for(let i=a;i<=b;i++) out.push(i);
    return out;
  }

  function sum(arr){ return arr.reduce((a,b)=>a+b,0); }

  function normalizeWeights(values){
    const w = values.map(n => WEIGHTS[String(n)] ?? 1e-12);
    const s = w.reduce((a,b)=>a+b,0) || 1;
    return w.map(x=>x/s);
  }

  // Weighted sample without replacement
  function pickKNoReplace(values, probs, k){
    const vals = values.slice();
    const ps = probs.slice();
    const picked = [];
    for(let t=0;t<k;t++){
      let r = Math.random();
      let cum = 0, idx = 0;
      for(; idx<ps.length; idx++){
        cum += ps[idx];
        if(r <= cum) break;
      }
      if(idx >= vals.length) idx = vals.length - 1;
      picked.push(vals[idx]);
      vals.splice(idx,1);
      ps.splice(idx,1);

      // renormalize
      const s = ps.reduce((a,b)=>a+b,0) || 1;
      for(let i=0;i<ps.length;i++) ps[i] /= s;
    }
    return picked;
  }

  function scoreCombo(combo, pairStrength){
    // score = sum(log(p(n))) + pairStrength * scaled pair count
    let s = 0;
    for(const n of combo){
      const p = WEIGHTS[String(n)] ?? 1e-12;
      s += Math.log(p);
    }
    if(pairStrength > 0){
      for(let i=0;i<combo.length;i++){
        for(let j=i+1;j<combo.length;j++){
          const a = Math.min(combo[i], combo[j]);
          const b = Math.max(combo[i], combo[j]);
          const key = `${a}-${b}`;
          const bonus = PAIR_BONUS[key] ?? 0;
          s += pairStrength * bonus * 0.01; // scaling
        }
      }
    }
    return s;
  }

  function getPools(){
    const mode = poolModeEl.value;
    if(mode === "top20"){
      return { LOW: LOW_TOP, MID: MID_TOP, HIGH: HIGH_TOP };
    }
    return { LOW: LOW_ALL, MID: MID_ALL, HIGH: HIGH_ALL };
  }

  function makeBalancedCombo(){
    const {LOW, MID, HIGH} = getPools();

    // Safety: Top20 mode must still have at least 2 numbers per bucket
    if(LOW.length < 2 || MID.length < 2 || HIGH.length < 2){
      throw new Error("Pool does not have enough numbers in each bucket for 2/2/2 balanced picks.");
    }

    const lp = normalizeWeights(LOW);
    const mp = normalizeWeights(MID);
    const hp = normalizeWeights(HIGH);

    const a = pickKNoReplace(LOW,  lp, 2);
    const b = pickKNoReplace(MID,  mp, 2);
    const c = pickKNoReplace(HIGH, hp, 2);

    return [...a, ...b, ...c].sort((x,y)=>x-y);
  }

  function simulateTopK(iters, pairStrength, sumMin, sumMax, topK){
    const best = new Map(); // key -> bestScore
    for(let i=0;i<iters;i++){
      const combo = makeBalancedCombo();
      const total = sum(combo);
      if(total < sumMin || total > sumMax) continue;

      const key = combo.join(",");
      const sc = scoreCombo(combo, pairStrength);
      const prev = best.get(key);
      if(prev === undefined || sc > prev) best.set(key, sc);
    }

    return Array.from(best.entries())
      .map(([k,v]) => ({combo: k.split(",").map(Number), score:v}))
      .sort((a,b)=>b.score - a.score)
      .slice(0, topK);
  }

  function formatResults(results){
    if(!results.length) return "No matches found.\n- Increase iterations\n- Or widen sum range\n- Or switch pool to All 1–54";
    let out = "";
    results.forEach((r,idx)=>{
      out += `${idx+1}) ${r.combo.join("  ")}   | sum=${sum(r.combo)}\n`;
    });
    return out.trim();
  }

  function readSettings(){
    const iters = Math.max(1000, Number(itersEl.value || 300000));
    const pairStrength = Math.max(0, Number(pairEl.value || 0));
    const sumMin = Number(sumMinEl.value || 155);
    const sumMax = Number(sumMaxEl.value || 175);
    const topK = (outputModeEl.value === "top10") ? 10 : 5;
    return { iters, pairStrength, sumMin, sumMax, topK };
  }

  function setBusy(isBusy, msg){
    runBtn.disabled = isBusy;
    showBestBtn.disabled = isBusy;
    gen10Btn.disabled = isBusy;
    if(msg) statusEl.textContent = msg;
  }

  // Default “best known” (filled after first run)
  let CURRENT_BEST = [
    [8, 15, 21, 26, 38, 49],  // common + balanced + sum 157
    [4, 12, 19, 31, 38, 52],  // sum 156
    [8, 17, 26, 31, 38, 49],  // sum 169
    [7, 15, 24, 31, 44, 49],  // sum 170
    [12, 15, 21, 26, 38, 52]  // sum 164
  ];

  function showCurrentBest(){
    const out = CURRENT_BEST
      .map((c,i)=>`${i+1}) ${c.join("  ")}   | sum=${sum(c)}`)
      .join("\n");
    outEl.textContent = out;
  }

  runBtn.addEventListener("click", async () => {
    try{
      const { iters, pairStrength, sumMin, sumMax, topK } = readSettings();
      setBusy(true, `Running… (${iters.toLocaleString()} iterations) • Pool: ${poolModeEl.value.toUpperCase()} • Target ${sumMin}–${sumMax}`);
      await new Promise(r => setTimeout(r, 10)); // allow UI refresh

      const results = simulateTopK(iters, pairStrength, sumMin, sumMax, topK);
      outEl.textContent = formatResults(results);

      if(results.length) CURRENT_BEST = results.map(r => r.combo);
      setBusy(false, `Done. Found ${results.length ? results.length : "0"} ranked sets in ${sumMin}–${sumMax}.`);
    }catch(err){
      outEl.textContent = "Error: " + (err?.message || String(err));
      setBusy(false, "Error occurred. Check console.");
      console.error(err);
    }
  });

  showBestBtn.addEventListener("click", () => {
    showCurrentBest();
    statusEl.textContent = "Showing current saved best sets.";
  });

  gen10Btn.addEventListener("click", async () => {
    try{
      const { iters, pairStrength, sumMin, sumMax } = readSettings();
      setBusy(true, `Generating 10 sets… (${iters.toLocaleString()} iterations)`);
      await new Promise(r => setTimeout(r, 10));

      // Generate more candidates then take top 10
      const results = simulateTopK(iters, pairStrength, sumMin, sumMax, 40);
      const top10 = results.slice(0, 10);

      if(!top10.length){
        outEl.textContent = "No matches found for 10 sets.\nIncrease iterations or widen sum range or switch pool.";
        setBusy(false, "No matches.");
        return;
      }

      let txt = "10 Generated Sets (ranked):\n\n";
      top10.forEach((r,i)=>{
        txt += `${i+1}) ${r.combo.join("  ")}   | sum=${sum(r.combo)}\n`;
      });

      outEl.textContent = txt.trim();
      CURRENT_BEST = top10.map(r => r.combo);
      setBusy(false, "Done. Generated 10 ranked sets.");
    }catch(err){
      outEl.textContent = "Error: " + (err?.message || String(err));
      setBusy(false, "Error occurred. Check console.");
      console.error(err);
    }
  });

  printBtn.addEventListener("click", () => window.print());

  // Initial display
  showCurrentBest();
});
</script>
</body>
</html>
