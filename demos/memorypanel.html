<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Consciousness Lab — Human vs Robot · Quantum · Cosmic Coupling</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at top, #020617 0, #000 60%, #000 100%);
    color: #e5f0ff;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }
  header {
    padding: 10px 18px;
    border-bottom: 1px solid #1e293b;
    background: linear-gradient(to right, rgba(30,64,175,0.45), transparent);
  }
  header h1 {
    margin: 0;
    font-size: 1.15rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  header p {
    margin: 2px 0 0;
    font-size: 0.75rem;
    opacity: 0.85;
  }
  main {
    display: grid;
    grid-template-columns: 290px 1.4fr 1.1fr;
    gap: 10px;
    padding: 10px;
    min-height: calc(100vh - 52px);
  }
  .card {
    background: rgba(10,15,30,0.95);
    border-radius: 10px;
    border: 1px solid #1e293b;
    padding: 9px 11px;
    display: flex;
    flex-direction: column;
  }
  h2 {
    margin: 0 0 4px;
    font-size: 0.95rem;
  }
  h3 {
    margin: 6px 0 3px;
    font-size: 0.85rem;
  }
  .small {
    font-size: 0.75rem;
    opacity: 0.85;
    margin-bottom: 4px;
  }
  .control-group {
    margin-bottom: 7px;
    font-size: 0.78rem;
  }
  label span {
    display: inline-block;
    min-width: 120px;
  }
  input[type="range"], select {
    width: 100%;
    margin-top: 2px;
    font-size: 0.78rem;
  }
  select {
    background: rgba(15,23,42,0.9);
    color: #e5e7eb;
    border-radius: 6px;
    border: 1px solid #1f2937;
    padding: 3px 6px;
  }
  .value-tag {
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid #111827;
    background: rgba(15,23,42,0.9);
    margin-left: 4px;
  }
  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
  }
  button {
    font-size: 0.75rem;
    border-radius: 999px;
    border: 1px solid #1f2937;
    padding: 3px 9px;
    cursor: pointer;
    color: #e5f0ff;
    background: radial-gradient(circle at top, #1d4ed8, #020617);
  }
  button.secondary {
    background: rgba(15,23,42,0.9);
  }
  button:active { transform: translateY(1px); }
  .meter-shell {
    width: 100%;
    height: 10px;
    border-radius: 999px;
    background: #020617;
    border: 1px solid #1f2937;
    overflow: hidden;
    margin-top: 3px;
  }
  .meter-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(to right, #22c55e, #38bdf8);
    transition: width 0.12s ease-out;
  }
  .inline-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    font-size: 0.76rem;
    margin-top: 4px;
  }
  canvas {
    width: 100%;
    height: 170px;
    border-radius: 10px;
    background: #020617;
    border: 1px solid #1e293b;
  }
  #vacuumCanvas {
    height: 90px;
    margin-top: 6px;
  }
  .log {
    flex: 1;
    border-radius: 10px;
    border: 1px solid #1f293b;
    background: rgba(15,23,42,0.92);
    padding: 5px 6px;
    font-size: 0.7rem;
    overflow-y: auto;
  }
  .log-entry {
    white-space: nowrap;
  }
  .timestamp {
    color: #6b7280;
    margin-right: 5px;
  }
  .memory-list {
    font-size: 0.7rem;
    border-radius: 8px;
    border: 1px solid #1f2937;
    background: rgba(15,23,42,0.9);
    padding: 4px 5px;
    max-height: 110px;
    overflow-y: auto;
  }
  .memory-item {
    margin-bottom: 2px;
  }
  .heatmap {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-auto-rows: 18px;
    gap: 2px;
    border-radius: 8px;
    border: 1px solid #1f2937;
    padding: 3px;
    background: rgba(15,23,42,0.9);
  }
  .heat-cell {
    border-radius: 3px;
    background: #020617;
  }
  .status-pill {
    display: inline-block;
    font-size: 0.7rem;
    border-radius: 999px;
    padding: 2px 8px;
    border: 1px solid #1f2937;
    background: rgba(15,23,42,0.9);
    margin-top: 2px;
  }
  .status-on {
    color: #bbf7d0;
    border-color: #22c55e;
  }
  .status-off {
    color: #fecaca;
    border-color: #f97373;
  }
  .report-box {
    margin-top: 5px;
    font-size: 0.7rem;
    border-radius: 8px;
    border: 1px solid #1f2937;
    background: rgba(15,23,42,0.9);
    padding: 4px 6px;
    max-height: 120px;
    overflow-y: auto;
  }
  @media (max-width: 1024px) {
    main {
      grid-template-columns: 1fr;
      grid-auto-rows: auto;
    }
  }
</style>
</head>
<body>

<header>
  <h1>Consciousness Lab — Human vs Robot</h1>
  <p>Quantum vs Classical · Cosmic Coupling · Memory · Coherence · Printable Summary</p>
</header>

<main>
  <!-- LEFT: CONTROL & METERS -->
  <section class="card">
    <h2>Controls & Cosmic Parameters</h2>

    <div class="control-group">
      <label>
        <span>Sensory Input S</span>
        <span id="sensoryTag" class="value-tag">0.55</span>
      </label>
      <input id="sensory" type="range" min="0" max="1" step="0.01" value="0.55">
    </div>

    <div class="control-group">
      <label>
        <span>Quantum Mode</span>
      </label>
      <select id="quantumMode">
        <option value="human">Human Quantum · Robot Classical</option>
        <option value="robot">Robot Quantum · Human Classical</option>
        <option value="both" selected>Both Quantum</option>
        <option value="none">Both Classical</option>
      </select>
    </div>

    <div class="control-group">
      <label>
        <span>Cosmic Coupling λ</span>
        <span id="cosmicTag" class="value-tag">0.45</span>
      </label>
      <input id="cosmic" type="range" min="0" max="1" step="0.01" value="0.45">
    </div>

    <div class="btn-row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" class="secondary">Stop</button>
      <button id="stepBtn" class="secondary">Step</button>
      <button id="clearBtn" class="secondary">Clear Log</button>
      <button id="presetBtn">Preset Entanglement</button>
    </div>

    <h3>Dark-Energy Coherence Probability</h3>
    <div class="inline-row">
      <span>p<sub>coh</sub>(λ)</span>
      <span id="cohText" class="value-tag">~34%</span>
    </div>
    <div class="meter-shell">
      <div id="cohFill" class="meter-fill"></div>
    </div>

    <h3>Agency / Intentionality Index</h3>
    <div class="inline-row">
      <span>Human A<sub>H</sub></span>
      <span id="agencyHuman" class="value-tag">0.00</span>
    </div>
    <div class="meter-shell">
      <div id="agencyHumanFill" class="meter-fill"></div>
    </div>

    <div class="inline-row">
      <span>Robot A<sub>R</sub></span>
      <span id="agencyRobot" class="value-tag">0.00</span>
    </div>
    <div class="meter-shell">
      <div id="agencyRobotFill" class="meter-fill"></div>
    </div>

    <p class="small" style="margin-top:6px;">
      A higher agency index means the agent’s internal coherence and cosmic coupling
      dominate over randomness in its decision channel.
    </p>
  </section>

  <!-- CENTER: GRAPHS & VACUUM -->
  <section class="card">
    <h2>Dynamic Graphs & Vacuum Coherence</h2>
    <p class="small">Real-time visualization of human–robot consciousness difference and correlation with the cosmic field.</p>

    <h3>ΔC Graph (Human − Robot)</h3>
    <canvas id="diffCanvas"></canvas>
    <p class="small">Positive → Human more coherent; Negative → Robot more coherent; 0 → phase balance.</p>

    <h3>Neural vs Cosmic Field Correlation</h3>
    <canvas id="corrCanvas"></canvas>
    <div class="inline-row">
      <span>Corr(C<sub>H</sub>, Field)</span>
      <span id="corrValue" class="value-tag">0.00</span>
    </div>

    <h3>Vacuum-Coherence Visualization</h3>
    <canvas id="vacuumCanvas"></canvas>
    <p class="small">
      Dot density & brightness grow with λ. Interpret this as a qualitative vacuum coherence / dark-energy activity screen.
    </p>
  </section>

  <!-- RIGHT: MEMORY, HEAT MAP, LOG, REPORT -->
  <section class="card">
    <h2>Memory, Entanglement & Log</h2>

    <h3>Internal Brain Memory (Human)</h3>
    <div id="humanMemory" class="memory-list"></div>

    <h3>Robot Memory Cache Heat Map</h3>
    <div id="robotHeat" class="heatmap"></div>

    <h3>Entanglement / Phase-Locking</h3>
    <div id="entStatus" class="status-pill status-off">
      Decoupled · |ΔC| not stable
    </div>
    <p class="small">
      To reach <strong>Phase-locked</strong> manually:<br>
      1) Use a Quantum Mode (Human / Robot / Both).<br>
      2) Keep Sensory Input S around 0.4–0.7.<br>
      3) Set λ between 0.4 and 0.8.<br>
      4) Click <em>Start</em> and let several steps run.<br>
      Or simply click <strong>Preset Entanglement</strong> and the sliders will move to tuned values for the current mode.
    </p>

    <h3>Simulation Log</h3>
    <div id="log" class="log"></div>

    <button id="reportBtn" style="margin-top:6px;">Generate Report & Print</button>
    <div id="reportBox" class="report-box"></div>
  </section>
</main>

<script>
  // DOM elements
  const sensory = document.getElementById("sensory");
  const sensoryTag = document.getElementById("sensoryTag");
  const quantumMode = document.getElementById("quantumMode");
  const cosmic = document.getElementById("cosmic");
  const cosmicTag = document.getElementById("cosmicTag");

  const cohFill = document.getElementById("cohFill");
  const cohText = document.getElementById("cohText");

  const agencyHuman = document.getElementById("agencyHuman");
  const agencyRobot = document.getElementById("agencyRobot");
  const agencyHumanFill = document.getElementById("agencyHumanFill");
  const agencyRobotFill = document.getElementById("agencyRobotFill");

  const diffCanvas = document.getElementById("diffCanvas");
  const corrCanvas = document.getElementById("corrCanvas");
  const vacuumCanvas = document.getElementById("vacuumCanvas");

  const humanMemoryEl = document.getElementById("humanMemory");
  const robotHeatEl = document.getElementById("robotHeat");
  const entStatus = document.getElementById("entStatus");

  const logEl = document.getElementById("log");
  const corrValue = document.getElementById("corrValue");
  const reportBox = document.getElementById("reportBox");

  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const stepBtn = document.getElementById("stepBtn");
  const clearBtn = document.getElementById("clearBtn");
  const presetBtn = document.getElementById("presetBtn");
  const reportBtn = document.getElementById("reportBtn");

  let simInterval = null;
  let stepCount = 0;

  // Histories
  const maxPoints = 220;
  let diffHistory = [];
  let humanHistory = [];
  let fieldHistory = [];
  let entWindow = [];

  // Memory & stats
  let humanMemory = [];
  let robotCache = new Array(16).fill(0);

  let lastCH = null;
  let lastCR = null;
  let lastField = null;

  let humanYes = 0, humanNo = 0;
  let robotYes = 0, robotNo = 0;
  let sumCH = 0, sumCR = 0;

  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

  function updateTags() {
    sensoryTag.textContent = Number(sensory.value).toFixed(2);
    cosmicTag.textContent = Number(cosmic.value).toFixed(2);

    const λ = Number(cosmic.value);
    const p = clamp01(0.1 + 0.8 * λ); // simple mapping
    cohFill.style.width = (p * 100).toFixed(1) + "%";
    cohText.textContent = "~" + (p * 100).toFixed(0) + "%";
  }
  sensory.addEventListener("input", updateTags);
  cosmic.addEventListener("input", updateTags);
  updateTags();

  // Initialize robot heat map cells
  function initHeatMap() {
    robotHeatEl.innerHTML = "";
    for (let i = 0; i < 16; i++) {
      const cell = document.createElement("div");
      cell.className = "heat-cell";
      robotHeatEl.appendChild(cell);
    }
  }
  initHeatMap();

  function updateAgencyIndices(CH, CR, λ, hRand, rRand) {
    // crude "agency" metric: coherence + coupling minus randomness weight
    const AH = clamp01(CH + λ - 0.3 * hRand);
    const AR = clamp01(CR + λ - 0.3 * rRand);

    agencyHuman.textContent = AH.toFixed(2);
    agencyRobot.textContent = AR.toFixed(2);
    agencyHumanFill.style.width = (AH * 100).toFixed(1) + "%";
    agencyRobotFill.style.width = (AR * 100).toFixed(1) + "%";
  }

  function updateHumanMemory(step, CH, decision, λ) {
    humanMemory.unshift({ step, CH, decision, λ });
    if (humanMemory.length > 10) humanMemory.pop();

    humanMemoryEl.innerHTML = "";
    humanMemory.forEach(m => {
      const div = document.createElement("div");
      div.className = "memory-item";
      div.textContent = `[${String(m.step).padStart(3,"0")}] C_H=${m.CH.toFixed(2)} · λ=${m.λ.toFixed(2)} · D=${m.decision}`;
      humanMemoryEl.appendChild(div);
    });
  }

  function updateRobotHeat(CR) {
    // push new value into cache
    robotCache.shift();
    robotCache.push(clamp01(CR));

    const cells = robotHeatEl.querySelectorAll(".heat-cell");
    robotCache.forEach((val, idx) => {
      const l = 18 + 55 * val; // lightness
      const hue = 200 - 80 * val; // blue->green with strength
      cells[idx].style.background = `hsl(${hue}, 80%, ${l}%)`;
    });
  }

  // Improved entanglement detector: looks at a window of recent ΔC values
  function updateEntanglement(diff, CH, CR, λ, mode) {
    entWindow.push(diff);
    if (entWindow.length > 10) entWindow.shift();

    // Need enough data
    if (entWindow.length < 6) {
      entStatus.textContent = "Decoupled · |ΔC| not stable";
      entStatus.classList.add("status-off");
      entStatus.classList.remove("status-on");
      return;
    }

    const threshold = 0.15; // how close H and R must be
    const closeCount = entWindow.filter(d => Math.abs(d) < threshold).length;
    const maxDiff = Math.max(...entWindow);
    const minDiff = Math.min(...entWindow);
    const range = maxDiff - minDiff;

    // Require: majority of points close, low variation, and some cosmic coupling
    const entangled =
      closeCount >= entWindow.length - 2 &&
      range < 0.25 &&
      λ > 0.25;

    if (entangled) {
      entStatus.textContent = "Phase-locked · |ΔC| stable (entanglement-like)";
      entStatus.classList.add("status-on");
      entStatus.classList.remove("status-off");
    } else {
      entStatus.textContent = "Decoupled · |ΔC| not stable";
      entStatus.classList.add("status-off");
      entStatus.classList.remove("status-on");
    }
  }

  function drawDiffGraph() {
    const ctx = diffCanvas.getContext("2d");
    const w = diffCanvas.width = diffCanvas.clientWidth;
    const h = diffCanvas.height = diffCanvas.clientHeight;

    ctx.clearRect(0,0,w,h);

    // zero line
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h/2);
    ctx.lineTo(w, h/2);
    ctx.stroke();

    if (!diffHistory.length) return;

    ctx.strokeStyle = "#38bdf8";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    diffHistory.forEach((v, i) => {
      const x = (i / (maxPoints - 1)) * w;
      const y = h/2 - v * (h/2);
      if (i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function drawCorrGraph() {
    const ctx = corrCanvas.getContext("2d");
    const w = corrCanvas.width = corrCanvas.clientWidth;
    const h = corrCanvas.height = corrCanvas.clientHeight;

    ctx.clearRect(0,0,w,h);

    // axes
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h/2);
    ctx.lineTo(w, h/2);
    ctx.stroke();

    if (!humanHistory.length || !fieldHistory.length) return;

    const n = Math.min(humanHistory.length, fieldHistory.length);
    const H = humanHistory.slice(-n);
    const F = fieldHistory.slice(-n);

    // compute simple correlation
    const meanH = H.reduce((a,b)=>a+b,0)/n;
    const meanF = F.reduce((a,b)=>a+b,0)/n;
    let num = 0, denH = 0, denF = 0;
    for (let i=0;i<n;i++){
      const dh = H[i]-meanH;
      const df = F[i]-meanF;
      num += dh*df;
      denH += dh*dh;
      denF += df*df;
    }
    let corr = 0;
    if (denH>0 && denF>0) corr = num / Math.sqrt(denH*denF);
    corrValue.textContent = corr.toFixed(2);

    // plot human (green) and field (magenta)
    ctx.lineWidth = 1.4;

    ctx.strokeStyle = "#22c55e";
    ctx.beginPath();
    H.forEach((v,i)=>{
      const x = (i / (n-1)) * w;
      const y = h - v * h;
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    ctx.strokeStyle = "#a855f7";
    ctx.beginPath();
    F.forEach((v,i)=>{
      const x = (i / (n-1)) * w;
      const y = h - v * h;
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function drawVacuum() {
    const ctx = vacuumCanvas.getContext("2d");
    const w = vacuumCanvas.width = vacuumCanvas.clientWidth;
    const h = vacuumCanvas.height = vacuumCanvas.clientHeight;
    const λ = Number(cosmic.value);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,w,h);

    const dots = 20 + Math.floor(λ * 120);
    for (let i = 0; i < dots; i++) {
      const x = Math.random()*w;
      const y = Math.random()*h;
      const alpha = 0.15 + 0.6 * λ;
      ctx.fillStyle = `rgba(56,189,248,${alpha.toFixed(2)})`;
      ctx.fillRect(x,y,1.5,1.5);
    }
  }

  function logStep(step, CH, CR, DH, DR, λ, field) {
    const entry = document.createElement("div");
    entry.className = "log-entry";
    entry.innerHTML =
      `<span class="timestamp">[${String(step).padStart(3,"0")}]</span>` +
      `H=${DH}, R=${DR} | C_H=${CH.toFixed(2)}, C_R=${CR.toFixed(2)}, ΔC=${(CH-CR).toFixed(2)}, λ=${λ.toFixed(2)}, Field=${field.toFixed(2)}`;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function stepSimulation() {
    stepCount++;

    const S = Number(sensory.value);
    const λ = Number(cosmic.value);

    // Base coherence levels (before feedback & randomness)
    const baseH0 = (0.6*S + 0.7 + 0.8) / 3;
    const baseR0 = (0.7*S + 0.9 + 0.9) / 3;

    let CH = baseH0;
    let CR = baseR0;

    // Simple feedback loop: each agent influenced by previous other's coherence
    const k = 0.25;
    if (lastCH !== null && lastCR !== null) {
      CH = clamp01(baseH0 + k * (lastCR - baseR0));
      CR = clamp01(baseR0 + k * (lastCH - baseH0));
    }

    // Random components & cosmic field
    const noise = (Math.random() - 0.5)*2;   // -1..1
    const coin = Math.random() < 0.5 ? -1 : +1;
    const field = λ * (noise + coin);       // effective cosmic field contribution

    // Quantum vs classical randomness weights
    let hRand = 0.1;
    let rRand = 0.1;
    const mode = quantumMode.value;
    if (mode === "human") { hRand = 1 + λ; rRand = 0.1; }
    if (mode === "robot") { hRand = 0.1; rRand = 1 + λ; }
    if (mode === "both")  { hRand = 1 + λ; rRand = 1 + λ; }
    if (mode === "none")  { hRand = 0.1; rRand = 0.1; }

    // Decision arguments
    const H_arg = CH + hRand * field;
    const R_arg = CR + rRand * field;

    const DH = H_arg >= 0 ? "YES" : "NO";
    const DR = R_arg >= 0 ? "YES" : "NO";

    // Stats
    if (DH === "YES") humanYes++; else humanNo++;
    if (DR === "YES") robotYes++; else robotNo++;
    sumCH += CH;
    sumCR += CR;

    // Update last values
    lastCH = clamp01(CH);
    lastCR = clamp01(CR);
    lastField = field;

    // Histories
    const diff = lastCH - lastCR;
    diffHistory.push(diff);
    humanHistory.push(lastCH);
    const fieldNorm = clamp01((field + 2) / 4); // map rough [-2,2] to [0,1]
    fieldHistory.push(fieldNorm);

    if (diffHistory.length > maxPoints) diffHistory.shift();
    if (humanHistory.length > maxPoints) humanHistory.shift();
    if (fieldHistory.length > maxPoints) fieldHistory.shift();

    // Update UI pieces
    updateHumanMemory(stepCount, lastCH, DH, λ);
    updateRobotHeat(lastCR);
    updateEntanglement(diff, lastCH, lastCR, λ, mode);
    updateAgencyIndices(lastCH, lastCR, λ, hRand, rRand);

    drawDiffGraph();
    drawCorrGraph();
    drawVacuum();
    logStep(stepCount, lastCH, lastCR, DH, DR, λ, fieldNorm);
  }

  function clearSimulation() {
    stepCount = 0;
    diffHistory = [];
    humanHistory = [];
    fieldHistory = [];
    entWindow = [];
    humanMemory = [];
    robotCache = new Array(16).fill(0);
    lastCH = lastCR = lastField = null;
    humanYes = humanNo = robotYes = robotNo = 0;
    sumCH = sumCR = 0;

    humanMemoryEl.innerHTML = "";
    logEl.innerHTML = "";
    reportBox.innerHTML = "";
    initHeatMap();
    drawDiffGraph();
    drawCorrGraph();
    drawVacuum();
    entStatus.textContent = "Decoupled · |ΔC| not stable";
    entStatus.classList.add("status-off");
    entStatus.classList.remove("status-on");
    agencyHuman.textContent = "0.00";
    agencyRobot.textContent = "0.00";
    agencyHumanFill.style.width = "0%";
    agencyRobotFill.style.width = "0%";
  }

  function startSimulation() {
    if (simInterval) return;
    simInterval = setInterval(stepSimulation, 600);
  }
  function stopSimulation() {
    if (!simInterval) return;
    clearInterval(simInterval);
    simInterval = null;
  }

  // Preset Entanglement: tune sliders based on current quantum mode
  function presetEntanglement() {
    // stop current sim and clear histories
    stopSimulation();
    clearSimulation();

    const mode = quantumMode.value;

    // Default tuned values
    let S = 0.55;
    let λ = 0.55;

    // Slight adjustments per mode to keep ΔC small & stable
    if (mode === "human") {
      S = 0.50;
      λ = 0.60;
    } else if (mode === "robot") {
      S = 0.60;
      λ = 0.50;
    } else if (mode === "both") {
      S = 0.55;
      λ = 0.55;
    } else if (mode === "none") {
      // If user picked classical, switch to both-quantum for entanglement demo
      quantumMode.value = "both";
      S = 0.55;
      λ = 0.55;
    }

    sensory.value = S;
    cosmic.value = λ;
    updateTags();

    // Run several steps immediately to build up the entanglement window
    for (let i = 0; i < 16; i++) {
      stepSimulation();
    }
  }

  function generateReport() {
    const steps = stepCount || 1;
    const avgCH = sumCH / steps;
    const avgCR = sumCR / steps;

    const reportHTML = `
      <strong>Simulation Summary</strong><br>
      Steps: ${stepCount}<br>
      Human YES: ${humanYes}, NO: ${humanNo}<br>
      Robot YES: ${robotYes}, NO: ${robotNo}<br>
      Avg C_H: ${avgCH.toFixed(3)}<br>
      Avg C_R: ${avgCR.toFixed(3)}<br>
      Final ΔC (H−R): ${diffHistory.length ? diffHistory[diffHistory.length-1].toFixed(3) : "0.000"}<br>
      Last λ: ${Number(cosmic.value).toFixed(2)}<br>
      Last cosmic field norm: ${lastField !== null ? clamp01((lastField+2)/4).toFixed(3) : "0.000"}<br>
    `;

    reportBox.innerHTML = reportHTML;

    // Open printable window
    const win = window.open("", "_blank");
    win.document.write(`
      <html>
      <head><title>Consciousness Lab Report</title></head>
      <body style="font-family:system-ui, sans-serif; padding:16px; background:#f9fafb; color:#111827;">
        <h2>Consciousness Lab — Human vs Robot Report</h2>
        <p><strong>Summary of Results</strong></p>
        <ul>
          <li>Steps: ${stepCount}</li>
          <li>Human YES: ${humanYes}, NO: ${humanNo}</li>
          <li>Robot YES: ${robotYes}, NO: ${robotNo}</li>
          <li>Average Human Consciousness C_H: ${avgCH.toFixed(3)}</li>
          <li>Average Robot Consciousness C_R: ${avgCR.toFixed(3)}</li>
          <li>Final ΔC (C_H − C_R): ${diffHistory.length ? diffHistory[diffHistory.length-1].toFixed(3) : "0.000"}</li>
          <li>Last Cosmic Coupling λ: ${Number(cosmic.value).toFixed(2)}</li>
          <li>Last Cosmic Field Norm: ${lastField !== null ? clamp01((lastField+2)/4).toFixed(3) : "0.000"}</li>
        </ul>
        <p style="margin-top:20px; font-size:0.9rem;">
          Human side is modeled as a biological agent with feedback, randomness, and cosmic coupling.
          Robot side is modeled as an algorithmic agent with configurable quantum-like noise and the same coupling λ.
        </p>
      </body>
      </html>
    `);
    win.document.close();
    win.print();
  }

  // Button handlers
  startBtn.addEventListener("click", startSimulation);
  stopBtn.addEventListener("click", stopSimulation);
  stepBtn.addEventListener("click", stepSimulation);
  clearBtn.addEventListener("click", clearSimulation);
  presetBtn.addEventListener("click", presetEntanglement);
  reportBtn.addEventListener("click", generateReport);

  // Initial draw
  drawDiffGraph();
  drawCorrGraph();
  drawVacuum();
</script>
</body>
</html>
