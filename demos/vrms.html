<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST-Locked VT↔CIT vRMS — Always-Live Wave + Scan (rAF + Fallback)</title>
<style>
  :root{
    --bg:#0b1222;--panel:#121a33;--ink:#eaf0ff;--muted:#a9b7e3;--accent:#8fb4ff;--grid:#1b2550;--ok:#7bffb1;--bad:#ff8c8c
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1220px;margin:0 auto;padding:18px}
  h1{font-size:1.35rem;margin:0 0 10px}
  .sub{color:var(--muted);font-size:0.95rem;margin:0 0 16px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--grid);border-radius:14px;padding:14px}
  label{display:block;font-size:12px;color:var(--muted);margin:8px 0 4px}
  input,select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--grid);background:#0e1630;color:var(--ink)}
  .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{background:#15224d;color:var(--ink);border:1px solid var(--accent);padding:8px 10px;border-radius:10px;cursor:pointer;white-space:nowrap}
  button:hover{background:#1b2b63}
  .kv{display:grid;grid-template-columns:200px 1fr;gap:10px;margin:6px 0}
  .good{color:var(--ok)}
  .bad{color:var(--bad)}
  canvas{width:100%;height:320px;background:#0f1836;border:1px solid var(--grid);border-radius:10px;display:block}
  table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
  th,td{border:1px solid var(--grid);padding:6px;text-align:center}
  th{background:#182045;color:var(--ink)}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .small{font-size:12px;color:var(--muted)}
  .planetbar{display:flex;gap:8px;flex-wrap:wrap;max-height:96px;overflow:auto;padding:6px;background:#0e1630;border:1px solid var(--grid);border-radius:12px}
  .row{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  .chip{border:1px dashed var(--grid);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST-Locked VT↔CIT vRMS — Always-Live Wave + Scan</h1>
  <p class="sub">
    Wave, midline, and acceptance window move continuously and are phase-locked to ω′ = (2π/T)·T<sub>cst</sub>.
    The panel demonstrates (conceptually) the equivalence of Vibrational (v<sub>RMS</sub>) and Influx formulations of surface acceleration,
    with CST timestamping for stability/equilibrium. <strong>Disclaimer:</strong> visualization only; not a proven physical model.
  </p>

  <div class="grid">
    <div class="card">
      <h3>Body & Constants</h3>
      <div class="grid-3">
        <div><label>Radius R (m)</label><input id="R" value="6371000" type="number"/></div>
        <div><label>ρ_mat (kg/m³)</label><input id="rho_mat" value="5514" type="number"/></div>
        <div><label>Mass M (kg)</label><input id="M" value="5.972e24" type="number"/></div>
      </div>
      <div class="grid-3">
        <div><label>g (m/s²)</label><input id="g_obs" value="9.81" step="0.01" type="number"/></div>
        <div><label>c (m/s)</label><input id="c" value="2.99792458e8" type="number"/></div>
        <div><label>κ</label><input id="kappa" value="1" step="0.01" type="number"/></div>
      </div>
      <div class="grid-3">
        <div><label>Boundary</label>
          <select id="boundary">
            <option value="toroid" selected>Toroid</option>
            <option value="spherical">Spherical</option>
          </select>
        </div>
        <div><label>α (spherical)</label><input id="alpha" value="1" step="0.1" type="number"/></div>
        <div><label>T (s)</label><input id="T" value="3240" step="1" type="number"/></div>
      </div>

      <div class="row" style="margin-top:8px">
        <span class="chip">Select a body to auto-fill R, ρ, M, g, T</span>
      </div>
      <div class="planetbar" id="planetBar" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <h3>CST & Wave Controls</h3>
      <div class="grid-3">
        <div><label>T_cst</label><input id="T_cst" value="1.000000" step="0.000001" type="number"/></div>
        <div><label>Δ window (min)</label><input id="delta" value="20" type="number"/></div>
        <div><label>Amplitude (ppm)</label><input id="amp_ppm" value="120" type="number"/></div>
      </div>
      <p class="small">Always-live: no pause/resume. Change any control or select a body to see immediate response.</p>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Live Wave & Results</h3>
    <canvas id="chart" width="1100" height="320"></canvas>
    <div class="row">
      <div id="decision" class="mono"></div>
      <div class="small">Heartbeat: <span id="hb">0</span></div>
      <div class="small">CST Timestamp: <span id="clock" class="mono"></span></div>
    </div>
    <p class="small">
      Blue sine = v(t); dashed midline “breathes” for equilibrium tracking; translucent window drifts sideways (Δ-acceptance visualization).
      Tracer dot rides the wave so motion is obvious even at low frequency.
    </p>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Scan Results</h3>
    <div class="btns">
      <button id="autoScan">Auto-Scan 10×</button>
      <button id="clearScan">Clear Scan</button>
    </div>
    <table id="scanTable">
      <thead><tr><th>#</th><th>τ*</th><th>u_v (J/m³)</th><th>Residual (J/m³)</th><th>Status</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
(function(){
  const el = id => document.getElementById(id);
  const fmtExp = x => (isFinite(x) ? Number(x).toExponential(3) : "—");
  const TWO_PI = 2*Math.PI;

  // Planetary dataset (approximate means)
  const PLANETS = [
    {name:'Sun',     R:6.957e8,   rho:1408,  M:1.989e30, g:274.0, T:3600},
    {name:'Mercury', R:2.4397e6,  rho:5427,  M:3.301e23, g:3.70,  T:3000},
    {name:'Venus',   R:6.0518e6,  rho:5243,  M:4.867e24, g:8.87,  T:3300},
    {name:'Earth',   R:6.371e6,   rho:5514,  M:5.972e24, g:9.81,  T:3240},
    {name:'Moon',    R:1.7374e6,  rho:3344,  M:7.347e22, g:1.62,  T:5460},
    {name:'Mars',    R:3.3895e6,  rho:3933,  M:6.417e23, g:3.71,  T:3540},
    {name:'Jupiter', R:6.9911e7,  rho:1326,  M:1.898e27, g:24.79, T:1800},
    {name:'Saturn',  R:5.8232e7,  rho: 687,  M:5.683e26, g:10.44, T:2100},
    {name:'Uranus',  R:2.5362e7,  rho:1271,  M:8.681e25, g:8.69,  T:2400},
    {name:'Neptune', R:2.4622e7,  rho:1638,  M:1.024e26, g:11.15, T:2520},
    {name:'Pluto',   R:1.1883e6,  rho:1850,  M:1.309e22, g:0.62,  T:6000}
  ];

  // Build planet buttons
  const bar = el('planetBar');
  PLANETS.forEach(p=>{
    const b = document.createElement('button');
    b.textContent = p.name;
    b.onclick = ()=>applyPreset(p);
    bar.appendChild(b);
  });

  function applyPreset(p){
    el('R').value = p.R;
    el('rho_mat').value = p.rho;
    el('M').value = p.M;
    el('g_obs').value = p.g;
    el('T').value = p.T;
  }

  let phase = 0, lastTs = 0, rafId = null, intervalId = null, hb = 0;

  function computeState(){
    const R = +el('R').value,
          rho = +el('rho_mat').value,
          M = +el('M').value,
          g = +el('g_obs').value,
          c = +el('c').value,
          kappa = +el('kappa').value,
          T = Math.max(+el('T').value, 1e-6),
          T_cst = +el('T_cst').value;
    const boundary = el('boundary').value,
          alpha = Math.max(+el('alpha').value, 1e-9);

    const omega = TWO_PI / T;
    const omega_cst = omega * T_cst;

    let v_base = omega_cst * R;
    if (boundary === 'spherical') v_base = (omega_cst * R) / alpha;

    // simplified mapping (concept demo)
    const rho_v = (g * rho * R) / (kappa * TWO_PI * c * c);
    const u_v = rho_v * c * c;
    const rho_in = u_v / (v_base * v_base);

    const amp_ppm = +el('amp_ppm').value;
    const delta = +el('delta').value;

    return {R, rho, M, g, c, kappa, T, T_cst, boundary, alpha, omega_cst, v_base, u_v, rho_in, amp_ppm, delta};
  }

  function vInstant(state, tSec){
    const amp_v = state.v_base * (state.amp_ppm / 1e6);
    return state.v_base + amp_v * Math.sin(state.omega_cst * tSec + phase);
  }

  function drawWave(state, tNow){
    const cnv = el('chart'), ctx = cnv.getContext('2d');
    const w = cnv.width, h = cnv.height;
    ctx.clearRect(0,0,w,h);

    // MOVING acceptance window (side-to-side drift like a "square" band)
    const frameL = 40, frameT = 10, frameW = w-50, frameH = h-30;
    const bandFrac = Math.min(state.delta/60, 0.8);
    const bandW = frameW * bandFrac;
    const bandCx = frameL + frameW/2 + (frameW/4)*Math.sin(tNow*0.5); // gentle left-right drift
    ctx.fillStyle = 'rgba(123,255,177,0.12)';
    ctx.fillRect(bandCx - bandW/2, frameT, bandW, frameH);

    // frame
    ctx.strokeStyle = '#1b2550'; ctx.lineWidth = 1; ctx.strokeRect(frameL,frameT,frameW,frameH);

    // visual amplitude in px (maps ppm -> pixels to make motion obvious)
    const Apx = Math.max(12, state.amp_ppm * 2); // 120ppm => 240px p-p
    const cycles = 3;                             // 3 cycles across width
    const kx = TWO_PI * cycles / frameW;

    // "breathing" midline (moving baseline for equilibrium visualization)
    const midY = frameT + frameH/2;
    const baseDrift = Math.max(6, Apx * 0.12) * Math.sin(phase * 0.25);
    const yBase = midY + baseDrift;

    // sine wave
    ctx.beginPath();
    for(let x=0;x<=frameW;x++){
      const X = frameL + x;
      const y = yBase + Apx * Math.sin(kx * x + phase);
      if(x===0) ctx.moveTo(X,y); else ctx.lineTo(X,y);
    }
    ctx.strokeStyle = '#8fb4ff'; ctx.lineWidth = 2; ctx.stroke();

    // tracer dot moving across width (1s sweep)
    const sweepT = (tNow % 1);
    const xDot = frameL + Math.floor(sweepT * frameW);
    const yDot = yBase + Apx * Math.sin(kx*(xDot-frameL) + phase);
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(xDot, yDot, 4, 0, TWO_PI); ctx.fill();

    // dashed (moving) baseline
    ctx.setLineDash([4,4]); ctx.strokeStyle='#ffd37a';
    ctx.beginPath(); ctx.moveTo(frameL, yBase); ctx.lineTo(frameL+frameW, yBase); ctx.stroke(); ctx.setLineDash([]);
  }

  function updateDecision(state){
    const vNow = vInstant(state, 0);
    const Rres = state.u_v - state.rho_in * vNow * vNow;
    const pass = Math.abs(Rres) < 1e6;
    el('decision').innerHTML =
      `u_v=${fmtExp(state.u_v)} | Residual=${fmtExp(Rres)} | ` +
      `<span style="color:${pass?'#7bffb1':'#ff8c8c'}">${pass?'PASS':'REJECT'}</span>`;
  }

  function frame(ts){
    const tNow = ts/1000;
    const S = computeState();
    const dt = lastTs ? (ts - lastTs) / 1000 : 0;
    lastTs = ts;
    // ALWAYS LIVE: phase always advances
    phase += S.omega_cst * dt;
    updateDecision(S);
    drawWave(S, tNow);
    hb = (hb + 1) % 100000; el('hb').textContent = hb;
    el('clock').textContent = new Date().toLocaleString(); // local CST timestamp
    rafId = requestAnimationFrame(frame);
  }

  function startFallback(){
    if (intervalId) return;
    intervalId = setInterval(()=>{
      const S = computeState();
      phase += S.omega_cst * (1/30);
      updateDecision(S);
      drawWave(S, performance.now()/1000);
      hb = (hb + 1) % 100000; el('hb').textContent = hb;
      el('clock').textContent = new Date().toLocaleString();
    }, 33);
  }

  // Scan controls
  el('autoScan').onclick = ()=>{
    const S = computeState();
    const tbody = el('scanTable').querySelector('tbody');
    tbody.innerHTML = '';
    const now = Date.now();
    for(let i=0;i<10;i++){
      const tSec = i*6; // 6-second steps
      const v_i = vInstant(S, tSec);
      const Rres = S.u_v - S.rho_in * v_i * v_i;
      const pass = Math.abs(Rres) < 1e6;
      const tau = new Date(now + i*6000).toLocaleString();
      const row =
        `<tr><td>${i+1}</td><td>${tau}</td><td>${fmtExp(S.u_v)}</td>` +
        `<td>${fmtExp(Rres)}</td><td style="color:${pass?'#7bffb1':'#ff8c8c'}">${pass?'PASS':'REJECT'}</td></tr>`;
      tbody.insertAdjacentHTML('beforeend', row);
    }
  };
  el('clearScan').onclick = ()=>{ el('scanTable').querySelector('tbody').innerHTML = ''; };

  // Reflect input changes next frame automatically
  ['R','rho_mat','M','g_obs','c','kappa','T','boundary','alpha','T_cst','delta','amp_ppm'].forEach(id=>{
    el(id).addEventListener('input', ()=>{/* picked up next frame */});
  });

  // Kick off animation + robust fallback
  requestAnimationFrame(frame);
  startFallback();

  // Default: Earth
  applyPreset(PLANETS.find(p=>p.name==='Earth'));
})();
</script>
</body>
</html>
