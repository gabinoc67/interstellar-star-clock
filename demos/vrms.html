<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST-Locked v-RMS — Open Toroid (Animated) + Solar System Selector</title>
<meta name="description" content="Live v-RMS wave with CST clock, G ≈ vRMS²/(8πc²), animated open-toroid influx/outflux visualization, and planet/Sun selector (incl. Pluto) with density-scaled 54-minute period estimate. Includes Auto-Scan 10× log and Excel-compatible export." />
<style>
  :root{
    /* Gabino site palette */
    --bg:#0b1222;--panel:#111a34;--ink:#eaf0ff;--muted:#a7b7e6;--accent:#8fb4ff;--grid:#1b2550;
    --ok:#7bffb1;--warn:#ffd37a;--bad:#ff8c8c;--card:#0e1740;--border:#213067;--btn:#162455;--btnHover:#1d2e6e
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  a{color:var(--accent);text-decoration:none}
  .wrap{max-width:1320px;margin:0 auto;padding:18px}
  h1{margin:0 0 8px;font-size:1.35rem}
  .sub{color:var(--muted);margin:0 0 14px;font-size:0.92rem}
  .grid{display:grid;grid-template-columns:1.15fr 0.85fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:0 0 8px;font-size:1.05rem}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .small{font-size:0.88rem;color:var(--muted)}
  .kpi{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
  .kpi div{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:8px}
  .kpi .v{font-size:1rem}
  .btns{display:flex;flex-wrap:wrap;gap:8px}
  button{background:var(--btn);color:var(--ink);border:1px solid var(--accent);border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{background:var(--btnHover)}
  button:disabled{opacity:.6;cursor:not-allowed}
  .toggle{display:flex;align-items:center;gap:8px;margin:6px 0}
  input[type="range"], select{width:100%}
  canvas{display:block;background:linear-gradient(transparent,transparent),
    repeating-linear-gradient(0deg,transparent 0 22px,var(--grid) 22px 23px);
    border-radius:12px;border:1px solid var(--border)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .badge{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:.8rem;color:var(--muted)}
  .good{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .footer{color:var(--muted);font-size:.85rem;margin-top:10px}
  .topbar{display:flex;gap:10px;align-items:center;margin-bottom:10px}
  .topbar a.btn{background:var(--btn);border:1px solid var(--accent);padding:8px 12px;border-radius:10px}
  table{width:100%;border-collapse:collapse;font-size:.9rem}
  th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left}
  th{color:var(--muted);font-weight:600}
  tbody tr:hover{background:rgba(143,180,255,0.06)}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:.8rem}
  .right{display:flex;justify-content:flex-end;gap:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <a class="btn" href="https://gabinoc67.github.io/interstellar-star-clock/">← Back to Quick Links</a>
    <span class="pill">CST-Locked</span>
    <span class="pill">Live</span>
  </div>

  <h1>CST-Locked v-RMS Gravity Equivalence</h1>
  <p class="sub">
    Continuous v-RMS wave shows gravity as an energy-density gradient in a dynamic medium—<em>Vibrational form ≡ Influx form</em>.
    Calibrated from Earth’s ~54-minute reference; density-scaled to Sun & planets (incl. Pluto).
    Real-time \(G_{\text{est}} = v_{\rm RMS}^2/(8\pi c^2)\).
    <span class="badge">Always Running</span>
  </p>

  <div class="grid">
    <!-- LEFT: Live Wave + Results + Controls + Auto-Scan Panel -->
    <div class="card">
      <h2>Live Wave &amp; Results</h2>
      <canvas id="wave" width="1000" height="260" aria-label="v-RMS live wave"></canvas>

      <div class="kpi">
        <div>
          <div class="small">v-RMS (m/s)</div>
          <div id="vOut" class="v mono">0.000</div>
        </div>
        <div>
          <div class="small">G_est (m³·kg⁻¹·s⁻²)</div>
          <div id="gOut" class="v mono">0.00000000000</div>
        </div>
        <div>
          <div class="small">Δ vs G₀</div>
          <div id="errOut" class="v mono">0.00%</div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Body &amp; Calibration</h2>
          <label class="small">Select body
            <select id="bodySel">
              <option>Earth</option>
              <option>Sun</option>
              <option>Mercury</option>
              <option>Venus</option>
              <option>Mars</option>
              <option>Jupiter</option>
              <option>Saturn</option>
              <option>Uranus</option>
              <option>Neptune</option>
              <option>Pluto</option>
            </select>
          </label>
          <div class="small">
            Density-scaled period estimate:
            <span id="periodS" class="mono"></span> s
            (<span id="periodMin" class="mono"></span> min)
          </div>
          <div class="small">Method: <span class="mono">T_body ≈ 54 min × √(ρ⊕ / ρ_body)</span> — heuristic for demo alignment.</div>
          <label class="small">Fine tune period (±20%)<br/>
            <input id="periodFine" type="range" min="0.8" max="1.2" step="0.005" value="1.000">
          </label>
          <label class="small">Base amplitude (m/s)
            <input id="amp" type="range" min="0" max="0.06" step="0.0005" value="0.030">
          </label>
          <label class="small">Noise mix
            <input id="noise" type="range" min="0" max="1" step="0.02" value="0.18">
          </label>
          <label class="small">Vibrational ↔ Influx blend
            <input id="blend" type="range" min="0" max="1" step="0.01" value="0.50">
          </label>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">CST Phase / Clock</h2>
          <div class="small">Local (browser) time is used as CST stamp/phase reference.</div>
          <canvas id="phaseDial" width="220" height="160" aria-label="CST phase dial"></canvas>
          <div class="small">Phase (rad): <span id="phaseOut" class="mono">0.000</span></div>
          <div class="small">CST Time: <span id="timeOut" class="mono">--:--:--</span></div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Controls</h2>
          <div class="btns">
            <button id="scan10">Auto-Scan 10×</button>
            <button id="clearScan">Clear Scan</button>
            <button id="pauseBtn">Pause</button>
            <button id="resumeBtn" disabled>Resume</button>
          </div>
          <div class="small">Always-live rendering (requestAnimationFrame + fallback). “Pause” halts drawing; CST phase continues for timing consistency.</div>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">Equation (Displayed)</h2>
          <div class="small mono">
            G_est = vRMS² / (8·π·c²), &nbsp; c = 299,792,458 m/s, &nbsp; G₀ = 6.67430×10⁻¹¹
          </div>
          <div class="small">This shows <em>vibrational</em> and <em>influx</em> forms map to the same surface g via the shared kinetic relic v-RMS.</div>
        </div>
      </div>

      <!-- NEW: Auto-Scan Panel (10 entries) -->
      <div class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
          <h2 style="margin-bottom:6px">Auto-Scan Log (10)</h2>
          <div class="right">
            <button id="exportCsv">Export CSV (Excel)</button>
          </div>
        </div>
        <div class="small">Each Auto-Scan captures v-RMS, G_est, and Δ vs G₀ with a CST timestamp and body selection.</div>
        <table id="scanTable" aria-label="Auto-scan results table">
          <thead>
            <tr>
              <th>#</th>
              <th>Time (CST)</th>
              <th>Body</th>
              <th>v-RMS (m/s)</th>
              <th>G_est (m³·kg⁻¹·s⁻²)</th>
              <th>Δ vs G₀</th>
            </tr>
          </thead>
          <tbody id="scanBody">
            <!-- rows injected here -->
          </tbody>
        </table>
        <div class="small" id="scanStatus"></div>
      </div>
    </div>

    <!-- RIGHT: Explanations + Animated Toroid -->
    <div class="card">
      <h2>Dynamic Matter ↔ Dynamic Energy (Physical Substrate)</h2>
      <p class="small">
        Near-surface field is modeled as a dual substrate: <strong>Dynamic Matter</strong> supports compressional/elastic modes (vibrational form),
        while <strong>Dynamic Energy</strong> carries directed influx/outflux momentum (influx form). The live v-RMS is the measurable kinetic
        statistic both share. A stable g field appears when the energy-density gradient is stationary in the CST phase frame.
      </p>

      <h2 style="margin-top:12px">Open-Toroidal Boundary (Animated)</h2>
      <div class="toggle">
        <input id="toroidToggle" type="checkbox" />
        <label for="toroidToggle" class="small">Show open-toroid visualization (blink + motion)</label>
      </div>

      <div class="row" style="grid-template-columns:1fr 1fr;gap:10px;margin-top:6px">
        <div class="card">
          <label class="small">Flow direction
            <select id="flowDir">
              <option value="in">Influx (arrows point inward)</option>
              <option value="out">Outflux (arrows point outward)</option>
            </select>
          </label>
          <label class="small">Arrow blink speed
            <input id="blinkSpeed" type="range" min="0.5" max="3" step="0.05" value="1.2">
          </label>
          <label class="small">Packet travel speed
            <input id="packetSpeed" type="range" min="0.2" max="3" step="0.05" value="1.4">
          </label>
        </div>
        <div class="card">
          <label class="small">Ring radius (visual)
            <input id="ringScale" type="range" min="0.6" max="1.4" step="0.02" value="1.00">
          </label>
          <label class="small">Arrow count
            <input id="arrowCount" type="range" min="4" max="16" step="1" value="8">
          </label>
          <label class="small">Packet density
            <input id="packetCount" type="range" min="4" max="60" step="1" value="18">
          </label>
        </div>
      </div>

      <canvas id="toroid" width="520" height="320" aria-label="Animated toroidal boundary"></canvas>
      <p class="small">
        The torus pulses and streams “packets” around its major circle. Blink = kinetic intensity; motion = net flux.
        Arrows blink and point in the selected flow direction. All animation is CST-phase locked to match the v-RMS clock.
      </p>

      <div class="footer">
        <strong>Safety &amp; Disclaimer:</strong> Conceptual research visualizer. Periods for non-Earth bodies use density-scaled estimates for demonstration;
        replace with observed fundamental modes as data become available. Validate with independent instrumentation.
      </div>
    </div>
  </div>
</div>

<script>
(()=>{
  // ======= Physical constants & body data =======
  const c = 299792458;                // m/s
  const G0 = 6.67430e-11;             // m^3 kg^-1 s^-2 (reference)
  const rhoEarth = 5514;              // kg/m^3
  const basePeriodEarth = 54*60;      // 54 minutes in seconds

  // Mean densities (kg/m^3). Pluto included.
  const bodies = {
    "Sun":     { rho: 1408 },
    "Mercury": { rho: 5427 },
    "Venus":   { rho: 5243 },
    "Earth":   { rho: 5514 },
    "Mars":    { rho: 3933 },
    "Jupiter": { rho: 1326 },
    "Saturn":  { rho:   687 },
    "Uranus":  { rho:  1270 },
    "Neptune": { rho:  1638 },
    "Pluto":   { rho:  1850 }
  };

  // ======= DOM =======
  const wave = document.getElementById('wave');
  const ctx = wave.getContext('2d');
  const vOut = document.getElementById('vOut');
  const gOut = document.getElementById('gOut');
  const errOut = document.getElementById('errOut');

  const phaseDial = document.getElementById('phaseDial');
  const pctx = phaseDial.getContext('2d');
  const timeOut = document.getElementById('timeOut');
  const phaseOut = document.getElementById('phaseOut');

  const bodySel = document.getElementById('bodySel');
  const periodSOut = document.getElementById('periodS');
  const periodMinOut = document.getElementById('periodMin');
  const periodFine = document.getElementById('periodFine');

  const amp = document.getElementById('amp');
  const noise = document.getElementById('noise');
  const blend = document.getElementById('blend');

  const scan10 = document.getElementById('scan10');
  const clearScan = document.getElementById('clearScan');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');

  const toroidToggle = document.getElementById('toroidToggle');
  const flowDir = document.getElementById('flowDir');
  const blinkSpeed = document.getElementById('blinkSpeed');
  const packetSpeed = document.getElementById('packetSpeed');
  const ringScale = document.getElementById('ringScale');
  const arrowCount = document.getElementById('arrowCount');
  const packetCount = document.getElementById('packetCount');

  const toroid = document.getElementById('toroid');
  const tctx = toroid.getContext('2d');

  const scanBody = document.getElementById('scanBody');
  const scanStatus = document.getElementById('scanStatus');
  const exportCsvBtn = document.getElementById('exportCsv');

  // ======= State =======
  let running = true;
  let scanMarks = [];
  let period = basePeriodEarth; // dynamic, depends on body + fine-tune

  // Auto-scan state
  let isScanning = false;
  let scanRows = []; // {idx,time,body,v,g,err}

  function densityScaledPeriod(bodyName){
    const rho = bodies[bodyName]?.rho ?? rhoEarth;
    return basePeriodEarth * Math.sqrt(rhoEarth / rho);
  }

  function updatePeriodUI(){
    const base = densityScaledPeriod(bodySel.value);
    period = base * parseFloat(periodFine.value);
    periodSOut.textContent = period.toFixed(1);
    periodMinOut.textContent = (period/60).toFixed(2);
  }

  // ======= Time & CST Phase =======
  const twoPi = Math.PI*2;
  function nowSec(){ return Date.now()/1000; }
  function cstPhase(){
    const t = nowSec();
    return (t % period) / period * twoPi; // [0,2π)
  }

  // ======= vRMS model =======
  function computeVRMS(ph){
    const A = parseFloat(amp.value);
    const n = parseFloat(noise.value);
    const b = parseFloat(blend.value);

    const vib = Math.sin(ph); // vibrational
    const tri = 2*Math.abs((ph/Math.PI)%2 - 1) - 1;
    const saw = (ph/Math.PI)%2 - 1;
    const inf = 0.6*tri + 0.4*saw; // influx profile

    const base = (1-b)*vib + b*inf;
    const rnd = (Math.random()*2-1)*0.5;
    const colored = 0.7*rnd + 0.3*Math.sin(ph*3.7+0.5);

    return Math.abs(A*((1-n)*base + n*colored));
  }

  function gFromVRMS(v){ return (v*v)/(8*Math.PI*c*c); }

  // ======= Drawing: Wave =======
  function drawWave(){
    const W = wave.width, H = wave.height;
    ctx.clearRect(0,0,W,H);

    // baseline
    ctx.strokeStyle = '#28407f'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0,H-30); ctx.lineTo(W,H-30); ctx.stroke();

    // gather recent samples
    const N = W;
    const samples = [];
    for(let i=0;i<N;i++){
      const tBack = (N-i)/N * 6; // 6 s window
      const ph = ((nowSec()-tBack) % period)/period * twoPi;
      samples.push(computeVRMS(ph));
    }

    const vmax = Math.max(0.001, parseFloat(amp.value)*1.2);
    ctx.strokeStyle = '#8fb4ff'; ctx.lineWidth = 2;
    ctx.beginPath();
    for(let x=0;x<N;x++){
      const v = samples[x];
      const y = H-30 - (v/vmax)*(H-50);
      if(x===0) ctx.moveTo(x+2,y); else ctx.lineTo(x+2,y);
    }
    ctx.stroke();

    // scan markers
    if(scanMarks.length){
      ctx.strokeStyle = '#7bffb1'; ctx.lineWidth = 1.5;
      scanMarks.forEach(m=>{
        const x = W - ((nowSec()-m.t)/6)*W;
        if(x>=0){
          ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,H-35); ctx.stroke();
        }
      });
    }
  }

  // ======= Drawing: KPIs =======
  function drawKPIs(v,g){
    vOut.textContent = v.toFixed(6);
    gOut.textContent = g.toExponential(11);
    const err = ((g - G0)/G0)*100;
    const e = isFinite(err)? err.toFixed(3)+'%' : '—';
    errOut.textContent = e;
    errOut.className = 'v mono ' + (Math.abs(err)<5?'good':Math.abs(err)<20?'warn':'bad');
  }

  // ======= Drawing: Phase Dial =======
  function drawPhase(ph){
    const W = phaseDial.width, H = phaseDial.height;
    pctx.clearRect(0,0,W,H);
    const cx=W/2, cy=H/2+10, r=60;

    // dial
    pctx.strokeStyle='#28407f'; pctx.lineWidth=2;
    pctx.beginPath(); pctx.arc(cx,cy,r,0,Math.PI*2); pctx.stroke();

    // ticks
    pctx.strokeStyle='#213067'; pctx.lineWidth=1;
    for(let k=0;k<12;k++){
      const ang=k*(Math.PI/6);
      const tx1=cx + (r-8)*Math.cos(ang - Math.PI/2);
      const ty1=cy + (r-8)*Math.sin(ang - Math.PI/2);
      const tx2=cx + (r)*Math.cos(ang - Math.PI/2);
      const ty2=cy + (r)*Math.sin(ang - Math.PI/2);
      pctx.beginPath(); pctx.moveTo(tx1,ty1); pctx.lineTo(tx2,ty2); pctx.stroke();
    }

    // hand
    pctx.strokeStyle='#8fb4ff'; pctx.lineWidth=3;
    const x=cx + r*Math.cos(ph - Math.PI/2);
    const y=cy + r*Math.sin(ph - Math.PI/2);
    pctx.beginPath(); pctx.moveTo(cx,cy); pctx.lineTo(x,y); pctx.stroke();

    phaseOut.textContent = ph.toFixed(3);
    timeOut.textContent = (new Date()).toLocaleTimeString();
  }

  // ======= Drawing: Animated Toroid =======
  function drawToroid(ph){
    const W=toroid.width, H=toroid.height;
    tctx.clearRect(0,0,W,H);
    if(!toroidToggle.checked) return;

    const dir = flowDir.value; // 'in' or 'out'
    const blink = parseFloat(blinkSpeed.value);
    const pSpeed = parseFloat(packetSpeed.value);
    const scale = parseFloat(ringScale.value);
    const nArrows = parseInt(arrowCount.value,10);
    const nPackets = parseInt(packetCount.value,10);

    const cx=W/2, cy=H/2;
    const R=110*scale, r=40*scale;

    // Outer ring
    tctx.strokeStyle='#28407f'; tctx.lineWidth=2;
    tctx.beginPath(); tctx.ellipse(cx,cy,R,r,0,0,Math.PI*2); tctx.stroke();

    // inner pulse synced to phase
    const pulse = 0.10*Math.sin(ph*2);
    const Rin = R*(1-0.25+pulse), rin = r*(1-0.25+pulse);
    tctx.beginPath(); tctx.ellipse(cx,cy,Rin,rin,0,0,Math.PI*2); tctx.stroke();

    // Blinking arrows positioned evenly around ring, pointing in/out
    const alpha = 0.35 + 0.65*(0.5*(1+Math.sin(ph*blink*2))); // 0.35..1.0
    for(let k=0;k<nArrows;k++){
      const ang = k*(twoPi/nArrows);
      const ax = cx + R*Math.cos(ang);
      const ay = cy + r*Math.sin(ang);

      // inward/outward direction
      const baseDir = Math.atan2(cy - ay, cx - ax); // toward center
      const theta = (dir==='in') ? baseDir : baseDir + Math.PI;

      tctx.save();
      tctx.globalAlpha = alpha;
      tctx.translate(ax,ay); tctx.rotate(theta);
      tctx.strokeStyle='#8fb4ff'; tctx.lineWidth=2;
      const len=26*scale;
      tctx.beginPath(); tctx.moveTo(0,0); tctx.lineTo(len,0); tctx.stroke();
      tctx.beginPath();
      tctx.moveTo(len,0); tctx.lineTo(len-6,4); tctx.lineTo(len-6,-4); tctx.closePath(); tctx.stroke();
      tctx.restore();
    }

    // Traveling packets
    const sign = (dir==='in') ? 1 : -1; // convention
    const baseRate = pSpeed * 0.9; // radians/sec scale
    const t = nowSec();
    for(let j=0;j<nPackets;j++){
      const phaseJ = (j/nPackets)*twoPi;
      const psi = (phaseJ + sign*(t*baseRate)) % twoPi;
      const px = cx + R*Math.cos(psi);
      const py = cy + r*Math.sin(psi);

      const s = 3.0*scale*(1.0+0.2*Math.sin(ph*3 + j));
      tctx.beginPath();
      tctx.fillStyle = '#7bffb1';
      tctx.arc(px,py,s,0,twoPi); tctx.fill();
    }
  }

  // ======= Auto-Scan: capture 10 sequential samples, show table, allow CSV export =======
  function cstTimestamp(){
    // Use local time (assumed CST for your site); if you host globally, you could adjust tz here.
    const d = new Date();
    const pad = n=>String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function appendScanRow(row){
    // row: {idx,time,body,v,g,err}
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.idx}</td>
      <td class="mono">${row.time}</td>
      <td>${row.body}</td>
      <td class="mono">${row.v.toFixed(6)}</td>
      <td class="mono">${row.g.toExponential(11)}</td>
      <td class="mono">${row.err.toFixed(3)}%</td>
    `;
    scanBody.appendChild(tr);
  }

  function rebuildTable(){
    scanBody.innerHTML = '';
    scanRows.forEach(r=>appendScanRow(r));
  }

  function clearScanAll(){
    scanRows = [];
    scanMarks = [];
    rebuildTable();
    scanStatus.textContent = 'Cleared.';
  }

  async function runAutoScan10(){
    if(isScanning) return;
    isScanning = true;
    scanStatus.textContent = 'Auto-Scan running… (10 samples)';
    scanRows = [];
    scanMarks = [];

    const body = bodySel.value;
    const stepMs = 400; // spacing between each capture
    for(let i=1;i<=10;i++){
      // Wait step (except immediate first capture)
      if(i>1) await new Promise(res=>setTimeout(res, stepMs));

      // Capture current values
      const ph = cstPhase();
      const v = computeVRMS(ph);
      const g = gFromVRMS(v);
      const err = ((g - G0)/G0)*100;

      // Mark on wave
      scanMarks.push({t: nowSec()});

      // Store row
      const row = { idx:i, time:cstTimestamp(), body, v, g, err };
      scanRows.push(row);
      appendScanRow(row);
    }
    scanStatus.textContent = 'Auto-Scan complete.';
    isScanning = false;
  }

  function exportCSV(){
    if(!scanRows.length){
      scanStatus.textContent = 'Nothing to export — run Auto-Scan first.';
      return;
    }
    const hdr = ['Index','Time_CST','Body','vRMS_m_per_s','G_est_m3kg-1s-2','Delta_vs_G0_percent'];
    const lines = [hdr.join(',')];
    scanRows.forEach(r=>{
      lines.push([r.idx, r.time, r.body, r.v.toFixed(6), r.g.toExponential(11), r.err.toFixed(3)].join(','));
    });
    const csv = lines.join('\r\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const ts = cstTimestamp().replace(/[: ]/g,'-');
    const fname = `vrms_autoscan_${bodySel.value}_${ts}.csv`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fname;
    a.click();
    URL.revokeObjectURL(a.href);
    scanStatus.textContent = `Exported ${fname}`;
  }

  // ======= Animation loop =======
  let rafId=null, fallbackId=null;
  function loop(){
    if(!running){ rafId = requestAnimationFrame(loop); return; }
    const ph = cstPhase();
    const v = computeVRMS(ph);
    const g = gFromVRMS(v);

    drawWave();
    drawKPIs(v,g);
    drawPhase(ph);
    drawToroid(ph);

    rafId = requestAnimationFrame(loop);
  }
  function start(){
    if(rafId==null) rafId = requestAnimationFrame(loop);
    if(fallbackId==null){
      fallbackId = setInterval(()=>{/* minimal fallback tick to keep UI alive if rAF throttles */}, 600);
    }
  }

  // ======= Controls =======
  scan10.onclick = runAutoScan10;
  clearScan.onclick = clearScanAll;
  exportCsvBtn.onclick = exportCSV;

  pauseBtn.onclick = ()=>{ running=false; pauseBtn.disabled=true; resumeBtn.disabled=false; };
  resumeBtn.onclick = ()=>{ running=true; resumeBtn.disabled=true; pauseBtn.disabled=false; };

  // Body / period handlers
  bodySel.onchange = updatePeriodUI;
  periodFine.oninput = updatePeriodUI;

  // Init
  updatePeriodUI();
  start();
})();
</script>
</body>
</html>
