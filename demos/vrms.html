<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST-Locked v-RMS Gravity Equivalence — Always-Live Wave</title>
<meta name="description" content="Live v-RMS wave showing gravity as energy-density gradient (Vibrational ≡ Influx), CST phase/clock, 54-minute calibration, and G ≈ vRMS²/(8πc²) readout with toroidal boundary visualization." />
<style>
  :root{
    --bg:#0b1222;--panel:#121a33;--ink:#eaf0ff;--muted:#a9b7e3;--accent:#8fb4ff;--grid:#1b2550;
    --ok:#7bffb1;--warn:#ffd37a;--bad:#ff8c8c;--card:#0f1840;--border:#213067
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  a{color:var(--accent)}
  .wrap{max-width:1300px;margin:0 auto;padding:18px}
  h1{margin:0 0 8px;font-size:1.35rem}
  .sub{color:var(--muted);margin:0 0 14px;font-size:0.92rem}
  .grid{display:grid;grid-template-columns:1.15fr 0.85fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:0 0 8px;font-size:1.05rem}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .small{font-size:0.88rem;color:var(--muted)}
  .kpi{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:8px}
  .kpi div{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:8px}
  .kpi .v{font-size:1rem}
  .btns{display:flex;flex-wrap:wrap;gap:8px}
  button{background:#15245a;color:var(--ink);border:1px solid var(--accent);border-radius:10px;padding:8px 10px;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  .toggle{display:flex;align-items:center;gap:8px;margin:6px 0}
  input[type="range"]{width:100%}
  canvas{display:block;background:linear-gradient(transparent,transparent), repeating-linear-gradient(0deg,transparent 0 22px,var(--grid) 22px 23px);border-radius:12px;border:1px solid var(--border)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .badge{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:.8rem;color:var(--muted)}
  .good{color:var(--ok)}
  .warn{color:var(--warn)}
  .bad{color:var(--bad)}
  .footer{color:var(--muted);font-size:.85rem;margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
  <h1>CST-Locked v-RMS Gravity Equivalence</h1>
  <p class="sub">
    Continuous v-RMS wave shows gravity as an energy-density gradient in a dynamic medium—<em>Vibrational form ≡ Influx form</em>.
    Calibrated to Earth’s ~54-minute fundamental; shows \(G \approx v_{\rm RMS}^2/(8\pi c^2)\), phase-locked to CST.
    <span class="badge">Live</span>
  </p>

  <div class="grid">
    <!-- LEFT: Live Wave + Results -->
    <div class="card">
      <h2>Live Wave &amp; Results (Always Running)</h2>
      <canvas id="wave" width="1000" height="260" aria-label="v-RMS live wave"></canvas>

      <div class="kpi">
        <div>
          <div class="small">v-RMS (m/s)</div>
          <div id="vOut" class="v mono">0.000</div>
        </div>
        <div>
          <div class="small">G_est (m³·kg⁻¹·s⁻²)</div>
          <div id="gOut" class="v mono">0.00000000000</div>
        </div>
        <div>
          <div class="small">Δ vs G₀</div>
          <div id="errOut" class="v mono">0.00%</div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Calibration • 54-minute Mode</h2>
          <div class="small">Period (s) = <span id="periodS" class="mono"></span> • ω = 2π/Period</div>
          <label class="small">Base amplitude (m/s)
            <input id="amp" type="range" min="0" max="0.06" step="0.0005" value="0.030">
          </label>
          <label class="small">Noise mix
            <input id="noise" type="range" min="0" max="1" step="0.02" value="0.18">
          </label>
          <label class="small">Vibrational ↔ Influx blend
            <input id="blend" type="range" min="0" max="1" step="0.01" value="0.50">
          </label>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">CST Phase / Clock</h2>
          <div class="small">Local (browser) time is used as CST stamp/phase reference.</div>
          <canvas id="phaseDial" width="220" height="160" aria-label="CST phase dial"></canvas>
          <div class="small">Phase (rad): <span id="phaseOut" class="mono">0.000</span></div>
          <div class="small">CST Time: <span id="timeOut" class="mono">--:--:--</span></div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Controls</h2>
          <div class="btns">
            <button id="scan10">Auto-Scan 10×</button>
            <button id="clearScan">Clear Scan</button>
            <button id="pauseBtn">Pause</button>
            <button id="resumeBtn" disabled>Resume</button>
          </div>
          <div class="small">Always-live rendering (requestAnimationFrame + fallback). “Pause” only halts drawing; the CST phase keeps time for consistency.</div>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">Equation (Displayed)</h2>
          <div class="small mono">
            G_est = vRMS² / (8·π·c²), &nbsp; c = 299,792,458 m/s, &nbsp; G₀ = 6.67430×10⁻¹¹
          </div>
          <div class="small">This makes the <em>vibrational</em> and <em>influx</em> forms transparent: both map their energy-density dynamics to the same surface g via the shared kinetic relic v-RMS.</div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Explanations + Toroid -->
    <div class="card">
      <h2>Dynamic Matter ↔ Dynamic Energy (Physical Substrate)</h2>
      <p class="small">
        The simulator treats the near-surface field as a dual substrate:
        <strong>Dynamic Matter</strong> supports compressional/elastic modes (vibrational form),
        while <strong>Dynamic Energy</strong> handles directed influx/outflux momentum (influx form).
        The live v-RMS is the measurable kinetic statistic both forms share. A stable g field
        appears when their energy-density gradient is stationary in the CST phase frame.
      </p>

      <h2 style="margin-top:12px">Open-Toroidal Boundary</h2>
      <div class="toggle">
        <input id="toroidToggle" type="checkbox" />
        <label for="toroidToggle" class="small">Show open-toroid visualization</label>
      </div>
      <canvas id="toroid" width="480" height="280" aria-label="Toroidal boundary visualization"></canvas>
      <p class="small">
        The toroid here is a <em>physical</em> inflow/outflow path candidate, not just a container: influx (arrows inward),
        re-radiation (arrows outward). When enabled, its pulsation is phase-locked to the same CST clock as the v-RMS wave.
      </p>

      <h2 style="margin-top:12px">Reviewer Notes / What’s Shown</h2>
      <ul class="small">
        <li><strong>Numerical calibration:</strong> 54-minute Earth mode → sets the live wave’s base frequency.</li>
        <li><strong>G equivalence panel:</strong> Real-time \( G_{\text{est}} \) from v-RMS.</li>
        <li><strong>CST stamp:</strong> Phase dial and time ensure repeatable synchronization for experiments.</li>
        <li><strong>Substrate detail:</strong> Panel above documents Dynamic Matter/Energy roles.</li>
        <li><strong>Toroid:</strong> Optional, to clarify boundary necessity vs convenience.</li>
      </ul>

      <div class="footer">
        <strong>Safety &amp; Disclaimer:</strong> Conceptual research visualizer. Always validate with independent data.
        Not a replacement for geophysical instrumentation. Use responsibly.
      </div>
    </div>
  </div>
</div>

<script>
(()=>{
  // Constants
  const c = 299792458;            // m/s
  const G0 = 6.67430e-11;         // CODATA 2018 (constant used here)
  const periodMin = 54;           // minutes
  const period = periodMin*60;    // seconds
  const twoPi = Math.PI*2;

  // DOM
  const wave = document.getElementById('wave');
  const ctx = wave.getContext('2d');
  const vOut = document.getElementById('vOut');
  const gOut = document.getElementById('gOut');
  const errOut = document.getElementById('errOut');
  const phaseDial = document.getElementById('phaseDial');
  const pctx = phaseDial.getContext('2d');
  const timeOut = document.getElementById('timeOut');
  const phaseOut = document.getElementById('phaseOut');
  const toroid = document.getElementById('toroid');
  const tctx = toroid.getContext('2d');

  const amp = document.getElementById('amp');
  const noise = document.getElementById('noise');
  const blend = document.getElementById('blend');
  const periodS = document.getElementById('periodS');
  const scan10 = document.getElementById('scan10');
  const clearScan = document.getElementById('clearScan');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const toroidToggle = document.getElementById('toroidToggle');

  periodS.textContent = period.toFixed(0);

  // State
  let running = true;
  let scanMarks = []; // store vRMS samples from Auto-Scan
  let lastTs = performance.now();

  // Utility: time + CST phase
  function nowSec(){ return Date.now()/1000; }
  function cstPhase(){
    const t = nowSec();
    // phase wrapped to [0, 2π)
    const ph = (t % period) / period * twoPi;
    return ph;
  }

  // vRMS model: base sinusoid (vibrational) + directed drift (influx) + noise
  function computeVRMS(ph){
    const A = parseFloat(amp.value);       // base m/s scale
    const n = parseFloat(noise.value);     // noise mix 0..1
    const b = parseFloat(blend.value);     // 0 vibrational .. 1 influx

    // Vibrational: classic sinusoid
    const vib = Math.sin(ph);

    // Influx: saw/triangle hybrid emphasizing directed momentum bias
    const tri = 2*Math.abs((ph/Math.PI)%2 - 1) - 1; // triangle in [-1,1]
    const saw = (ph/Math.PI)%2 - 1;                 // saw in [-1,1]
    const inf = 0.6*tri + 0.4*saw;

    // Blend + noise
    const base = (1-b)*vib + b*inf;
    const rnd = (Math.random()*2-1)*0.5;           // uniform noise
    const colored = 0.7*rnd + 0.3*Math.sin(ph*3.7+0.5);

    const v = A*( (1-n)*base + n*colored );
    // vRMS must be non-negative statistic; use absolute magnitude proxy
    return Math.abs(v);
  }

  function gFromVRMS(v){
    return (v*v)/(8*Math.PI*c*c);
  }

  // Drawing helpers
  function drawWave(){
    const W = wave.width, H = wave.height;
    ctx.clearRect(0,0,W,H);

    // axes/grid overlays are provided by CSS bg; draw zero line and labels
    ctx.strokeStyle = '#28407f';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0,H-30);
    ctx.lineTo(W,H-30);
    ctx.stroke();

    // Draw the live wave: recent N samples across width
    const N = W;
    const samples = [];
    for(let i=0;i<N;i++){
      // project backward in time across one screen width
      const tBack = (N-i)/N * 6; // 6 seconds visual window
      const ph = ((nowSec()-tBack) % period)/period * twoPi;
      samples.push(computeVRMS(ph));
    }
    // scale v to pixels
    const vmax = Math.max(0.001, parseFloat(amp.value)*1.2);
    ctx.strokeStyle = '#8fb4ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let x=0;x<N;x++){
      const v = samples[x];
      const y = H-30 - (v/vmax)*(H-50);
      if(x===0) ctx.moveTo(x+2,y);
      else ctx.lineTo(x+2,y);
    }
    ctx.stroke();

    // If we have scan marks, draw them as vertical ticks
    if(scanMarks.length){
      ctx.strokeStyle = '#7bffb1';
      ctx.lineWidth = 1.5;
      scanMarks.forEach(m=>{
        const x = W - ( (nowSec()-m.t) / 6 ) * W; // same 6s window mapping
        if(x>=0){
          ctx.beginPath();
          ctx.moveTo(x,10);
          ctx.lineTo(x,H-35);
          ctx.stroke();
        }
      });
    }
  }

  function drawKPIs(v,g){
    vOut.textContent = v.toFixed(6);
    gOut.textContent = g.toExponential(11);
    const err = ( (g - G0)/G0 )*100;
    errOut.textContent = (isFinite(err)? err.toFixed(3) : '—') + '%';
    errOut.className = 'v mono ' + (Math.abs(err)<5?'good':Math.abs(err)<20?'warn':'bad');
  }

  function drawPhase(ph){
    const W = phaseDial.width, H = phaseDial.height;
    pctx.clearRect(0,0,W,H);
    // Dial
    const cx=W/2, cy=H/2+10, r=60;
    pctx.strokeStyle='#28407f'; pctx.lineWidth=2;
    pctx.beginPath(); pctx.arc(cx,cy,r,0,Math.PI*2); pctx.stroke();
    // hand
    pctx.strokeStyle='#8fb4ff'; pctx.lineWidth=3;
    const x=cx + r*Math.cos(ph - Math.PI/2);
    const y=cy + r*Math.sin(ph - Math.PI/2);
    pctx.beginPath(); pctx.moveTo(cx,cy); pctx.lineTo(x,y); pctx.stroke();
    // ticks
    pctx.strokeStyle='#213067'; pctx.lineWidth=1;
    for(let k=0;k<12;k++){
      const ang=k*(Math.PI/6);
      const tx1=cx + (r-8)*Math.cos(ang - Math.PI/2);
      const ty1=cy + (r-8)*Math.sin(ang - Math.PI/2);
      const tx2=cx + (r)*Math.cos(ang - Math.PI/2);
      const ty2=cy + (r)*Math.sin(ang - Math.PI/2);
      pctx.beginPath(); pctx.moveTo(tx1,ty1); pctx.lineTo(tx2,ty2); pctx.stroke();
    }
    phaseOut.textContent = ph.toFixed(3);
    const now = new Date();
    timeOut.textContent = now.toLocaleTimeString();
  }

  function drawToroid(ph){
    const W=toroid.width, H=toroid.height;
    tctx.clearRect(0,0,W,H);
    if(!toroidToggle.checked) return;

    const cx=W/2, cy=H/2, R=110, r=40;
    // outer torus ring
    tctx.strokeStyle='#28407f'; tctx.lineWidth=2;
    tctx.beginPath();
    tctx.ellipse(cx,cy,R, r, 0, 0, Math.PI*2);
    tctx.stroke();

    // pulsation synced to phase
    const pulse = 0.12*Math.sin(ph*2);
    const Rin = R*(1-0.25+pulse), rin = r*(1-0.25+pulse);
    tctx.beginPath();
    tctx.ellipse(cx,cy,Rin, rin, 0, 0, Math.PI*2);
    tctx.stroke();

    // arrows to suggest influx/outflux
    function arrow(ax,ay,ang,len=26){
      tctx.save();
      tctx.translate(ax,ay); tctx.rotate(ang);
      tctx.strokeStyle='#8fb4ff'; tctx.lineWidth=2;
      tctx.beginPath(); tctx.moveTo(0,0); tctx.lineTo(len,0); tctx.stroke();
      tctx.beginPath();
      tctx.moveTo(len,0); tctx.lineTo(len-6,4); tctx.lineTo(len-6,-4); tctx.closePath(); tctx.stroke();
      tctx.restore();
    }
    // place 6 arrows around
    for(let k=0;k<6;k++){
      const ang = k*(Math.PI/3);
      const ax = cx + (R-10)*Math.cos(ang);
      const ay = cy + (r-6)*Math.sin(ang);
      // inward on one side, outward on the opposite: alternate by k
      arrow(ax,ay,ang + (k%2?Math.PI:0));
    }
  }

  // Animation loop with fallback
  let rafId=null, fallbackId=null;
  function loop(){
    if(!running){ rafId = requestAnimationFrame(loop); return; }
    const ph = cstPhase();
    const v = computeVRMS(ph);
    const g = gFromVRMS(v);

    drawWave();
    drawKPIs(v,g);
    drawPhase(ph);
    drawToroid(ph);

    rafId = requestAnimationFrame(loop);
  }
  function start(){
    if(rafId==null) rafId = requestAnimationFrame(loop);
    if(fallbackId==null){
      fallbackId = setInterval(()=>{ if(!running) return; /* ensures some updates if rAF throttles */ }, 500);
    }
  }

  // Controls
  scan10.onclick = ()=>{
    for(let i=0;i<10;i++){
      scanMarks.push({t:nowSec() + i*0.15});
    }
  };
  clearScan.onclick = ()=>{ scanMarks.length=0; };
  pauseBtn.onclick = ()=>{
    running=false; pauseBtn.disabled=true; resumeBtn.disabled=false;
  };
  resumeBtn.onclick = ()=>{
    running=true; resumeBtn.disabled=true; pauseBtn.disabled=false;
  };

  // Kickoff
  start();
})();
</script>
</body>
</html>
