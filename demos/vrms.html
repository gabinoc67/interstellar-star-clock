<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST‑Locked v-RMS — VT ≡ CIT • Open Toroid • DC/DE/DM Coherence • Harmony Glow</title>
<meta name="description" content="Live vRMS, VT↔CIT equivalence (G = v^2/(8πc^2)), Earth 54‑min reference, DC/DE/DM triad coherence control, CST clock, toroidal animation, presets, Auto‑Scan 10× with CSV export, and Harmony Glow visuals (toroid brightness, wave breathing, background cross‑fade)." />
<style>
  :root{
    --bg-ordered:#0b1222;   /* cool blue */
    --bg-chaotic:#3a0d0d;   /* deep red */
    --panel:#0f1839;--ink:#eaf0ff;--muted:#9fb2e4;--accent:#8fb4ff;--grid:#1b2550;
    --ok:#7bffb1;--warn:#ffd37a;--bad:#ff8c8c;--card:#0e1740;--border:#213067;--btn:#162455;--btnH:#1d2e6e
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  body{background:var(--bg-ordered);} /* will be cross‑faded by JS */
  a{color:var(--accent);text-decoration:none}
  .wrap{max-width:1320px;margin:0 auto;padding:18px}
  h1{margin:0 0 8px;font-size:1.35rem}
  .sub{color:var(--muted);margin:0 0 14px;font-size:0.92rem}
  .grid{display:grid;grid-template-columns:1.12fr 0.88fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:0 0 8px;font-size:1.05rem}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .small{font-size:0.88rem;color:var(--muted)}
  .kpi{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px;margin-top:8px}
  .kpi div{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:8px}
  .kpi .v{font-size:1rem}
  .btns{display:flex;flex-wrap:wrap;gap:8px}
  button{background:var(--btn);color:var(--ink);border:1px solid var(--accent);border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{background:var(--btnH)} button:disabled{opacity:.6;cursor:not-allowed}
  label.small{display:block;margin:8px 0 6px}
  input[type="number"], select, textarea{width:100%;background:#0f1840;color:var(--ink);border:1px solid var(--border);border-radius:10px;padding:8px}
  input[type="range"]{width:100%}
  input[type="checkbox"]{transform:scale(1.1)}
  canvas{display:block;background:linear-gradient(transparent,transparent),
    repeating-linear-gradient(0deg,transparent 0 22px,var(--grid) 22px 23px);
    border-radius:12px;border:1px solid var(--border)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:.8rem;color:var(--muted)}
  .legend{display:flex;gap:10px;flex-wrap:wrap}
  .legend .item{display:flex;align-items:center;gap:6px}
  .legend .dot{width:10px;height:10px;border-radius:999px;border:1px solid var(--border);background:#7bffb1}
  table{width:100%;border-collapse:collapse;font-size:.9rem}
  th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left}
  th{color:var(--muted);font-weight:600}
  tbody tr:hover{background:rgba(143,180,255,0.06)}
  .good{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;gap:10px;align-items:center;margin-bottom:10px">
    <a class="pill" href="https://gabinoc67.github.io/interstellar-star-clock/">← Back to Quick Links</a>
    <span class="pill">CST‑Locked</span><span class="pill">VT ≡ CIT</span><span class="pill">Live</span>
  </div>

  <h1>CST‑Locked v‑RMS Gravity Equivalence — VT (Vibration) ≡ CIT (Influx)</h1>
  <p class="sub">
    Live identification of \(G\) via \(G_{\text{est}}=v_{\rm RMS}^2/(8\pi c^2)\). Earth’s ~54‑min reference with density scaling to other bodies.
    VT↔CIT mapping (\(\rho_v c^2=\rho_{\rm influx} v_{\rm RMS}^2\)), open‑toroid animation, CST phase dial, DC/DE/DM triad, Auto‑Scan 10×, CSV export.
    <b>New:</b> <i>Harmony Glow</i> visuals (toroid brightening, wave breathing, background cross‑fade).
  </p>

  <div class="grid">
    <!-- LEFT column -->
    <div class="card">
      <h2>Live Wave & Results</h2>
      <canvas id="wave" width="1000" height="260" aria-label="v-RMS live wave"></canvas>

      <div class="kpi">
        <div><div class="small">v‑RMS (m/s)</div><div id="vOut" class="v mono">0.000000</div></div>
        <div><div class="small">G_est (m³·kg⁻¹·s⁻²)</div><div id="gOut" class="v mono">0.00000000000e+00</div></div>
        <div><div class="small">Δ vs G₀</div><div id="errOut" class="v mono">0.00%</div></div>
        <div><div class="small">Tolerance</div><div id="tolOut" class="v mono">±5.0% (base)</div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <!-- Calibration + Presets -->
        <div class="card">
          <h2 style="margin-bottom:6px">Body & Calibration</h2>

          <label class="small">Planet preset
            <select id="presetSel">
              <option value="Earth">Earth</option><option value="Sun">Sun</option><option value="Mercury">Mercury</option><option value="Venus">Venus</option><option value="Mars">Mars</option>
              <option value="Jupiter">Jupiter</option><option value="Saturn">Saturn</option><option value="Uranus">Uranus</option><option value="Neptune">Neptune</option><option value="Pluto">Pluto</option>
            </select>
          </label>
          <div class="btns" style="margin-bottom:6px">
            <button id="applyPreset">Apply Preset</button>
            <button id="autoCal">Auto‑Calibrate to G₀</button>
          </div>

          <label class="small">Select body
            <select id="bodySel">
              <option>Earth</option><option>Sun</option><option>Mercury</option><option>Venus</option><option>Mars</option>
              <option>Jupiter</option><option>Saturn</option><option>Uranus</option><option>Neptune</option><option>Pluto</option>
            </select>
          </label>

          <label class="small">Mode library (Earth reference)
            <select id="modeSel">
              <option value="54">Reference: 54 min</option>
              <option value="60">Alt: 60 min</option>
              <option value="45">Alt: 45 min</option>
              <option value="30">Alt: 30 min</option>
              <option value="custom">Custom (minutes below)</option>
            </select>
          </label>
          <label class="small">Custom mode (minutes)
            <input id="modeCustom" type="number" min="1" step="0.1" value="54">
          </label>
          <div class="small">Density‑scaled period: <span id="periodS" class="mono">—</span> s (<span id="periodMin" class="mono">—</span> min).</div>
          <div class="small">T<sub>body</sub> = T<sub>EarthMode</sub> × √(ρ⊕/ρ<sub>body</sub>) × fine‑tune</div>
          <label class="small">Fine‑tune factor (×, 0.8–1.2)
            <input id="periodFineNum" type="number" min="0.8" max="1.2" step="0.005" value="1.000">
          </label>

          <label class="small">Base amplitude A (m/s)
            <input id="ampNum" type="number" min="0" max="40000" step="0.001" value="12278.450">
          </label>
          <label class="small">Noise mix n (0–1)
            <input id="noiseNum" type="number" min="0" max="1" step="0.01" value="0.30">
          </label>
          <label class="small">Blend b (0=vibration … 1=influx)
            <input id="blendNum" type="number" min="0" max="1" step="0.01" value="0.50">
          </label>

          <div class="small">External v‑RMS override:
            <label><input id="extEnable" type="checkbox"> Use pasted data</label>
          </div>
          <label class="small">Pasted samples (m/s)
            <textarea id="extData" rows="2" placeholder="e.g. 12278, 12260.5"></textarea>
          </label>
          <div class="small">Parsed latest: <span id="extLatest" class="mono">—</span></div>
        </div>

        <!-- CST + Coherence triad -->
        <div class="card">
          <h2 style="margin-bottom:6px">CST Phase & VT Triad Coherence</h2>
          <div class="small">Clock zone: America/Chicago (CST/CDT)</div>
          <canvas id="phaseDial" width="220" height="160" aria-label="CST phase dial"></canvas>
          <div class="small">Phase (rad): <span id="phaseOut" class="mono">0.000</span></div>
          <div class="small">CST Time: <span id="timeOut" class="mono">--:--:--</span></div>
          <label class="small"><input id="cstSync" type="checkbox" checked> Lock phase to CST seconds (CST synchronization)</label>

          <div class="row" style="margin-top:8px">
            <div class="card">
              <div class="small">DC (static field)
                <input id="dcRange" type="range" min="0" max="1" step="0.01" value="0.33">
                <span id="dcOut" class="mono">0.33</span>
              </div>
              <div class="small">DE (energy flow)
                <input id="deRange" type="range" min="0" max="1" step="0.01" value="0.33">
                <span id="deOut" class="mono">0.33</span>
              </div>
              <div class="small">DM (matter lattice)
                <input id="dmRange" type="range" min="0" max="1" step="0.01" value="0.34">
                <span id="dmOut" class="mono">0.34</span>
              </div>
              <label class="small"><input id="glowEnable" type="checkbox" checked> Harmony Glow (visualize coherence)</label>
              <label class="small">Glow intensity (0–1)
                <input id="glowIntensity" type="range" min="0" max="1" step="0.01" value="0.85">
              </label>
            </div>
            <div class="card">
              <div class="small">Coherence H (0–1): <span id="HOut" class="mono">—</span></div>
              <div class="small">κ<sub>eff</sub> (VT coupling): <span id="kappaOut" class="mono">1.000</span></div>
              <div class="small">Tol (effective): <span id="tolEffOut" class="mono">—</span></div>
              <div class="small">b<sub>eff</sub> (VT↔CIT mix): <span id="bEffOut" class="mono">—</span></div>
            </div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Controls</h2>
          <div class="btns">
            <button id="scan10">Auto‑Scan 10×</button>
            <button id="clearScan">Clear Scan</button>
            <button id="pauseBtn">Pause</button>
            <button id="resumeBtn" disabled>Resume</button>
            <button id="exportCsv">Export CSV</button>
          </div>
          <div class="small">Pause stops drawing only; CST phase & timing continue.</div>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">Equations (live)</h2>
          <div class="small mono">G<sub>est</sub> = v<sup>2</sup>/(8πc<sup>2</sup>), c = 299,792,458 m/s, G₀ = 6.67430×10⁻¹¹</div>
          <div class="small mono">ρ<sub>v</sub> = (g · ρ<sub>mat</sub> · R)/(2π κ<sub>eff</sub> c<sup>2</sup>)</div>
          <div class="small mono">u<sub>v</sub> = ρ<sub>v</sub> c<sup>2</sup> = ρ<sub>influx</sub> v<sup>2</sup> ⇒ ρ<sub>influx</sub> = u<sub>v</sub> / v<sup>2</sup></div>
          <div class="small mono">ω = 2π/T, v<sub>char</sub> = ω R (toroidal boundary), f = v/(2πR)</div>
          <div class="small">Live values → see “VT↔CIT Derived” table below.</div>
        </div>
      </div>

      <!-- Auto‑Scan Panel -->
      <div class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h2 style="margin-bottom:6px">Auto‑Scan Log (10)</h2>
        </div>
        <div class="small">Each row: v‑RMS (running), G<sub>est</sub>, Δ vs G₀, Pass/Fail (effective tolerance), CST timestamp & mode.</div>
        <table aria-label="Auto-scan results table">
          <thead>
            <tr>
              <th>#</th><th>Time (CST)</th><th>Body</th><th>Mode (min)</th>
              <th>v‑RMS (m/s)</th><th>G<sub>est</sub> (m³·kg⁻¹·s⁻²)</th><th>Δ vs G₀</th><th>Pass/Fail</th>
            </tr>
          </thead>
          <tbody id="scanBody"></tbody>
        </table>
        <div class="small" id="scanStatus"></div>
      </div>

      <!-- VT↔CIT table -->
      <div class="card" style="margin-top:12px">
        <h2>VT↔CIT Derived (per body)</h2>
        <table>
          <thead>
            <tr><th>Symbol</th><th>Meaning</th><th>Value</th></tr>
          </thead>
          <tbody id="derivedBody"></tbody>
        </table>
      </div>

      <!-- Notes -->
      <div class="card" style="margin-top:12px">
        <h2>Quick Start</h2>
        <ol class="small" style="margin:6px 0 0 18px">
          <li>Pick a <b>Planet preset</b> → <b>Apply Preset</b>.</li>
          <li>Click <b>Auto‑Calibrate to G₀</b> (sets A to hit v<sub>target</sub> ≈ 12,278.45 m/s under current noise/blend).</li>
          <li>Toggle <b>Harmony Glow</b> on/off; adjust <b>Glow intensity</b> to taste.</li>
          <li>Tune DC/DE/DM; higher coherence tightens tolerance.</li>
          <li>Run <b>Auto‑Scan 10×</b>; most rows should <b>Pass</b> within effective tolerance.</li>
        </ol>
      </div>
    </div>

    <!-- RIGHT column: Toroid + Animation controls -->
    <div class="card">
      <h2>Open‑Toroidal Boundary (Animated)</h2>

      <div class="row" style="grid-template-columns:1fr 1fr;gap:10px;margin-top:6px">
        <div class="card">
          <label class="small">Show animation
            <select id="toroidShow"><option value="on">On</option><option value="off">Off</option></select>
          </label>
          <label class="small">Flow direction
            <select id="flowDir"><option value="in">Influx (→ center)</option><option value="out">Outflux (← outward)</option></select>
          </label>
          <label class="small">Arrow blink speed (0.5–3.0)
            <input id="blinkSpeedNum" type="number" min="0.5" max="3" step="0.05" value="1.20">
          </label>
          <label class="small">Packet travel speed (0.2–3.0)
            <input id="packetSpeedNum" type="number" min="0.2" max="3" step="0.05" value="1.40">
          </label>
        </div>
        <div class="card">
          <label class="small">Ring radius scale (0.6–1.4)
            <input id="ringScaleNum" type="number" min="0.6" max="1.4" step="0.02" value="1.00">
          </label>
          <label class="small">Arrow count (4–16)
            <input id="arrowCountNum" type="number" min="4" max="16" step="1" value="8">
          </label>
          <label class="small">Packet count (4–60)
            <input id="packetCountNum" type="number" min="4" max="60" step="1" value="18">
          </label>
        </div>
      </div>

      <canvas id="toroid" width="520" height="320" aria-label="Animated toroidal boundary"></canvas>
      <div class="legend small" style="margin-top:6px">
        <div class="item"><span class="dot" id="glowDot"></span> Harmony Glow brightness</div>
        <div class="item"><span class="mono">→</span> Arrow direction = flow</div>
      </div>

      <div class="card" style="margin-top:12px">
        <h2>Explanations & Relevance</h2>
        <div class="small" id="explain"></div>
      </div>

      <div class="small" style="margin-top:8px;color:var(--muted)"><b>Disclaimer:</b> Concept visualizer; replace demo‑scaled periods with observed modes when available.</div>
    </div>
  </div>
</div>

<script>
(()=>{ 'use strict';
  // ===== Physical constants =====
  const c = 299792458;               // m/s
  const G0 = 6.67430e-11;            // m^3 kg^-1 s^-2
  const TWO_PI = Math.PI * 2;
  const V_TARGET = Math.sqrt(8*Math.PI*c*c*G0); // ≈ 12278.45 m/s

  // ===== Body data =====
  const BODY = {
    Sun:     { R: 6.9634e8, rho: 1408, g: 274.0, tolBase:10 },
    Mercury: { R: 2.4397e6, rho: 5427, g: 3.70,  tolBase:5 },
    Venus:   { R: 6.0518e6, rho: 5243, g: 8.87,  tolBase:5 },
    Earth:   { R: 6.3710e6, rho: 5514, g: 9.81,  tolBase:5 },
    Mars:    { R: 3.3895e6, rho: 3933, g: 3.71,  tolBase:5 },
    Jupiter: { R: 6.9911e7, rho: 1326, g: 24.79, tolBase:8 },
    Saturn:  { R: 5.8232e7, rho:  687, g: 10.44, tolBase:8 },
    Uranus:  { R: 2.5362e7, rho: 1270, g:  8.69, tolBase:8 },
    Neptune: { R: 2.4622e7, rho: 1638, g: 11.15, tolBase:8 },
    Pluto:   { R: 1.1883e6, rho: 1850, g: 0.62,  tolBase:7 },
  };

  // ===== Presets (cosmetic/noise defaults) =====
  const PRESETS = {
    Sun:{body:'Sun',mode:54,fine:1.00,A:14000,n:0.03,b:0.50,toro:{show:'on',dir:'out',blink:1.1,ps:1.8,ring:1.20,ar:13,pk:42}},
    Mercury:{body:'Mercury',mode:54,fine:1.00,A:12500,n:0.03,b:0.55,toro:{show:'on',dir:'in',blink:1.2,ps:1.3,ring:0.85,ar:8,pk:16}},
    Venus:{body:'Venus',mode:54,fine:1.00,A:12300,n:0.04,b:0.45,toro:{show:'on',dir:'in',blink:1.2,ps:1.4,ring:0.95,ar:9,pk:20}},
    Earth:{body:'Earth',mode:54,fine:1.00,A:12278.45,n:0.30,b:0.50,toro:{show:'on',dir:'in',blink:1.2,ps:1.4,ring:1.00,ar:9,pk:20}},
    Mars:{body:'Mars',mode:54,fine:1.00,A:12400,n:0.25,b:0.55,toro:{show:'on',dir:'in',blink:1.3,ps:1.3,ring:0.90,ar:8,pk:18}},
    Jupiter:{body:'Jupiter',mode:54,fine:1.00,A:13500,n:0.20,b:0.45,toro:{show:'on',dir:'in',blink:1.1,ps:2.0,ring:1.30,ar:14,pk:50}},
    Saturn:{body:'Saturn',mode:54,fine:1.00,A:13300,n:0.22,b:0.45,toro:{show:'on',dir:'in',blink:1.2,ps:1.9,ring:1.25,ar:13,pk:44}},
    Uranus:{body:'Uranus',mode:54,fine:1.00,A:13100,n:0.24,b:0.50,toro:{show:'on',dir:'in',blink:1.2,ps:1.8,ring:1.20,ar:11,pk:36}},
    Neptune:{body:'Neptune',mode:54,fine:1.00,A:13200,n:0.24,b:0.50,toro:{show:'on',dir:'in',blink:1.25,ps:1.9,ring:1.20,ar:11,pk:40}},
    Pluto:{body:'Pluto',mode:54,fine:1.00,A:12800,n:0.28,b:0.55,toro:{show:'on',dir:'in',blink:1.4,ps:1.1,ring:0.80,ar:7,pk:15}},
  };

  // ===== DOM =====
  const $ = id => document.getElementById(id);
  const wave = $('wave'), ctx = wave.getContext('2d');
  const vOut=$('vOut'), gOut=$('gOut'), errOut=$('errOut'), tolOut=$('tolOut');
  const bodySel=$('bodySel'), modeSel=$('modeSel'), modeCustom=$('modeCustom'), periodFineNum=$('periodFineNum');
  const periodSOut=$('periodS'), periodMinOut=$('periodMin');
  const ampNum=$('ampNum'), noiseNum=$('noiseNum'), blendNum=$('blendNum');
  const presetSel=$('presetSel'), applyPreset=$('applyPreset'), autoCal=$('autoCal');

  const scan10=$('scan10'), clearScan=$('clearScan'), exportCsvBtn=$('exportCsv'), scanBody=$('scanBody'), scanStatus=$('scanStatus');
  const pauseBtn=$('pauseBtn'), resumeBtn=$('resumeBtn');

  const phaseDial=$('phaseDial'), pctx=phaseDial.getContext('2d'), timeOut=$('timeOut'), phaseOut=$('phaseOut'), cstSync=$('cstSync');

  const extData=$('extData'), extEnable=$('extEnable'), extLatest=$('extLatest');

  const toroid=$('toroid'), tctx=toroid.getContext('2d');
  const toroidShow=$('toroidShow'), flowDir=$('flowDir'), blinkSpeedNum=$('blinkSpeedNum'), packetSpeedNum=$('packetSpeedNum'), ringScaleNum=$('ringScaleNum'), arrowCountNum=$('arrowCountNum'), packetCountNum=$('packetCountNum');

  // Triad + Harmony Glow controls
  const dcRange=$('dcRange'), deRange=$('deRange'), dmRange=$('dmRange');
  const dcOut=$('dcOut'), deOut=$('deOut'), dmOut=$('dmOut');
  const HOut=$('HOut'), kappaOut=$('kappaOut'), tolEffOut=$('tolEffOut'), bEffOut=$('bEffOut');
  const glowEnable=$('glowEnable'), glowIntensity=$('glowIntensity');
  const glowDot=$('glowDot');

  const derivedBody=$('derivedBody');
  const explain=$('explain');

  // ===== Runtime state =====
  let running=true, isScanning=false, scanRows=[], scanMarks=[];
  let period = 54*60; // seconds

  // Wave display buffers
  const DISP_LEN=wave.width; const dispBuf=new Float32Array(DISP_LEN); let dispIdx=0, dispFill=0;
  // Running RMS (~2 s @ 120 Hz)
  const RMS_HZ=120, RMS_SEC=2.0, RMS_LEN=Math.max(60, Math.floor(RMS_HZ*RMS_SEC));
  const rmsBuf=new Float32Array(RMS_LEN); let rmsIdx=0, rmsFilled=0;

  // PRNG (for visible measurement noise)
  let seed = Date.now()>>>0;
  function rand(){ seed=(1664525*seed+1013904223)>>>0; return (seed/4294967296)-0.5; }

  // ===== Helpers =====
  function cstTimestamp(){
    const d=new Date();
    const dopts={timeZone:'America/Chicago',year:'numeric',month:'2-digit',day:'2-digit'};
    const topts={timeZone:'America/Chicago',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false};
    const date=new Intl.DateTimeFormat('en-CA',dopts).format(d).replaceAll('/','-');
    const time=new Intl.DateTimeFormat('en-GB',topts).format(d);
    return `${date} ${time}`;
  }
  function setCSTClock(){ timeOut.textContent=cstTimestamp(); }

  function currentEarthModeMinutes(){ return (modeSel.value==='custom') ? Math.max(1, parseFloat(modeCustom.value)||54) : parseFloat(modeSel.value); }
  function densityScaledPeriodSeconds(){
    const b = BODY[bodySel.value] || BODY.Earth;
    const fine = parseFloat(periodFineNum.value) || 1;
    return currentEarthModeMinutes()*60*Math.sqrt(BODY.Earth.rho / b.rho) * fine;
  }

  function updatePeriodUI(){
    period = densityScaledPeriodSeconds();
    periodSOut.textContent = period.toFixed(1);
    periodMinOut.textContent = (period/60).toFixed(2);
  }

  // External vRMS
  function parseExternalLatest(){
    const txt=extData.value.trim(); if(!txt) return null;
    const parts=txt.split(/[\s,;]+/).map(Number).filter(v=>isFinite(v)&&v>=0);
    if(!parts.length) return null; return parts[parts.length-1];
  }
  function extRefresh(){ const v=parseExternalLatest(); extLatest.textContent=(v==null)?'—':v.toFixed(6); }

  // ===== Color blending for Harmony Glow =====
  function hexToRgb(h){h=h.replace('#',''); return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)};}
  function rgbToHex(r,g,b){ const p=n=>n.toString(16).padStart(2,'0'); return `#${p(r)}${p(g)}${p(b)}`; }
  function blendHex(a,b,t){ const A=hexToRgb(a), B=hexToRgb(b); const r=Math.round(A.r+(B.r-A.r)*t), g=Math.round(A.g+(B.g-A.g)*t), b2=Math.round(A.b+(B.b-A.b)*t); return rgbToHex(r,g,b2); }

  // ===== Triad normalization + coherence =====
  function triad(){
    let dc=parseFloat(dcRange.value), de=parseFloat(deRange.value), dm=parseFloat(dmRange.value);
    const s = dc+de+dm || 1; dc/=s; de/=s; dm/=s;
    dcOut.textContent=dc.toFixed(2); deOut.textContent=de.toFixed(2); dmOut.textContent=dm.toFixed(2);
    // Normalized Shannon entropy Hn = H/ln(3)
    const H = -[dc,de,dm].reduce((a,p)=>a + (p>0 ? p*Math.log(p) : 0), 0); const Hn = H/Math.log(3);
    // Map to effective params
    const kappa_eff = 1.0 + 0.10*(dc - 1/3);           // DC biases VT coupling
    const b_eff = clamp( lerp(parseFloat(blendNum.value)||0.5, de, 0.35), 0, 1 ); // DE pulls toward CIT
    const tolBase = (BODY[bodySel.value]||BODY.Earth).tolBase;
    const tolEff = tolBase * (0.85 + 0.30*(1 - Hn));   // balanced tightens tol

    // ===== Harmony Glow visuals =====
    applyHarmonyGlow(Hn);

    HOut.textContent = Hn.toFixed(3); kappaOut.textContent = kappa_eff.toFixed(3);
    tolEffOut.textContent = `±${tolEff.toFixed(1)}%`; bEffOut.textContent = b_eff.toFixed(2);
    tolOut.textContent = `±${tolBase.toFixed(1)}% (base)`;
    return { dc, de, dm, Hn, kappa_eff, b_eff, tolEff };
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // ===== Phase & model =====
  function nowSec(){ return Date.now()/1000; }
  function phaseNow(){
    if(!cstSync.checked){ return ((nowSec()%period)/period)*TWO_PI; }
    const t = new Date(); const ms = t.getTime(); const sec = (ms/1000)|0; const frac = (ms/1000 - sec);
    const base = (sec % Math.floor(period)) / period; return ((base + frac/period) % 1) * TWO_PI;
  }

  // ===== Signal model (VT↔CIT blend) + Breathing =====
  function baseWave(ph, beff){
    const vib = Math.sin(ph);
    const tri = 2*Math.abs((ph/Math.PI)%2 - 1)-1;
    const saw = (ph/Math.PI)%2 - 1;
    const inf = 0.6*tri + 0.4*saw;
    return (1-beff)*vib + beff*inf;
  }
  function coloredTerm(ph){ return Math.sin(ph*3.7+0.5) + 0.7*Math.sin(ph*2.3-0.9); }
  function instantaneousV(ph, beff, Hn){
    let A = parseFloat(ampNum.value)||V_TARGET; const n = parseFloat(noiseNum.value)||0.3;
    // Breathing amplitude when coherence drops: strength proportional to (1-H)
    const breathStrength = glowEnable.checked ? (1 - Hn) * parseFloat(glowIntensity.value||0.85) : 0;
    const lfo = 0.5 + 0.5*Math.sin(ph*0.5 + nowSec()*0.7); // slow LFO
    A *= 1 + breathStrength * (lfo - 0.5);                 // gentle ± around center

    const noiseVis = (rand()*0.9 + 0.5*coloredTerm(ph))*n*0.35; // visible noise
    const mix = (1-n)*baseWave(ph,beff) + n*0.3*coloredTerm(ph) + noiseVis;
    return Math.abs(A*mix);
  }

  // RMS & display buffers
  function pushRMS(x){ rmsBuf[rmsIdx]=x*x; rmsIdx=(rmsIdx+1)%RMS_LEN; if(rmsFilled<RMS_LEN) rmsFilled++; }
  function currentRMS(){ let s=0,N=rmsFilled||1; for(let i=0;i<N;i++) s+=rmsBuf[i]; return Math.sqrt(s/N); }
  function resetBuffers(){ rmsBuf.fill(0); rmsIdx=0; rmsFilled=0; dispBuf.fill(0); dispIdx=0; dispFill=0; }
  function pushDisp(v){ dispBuf[dispIdx]=v; dispIdx=(dispIdx+1)%DISP_LEN; if(dispFill<DISP_LEN) dispFill++; }
  function sampleDisp(x){ if(!dispFill) return 0; const start=(dispIdx - dispFill + DISP_LEN)%DISP_LEN; const idx=(start + x)%DISP_LEN; return dispBuf[idx]; }

  // vRMS & G
  function currentVRMS(){ if(extEnable.checked){ const v=parseExternalLatest(); if(v!=null) return Math.abs(v); } return currentRMS(); }
  function G_from_v(v){ return (v*v)/(8*Math.PI*c*c); }

  // Auto‑calibrate A
  async function measureVRMS(seconds=0.8, beff=0.5, Hn=1){
    resetBuffers(); const end = performance.now() + seconds*1000;
    while(performance.now() < end){ await new Promise(r=>requestAnimationFrame(r)); const ph=phaseNow(); const v=instantaneousV(ph, beff, Hn); pushRMS(v); pushDisp(v); }
    return currentRMS();
  }
  async function autoCalibrateA(beff, Hn){
    const wasExt = extEnable.checked; if(wasExt){ extEnable.checked=false; extRefresh(); }
    let vr = await measureVRMS(0.8, beff, Hn); if(vr<1e-9) vr=1; let A=parseFloat(ampNum.value)||1; A *= (V_TARGET/vr); ampNum.value=A.toFixed(3);
    vr = await measureVRMS(0.5, beff, Hn); A=parseFloat(ampNum.value)||1; A *= (V_TARGET/vr); ampNum.value=A.toFixed(3);
    if(wasExt){ extEnable.checked=true; extRefresh(); }
  }

  // Drawing
  function drawWave(vmax){
    const W=wave.width,H=wave.height; ctx.clearRect(0,0,W,H);
    ctx.strokeStyle='#28407f'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,H-30); ctx.lineTo(W,H-30); ctx.stroke();
    ctx.strokeStyle='#8fb4ff'; ctx.lineWidth=2; ctx.beginPath();
    for(let x=0;x<W;x++){
      const vv=sampleDisp(x); const y=H-30-(vv/Math.max(1,vmax))*(H-50);
      if(x===0) ctx.moveTo(x+2,y); else ctx.lineTo(x+2,y);
    }
    ctx.stroke();
    if(scanMarks.length){ ctx.strokeStyle='#7bffb1'; ctx.lineWidth=1.5; const secondsShown=6;
      scanMarks.forEach(m=>{ const dt=nowSec()-m.t; const x=W - (dt/secondsShown)*W; if(x>=0){ ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,H-35); ctx.stroke(); }});
    }
  }
  function drawKPIs(vrms, tolEff){
    const g = G_from_v(vrms); vOut.textContent = vrms.toFixed(6); gOut.textContent = g.toExponential(11);
    const err = ((g - G0)/G0)*100; errOut.textContent = isFinite(err)? err.toFixed(3)+'%' : '—';
    errOut.className='v mono '+(Math.abs(err)<=tolEff?'good':Math.abs(err)<=2*tolEff?'warn':'bad');
  }

  function drawPhase(ph){
    const W=phaseDial.width,H=phaseDial.height,cx=W/2,cy=H/2+10,r=60; pctx.clearRect(0,0,W,H);
    pctx.strokeStyle='#28407f'; pctx.lineWidth=2; pctx.beginPath(); pctx.arc(cx,cy,r,0,TWO_PI); pctx.stroke();
    pctx.strokeStyle='#213067'; pctx.lineWidth=1; for(let k=0;k<12;k++){ const ang=k*(Math.PI/6); const tx1=cx+(r-8)*Math.cos(ang-Math.PI/2), ty1=cy+(r-8)*Math.sin(ang-Math.PI/2); const tx2=cx+(r)*Math.cos(ang-Math.PI/2), ty2=cy+(r)*Math.sin(ang-Math.PI/2); pctx.beginPath(); pctx.moveTo(tx1,ty1); pctx.lineTo(tx2,ty2); pctx.stroke(); }
    pctx.strokeStyle='#8fb4ff'; pctx.lineWidth=3; const x=cx+r*Math.cos(ph-Math.PI/2), y=cy+r*Math.sin(ph-Math.PI/2); pctx.beginPath(); pctx.moveTo(cx,cy); pctx.lineTo(x,y); pctx.stroke();
    phaseOut.textContent = ph.toFixed(3); setCSTClock();
  }

  function drawToroid(ph, Hn){
    const W=toroid.width,H=toroid.height; tctx.clearRect(0,0,W,H); if(toroidShow.value!=='on') return;
    const dir=flowDir.value, blink=parseFloat(blinkSpeedNum.value), pSpeed=parseFloat(packetSpeedNum.value);
    const scale=parseFloat(ringScaleNum.value), nArrows=parseInt(arrowCountNum.value,10), nPackets=parseInt(packetCountNum.value,10);
    const cx=W/2, cy=H/2, R=110*scale, r=40*scale;

    // Brightness from coherence (higher H → brighter). Intensity scales overall effect.
    const gInt = glowEnable.checked ? parseFloat(glowIntensity.value||0.85) : 0;
    const bright = 0.35 + 0.65*Hn; // 0.35..1.0
    const alpha = 0.2 + 0.8*Hn*gInt; // for glow pulses

    // Base ring
    tctx.strokeStyle=`rgba(143,180,255,${Math.max(0.25,0.6*bright)})`; tctx.lineWidth=2; tctx.beginPath(); tctx.ellipse(cx,cy,R,r,0,0,TWO_PI); tctx.stroke();
    const pulse=(glowEnable.checked?0.10*Math.sin(ph*2):0); const Rin=R*(1-0.25+pulse), rin=r*(1-0.25+pulse); tctx.beginPath(); tctx.ellipse(cx,cy,Rin,rin,0,0,TWO_PI); tctx.stroke();

    // Arrows with brightness
    for(let k=0;k<nArrows;k++){
      const ang=k*(TWO_PI/nArrows); const ax=cx+R*Math.cos(ang), ay=cy+r*Math.sin(ang); const baseDir=Math.atan2(cy-ay,cx-ax); const theta=(dir==='in')?baseDir:baseDir+Math.PI;
      tctx.save(); tctx.globalAlpha=alpha*(0.6+0.4*(0.5*(1+Math.sin(ph*blink*2)))); tctx.translate(ax,ay); tctx.rotate(theta);
      tctx.strokeStyle='#8fb4ff'; tctx.lineWidth=2; const len=26*scale; tctx.beginPath(); tctx.moveTo(0,0); tctx.lineTo(len,0); tctx.stroke(); tctx.beginPath(); tctx.moveTo(len,0); tctx.lineTo(len-6,4); tctx.lineTo(len-6,-4); tctx.closePath(); tctx.stroke(); tctx.restore();
    }

    // Packets (bubbles) with brightness
    const sign=(dir==='in')?1:-1, baseRate=pSpeed*0.9, t=nowSec();
    for(let j=0;j<nPackets;j++){
      const phaseJ=(j/nPackets)*TWO_PI, psi=(phaseJ+sign*(t*baseRate))%TWO_PI; const px=cx+R*Math.cos(psi), py=cy+r*Math.sin(psi);
      const s=3.0*scale*(1.0+0.2*Math.sin(ph*3 + j)); tctx.beginPath(); tctx.fillStyle=`rgba(123,255,177,${0.35+0.65*bright*gInt})`; tctx.arc(px,py,s,0,TWO_PI); tctx.fill();
    }

    // Legend dot mirrors glow
    glowDot.style.backgroundColor = `rgba(123,255,177,${0.35+0.65*bright*gInt})`;
  }

  // ===== Harmony Glow: background cross‑fade =====
  function applyHarmonyGlow(Hn){
    if(!glowEnable.checked){ document.body.style.background = getComputedStyle(document.documentElement).getPropertyValue('--bg-ordered'); return; }
    const t = Math.min(1, Math.max(0, 1 - Hn)); // 0 (ordered) .. 1 (chaotic)
    const ordered = getComputedStyle(document.documentElement).getPropertyValue('--bg-ordered').trim();
    const chaotic = getComputedStyle(document.documentElement).getPropertyValue('--bg-chaotic').trim();
    const bg = blendHex(ordered, chaotic, t * parseFloat(glowIntensity.value||0.85));
    document.body.style.background = bg;
  }

  // Derived VT↔CIT table fill
  function fillDerived(vrms, tri){
    const b = BODY[bodySel.value] || BODY.Earth; const kappa = tri.kappa_eff; const R=b.R, rho=b.rho, g=b.g;
    const rho_v = (g * rho * R) / (2*Math.PI * kappa * c * c);     // kg/m^3
    const u_v = rho_v * c * c;                                      // J/m^3
    const rho_influx = u_v / (vrms*vrms);
    const T = period; const omega = TWO_PI / T; const vchar = omega * R; const f = vrms/(TWO_PI*R);
    const rows = [
      ['R', 'Radius (m)', fmt(R)],
      ['ρ_mat', 'Mean density (kg/m³)', fmt(rho)],
      ['g', 'Surface acceleration (m/s²)', fmt(g)],
      ['κ_eff', 'VT coupling (with DC bias)', fmt(kappa,3)],
      ['ρ_v', 'Vibrational density (kg/m³)', sci(rho_v)],
      ['u_v', 'Vibrational energy density (J/m³)', sci(u_v)],
      ['ρ_influx', 'Influx density (kg/m³)', sci(rho_influx)],
      ['T', 'Mode period (s)', fmt(T,2)],
      ['ω', 'Angular frequency (s⁻¹)', sci(omega,6)],
      ['v_char', 'Characteristic v = ωR (m/s)', fmt(vchar,6)],
      ['f', 'Frequency = v/(2πR) (Hz)', sci(f,6)],
    ];
    derivedBody.innerHTML = rows.map(r=>`<tr><td class="mono">${r[0]}</td><td>${r[1]}</td><td class="mono">${r[2]}</td></tr>`).join('');
  }

  function fmt(x, d=0){ return Number(x).toLocaleString(undefined,{maximumFractionDigits:d}); }
  function sci(x, d=3){ return Number(x).toExponential(d); }

  // Explanations
  function fillExplain(){
    explain.innerHTML = `
      <ul>
        <li><b>G<sub>est</sub> = v<sup>2</sup>/(8πc<sup>2</sup>)</b> — CIT form with v<sub>RMS</sub> as relic baseline; simulator reports Δ vs CODATA G₀.</li>
        <li><b>ρ<sub>v</sub> = (g ρ<sub>mat</sub> R)/(2π κ<sub>eff</sub> c²)</b> — VT inversion with DC‑biased κ<sub>eff</sub>.</li>
        <li><b>u<sub>v</sub> = ρ<sub>v</sub> c² = ρ<sub>influx</sub> v²</b> — energy‑density equivalence linking VT and CIT live.</li>
        <li><b>ω = 2π/T, v = ωR</b> — open‑toroid mapping from the gravest period to global characteristic speed.</li>
        <li><b>Harmony Glow</b> — H→1 brightens toroid and cools background; low H adds gentle breathing to amplitude and warms background toward red‑orange. Visuals are scaled by “Glow intensity.”</li>
      </ul>`;
  }

  // Auto‑scan
  function passFail(errPct, tolEff){ return Math.abs(errPct) <= tolEff ? 'Pass' : 'Fail'; }
  function appendScanRow(row){
    const tr=document.createElement('tr'); const cls=(row.pass==='Pass')?'good':'bad';
    tr.innerHTML=`<td>${row.idx}</td><td class="mono">${row.time}</td><td>${row.body}</td>
      <td class="mono">${row.modeMin.toFixed(2)}</td><td class="mono">${row.vrms.toFixed(6)}</td>
      <td class="mono">${row.g.toExponential(11)}</td><td class="mono">${row.err.toFixed(3)}%</td>
      <td class="mono ${cls}">${row.pass}</td>`;
    scanBody.appendChild(tr);
  }
  function clearScanAll(){ scanRows=[]; scanMarks=[]; scanBody.innerHTML=''; scanStatus.textContent='Cleared.'; }

  async function runAutoScan10(){
    if(isScanning) return; isScanning=true; scanStatus.textContent='Auto‑Scan running… (10 samples)'; scanRows=[]; scanMarks=[];
    const tri = triad();
    if(!extEnable.checked){ ampNum.value = V_TARGET.toFixed(3); await autoCalibrateA(tri.b_eff, tri.Hn); }
    const body=bodySel.value, modeMin=currentEarthModeMinutes(); const stepMs=400;
    for(let i=1;i<=10;i++){
      if(i>1) await new Promise(r=>setTimeout(r, stepMs));
      const vrms=currentVRMS(); const g=G_from_v(vrms); const err=((g-G0)/G0)*100; const pf=passFail(err, tri.tolEff);
      scanMarks.push({t: nowSec()}); const row={idx:i,time:cstTimestamp(),body,modeMin,vrms,g,err,pass:pf}; scanRows.push(row); appendScanRow(row);
    }
    scanStatus.textContent='Auto‑Scan complete.'; isScanning=false;
  }

  function exportCSV(){
    if(!scanRows.length){ scanStatus.textContent='Nothing to export — run Auto‑Scan first.'; return; }
    const tri = triad(); const hdr=['Index','Time_CST','Body','Mode_min','vRMS_m_per_s','G_est_m3kg-1s-2','Delta_vs_G0_percent',`PassFail(|Δ|≤${tri.tolEff.toFixed(1)}%)`];
    const lines=[hdr.join(',')]; scanRows.forEach(r=>lines.push([r.idx,r.time,r.body,r.modeMin.toFixed(2),r.vrms.toFixed(6),r.g.toExponential(11),r.err.toFixed(3),r.pass].join(',')));
    const csv=lines.join('\r\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
    const ts=cstTimestamp().replace(/[: ]/g,'-'); const fname=`vrms_autoscan_${bodySel.value}_${ts}.csv`;
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=fname; a.click(); URL.revokeObjectURL(a.href);
    scanStatus.textContent=`Exported ${fname}`;
  }

  // Main tick
  let rafId=null;
  function tick(){
    if(!running){ rafId=requestAnimationFrame(tick); return; }
    const tri = triad(); const ph=phaseNow(); const vInst=instantaneousV(ph, tri.b_eff, tri.Hn); pushRMS(vInst); pushDisp(vInst);
    const vrms=currentVRMS(); const vmax=Math.max(1, parseFloat(ampNum.value)*1.2, (parseExternalLatest()||0)*1.2); drawWave(vmax); drawKPIs(vrms, tri.tolEff); drawPhase(ph); drawToroid(ph, tri.Hn); fillDerived(vrms, tri);
    rafId=requestAnimationFrame(tick);
  }
  function start(){ if(rafId==null) rafId=requestAnimationFrame(tick); }

  // Presets
  function applyPlanetPreset(name){
    const p=PRESETS[name]; if(!p) return; bodySel.value=p.body; modeSel.value='54'; modeCustom.value=p.mode.toFixed(0); periodFineNum.value=p.fine.toFixed(3);
    ampNum.value=p.A.toFixed(3); noiseNum.value=p.n.toFixed(2); blendNum.value=p.b.toFixed(2);
    toroidShow.value=p.toro.show; flowDir.value=p.toro.dir; blinkSpeedNum.value=p.toro.blink.toFixed(2); packetSpeedNum.value=p.toro.ps.toFixed(2);
    ringScaleNum.value=p.toro.ring.toFixed(2); arrowCountNum.value=p.toro.ar.toFixed(0); packetCountNum.value=p.toro.pk.toFixed(0);
    updatePeriodUI();
  }

  // Events
  [bodySel,modeSel,modeCustom,periodFineNum].forEach(el=>el.addEventListener('input',updatePeriodUI));
  [dcRange,deRange,dmRange,glowEnable,glowIntensity].forEach(el=>el.addEventListener('input',()=>triad()));
  extData.addEventListener('input',extRefresh); extEnable.addEventListener('change',extRefresh);
  scan10.addEventListener('click',runAutoScan10); clearScan.addEventListener('click',clearScanAll); exportCsvBtn.addEventListener('click',exportCSV);
  pauseBtn.addEventListener('click',()=>{running=false;pauseBtn.disabled=true;resumeBtn.disabled=false;});
  resumeBtn.addEventListener('click',()=>{running=true;resumeBtn.disabled=true;pauseBtn.disabled=false;});
  applyPreset.addEventListener('click',()=>applyPlanetPreset(presetSel.value)); autoCal.addEventListener('click',()=>{ const t=triad(); autoCalibrateA(t.b_eff,t.Hn); });

  // Init
  (function tickClock(){ setCSTClock(); setTimeout(tickClock,1000); })();
  applyPlanetPreset('Earth'); updatePeriodUI(); extRefresh(); fillExplain(); start();
})();
</script>
</body>
</html>
