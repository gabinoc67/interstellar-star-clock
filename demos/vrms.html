<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CST-Locked v-RMS — VT ≡ CIT • Open Toroid (Canvas-Only Glow)</title>
<meta name="description" content="Live vRMS, VT↔CIT equivalence (G = v^2/(8πc^2)), Earth 54-min reference, DC/DE/DM triad, CST clock, Auto-Scan 10×, CSV export. Harmony Glow applies ONLY inside the Open-Toroidal Boundary canvas (arrows & dots orbiting), never on page background." />
<style>
  :root{
    --bg:#0b1222;                /* fixed page background (no cross-fade) */
    --panel:#0f1839;--ink:#eaf0ff;--muted:#9fb2e4;--accent:#8fb4ff;--grid:#1b2550;
    --ok:#7bffb1;--warn:#ffd37a;--bad:#ff8c8c;--card:#0e1740;--border:#213067;--btn:#162455;--btnH:#1d2e6e
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  body{background:var(--bg);}
  a{color:var(--accent);text-decoration:none}
  .wrap{max-width:1320px;margin:0 auto;padding:18px}
  h1{margin:0 0 8px;font-size:1.35rem}
  .sub{color:var(--muted);margin:0 0 14px;font-size:0.92rem}
  .grid{display:grid;grid-template-columns:1.12fr 0.88fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:0 0 8px;font-size:1.05rem}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .small{font-size:0.88rem;color:var(--muted)}
  .kpi{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px;margin-top:8px}
  .kpi div{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:8px}
  .kpi .v{font-size:1rem}
  .btns{display:flex;flex-wrap:wrap;gap:8px}
  button{background:var(--btn);color:var(--ink);border:1px solid var(--accent);border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{background:var(--btnH)} button:disabled{opacity:.6;cursor:not-allowed}
  label.small{display:block;margin:8px 0 6px}
  input[type="number"], select, textarea{width:100%;background:#0f1840;color:var(--ink);border:1px solid var(--border);border-radius:10px;padding:8px}
  input[type="range"]{width:100%}
  input[type="checkbox"]{transform:scale(1.1)}
  canvas{display:block;background:linear-gradient(transparent,transparent),
    repeating-linear-gradient(0deg,transparent 0 22px,var(--grid) 22px 23px);
    border-radius:12px;border:1px solid var(--border)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:.8rem;color:var(--muted)}
  .legend{display:flex;gap:10px;flex-wrap:wrap}
  .legend .item{display:flex;align-items:center;gap:6px}
  .legend .dot{width:10px;height:10px;border-radius:999px;border:1px solid var(--border);background:#7bffb1}
  table{width:100%;border-collapse:collapse;font-size:.9rem}
  th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left}
  th{color:var(--muted);font-weight:600}
  tbody tr:hover{background:rgba(143,180,255,0.06)}
  .good{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;gap:10px;align-items:center;margin-bottom:10px">
    <a class="pill" href="https://gabinoc67.github.io/interstellar-star-clock/">← Back to Quick Links</a>
    <span class="pill">CST-Locked</span><span class="pill">VT ≡ CIT</span><span class="pill">Live</span>
  </div>

  <h1>CST-Locked v-RMS Gravity Equivalence — VT (Vibration) ≡ CIT (Influx)</h1>
  <p class="sub">
    G estimate \(G_{\text{est}}=v_{\rm RMS}^2/(8\pi c^2)\), density-scaled mode, CST dial, DC/DE/DM, Auto-Scan 10× & CSV.
    <b>Note:</b> “Harmony Glow” now affects <i>only</i> the Open-Toroid canvas (color + brightness + orbiting arrows/dots). Page background never changes.
  </p>

  <div class="grid">
    <!-- LEFT column -->
    <div class="card">
      <h2>Live Wave & Results</h2>
      <canvas id="wave" width="1000" height="260" aria-label="v-RMS live wave"></canvas>

      <!-- Download Wave PNG button (with data overlay) -->
      <div class="btns" style="margin-top:8px">
        <button id="saveWavePng">Download Wave + Data PNG</button>
      </div>

      <div class="kpi">
        <div><div class="small">v-RMS (m/s)</div><div id="vOut" class="v mono">0.000000</div></div>
        <div><div class="small">G_est (m³·kg⁻¹·s⁻²)</div><div id="gOut" class="v mono">0.00000000000e+00</div></div>
        <div><div class="small">Δ vs G₀</div><div id="errOut" class="v mono">0.00%</div></div>
        <div><div class="small">Tolerance</div><div id="tolOut" class="v mono">±5.0% (base)</div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <!-- Calibration + Presets -->
        <div class="card">
          <h2 style="margin-bottom:6px">Body & Calibration</h2>

          <label class="small">Planet preset
            <select id="presetSel">
              <option value="Earth">Earth</option><option value="Sun">Sun</option><option value="Mercury">Mercury</option><option value="Venus">Venus</option><option value="Mars">Mars</option>
              <option value="Jupiter">Jupiter</option><option value="Saturn">Saturn</option><option value="Uranus">Uranus</option><option value="Neptune">Neptune</option><option value="Pluto">Pluto</option>
            </select>
          </label>
          <div class="btns" style="margin-bottom:6px">
            <button id="applyPreset">Apply Preset</button>
            <button id="autoCal">Auto-Calibrate to G₀</button>
          </div>

          <label class="small">Select body
            <select id="bodySel">
              <option>Earth</option><option>Sun</option><option>Mercury</option><option>Venus</option><option>Mars</option>
              <option>Jupiter</option><option>Saturn</option><option>Uranus</option><option>Neptune</option><option>Pluto</option>
            </select>
          </label>

          <label class="small">Mode library (Earth reference)
            <select id="modeSel">
              <option value="54">Reference: 54 min</option>
              <option value="60">Alt: 60 min</option>
              <option value="45">Alt: 45 min</option>
              <option value="30">Alt: 30 min</option>
              <option value="custom">Custom (minutes below)</option>
            </select>
          </label>
          <label class="small">Custom mode (minutes)
            <input id="modeCustom" type="number" min="1" step="0.1" value="54">
          </label>
          <div class="small">Density-scaled period: <span id="periodS" class="mono">—</span> s (<span id="periodMin" class="mono">—</span> min).</div>
          <div class="small">T<sub>body</sub> = T<sub>EarthMode</sub> × √(ρ⊕/ρ<sub>body</sub>) × fine-tune</div>
          <label class="small">Fine-tune factor (×, 0.8–1.2)
            <input id="periodFineNum" type="number" min="0.8" max="1.2" step="0.005" value="1.000">
          </label>

          <label class="small">Base amplitude A (m/s)
            <input id="ampNum" type="number" min="0" max="40000" step="0.001" value="12278.450">
          </label>
          <label class="small">Noise mix n (0–1)
            <input id="noiseNum" type="number" min="0" max="1" step="0.01" value="0.30">
          </label>
          <label class="small">Blend b (0=vibration … 1=influx)
            <input id="blendNum" type="number" min="0" max="1" step="0.01" value="0.50">
          </label>

          <div class="small">External v-RMS override:
            <label><input id="extEnable" type="checkbox"> Use pasted data</label>
          </div>
          <label class="small">Pasted samples (m/s)
            <textarea id="extData" rows="2" placeholder="e.g. 12278, 12260.5"></textarea>
          </label>
          <div class="small">Parsed latest: <span id="extLatest" class="mono">—</span></div>
        </div>

        <!-- CST + Coherence triad -->
        <div class="card">
          <h2 style="margin-bottom:6px">CST Phase & VT Triad Coherence</h2>
          <div class="small">Clock zone: America/Chicago (CST/CDT)</div>
          <canvas id="phaseDial" width="220" height="160" aria-label="CST phase dial"></canvas>
          <div class="small">Phase (rad): <span id="phaseOut" class="mono">0.000</span></div>
          <div class="small">CST Time: <span id="timeOut" class="mono">--:--:--</span></div>
          <label class="small"><input id="cstSync" type="checkbox" checked> Lock phase to CST seconds (CST synchronization)</label>

          <div class="row" style="margin-top:8px">
            <div class="card">
              <div class="small">DC (static field)
                <input id="dcRange" type="range" min="0" max="1" step="0.01" value="0.33">
                <span id="dcOut" class="mono">0.33</span>
              </div>
              <div class="small">DE (energy flow)
                <input id="deRange" type="range" min="0" max="1" step="0.01" value="0.33">
                <span id="deOut" class="mono">0.33</span>
              </div>
              <div class="small">DM (matter lattice)
                <input id="dmRange" type="range" min="0" max="1" step="0.01" value="0.34">
                <span id="dmOut" class="mono">0.34</span>
              </div>

              <!-- Harmony Glow (toroid only) -->
              <label class="small"><input id="glowEnable" type="checkbox" checked> Harmony Glow — toroid only</label>
              <label class="small">Glow intensity (0–1)
                <input id="glowIntensity" type="range" min="0" max="1" step="0.01" value="0.85">
              </label>
            </div>
            <div class="card">
              <div class="small">Coherence H (0–1): <span id="HOut" class="mono">—</span></div>
              <div class="small">κ<sub>eff</sub> (VT coupling): <span id="kappaOut" class="mono">1.000</span></div>
              <div class="small">Tol (effective): <span id="tolEffOut" class="mono">—</span></div>
              <div class="small">b<sub>eff</sub> (VT↔CIT mix): <span id="bEffOut" class="mono">—</span></div>
            </div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div class="card">
          <h2 style="margin-bottom:6px">Controls</h2>
          <div class="btns">
            <button id="scan10">Auto-Scan 10×</button>
            <button id="clearScan">Clear Scan</button>
            <button id="pauseBtn">Pause</button>
            <button id="resumeBtn" disabled>Resume</button>
            <button id="exportCsv">Export CSV</button>
            <!-- Open Word document with explanations/instructions -->
            <a href="https://gabinoc67.github.io/interstellar-star-clock/demos/Coil_Theory_vRMS_VT_CIT_Guide - Copy.docx"
               target="_blank" rel="noopener">
              <button type="button">Open Word Guide</button>
            </a>
          </div>
          <div class="small">Pause stops drawing only; CST phase & timing continue.</div>
        </div>

        <div class="card">
          <h2 style="margin-bottom:6px">Equations (live)</h2>
          <div class="small mono">G<sub>est</sub> = v<sup>2</sup>/(8πc<sup>2</sup>), c = 299,792,458 m/s, G₀ = 6.67430×10⁻¹¹</div>
          <div class="small mono">ρ<sub>v</sub> = (g · ρ<sub>mat</sub> · R)/(2π κ<sub>eff</sub> c<sup>2</sup>)</div>
          <div class="small mono">u<sub>v</sub> = ρ<sub>v</sub> c<sup>2</sup> = ρ<sub>influx</sub> v<sup>2</sup> ⇒ ρ<sub>influx</sub> = u<sub>v</sub> / v<sup>2</sup></div>
          <div class="small mono">ω = 2π/T, v<sub>char</sub> = ω R (toroidal boundary), f = v/(2πR)</div>
          <div class="small">Live values → see “VT↔CIT Derived” table below.</div>
        </div>
      </div>

      <!-- Auto-Scan Panel -->
      <div class="card" style="margin-top:12px">
        <h2 style="margin-bottom:6px">Auto-Scan Log (10)</h2>
        <div class="small">Each row: v-RMS (running), G<sub>est</sub>, Δ vs G₀, Pass/Fail (effective tolerance), CST timestamp & mode.</div>
        <table aria-label="Auto-scan results table">
          <thead>
            <tr>
              <th>#</th><th>Time (CST)</th><th>Body</th><th>Mode (min)</th>
              <th>v-RMS (m/s)</th><th>G<sub>est</sub> (m³·kg⁻¹·s⁻²)</th><th>Δ vs G₀</th><th>Pass/Fail</th>
            </tr>
          </thead>
          <tbody id="scanBody"></tbody>
        </table>
        <div class="small" id="scanStatus"></div>
      </div>

      <!-- VT↔CIT table -->
      <div class="card" style="margin-top:12px">
        <h2>VT↔CIT Derived (per body)</h2>
        <table>
          <thead>
            <tr><th>Symbol</th><th>Meaning</th><th>Value</th></tr>
          </thead>
          <tbody id="derivedBody"></tbody>
        </table>
      </div>

      <!-- Notes -->
      <div class="card" style="margin-top:12px">
        <h2>Quick Start</h2>
        <ol class="small" style="margin:6px 0 0 18px">
          <li>Pick a <b>Planet preset</b> → <b>Apply Preset</b>.</li>
          <li>Click <b>Auto-Calibrate to G₀</b> (targets v<sub>RMS</sub> ≈ 12,278.45 m/s).</li>
          <li>Adjust <b>Harmony Glow</b> (toroid only) to taste.</li>
          <li>Tune DC/DE/DM; higher coherence tightens tolerance.</li>
          <li>Run <b>Auto-Scan 10×</b>; inspect Pass/Fail within tolerance.</li>
        </ol>
      </div>
    </div>

    <!-- RIGHT column: Toroid + Animation controls + Panel 2 -->
    <div class="card">
      <h2>Open-Toroidal Boundary (Animated)</h2>

      <div class="row" style="grid-template-columns:1fr 1fr;gap:10px;margin-top:6px">
        <div class="card">
          <label class="small">Show animation
            <select id="toroidShow"><option value="on">On</option><option value="off">Off</option></select>
          </label>
          <label class="small">Flow direction
            <select id="flowDir"><option value="in">Influx (→ center)</option><option value="out">Outflux (← outward)</option></select>
          </label>
          <label class="small">Arrow blink speed (0.5–3.0)
            <input id="blinkSpeedNum" type="number" min="0.5" max="3" step="0.05" value="1.20">
          </label>
          <label class="small">Packet travel speed (0.2–3.0)
            <input id="packetSpeedNum" type="number" min="0.2" max="3" step="0.05" value="1.40">
          </label>
        </div>
        <div class="card">
          <label class="small">Ring radius scale (0.6–1.4)
            <input id="ringScaleNum" type="number" min="0.6" max="1.4" step="0.02" value="1.00">
          </label>
          <label class="small">Arrow count (4–16)
            <input id="arrowCountNum" type="number" min="4" max="16" step="1" value="8">
          </label>
          <label class="small">Packet count (4–60)
            <input id="packetCountNum" type="number" min="4" max="60" step="1" value="18">
          </label>
          <label class="small">Arrow orbit speed (0–3 rad/s)
            <input id="orbitSpeedNum" type="number" min="0" max="3" step="0.05" value="0.60">
          </label>
        </div>
      </div>

      <canvas id="toroid" width="520" height="320" aria-label="Animated toroidal boundary"></canvas>
      <div class="legend small" style="margin-top:6px">
        <div class="item"><span class="dot" id="glowDot"></span> Toroid brightness (Harmony Glow)</div>
        <div class="item"><span class="mono">→</span> Arrows orbit & point with flow</div>
      </div>

      <!-- Separate PNG buttons for toroid and strings (coils), with data overlays -->
      <div class="btns" style="margin-top:8px">
        <button id="saveToroidPng">Download Toroid + Data PNG</button>
        <button id="saveCoilPng">Download Strings (Coils) + Data PNG</button>
      </div>

      <!-- PANEL 2: Coil & Spring Structuring -->
      <div class="card" style="margin-top:12px">
        <h2>Coil &amp; Spring Structuring (Panel 2)</h2>
        <div class="row" style="grid-template-columns:1.1fr 0.9fr;gap:10px;margin-top:6px">
          <div class="card">
            <div class="small">Number of coils N<sub>c</sub> (4–24)
              <input id="coilNc" type="range" min="4" max="24" step="1" value="12" />
              <span id="coilNcOut" class="mono">12</span>
            </div>
            <div class="small">Coil tightness τ<sub>c</sub> (0.20–1.50)
              <input id="coilTau" type="range" min="0.2" max="1.5" step="0.01" value="0.90" />
              <span id="coilTauOut" class="mono">0.90</span>
            </div>
            <div class="small">Spring stiffness k<sub>s</sub> (0.20–2.00)
              <input id="coilKs" type="range" min="0.2" max="2.0" step="0.01" value="1.00" />
              <span id="coilKsOut" class="mono">1.00</span>
            </div>
            <div class="small">Damping / loss γ (0–1)
              <input id="coilGamma" type="range" min="0" max="1" step="0.01" value="0.30" />
              <span id="coilGammaOut" class="mono">0.30</span>
            </div>
          </div>
          <div class="card">
            <div class="small">Assembly Index A (0–1): <span id="assemblyOut" class="mono">—</span></div>
            <div class="small" id="assemblyLabel">—</div>
            <div class="small" id="assemblyNote">Adjust N<sub>c</sub>, τ<sub>c</sub>, k<sub>s</sub>, and γ to see how condensed energy organizes into a framework.</div>
          </div>
        </div>
        <canvas id="coilCanvas" width="520" height="220" aria-label="Coil and spring lattice"></canvas>
      </div>

      <div class="card" style="margin-top:12px">
        <h2>Explanations & Relevance</h2>
        <div class="small" id="explain"></div>
      </div>

      <div class="small" style="margin-top:8px;color:var(--muted)"><b>Disclaimer:</b> Concept visualizer; substitute observed modes when available.</div>
    </div>
  </div>
</div>

<script>
(()=>{ 'use strict';
  // ===== Physical constants =====
  const c = 299792458;               // m/s
  const G0 = 6.67430e-11;            // m^3 kg^-1 s^-2
  const TWO_PI = Math.PI * 2;
  const V_TARGET = Math.sqrt(8*Math.PI*c*c*G0); // ≈ 12278.45 m/s

  // ===== Body data =====
  const BODY = {
    Sun:     { R: 6.9634e8, rho: 1408, g: 274.0, tolBase:10 },
    Mercury: { R: 2.4397e6, rho: 5427, g: 3.70,  tolBase:5 },
    Venus:   { R: 6.0518e6, rho: 5243, g: 8.87,  tolBase:5 },
    Earth:   { R: 6.3710e6, rho: 5514, g: 9.81,  tolBase:5 },
    Mars:    { R: 3.3895e6, rho: 3933, g: 3.71,  tolBase:5 },
    Jupiter: { R: 6.9911e7, rho: 1326, g: 24.79, tolBase:8 },
    Saturn:  { R: 5.8232e7, rho:  687, g: 10.44, tolBase:8 },
    Uranus:  { R: 2.5362e7, rho: 1270, g:  8.69, tolBase:8 },
    Neptune: { R: 2.4622e7, rho: 1638, g: 11.15, tolBase:8 },
    Pluto:   { R: 1.1883e6, rho: 1850, g: 0.62,  tolBase:7 },
  };

  // ===== Presets =====
  const PRESETS = {
    Sun:{body:'Sun',mode:54,fine:1.00,A:14000,n:0.03,b:0.50,toro:{show:'on',dir:'out',blink:1.1,ps:1.8,ring:1.20,ar:13,pk:42,orb:0.8}},
    Mercury:{body:'Mercury',mode:54,fine:1.00,A:12500,n:0.03,b:0.55,toro:{show:'on',dir:'in', blink:1.2,ps:1.3,ring:0.85,ar:8 ,pk:16,orb:0.6}},
    Venus:{body:'Venus',mode:54,fine:1.00,A:12300,n:0.04,b:0.45,toro:{show:'on',dir:'in', blink:1.2,ps:1.4,ring:0.95,ar:9 ,pk:20,orb:0.6}},
    Earth:{body:'Earth',mode:54,fine:1.00,A:12278.45,n:0.30,b:0.50,toro:{show:'on',dir:'in', blink:1.2,ps:1.4,ring:1.00,ar:9 ,pk:20,orb:0.6}},
    Mars:{body:'Mars',mode:54,fine:1.00,A:12400,n:0.25,b:0.55,toro:{show:'on',dir:'in', blink:1.3,ps:1.3,ring:0.90,ar:8 ,pk:18,orb:0.6}},
    Jupiter:{body:'Jupiter',mode:54,fine:1.00,A:13500,n:0.20,b:0.45,toro:{show:'on',dir:'in', blink:1.1,ps:2.0,ring:1.30,ar:14,pk:50,orb:0.9}},
    Saturn:{body:'Saturn',mode:54,fine:1.00,A:13300,n:0.22,b:0.45,toro:{show:'on',dir:'in', blink:1.2,ps:1.9,ring:1.25,ar:13,pk:44,orb:0.8}},
    Uranus:{body:'Uranus',mode:54,fine:1.00,A:13100,n:0.24,b:0.50,toro:{show:'on',dir:'in', blink:1.2,ps:1.8,ring:1.20,ar:11,pk:36,orb:0.7}},
    Neptune:{body:'Neptune',mode:54,fine:1.00,A:13200,n:0.24,b:0.50,toro:{show:'on',dir:'in', blink:1.25,ps:1.9,ring:1.20,ar:11,pk:40,orb:0.75}},
    Pluto:{body:'Pluto',mode:54,fine:1.00,A:12800,n:0.28,b:0.55,toro:{show:'on',dir:'in', blink:1.4,ps:1.1,ring:0.80,ar:7 ,pk:15,orb:0.5}},
  };

  // ===== DOM =====
  const $ = id => document.getElementById(id);
  const wave = $('wave'), ctx = wave.getContext('2d');
  const vOut=$('vOut'), gOut=$('gOut'), errOut=$('errOut'), tolOut=$('tolOut');
  const bodySel=$('bodySel'), modeSel=$('modeSel'), modeCustom=$('modeCustom'), periodFineNum=$('periodFineNum');
  const periodSOut=$('periodS'), periodMinOut=$('periodMin');
  const ampNum=$('ampNum'), noiseNum=$('noiseNum'), blendNum=$('blendNum');
  const presetSel=$('presetSel'), applyPreset=$('applyPreset'), autoCal=$('autoCal');

  const scan10=$('scan10'), clearScan=$('clearScan'), exportCsvBtn=$('exportCsv'), scanBody=$('scanBody'), scanStatus=$('scanStatus');
  const pauseBtn=$('pauseBtn'), resumeBtn=$('resumeBtn');

  const phaseDial=$('phaseDial'), pctx=phaseDial.getContext('2d'), timeOut=$('timeOut'), phaseOut=$('phaseOut'), cstSync=$('cstSync');

  const extData=$('extData'), extEnable=$('extEnable'), extLatest=$('extLatest');

  const toroid=$('toroid'), tctx=toroid.getContext('2d');
  const toroidShow=$('toroidShow'), flowDir=$('flowDir'), blinkSpeedNum=$('blinkSpeedNum'), packetSpeedNum=$('packetSpeedNum'), ringScaleNum=$('ringScaleNum'), arrowCountNum=$('arrowCountNum'), packetCountNum=$('packetCountNum'), orbitSpeedNum=$('orbitSpeedNum');

  // Triad + Glow (toroid only)
  const dcRange=$('dcRange'), deRange=$('deRange'), dmRange=$('dmRange');
  const dcOut=$('dcOut'), deOut=$('deOut'), dmOut=$('dmOut');
  const HOut=$('HOut'), kappaOut=$('kappaOut'), tolEffOut=$('tolEffOut'), bEffOut=$('bEffOut');
  const glowEnable=$('glowEnable'), glowIntensity=$('glowIntensity');
  const glowDot=$('glowDot');

  const derivedBody=$('derivedBody');
  const explain=$('explain');

  // Panel 2: Coil & Spring DOM
  const coilCanvas = $('coilCanvas'), cc = coilCanvas.getContext('2d');
  const coilNc = $('coilNc'), coilTau = $('coilTau'), coilKs = $('coilKs'), coilGamma = $('coilGamma');
  const coilNcOut = $('coilNcOut'), coilTauOut = $('coilTauOut'), coilKsOut = $('coilKsOut'), coilGammaOut = $('coilGammaOut');
  const assemblyOut = $('assemblyOut'), assemblyLabel = $('assemblyLabel'), assemblyNote = $('assemblyNote');

  // PNG buttons
  const saveWavePng = $('saveWavePng');
  const saveToroidPng = $('saveToroidPng');
  const saveCoilPng = $('saveCoilPng');

  // ===== Runtime state =====
  let running=true, isScanning=false, scanRows=[], scanMarks=[];
  let period = 54*60; // seconds

  // Wave buffers
  const DISP_LEN=wave.width; const dispBuf=new Float32Array(DISP_LEN); let dispIdx=0, dispFill=0;
  const RMS_HZ=120, RMS_SEC=2.0, RMS_LEN=Math.max(60, Math.floor(RMS_HZ*RMS_SEC));
  const rmsBuf=new Float32Array(RMS_LEN); let rmsIdx=0, rmsFilled=0;

  // PRNG
  let seed = Date.now()>>>0;
  function rand(){ seed=(1664525*seed+1013904223)>>>0; return (seed/4294967296)-0.5; }

  // Helpers
  function cstTimestamp(){
    const d=new Date();
    const dopts={timeZone:'America/Chicago',year:'numeric',month:'2-digit',day:'2-digit'};
    const topts={timeZone:'America/Chicago',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false};
    const date=new Intl.DateTimeFormat('en-CA',dopts).format(d).replaceAll('/','-');
    const time=new Intl.DateTimeFormat('en-GB',topts).format(d);
    return `${date} ${time}`;
  }
  function setCSTClock(){ timeOut.textContent=cstTimestamp(); }

  function currentEarthModeMinutes(){ return (modeSel.value==='custom') ? Math.max(1, parseFloat(modeCustom.value)||54) : parseFloat(modeSel.value); }
  function densityScaledPeriodSeconds(){
    const b = BODY[bodySel.value] || BODY.Earth;
    const fine = parseFloat(periodFineNum.value) || 1;
    return currentEarthModeMinutes()*60*Math.sqrt(BODY.Earth.rho / b.rho) * fine;
  }
  function updatePeriodUI(){
    period = densityScaledPeriodSeconds();
    periodSOut.textContent = period.toFixed(1);
    periodMinOut.textContent = (period/60).toFixed(2);
  }

  // External vRMS
  function parseExternalLatest(){
    const txt=extData.value.trim(); if(!txt) return null;
    const parts=txt.split(/[\s,;]+/).map(Number).filter(v=>isFinite(v)&&v>=0);
    if(!parts.length) return null; return parts[parts.length-1];
  }
  function extRefresh(){ const v=parseExternalLatest(); extLatest.textContent=(v==null)?'—':v.toFixed(6); }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function nowSec(){ return Date.now()/1000; }

  // ===== Toroid-only Glow State =====
  let torGlow = {
    alpha: 0.7,        // global alpha for arrows/packets
    ring:  0.7,        // ring brightness factor
    warm:  0.0         // 0 cool-blue … 1 warm-green/teal
  };

  // Triad & coherence → effective params; also compute toroid-only glow state
  function triad(){
    let dc=parseFloat(dcRange.value), de=parseFloat(deRange.value), dm=parseFloat(dmRange.value);
    const s = dc+de+dm || 1; dc/=s; de/=s; dm/=s;
    dcOut.textContent=dc.toFixed(2); deOut.textContent=de.toFixed(2); dmOut.textContent=dm.toFixed(2);
    const H = -[dc,de,dm].reduce((a,p)=>a + (p>0 ? p*Math.log(p) : 0), 0); const Hn = H/Math.log(3); // 0..1
    const kappa_eff = 1.0 + 0.10*(dc - 1/3);
    const b_eff = clamp( lerp(parseFloat(blendNum.value)||0.5, de, 0.35), 0, 1 );
    const tolBase = (BODY[bodySel.value]||BODY.Earth).tolBase;
    const tolEff = tolBase * (0.85 + 0.30*(1 - Hn));

    // Toroid-only glow parameters (no page background changes)
    setToroidGlow(Hn);

    HOut.textContent = Hn.toFixed(3); kappaOut.textContent = kappa_eff.toFixed(3);
    tolEffOut.textContent = `±${tolEff.toFixed(1)}%`; bEffOut.textContent = b_eff.toFixed(2);
    tolOut.textContent = `±${tolBase.toFixed(1)}% (base)`;
    return { dc, de, dm, Hn, kappa_eff, b_eff, tolEff };
  }

  function phaseNow(){
    if(!cstSync.checked){ return ((nowSec()%period)/period)*TWO_PI; }
    const t = new Date(); const ms = t.getTime(); const sec = (ms/1000)|0; const frac = (ms/1000 - sec);
    const base = (sec % Math.floor(period)) / period; return ((base + frac/period) % 1) * TWO_PI;
  }

  // Wave model
  function baseWave(ph, beff){
    const vib = Math.sin(ph);
    const tri = 2*Math.abs((ph/Math.PI)%2 - 1)-1;
    const saw = (ph/Math.PI)%2 - 1;
    const inf = 0.6*tri + 0.4*saw;
    return (1-beff)*vib + beff*inf;
  }
  function coloredTerm(ph){ return Math.sin(ph*3.7+0.5) + 0.7*Math.sin(ph*2.3-0.9); }
  function instantaneousV(ph, beff){
    let A = parseFloat(ampNum.value)||V_TARGET; const n = parseFloat(noiseNum.value)||0.3;
    const noiseVis = (rand()*0.9 + 0.5*coloredTerm(ph))*n*0.35;
    const mix = (1-n)*baseWave(ph,beff) + n*0.3*coloredTerm(ph) + noiseVis;
    return Math.abs(A*mix);
  }

  // RMS & display
  function pushRMS(x){ rmsBuf[rmsIdx]=x*x; rmsIdx=(rmsIdx+1)%RMS_LEN; if(rmsFilled<RMS_LEN) rmsFilled++; }
  function currentRMS(){ let s=0,N=rmsFilled||1; for(let i=0;i<N;i++) s+=rmsBuf[i]; return Math.sqrt(s/N); }
  function resetBuffers(){ rmsBuf.fill(0); rmsIdx=0; rmsFilled=0; dispBuf.fill(0); dispIdx=0; dispFill=0; }
  function pushDisp(v){ dispBuf[dispIdx]=v; dispIdx=(dispIdx+1)%DISP_LEN; if(dispFill<DISP_LEN) dispFill++; }
  function sampleDisp(x){ if(!dispFill) return 0; const start=(dispIdx - dispFill + DISP_LEN)%DISP_LEN; const idx=(start + x)%DISP_LEN; return dispBuf[idx]; }

  function currentVRMS(){ if(extEnable.checked){ const v=parseExternalLatest(); if(v!=null) return Math.abs(v); } return currentRMS(); }
  function G_from_v(v){ return (v*v)/(8*Math.PI*c*c); }

  async function measureVRMS(seconds=0.8, beff=0.5){
    resetBuffers(); const end = performance.now() + seconds*1000;
    while(performance.now() < end){ await new Promise(r=>requestAnimationFrame(r)); const ph=phaseNow(); const v=instantaneousV(ph, beff); pushRMS(v); pushDisp(v); }
    return currentRMS();
  }
  async function autoCalibrateA(beff){
    const wasExt = extEnable.checked; if(wasExt){ extEnable.checked=false; extRefresh(); }
    let vr = await measureVRMS(0.8, beff); if(vr<1e-9) vr=1; let A=parseFloat(ampNum.value)||1; A *= (V_TARGET/vr); ampNum.value=A.toFixed(3);
    vr = await measureVRMS(0.5, beff); A=parseFloat(ampNum.value)||1; A *= (V_TARGET/vr); ampNum.value=A.toFixed(3);
    if(wasExt){ extEnable.checked=true; extRefresh(); }
  }

  // Drawing — wave
  function drawWave(vmax){
    const W=wave.width,H=wave.height; ctx.clearRect(0,0,W,H);
    ctx.strokeStyle='#28407f'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,H-30); ctx.lineTo(W,H-30); ctx.stroke();
    ctx.strokeStyle='#8fb4ff'; ctx.lineWidth=2; ctx.beginPath();
    for(let x=0;x<W;x++){
      const vv=sampleDisp(x); const y=H-30-(vv/Math.max(1,vmax))*(H-50);
      if(x===0) ctx.moveTo(x+2,y); else ctx.lineTo(x+2,y);
    }
    ctx.stroke();
    if(scanMarks.length){ ctx.strokeStyle='#7bffb1'; ctx.lineWidth=1.5; const secondsShown=6;
      scanMarks.forEach(m=>{ const dt=nowSec()-m.t; const x=W - (dt/secondsShown)*W; if(x>=0){ ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,H-35); ctx.stroke(); }});
    }
  }
  function drawKPIs(vrms, tolEff){
    const g = G_from_v(vrms); vOut.textContent = vrms.toFixed(6); gOut.textContent = g.toExponential(11);
    const err = ((g - G0)/G0)*100; errOut.textContent = isFinite(err)? err.toFixed(3)+'%' : '—';
    errOut.className='v mono '+(Math.abs(err)<=tolEff?'good':Math.abs(err)<=2*tolEff?'warn':'bad');
  }
  function drawPhase(ph){
    const W=phaseDial.width,H=phaseDial.height,cx=W/2,cy=H/2+10,r=60; pctx.clearRect(0,0,W,H);
    pctx.strokeStyle='#28407f'; pctx.lineWidth=2; pctx.beginPath(); pctx.arc(cx,cy,r,0,TWO_PI); pctx.stroke();
    pctx.strokeStyle='#213067'; pctx.lineWidth=1; for(let k=0;k<12;k++){ const ang=k*(Math.PI/6); const tx1=cx+(r-8)*Math.cos(ang-Math.PI/2), ty1=cy+(r-8)*Math.sin(ang-Math.PI/2); const tx2=cx+(r)*Math.cos(ang-Math.PI/2), ty2=cy+(r)*Math.sin(ang-Math.PI/2); pctx.beginPath(); pctx.moveTo(tx1,ty1); pctx.lineTo(tx2,ty2); pctx.stroke(); }
    pctx.strokeStyle='#8fb4ff'; pctx.lineWidth=3; const x=cx+r*Math.cos(ph-Math.PI/2), y=cy+r*Math.sin(ph-Math.PI/2); pctx.beginPath(); pctx.moveTo(cx,cy); pctx.lineTo(x,y); pctx.stroke();
    phaseOut.textContent = ph.toFixed(3); setCSTClock();
  }

  function setToroidGlow(Hn){
    const intensity = glowEnable.checked ? parseFloat(glowIntensity.value||0.85) : 0;
    torGlow.alpha = 0.3 + 0.7*Hn*intensity;
    torGlow.ring  = 0.35 + 0.65*Hn;
    torGlow.warm  = 0.15 + 0.55*Hn*intensity;
    glowDot.style.backgroundColor = `rgba(123,255,177,${0.35+0.65*Hn*intensity})`;
  }

  // Toroid drawing (orbiting arrows & dots; clockwise)
  function drawToroid(ph){
    const W=toroid.width,H=toroid.height; tctx.clearRect(0,0,W,H); if(toroidShow.value!=='on') return;
    const dir=flowDir.value, blink=parseFloat(blinkSpeedNum.value), pSpeed=parseFloat(packetSpeedNum.value);
    const scale=parseFloat(ringScaleNum.value), nArrows=parseInt(arrowCountNum.value,10), nPackets=parseInt(packetCountNum.value,10);
    const cx=W/2, cy=H/2, R=110*scale, r=40*scale;

    const cool = {r:143,g:180,b:255};
    const warm = {r:123,g:255,b:177};
    const mix = torGlow.warm;
    const col = { r:Math.round(cool.r+(warm.r-cool.r)*mix),
                  g:Math.round(cool.g+(warm.g-cool.g)*mix),
                  b:Math.round(cool.b+(warm.b-cool.b)*mix) };
    const ringStroke = `rgba(${col.r},${col.g},${col.b},${Math.max(0.25,0.6*torGlow.ring)})`;
    const arrowStroke= `rgba(${col.r},${col.g},${col.b},${torGlow.alpha})`;
    const dotFill    = `rgba(${Math.round(0.9*warm.r)},${warm.g},${warm.b},${0.35+0.65*torGlow.alpha})`;

    tctx.strokeStyle=ringStroke; tctx.lineWidth=2; tctx.beginPath(); tctx.ellipse(cx,cy,R,r,0,0,TWO_PI); tctx.stroke();
    const pulse=(glowEnable.checked?0.08*Math.sin(ph*2):0); const Rin=R*(1-0.25+pulse), rin=r*(1-0.25+pulse); tctx.beginPath(); tctx.ellipse(cx,cy,Rin,rin,0,0,TWO_PI); tctx.stroke();

    const t = nowSec(); const spin = parseFloat(orbitSpeedNum.value||0.6); const angOffset = -t * spin;
    for(let k=0;k<nArrows;k++){
      const baseAng = k*(TWO_PI/nArrows); const ang = baseAng + angOffset;
      const ax=cx+R*Math.cos(ang), ay=cy+r*Math.sin(ang);
      const baseDir=Math.atan2(cy-ay,cx-ax); const theta=(dir==='in')?baseDir:baseDir+Math.PI;
      tctx.save();
      const blinkAlpha = 0.6+0.4*(0.5*(1+Math.sin(ph*blink*2)));
      tctx.globalAlpha = torGlow.alpha * blinkAlpha;
      tctx.translate(ax,ay); tctx.rotate(theta);
      tctx.strokeStyle=arrowStroke; tctx.lineWidth=2;
      const len=26*scale; tctx.beginPath(); tctx.moveTo(0,0); tctx.lineTo(len,0); tctx.stroke();
      tctx.beginPath(); tctx.moveTo(len,0); tctx.lineTo(len-6,4); tctx.lineTo(len-6,-4); tctx.closePath(); tctx.stroke();
      tctx.restore();
    }

    const sign=(dir==='in')?1:-1, baseRate=(parseFloat(packetSpeedNum.value)||1.4)*0.9;
    for(let j=0;j<nPackets;j++){
      const phaseJ=(j/nPackets)*TWO_PI, psi=(phaseJ+sign*(t*baseRate))%TWO_PI; const px=cx+R*Math.cos(psi), py=cy+r*Math.sin(psi);
      const s=3.0*scale*(1.0+0.18*Math.sin(ph*3 + j));
      tctx.beginPath(); tctx.fillStyle=dotFill; tctx.arc(px,py,s,0,TWO_PI); tctx.fill();
    }
  }

  // ===== Panel 2: Coil & Spring helpers =====
  function updateCoilUI(){
    coilNcOut.textContent = parseInt(coilNc.value,10);
    coilTauOut.textContent = parseFloat(coilTau.value).toFixed(2);
    coilKsOut.textContent = parseFloat(coilKs.value).toFixed(2);
    coilGammaOut.textContent = parseFloat(coilGamma.value).toFixed(2);
  }

  function assemblyFromParams(Hn){
    const Nc = parseInt(coilNc.value,10)||8;
    const tau = parseFloat(coilTau.value)||0.9;
    const ks = parseFloat(coilKs.value)||1.0;
    const gamma = parseFloat(coilGamma.value)||0.3;
    function gauss(x,mu,sig){ const z=(x-mu)/sig; return Math.exp(-z*z); }
    const NcTerm = gauss(Nc,12,4.5);
    const tauTerm= gauss(tau,0.9,0.32);
    const ksTerm = gauss(ks,1.0,0.65);
    const gTerm  = gauss(gamma,0.35,0.25);
    let A = Hn * (0.25*NcTerm + 0.25*tauTerm + 0.25*ksTerm + 0.25*gTerm);
    return clamp(A,0,1);
  }

  function updateAssemblyReadout(Hn){
    const A = assemblyFromParams(Hn);
    assemblyOut.textContent = A.toFixed(3);
    let label, note;
    if(A>0.8){
      label='High structural coherence';
      note='Coils lock into a stable lattice; springs share load smoothly.';
    }else if(A>0.45){
      label='Moderate structuring';
      note='Framework forms but some modes are still loose or over-damped.';
    }else{
      label='Low structuring';
      note='Energy is condensed but not yet organized into a stable framework.';
    }
    assemblyLabel.textContent = label;
    assemblyNote.textContent = note;
    return A;
  }

  function drawCoil(ph, tri){
    const W=coilCanvas.width,H=coilCanvas.height;
    cc.clearRect(0,0,W,H);

    const Nc = parseInt(coilNc.value,10)||8;
    const tau = parseFloat(coilTau.value)||0.9;
    const ks = parseFloat(coilKs.value)||1.0;
    const gamma = parseFloat(coilGamma.value)||0.3;
    const A = assemblyFromParams(tri.Hn);

    const baseColor = {r:143,g:180,b:255};
    const strongColor = {r:123,g:255,b:177};
    const mix = A;
    const col = {
      r:Math.round(baseColor.r + (strongColor.r-baseColor.r)*mix),
      g:Math.round(baseColor.g + (strongColor.g-baseColor.g)*mix),
      b:Math.round(baseColor.b + (strongColor.b-baseColor.b)*mix)
    };
    const filamentStroke = `rgba(${col.r},${col.g},${col.b},${0.35+0.55*A})`;
    const springStroke   = `rgba(${col.r},${col.g},${col.b},${0.25+0.50*A})`;

    const midY = H*0.52;

    cc.strokeStyle='rgba(33,48,103,0.8)';
    cc.lineWidth=1;
    cc.beginPath();
    cc.moveTo(20,midY);
    cc.lineTo(W-20,midY);
    cc.stroke();

    const nPosts = 4;
    const span = (W-80)/(nPosts-1);
    for(let i=0;i<nPosts;i++){
      const x = 40 + i*span;
      const h = 40 + 35*ks;
      cc.beginPath();
      cc.moveTo(x,midY-h/2);
      cc.lineTo(x,midY+h/2);
      cc.stroke();
    }

    cc.strokeStyle=filamentStroke;
    cc.lineWidth=1.5;
    const amp = 10 + 18*tau;
    const nCoils = Math.max(1,Nc);
    for(let k=0;k<nCoils;k++){
      const tNorm = k/Math.max(1,nCoils-1);
      const y0 = midY - 30 + 60*tNorm;
      cc.beginPath();
      for(let x=30;x<=W-30;x+=4){
        const u=(x-30)/(W-60);
        const phase = ph*0.8 + tNorm*TWO_PI;
        const y = y0 + amp*Math.sin(2*Math.PI*u*tau*1.2 + phase);
        if(x===30) cc.moveTo(x,y); else cc.lineTo(x,y);
      }
      cc.stroke();
    }

    cc.strokeStyle=springStroke;
    cc.lineWidth=1.2;
    const baseSag = 12+24*gamma;
    for(let i=0;i<nPosts-1;i++){
      const x1 = 40 + i*span;
      const x2 = 40 + (i+1)*span;
      const steps = 14;
      const yTop = midY - 6;
      const yBottom = midY + 6 + baseSag*(1-0.4*A);
      cc.beginPath();
      for(let s=0;s<=steps;s++){
        const t = s/steps;
        const x = x1 + (x2-x1)*t;
        const y = (s%2===0)?yTop:yBottom;
        if(s===0) cc.moveTo(x,y); else cc.lineTo(x,y);
      }
      cc.stroke();
    }

    if(A>0.75){
      cc.strokeStyle=`rgba(${col.r},${col.g},${col.b},0.35)`;
      cc.lineWidth=2;
      cc.strokeRect(24,midY-52, W-48, 104);
    }
  }

  // Derived VT↔CIT table
  function fillDerived(vrms, tri){
    const b = BODY[bodySel.value] || BODY.Earth; const kappa = tri.kappa_eff; const R=b.R, rho=b.rho, g=b.g;
    const rho_v = (g * rho * R) / (2*Math.PI * kappa * c * c);
    const u_v = rho_v * c * c;
    const rho_influx = u_v / (vrms*vrms);
    const T = period; const omega = TWO_PI / T; const vchar = omega * R; const f = vrms/(TWO_PI*R);
    const rows = [
      ['R', 'Radius (m)', fmt(R)],
      ['ρ_mat', 'Mean density (kg/m³)', fmt(rho)],
      ['g', 'Surface acceleration (m/s²)', fmt(g)],
      ['κ_eff', 'VT coupling (with DC bias)', fmt(kappa,3)],
      ['ρ_v', 'Vibrational density (kg/m³)', sci(rho_v)],
      ['u_v', 'Vibrational energy density (J/m³)', sci(u_v)],
      ['ρ_influx', 'Influx density (kg/m³)', sci(rho_influx)],
      ['T', 'Mode period (s)', fmt(T,2)],
      ['ω', 'Angular frequency (s⁻¹)', sci(omega,6)],
      ['v_char', 'Characteristic v = ωR (m/s)', fmt(vchar,6)],
      ['f', 'Frequency = v/(2πR) (Hz)', sci(f,6)],
    ];
    derivedBody.innerHTML = rows.map(r=>`<tr><td class="mono">${r[0]}</td><td>${r[1]}</td><td class="mono">${r[2]}</td></tr>`).join('');
  }

  function fmt(x, d=0){ return Number(x).toLocaleString(undefined,{maximumFractionDigits:d}); }
  function sci(x, d=3){ return Number(x).toExponential(d); }

  // Explanations
  function fillExplain(){
    explain.innerHTML = `
      <ul>
        <li><b>Harmony Glow (canvas-only):</b> Color &amp; brightness respond to the DC/DE/DM coherence index H <i>inside</i> the torus. Page background never changes.</li>
        <li><b>Curvature normalization (for QMC / CST interface):</b> the simulator uses
          <span class="mono">C = v_RMS / v_RMS(Earth-ref)</span>, so C = 1.0 corresponds to the Earth 54-minute reference band.</li>
        <li><b>Frequency–energy mapping:</b> for visualization the effective energy is
          <span class="mono">E_eff = k · v_RMS²</span>, with k chosen so that the Earth 54-minute band maps to E_eff ≈ 1 in the glow layer.</li>
        <li><b>VT↔CIT v-RMS equivalence (for Ruud &amp; Carl):</b> each scan applies
          <span class="mono">G_est = v² / (8π c²)</span> and compares it to G₀ = 6.67430×10⁻¹¹ m³·kg⁻¹·s⁻². The Auto-Scan log plus
          <b>Export CSV</b> give the full dataset (v_RMS, G_est, Δ vs G₀, Pass/Fail, body, mode, CST time).</li>
        <li><b>Exports for external teams:</b> use <b>Download Wave + Data PNG</b> for the live v-RMS waveform, <b>Download Toroid + Data PNG</b> for the toroidal flow, <b>Download Strings (Coils) + Data PNG</b> for the coil/lattice, and <b>Export CSV</b> for the corresponding numeric run.</li>
        <li><b>Coil &amp; Spring Panel (2):</b> N<sub>c</sub>, τ<sub>c</sub>, k<sub>s</sub>, and γ show how condensed VT↔CIT modes organize into a filament + lattice framework as assembly index A → 1.</li>
      </ul>`;
  }

  // Auto-scan
  function passFail(errPct, tolEff){ return Math.abs(errPct) <= tolEff ? 'Pass' : 'Fail'; }
  function appendScanRow(row){
    const tr=document.createElement('tr'); const cls=(row.pass==='Pass')?'good':'bad';
    tr.innerHTML=`<td>${row.idx}</td><td class="mono">${row.time}</td><td>${row.body}</td>
      <td class="mono">${row.modeMin.toFixed(2)}</td><td class="mono">${row.vrms.toFixed(6)}</td>
      <td class="mono">${row.g.toExponential(11)}</td><td class="mono">${row.err.toFixed(3)}%</td>
      <td class="mono ${cls}">${row.pass}</td>`;
    scanBody.appendChild(tr);
  }
  function clearScanAll(){ scanRows=[]; scanMarks=[]; scanBody.innerHTML=''; scanStatus.textContent='Cleared.'; }

  async function runAutoScan10(){
    if(isScanning) return; isScanning=true; scanStatus.textContent='Auto-Scan running… (10 samples)'; scanRows=[]; scanMarks=[];
    const tri = triad();
    if(!extEnable.checked){ ampNum.value = V_TARGET.toFixed(3); await autoCalibrateA(tri.b_eff); }
    const body=bodySel.value, modeMin=currentEarthModeMinutes(); const stepMs=400;
    for(let i=1;i<=10;i++){
      if(i>1) await new Promise(r=>setTimeout(r, stepMs));
      const vrms=currentVRMS(); const g=G_from_v(vrms); const err=((g-G0)/G0)*100; const pf=passFail(err, tri.tolEff);
      scanMarks.push({t: nowSec()}); const row={idx:i,time:cstTimestamp(),body,modeMin,vrms,g,err,pass:pf}; scanRows.push(row); appendScanRow(row);
    }
    scanStatus.textContent='Auto-Scan complete.'; isScanning=false;
  }

  function exportCSV(){
    if(!scanRows.length){ scanStatus.textContent='Nothing to export — run Auto-Scan first.'; return; }
    const tri = triad(); const hdr=['Index','Time_CST','Body','Mode_min','vRMS_m_per_s','G_est_m3kg-1s-2','Delta_vs_G0_percent',`PassFail(|Δ|≤${tri.tolEff.toFixed(1)}%)`];
    const lines=[hdr.join(',')]; scanRows.forEach(r=>lines.push([r.idx,r.time,r.body,r.modeMin.toFixed(2),r.vrms.toFixed(6),r.g.toExponential(11),r.err.toFixed(3),r.pass].join(',')));
    const csv=lines.join('\r\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
    const ts=cstTimestamp().replace(/[: ]/g,'-'); const fname=`vrms_autoscan_${bodySel.value}_${ts}.csv`;
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=fname; a.click(); URL.revokeObjectURL(a.href);
    scanStatus.textContent=`Exported ${fname}`;
  }

  // canvas→PNG helpers
  function downloadCanvasPng(canvas, filename){
    try{
      const link=document.createElement('a');
      link.download=filename;
      link.href=canvas.toDataURL('image/png');
      link.click();
    }catch(e){
      console.warn('PNG download failed', e);
    }
  }

  function downloadCanvasWithData(canvas, filename){
    try{
      const off=document.createElement('canvas');
      off.width=canvas.width;
      off.height=canvas.height;
      const octx=off.getContext('2d');
      octx.drawImage(canvas,0,0);

      const lines = [
        `Time: ${cstTimestamp()} CST`,
        `Body: ${bodySel.value} | Mode: ${periodMinOut.textContent} min`,
        `v_RMS: ${vOut.textContent} m/s`,
        `G_est: ${gOut.textContent}`,
        `Δ vs G0: ${errOut.textContent}`
      ];

      const pad=8, lineH=14;
      const boxHeight = lines.length*lineH + pad*2;
      octx.fillStyle='rgba(11,18,34,0.88)';
      octx.fillRect(0, off.height-boxHeight, off.width, boxHeight);

      octx.fillStyle='#eaf0ff';
      octx.font='11px ui-monospace, SFMono-Regular, Menlo, monospace';
      octx.textBaseline='top';
      let y = off.height - boxHeight + pad;
      const x = pad;
      lines.forEach(str=>{
        octx.fillText(str,x,y);
        y += lineH;
      });

      const link=document.createElement('a');
      link.download=filename;
      link.href=off.toDataURL('image/png');
      link.click();
    }catch(e){
      console.warn('PNG+data download failed', e);
    }
  }

  // Main loop
  let rafId=null;
  function tick(){
    if(!running){ rafId=requestAnimationFrame(tick); return; }
    const tri = triad();
    const ph=phaseNow();
    const vInst=instantaneousV(ph, tri.b_eff); pushRMS(vInst); pushDisp(vInst);
    const vrms=currentVRMS(); const vmax=Math.max(1, parseFloat(ampNum.value)*1.2, (parseExternalLatest()||0)*1.2);
    drawWave(vmax); drawKPIs(vrms, tri.tolEff); drawPhase(ph); drawToroid(ph); drawCoil(ph, tri); fillDerived(vrms, tri);
    updateAssemblyReadout(tri.Hn);
    rafId=requestAnimationFrame(tick);
  }
  function start(){ if(rafId==null) rafId=requestAnimationFrame(tick); }

  // Presets
  function applyPlanetPreset(name){
    const p=PRESETS[name]; if(!p) return;
    bodySel.value=p.body;
    modeSel.value='54'; modeCustom.value=p.mode.toFixed(0); periodFineNum.value=p.fine.toFixed(3);
    ampNum.value=p.A.toFixed(3); noiseNum.value=p.n.toFixed(2); blendNum.value=p.b.toFixed(2);
    toroidShow.value=p.toro.show; flowDir.value=p.toro.dir; blinkSpeedNum.value=p.toro.blink.toFixed(2); packetSpeedNum.value=p.toro.ps.toFixed(2);
    ringScaleNum.value=p.toro.ring.toFixed(2); arrowCountNum.value=p.toro.ar.toFixed(0); packetCountNum.value=p.toro.pk.toFixed(0); orbitSpeedNum.value=p.toro.orb.toFixed(2);
    updatePeriodUI();
  }

  // Events
  [bodySel,modeSel,modeCustom,periodFineNum].forEach(el=>el.addEventListener('input',updatePeriodUI));
  [dcRange,deRange,dmRange,glowEnable,glowIntensity].forEach(el=>el.addEventListener('input',()=>triad()));
  extData.addEventListener('input',extRefresh); extEnable.addEventListener('change',extRefresh);
  scan10.addEventListener('click',runAutoScan10); clearScan.addEventListener('click',clearScanAll); exportCsvBtn.addEventListener('click',exportCSV);
  pauseBtn.addEventListener('click',()=>{running=false;pauseBtn.disabled=true;resumeBtn.disabled=false;});
  resumeBtn.addEventListener('click',()=>{running=true;resumeBtn.disabled=true;pauseBtn.disabled=false;});
  applyPreset.addEventListener('click',()=>applyPlanetPreset(presetSel.value));
  autoCal.addEventListener('click',()=>{ const t=triad(); autoCalibrateA(t.b_eff); });

  [coilNc,coilTau,coilKs,coilGamma].forEach(el=>el.addEventListener('input',()=>{updateCoilUI();}));

  if(saveWavePng){
    saveWavePng.addEventListener('click',()=>{
      const ts=cstTimestamp().replace(/[: ]/g,'-');
      downloadCanvasWithData(wave, `vrms_wave_${bodySel.value}_${ts}.png`);
    });
  }
  if(saveToroidPng){
    saveToroidPng.addEventListener('click',()=>{
      const ts=cstTimestamp().replace(/[: ]/g,'-');
      downloadCanvasWithData(toroid, `vrms_toroid_${bodySel.value}_${ts}.png`);
    });
  }
  if(saveCoilPng){
    saveCoilPng.addEventListener('click',()=>{
      const ts=cstTimestamp().replace(/[: ]/g,'-');
      downloadCanvasWithData(coilCanvas, `vrms_strings_${bodySel.value}_${ts}.png`);
    });
  }

  (function tickClock(){ setCSTClock(); setTimeout(tickClock,1000); })();
  applyPlanetPreset('Earth'); updatePeriodUI(); extRefresh(); fillExplain(); updateCoilUI(); start();
})();
</script>
</body>
</html>
