<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Earth ⇄ Mars 3-Point Geodesic Curvature Demo</title>
<style>
  :root{
    --bg:#0b0f16; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
  }
  *{ box-sizing:border-box; }
  body{ margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--ink); }
  .wrap{ display:grid; grid-template-columns: 1.35fr 0.65fr; gap:14px; padding:14px; }
  canvas{ width:100%; height: calc(100vh - 28px); background:#070a10; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .panel{ height: calc(100vh - 28px); background:var(--panel); border-radius:14px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); overflow:auto; }
  h1{ font-size:16px; margin:0 0 8px; }
  .tiny{ font-size:12px; color:var(--muted); line-height:1.35; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
  button{
    background:#1f2937; color:var(--ink); border:1px solid #374151; border-radius:10px;
    padding:10px 12px; cursor:pointer;
  }
  button:hover{ filter:brightness(1.08); }
  button.primary{ background:#2563eb; border-color:#1d4ed8; }
  button.danger{ background:#991b1b; border-color:#7f1d1d; }
  .box{ border:1px solid #374151; border-radius:12px; padding:10px; margin:10px 0; background:#0b1220; }
  .tag{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #374151; color:var(--muted); }
  .tag.good{ border-color: rgba(34,197,94,.45); color:#86efac; }
  .tag.warn{ border-color: rgba(245,158,11,.45); color:#fde68a; }
  .tag.bad{ border-color: rgba(239,68,68,.45); color:#fecaca; }
  .kv{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 10px; margin-top:8px; }
  .k{ color:var(--muted); font-size:12px; }
  .v{ font-variant-numeric: tabular-nums; }
  input[type="range"]{ width:100%; }
  textarea{
    width:100%; min-height:200px; resize:vertical;
    border-radius:12px; border:1px solid #374151; background:#060a12; color:var(--ink); padding:10px;
  }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="cv"></canvas>

  <div class="panel">
    <h1>Earth ⇄ Mars 3-Point Geodesic Curvature Demo (Sun static)</h1>
    <div class="tiny">
      This matches your “circle creates 3 points” idea: a rotating line locks <b>3 anchor points</b> and draws
      the <b>3 locked vectors</b> + <b>triangle chords</b> (geodesic-style paths) for Earth, then Mars.
      After both run 360°, we compare closest angular alignment.
    </div>

    <div class="row" style="justify-content:space-between; align-items:center;">
      <span class="tag good" id="jsTag">JS RUNNING ✅</span>
      <span class="tag" id="phaseTag">Phase: idle</span>
      <span class="tag" id="alignTag">Alignment: waiting</span>
    </div>

    <div class="row">
      <button class="primary" id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button class="danger" id="resetBtn">Reset</button>
      <button id="printBtn">Print</button>
    </div>

    <div class="box">
      <div class="k">Simulation speed</div>
      <input id="speed" type="range" min="0.2" max="6" step="0.1" value="1.5"/>
      <div class="tiny">Higher = faster sweep. Earth completes 360° then Mars.</div>
    </div>

    <div class="box">
      <div class="k">Live readouts</div>
      <div class="kv">
        <div class="k">Earth θ (deg)</div><div class="v" id="earthDeg">—</div>
        <div class="k">Mars θ (deg)</div><div class="v" id="marsDeg">—</div>

        <div class="k">Earth r (AU)</div><div class="v" id="earthR">—</div>
        <div class="k">Mars r (AU)</div><div class="v" id="marsR">—</div>

        <div class="k">Earth v (km/s)</div><div class="v" id="earthV">—</div>
        <div class="k">Mars v (km/s)</div><div class="v" id="marsV">—</div>

        <div class="k">Earth closest/farthest (AU)</div><div class="v" id="earthCF">—</div>
        <div class="k">Mars closest/farthest (AU)</div><div class="v" id="marsCF">—</div>

        <div class="k">Best match Δθ (deg)</div><div class="v" id="matchDeg">—</div>
        <div class="k">Hohmann time / Δv (ideal)</div><div class="v" id="hohmann">—</div>
      </div>
    </div>

    <div class="box">
      <div class="k">Log</div>
      <textarea id="log" readonly></textarea>
    </div>

    <div class="tiny">
      If buttons still don’t work, you’re likely running this inside a builder that blocks scripts.
      Save as a local <b>.html</b> file and open in Chrome/Edge.
    </div>
  </div>
</div>

<script>
(function(){
  // ---------- DOM ----------
  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d");
  const $ = id => document.getElementById(id);

  const startBtn = $("startBtn"), pauseBtn = $("pauseBtn"), resetBtn = $("resetBtn"), printBtn = $("printBtn");
  const speedEl = $("speed");
  const phaseTag = $("phaseTag"), alignTag = $("alignTag");

  const earthDegEl=$("earthDeg"), marsDegEl=$("marsDeg");
  const earthREl=$("earthR"), marsREl=$("marsR");
  const earthVEl=$("earthV"), marsVEl=$("marsV");
  const earthCF=$("earthCF"), marsCF=$("marsCF");
  const matchDegEl=$("matchDeg"), hohmannEl=$("hohmann");
  const logEl=$("log");

  // ---------- Constants ----------
  const AU = 1.495978707e11;          // m
  const MU_SUN = 1.32712440018e20;    // m^3/s^2

  const Earth = { name:"Earth", a_AU:1.00000011, e:0.01671022, color:"#3b82f6", period_days:365.256 };
  const Mars  = { name:"Mars",  a_AU:1.523679,   e:0.0934,     color:"#fb7185", period_days:686.980 };

  // Your “3 points” anchors (geodesic vectors to these)
  const TP = [
    {label:"Perihelion (closest)", theta:0},
    {label:"Quadrature (90°)",     theta:Math.PI/2},
    {label:"Aphelion (farthest)",  theta:Math.PI}
  ];

  // ---------- Resize ----------
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.max(700, Math.floor(rect.width  * dpr));
    canvas.height = Math.max(500, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  // ---------- Math ----------
  const TWO_PI = 2*Math.PI;
  const deg = r => r*180/Math.PI;
  const wrap2pi = t => (t%TWO_PI + TWO_PI) % TWO_PI;

  function fmt(n,d=3){ return Number.isFinite(n) ? n.toFixed(d) : "—"; }

  function rAU(planet, theta){
    const a = planet.a_AU, e = planet.e;
    const p = a*(1 - e*e);
    return p / (1 + e*Math.cos(theta)); // Sun at focus
  }

  function visViva_kms(planet, r_AU){
    const r = r_AU * AU;
    const a = planet.a_AU * AU;
    const v = Math.sqrt(MU_SUN * (2/r - 1/a)); // m/s
    return v / 1000;
  }

  function nearAngle(a,b,eps){
    let d = (a-b) % TWO_PI;
    if (d>Math.PI) d-=TWO_PI;
    if (d<-Math.PI) d+=TWO_PI;
    return Math.abs(d) <= eps;
  }

  // chord length between two orbital points in AU (straight-line in this 2D plane)
  function chordAU(p1, p2){
    const dx = p1.r_AU*Math.cos(p1.theta) - p2.r_AU*Math.cos(p2.theta);
    const dy = p1.r_AU*Math.sin(p1.theta) - p2.r_AU*Math.sin(p2.theta);
    return Math.sqrt(dx*dx + dy*dy);
  }

  // ---------- Hohmann (idealized) ----------
  function hohmann(){
    const r1 = Earth.a_AU * AU;
    const r2 = Mars.a_AU  * AU;
    const aT = (r1 + r2)/2;

    const v1  = Math.sqrt(MU_SUN / r1);
    const v2  = Math.sqrt(MU_SUN / r2);
    const vT1 = Math.sqrt(MU_SUN * (2/r1 - 1/aT));
    const vT2 = Math.sqrt(MU_SUN * (2/r2 - 1/aT));

    const dv1 = Math.abs(vT1 - v1);
    const dv2 = Math.abs(v2 - vT2);
    const dvT = dv1 + dv2;

    const t = Math.PI * Math.sqrt((aT*aT*aT)/MU_SUN); // seconds
    return { days: t/86400, dv_kms: dvT/1000 };
  }
  const H = hohmann();
  hohmannEl.textContent = `${H.days.toFixed(1)} d / ${H.dv_kms.toFixed(3)} km/s`;

  // ---------- Drawing ----------
  function clear(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

  function drawStars(w,h){
    ctx.save();
    ctx.fillStyle="rgba(255,255,255,0.07)";
    for (let i=0;i<120;i++){
      const x=(i*173)%w, y=(i*97)%h;
      ctx.fillRect(x,y,1,1);
    }
    ctx.restore();
  }

  function drawSun(cx,cy){
    ctx.save();
    const grd = ctx.createRadialGradient(cx,cy,2,cx,cy,70);
    grd.addColorStop(0,"rgba(255,215,0,0.95)");
    grd.addColorStop(1,"rgba(255,215,0,0.0)");
    ctx.fillStyle=grd;
    ctx.beginPath(); ctx.arc(cx,cy,70,0,TWO_PI); ctx.fill();

    ctx.fillStyle="#facc15";
    ctx.beginPath(); ctx.arc(cx,cy,12,0,TWO_PI); ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.font="14px system-ui";
    ctx.fillText("SUN (static)", cx+16, cy+5);
    ctx.restore();
  }

  function orbitPoint(cx,cy,pxPerAU, planet, theta){
    const r = rAU(planet, theta);
    return { x: cx + Math.cos(theta)*r*pxPerAU, y: cy + Math.sin(theta)*r*pxPerAU, r_AU:r, theta };
  }

  function drawOrbit(cx,cy,pxPerAU, planet){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.92)";
    ctx.lineWidth=4;
    ctx.beginPath();
    const steps=900;
    for (let i=0;i<=steps;i++){
      const th=(i/steps)*TWO_PI;
      const P=orbitPoint(cx,cy,pxPerAU,planet,th);
      if (i===0) ctx.moveTo(P.x,P.y); else ctx.lineTo(P.x,P.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawPlanetDot(P, planet){
    ctx.save();
    ctx.fillStyle=planet.color;
    ctx.beginPath(); ctx.arc(P.x,P.y,8,0,TWO_PI); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.font="13px system-ui";
    ctx.fillText(planet.name, P.x+12, P.y+4);
    ctx.restore();
  }

  function drawRadial(cx,cy,P, alpha=0.65, width=2){
    ctx.save();
    ctx.strokeStyle=`rgba(255,255,255,${alpha})`;
    ctx.lineWidth=width;
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.lineTo(P.x,P.y);
    ctx.stroke();
    ctx.restore();
  }

  // locked geodesic vectors (Sun->anchor points)
  function drawLockedVectors(cx,cy, locked){
    for (const m of locked){
      drawRadial(cx,cy,m,0.75,3);
    }
  }

  function drawAnchorMarks(locked){
    ctx.save();
    for (const m of locked){
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.beginPath(); ctx.arc(m.x,m.y,6,0,TWO_PI); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.85)";
      ctx.font="12px system-ui";
      ctx.fillText(m.labelShort, m.x+10, m.y-10);
    }
    ctx.restore();
  }

  // triangle chords between the 3 anchor points (geodesic-style straight chords)
  function drawTriangleChords(locked){
    if (locked.length !== 3) return;
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.35)";
    ctx.lineWidth=2.5;
    ctx.beginPath();
    ctx.moveTo(locked[0].x, locked[0].y);
    ctx.lineTo(locked[1].x, locked[1].y);
    ctx.lineTo(locked[2].x, locked[2].y);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  // ---------- State ----------
  let running=false, paused=false;
  let phase="idle"; // idle -> earth -> mars -> done
  let thetaE=0, thetaM=0;
  let lastT=performance.now();

  const lockedEarth=[]; // locked points objects
  const lockedMars=[];
  const markedE = new Set();
  const markedM = new Set();

  const baseSweepSeconds = 18; // each 360 sweep at speed=1

  function logLine(s){
    logEl.value += s + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setTags(){
    phaseTag.textContent = `Phase: ${phase}${paused ? " (paused)" : ""}`;
    phaseTag.className = "tag" + (phase==="done" ? " good" : (phase==="idle" ? "" : " warn"));
  }

  function alignmentReport(){
    if (lockedEarth.length<3 || lockedMars.length<3) return null;
    let best = {d:1e9, e:null, m:null};
    for (const e of lockedEarth){
      for (const m of lockedMars){
        let d = (e.theta - m.theta) % TWO_PI;
        if (d>Math.PI) d-=TWO_PI;
        if (d<-Math.PI) d+=TWO_PI;
        d = Math.abs(d);
        if (d < best.d) best = {d,e,m};
      }
    }
    return { matchDeg: deg(best.d), e:best.e, m:best.m };
  }

  function tryLock(planetName){
    const eps = 0.04; // ~2.3°
    const isE = planetName==="Earth";
    const planet = isE ? Earth : Mars;
    const theta  = isE ? thetaE : thetaM;
    const marked = isE ? markedE : markedM;
    const locked = isE ? lockedEarth : lockedMars;

    // compute geometry frame
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const pxPerAU = Math.min(rect.width, rect.height)*0.26;

    for (const tp of TP){
      if (marked.has(tp.label)) continue;
      if (nearAngle(theta, tp.theta, eps)){
        const P = orbitPoint(cx,cy,pxPerAU, planet, tp.theta);
        const v = visViva_kms(planet, P.r_AU);
        marked.add(tp.label);
        locked.push({
          label: tp.label,
          labelShort: tp.label.includes("Peri") ? "Peri" : (tp.label.includes("Aph") ? "Aph" : "Quad"),
          theta: tp.theta,
          x:P.x, y:P.y, r_AU:P.r_AU,
          v_kms:v
        });
        logLine(`[${planetName}] LOCKED ${tp.labelShort} at θ=${deg(tp.theta).toFixed(1)}° | r=${P.r_AU.toFixed(6)} AU | v=${v.toFixed(3)} km/s`);
      }
    }
  }

  function reset(){
    running=false; paused=false; phase="idle";
    thetaE=0; thetaM=0;
    lockedEarth.length=0; lockedMars.length=0;
    markedE.clear(); markedM.clear();
    logEl.value="";
    logLine("Reset complete. Click Start.");
    setTags();
    updateUI();
  }

  // ---------- UI ----------
  function updateUI(){
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const pxPerAU = Math.min(rect.width, rect.height)*0.26;

    if (phase==="idle"){
      earthDegEl.textContent="—"; marsDegEl.textContent="—";
      earthREl.textContent="—";  marsREl.textContent="—";
      earthVEl.textContent="—";  marsVEl.textContent="—";
      earthCF.textContent="—";   marsCF.textContent="—";
      matchDegEl.textContent="—";
      alignTag.textContent="Alignment: waiting";
      alignTag.className="tag";
      return;
    }

    const PE = orbitPoint(cx,cy,pxPerAU, Earth, thetaE);
    earthDegEl.textContent = fmt(deg(thetaE),1);
    earthREl.textContent   = fmt(PE.r_AU,6);
    earthVEl.textContent   = fmt(visViva_kms(Earth, PE.r_AU),3);

    // closest/farthest from locked points (if available)
    if (lockedEarth.length){
      const rPeri = lockedEarth.find(p=>p.labelShort==="Peri")?.r_AU;
      const rAph  = lockedEarth.find(p=>p.labelShort==="Aph")?.r_AU;
      earthCF.textContent = (rPeri && rAph) ? `${rPeri.toFixed(6)} / ${rAph.toFixed(6)}` : "—";
    }

    if (phase==="mars" || phase==="done"){
      const PM = orbitPoint(cx,cy,pxPerAU, Mars, thetaM);
      marsDegEl.textContent = fmt(deg(thetaM),1);
      marsREl.textContent   = fmt(PM.r_AU,6);
      marsVEl.textContent   = fmt(visViva_kms(Mars, PM.r_AU),3);

      if (lockedMars.length){
        const rPeri = lockedMars.find(p=>p.labelShort==="Peri")?.r_AU;
        const rAph  = lockedMars.find(p=>p.labelShort==="Aph")?.r_AU;
        marsCF.textContent = (rPeri && rAph) ? `${rPeri.toFixed(6)} / ${rAph.toFixed(6)}` : "—";
      }
    } else {
      marsDegEl.textContent="—"; marsREl.textContent="—"; marsVEl.textContent="—"; marsCF.textContent="—";
    }

    const R = alignmentReport();
    if (!R){
      matchDegEl.textContent="—";
      alignTag.textContent="Alignment: waiting";
      alignTag.className="tag";
    } else {
      matchDegEl.textContent = fmt(R.matchDeg,3);
      if (R.matchDeg <= 1.5){
        alignTag.textContent = "Alignment: TOUCH (≤1.5°)";
        alignTag.className="tag good";
      } else if (R.matchDeg <= 5){
        alignTag.textContent = "Alignment: close (≤5°)";
        alignTag.className="tag warn";
      } else {
        alignTag.textContent = "Alignment: not close";
        alignTag.className="tag bad";
      }
    }
  }

  // ---------- Loop ----------
  function tick(now){
    const dt = Math.min(0.05, (now - lastT)/1000);
    lastT = now;

    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const pxPerAU = Math.min(rect.width, rect.height)*0.26;

    if (running && !paused){
      const speed = parseFloat(speedEl.value);
      const omega = TWO_PI / (baseSweepSeconds / speed);

      if (phase==="earth"){
        thetaE = wrap2pi(thetaE + omega*dt);
        tryLock("Earth");

        // stop Earth after full lock and passing near 0 again
        if (markedE.size===3 && nearAngle(thetaE, 0, 0.02)){
          thetaE = 0;
          phase = "mars";
          logLine("— Earth 360° complete. Earth stopped. Starting Mars sweep. —");
          setTags();
        }
      } else if (phase==="mars"){
        thetaM = wrap2pi(thetaM + omega*dt);
        tryLock("Mars");

        if (markedM.size===3 && nearAngle(thetaM, 0, 0.02)){
          thetaM = 0;
          phase = "done";
          logLine("— Mars 360° complete. Mars stopped. —");

          // chord lengths (triangle geodesic-style)
          if (lockedEarth.length===3){
            const c01 = chordAU(lockedEarth[0], lockedEarth[1]);
            const c12 = chordAU(lockedEarth[1], lockedEarth[2]);
            const c20 = chordAU(lockedEarth[2], lockedEarth[0]);
            logLine(`[Earth chords] (AU) ${c01.toFixed(4)}, ${c12.toFixed(4)}, ${c20.toFixed(4)}`);
          }
          if (lockedMars.length===3){
            const c01 = chordAU(lockedMars[0], lockedMars[1]);
            const c12 = chordAU(lockedMars[1], lockedMars[2]);
            const c20 = chordAU(lockedMars[2], lockedMars[0]);
            logLine(`[Mars chords] (AU) ${c01.toFixed(4)}, ${c12.toFixed(4)}, ${c20.toFixed(4)}`);
          }

          const R = alignmentReport();
          if (R){
            logLine(`BEST ANGLE TOUCH: Δθ=${R.matchDeg.toFixed(3)}° | Earth:${R.e.labelShort} vs Mars:${R.m.labelShort}`);
            logLine(`Hohmann (ideal): ${H.days.toFixed(1)} days, total Δv ~ ${H.dv_kms.toFixed(3)} km/s`);
          }
          setTags();
        }
      }
    }

    // ----- draw -----
    ctx.save();
    clear();
    drawStars(rect.width, rect.height);
    drawSun(cx,cy);

    // bold orbit lines
    drawOrbit(cx,cy,pxPerAU, Earth);
    drawOrbit(cx,cy,pxPerAU, Mars);

    // locked vectors + triangle chords to create your “3-point petal geometry”
    drawLockedVectors(cx,cy, lockedEarth);
    drawTriangleChords(lockedEarth);
    drawAnchorMarks(lockedEarth);

    drawLockedVectors(cx,cy, lockedMars);
    drawTriangleChords(lockedMars);
    drawAnchorMarks(lockedMars);

    // moving line + planet dots
    if (phase==="idle"){
      const P0 = orbitPoint(cx,cy,pxPerAU, Earth, 0);
      drawRadial(cx,cy,P0,0.55,2);
      drawPlanetDot(P0, Earth);
    } else if (phase==="earth"){
      const PE = orbitPoint(cx,cy,pxPerAU, Earth, thetaE);
      drawRadial(cx,cy,PE,0.70,2.5); // moving line that will “touch” anchors
      drawPlanetDot(PE, Earth);
    } else if (phase==="mars"){
      const PE0 = orbitPoint(cx,cy,pxPerAU, Earth, 0);
      drawPlanetDot(PE0, Earth);
      const PM = orbitPoint(cx,cy,pxPerAU, Mars, thetaM);
      drawRadial(cx,cy,PM,0.70,2.5);
      drawPlanetDot(PM, Mars);
    } else {
      const PE0 = orbitPoint(cx,cy,pxPerAU, Earth, 0);
      const PM0 = orbitPoint(cx,cy,pxPerAU, Mars, 0);
      drawPlanetDot(PE0, Earth);
      drawPlanetDot(PM0, Mars);

      // show the best alignment line
      const R = alignmentReport();
      if (R){
        const ang = R.e.theta;
        const P = { x: cx + Math.cos(ang)*(Mars.a_AU*pxPerAU*1.02), y: cy + Math.sin(ang)*(Mars.a_AU*pxPerAU*1.02) };
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.6)";
        ctx.lineWidth=2.5;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(P.x,P.y); ctx.stroke();
        ctx.restore();
      }
    }

    ctx.restore();

    updateUI();
    requestAnimationFrame(tick);
  }

  // ---------- Controls ----------
  startBtn.addEventListener("click", () => {
    if (!running){
      running=true; paused=false;
      phase="earth";
      thetaE=0; thetaM=0;
      lockedEarth.length=0; lockedMars.length=0;
      markedE.clear(); markedM.clear();
      logEl.value="";
      logLine("Starting Earth sweep: moving line will lock Peri / Quad / Aph.");
      setTags();
    } else {
      paused=false;
      logLine("Resumed.");
      setTags();
    }
  });

  pauseBtn.addEventListener("click", () => {
    if (!running) return;
    paused = !paused;
    logLine(paused ? "Paused." : "Resumed.");
    setTags();
  });

  resetBtn.addEventListener("click", reset);

  printBtn.addEventListener("click", () => window.print());

  // ---------- Init ----------
  resize();
  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
