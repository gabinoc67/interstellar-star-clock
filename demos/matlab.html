<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>CST–Warp Engine Simulator (HTML/JS Single File)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    color-scheme: dark;
  }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: radial-gradient(circle at top, #0f172a 0, #020617 55%, #000 100%);
    color: #e5f0ff;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #viewport {
    flex: 1.1;
    display: flex;
    align-items: stretch;
    justify-content: center;
    position: relative;
  }
  #canvas {
    width: 100%;
    height: 100%;
    display: block;
    background: radial-gradient(circle at center, #020617 0, #020617 40%, #000 100%);
  }
  #ui {
    width: 320px;
    max-width: 340px;
    padding: 14px 16px;
    background: linear-gradient(180deg, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
    border-left: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: 0 0 40px rgba(15,23,42,0.9);
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  h1 {
    font-size: 16px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #7dd3fc;
    margin: 0 0 4px;
  }
  .subtitle {
    font-size: 11px;
    color: #9ca3af;
    text-transform: uppercase;
    letter-spacing: 0.16em;
  }
  hr {
    border: none;
    border-top: 1px solid rgba(148,163,184,0.35);
    margin: 4px 0 8px;
  }
  .group-title {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: #9ca3af;
    margin-bottom: 4px;
  }
  .control-block {
    margin-bottom: 4px;
  }
  label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    margin-bottom: 2px;
    color: #e5e7eb;
  }
  label span.value {
    font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
    color: #a5b4fc;
    margin-left: 6px;
    min-width: 36px;
    text-align: right;
    font-size: 11px;
  }
  input[type="range"] {
    width: 100%;
    accent-color: #38bdf8;
  }
  button {
    width: 49%;
    border-radius: 999px;
    border: 1px solid rgba(148,163,184,0.5);
    padding: 6px 0;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    cursor: pointer;
    background: radial-gradient(circle at top, #0ea5e9 0, #0369a1 40%, #0b1120 100%);
    color: #e5f0ff;
  }
  button.stop {
    background: radial-gradient(circle at top, #f97373 0, #b91c1c 45%, #111827 100%);
  }
  button:active {
    transform: translateY(1px);
  }
  .row {
    display: flex;
    justify-content: space-between;
    gap: 4px;
  }
  .status {
    font-size: 11px;
    padding: 6px 8px;
    border-radius: 10px;
    background: rgba(15,23,42,0.9);
    border: 1px solid rgba(56,189,248,0.6);
    color: #7dd3fc;
    min-height: 32px;
  }
  .mini-metrics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
    font-size: 11px;
  }
  .metric {
    padding: 4px 6px;
    border-radius: 8px;
    background: rgba(15,23,42,0.8);
    border: 1px solid rgba(55,65,81,0.8);
  }
  .metric .label {
    color: #9ca3af;
    font-size: 10px;
    margin-bottom: 2px;
  }
  .metric .value {
    font-family: "JetBrains Mono","Cascadia Code",Consolas,monospace;
    color: #e5e7eb;
  }
</style>
</head>
<body>
  <div id="viewport">
    <canvas id="canvas"></canvas>
  </div>
  <aside id="ui">
    <div>
      <h1>CST–Warp Engine</h1>
      <div class="subtitle">Technical + NX Hybrid • Browser Simulator</div>
      <hr />
    </div>

    <div>
      <div class="group-title">Engine Controls</div>
      <div class="control-block">
        <label>Warp Factor <span class="value" id="warpVal">1.0</span></label>
        <input type="range" id="warp" min="1" max="10" step="0.1" value="1" />
      </div>
      <div class="control-block">
        <label>CST Phase φ <span class="value" id="phiVal">0.00</span></label>
        <input type="range" id="phi" min="0" max="6.283" step="0.01" value="0" />
      </div>
      <div class="control-block">
        <label>m ↔ E Converter <span class="value" id="convVal">0.20</span></label>
        <input type="range" id="conv" min="0" max="1" step="0.01" value="0.2" />
      </div>
    </div>

    <div>
      <div class="group-title">Reactor</div>
      <div class="row">
        <button id="startBtn">Start</button>
        <button id="stopBtn" class="stop">Stop</button>
      </div>
    </div>

    <div>
      <div class="group-title">Status</div>
      <div class="status" id="statusText">
        ENGINE IDLE — Adjust controls and press START.
      </div>
    </div>

    <!-- NEW: Slider Explanation Panel -->
    <div>
      <div class="group-title">Slider Explanation</div>
      <div class="status" id="explainText">
        Adjust Warp, CST Phase φ, and m ↔ E to see how the field and CST clocks respond.
      </div>
    </div>

    <div>
      <div class="group-title">CST Warp Metrics (Approx)</div>
      <div class="mini-metrics">
        <div class="metric">
          <div class="label">Warp Power W</div>
          <div class="value" id="metricW">0.0</div>
        </div>
        <div class="metric">
          <div class="label">Curvature K</div>
          <div class="value" id="metricK">0.0</div>
        </div>
        <div class="metric">
          <div class="label">dK/dr</div>
          <div class="value" id="metricGrad">0.0</div>
        </div>
        <div class="metric">
          <div class="label">Core Temp T</div>
          <div class="value" id="metricT">0 K</div>
        </div>
      </div>
    </div>

    <!-- NEW: Reactor Power Metrics -->
    <div>
      <div class="group-title">Reactor Power</div>
      <div class="mini-metrics">
        <div class="metric">
          <div class="label">Nuclear Power Pₙ</div>
          <div class="value" id="metricPn">0.0</div>
        </div>
        <div class="metric">
          <div class="label">Fusion Power P_f</div>
          <div class="value" id="metricPf">0.0</div>
        </div>
      </div>
    </div>

    <!-- NEW: CST Time Clocks Panel -->
    <div>
      <div class="group-title">CST Time Clocks</div>
      <div class="mini-metrics">
        <div class="metric">
          <div class="label">Earth Clock tₑ</div>
          <div class="value" id="clockEarth">0.0 s</div>
        </div>
        <div class="metric">
          <div class="label">CST Clock t_CST</div>
          <div class="value" id="clockCST">0.0 s</div>
        </div>
        <div class="metric">
          <div class="label">Ship Clock τ</div>
          <div class="value" id="clockShip">0.0 s</div>
        </div>
        <div class="metric">
          <div class="label">Δt (CST−Earth)</div>
          <div class="value" id="clockDrift">0.0 s</div>
        </div>
      </div>
    </div>
  </aside>

<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Controls
  const warpSlider = document.getElementById('warp');
  const phiSlider = document.getElementById('phi');
  const convSlider = document.getElementById('conv');
  const warpVal = document.getElementById('warpVal');
  const phiVal = document.getElementById('phiVal');
  const convVal = document.getElementById('convVal');
  const statusText = document.getElementById('statusText');
  const explainText = document.getElementById('explainText');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');

  const metricW = document.getElementById('metricW');
  const metricK = document.getElementById('metricK');
  const metricGrad = document.getElementById('metricGrad');
  const metricT = document.getElementById('metricT');

  const metricPn = document.getElementById('metricPn');
  const metricPf = document.getElementById('metricPf');

  const clockEarth = document.getElementById('clockEarth');
  const clockCST  = document.getElementById('clockCST');
  const clockShip = document.getElementById('clockShip');
  const clockDrift = document.getElementById('clockDrift');

  let running = false;
  startBtn.onclick = () => {
    running = true;
    statusText.textContent = 'ENGINE RUNNING — Warp field stabilizing...';
  };
  stopBtn.onclick = () => {
    running = false;
    statusText.textContent = 'ENGINE STOPPED — Containment nominal.';
  };

  // Simple "physics" like the Level 1 MATLAB version
  function warpFieldEquations(warp, phi, ce) {
    const W  = Math.pow(warp, 1.3);
    const K  = 0.5 + 0.4 * Math.cos(phi);
    const dKdr = 0.1 * warp;
    const B  = 1 + 0.05 * warp;
    const phiDot = 0.02 + 0.005 * warp;
    const mE = 0.5 + 0.5 * ce;
    const T  = 100 + 10 * warp;

    // Effective velocity and CST timing (for clocks)
    const vEff = Math.min(0.92, 0.06 * warp);         // v/c effective
    const gamma = 1 / Math.sqrt(1 - vEff * vEff);    // relativistic factor
    const cstRate = 1 + 0.02 * warp * ce;            // CST clock rate vs Earth

    return { W, K, dKdr, B, phiDot, mE, T, vEff, gamma, cstRate };
  }

  // Particle system for heavy downward exhaust
  const maxParticles = 220;
  const particles = [];
  function spawnParticle(side, warp) {
    const sx = side === 'L' ? -0.5 : 0.5;
    const baseY = 0.25;
    particles.push({
      x: sx + (Math.random() - 0.5) * 0.2,
      y: baseY + (Math.random() - 0.5) * 0.05,
      vy: 0.008 + warp * 0.004 + Math.random() * 0.004,
      life: 1,
      side
    });
    if (particles.length > maxParticles) particles.shift();
  }

  // CST time clocks (simulation time, stable)
  let earthTime = 0;  // baseline seconds
  let cstTime   = 0;  // CST-synchronized time
  let shipTime  = 0;  // proper time onboard
  const baseDt  = 0.05; // "seconds" per frame for Earth

  function formatSeconds(t) {
    return t.toFixed(1) + ' s';
  }

  function updateExplanation(w, phi, ce, P) {
    const cosPhi = Math.cos(phi);
    const sinPhi = Math.sin(phi);

    let warpText;
    if (w < 2) {
      warpText = 'low-warp regime (field barely compressed, gentle exhaust).';
    } else if (w < 5) {
      warpText = 'mid-warp regime — bubble brightens and curvature gradient increases.';
    } else if (w < 8) {
      warpText = 'high-warp regime — strong curvature gradients, heavy downward exhaust.';
    } else {
      warpText = 'extreme-warp regime — CST field highly compressed, reactor load intense.';
    }

    let phiText;
    if (Math.abs(cosPhi) > Math.abs(sinPhi)) {
      phiText = 'Most energy sits in the “material channel” (cos φ), stabilizing synthetic mass.';
    } else {
      phiText = 'Most energy sits in the “field / radiation channel” (sin φ), strengthening the warp bubble.';
    }

    let convText;
    if (ce < 0.3) {
      convText = 'The m ↔ E converter is throttled low — nuclear power stays mostly as rest mass.';
    } else if (ce < 0.7) {
      convText = 'The converter balances mass storage and energy release, keeping CST clocks near Earth time.';
    } else {
      convText = 'The converter is near maximum — mass is aggressively converted to field energy, CST time runs faster while ship proper time slows.';
    }

    explainText.textContent =
      'Warp slider: ' + warpText + ' ' +
      'CST Phase φ: ' + phiText + ' ' +
      'm ↔ E slider: ' + convText;
  }

  let t = 0;
  function loop() {
    requestAnimationFrame(loop);

    const w = parseFloat(warpSlider.value);
    const phi = parseFloat(phiSlider.value);
    const ce = parseFloat(convSlider.value);

    warpVal.textContent = w.toFixed(1);
    phiVal.textContent = phi.toFixed(2);
    convVal.textContent = ce.toFixed(2);

    const P = warpFieldEquations(w, phi, ce);

    metricW.textContent = P.W.toFixed(2);
    metricK.textContent = P.K.toFixed(3);
    metricGrad.textContent = P.dKdr.toFixed(3);
    metricT.textContent = P.T.toFixed(0) + ' K';

    // Nuclear & Fusion power (change with sliders)
    const Pnuc = 100 + 40 * w;                 // arbitrary nuclear power units
    const Pfus = Pnuc * P.mE * (1.0 + ce);     // fusion output scales with converter & mass-energy factor
    metricPn.textContent = Pnuc.toFixed(1);
    metricPf.textContent = Pfus.toFixed(1);

    // Update CST time clocks (stable, always advancing)
    earthTime += baseDt;
    cstTime   += baseDt * P.cstRate;
    shipTime  += baseDt / P.gamma;

    clockEarth.textContent = formatSeconds(earthTime);
    clockCST.textContent   = formatSeconds(cstTime);
    clockShip.textContent  = formatSeconds(shipTime);
    clockDrift.textContent = formatSeconds(cstTime - earthTime);

    // Update slider explanation text
    updateExplanation(w, phi, ce, P);

    if (running) {
      phiSlider.value = (phi + P.phiDot) % (2 * Math.PI);
    }

    const cw = canvas.width;
    const ch = canvas.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cw,ch);

    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,cw,ch);
    const grad = ctx.createRadialGradient(cw*0.5,ch*0.45,10,cw*0.5,ch*0.45,ch*0.9);
    grad.addColorStop(0,"#020617");
    grad.addColorStop(1,"#000000");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,cw,ch);

    ctx.save();
    const scale = Math.min(cw, ch) / 900;
    ctx.translate(cw*0.5, ch*0.5);
    ctx.scale(scale, scale);

    // Draw stars
    ctx.save();
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = "#ffffff";
    for (let i = 0; i < 40; i++) {
      const sx = (Math.random()*2-1)*600;
      const sy = (Math.random()*2-1)*400;
      ctx.fillRect(sx, sy, 1, 1);
    }
    ctx.restore();

    // Warp bubble
    const bubbleR = 360 + P.B * 10;
    ctx.save();
    ctx.beginPath();
    const bubbleGrad = ctx.createRadialGradient(0,0,bubbleR*0.1,0,0,bubbleR);
    const bright = 0.1 + 0.03*w;
    bubbleGrad.addColorStop(0, `rgba(56,189,248,${bright})`);
    bubbleGrad.addColorStop(0.5, 'rgba(56,189,248,0.12)');
    bubbleGrad.addColorStop(1, 'rgba(15,23,42,0)');
    ctx.fillStyle = bubbleGrad;
    ctx.arc(0,0,bubbleR,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Positive/Negative curvature hull
    ctx.save();
    ctx.strokeStyle = "rgba(148,163,184,0.7)";
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(-260,-60);
    ctx.bezierCurveTo(-140,-110,140,-110,260,-60);
    ctx.lineTo(260, 60);
    ctx.bezierCurveTo(140,110,-140,110,-260,60);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    function roundedRect(x,y,w,h,r,fill,stroke,alpha) {
      ctx.save();
      ctx.globalAlpha = alpha ?? 1;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.lineTo(x+w-r,y);
      ctx.quadraticCurveTo(x+w,y,x+w,y+r);
      ctx.lineTo(x+w,y+h-r);
      ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
      ctx.lineTo(x+r,y+h);
      ctx.quadraticCurveTo(x,y+h,x,y+h-r);
      ctx.lineTo(x,y+r);
      ctx.quadraticCurveTo(x,y,x+r,y);
      ctx.closePath();
      ctx.fillStyle = fill;
      if (stroke) ctx.strokeStyle = stroke;
      ctx.fill();
      if (stroke) ctx.stroke();
      ctx.restore();
    }

    // Nuclear reactor (bottom)
    roundedRect(-55, 80, 110, 60, 12, "rgba(250,204,21,0.12)", "rgba(250,204,21,0.7)", 0.9);
    ctx.fillStyle = "rgba(250,204,21,0.9)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("Nuclear Reactor", 0, 120);

    // Fusion chamber (top)
    roundedRect(-45, -140, 90, 55, 12, "rgba(248,113,113,0.18)", "rgba(248,113,113,0.8)", 0.9);
    ctx.fillStyle = "rgba(248,250,252,0.9)";
    ctx.fillText("Fusion", 0, -118);

    // Mass–Energy converter
    const convGlow = 0.2 + 0.6 * P.mE;
    roundedRect(-45, -35, 90, 70, 16,
      `rgba(196,181,253,${0.18+0.4*convGlow})`,
      "rgba(196,181,253,0.8)",
      0.95
    );
    ctx.fillStyle = "rgba(224,231,255,0.9)";
    ctx.fillText("m ↔ E", 0, -5);

    // Synthetic mass bank (circle)
    ctx.save();
    ctx.globalAlpha = 0.6;
    const massR = 34 + 6*Math.sin(t*0.003 + phi);
    const gradMass = ctx.createRadialGradient(0, -55, 4, 0, -55, massR);
    gradMass.addColorStop(0, "rgba(196,181,253,1)");
    gradMass.addColorStop(1, "rgba(79,70,229,0)");
    ctx.fillStyle = gradMass;
    ctx.beginPath();
    ctx.arc(0,-55,massR,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.fillStyle = "rgba(191,219,254,0.9)";
    ctx.fillText("Synthetic Mass Bank", 0, -72);

    // Main core column
    ctx.save();
    const coreHeight = 190;
    const coreWidth = 40;
    const coreGlow = 0.35 + 0.25*Math.sin(t*0.002 + phi*1.2) + 0.05*w;
    const coreGrad = ctx.createLinearGradient(0,-coreHeight/2,0,coreHeight/2);
    coreGrad.addColorStop(0, `rgba(59,130,246,${0.2+coreGlow})`);
    coreGrad.addColorStop(0.5, `rgba(56,189,248,${0.4+coreGlow})`);
    coreGrad.addColorStop(1, `rgba(59,130,246,${0.2+coreGlow})`);
    roundedRect(-coreWidth/2,-coreHeight/2,coreWidth,coreHeight,18,coreGrad,"rgba(191,219,254,0.3)",0.95);
    ctx.restore();

    // Warp coils (rings)
    ctx.save();
    ctx.strokeStyle = "rgba(45,212,191,0.8)";
    ctx.lineWidth = 2;
    const coilLevels = [-70,-35,0,35,70];
    const baseRadius = 70;
    const phase = phi;
    for (let i = 0; i < coilLevels.length; i++) {
      const y = coilLevels[i];
      const r = baseRadius + 4*Math.sin(phase + i*0.7 + t*0.004 + w*0.2);
      ctx.beginPath();
      ctx.ellipse(0,y,r,r*0.38,0,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();

    // NX nacelles
    ctx.save();
    const osc = 8 * Math.sin(t*0.003*w + phi);
    const nacelleOffsetY = 110;
    const nacelleLength = 260;
    const nacelleHeight = 32;
    const nacelleX = 170;

    function drawNacelle(side) {
      const sgn = side === 'L' ? -1 : 1;
      const yShift = side === 'L' ? (nacelleOffsetY + osc) : (nacelleOffsetY - osc);

      // Hull
      ctx.save();
      ctx.translate(sgn*nacelleX, yShift);
      ctx.beginPath();
      ctx.moveTo(-nacelleLength/2, -nacelleHeight/2);
      ctx.quadraticCurveTo(nacelleLength/2, -nacelleHeight/2, nacelleLength/2, 0);
      ctx.quadraticCurveTo(nacelleLength/2, nacelleHeight/2, -nacelleLength/2, nacelleHeight/2);
      ctx.quadraticCurveTo(-nacelleLength/2-35, 0, -nacelleLength/2, -nacelleHeight/2);
      const hullGrad = ctx.createLinearGradient(-nacelleLength/2,0,nacelleLength/2,0);
      hullGrad.addColorStop(0,"rgba(148,163,184,0.12)");
      hullGrad.addColorStop(0.5,"rgba(209,213,219,0.4)");
      hullGrad.addColorStop(1,"rgba(148,163,184,0.12)");
      ctx.fillStyle = hullGrad;
      ctx.strokeStyle = "rgba(148,163,184,0.8)";
      ctx.fill();
      ctx.stroke();

      // Coil segments
      ctx.strokeStyle = "rgba(56,189,248,0.9)";
      ctx.lineWidth = 1.4;
      const segments = 8;
      for (let i=0;i<=segments;i++) {
        const x = -nacelleLength/2 + (nacelleLength/segments)*i;
        const pulse = 1 + 0.6*Math.sin(t*0.006 + i*0.7 + w*0.5);
        ctx.beginPath();
        ctx.moveTo(x, -nacelleHeight*0.45 * pulse);
        ctx.lineTo(x,  nacelleHeight*0.45 * pulse);
        ctx.stroke();
      }

      // Bussard collector
      const noseR = nacelleHeight*0.7;
      const noseGrad = ctx.createRadialGradient(nacelleLength/2,0,4,nacelleLength/2,0,noseR);
      const noseBright = 0.2 + 0.08*w;
      noseGrad.addColorStop(0,`rgba(251,191,36,${0.7+noseBright})`);
      noseGrad.addColorStop(1,"rgba(251,191,36,0)");
      ctx.fillStyle = noseGrad;
      ctx.beginPath();
      ctx.arc(nacelleLength/2,0,noseR,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    drawNacelle('L');
    drawNacelle('R');
    ctx.restore();

    // Heavy high-energy exhaust (downward)
    if (running) {
      for (let i = 0; i < 8*w; i++) {
        spawnParticle('L', w);
        spawnParticle('R', w);
      }
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.y += p.vy;
      p.life -= 0.01 + 0.004*w;
      if (p.life <= 0 || p.y > 1.2) {
        particles.splice(i,1);
        continue;
      }
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life);
      const px = p.x * 380;
      const py = p.y * 300;
      const particleSize = 4 + 2 * w * p.life;
      const cGrad = ctx.createRadialGradient(px,py,0,px,py,particleSize);
      cGrad.addColorStop(0,"rgba(248,250,252,1)");
      cGrad.addColorStop(0.4,"rgba(248,250,252,0.7)");
      cGrad.addColorStop(1,"rgba(148,163,184,0)");
      ctx.fillStyle = cGrad;
      ctx.beginPath();
      ctx.arc(px,py,particleSize,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // ===== NEW: TITLE + LABELS WITH LINES =====
    function labelWithLine(text, xText, yText, xAnchor, yAnchor) {
      ctx.save();
      ctx.strokeStyle = "rgba(148,163,184,0.9)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(xText, yText);
      ctx.lineTo(xAnchor, yAnchor);
      ctx.stroke();

      ctx.fillStyle = "rgba(226,232,240,0.96)";
      ctx.font = "11px system-ui";
      ctx.textAlign = (xText < xAnchor) ? "left" : "right";
      ctx.fillText(text, xText, yText - 4);
      ctx.restore();
    }

    // Diagram title
    ctx.save();
    ctx.fillStyle = "rgba(125,211,252,0.95)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("CST–Warp Engine Field Layout (Nuclear + Fusion + CST Time)", 0, -260);
    ctx.restore();

    // Approximate anchor points (engine space)
    // Nuclear Reactor center ~ (0,110)
    labelWithLine("Nuclear Reactor (E = mc² power source)", -320, 150, 0, 110);
    // Fusion chamber center ~ (0,-120)
    labelWithLine("Fusion Chamber (plasma gain stage)", -320, -150, 0, -120);
    // m <-> E converter center ~ (0,0)
    labelWithLine("m ↔ E Converter (mass–energy loop)", 320, -20, 0, 0);
    // Synthetic mass bank ~ (0,-55)
    labelWithLine("Synthetic Mass Bank (Φ_mass)", 320, -80, 0, -55);
    // Warp coils stack
    labelWithLine("Warp Coils / CST Rings", -320, -200, 0, -40);
    // Left nacelle
    labelWithLine("Left NX Warp Nacelle", -320, 60, -nacelleX, nacelleOffsetY + osc);
    // Right nacelle
    labelWithLine("Right NX Warp Nacelle", 320, 60, nacelleX, nacelleOffsetY - osc);
    // Exhaust
    labelWithLine("Downward Exhaust (warp plasma stream)", 0, 250, 0, 190);
    // Curvature hull
    labelWithLine("Positive / Negative Curvature Hull", 0, -230, 0, -100);
    // Warp bubble
    labelWithLine("CST Warp Bubble (shield + field envelope)", 320, -230, bubbleR * 0.6, -40);

    ctx.restore();
    t += running ? 16 : 10;
  }

  loop();
})();
</script>
</body>
</html>
