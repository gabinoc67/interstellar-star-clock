<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Supernova CST–Astronomy Observation Simulator (Full + Light Curve + Time Dilation)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f5f7fb;margin:0;color:#111;}
  header{background:#0b3d91;color:#fff;padding:18px;}
  main{display:grid;grid-template-columns:460px 1fr;gap:16px;padding:16px;}
  .panel{background:#fff;border-radius:10px;padding:14px;box-shadow:0 4px 12px rgba(0,0,0,0.08);}
  .panel h3{margin-top:0;color:#0b3d91;}
  label{display:block;font-size:13px;margin-top:8px;}
  input,select,button{width:100%;padding:6px;margin-top:4px;box-sizing:border-box;}
  button{background:#0b3d91;color:#fff;border:none;border-radius:6px;cursor:pointer;margin-top:8px;}
  button:hover{background:#092f70;}
  canvas{background:#000;border-radius:10px;}
  .readout{font-family:monospace;font-size:12px;white-space:pre-line;margin-top:8px;}
  .eq{font-family:monospace;background:#eef2ff;padding:6px;border-radius:6px;margin:6px 0;font-size:12px;}
  .explain{font-size:13px;line-height:1.45;}
  .clock{background:#000;color:#0f0;padding:6px;border-radius:6px;margin-top:6px;font-family:monospace;font-size:12px;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .small{font-size:12px;color:#333;margin-top:6px;}
  .toggle{display:flex;align-items:center;gap:8px;margin-top:8px;font-size:13px;}
  .toggle input{width:auto;margin:0;}
  .warn{background:#fff3cd;border:1px solid #ffe69c;padding:8px;border-radius:8px;margin-top:10px;font-size:12px;line-height:1.35;}
  .info{background:#e7f1ff;border:1px solid #b6d4fe;padding:8px;border-radius:8px;margin-top:10px;font-size:12px;line-height:1.35;}
  .divider{height:1px;background:#e6e6e6;margin:10px 0;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b3d91;color:#fff;font-size:11px;margin-left:6px;}
  .muted{color:#555;}
</style>
</head>
<body>
<header>
  <h2>Supernova Light Detection Simulator (Astronomy + CST)</h2>
  <div>Heliocentric geometry · Earth observer location · φ-tomography · CST synchronization · Light-curve markers · (1+z) time stretch · Dark Energy model</div>
</header>

<main>
  <div class="panel">
    <h3>What this Simulation Does</h3>
    <div class="explain">
      This simulator models how light from a distant supernova is detected on Earth, explicitly showing:
      <ul>
        <li>The Sun-centered (heliocentric) geometry</li>
        <li>The Earth’s orbital position around the Sun</li>
        <li>The observer’s latitude and longitude on Earth</li>
        <li>A photon traveling from the supernova to Earth (visual animation)</li>
        <li>How redshift, distance, H<sub>eff</sub>, φ, and CST-adjusted φ are computed</li>
        <li>Light-curve timing markers and cosmological time dilation: Δt<sub>obs</sub> = (1+z)·Δt<sub>rest</sub></li>
        <li><b>Distance-mode switch</b>: D<sub>L</sub> vs D<sub>C</sub> vs D<sub>A</sub to show how (1+z) packaging bends φ(z)</li>
        <li><b>Dark energy model</b>: turn dark energy on/off and set equation-of-state w</li>
      </ul>
      Note: The “two-marker” feature measures <b>time stretch</b> and light-curve structure, not changes in the speed of light (c is constant).
    </div>

    <h3>Equations Used (Paper-style + CST + Time Dilation + Dark Energy)</h3>
    <div class="eq">Distance modulus:  μ = 5·log10(D<sub>L</sub>/Mpc) + 25  ⇒  D<sub>L</sub> = 10<sup>(μ − 25)/5</sup> Mpc</div>
    <div class="eq"><b>Distance mode switch:</b> D<sub>L</sub> = (1+z)·D<sub>C</sub>  |  D<sub>C</sub> = D<sub>L</sub>/(1+z)  |  D<sub>A</sub> = D<sub>L</sub>/(1+z)<sup>2</sup></div>
    <div class="eq">H<sub>eff</sub>(z) = (c · z) / D<sub>mode</sub>(z)</div>
    <div class="eq">φ(z) = arctan(H<sub>eff</sub> / H<sub>0,ref</sub>)</div>
    <div class="eq">Toy observer redshift:  z<sub>obs</sub> = z + (v<sub>⊕</sub>/c) · cos(lat) · cos(lon)</div>
    <div class="eq">Cosmological time dilation:  Δt<sub>obs</sub> = (1+z)·Δt<sub>rest</sub></div>
    <div class="eq">φ<sub>CST</sub> = φ · CST</div>

    <div class="eq"><b>wCDM expansion history:</b>
      E(z)=H(z)/H<sub>0</sub> = √(Ω<sub>m</sub>(1+z)<sup>3</sup> + Ω<sub>k</sub>(1+z)<sup>2</sup> + Ω<sub>DE</sub>(1+z)<sup>3(1+w)</sup>)
    </div>
    <div class="eq">D<sub>L</sub>=(1+z)·(c/H<sub>0</sub>)·∫<sub>0→z</sub> dz′/E(z′)</div>
    <div class="eq">Lookback:  t<sub>L</sub>=(1/H<sub>0</sub>)·∫<sub>0→z</sub> dz′/((1+z′)E(z′))</div>

    <div class="info">
      <b>What the Distance Mode Toggle Proves (the (1+z) test):</b><br/>
      Switching from D<sub>L</sub> to D<sub>C</sub>=D<sub>L</sub>/(1+z) increases H<sub>eff</sub> by (1+z):<br/>
      <span style="font-family:monospace;">H_eff,DC = (1+z)·H_eff,DL</span><br/>
      So φ(z) lifts upward and the downward bend past z≈0.1 can flatten a lot if the bend was mainly the (1+z) wrapper.
      Dark energy is tested via the remaining shape from E(z) (the integral).
    </div>

    <div class="divider"></div>

    <h3>Observer Location (Earth)</h3>
    <label>Latitude (deg)
      <input id="lat" type="number" value="30" step="0.001" />
    </label>
    <label>Longitude (deg)
      <input id="lon" type="number" value="-97" step="0.001" />
    </label>
    <label>Day of Year (Earth around Sun)
      <input id="day" type="number" value="180" min="1" max="365" />
    </label>

    <h3>CST</h3>
    <label>CST Scale Factor
      <input id="cst" type="number" value="1.00" step="0.01" />
    </label>

    <h3>Supernova Source</h3>
    <label>Galaxy / Redshift
      <select id="galaxy">
        <option value="0.0002" data-preset="sn1987a">SN 1987A (LMC, local; use preset distance)</option>
        <option value="0.01">Local Group (z ≈ 0.01)</option>
        <option value="0.05" selected>Virgo Cluster (z ≈ 0.05)</option>
        <option value="0.10">Great Attractor (z ≈ 0.10)</option>
        <option value="0.50">Deep Field SN (z ≈ 0.50)</option>
        <option value="1.00">Early Universe SN (z ≈ 1.0)</option>
      </select>
    </label>

    <div class="toggle">
      <input id="useSN1987A" type="checkbox" />
      <label for="useSN1987A" style="margin:0;">Use SN 1987A distance preset (D ≈ 0.0514 Mpc) + core-collapse template</label>
    </div>
    <div class="small muted">
      SN 1987A is nearby (Large Magellanic Cloud), so cosmology distances are not appropriate; this preset uses a local distance calibration.
    </div>

    <h3>Light-Curve Template (for Markers)</h3>
    <label>Supernova Type
      <select id="snType">
        <option value="Ia" selected>Type Ia (thermonuclear)</option>
        <option value="CC">Core-Collapse (massive star)</option>
      </select>
    </label>

    <div class="row">
      <div>
        <label>Marker A (event)
          <select id="markA">
            <option value="first" selected>First light (model)</option>
            <option value="peak">Peak brightness</option>
            <option value="p15">+15 days after peak</option>
            <option value="sec">Secondary maximum (template)</option>
          </select>
        </label>
      </div>
      <div>
        <label>Marker B (event)
          <select id="markB">
            <option value="first">First light (model)</option>
            <option value="peak" selected>Peak brightness</option>
            <option value="p15">+15 days after peak</option>
            <option value="sec">Secondary maximum (template)</option>
          </select>
        </label>
      </div>
    </div>

    <label>Stretch / Timescale (s)
      <input id="stretch" type="number" value="1.00" step="0.01" />
    </label>
    <div class="small">s scales rest-frame timing: t → s·t. (For Ia, “stretch” is a common way to represent slower/faster light curves.)</div>

    <h3>Distance Module</h3>
    <label>Distance Mode (shows how (1+z) packaging changes φ-curvature)
      <select id="distMode">
        <option value="DL" selected>Luminosity distance D_L (standard)</option>
        <option value="DC">Comoving distance D_C = D_L/(1+z) (remove (1+z))</option>
        <option value="DA">Angular diameter distance D_A = D_L/(1+z)^2</option>
      </select>
    </label>

    <div class="toggle">
      <input id="useCosmo" type="checkbox" checked />
      <label for="useCosmo" style="margin:0;">Use cosmology distance calculator (recommended for distant SNe)</label>
    </div>

    <div class="row">
      <div>
        <label>H<sub>0</sub> (km/s/Mpc)
          <input id="H0in" type="number" value="70" step="0.1" />
        </label>
      </div>
      <div>
        <label>Ω<sub>m</sub>
          <input id="Om" type="number" value="0.3" step="0.01" />
        </label>
      </div>
    </div>

    <div class="toggle">
      <input id="forceFlat" type="checkbox" checked />
      <label for="forceFlat" style="margin:0;">Force flat universe (Ω<sub>k</sub>=0)</label>
    </div>

    <h3>Dark Energy (Add to Simulation)</h3>
    <div class="toggle">
      <input id="useDE" type="checkbox" checked />
      <label for="useDE" style="margin:0;">Enable Dark Energy term Ω<sub>DE</sub> <span class="pill">ON</span></label>
    </div>

    <label>Equation of state w (ΛCDM is w = −1)
      <input id="wde" type="number" value="-1.00" step="0.01" />
    </label>

    <div class="info" id="deInfo">
      With dark energy ON and flatness ON: Ω<sub>DE</sub> = 1 − Ω<sub>m</sub>.<br/>
      With dark energy OFF: Ω<sub>DE</sub>=0 (matter/curvature-only expansion).<br/>
      If flatness is OFF, Ω<sub>k</sub> is computed so Ω<sub>m</sub>+Ω<sub>DE</sub>+Ω<sub>k</sub>=1.
    </div>

    <div class="toggle">
      <input id="showLC" type="checkbox" checked />
      <label for="showLC" style="margin:0;">Show Light Curve Panel</label>
    </div>

    <button onclick="generateSN()">Generate Supernova & Photon</button>
    <button onclick="resetSim()">Reset</button>

    <h3>Live Clocks</h3>
    <div class="clock" id="utcClock"></div>
    <div class="clock" id="cstClock"></div>
    <div class="clock" id="travelClock"></div>
    <div class="clock" id="arrivalClock"></div>

    <div class="warn">
      <b>Important:</b> For cosmological distances, “arrival date” in calendar form can exceed JavaScript date limits.
      This simulator therefore reports travel times in <b>years</b> while the animation is a visualization.
    </div>

    <div class="info">
      <b>Dark Energy in this simulator:</b><br/>
      You are not just “turning a label on.” You are changing E(z), which changes the distance integral, which changes D<sub>L</sub>(z),
      which then changes H<sub>eff</sub>(z) and φ(z). This is the clean way to represent “dark energy added.”
    </div>
  </div>

  <div class="panel">
    <h3>Heliocentric Geometry & Photon Propagation</h3>
    <canvas id="sky" width="900" height="420"></canvas>
    <div class="readout" id="output"></div>

    <div id="lcWrap">
      <h3 style="margin-top:14px;">Light Curve (Template) + Two Markers</h3>
      <canvas id="lc" width="900" height="220"></canvas>
      <div class="readout" id="lcOut"></div>
    </div>
  </div>
</main>

<script>
/* =========================
   Constants & Utilities
========================= */
const c_km_s = 299792;           // km/s
const Mpc_km = 3.085677581e19;   // km
const sec_per_year = 365.25*24*3600;

const canvas = document.getElementById('sky');
const ctx = canvas.getContext('2d');

const lcCanvas = document.getElementById('lc');
const lcCtx = lcCanvas.getContext('2d');

let photonProgress = 0;
let anim = null;
let travelSeconds = 0;

function deg2rad(d){ return d*Math.PI/180; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function earthOrbitalVelocity(day){
  return 29.8 * Math.cos(2*Math.PI*(day/365));
}

/* =========================
   Distance Mode Helpers
========================= */
function distanceModeFromDl(DL_Mpc, z, mode){
  if(mode === "DL") return DL_Mpc;
  if(mode === "DC") return DL_Mpc / (1 + z);
  if(mode === "DA") return DL_Mpc / ((1 + z)**2);
  return DL_Mpc;
}
function Heff_from_distance(c_km_s, z, D_Mpc){
  return (D_Mpc > 0) ? (c_km_s * z) / D_Mpc : 0;
}
function phiDeg(HeffVal, H0ref){
  return Math.atan(HeffVal / H0ref) * (180 / Math.PI);
}

/* =========================
   Cosmology Calculator
   wCDM with curvature option
========================= */
function E_z(z, Om, Ode, Ok, w){
  const zp1 = 1 + z;
  const matter = Om * Math.pow(zp1, 3);
  const curv   = Ok * Math.pow(zp1, 2);
  const de     = Ode * Math.pow(zp1, 3*(1+w)); // w=-1 => constant
  return Math.sqrt(Math.max(0, matter + curv + de));
}

function simpsonIntegral(f, a, b, n){
  if(n % 2 === 1) n++;
  const h = (b-a)/n;
  let s = f(a) + f(b);
  for(let i=1;i<n;i++){
    const x = a + i*h;
    s += (i%2===0 ? 2 : 4) * f(x);
  }
  return s * (h/3);
}

function lumDist_Mpc_wCDM(z, H0, Om, Ode, Ok, w){
  if(z <= 0) return 0;
  const f = (zp)=> 1 / E_z(zp, Om, Ode, Ok, w);
  const I = simpsonIntegral(f, 0, z, 900);
  const Dc_Mpc = (c_km_s/H0) * I;
  return (1+z) * Dc_Mpc;
}

function lookbackTime_years_wCDM(z, H0, Om, Ode, Ok, w){
  if(z <= 0) return 0;
  const H0_s = H0 / Mpc_km;
  const f = (zp)=> 1 / ((1+zp) * E_z(zp, Om, Ode, Ok, w));
  const I = simpsonIntegral(f, 0, z, 1400);
  const t_sec = I / H0_s;
  return t_sec / sec_per_year;
}

/* =========================
   Light Curve Templates
========================= */
function templateFlux_Ia(t){
  const rise = 1 / (1 + Math.exp(-(t-12)/2.2));
  const decay = Math.exp(-Math.max(0, t-19)/22);
  return rise * decay;
}
function templateFlux_CC(t){
  const rise = 1 / (1 + Math.exp(-(t-7)/1.6));
  const plateau = 1 / (1 + Math.exp((t-60)/6));
  const tail = Math.exp(-Math.max(0, t-80)/45);
  return rise * (0.7*plateau + 0.3*tail);
}
function getTemplateFlux(snType, tRestDays){
  return (snType === "CC") ? templateFlux_CC(tRestDays) : templateFlux_Ia(tRestDays);
}

/* =========================
   Marker Times (rest-frame days)
========================= */
function markerTimeRestDays(snType, marker){
  if(snType === "Ia"){
    if(marker === "first") return 0;
    if(marker === "peak")  return 19;
    if(marker === "p15")   return 34;
    if(marker === "sec")   return 32;
  } else {
    if(marker === "first") return 0;
    if(marker === "peak")  return 10;
    if(marker === "p15")   return 25;
    if(marker === "sec")   return 55;
  }
  return 0;
}
function markerLabel(m){
  if(m==="first") return "First light (model)";
  if(m==="peak")  return "Peak brightness";
  if(m==="p15")   return "+15 days after peak";
  if(m==="sec")   return "Secondary maximum (template)";
  return m;
}

/* =========================
   Clocks
========================= */
function updateClocks(){
  const now = new Date();
  document.getElementById('utcClock').textContent = `UTC now: ${now.toUTCString()}`;
  document.getElementById('cstClock').textContent = `CST (scaled seconds): ${(now.getTime()/1000).toFixed(2)}`;
}
setInterval(updateClocks, 200);

/* =========================
   Main Simulation
========================= */
function generateSN(){
  cancelAnimationFrame(anim);
  photonProgress = 0;

  const lat = +document.getElementById('lat').value;
  const lon = +document.getElementById('lon').value;
  const day = +document.getElementById('day').value;
  const CST = +document.getElementById('cst').value;

  const galSel = document.getElementById('galaxy');
  let z = +galSel.value;

  const snTypeSel = document.getElementById('snType');
  let snType = snTypeSel.value;

  const markA = document.getElementById('markA').value;
  const markB = document.getElementById('markB').value;
  const stretch = Math.max(0.1, +document.getElementById('stretch').value);

  const useCosmo = document.getElementById('useCosmo').checked;
  const H0 = +document.getElementById('H0in').value;
  let Om = +document.getElementById('Om').value;

  const forceFlat = document.getElementById('forceFlat').checked;

  const useDE = document.getElementById('useDE').checked;
  const w = +document.getElementById('wde').value;

  const distMode = document.getElementById('distMode').value;

  // Optional SN 1987A preset
  const useSN1987A = document.getElementById('useSN1987A').checked;

  // Observer correction (toy)
  const vE = earthOrbitalVelocity(day);
  const geo = Math.cos(deg2rad(lat))*Math.cos(deg2rad(lon));
  let zObs = z + (vE/c_km_s)*geo;

  // Build Ω parameters
  let Ode = useDE ? (forceFlat ? (1 - Om) : (1 - Om)) : 0; // initial
  let Ok;

  if(forceFlat){
    if(!useDE){
      // A truly flat universe without DE requires Om=1 (in this toy parameterization)
      Om = 1.0;
    }
    Ode = useDE ? (1 - Om) : 0;
    Ok = 0;
  } else {
    // Allow curvature; enforce closure Ωm+ΩDE+Ωk=1
    Ok = 1 - Om - Ode;
  }

  // Distances
  let DL_Mpc = 0;
  let lookback_years = 0;

  if(useSN1987A){
    DL_Mpc = 0.0514; // 51.4 kpc = 0.0514 Mpc
    z = 0.0002;
    zObs = z + (vE/c_km_s)*geo;
    lookback_years = DL_Mpc * 3.26156e6; // local approx OK
    snType = "CC";
    snTypeSel.value = "CC";
  } else {
    if(useCosmo){
      DL_Mpc = lumDist_Mpc_wCDM(zObs, H0, Om, Ode, Ok, w);
      lookback_years = lookbackTime_years_wCDM(zObs, H0, Om, Ode, Ok, w);
    } else {
      // linear low-z approximation
      DL_Mpc = (c_km_s*zObs)/H0;
      const H0_s = H0 / Mpc_km;
      lookback_years = (zObs / H0_s) / sec_per_year;
    }
  }

  // Apply Distance Mode
  const D_mode_Mpc = distanceModeFromDl(DL_Mpc, zObs, distMode);

  // φ analysis
  const Heff = Heff_from_distance(c_km_s, zObs, D_mode_Mpc);
  const phi = phiDeg(Heff, H0);
  const phiCST = phi * CST;

  // Times
  const naiveTravel_years = DL_Mpc * 3.26156e6;
  travelSeconds = lookback_years * sec_per_year;

  // Light-curve marker time dilation
  const tA_rest = markerTimeRestDays(snType, markA) * stretch;
  const tB_rest = markerTimeRestDays(snType, markB) * stretch;
  const dT_rest = Math.abs(tB_rest - tA_rest);
  const dT_obs = dT_rest * (1 + zObs);
  const tA_obs = tA_rest * (1 + zObs);
  const tB_obs = tB_rest * (1 + zObs);

  // Pretty names
  const snTypeName = (snType === "CC") ? "Core-Collapse" : "Type Ia";
  const distModeName =
    (distMode==="DL") ? "Luminosity distance D_L (standard)" :
    (distMode==="DC") ? "Comoving distance D_C = D_L/(1+z) (remove (1+z))" :
    "Angular diameter distance D_A = D_L/(1+z)^2";

  const cosmoName = useSN1987A ? "SN 1987A preset (local distance; not cosmology)" :
                    (useCosmo ? "wCDM / ΛCDM (integral)" : "Linear low-z approximation");

  // Output
  document.getElementById('output').textContent =
`Supernova source: ${galSel.options[galSel.selectedIndex].text}
SN type: ${snTypeName}
Observer (lat, lon, day): (${lat.toFixed(3)}°, ${lon.toFixed(3)}°, day ${day})

Distance packaging test:
  Distance Mode: ${distModeName}
  D_L (base luminosity distance): ${DL_Mpc.toFixed(6)} Mpc
  D_mode (used in H_eff):         ${D_mode_Mpc.toFixed(6)} Mpc
  If mode=DC, then H_eff increases by (1+z).

Cosmology:
  Mode: ${cosmoName}
  H0 = ${H0.toFixed(2)} km/s/Mpc
  Ωm = ${Om.toFixed(3)}
  Dark Energy enabled: ${useDE ? "YES" : "NO"}
  w = ${w.toFixed(2)}
  ΩDE = ${Ode.toFixed(3)}
  Ωk = ${Ok.toFixed(3)}   (closure: Ωm+ΩDE+Ωk = ${(Om+Ode+Ok).toFixed(3)})

Observed redshift z_obs: ${zObs.toFixed(5)}

Times:
  Lookback / travel time used: ${lookback_years.toExponential(3)} years
  Naive D_L/c travel time:     ${naiveTravel_years.toExponential(3)} years

Paper-style φ (computed from D_mode):
  H_eff = (c z_obs)/D_mode = ${Heff.toFixed(6)} km/s/Mpc
  φ = arctan(H_eff/H0)     = ${phi.toFixed(3)}°
  CST-adjusted φ_CST       = ${phiCST.toFixed(3)}°

Two-marker timing (rest vs observed):
  Marker A: ${markerLabel(markA)} at t_rest = ${tA_rest.toFixed(2)} d  → t_obs = ${tA_obs.toFixed(2)} d
  Marker B: ${markerLabel(markB)} at t_rest = ${tB_rest.toFixed(2)} d  → t_obs = ${tB_obs.toFixed(2)} d
  Δt_rest = ${dT_rest.toFixed(2)} d
  Δt_obs  = (1+z_obs)·Δt_rest = ${(1+zObs).toFixed(5)} · ${dT_rest.toFixed(2)} = ${dT_obs.toFixed(2)} d
`;

  // Light curve
  const showLC = document.getElementById('showLC').checked;
  document.getElementById('lcWrap').style.display = showLC ? "block" : "none";
  if(showLC){
    drawLightCurve(snType, zObs, stretch, markA, markB);
  } else {
    document.getElementById('lcOut').textContent = "";
  }

  animatePhoton(phi);
}

/* =========================
   Light Curve Drawing
========================= */
function drawLightCurve(snType, zObs, stretch, markA, markB){
  const W = lcCanvas.width, H = lcCanvas.height;
  lcCtx.clearRect(0,0,W,H);
  lcCtx.fillStyle = "black";
  lcCtx.fillRect(0,0,W,H);

  const tMin = 0;
  const tMax = (snType==="CC") ? 140*stretch : 80*stretch;

  const L = 50, R = 20, T = 18, B = 34;
  const plotW = W - L - R;
  const plotH = H - T - B;

  const N = 500;
  let maxF = 1e-9;
  const pts = [];
  for(let i=0;i<=N;i++){
    const t = tMin + (tMax-tMin)*(i/N);
    const f = getTemplateFlux(snType, t);
    maxF = Math.max(maxF, f);
    pts.push({t, f});
  }

  lcCtx.strokeStyle = "rgba(255,255,255,0.35)";
  lcCtx.beginPath();
  lcCtx.moveTo(L, T);
  lcCtx.lineTo(L, T+plotH);
  lcCtx.lineTo(L+plotW, T+plotH);
  lcCtx.stroke();

  lcCtx.fillStyle = "white";
  lcCtx.font = "12px Arial";
  lcCtx.fillText("Normalized flux (template)", L, 14);
  lcCtx.fillText("t_rest (days)  →  t_obs = (1+z)·t_rest", L, H-10);

  lcCtx.strokeStyle = "white";
  lcCtx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x = L + (pts[i].t - tMin) / (tMax - tMin) * plotW;
    const y = T + plotH - (pts[i].f / maxF) * plotH;
    if(i===0) lcCtx.moveTo(x,y); else lcCtx.lineTo(x,y);
  }
  lcCtx.stroke();

  function drawMarker(markerKey, label, colorStyle){
    const t0 = markerTimeRestDays(snType, markerKey) * stretch;
    const x = L + (t0 - tMin) / (tMax - tMin) * plotW;
    const f0 = getTemplateFlux(snType, t0);
    const y = T + plotH - (f0 / maxF) * plotH;

    lcCtx.strokeStyle = colorStyle;
    lcCtx.beginPath();
    lcCtx.moveTo(x, T);
    lcCtx.lineTo(x, T+plotH);
    lcCtx.stroke();

    lcCtx.fillStyle = colorStyle;
    lcCtx.beginPath();
    lcCtx.arc(x, y, 4, 0, 2*Math.PI);
    lcCtx.fill();

    lcCtx.fillStyle = "white";
    const tObs = t0 * (1+zObs);
    lcCtx.fillText(`${label}: t_rest=${t0.toFixed(1)}d, t_obs=${tObs.toFixed(1)}d`, clamp(x-120, 60, W-360), clamp(y-10, 18, H-46));
    return t0;
  }

  const tA = drawMarker(markA, "A", "rgba(255,80,80,0.95)");
  const tB = drawMarker(markB, "B", "rgba(80,170,255,0.95)");

  const dT_rest = Math.abs(tB - tA);
  const dT_obs = dT_rest * (1+zObs);

  document.getElementById('lcOut').textContent =
`Light-curve markers (template-driven):
  A = ${markerLabel(markA)}
  B = ${markerLabel(markB)}

Time dilation:
  Δt_rest = ${dT_rest.toFixed(2)} days
  Δt_obs  = (1+z_obs)·Δt_rest = ${(1+zObs).toFixed(5)} · ${dT_rest.toFixed(2)} = ${dT_obs.toFixed(2)} days

Interpretation:
  These two markers do NOT measure changes in c.
  They measure how observed timing stretches with redshift and how the light-curve timescale behaves (via stretch s).`;
}

/* =========================
   Photon Animation
========================= */
function animatePhoton(phi0){
  function frame(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='black'; ctx.fillRect(0,0,canvas.width,canvas.height);

    const sunX=450, sunY=210, orbitR=90;

    // Sun
    ctx.fillStyle='yellow';
    ctx.beginPath(); ctx.arc(sunX,sunY,16,0,2*Math.PI); ctx.fill();
    ctx.fillStyle='white'; ctx.font="12px Arial"; ctx.fillText('Sun',sunX-12,sunY-24);

    // Earth orbit
    ctx.strokeStyle='rgba(255,255,0,0.75)';
    ctx.beginPath(); ctx.arc(sunX,sunY,orbitR,0,2*Math.PI); ctx.stroke();

    // Earth position
    const day = +document.getElementById('day').value;
    const angle = 2*Math.PI*(day/365);
    const earthX = sunX + orbitR*Math.cos(angle);
    const earthY = sunY + orbitR*Math.sin(angle);

    // Earth
    ctx.fillStyle='deepskyblue';
    ctx.beginPath(); ctx.arc(earthX,earthY,8,0,2*Math.PI); ctx.fill();
    ctx.fillStyle='white';
    ctx.fillText('Earth (observer)',earthX-40,earthY+22);

    // Supernova
    const snX = sunX + 320;
    const snY = sunY;
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(snX,snY,7,0,2*Math.PI); ctx.fill();
    ctx.fillText('Supernova',snX-36,snY-14);

    // Photon
    const px = snX + (earthX - snX)*photonProgress;
    const py = snY + (earthY - snY)*photonProgress;

    ctx.fillStyle = (Math.floor(performance.now()/150)%2===0)?'red':'white';
    ctx.beginPath(); ctx.arc(px,py,4,0,2*Math.PI); ctx.fill();

    // Small illustrative jitter of φ
    const phiNow = phi0 + 0.05*Math.sin(photonProgress*20);

    const elapsedYears = (photonProgress*travelSeconds) / sec_per_year;
    document.getElementById('travelClock').textContent = `Photon travel elapsed (visual): ${elapsedYears.toExponential(2)} years   |   φ(t) ≈ ${phiNow.toFixed(3)}°`;

    const remainingYears = ((1-photonProgress)*travelSeconds) / sec_per_year;
    document.getElementById('arrivalClock').textContent =
      (photonProgress < 1)
        ? `Estimated remaining (visual): ${remainingYears.toExponential(2)} years`
        : `Photon arrived (visual): ${new Date().toUTCString()}`;

    photonProgress += 0.001;
    if(photonProgress < 1){
      anim = requestAnimationFrame(frame);
    }
  }
  frame();
}

/* =========================
   Reset
========================= */
function resetSim(){
  cancelAnimationFrame(anim);
  anim = null;
  photonProgress = 0;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  lcCtx.clearRect(0,0,lcCanvas.width,lcCanvas.height);

  document.getElementById('output').textContent = '';
  document.getElementById('lcOut').textContent = '';
  document.getElementById('travelClock').textContent = '';
  document.getElementById('arrivalClock').textContent = '';
}

/* =========================
   UI behavior
========================= */
document.getElementById('showLC').addEventListener('change', ()=>{
  document.getElementById('lcWrap').style.display = document.getElementById('showLC').checked ? "block" : "none";
});

document.getElementById('galaxy').addEventListener('change', ()=>{
  const sel = document.getElementById('galaxy');
  const opt = sel.options[sel.selectedIndex];
  if(opt && opt.dataset && opt.dataset.preset === "sn1987a"){
    document.getElementById('useSN1987A').checked = true;
    document.getElementById('snType').value = "CC";
  }
});

function syncDEBadges(){
  const useDE = document.getElementById('useDE').checked;
  const label = document.querySelector('label[for="useDE"]') || null;
  const pills = document.querySelectorAll('.pill');
  if(pills.length){
    pills[0].textContent = useDE ? "ON" : "OFF";
    pills[0].style.background = useDE ? "#0b3d91" : "#777";
  }
}
document.getElementById('useDE').addEventListener('change', syncDEBadges);
syncDEBadges();
</script>
</body>
</html>
