<!-- PART 1 / 4  (DOCTYPE + HEAD + STYLES) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>6/54 Sum-It-Up Predictor — Embedded History (Peak / Secondary / Upper + Quick Picks)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121a24; --panel2:#0f1620; --text:#e8eef7; --muted:#9fb0c7;
      --accent:#59c1ff; --good:#60ffa7; --warn:#ffd166; --bad:#ff5c7a; --line:#243245;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:var(--sans); background:linear-gradient(180deg,#070a0f, var(--bg)); color:var(--text)}
    header{padding:18px 16px; border-bottom:1px solid var(--line); background:rgba(18,26,36,.6); backdrop-filter: blur(8px);}
    header h1{margin:0; font-size:18px; letter-spacing:.2px}
    header p{margin:8px 0 0; color:var(--muted); font-size:13px; line-height:1.35}

    .wrap{max-width:1250px; margin:0 auto; padding:16px;}
    .grid{display:grid; grid-template-columns: 1.05fr .95fr; gap:14px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }

    .card{background:rgba(18,26,36,.86); border:1px solid var(--line); border-radius:14px; padding:14px; box-shadow: 0 10px 35px rgba(0,0,0,.25);}
    .card h2{margin:0 0 10px; font-size:15px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    label{font-size:12px; color:var(--muted)}

    input[type="text"]{
      width:100%; padding:10px 10px; border-radius:12px; border:1px solid var(--line);
      background:rgba(15,22,32,.9); color:var(--text); outline:none;
      font-family:var(--mono); font-size:13px;
    }

    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    button{
      border:1px solid var(--line); background:rgba(15,22,32,.9); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800; font-size:13px;
    }
    button:hover{border-color:rgba(89,193,255,.6)}
    button.primary{background:rgba(89,193,255,.14); border-color:rgba(89,193,255,.55)}
    button.good{background:rgba(96,255,167,.12); border-color:rgba(96,255,167,.45)}
    button.warn{background:rgba(255,209,102,.12); border-color:rgba(255,209,102,.45)}
    button.bad{background:rgba(255,92,122,.10); border-color:rgba(255,92,122,.45)}

    .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
      border:1px solid var(--line); background:rgba(15,22,32,.7); color:var(--muted); font-size:12px}
    .mono{font-family:var(--mono)}

    .kpi{display:grid; grid-template-columns: repeat(4,1fr); gap:10px; margin-top:10px}
    @media (max-width: 980px){ .kpi{grid-template-columns: repeat(2,1fr)} }
    .kpi .box{padding:10px; border-radius:14px; border:1px solid var(--line); background:rgba(15,22,32,.7)}
    .kpi .box .t{font-size:11px; color:var(--muted)}
    .kpi .box .v{font-size:16px; margin-top:6px; font-weight:900}

    .hr{height:1px; background:var(--line); margin:12px 0}

    table{width:100%; border-collapse: collapse; overflow:hidden; border-radius:12px; border:1px solid var(--line);}
    th,td{padding:10px 10px; text-align:left; border-bottom:1px solid var(--line); font-size:13px}
    th{color:var(--muted); font-size:12px; background:rgba(15,22,32,.65)}
    tr:last-child td{border-bottom:none}

    .tag{display:inline-block; padding:3px 8px; border-radius:999px; font-size:12px; border:1px solid var(--line); color:var(--muted)}
    .tag.good{border-color:rgba(96,255,167,.45); color:var(--good)}
    .tag.warn{border-color:rgba(255,209,102,.45); color:var(--warn)}
    .tag.bad{border-color:rgba(255,92,122,.5); color:var(--bad)}

    .small{font-size:12px; color:var(--muted); line-height:1.35}
    .note{padding:10px; border-radius:12px; border:1px dashed rgba(89,193,255,.5); background:rgba(89,193,255,.07); color:var(--muted); font-size:12px; line-height:1.35}

    .sectionTitle{display:flex; justify-content:space-between; align-items:center; gap:10px}
    .sectionTitle .right{display:flex; gap:8px; flex-wrap:wrap}

    .print-area{display:none}
    @media print{
      body{background:#fff; color:#000}
      header,.no-print{display:none !important}
      .wrap{max-width:none; padding:0}
      .card{box-shadow:none; border:1px solid #bbb; background:#fff}
      .print-area{display:block}
      table{border:1px solid #bbb}
      th,td{border-bottom:1px solid #ddd}
    }
  </style>
</head>
<!-- PART 2 / 4  (BODY / UI) -->
<body>
<header>
  <h1>6/54 Sum-It-Up Predictor — Embedded History + Cached Model</h1>
  <p>
    Enter the last draw (6 numbers). Click <b>Analyze</b> to see sum + parity.
    Click <b>Predict Targets</b> to select <span class="mono">10 Peak</span>, <span class="mono">10 Secondary</span>, <span class="mono">10 Upper</span> sums (learned from the embedded history and your last-sum transitions).
    Click <b>Generate 40</b> to create 30 targeted lines + 10 quick picks, then <b>Print</b>.
  </p>
</header>

<div class="wrap">
  <div class="grid">

    <!-- LEFT: INPUTS -->
    <div class="card no-print">
      <h2>1) Enter Last Draw (Balls 1–6)</h2>
      <label>Example: <span class="mono">1 21 31 39 41 51</span></label>
      <input id="lastDraw" type="text" placeholder="e.g., 1 21 31 39 41 51" />

      <div class="row" style="margin-top:10px">
        <span class="pill">Auto Sum: <b id="autoSum" class="mono">—</b></span>
        <span class="pill">Odds: <b id="autoOdd" class="mono">—</b></span>
        <span class="pill">Evens: <b id="autoEven" class="mono">—</b></span>
        <span class="pill">Spread: <b id="autoSpread" class="mono">—</b></span>
      </div>

      <div class="hr"></div>

      <h2>2) Bands (fixed)</h2>
      <div class="note">
        <b>Main Peak:</b> 155–170<br>
        <b>Secondary Lift:</b> 173–178<br>
        <b>Upper Volatility:</b> 182–201<br><br>
        The “anchor” is ALWAYS the <b>last draw sum</b> you type above.
      </div>

      <div class="btns">
        <button class="primary" id="btnAnalyze">Analyze</button>
        <button class="good" id="btnPredict">Predict Targets (10/10/10)</button>
        <button class="warn" id="btnGenerate">Generate 40 Lines</button>
        <button id="btnPrint">Print 40</button>
        <button class="bad" id="btnReset">Reset</button>
      </div>

      <div class="hr"></div>
      <div class="small">
        <span class="tag warn">Reminder</span>
        This is not “cheating” — it just keeps you in realistic sum/parity patterns seen in your history, and uses last-sum transition tendencies.
      </div>
    </div>

    <!-- RIGHT: RESULTS -->
    <div class="card">
      <div class="sectionTitle">
        <h2 style="margin:0">Results</h2>
        <div class="right">
          <span class="tag good" id="modelStatus">Model: embedded + cached</span>
          <span class="tag" id="anchorTag">Anchor: —</span>
          <span class="tag" id="transitionTag">Transition: —</span>
        </div>
      </div>

      <div class="kpi">
        <div class="box">
          <div class="t">Last Draw Sum</div>
          <div class="v mono" id="kpiSum">—</div>
        </div>
        <div class="box">
          <div class="t">Odd / Even</div>
          <div class="v mono" id="kpiParity">—</div>
        </div>
        <div class="box">
          <div class="t">Band Hint</div>
          <div class="v mono" id="kpiBandHint">—</div>
        </div>
        <div class="box">
          <div class="t">Lines Ready</div>
          <div class="v mono" id="kpiLines">0 / 40</div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>Predicted Target Sums (10 Peak, 10 Secondary, 10 Upper)</h2>
      <div class="small">
        Score = blend of (sum frequency) + (anchor-sum transition tendency).
        Preferred parity is learned per sum (most common odd-count for that sum).
      </div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Band</th>
              <th>#</th>
              <th>Target Sum</th>
              <th>Preferred Odd/Even</th>
              <th>Score</th>
            </tr>
          </thead>
          <tbody id="sumTable">
            <tr><td colspan="5" class="small">Click <b>Predict Targets</b>.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="hr"></div>

      <h2>Generated 40 Lines (Print This)</h2>
      <div class="small">
        Order: 10 Peak → 10 Secondary → 10 Upper → 10 Quick Picks.
      </div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Group</th>
              <th>#</th>
              <th>Numbers (6)</th>
              <th>Sum</th>
              <th>Odd/Even</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody id="comboTable">
            <tr><td colspan="6" class="small">Click <b>Generate 40 Lines</b>.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="print-area">
        <h2>Printed Output</h2>
        <p class="small">Predicted target sums and generated 40 lines.</p>
      </div>
    </div>

  </div>
</div>

<script>
<!-- PART 3 / 4  (EMBEDDED HISTORY ARRAY + MODEL BUILD ONCE + FIXED WEIGHTED MATH) -->
/**
 * EMBEDDED FULL HISTORY (PERMANENT)
 * Extracted from your Excel: 2198 valid rows (6 unique balls, 1..54).
 * Stored as an ARRAY (faster than CSV parsing).
 *
 * IMPORTANT:
 * - This is cached model: we build frequencies + parity + transitions ONCE at page load.
 * - Transition counts are built BOTH directions between adjacent rows to avoid sheet ordering issues.
 */
const HISTORY = [
  [7,14,23,38,42,44],
  [4,15,16,29,39,44],
  [4,25,33,37,44,51],
  [1,19,24,41,44,54],
  [14,20,25,45,47,52],
  [4,12,35,41,48,49],
  [17,20,32,36,46,51],
  [16,19,35,40,45,47],
  [1,9,15,21,39,41],
  [3,4,6,32,38,40],
  [9,20,26,36,37,43],
  [2,15,25,43,45,48],
  [2,12,31,35,38,46],
  [3,4,8,25,43,46],
  [1,3,12,20,32,37],
  [2,7,33,36,42,51],
  [17,20,23,32,49,52],
  [8,20,27,34,41,50],
  [4,8,25,30,41,47],
  [16,17,26,31,43,48],
  [19,24,28,34,48,52],
  [1,11,12,29,49,54],
  [17,19,23,29,30,50],
  [8,15,27,31,43,52],
  [5,13,14,20,31,46],
  [1,4,29,33,35,52],
  [6,10,21,25,36,41],
  [2,6,11,12,29,33],
  [15,19,26,29,34,54],
  [6,20,31,34,36,40],
  [8,10,28,39,50,53],
  [9,11,22,31,45,52],
  [1,5,15,30,32,46],
  [6,8,14,23,32,52]
  /*  ... SNIPPET SHOWN ...
      Your file contains 2198 rows.
      To keep this message size safe, I’m not printing all 2198 lines here.
      You can paste the remaining HISTORY rows continuing the same format:
      [b1,b2,b3,b4,b5,b6],
      ...
  */
];

// Your provided frequency weights (Ball -> times drawn)
const FREQ = {
  1:240,2:239,3:242,4:279,5:261,6:256,7:263,8:290,9:257,10:261,11:227,12:266,
  13:253,14:269,15:283,16:257,17:274,18:262,19:281,20:243,21:276,22:256,23:242,24:263,
  25:255,26:284,27:269,28:250,29:262,30:233,31:284,32:239,33:231,34:261,35:271,36:249,
  37:263,38:282,39:259,40:243,41:251,42:256,43:251,44:271,45:220,46:230,47:238,48:227,
  49:276,50:228,51:243,52:270,53:235,54:259
};

// Bands
const BANDS = {
  peak:      {name:"Peak",      lo:155, hi:170},
  secondary: {name:"Secondary", lo:173, hi:178},
  upper:     {name:"Upper",     lo:182, hi:201}
};

const $ = (id)=>document.getElementById(id);

function parseSixNumbers(str){
  const parts = (str || "")
    .replace(/[^0-9, ]/g," ")
    .split(/[\s,]+/).filter(Boolean)
    .map(x=>parseInt(x,10))
    .filter(n=>Number.isFinite(n));

  const uniq = [];
  for(const n of parts){
    if(n>=1 && n<=54 && !uniq.includes(n)) uniq.push(n);
    if(uniq.length===6) break;
  }
  return uniq;
}
function sum(arr){ return arr.reduce((a,b)=>a+b,0); }
function oddCount(arr){ return arr.reduce((a,b)=>a + (b%2!==0 ? 1:0),0); }
function spread(arr){ return Math.max(...arr) - Math.min(...arr); }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function parityLabel(arr){ const o=oddCount(arr); return `${o} odd / ${6-o} even`; }
function keyOfArr(arr){ return arr.slice().sort((a,b)=>a-b).join("-"); }

// Auto UI update
function updateAuto(){
  const balls = parseSixNumbers($("lastDraw").value);
  if(balls.length!==6){
    $("autoSum").textContent="—";
    $("autoOdd").textContent="—";
    $("autoEven").textContent="—";
    $("autoSpread").textContent="—";
    return;
  }
  const s=sum(balls), o=oddCount(balls);
  $("autoSum").textContent=String(s);
  $("autoOdd").textContent=String(o);
  $("autoEven").textContent=String(6-o);
  $("autoSpread").textContent=String(spread(balls));
}
$("lastDraw").addEventListener("input", updateAuto);

function setKpis(balls){
  if(balls.length!==6){
    $("kpiSum").textContent="—";
    $("kpiParity").textContent="—";
    $("kpiBandHint").textContent="—";
    $("anchorTag").textContent="Anchor: —";
    return;
  }
  const s=sum(balls), o=oddCount(balls), e=6-o;
  $("kpiSum").textContent=String(s);
  $("kpiParity").textContent=`${o} odd / ${e} even`;
  $("anchorTag").textContent=`Anchor: ${s}`;

  let hint="Below peak band";
  if(s>=BANDS.peak.lo && s<=BANDS.peak.hi) hint="Peak zone";
  else if(s>=BANDS.secondary.lo && s<=BANDS.secondary.hi) hint="Secondary lift";
  else if(s>=BANDS.upper.lo && s<=BANDS.upper.hi) hint="Upper volatility";
  else if(s > BANDS.upper.hi) hint="Above upper band";
  $("kpiBandHint").textContent=hint;
}

/**
 * FIXED WEIGHTED PICKING MATH (correct with exclusions)
 * We recompute remaining weight total per pick to avoid bias.
 */
function weightedPickOne(excludeSet){
  let total = 0;
  for(let n=1;n<=54;n++){
    if(excludeSet.has(n)) continue;
    total += (FREQ[n] || 1);
  }
  if(total <= 0) return null;

  let r = Math.random() * total;
  for(let n=1;n<=54;n++){
    if(excludeSet.has(n)) continue;
    r -= (FREQ[n] || 1);
    if(r <= 0) return n;
  }
  for(let n=1;n<=54;n++){
    if(!excludeSet.has(n)) return n;
  }
  return null;
}
function weightedSampleUnique(k){
  const set = new Set();
  const arr = [];
  while(arr.length<k){
    const n = weightedPickOne(set);
    if(n==null) break;
    set.add(n);
    arr.push(n);
  }
  return arr.length===k ? arr : null;
}

/** Build cached model ONCE */
const MODEL = (() => {
  const sumFreq = new Map();          // sum -> count
  const parityBySum = new Map();      // sum -> Map(oddCount -> count)
  const transitions = new Map();      // sumA -> Map(sumB -> count) (UNDIRECTED adjacency)
  const globalOddCounts = new Map();  // oddCount -> count

  const sums = new Array(HISTORY.length);
  for(let i=0;i<HISTORY.length;i++){
    const s = sum(HISTORY[i]);
    sums[i]=s;

    sumFreq.set(s, (sumFreq.get(s)||0)+1);

    const o = oddCount(HISTORY[i]);
    globalOddCounts.set(o, (globalOddCounts.get(o)||0)+1);

    if(!parityBySum.has(s)) parityBySum.set(s, new Map());
    const pm = parityBySum.get(s);
    pm.set(o, (pm.get(o)||0)+1);
  }

  // Build adjacency transitions both directions to avoid ordering ambiguity
  for(let i=0;i<sums.length-1;i++){
    const a = sums[i], b = sums[i+1];
    if(!transitions.has(a)) transitions.set(a, new Map());
    if(!transitions.has(b)) transitions.set(b, new Map());
    transitions.get(a).set(b, (transitions.get(a).get(b)||0)+1);
    transitions.get(b).set(a, (transitions.get(b).get(a)||0)+1);
  }

  // global odd mode
  let globalOddMode = 3, best=-1;
  for(const [o,c] of globalOddCounts.entries()){
    if(c>best){ best=c; globalOddMode=o; }
  }

  // max freq cached
  let maxFreq = 1;
  for(const c of sumFreq.values()) maxFreq = Math.max(maxFreq, c);

  return {sumFreq, parityBySum, transitions, globalOddMode, maxFreq};
})();

/** Cache for the last predicted target list so Generate uses it */
let LAST_TARGETS = null;
<!-- PART 4 / 4  (PREDICT TARGETS + GENERATE 40 + RENDER + EVENTS + CLOSE HTML) -->
function preferredOddForSum(targetSum){
  const pm = MODEL.parityBySum.get(targetSum);
  if(pm && pm.size){
    let bestO = MODEL.globalOddMode, bestC=-1;
    for(const [o,c] of pm.entries()){
      if(c>bestC){ bestC=c; bestO=o; }
    }
    return bestO;
  }
  return MODEL.globalOddMode ?? 3;
}

/** Build sum scores using anchor sum */
function buildSumScores(anchorSum){
  // transition normalization for this anchor
  const tm = MODEL.transitions.get(anchorSum);
  let maxT = 1;
  if(tm) for(const c of tm.values()) maxT = Math.max(maxT, c);

  const scores = new Map();
  for(let s=120; s<=220; s++){
    const f = MODEL.sumFreq.get(s) || 0;
    const fNorm = f / MODEL.maxFreq;

    const tCount = tm ? (tm.get(s)||0) : 0;
    const tNorm = tm ? (tCount / maxT) : 0;

    // weights: more stable on frequency, but still uses transition info when available
    let score = 0.65*fNorm + 0.35*tNorm;
    if(f===0 && (!tm || tCount===0)) score = 0.01; // tiny baseline
    scores.set(s, score);
  }
  return {scores, hasTransition: !!tm};
}

function pickTopSumsInBand(band, scores, N){
  const list = [];
  for(let s=band.lo; s<=band.hi; s++){
    list.push({sum:s, score: scores.get(s) ?? 0.01});
  }
  list.sort((a,b)=> b.score - a.score);
  return list.slice(0, N);
}

/** Soft distribution scoring: prefer certain low/mid/high mixes per band */
function bucketCounts(arr){
  let low=0, mid=0, high=0;
  for(const n of arr){
    if(n<=18) low++;
    else if(n<=36) mid++;
    else high++;
  }
  return {low,mid,high};
}
function acceptDistributionForBand(bandName, counts){
  // Peak/Secondary: prefer 2-2-2, but allow 1-2-3 sometimes
  // Upper: prefer 1-2-3, allow 2-1-3, 1-1-4 occasionally
  if(bandName==="Upper"){
    const ok = (counts.low===1 && counts.mid===2 && counts.high===3);
    if(ok) return true;
    if(counts.high>=3 && counts.mid>=1 && counts.low>=0) return Math.random() < 0.35;
    return Math.random() < 0.12;
  } else {
    const ok = (counts.low===2 && counts.mid===2 && counts.high===2);
    if(ok) return true;
    const ok2 = (counts.low===1 && counts.mid===2 && counts.high===3);
    if(ok2) return Math.random() < 0.55;
    return Math.random() < 0.18;
  }
}

/**
 * Fast exact-sum combo generator:
 * pick 5 weighted unique numbers -> compute needed 6th -> check sum + parity + spread + distribution
 */
function generateComboForTarget(targetSum, targetOdd, bandName, maxTries=110000){
  for(let t=0;t<maxTries;t++){
    const picked5 = weightedSampleUnique(5);
    if(!picked5) continue;

    // parity steering
    const o5 = oddCount(picked5);
    if(o5 > targetOdd && Math.random() < 0.70) continue;

    const needed = targetSum - sum(picked5);
    if(needed < 1 || needed > 54) continue;
    if(picked5.includes(needed)) continue;

    const arr = picked5.concat([needed]).sort((a,b)=>a-b);
    if(sum(arr) !== targetSum) continue;
    if(oddCount(arr) !== targetOdd) continue;

    // spread sanity
    const sp = spread(arr);
    if(sp < 18 && Math.random() < 0.65) continue;
    if(sp > 50 && Math.random() < 0.65) continue;

    // distribution preference (soft)
    const bc = bucketCounts(arr);
    if(!acceptDistributionForBand(bandName, bc)) continue;

    return arr;
  }
  return null;
}

function generateQuickPick(maxTries=30000){
  for(let t=0;t<maxTries;t++){
    const arr = weightedSampleUnique(6);
    if(!arr) continue;
    arr.sort((a,b)=>a-b);

    const s=sum(arr), o=oddCount(arr), sp=spread(arr);
    // soft constraints
    if(s < 145 || s > 205) { if(Math.random() < 0.92) continue; }
    if(o === 0 || o === 6) { if(Math.random() < 0.97) continue; }
    if(sp < 16) { if(Math.random() < 0.70) continue; }

    return arr;
  }
  return null;
}

/** Render tables */
function renderTargets(allTargets){
  const tbody = $("sumTable");
  tbody.innerHTML = "";
  for(const row of allTargets){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.band}</td>
      <td class="mono">${row.idx}</td>
      <td class="mono"><b>${row.sum}</b></td>
      <td class="mono">${row.odd} odd / ${6-row.odd} even</td>
      <td class="mono">${Math.round(row.score*100)}%</td>
    `;
    tbody.appendChild(tr);
  }
}

function renderLines(lines){
  const tbody = $("comboTable");
  tbody.innerHTML = "";
  let made = 0;

  for(const line of lines){
    const tr = document.createElement("tr");
    if(line.nums){
      made++;
      tr.innerHTML = `
        <td>${line.group}</td>
        <td class="mono">${line.idx}</td>
        <td class="mono"><b>${line.nums.join(", ")}</b></td>
        <td class="mono">${sum(line.nums)}</td>
        <td class="mono">${parityLabel(line.nums)}</td>
        <td class="small">${line.note || ""}</td>
      `;
    } else {
      tr.innerHTML = `
        <td>${line.group}</td>
        <td class="mono">${line.idx}</td>
        <td class="mono"><span class="tag bad">No combo found fast</span></td>
        <td class="mono">—</td>
        <td class="mono">—</td>
        <td class="small">${line.note || ""}</td>
      `;
    }
    tbody.appendChild(tr);
  }
  $("kpiLines").textContent = `${made} / 40`;
}

/** Predict targets button */
function predictTargets(){
  const balls = parseSixNumbers($("lastDraw").value);
  setKpis(balls);
  updateAuto();

  if(balls.length !== 6){
    $("transitionTag").textContent = "Transition: —";
    $("transitionTag").className = "tag";
    LAST_TARGETS = null;
    return;
  }

  const anchorSum = sum(balls);
  const {scores, hasTransition} = buildSumScores(anchorSum);
  $("transitionTag").textContent = hasTransition ? "Transition: on" : "Transition: off";
  $("transitionTag").className = hasTransition ? "tag good" : "tag warn";

  const peakS = pickTopSumsInBand(BANDS.peak, scores, 10);
  const secS  = pickTopSumsInBand(BANDS.secondary, scores, 10);
  const uppS  = pickTopSumsInBand(BANDS.upper, scores, 10);

  const targets = [];
  function push(bandName, arr){
    arr.forEach((it,i)=>{
      targets.push({
        band: bandName,
        idx: i+1,
        sum: it.sum,
        odd: preferredOddForSum(it.sum),
        score: clamp(it.score, 0.01, 1.0)
      });
    });
  }
  push("Peak", peakS);
  push("Secondary", secS);
  push("Upper", uppS);

  LAST_TARGETS = targets;
  renderTargets(targets);

  // reset lines table (optional)
  $("comboTable").innerHTML = `<tr><td colspan="6" class="small">Click <b>Generate 40 Lines</b>.</td></tr>`;
  $("kpiLines").textContent = "0 / 40";
}

/** Generate 40 lines button */
function generate40(){
  // ensure we have targets (auto-predict if needed)
  if(!LAST_TARGETS){
    predictTargets();
    if(!LAST_TARGETS) return;
  }

  const used = new Set();
  const lines = [];

  function addUnique(group, idx, nums, note){
    if(nums){
      const k = keyOfArr(nums);
      if(used.has(k)) return false;
      used.add(k);
    }
    lines.push({group, idx, nums, note});
    return true;
  }

  // 30 targeted
  for(const t of LAST_TARGETS){
    let combo = null;

    const tries = (t.band === "Upper") ? 80 : 55;
    const perTry = (t.band === "Upper") ? 52000 : 32000;

    for(let a=0;a<tries;a++){
      const c = generateComboForTarget(t.sum, t.odd, t.band, perTry);
      if(!c) continue;
      const k = keyOfArr(c);
      if(!used.has(k)){ combo = c; break; }
    }

    addUnique(t.band, t.idx, combo, `Target ${t.sum}, pref ${t.odd} odd`);
  }

  // 10 quick picks
  for(let i=1;i<=10;i++){
    let qp = null;
    for(let a=0;a<60;a++){
      const c = generateQuickPick(16000);
      if(!c) continue;
      const k = keyOfArr(c);
      if(!used.has(k)){ qp = c; break; }
    }
    addUnique("Quick", i, qp, qp ? "Weighted quick pick" : "Quick pick failed");
  }

  renderLines(lines);
}

/** Events */
$("btnAnalyze").addEventListener("click", ()=>{
  const balls = parseSixNumbers($("lastDraw").value);
  setKpis(balls);
  updateAuto();
});

$("btnPredict").addEventListener("click", predictTargets);
$("btnGenerate").addEventListener("click", generate40);
$("btnPrint").addEventListener("click", ()=>window.print());

$("btnReset").addEventListener("click", ()=>{
  $("lastDraw").value = "";
  updateAuto();
  setKpis([]);
  LAST_TARGETS = null;

  $("sumTable").innerHTML = `<tr><td colspan="5" class="small">Click <b>Predict Targets</b>.</td></tr>`;
  $("comboTable").innerHTML = `<tr><td colspan="6" class="small">Click <b>Generate 40 Lines</b>.</td></tr>`;
  $("kpiLines").textContent = "0 / 40";
  $("transitionTag").textContent = "Transition: —";
  $("transitionTag").className = "tag";
  $("anchorTag").textContent = "Anchor: —";
});

/** Init */
updateAuto();
</script>
</body>
</html>  
