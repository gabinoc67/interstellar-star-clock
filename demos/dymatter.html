<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Circle-in-Square — Coil & Field Demo</title>
<style>
  :root{
    --bg:#0b1222; --panel:#111a34; --ink:#eaf0ff; --muted:#a7b7e6;
    --grid:#1a2759; --accent:#8fb4ff; --ok:#7bffb1; --warn:#ffd37a;
    --square:#2b5cff; --field:#9fd0ff; --particle:#7bffb1;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
            font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:18px}
  h1{margin:0 0 6px;font-size:1.25rem}
  .sub{margin:0 0 16px;color:var(--muted);font-size:0.95rem;line-height:1.4}
  .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  .card{background:var(--panel);border:1px solid #1a2a63;border-radius:14px;overflow:hidden}
  .head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #1a2a63}
  .head h2{margin:0;font-size:1rem}
  .body{padding:12px}
  .controls{display:grid;gap:10px}
  label{font-size:0.9rem;color:var(--muted)}
  input[type="range"]{width:100%}
  .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
  .btn{background:#162455;border:1px solid #243577;color:var(--ink);
       padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn:hover{background:#1d2e6e}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;
        background:#0f1a3f;border:1px solid #213067;font-size:0.85rem;color:var(--muted)}
  canvas{display:block;width:100%;height:540px;background:
          linear-gradient(180deg,#0b1222 0,#0b1222 60%,#0b1222 100%)}
  .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:8px}
  .eq{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:0.9rem; background:#0d173a;border:1px solid #22316b;color:#d8e2ff;
      padding:10px;border-radius:10px;line-height:1.35}
  .hint{color:var(--muted);font-size:0.85rem;margin-top:8px}
  .badge{padding:3px 8px;border-radius:8px;border:1px solid #2b3d86;background:#0f1a3f;color:#b9c7ff;font-size:0.78rem}
  .switch{display:flex;align-items:center;gap:8px}
  .switch input{accent-color:#6fb3ff;transform:scale(1.2)}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;margin-top:8px}
  .kv div{font-size:0.9rem;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Circle-in-Square — Coil (Algebra) & Field (Geometry)</h1>
    <p class="sub">
      The square coil represents <strong>algebraic structure</strong> (quantized turns, fixed boundaries). The circular flow
      shows the <strong>geometric field</strong> that arises from current. Adjust the current and overlays to see how
      <em>equations frame motion</em> and <em>motion gives equations meaning</em>.
    </p>

    <div class="grid">
      <!-- Visualization -->
      <div class="card">
        <div class="head">
          <h2>Visualization</h2>
          <span class="pill">
            <span class="badge">Square = algebra</span>
            <span class="badge">Circle = geometry</span>
          </span>
        </div>
        <div class="body">
          <canvas id="viz" width="1000" height="540"></canvas>
          <div class="legend">
            <span class="pill"><span style="width:12px;height:12px;border-radius:50%;background:var(--particle);display:inline-block"></span> Field tracers</span>
            <span class="pill"><span style="width:12px;height:12px;border-radius:3px;background:var(--square);display:inline-block"></span> Square coil</span>
            <span class="pill"><span style="width:12px;height:12px;border-radius:50%;background:var(--field);display:inline-block"></span> Field arrows</span>
          </div>
          <div class="hint">Tip: higher current → stronger, tighter circular motion. Pause to inspect arrows precisely.</div>
        </div>
      </div>

      <!-- Controls & Theory -->
      <div class="card">
        <div class="head"><h2>Controls & Theory</h2></div>
        <div class="body">
          <div class="controls">
            <div class="row">
              <label for="current"><strong>Current (I)</strong> — normalized</label>
              <span class="badge" id="iReadout">1.00</span>
            </div>
            <input id="current" type="range" min="0.2" max="3" step="0.01" value="1" />

            <div class="row">
              <label for="particles"><strong>Tracer Count</strong></label>
              <span class="badge" id="pReadout">240</span>
            </div>
            <input id="particles" type="range" min="60" max="600" step="10" value="240" />

            <div class="row">
              <label for="drag"><strong>Field Drag</strong> (visual smoothness)</label>
              <span class="badge" id="dReadout">0.965</span>
            </div>
            <input id="drag" type="range" min="0.9" max="0.995" step="0.001" value="0.965" />

            <div class="row">
              <button class="btn" id="toggle">⏸️ Pause</button>
              <button class="btn" id="reset">↺ Reset</button>
              <label class="switch"><input id="showArrows" type="checkbox" checked />Show field arrows</label>
            </div>

            <div class="kv">
              <div>Radius scale:</div><div><span class="badge" id="rScale">1/r</span></div>
              <div>Arrow density:</div><div><span class="badge" id="aDensity">coarse→fine with I</span></div>
            </div>

            <details style="margin-top:10px">
              <summary style="cursor:pointer">Show equations (algebra framing geometry)</summary>
              <div class="eq" style="margin-top:8px">
                Maxwell (curl form):<br/>
                ∇ × E = −∂B/∂t &nbsp;&nbsp; , &nbsp;&nbsp; ∇ × B = μ₀ε₀ ∂E/∂t<br/><br/>
                Loop intuition (centered, illustrative):<br/>
                |B(r)| ≈ k · I / r  &nbsp;&nbsp; with  &nbsp;  k ≈ μ₀/2π  (heuristic for circular flow)<br/><br/>
                Tangential direction ê<sub>θ</sub> gives <em>geometry</em>; magnitude |B| gives <em>algebra</em>.
              </div>
            </details>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('viz');
  const ctx = canvas.getContext('2d');

  const ISlider = document.getElementById('current');
  const PSlider = document.getElementById('particles');
  const DSlider = document.getElementById('drag');
  const iReadout = document.getElementById('iReadout');
  const pReadout = document.getElementById('pReadout');
  const dReadout = document.getElementById('dReadout');
  const toggleBtn = document.getElementById('toggle');
  const resetBtn = document.getElementById('reset');
  const showArrows = document.getElementById('showArrows');

  let W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  // Square coil geometry (a simple visual boundary / "algebraic frame")
  const square = {
    size: Math.min(W,H)*0.55,
    draw(){
      const s = this.size, x = cx - s/2, y = cy - s/2;
      ctx.lineWidth = 3;
      ctx.strokeStyle = getCss('--square');
      ctx.setLineDash([8,6]);
      ctx.strokeRect(x, y, s, s);
      ctx.setLineDash([]);
      // Glow
      ctx.shadowColor = getCss('--square');
      ctx.shadowBlur = 20;
      ctx.strokeRect(x, y, s, s);
      ctx.shadowBlur = 0;
    }
  };

  // Particles tracing the circular field (the "geometry in motion")
  let particles = [];
  function seedParticles(n){
    particles = [];
    for(let i=0;i<n;i++){
      // bias spawn near square interior
      const rMax = square.size*0.48;
      // random radius with slight center preference
      const rr = Math.sqrt(Math.random()) * rMax;
      const th = Math.random()*Math.PI*2;
      const x = cx + rr*Math.cos(th);
      const y = cy + rr*Math.sin(th);
      particles.push({
        x, y,
        vx: 0, vy: 0,
        life: Math.random()*300+100
      });
    }
  }

  // Helper to read CSS vars
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // Vector field: circular flow with |B| ~ k*I/r, direction êθ
  function fieldAt(x,y, I){
    const dx = x - cx, dy = y - cy;
    let r = Math.hypot(dx,dy);
    const minR = 8; // avoid singularity
    r = Math.max(r, minR);

    // Tangential unit vector (rotate radial by +90°)
    const ex = -dy/r, ey = dx/r;

    // Magnitude (visual heuristic)
    const k = 110; // visual scaling coefficient
    const mag = (k * I) / r;

    return {fx: ex*mag, fy: ey*mag, r, ex, ey, mag};
  }

  // Field arrows grid (algebra + geometry overlay)
  function drawArrows(I){
    const stepBase = 50;
    const densityFactor = Math.max(0.6, Math.min(1.5, I)); // denser arrows with I
    const step = stepBase / densityFactor;

    ctx.lineWidth = 1.4;
    ctx.strokeStyle = getCss('--field');

    for(let y=cy-square.size*0.5+20; y<=cy+square.size*0.5-20; y+=step){
      for(let x=cx-square.size*0.5+20; x<=cx+square.size*0.5-20; x+=step){
        const F = fieldAt(x,y,I);
        const len = Math.min(22, 12 + F.mag*0.25);
        // draw a small arrow along tangential direction
        const x2 = x + F.ex*len, y2 = y + F.ey*len;

        // core line
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // arrow head
        const head = 5;
        const hx1 = x2 + (-F.ey)*head + (-F.ex)*head*0.4;
        const hy1 = y2 + ( F.ex)*head + (-F.ey)*head*0.4;
        const hx2 = x2 + ( F.ey)*head + (-F.ex)*head*0.4;
        const hy2 = y2 + (-F.ex)*head + (-F.ey)*head*0.4;

        ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(hx1,hy1);
        ctx.moveTo(x2,y2);
        ctx.lineTo(hx2,hy2);
        ctx.stroke();
      }
    }
  }

  // Draw background grid
  function grid(){
    ctx.save();
    ctx.strokeStyle = getCss('--grid');
    ctx.lineWidth = 1;
    const step = 32;
    for(let x = (W%step); x < W; x += step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y = (H%step); y < H; y += step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();
  }

  // Update/draw loop
  let running = true;
  const trail = document.createElement('canvas');
  trail.width = W; trail.height = H;
  const tctx = trail.getContext('2d');

  function step(){
    if(!running){ requestAnimationFrame(step); return; }

    const I = parseFloat(ISlider.value);
    const drag = parseFloat(DSlider.value);

    // fade trails
    tctx.fillStyle = `rgba(11,18,34,${1-drag})`; // background fade
    tctx.fillRect(0,0,W,H);

    // advance particles with field
    const color = getCss('--particle');
    tctx.fillStyle = color;
    for(const p of particles){
      const F = fieldAt(p.x,p.y,I);

      // Euler step in a "flow": follow tangent
      p.vx = F.fx*0.02 + p.vx*0.96;
      p.vy = F.fy*0.02 + p.vy*0.96;

      p.x += p.vx;
      p.y += p.vy;

      // soft confinement: keep tracers near square interior
      const half = square.size*0.5 - 8;
      const rx = p.x - cx, ry = p.y - cy;
      if(Math.abs(rx) > half || Math.abs(ry) > half){
        // nudge back in
        p.vx *= -0.4; p.vy *= -0.4;
        p.x = cx + Math.sign(rx)*half*0.98;
        p.y = cy + Math.sign(ry)*half*0.98;
      }

      // draw tracer dot
      tctx.beginPath();
      tctx.arc(p.x, p.y, 1.3, 0, Math.PI*2);
      tctx.fill();

      // lifespan recycle
      if(--p.life < 0){
        const rMax = square.size*0.45;
        const rr = Math.sqrt(Math.random()) * rMax;
        const th = Math.random()*Math.PI*2;
        p.x = cx + rr*Math.cos(th);
        p.y = cy + rr*Math.sin(th);
        p.vx = p.vy = 0;
        p.life = Math.random()*300+100;
      }
    }

    // compose: grid → trail → arrows → square
    ctx.clearRect(0,0,W,H);
    grid();
    ctx.drawImage(trail,0,0);

    if(showArrows.checked){
      ctx.save();
      ctx.globalAlpha = 0.8;
      drawArrows(I);
      ctx.restore();
    }

    square.draw();

    requestAnimationFrame(step);
  }

  // UI wiring
  function syncReadouts(){
    iReadout.textContent = (+ISlider.value).toFixed(2);
    pReadout.textContent = PSlider.value;
    dReadout.textContent = (+DSlider.value).toFixed(3);
  }
  ISlider.addEventListener('input', syncReadouts);
  PSlider.addEventListener('input', ()=>{
    seedParticles(+PSlider.value);
    syncReadouts();
  });
  DSlider.addEventListener('input', syncReadouts);

  toggleBtn.addEventListener('click', ()=>{
    running = !running;
    toggleBtn.textContent = running ? '⏸️ Pause' : '▶️ Play';
  });

  resetBtn.addEventListener('click', ()=>{
    seedParticles(+PSlider.value);
    // wipe trails
    tctx.fillStyle = '#0b1222';
    tctx.fillRect(0,0,W,H);
  });

  // Init
  seedParticles(+PSlider.value);
  syncReadouts();
  step();

  // Responsive (optional: keeps drawing crisp on resize)
  window.addEventListener('resize', ()=>{
    const rect = canvas.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width*ratio);
    canvas.height = Math.round(540*ratio);
    W = canvas.width; H = canvas.height;
    trail.width = W; trail.height = H;
  });
})();
</script>
</body>
</html>
