<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FULL UNIFIED COMPRECISANCE LAB — Physics • DNA • Cognition • Language • Evolution</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root { color-scheme: dark; }
  body {
    margin:0; padding:18px;
    background: radial-gradient(circle at top, #020617 0, #000 65%);
    color:#e5e7eb;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }
  h1 { margin-top:0; font-size:1.5rem; }
  .layout{
    display:flex;
    flex-wrap:wrap;
    gap:22px;
  }
  #plot {
    border:1px solid #1f2937;
    border-radius:10px;
    background:radial-gradient(circle at center, #020617 0, #000 90%);
  }
  .side {
    display:flex;
    flex-direction:column;
    gap:12px;
    width:360px;
    max-width:420px;
  }
  .box{
    padding:12px;
    border-radius:12px;
    background:rgba(15,23,42,0.92);
    border:1px solid #1f2937;
  }
  h2 { margin:0 0 4px 0; font-size:1rem; }
  label{
    display:block;
    font-size:0.78rem;
    margin:4px 0;
  }
  input[type=range]{ width:100%; }
  button{
    padding:6px 10px; font-size:0.82rem;
    border-radius:6px; border:none; cursor:pointer;
    background:#1e3a8a; color:#e5e7eb;
    margin-right:4px;
    margin-top:4px;
  }
  button:hover{ background:#3749ad; }
  .tiny{ font-size:0.75rem; color:#9ca3af; }
  pre{ white-space:pre-wrap; font-size:0.72rem; max-height:180px; overflow:auto; }
  #cstLabel{
    font-size:0.8rem;
    color:#a5b4fc;
    margin-top:4px;
  }
  #treeCanvas{
    width:100%;
    border-radius:8px;
    border:1px solid #1f2937;
    background:radial-gradient(circle at top, #020617 0, #000 100%);
  }
</style>
</head>
<body>

<h1>Unified Comprecisance Evolution Lab — Physics, DNA, Syntax, Cognition, Natural Selection</h1>

<p style="max-width:960px;font-size:0.9rem;">
Every organism cluster is an <strong>agent</strong>:
drifting, adapting, station-locking, branching and dying based on fitness.
Fitness unifies <strong>DNA geometry, syntax, semantics, brain coherence and physics constraints</strong>.
</p>

<div class="layout">
  <!-- MAIN EVOLUTION PLOT -->
  <canvas id="plot" width="680" height="600"></canvas>

  <!-- CONTROL + EXPLANATION SIDE PANEL -->
  <div class="side">

    <!-- PHYSICS BAND -->
    <div class="box">
      <h2>Physics Comprecisance</h2>
      <label>
        Physics band width
        <input id="bandWidth" type="range" min="0.05" max="0.4" step="0.01" value="0.18">
      </label>
      <label>
        Physics slope
        <input id="slope" type="range" min="0.4" max="1.6" step="0.05" value="1.0">
      </label>
      <p class="tiny">
        Defines comfort region for EM, strong, weak, gravity.
        Species closer to this band feel less physical penalty.
      </p>
    </div>

    <!-- EVOLUTION -->
    <div class="box">
      <h2>Evolutionary Dynamics</h2>

      <label>
        Evolutionary band width
        <input id="evoWidth" type="range" min="0.05" max="0.45" step="0.01" value="0.25">
      </label>

      <label>
        Extinction radius
        <input id="extinctRadius" type="range" min="0.05" max="0.7" step="0.01" value="0.35">
      </label>

      <label>
        DNA mutation step size
        <input id="dnaComplex" type="range" min="0.05" max="1" step="0.05" value="0.45">
      </label>

      <label>
        Mutation rate
        <input id="mutationRate" type="range" min="0.0" max="0.02" step="0.001" value="0.006">
      </label>

      <label>
        Branching threshold (0 = easy, 1 = strict)
        <input id="branchThreshold" type="range" min="0.1" max="1" step="0.05" value="0.5">
      </label>

      <label>
        Mortality curve (aging / fragility)
        <input id="mortalityCurve" type="range" min="0" max="1" step="0.05" value="0.4">
      </label>

      <label>
        Syntactic precision strength
        <input id="syntaxWeight" type="range" min="0" max="1" step="0.05" value="0.6">
      </label>

      <label>
        Semantic compression strength
        <input id="semanticWeight" type="range" min="0" max="1" step="0.05" value="0.6">
      </label>

      <label>
        CST-time drift rate
        <input id="cstDrift" type="range" min="0" max="2" step="0.05" value="0.3">
      </label>

      <div id="cstLabel">CST-time τ = 0.00</div>

      <button id="addDNA">Add Species</button>
      <button id="driftToggle">Start Drift</button>
      <button id="toggle3D">Toggle 3D Holographic</button>

      <p class="tiny">
        Species adapt, branch, drift, or go extinct.<br>
        CST-time slowly warps the environment, like a universal metronome.
      </p>
    </div>

    <!-- COGNITION / BRAIN COHERENCE -->
    <div class="box">
      <h2>Cognition & Brain Coherence</h2>
      <label>
        Brain coherence weight
        <input id="brainWeight" type="range" min="0" max="1" step="0.05" value="0.5">
      </label>
      <p class="tiny">
        Extra fitness for species that align with a "brain coherence" attractor line:
        a proxy for neural synchrony, decision coherence, and cognitive stability.
      </p>
    </div>

    <!-- PHYLOGENETIC TREE -->
    <div class="box">
      <h2>Phylogenetic Tree (Real-Time)</h2>
      <canvas id="treeCanvas" width="340" height="220"></canvas>
      <p class="tiny">
        Roots on the left, descendants to the right. Vertical order ≈ birth time.
        Lines show who branched from whom.
      </p>
    </div>

    <!-- EXPORT -->
    <div class="box">
      <h2>Export Population Histories</h2>
      <button id="exportCSV">Export CSV History</button>
      <p class="tiny">
        Exports simulation snapshots over time: step, CST-time, species name,
        position, fitness, and extinction status. Paste into Excel, R, Python, or papers.
      </p>
      <pre id="csvOut"></pre>
    </div>

  </div>
</div>

<script>
/* ============================================================
   CORE GLOBALS & DATA STRUCTURES
   ============================================================ */

// Main canvas for the 2D phase-space plot
const canvas = document.getElementById("plot");
const ctx = canvas.getContext("2d");

// Phylogenetic tree canvas
const treeCanvas = document.getElementById("treeCanvas");
const treeCtx = treeCanvas.getContext("2d");

// Simulation state
let drifting = false;       // whether the evolution loop is running
let threeD = false;         // 3D holographic placeholder toggle
let species = [];           // list of all species agents
let nextId = 1;             // unique numeric ID for species
let nextName = 1;           // human-readable name counter (Species-001, etc.)
let simStep = 0;            // simulation steps counter
let cstTime = 0;            // CST-time τ (tau), global drift variable

// History of population states: logged periodically for CSV export
const history = [];

// Fixed "forces" drawn as anchor points: EM, Weak, Strong, Gravity
const forces = [
  { name:"EM",       x:0.78, y:0.72, color:"#38bdf8" },
  { name:"Weak",     x:0.65, y:0.55, color:"#f97316" },
  { name:"Strong",   x:0.88, y:0.82, color:"#22c55e" },
  { name:"Gravity",  x:0.35, y:0.40, color:"#e5e7eb" }
];

/* ============================================================
   DOM HOOKS — SLIDERS & BUTTONS
   ============================================================ */

const bandWidthIn   = document.getElementById("bandWidth");
const slopeIn       = document.getElementById("slope");
const evoWidthIn    = document.getElementById("evoWidth");
const extinctIn     = document.getElementById("extinctRadius");
const dnaCompIn     = document.getElementById("dnaComplex");
const mutationRateIn= document.getElementById("mutationRate");
const branchThIn    = document.getElementById("branchThreshold");
const mortalityIn   = document.getElementById("mortalityCurve");
const synIn         = document.getElementById("syntaxWeight");
const semIn         = document.getElementById("semanticWeight");
const cstDriftIn    = document.getElementById("cstDrift");
const brainWeightIn = document.getElementById("brainWeight");

const addBtn        = document.getElementById("addDNA");
const driftBtn      = document.getElementById("driftToggle");
const toggle3DBtn   = document.getElementById("toggle3D");
const exportBtn     = document.getElementById("exportCSV");
const csvOut        = document.getElementById("csvOut");
const cstLabel      = document.getElementById("cstLabel");

/* ============================================================
   COORDINATE UTILS
   ============================================================ */

/**
 * Convert normalized coordinates (0..1, 0..1) to canvas pixels.
 * x,y in [0,1] => (cx, cy) on screen, with padding around edges.
 */
function toCanvas(x, y){
  const pad = 60;
  const w = canvas.width  - pad*2;
  const h = canvas.height - pad*2;
  const cx = pad + x * w;
  const cy = canvas.height - pad - y * h;
  return { cx, cy };
}

/* ============================================================
   DRAWING THE BACKGROUND: AXES & BANDS
   ============================================================ */

function drawAxes(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Soft grid
  ctx.strokeStyle = "rgba(148,163,184,0.12)";
  for(let i=0;i<=10;i++){
    const x = (canvas.width/10)*i;
    const y = (canvas.height/10)*i;

    ctx.beginPath();
    ctx.moveTo(x,0); ctx.lineTo(x,canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0,y); ctx.lineTo(canvas.width,y);
    ctx.stroke();
  }

  // X/Y axes (phase-space interpretation)
  ctx.strokeStyle = "#9ca3af";
  // X axis
  ctx.beginPath();
  ctx.moveTo(60, canvas.height - 60);
  ctx.lineTo(canvas.width - 15, canvas.height - 60);
  ctx.stroke();
  // Y axis
  ctx.beginPath();
  ctx.moveTo(60, canvas.height - 60);
  ctx.lineTo(60, 15);
  ctx.stroke();

  // Axis labels (optional, conceptual)
  ctx.fillStyle = "#9ca3af";
  ctx.font = "11px system-ui";
  ctx.fillText("DNA / Syntax / Geometry →", canvas.width - 200, canvas.height - 42);
  ctx.save();
  ctx.translate(30, 100);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Fitness / Semantics / Brain Coherence ↑", 0, 0);
  ctx.restore();

  // If holographic mode is on, label it at the top
  if(threeD){
    ctx.fillStyle = "#a5b4fc";
    ctx.font = "11px system-ui";
    ctx.fillText("3D holographic placeholder: Z-axis = fitness (brightness, size, vertical offset)", 70, 30);
  }
}

/**
 * Generic band drawing for physics or evolution comfort regions.
 * width  = half-thickness of the band
 * slope  = linear slope of the center line y = slope * x
 * fill   = RGBA fill color
 * edge   = stroke color
 */
function drawBand(width, slope, fill, edge){
  const N = 150;
  ctx.beginPath();

  // Upper boundary y = slope*x + width
  for(let i=0;i<=N;i++){
    const x = i / N;
    let yT = slope * x + width;
    if(yT>1) yT = 1;
    const {cx, cy} = toCanvas(x, yT);
    if(i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
  }

  // Lower boundary y = slope*x - width
  for(let i=N;i>=0;i--){
    const x = i / N;
    let yB = slope * x - width;
    if(yB<0) yB = 0;
    const {cx, cy} = toCanvas(x, yB);
    ctx.lineTo(cx,cy);
  }

  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = edge;
  ctx.stroke();
}

/**
 * Draw fixed physics forces as anchor nodes.
 */
function drawForces(){
  for(const f of forces){
    const {cx,cy} = toCanvas(f.x, f.y);
    ctx.beginPath();
    ctx.arc(cx,cy,6,0,Math.PI*2);
    ctx.fillStyle = f.color;
    ctx.fill();

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px system-ui";
    ctx.fillText(f.name, cx+8, cy-8);
  }
}

/* ============================================================
   FITNESS MODEL
   ============================================================ */

/**
 * Compute the fitness of a given species, using:
 * - Distance from a dynamic diagonal band (syntax/semantics vs physics)
 * - Evolution band width
 * - Brain coherence attractor line
 * - Extinction radius (if too far off band)
 */
function computeFitness(sp){
  const evoWidth   = parseFloat(evoWidthIn.value);
  const extinctR   = parseFloat(extinctIn.value);
  const synW       = parseFloat(synIn.value);
  const semW       = parseFloat(semIn.value);
  const brainW     = parseFloat(brainWeightIn.value);
  const baseSlope  = parseFloat(slopeIn.value);
  const driftRate  = parseFloat(cstDriftIn.value);

  // A CST-driven wobble in slope: environment changes slowly over time.
  // As CST-time increases, we modulate the effective slope.
  const cstMod = 0.2 * Math.sin(cstTime * driftRate * 0.05);
  const effectiveSlope = baseSlope + cstMod;

  // Syntax/semantics diagonal line (target)
  const targetY = effectiveSlope * sp.x;
  const dist = Math.abs(sp.y - targetY);

  // Syntax & semantics fitness: closer to the line → better
  const syntaxFit   = Math.max(0, 1 - dist);
  const semanticFit = Math.max(0, 1 - dist);

  // Brain coherence attractor:
  // imagine a "neural" line y = 0.8x + 0.1 as a rough locus of coherent brains.
  const brainTargetY = 0.8 * sp.x + 0.1;
  const brainDist    = Math.abs(sp.y - brainTargetY);
  const brainCoherence = Math.max(0, 1 - brainDist * 1.2); // weight distance

  // Combine syntax, semantics, and brain coherence
  const combined = synW*syntaxFit + semW*semanticFit + brainW*brainCoherence;

  // Penalty if too far from the evolution band (dna penalty)
  const dnaPenalty = Math.min(1, (dist / evoWidth));

  let fitness = combined - dnaPenalty;
  fitness = Math.max(0, Math.min(1, fitness)); // clamp 0..1

  // Extinction flag: if too far off the band, the species is flagged as dying
  if(dist > extinctR){
    sp.extinct = true;
  }

  return fitness;
}

/* ============================================================
   DRAWING SPECIES POINTS
   ============================================================ */

function drawSpecies(){
  const extinctR = parseFloat(extinctIn.value);

  for(const sp of species){
    const f = computeFitness(sp);
    const {cx,cy} = toCanvas(sp.x, sp.y);

    // Color encodes fitness: greener = fitter
    const hue = 120 * f; // 0 (red) -> 120 (green)
    const baseLight = 40 + f*35;

    // Holographic mode: we use fitness as "height" (Z)
    // represented by size and a small vertical offset.
    let radius = 7;
    let yOffset = 0;
    if(threeD){
      radius = 5 + 8*f;           // bigger = higher in Z
      yOffset = -12 * (f - 0.5);  // slight vertical lift
    }

    ctx.beginPath();
    ctx.arc(cx, cy + yOffset, radius, 0, Math.PI*2);
    ctx.fillStyle = `hsl(${hue}, 75%, ${baseLight}%)`;
    ctx.fill();

    // Name of species (Species-001, Species-002...)
    ctx.fillStyle = "#e5e7eb";
    ctx.font = "10px system-ui";
    ctx.fillText(sp.name, cx + 10, cy - 10 + yOffset);

    // Extinction tag
    if(sp.extinct){
      ctx.save();
      ctx.fillStyle = "#ef4444";
      ctx.font = "10px system-ui";
      ctx.fillText("EXTINCT", cx + 10, cy + yOffset);
      ctx.restore();
    }
  }
}

/* ============================================================
   PHYLOGENETIC TREE DRAWING
   ============================================================ */

/**
 * Draws a simple parent-child tree: roots on left, children to the right,
 * sorted by birthStep vertically.
 */
function drawTree(){
  treeCtx.clearRect(0,0,treeCanvas.width,treeCanvas.height);

  if(species.length === 0) return;

  // Sort species by birth time (older at top)
  const sorted = [...species].sort((a,b)=>a.birthStep - b.birthStep);

  // Compute depth (generations) from parentId
  const depthMap = new Map(); // id -> depth
  function getDepth(sp){
    if(depthMap.has(sp.id)) return depthMap.get(sp.id);
    if(sp.parentId === null){
      depthMap.set(sp.id,0);
      return 0;
    }
    const parent = species.find(s=>s.id===sp.parentId);
    if(!parent){
      depthMap.set(sp.id,0);
      return 0;
    }
    const d = getDepth(parent)+1;
    depthMap.set(sp.id,d);
    return d;
  }
  sorted.forEach(sp => getDepth(sp));

  // Precompute node positions
  const nodePos = new Map(); // id -> {x,y}
  const maxDepth = Math.max(...sorted.map(sp => depthMap.get(sp.id)));
  const padX = 25;
  const padY = 20;
  const innerW = treeCanvas.width  - padX*2;
  const innerH = treeCanvas.height - padY*2;
  const stepY  = sorted.length>1 ? innerH/(sorted.length-1) : 0;
  const stepX  = maxDepth>0 ? innerW/maxDepth : 0;

  sorted.forEach((sp, i)=>{
    const depth = depthMap.get(sp.id);
    const x = padX + depth * stepX;
    const y = padY + i * stepY;
    nodePos.set(sp.id,{x,y});
  });

  // Draw edges (parent-child connections)
  treeCtx.strokeStyle = "rgba(148,163,184,0.7)";
  treeCtx.lineWidth = 1;
  for(const sp of sorted){
    if(sp.parentId !== null && nodePos.has(sp.parentId)){
      const parentPos = nodePos.get(sp.parentId);
      const childPos  = nodePos.get(sp.id);
      treeCtx.beginPath();
      treeCtx.moveTo(parentPos.x+4, parentPos.y);
      treeCtx.lineTo(childPos.x-4, childPos.y);
      treeCtx.stroke();
    }
  }

  // Draw nodes
  for(const sp of sorted){
    const pos = nodePos.get(sp.id);
    const f = computeFitness(sp);
    const radius = 3 + 3*f; // fittest species look slightly larger

    treeCtx.beginPath();
    treeCtx.arc(pos.x,pos.y,radius,0,Math.PI*2);
    treeCtx.fillStyle = sp.extinct ? "#f97373" : "#22c55e";
    treeCtx.fill();

    treeCtx.fillStyle = "#e5e7eb";
    treeCtx.font = "8px system-ui";
    treeCtx.fillText(sp.name, pos.x+5, pos.y+3);
  }
}

/* ============================================================
   EVOLUTION / DRIFT LOOP
   ============================================================ */

/**
 * Main simulation loop; runs while `drifting === true`.
 * Handles:
 * - Mutation (random drift in x,y)
 * - Station-locking toward band
 * - Branching (speciation) when conditions are good
 * - Mortality (age-based + environment accidents)
 * - Logging history
 */
function driftLoop(){
  if(!drifting) return;

  simStep++;

  const dnaStep    = parseFloat(dnaCompIn.value);
  const evoWidth   = parseFloat(evoWidthIn.value);
  const mutRate    = parseFloat(mutationRateIn.value);
  const branchTh   = parseFloat(branchThIn.value);
  const mortality  = parseFloat(mortalityIn.value);
  const driftRate  = parseFloat(cstDriftIn.value);

  // Increment CST-time (τ)
  cstTime += driftRate * 0.01;
  cstLabel.textContent = `CST-time τ = ${cstTime.toFixed(2)}`;

  // We’ll accumulate children here so we don't mutate the species list
  // while iterating over it.
  const newSpeciesToAdd = [];

  for(const sp of species){
    if(sp.extinct) {
      sp.age += 1;
      continue;
    }

    // Age up
    sp.age += 1;

    // MUTATION / DRIFT:
    // With probability `mutRate`, apply a random step influenced by dnaStep.
    if(Math.random() < mutRate){
      sp.x += (Math.random()-0.5) * 0.01 * dnaStep;
      sp.y += (Math.random()-0.5) * 0.01 * dnaStep;
    }

    // STATION-LOCKING:
    // If species is within evoWidth band, gently pulled toward the diagonal.
    const baseSlope  = parseFloat(slopeIn.value);
    const cstMod     = 0.2 * Math.sin(cstTime * driftRate * 0.05);
    const effectiveSlope = baseSlope + cstMod;
    const targetY    = effectiveSlope * sp.x;
    const dist       = Math.abs(sp.y - targetY);

    if(dist < evoWidth){
      // Move 5% toward the preferred band (station-lock)
      sp.y += (targetY - sp.y) * 0.05;
    }

    // BRANCHING (SPECIATION):
    // If very well aligned (dist small) and random chance, branch.
    // The branching threshold slider controls how strict this is.
    const branchingWindow = evoWidth * branchTh;
    if(dist < branchingWindow && Math.random() < 0.003){
      const child = {
        id: nextId++,
        name: "Species-" + String(nextName++).padStart(3,'0'),
        parentId: sp.id,
        x: sp.x + (Math.random()-0.5)*0.04,
        y: sp.y + (Math.random()-0.5)*0.04,
        extinct: false,
        age: 0,
        birthStep: simStep
      };
      newSpeciesToAdd.push(child);
    }

    // EXTINCTION CONDITION from distance:
    if(dist > parseFloat(extinctIn.value)){
      sp.extinct = true;
    }

    // MORTALITY CURVE:
    // Age-based + random hazard. Mortality slider scales the risk.
    const ageFactor = sp.age / 2000; // older → higher risk
    let deathProb = 0.0005 + mortality * 0.003 + mortality * ageFactor;
    if(Math.random() < deathProb){
      sp.extinct = true;
    }

    // Keep species inside [0,1] bounds
    sp.x = Math.max(0, Math.min(1, sp.x));
    sp.y = Math.max(0, Math.min(1, sp.y));
  }

  // Add new branches after we loop
  for(const child of newSpeciesToAdd){
    species.push(child);
  }

  // Log history every N steps to keep CSV manageable
  const logEvery = 15;
  if(simStep % logEvery === 0){
    for(const sp of species){
      const f = computeFitness(sp);
      history.push({
        step: simStep,
        cst: cstTime,
        id: sp.id,
        name: sp.name,
        x: sp.x,
        y: sp.y,
        fitness: f,
        extinct: sp.extinct
      });
    }
  }

  // Redraw everything
  redraw();

  // Request the next frame
  requestAnimationFrame(driftLoop);
}

/* ============================================================
   REDRAW WRAPPER
   ============================================================ */

function redraw(){
  drawAxes();

  // Physics band
  drawBand(
    parseFloat(bandWidthIn.value),
    parseFloat(slopeIn.value),
    "rgba(79,70,229,0.15)",
    "rgba(129,140,248,0.55)"
  );

  // Evolutionary band (syntax/semantics comfort region)
  drawBand(
    parseFloat(evoWidthIn.value),
    1.0,
    "rgba(14,165,233,0.12)",
    "rgba(14,165,233,0.6)"
  );

  drawForces();
  drawSpecies();
  drawTree();
}

/* ============================================================
   UI ACTIONS
   ============================================================ */

// Add a new root species at a random location
addBtn.onclick = ()=>{
  const sp = {
    id: nextId++,
    name: "Species-" + String(nextName++).padStart(3,'0'),
    parentId: null,
    x: Math.random()*0.9 + 0.05,
    y: Math.random()*0.9 + 0.05,
    extinct: false,
    age: 0,
    birthStep: simStep
  };
  species.push(sp);
  redraw();
};

// Start / stop drift
driftBtn.onclick = ()=>{
  drifting = !drifting;
  driftBtn.textContent = drifting ? "Stop Drift" : "Start Drift";
  if(drifting) driftLoop();
};

// Toggle 3D holographic placeholder
toggle3DBtn.onclick = ()=>{
  threeD = !threeD;
  if(threeD){
    alert("3D holographic mode: Z axis encoded in point size, brightness, and vertical offset.\nRotation & full 3D next upgrade.");
  }
  redraw();
};

// Export population history to CSV
exportBtn.onclick = ()=>{
  let rows = ["Step,CST_Time,SpeciesName,X,Y,Fitness,Extinct"];
  for(const h of history){
    rows.push(
      `${h.step},${h.cst.toFixed(3)},${h.name},${h.x.toFixed(3)},${h.y.toFixed(3)},${h.fitness.toFixed(3)},${h.extinct}`
    );
  }
  csvOut.textContent = rows.join("\n");
};

/* SLIDERS REDRAW ON INPUT */
[
  bandWidthIn, slopeIn, evoWidthIn, extinctIn,
  dnaCompIn, mutationRateIn, branchThIn, mortalityIn,
  synIn, semIn, cstDriftIn, brainWeightIn
].forEach(el => {
  el.oninput = redraw;
});

// Initial draw
redraw();
</script>
</body>
</html>
