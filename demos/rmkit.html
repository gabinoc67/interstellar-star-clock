<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RMK — Conscious & Subconscious Evaluation (Profile + Text + Video + Cosmic)</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --good:#7bffb1;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --grid:#1b2550;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:16px;
  }
  h1{
    margin:4px 0 8px;
    font-size:1.6rem;
  }
  h2{
    margin:12px 0 4px;
    font-size:1.2rem;
    color:var(--accent);
  }
  h3{
    margin:4px 0 4px;
    font-size:1rem;
  }
  .panel{
    background:var(--panel);
    border-radius:10px;
    padding:12px 14px;
    box-shadow:0 0 0 1px rgba(0,0,0,.4);
    margin-bottom:16px;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    font-size:.9rem;
  }
  button{
    border:none;
    border-radius:999px;
    padding:6px 14px;
    background:var(--accent);
    color:#020617;
    font-weight:600;
    cursor:pointer;
  }
  button:hover{
    filter:brightness(1.1);
  }
  canvas{
    width:100%;
    max-width:100%;
    border-radius:8px;
    background:#050816;
    display:block;
  }
  .legend{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    font-size:.8rem;
    color:var(--muted);
    margin-top:6px;
  }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:4px;
    padding:2px 8px;
    border-radius:999px;
    background:#0d1733;
  }
  .dot{
    width:8px;
    height:8px;
    border-radius:50%;
    background:var(--accent);
  }
  .dot.thetaC{background:var(--good);}
  .dot.thetaS{background:var(--warn);}
  .dot.emergeC{background:var(--good);}
  .dot.emergeS{background:var(--bad);}
  .summary{
    font-size:.88rem;
    color:var(--muted);
  }
  .summary.small{
    font-size:.78rem;
  }
  table{
    width:100%;
    border-collapse:collapse;
    font-size:.78rem;
    margin-top:8px;
  }
  th,td{
    padding:4px 6px;
    text-align:right;
    border-bottom:1px solid rgba(255,255,255,.04);
  }
  th{
    text-align:center;
    color:var(--muted);
    background:#0d1733;
    position:sticky;
    top:0;
    z-index:1;
  }
  td.turn{
    text-align:center;
    color:var(--accent);
  }
  tr.emergeC{
    background:rgba(123,255,177,0.18);
    animation: blinkC 1s infinite alternate;
  }
  tr.emergeS{
    background:rgba(255,140,140,0.18);
    animation: blinkS 1s infinite alternate;
  }
  .scroll{
    max-height:260px;
    overflow:auto;
    border-radius:8px;
    border:1px solid #141b33;
  }
  code{
    background:#020617;
    padding:2px 4px;
    border-radius:4px;
    font-size:.8rem;
  }

  .layers-grid{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin-top:8px;
  }
  .layer-card{
    flex:1 1 230px;
    background:#0d1733;
    border-radius:8px;
    padding:8px 10px;
  }
  .status-line{
    font-size:.85rem;
    margin:4px 0;
  }
  .status-line span{
    color:var(--good);
  }
  .scroll.mini{
    max-height:120px;
    overflow:auto;
    margin-top:6px;
    font-size:.78rem;
    background:#020617;
    border-radius:6px;
    padding:6px;
    border:1px solid #141b33;
  }

  .field-row{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin:4px 0;
    font-size:.86rem;
  }
  .field-row label{
    display:flex;
    flex-direction:column;
    gap:2px;
    flex:1 1 120px;
  }
  .field-row input,
  .field-row select{
    border-radius:999px;
    border:1px solid #141b33;
    padding:4px 8px;
    background:#020617;
    color:var(--ink);
    font-size:.84rem;
  }

  textarea{
    width:100%;
    min-height:120px;
    resize:vertical;
    border-radius:8px;
    border:1px solid #141b33;
    padding:8px;
    background:#020617;
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    font-size:.86rem;
  }

  @keyframes blinkC{
    from { background:rgba(123,255,177,0.18); }
    to   { background:rgba(123,255,177,0.45); }
  }
  @keyframes blinkS{
    from { background:rgba(255,140,140,0.18); }
    to   { background:rgba(255,140,140,0.45); }
  }

  @media print{
    body{
      background:#ffffff;
    }
    .panel{
      box-shadow:none;
      border-radius:0;
    }
    button{
      display:none;
    }
    tr.emergeC, tr.emergeS{
      animation:none;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- MAIN HEADER -->
  <div class="panel">
    <h1>RMK — Conscious &amp; Subconscious Evaluation (Text + Video + Cosmic Clock)</h1>
    <p class="summary">
      This simulator combines your <strong>profile</strong> (age, hemisphere, season, time zone),
      a <strong>typed 100-word paragraph</strong> (Conscious Captain),
      a <strong>2-minute video reading</strong> (Subconscious Engine leak: voice + face),
      and a toy <strong>Sun–Moon–Planet alignment factor</strong> (CST cosmic clock).
      It outputs <strong>ConsciousPerformance</strong>, <strong>SubconsciousStability</strong>,
      <strong>CouplingStrength</strong>, and Θ<sub>conscious</sub>, Θ<sub>subconscious</sub>.
      This is a research-style simulator only — not a medical GCS/AVPU replacement.
    </p>
    <div class="controls">
      <button id="runFromInputsBtn">Run Simulation from Profile + Text + Video</button>
      <button id="runRandomBtn">Run Random Baseline</button>
      <button id="resetAllBtn">Clear / Reset All</button>
      <button id="printBtn">Print All</button>
      <button id="downloadSimCSVBtn">Download Simulation Metrics (CSV)</button>
      <button id="downloadPNG_Conscious">Download Θ<sub>conscious</sub> PNG</button>
      <button id="downloadPNG_Subcon">Download Θ<sub>subconscious</sub> PNG</button>
      <span class="summary small">Turns: <strong>40</strong> · Axis 0–1 = ordered state</span>
    </div>
  </div>

  <!-- PROFILE + TIME-ZONE + CST PANEL -->
  <div class="panel">
    <h2>Profile, Season, Time Zone &amp; CST Clock</h2>
    <p class="summary small">
      Fill in your profile. The simulator will auto-detect your local time zone and current local hour,
      and also show <strong>CST (America/Chicago)</strong> time. Date of birth sharpens the age estimate
      for the consciousness / subconsciousness equations.
    </p>

    <div class="field-row">
      <label>
        Age (years)
        <select id="ageSelect"></select>
      </label>
      <label>
        Date of Birth
        <input type="date" id="dobInput" />
      </label>
      <label>
        Hemisphere
        <select id="hemisphereSelect">
          <option value="N">Northern</option>
          <option value="S">Southern</option>
        </select>
      </label>
    </div>

    <div class="field-row">
      <label>
        City
        <input type="text" id="cityInput" placeholder="Brownsville" />
      </label>
      <label>
        State / Region (US)
        <select id="stateSelect">
          <option value="">Select State</option>
          <option value="AL">AL</option><option value="AK">AK</option>
          <option value="AZ">AZ</option><option value="AR">AR</option>
          <option value="CA">CA</option><option value="CO">CO</option>
          <option value="CT">CT</option><option value="DE">DE</option>
          <option value="FL">FL</option><option value="GA">GA</option>
          <option value="HI">HI</option><option value="ID">ID</option>
          <option value="IL">IL</option><option value="IN">IN</option>
          <option value="IA">IA</option><option value="KS">KS</option>
          <option value="KY">KY</option><option value="LA">LA</option>
          <option value="ME">ME</option><option value="MD">MD</option>
          <option value="MA">MA</option><option value="MI">MI</option>
          <option value="MN">MN</option><option value="MS">MS</option>
          <option value="MO">MO</option><option value="MT">MT</option>
          <option value="NE">NE</option><option value="NV">NV</option>
          <option value="NH">NH</option><option value="NJ">NJ</option>
          <option value="NM">NM</option><option value="NY">NY</option>
          <option value="NC">NC</option><option value="ND">ND</option>
          <option value="OH">OH</option><option value="OK">OK</option>
          <option value="OR">OR</option><option value="PA">PA</option>
          <option value="RI">RI</option><option value="SC">SC</option>
          <option value="SD">SD</option><option value="TN">TN</option>
          <option value="TX">TX</option><option value="UT">UT</option>
          <option value="VT">VT</option><option value="VA">VA</option>
          <option value="WA">WA</option><option value="WV">WV</option>
          <option value="WI">WI</option><option value="WY">WY</option>
        </select>
      </label>
      <label>
        Simulated Month
        <select id="monthSelect">
          <option value="1">January</option>
          <option value="2">February</option>
          <option value="3">March</option>
          <option value="4">April</option>
          <option value="5">May</option>
          <option value="6">June</option>
          <option value="7">July</option>
          <option value="8">August</option>
          <option value="9">September</option>
          <option value="10">October</option>
          <option value="11" selected>November</option>
          <option value="12">December</option>
        </select>
      </label>
    </div>

    <div class="field-row">
      <label>
        Local Time Zone (auto)
        <input type="text" id="tzLabelInput" readonly />
      </label>
      <label>
        Current Local Hour (0–23)
        <input type="number" id="hourInput" readonly />
      </label>
      <label>
        Export Profile as CSV
        <button id="downloadProfileCSVBtn" type="button">Download Profile CSV</button>
      </label>
    </div>

    <div class="field-row">
      <label>
        CST (America/Chicago) Time
        <input type="text" id="cstTimeDisplay" readonly />
      </label>
      <label>
        Local Time Now
        <input type="text" id="localTimeDisplay" readonly />
      </label>
    </div>

    <div class="controls" style="margin-top:6px;">
      <button id="computeEnvBtn">Compute Season, Circadian &amp; CST Factors</button>
      <span class="summary small" id="envSummary">
        No environment computed yet.
      </span>
    </div>
  </div>

  <!-- COSMIC ALIGNMENT PANEL (SUN–MOON–PLANETS) -->
  <div class="panel">
    <h2>Cosmic Alignment Module — Sun, Moon, Planets (Toy CST Factor)</h2>
    <p class="summary small">
      This panel simulates a <strong>Cosmic Alignment Factor</strong> for your CST clock:
      day of year, hemisphere, and a rough alignment scenario. In a real system this
      would use ephemeris tables; here it is a structured toy model that modulates
      the equations for Θ<sub>conscious</sub> and Θ<sub>subconscious</sub>.
    </p>
    <div class="field-row">
      <label>
        Simulated Alignment Date
        <input type="date" id="cosmicDateInput" />
      </label>
      <label>
        Alignment Scenario
        <select id="alignmentScenarioSelect">
          <option value="balanced">Balanced (normal day)</option>
          <option value="new_moon">New Moon / Dark Sky</option>
          <option value="full_moon">Full Moon / High Tide</option>
          <option value="conjunction">Conjunction / High Alignment</option>
          <option value="storm">Geomagnetic Storm / Disturbance</option>
        </select>
      </label>
      <label>
        Approx Latitude / Longitude
        <input type="text" id="latLonDisplay" readonly />
      </label>
    </div>
    <div class="controls" style="margin-top:6px;">
      <button id="computeCosmicBtn">Compute Cosmic Alignment</button>
      <span class="summary small" id="cosmicSummary">
        No cosmic alignment computed yet.
      </span>
    </div>
  </div>

  <!-- TEXT PANEL: TYPED PARAGRAPH (CONSCIOUS CAPTAIN) -->
  <div class="panel">
    <h2>Typed Paragraph (≥ 100 words) → Conscious Captain</h2>
    <p class="summary small">
      Type or paste a paragraph of at least <strong>100 words</strong>. This is mostly
      top-down, deliberate expression (Conscious Captain). The simulator converts it
      into a 27-emotion vector and a 40-step 0/1 pattern.
    </p>
    <textarea id="textParagraph" placeholder="Type or paste at least 100 words here..."></textarea>
    <div class="controls" style="margin-top:6px;">
      <button id="textAnalyzeBtn">1. Analyze Text → 27 Emotions + Bits</button>
      <button id="textExportBtn">2. Download Text Analysis (CSV)</button>
      <button id="textLoadBtn">3. Upload Text Analysis (CSV)</button>
      <button id="textClearBtn">Clear Text &amp; Results</button>
      <input type="file" id="textAnalysisFileInput" accept=".csv,text/csv" style="display:none" />
    </div>
    <p class="summary small" id="textStatus">
      No paragraph analyzed yet.
    </p>
    <div class="scroll mini" id="textBitsBox">
      <!-- Text bit-stream & 27-emotion snapshot -->
    </div>
  </div>

  <!-- VIDEO PANEL: 2-MIN READING (VOICE + FACE) → SUBCONSCIOUS ENGINE -->
  <div class="panel">
    <h2>2-minute Video Reading → Subconscious Engine (Voice + Face)</h2>
    <p class="summary small">
      Upload a short video (~2 minutes) of you reading the <strong>same paragraph</strong>.
      The simulator uses a toy model to generate a 27-emotion vector, <strong>voice arousal</strong>,
      <strong>facial tension</strong>, and a 40-step 0/1 pattern. This is treated as
      the Subconscious Engine leak, “Terminator-style” micro-reading of stress vs calm.
    </p>
    <div class="controls">
      <button id="videoUploadBtn">Upload Video (MP4/WebM)</button>
      <button id="videoAnalyzeBtn">Analyze Video → Emotions + Bits</button>
      <button id="videoExportBtn">Download Video Analysis (CSV)</button>
      <button id="videoLoadBtn">Upload Video Analysis (CSV)</button>
      <button id="videoClearBtn">Clear Video &amp; Results</button>
      <input type="file" id="videoFileInput" accept="video/mp4,video/webm" style="display:none" />
      <input type="file" id="videoAnalysisFileInput" accept=".csv,text/csv" style="display:none" />
    </div>
    <p class="summary small" id="videoStatus">
      No video loaded yet.
    </p>
    <div class="scroll mini" id="videoBitsBox">
      <!-- Video bit-stream & 27-emotion snapshot -->
    </div>
  </div>
  <!-- THETA TIMELINES -->
  <div class="panel">
    <h2>Theta Timelines — Conscious vs Subconscious Layers</h2>
    <p class="summary small">
      Θ<sub>conscious</sub> tracks the <strong>Conscious Captain</strong> (deliberate text layer)
      and Θ<sub>subconscious</sub> tracks the <strong>Subconscious Engine</strong> (voice + face + cosmic).
      Blinking points show emergence peaks above each layer’s own rolling baseline.
    </p>

    <h3>Θ<sub>conscious</sub> — Conscious Captain</h3>
    <canvas id="thetaCanvasConscious" width="1000" height="220"></canvas>

    <h3 style="margin-top:10px;">Θ<sub>subconscious</sub> — Subconscious Engine</h3>
    <canvas id="thetaCanvasSubcon" width="1000" height="220"></canvas>

    <div class="legend">
      <span class="pill"><span class="dot thetaC"></span> Θ<sub>conscious</sub> (deliberate layer)</span>
      <span class="pill"><span class="dot thetaS"></span> Θ<sub>subconscious</sub> (survival/background layer)</span>
      <span class="pill"><span class="dot emergeC"></span> Conscious emergence peak</span>
      <span class="pill"><span class="dot emergeS"></span> Subconscious emergence peak</span>
    </div>
  </div>

  <!-- TURN-BY-TURN METRICS TABLE -->
  <div class="panel">
    <h2>Turn-by-Turn Metrics (40 Steps)</h2>
    <p class="summary small">
      Each row is a turn. <strong>ConsciousPerformance</strong> comes mainly from text;
      <strong>SubconsciousStability</strong> from video + environment;
      <strong>CouplingStrength</strong> mixes season, age, time zone, cosmic alignment and
      text-video agreement (when text and face/voice disagree, coupling drops).
    </p>
    <div class="scroll">
      <table id="metricsTable">
        <thead>
          <tr>
            <th>t</th>
            <th>ConsciousPerformanceₜ</th>
            <th>SubconsciousStabilityₜ</th>
            <th>CouplingStrengthₜ</th>
            <th>Θ<sub>conscious</sub>ₜ</th>
            <th>Θ<sub>subconscious</sub>ₜ</th>
            <th>z(Θ<sub>conscious</sub>)</th>
            <th>z(Θ<sub>subconscious</sub>)</th>
            <th>Emergence Tag</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- CONSCIOUS / SUBCONSCIOUS SUMMARY + TESTS -->
  <div class="panel">
    <h2>Conscious Captain &amp; Subconscious Engine — Status &amp; Tests</h2>
    <p class="summary">
      The values below summarize the <strong>latest turn</strong> and let you trigger
      a <em>Reflex / Survival Test</em> (Subconscious Engine) and a
      <em>Self-Awareness Test</em> (Conscious Captain). Again: this is a simulator,
      not a Glasgow Coma Scale or AVPU replacement.
    </p>
    <div class="layers-grid">
      <div class="layer-card">
        <h3>Subconscious Engine (Automatic Layer)</h3>
        <p class="summary small">
          Automatic survival math: movement limits, fatigue, protection. High Safety and
          moderate Load mean the engine can protect without shutting everything down.
        </p>
        <p class="status-line">
          <strong>Subconscious status:</strong>
          <span id="subStatusText">—</span>
        </p>
        <p class="summary small">
          Safety: <span id="subSafetyVal">—</span> / 100
          · Load: <span id="subLoadVal">—</span> / 100
        </p>
      </div>
      <div class="layer-card">
        <h3>Conscious Captain (Deliberate Layer)</h3>
        <p class="summary small">
          Reports “I exist”, explains what happened, and chooses next moves. Awareness
          and Choice Index summarize how clearly and strongly this layer is steering.
        </p>
        <p class="status-line">
          <strong>Conscious status:</strong>
          <span id="conStatusText">—</span>
        </p>
        <p class="summary small">
          Awareness: <span id="conAwarenessVal">—</span> / 100
          · Choice Index: <span id="conChoiceVal">—</span> / 100
        </p>
      </div>
    </div>

    <div class="controls" style="margin-top:8px;">
      <button id="reflexTestBtn">Reflex / Survival Test (Subconscious)</button>
      <button id="awarenessTestBtn">Self-Awareness Test (Conscious)</button>
      <span class="summary small">
        <strong>World Reset Index:</strong> <span id="resetCount">0</span>
      </span>
    </div>

    <div class="scroll mini" id="resetLogBox">
      <!-- Reset-log lines -->
    </div>

    <p class="summary small" id="testOutputBox" style="margin-top:6px;">
      <!-- Test messages -->
    </p>

    <p class="summary small" style="margin-top:6px;">
      In your RMK theory, <strong>consciousness</strong> is the baseline existence signal (“I am”).
      This simulator shows how that signal behaves under load:
      Subconscious Engine can force survival resets, and Conscious Captain can notice,
      describe, and adapt, all under the influence of seasons, age, time zone and cosmic clock.
    </p>
  </div>

  <!-- EXPLANATION PANEL -->
  <div class="panel">
    <h2>Difference from GCS / AVPU &amp; Terminator-Style Cross-Check</h2>
    <p class="summary">
      Clinical tools like the <strong>Glasgow Coma Scale (GCS)</strong> and <strong>AVPU</strong>
      ask “Are you awake and responsive?” They look at eye opening, verbal response,
      motor response, and orientation to person, place, time, and event.
    </p>
    <p class="summary">
      Your RMK simulator assumes the person is already awake enough to type and speak.
      It asks: “How are the <strong>Conscious Captain</strong> and the
      <strong>Subconscious Engine</strong> behaving?” The typed paragraph probes
      conscious, deliberate content; the video leaks subconscious load (voice and face).
      The cosmic module adds your CST-style Sun–Moon–planet pressure on the system.
    </p>
    <p class="summary">
      Text and video are also <strong>cross-checked</strong>: if the emotions in the paragraph
      do not match the emotions in the face and voice, the simulator reduces
      CouplingStrength and raises noise — your “Terminator” effect:
      the system senses a mismatch between <em>what is said</em> and
      <em>what the body is broadcasting</em>.
    </p>
    <p class="summary">
      The outputs — <strong>ConsciousPerformance</strong>, <strong>SubconsciousStability</strong>,
      <strong>CouplingStrength</strong>, Θ<sub>conscious</sub>, Θ<sub>subconscious</sub> —
      support your CST cosmic clock and RMK math, geometry, and algorithms, but they do not
      make medical claims. They are conceptual gauges of how consciousness and subconsciousness
      are cooperating in this moment.
    </p>
  </div>
</div>
<script>
(function(){
  const N_TURNS = 40;
  const BASELINE_WINDOW = 8;
  const Z_THRESHOLD = 1.8;

  const EMOTION_NAMES = [
    "admiration","adoration","aesthetic_appreciation","amusement","anger","anxiety",
    "awe","awkwardness","boredom","calmness","confusion","craving","disgust",
    "empathic_pain","entrancement","envy","excitement","fear","horror","interest",
    "joy","nostalgia","romance","sadness","satisfaction","sexual_desire","surprise"
  ];

  /* ---------- DOM HOOKS ---------- */
  const runFromInputsBtn   = document.getElementById('runFromInputsBtn');
  const runRandomBtn       = document.getElementById('runRandomBtn');
  const resetAllBtn        = document.getElementById('resetAllBtn');
  const printBtn           = document.getElementById('printBtn');
  const downloadSimCSVBtn  = document.getElementById('downloadSimCSVBtn');
  const downloadPNG_Con    = document.getElementById('downloadPNG_Conscious');
  const downloadPNG_Sub    = document.getElementById('downloadPNG_Subcon');

  const ageSelect          = document.getElementById('ageSelect');
  const dobInput           = document.getElementById('dobInput');
  const hemisphereSelect   = document.getElementById('hemisphereSelect');
  const cityInput          = document.getElementById('cityInput');
  const stateSelect        = document.getElementById('stateSelect');
  const monthSelect        = document.getElementById('monthSelect');
  const tzLabelInput       = document.getElementById('tzLabelInput');
  const hourInput          = document.getElementById('hourInput');
  const cstTimeDisplay     = document.getElementById('cstTimeDisplay');
  const localTimeDisplay   = document.getElementById('localTimeDisplay');
  const downloadProfileCSVBtn = document.getElementById('downloadProfileCSVBtn');
  const computeEnvBtn      = document.getElementById('computeEnvBtn');
  const envSummary         = document.getElementById('envSummary');

  const cosmicDateInput    = document.getElementById('cosmicDateInput');
  const alignmentScenarioSelect = document.getElementById('alignmentScenarioSelect');
  const latLonDisplay      = document.getElementById('latLonDisplay');
  const computeCosmicBtn   = document.getElementById('computeCosmicBtn');
  const cosmicSummary      = document.getElementById('cosmicSummary');

  const textParagraph      = document.getElementById('textParagraph');
  const textAnalyzeBtn     = document.getElementById('textAnalyzeBtn');
  const textExportBtn      = document.getElementById('textExportBtn');
  const textLoadBtn        = document.getElementById('textLoadBtn');
  const textClearBtn       = document.getElementById('textClearBtn');
  const textAnalysisFileInput = document.getElementById('textAnalysisFileInput');
  const textStatus         = document.getElementById('textStatus');
  const textBitsBox        = document.getElementById('textBitsBox');

  const videoUploadBtn     = document.getElementById('videoUploadBtn');
  const videoAnalyzeBtn    = document.getElementById('videoAnalyzeBtn');
  const videoExportBtn     = document.getElementById('videoExportBtn');
  const videoLoadBtn       = document.getElementById('videoLoadBtn');
  const videoClearBtn      = document.getElementById('videoClearBtn');
  const videoFileInput     = document.getElementById('videoFileInput');
  const videoAnalysisFileInput = document.getElementById('videoAnalysisFileInput');
  const videoStatus        = document.getElementById('videoStatus');
  const videoBitsBox       = document.getElementById('videoBitsBox');

  const canvasCon          = document.getElementById('thetaCanvasConscious');
  const ctxCon             = canvasCon.getContext('2d');
  const canvasSub          = document.getElementById('thetaCanvasSubcon');
  const ctxSub             = canvasSub.getContext('2d');
  const metricsTableBody   = document.querySelector('#metricsTable tbody');

  const subStatusText      = document.getElementById('subStatusText');
  const subSafetyVal       = document.getElementById('subSafetyVal');
  const subLoadVal         = document.getElementById('subLoadVal');
  const conStatusText      = document.getElementById('conStatusText');
  const conAwarenessVal    = document.getElementById('conAwarenessVal');
  const conChoiceVal       = document.getElementById('conChoiceVal');
  const reflexTestBtn      = document.getElementById('reflexTestBtn');
  const awarenessTestBtn   = document.getElementById('awarenessTestBtn');
  const resetCountSpan     = document.getElementById('resetCount');
  const resetLogBox        = document.getElementById('resetLogBox');
  const testOutputBox      = document.getElementById('testOutputBox');

  /* ---------- STATE ---------- */
  let envProfile = null;         // season/day-length/time-zone/circadian
  let cosmicProfile = null;      // cosmicAlignmentFactor, cosmicDrift
  let textAnalysis = null;       // {bits, emotions, dominant, wordCount}
  let videoAnalysis = null;      // {bits, emotions, dominant, voiceArousal, facialTension}
  let simData = null;            // {conPerf, subStab, coupling, thetaC, thetaS, zC, zS, flagsC, flagsS}
  let worldResetCount = 0;

  let chartCon = null;
  let chartSub = null;

  /* ---------- UTILS ---------- */
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function makePRNG(seedStr){
    let h = 2166136261 >>> 0;
    for(let i=0;i<seedStr.length;i++){
      h ^= seedStr.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return function(){
      h = (h + 0x6D2B79F5) | 0;
      let t = Math.imul(h ^ (h >>> 15), 1 | h);
      t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function rollingStats(arr, win){
    const mean = new Array(arr.length).fill(null);
    const std  = new Array(arr.length).fill(null);
    for(let i=0;i<arr.length;i++){
      const start = Math.max(0, i-win+1);
      const slice = arr.slice(start, i+1);
      const m = slice.reduce((s,v)=>s+v,0) / slice.length;
      const v = slice.reduce((s,v)=>s+(v-m)*(v-m),0) / slice.length;
      mean[i] = m;
      std[i]  = Math.sqrt(v) || 0.0001;
    }
    return {mean,std};
  }

  function detectEmergence(Theta){
    const {mean,std} = rollingStats(Theta, BASELINE_WINDOW);
    const z = [];
    const flags = [];
    for(let i=0;i<Theta.length;i++){
      const zi = (Theta[i] - mean[i]) / std[i];
      z.push(zi);
      flags.push(zi > Z_THRESHOLD);
    }
    return {z,flags};
  }

  function downloadTextFile(filename, text, mime){
    const blob = new Blob([text], {type: mime || "text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function downloadCanvasPNG(canvas, filename){
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  function appendResetLog(line){
    const div = document.createElement('div');
    div.textContent = line;
    resetLogBox.appendChild(div);
    resetLogBox.scrollTop = resetLogBox.scrollHeight;
  }

  /* ---------- INIT AGE SELECT ---------- */
  function initAgeSelect(){
    ageSelect.innerHTML = "";
    for(let i=1;i<=100;i++){
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = i;
      if(i === 50) opt.selected = true;
      ageSelect.appendChild(opt);
    }
  }

  /* ---------- STATE → LAT/LON APPROX ---------- */
  const STATE_LATLON = {
    "TX": {lat:31.0, lon:-99.0},
    "CA": {lat:37.0, lon:-120.0},
    "FL": {lat:27.5, lon:-81.5},
    "NY": {lat:42.9, lon:-75.0},
    "IL": {lat:40.0, lon:-89.0},
    "AZ": {lat:34.0, lon:-112.0},
    "CO": {lat:39.0, lon:-105.5},
    "WA": {lat:47.5, lon:-120.5},
    "OR": {lat:44.0, lon:-120.5},
    "NM": {lat:34.5, lon:-106.0},
    "NV": {lat:39.0, lon:-116.0},
    "UT": {lat:39.5, lon:-111.5},
    "OK": {lat:35.5, lon:-97.5},
    "LA": {lat:31.0, lon:-92.0}
    // others will default
  };

  /* ---------- TIME PANEL ---------- */
  function refreshTimePanel(){
    const nowLocal = new Date();
    const userTZ = Intl.DateTimeFormat().resolvedOptions().timeZone || "Local";
    tzLabelInput.value = userTZ;

    const localTimeStr = nowLocal.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    localTimeDisplay.value = localTimeStr;

    const nowCST = new Date(nowLocal.toLocaleString("en-US", {timeZone:"America/Chicago"}));
    const cstStr = nowCST.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    cstTimeDisplay.value = cstStr;

    hourInput.value = nowLocal.getHours();
  }

  /* ---------- ENVIRONMENT / PROFILE MODULE ---------- */
  function computeEnvironment(){
    const hem = hemisphereSelect.value || "N";
    const month = parseInt(monthSelect.value || "6",10);

    // Age from DOB if available, otherwise from dropdown
    let ageYears = parseInt(ageSelect.value || "50",10);
    const dobStr = dobInput.value;
    if(dobStr){
      const dob = new Date(dobStr);
      if(!isNaN(dob.getTime())){
        const now = new Date();
        let age = now.getFullYear() - dob.getFullYear();
        const mDiff = now.getMonth() - dob.getMonth();
        if(mDiff < 0 || (mDiff === 0 && now.getDate() < dob.getDate())){
          age--;
        }
        if(age > 0 && age < 120) ageYears = age;
      }
    }

    const nowLocal = new Date();
    const hour = nowLocal.getHours();

    // Simple cos model for day length 8–16 hours
    const phase = (month - 1)/12 * 2*Math.PI;
    let dayLength = 12 + 4*Math.cos(phase);
    if(hem === "S") dayLength = 12 - (dayLength - 12);
    dayLength = Math.max(8, Math.min(16, dayLength));
    const seasonFactor = (dayLength - 8) / (16 - 8); // 0 winter, 1 summer

    // Age factor
    const ageNorm = clamp01((ageYears - 20) / 60);

    // Chronotype mid-sleep estimate based on age (toy)
    // Young = later, older = earlier
    const midSleepYoung = 3.5;   // ~03:30
    const midSleepOld   = 2.0;   // ~02:00
    const midSleepEst   = midSleepYoung*(1-ageNorm) + midSleepOld*ageNorm;

    let diff = Math.abs(hour - midSleepEst);
    if(diff > 12) diff = 24 - diff;
    const entrainmentMismatch = clamp01(diff / 12);

    // Alertness amplitude: better in long days, lower ageNorm & mismatch
    const baseAlert = 0.4 + 0.6*seasonFactor;
    const alertnessAmplitude = clamp01(baseAlert * (1 - 0.3*ageNorm) * (1 - 0.4*entrainmentMismatch));

    // Subconscious noise base
    const subconsciousNoiseBase = clamp01(0.2 + 0.3*ageNorm + 0.3*entrainmentMismatch + 0.2*(1-seasonFactor));

    // Top-down control baseline
    const topDownControlBase = clamp01(0.8 - 0.3*ageNorm - 0.2*entrainmentMismatch);

    // Lat/Lon approx
    const st = stateSelect.value || "";
    let lat = 0, lon = 0;
    if(STATE_LATLON[st]){
      lat = STATE_LATLON[st].lat;
      lon = STATE_LATLON[st].lon;
    }else{
      lat = hem === "N" ? 40 : -30;
      lon = -90;
    }
    latLonDisplay.value = lat.toFixed(2) + "°, " + lon.toFixed(2) + "°";

    envProfile = {
      ageYears,
      hemisphere: hem,
      month,
      hour,
      dayLength,
      seasonFactor,
      entrainmentMismatch,
      alertnessAmplitude,
      subconsciousNoiseBase,
      topDownControlBase,
      lat, lon,
      city: cityInput.value || "",
      state: st,
      tzLabel: tzLabelInput.value || ""
    };

    envSummary.textContent =
      "Age≈" + ageYears +
      " · SeasonFactor=" + seasonFactor.toFixed(2) +
      " · DayLength≈" + dayLength.toFixed(1) + "h" +
      " · EntrainmentMismatch=" + entrainmentMismatch.toFixed(2) +
      " · AlertnessAmplitude=" + alertnessAmplitude.toFixed(2) +
      " · SubconsciousNoiseBase=" + subconsciousNoiseBase.toFixed(2);
  }

  function buildProfileCSV(){
    if(!envProfile){
      return "No profile computed yet.";
    }
    const p = envProfile;
    const header = [
      "ageYears","city","state","hemisphere","month","hour",
      "tzLabel","lat","lon","dayLength","seasonFactor","entrainmentMismatch",
      "alertnessAmplitude","subconsciousNoiseBase","topDownControlBase"
    ];
    const row = [
      p.ageYears,
      JSON.stringify(p.city),
      JSON.stringify(p.state),
      p.hemisphere,
      p.month,
      p.hour,
      JSON.stringify(p.tzLabel),
      p.lat.toFixed(3),
      p.lon.toFixed(3),
      p.dayLength.toFixed(3),
      p.seasonFactor.toFixed(3),
      p.entrainmentMismatch.toFixed(3),
      p.alertnessAmplitude.toFixed(3),
      p.subconsciousNoiseBase.toFixed(3),
      p.topDownControlBase.toFixed(3)
    ];
    return header.join(",") + "\n" + row.join(",");
  }

  /* ---------- COSMIC ALIGNMENT MODULE ---------- */
  function computeCosmicAlignment(){
    if(!envProfile){
      computeEnvironment();
    }
    const dateStr = cosmicDateInput.value;
    let dayOfYearNorm = 0.5;
    if(dateStr){
      const d = new Date(dateStr + "T12:00:00");
      if(!isNaN(d.getTime())){
        const start = new Date(d.getFullYear(),0,0);
        const diff = (d - start);
        const oneDay = 1000*60*60*24;
        const day = Math.floor(diff/oneDay);
        dayOfYearNorm = clamp01(day/365);
      }
    }
    const hem = envProfile ? envProfile.hemisphere : "N";
    const scenario = alignmentScenarioSelect.value || "balanced";

    // Simple sinusoid for solar annual cycle
    const solarCycle = 0.5 + 0.5*Math.sin(2*Math.PI*(dayOfYearNorm - (hem==="N"?0.0:0.5)));

    // Scenario modifiers
    let alignBoost = 0;
    let noiseBoost = 0;
    if(scenario === "balanced"){
      alignBoost = 0.0;
      noiseBoost = 0.0;
    }else if(scenario === "new_moon"){
      alignBoost = 0.1;
      noiseBoost = -0.05;
    }else if(scenario === "full_moon"){
      alignBoost = 0.15;
      noiseBoost = 0.05;
    }else if(scenario === "conjunction"){
      alignBoost = 0.25;
      noiseBoost = 0.05;
    }else if(scenario === "storm"){
      alignBoost = -0.1;
      noiseBoost = 0.25;
    }

    const cosmicAlignmentFactor = clamp01(solarCycle + alignBoost);
    const cosmicDrift = clamp01(0.2 + noiseBoost);

    cosmicProfile = {
      cosmicAlignmentFactor,
      cosmicDrift,
      scenario,
      dayOfYearNorm
    };

    cosmicSummary.textContent =
      "CosmicAlignmentFactor=" + cosmicAlignmentFactor.toFixed(2) +
      " · CosmicDrift=" + cosmicDrift.toFixed(2) +
      " · Scenario=" + scenario;
  }

  /* ---------- TEXT ANALYSIS (CONSCIOUS) ---------- */
  const emotionKeywordMap = {
    joy: ["happy","glad","joy","smile","laugh","delight"],
    sadness: ["sad","cry","lonely","grief","loss","tear"],
    anger: ["angry","mad","furious","rage","irritated","annoyed"],
    fear: ["afraid","fear","scared","terrified","panic"],
    anxiety: ["anxious","nervous","worried","uneasy","tension"],
    calmness: ["calm","peaceful","relaxed","serene","quiet"],
    admiration: ["admire","respect","inspired","hero"],
    adoration: ["love","adore","beloved","precious"],
    awe: ["awe","astonished","overwhelmed","majestic"],
    amusement: ["funny","amusing","joke","humor"],
    boredom: ["bored","dull","boring","monotony"],
    disgust: ["disgust","gross","nausea","revolting"],
    surprise: ["surprised","shock","unexpected","suddenly"],
    nostalgia: ["nostalgia","memory","remember","childhood","past"],
    romance: ["romantic","kiss","embrace","date","lover"],
    satisfaction: ["satisfied","content","fulfilled","accomplished"],
    craving: ["craving","want","desire","need","yearn"],
    sexual_desire: ["sexual","desire","lust","intimate"],
    interest: ["curious","interested","engaged","fascinated"],
    excitement: ["excited","thrilled","eager","energetic"],
    horror: ["horror","nightmare","ghastly","gory"],
    confusion: ["confused","unclear","lost","puzzled"],
    awkwardness: ["awkward","embarrassed","clumsy"],
    envy: ["envy","jealous","resent"],
    empathic_pain: ["sorry","hurt","pain","suffer"],
    entrancement: ["entranced","spellbound","mesmerized","hypnotic"]
  };

  function analyzeTextParagraph(){
    const text = textParagraph.value || "";
    const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
    const wordCount = words.length;

    if(wordCount < 100){
      textStatus.textContent =
        "Warning: paragraph has only " + wordCount + " words (recommended ≥ 100). Analysis will still run.";
    }else{
      textStatus.textContent =
        "Paragraph length: " + wordCount + " words. Analyzing patterns (toy model)...";
    }

    const seedStr = text.slice(0,256) || "default-text-seed";
    const rand = makePRNG(seedStr);

    const emotions = {};
    EMOTION_NAMES.forEach(name=>{
      let base = 0.2 + 0.4*rand();
      const kwList = emotionKeywordMap[name] || [];
      if(kwList.length > 0 && wordCount > 0){
        let count = 0;
        for(const w of words){
          for(const kw of kwList){
            if(w === kw){
              count++;
            }
          }
        }
        const bump = Math.min(0.6, count * 0.03);
        base += bump;
      }
      emotions[name] = clamp01(base);
    });

    let dominant = EMOTION_NAMES[0];
    let maxVal = -1;
    for(const k of EMOTION_NAMES){
      if(emotions[k] > maxVal){
        maxVal = emotions[k];
        dominant = k;
      }
    }

    const bits = [];
    for(let i=0;i<N_TURNS;i++){
      bits.push(rand() > 0.5 ? 1 : 0);
    }

    textAnalysis = {
      bits,
      emotions,
      dominant,
      wordCount
    };

    const emoLines = EMOTION_NAMES
      .map(k => k + ": " + emotions[k].toFixed(2))
      .join(" · ");
    const bitLine = bits.map((b,i)=>((i+1)+":"+b)).join("  ");

    textBitsBox.textContent =
      "Bit-stream (40 turns, derived from text):\n" +
      bitLine +
      "\n\n27 emotion scores (0–1, keyword+noise model):\n" +
      emoLines;
  }

  function buildAnalysisCSV(analysis, typeLabel){
    const header = ["type","bits"].concat(EMOTION_NAMES).concat(["dominant"]);
    const bitsStr = (analysis.bits || []).map(b=>b?"1":"0").join("");
    const row = [typeLabel, bitsStr];
    EMOTION_NAMES.forEach(name=>{
      const v = analysis.emotions && analysis.emotions[name]!=null ? analysis.emotions[name] : 0;
      row.push(v.toFixed(4));
    });
    row.push(analysis.dominant || "");
    return header.join(",") + "\n" + row.join(",");
  }

  function parseAnalysisCSV(csvText){
    const lines = csvText.trim().split(/\r?\n/);
    if(lines.length < 2) throw new Error("CSV must have at least 2 lines");
    const header = lines[0].split(",");
    const cols   = lines[1].split(",");
    const idxBits = header.indexOf("bits");
    if(idxBits === -1) throw new Error("CSV missing 'bits' column");
    const bitsStr = cols[idxBits] || "";
    const bits = bitsStr.split("").slice(0,N_TURNS).map(c => c==="1" ? 1 : 0);

    const emotions = {};
    EMOTION_NAMES.forEach(name=>{
      const idx = header.indexOf(name);
      if(idx !== -1 && cols[idx] !== undefined){
        const val = parseFloat(cols[idx]);
        emotions[name] = isNaN(val)?0:val;
      }else{
        emotions[name] = 0;
      }
    });

    const idxDom = header.indexOf("dominant");
    const dominant = idxDom !== -1 ? (cols[idxDom] || "") : "";

    return {bits, emotions, dominant};
  }

  /* ---------- VIDEO ANALYSIS (SUBCONSCIOUS) ---------- */
  function analyzeVideoFile(file){
    const seedStr = file.name + ":" + file.size + ":" + file.lastModified;
    const rand = makePRNG(seedStr);

    const bits = [];
    for(let i=0;i<N_TURNS;i++){
      bits.push(rand() > 0.5 ? 1 : 0);
    }

    const emotions = {};
    EMOTION_NAMES.forEach(name=>{
      emotions[name] = clamp01(0.2 + 0.6*rand());
    });

    const voiceArousal   = clamp01(0.3 + 0.7*rand());
    const facialTension  = clamp01(0.3 + 0.7*rand());

    let dominant = EMOTION_NAMES[0];
    let maxVal = -1;
    for(const k of EMOTION_NAMES){
      if(emotions[k] > maxVal){
        maxVal = emotions[k];
        dominant = k;
      }
    }

    videoAnalysis = {
      bits,
      emotions,
      dominant,
      voiceArousal,
      facialTension,
      fileName: file.name,
      fileSize: file.size
    };

    const emoLines = EMOTION_NAMES
      .map(k => k + ": " + emotions[k].toFixed(2))
      .join(" · ");
    const bitLine = bits.map((b,i)=>((i+1)+":"+b)).join("  ");

    videoStatus.textContent =
      "Video loaded: " + file.name +
      " (" + file.size + " bytes). Dominant (simulated) emotion: " + dominant +
      " · VoiceArousal=" + voiceArousal.toFixed(2) +
      " · FacialTension=" + facialTension.toFixed(2);

    videoBitsBox.textContent =
      "Bit-stream (40 turns, simulated from video):\n" +
      bitLine +
      "\n\n27 emotion scores (0–1, toy model):\n" +
      emoLines +
      "\n\nNote: In reality this would come from voice + face models. Here it is a structured simulator.";
  }

  function buildVideoCSV(){
    if(!videoAnalysis){
      return "No video analysis to export.";
    }
    const header = ["type","bits"].concat(EMOTION_NAMES).concat(["dominant","voiceArousal","facialTension"]);
    const bitsStr = (videoAnalysis.bits||[]).map(b=>b?"1":"0").join("");
    const row = ["video", bitsStr];
    EMOTION_NAMES.forEach(name=>{
      const v = videoAnalysis.emotions && videoAnalysis.emotions[name]!=null ? videoAnalysis.emotions[name] : 0;
      row.push(v.toFixed(4));
    });
    row.push(videoAnalysis.dominant || "");
    row.push(videoAnalysis.voiceArousal.toFixed(4));
    row.push(videoAnalysis.facialTension.toFixed(4));
    return header.join(",") + "\n" + row.join(",");
  }

  function parseVideoCSV(csvText){
    const lines = csvText.trim().split(/\r?\n/);
    if(lines.length < 2) throw new Error("CSV must have at least 2 lines");
    const header = lines[0].split(",");
    const cols   = lines[1].split(",");
    const idxBits = header.indexOf("bits");
    if(idxBits === -1) throw new Error("CSV missing 'bits' column");
    const bitsStr = cols[idxBits] || "";
    const bits = bitsStr.split("").slice(0,N_TURNS).map(c => c==="1" ? 1 : 0);

    const emotions = {};
    EMOTION_NAMES.forEach(name=>{
      const idx = header.indexOf(name);
      if(idx !== -1 && cols[idx] !== undefined){
        const val = parseFloat(cols[idx]);
        emotions[name] = isNaN(val)?0:val;
      }else{
        emotions[name] = 0;
      }
    });

    const idxDom = header.indexOf("dominant");
    const idxA   = header.indexOf("voiceArousal");
    const idxF   = header.indexOf("facialTension");
    const dominant = idxDom !== -1 ? (cols[idxDom] || "") : "";
    const voiceArousal  = idxA !== -1 ? (parseFloat(cols[idxA]) || 0.5) : 0.5;
    const facialTension = idxF !== -1 ? (parseFloat(cols[idxF]) || 0.5) : 0.5;

    return {bits, emotions, dominant, voiceArousal, facialTension};
  }

  /* ---------- TEXT + VIDEO EMOTION MATCH (TERMINATOR CHECK) ---------- */
  function computeEmotionMatchScore(){
    if(!textAnalysis || !videoAnalysis) return 0.7; // neutral if one is missing
    let sumAbs = 0;
    let sumMax = 0;
    for(const k of EMOTION_NAMES){
      const t = textAnalysis.emotions[k] || 0;
      const v = videoAnalysis.emotions[k] || 0;
      sumAbs += Math.abs(t - v);
      sumMax += Math.max(t, v, 0.0001);
    }
    const normDiff = sumMax > 0 ? (sumAbs / sumMax) : 0;
    const match = clamp01(1 - normDiff); // 1 = perfect match, 0 = high mismatch
    return match;
  }

  /* ---------- HIGH-LEVEL SCALARS FROM TEXT + VIDEO + ENV + COSMIC ---------- */
  function computeHighLevelScalars(){
    let conScalar = 0.6;
    let subScalar = 0.6;
    let couplingBase = 0.6;

    // 1) From text (Conscious)
    if(textAnalysis){
      const emo = textAnalysis.emotions || {};
      const pos = Math.max(
        emo.joy || 0,
        emo.satisfaction || 0,
        emo.admiration || 0,
        emo.adoration || 0,
        emo.excitement || 0
      );
      const neg = Math.max(
        emo.fear || 0,
        emo.anxiety || 0,
        emo.sadness || 0,
        emo.anger || 0,
        emo.disgust || 0
      );
      const calm = emo.calmness || 0.5;
      const flex = (emo.interest || 0.5) + (emo.awe || 0) + (emo.nostalgia || 0);
      const flexNorm = clamp01(flex / 3);
      conScalar = clamp01(0.3 + 0.4*pos + 0.2*calm + 0.3*flexNorm - 0.3*neg);
    }

    // 2) From video (Subconscious)
    let voiceA = 0.6, faceT = 0.6;
    if(videoAnalysis){
      voiceA = videoAnalysis.voiceArousal;
      faceT  = videoAnalysis.facialTension;
      const emoV = videoAnalysis.emotions || {};
      const calmV = emoV.calmness || 0.5;
      const fearV = emoV.fear || 0;
      const anxV  = emoV.anxiety || 0;
      const loadNeg = Math.max(fearV, anxV, faceT);
      subScalar = clamp01(0.3 + 0.4*calmV + 0.2*(1 - loadNeg));
    }

    // 3) From environment (season, age, circadian)
    let alertAmp = 0.7;
    let subNoise = 0.3;
    let topDownBase = 0.7;
    let mismatch = 0.3;
    if(envProfile){
      alertAmp   = envProfile.alertnessAmplitude;
      subNoise   = envProfile.subconsciousNoiseBase;
      topDownBase = envProfile.topDownControlBase;
      mismatch    = envProfile.entrainmentMismatch;
    }

    // 4) Cosmic alignment
    let cosmicAlign = 0.7;
    let cosmicDrift = 0.3;
    if(cosmicProfile){
      cosmicAlign = cosmicProfile.cosmicAlignmentFactor;
      cosmicDrift = cosmicProfile.cosmicDrift;
    }

    // 5) Text vs Video emotion match
    const emoMatch = computeEmotionMatchScore();

    // Subconscious noise includes face tension + cosmic drift + mismatch
    const subconsciousNoise = clamp01(subNoise + 0.2*faceT + 0.2*cosmicDrift + 0.3*(1-emoMatch));

    // Top-down control
    const topDownControlStrength = clamp01(topDownBase * (0.6 + 0.4*conScalar));

    // Cosmic modulation factor (CST cosmic clock)
    const cosmicMod = 0.8 + 0.4*cosmicAlign;

    // Coupling strength:
    // strong when alert, low noise, good match between text and video
    const couplingStrength = clamp01(
      (topDownControlStrength * alertAmp * (0.6 + 0.4*emoMatch) * cosmicMod) /
      (1 + subconsciousNoise)
    );

    // Subconscious stability: punished by mismatch and cosmic drift + mismatch
    subScalar = clamp01(
      subScalar * (1 - 0.4*mismatch) * (1 - 0.3*subconsciousNoise) * (0.8 + 0.4*cosmicAlign)
    );

    // Conscious performance: boosted by cosmic alignment, reduced by mismatch
    conScalar = clamp01(
      conScalar * (0.85 + 0.3*cosmicAlign) * (0.7 + 0.3*emoMatch)
    );

    return {
      consciousPerformance: conScalar,
      subconsciousStability: subScalar,
      couplingStrength,
      alertnessAmplitude: alertAmp,
      subconsciousNoise,
      topDownControlStrength,
      entrainmentMismatch: mismatch,
      emoMatch,
      cosmicAlign,
      cosmicDrift
    };
  }

  function buildTimelinesFromScalars(h){
    const conPerf = [];
    const subStab = [];
    const coupling = [];
    const thetaC = [];
    const thetaS = [];

    const baseC = h.consciousPerformance;
    const baseS = h.subconsciousStability;
    const baseCouple = h.couplingStrength;

    const TWO_PI = Math.PI*2;
    for(let t=0;t<N_TURNS;t++){
      const phase = TWO_PI * (t/(N_TURNS-1));
      const circadian = 0.8 + 0.2*Math.cos(phase - Math.PI/2);

      const jitterC = (Math.random()*0.08 - 0.04);
      const jitterS = (Math.random()*0.08 - 0.04);
      const jitterCouple = (Math.random()*0.06 - 0.03);

      const c = clamp01(baseC * circadian + jitterC);
      const s = clamp01(baseS * (0.9 + 0.1*Math.sin(phase)) + jitterS);
      const k = clamp01(baseCouple * (0.9 + 0.1*Math.cos(phase)) + jitterCouple);

      conPerf.push(c);
      subStab.push(s);
      coupling.push(k);

      const thetaCon = clamp01(c * k);
      const thetaSub = clamp01(s * (1 - h.entrainmentMismatch) * (1 - 0.4*h.subconsciousNoise));
      thetaC.push(thetaCon);
      thetaS.push(thetaSub);
    }

    const emC = detectEmergence(thetaC);
    const emS = detectEmergence(thetaS);

    return {
      conPerf,
      subStab,
      coupling,
      thetaC,
      thetaS,
      zC: emC.z,
      zS: emS.z,
      flagsC: emC.flags,
      flagsS: emS.flags
    };
  }

  /* ---------- TABLE + LAYER UI ---------- */
  function fillMetricsTable(data){
    metricsTableBody.innerHTML = "";
    for(let t=0;t<N_TURNS;t++){
      const tr = document.createElement('tr');
      if(data.flagsC[t]) tr.classList.add('emergeC');
      if(data.flagsS[t]) tr.classList.add('emergeS');

      const tdT = document.createElement('td');
      tdT.className = 'turn';
      tdT.textContent = t+1;
      tr.appendChild(tdT);

      function tdNum(v){
        const td = document.createElement('td');
        td.textContent = v.toFixed(3);
        return td;
      }

      tr.appendChild(tdNum(data.conPerf[t]));
      tr.appendChild(tdNum(data.subStab[t]));
      tr.appendChild(tdNum(data.coupling[t]));
      tr.appendChild(tdNum(data.thetaC[t]));
      tr.appendChild(tdNum(data.thetaS[t]));
      tr.appendChild(tdNum(data.zC[t]));
      tr.appendChild(tdNum(data.zS[t]));

      const tdTag = document.createElement('td');
      let tag = "";
      if(data.flagsC[t] && data.flagsS[t]){
        tag = "Joint emergence (C+S peak)";
      }else if(data.flagsC[t]){
        tag = "Conscious peak (insight / decision)";
      }else if(data.flagsS[t]){
        tag = "Subconscious peak (survival / reset)";
      }
      tdTag.textContent = tag;
      tr.appendChild(tdTag);
      metricsTableBody.appendChild(tr);
    }
  }

  function classifySubStatus(safety, load){
    if(safety >= 70 && load <= 40) return "Calm / Protected";
    if(safety >= 40 && load <= 70) return "Alert / Loaded";
    return "Overloaded / Shutdown-Tilt";
  }

  function classifyConStatus(awareness, choice){
    if(awareness < 30 && choice < 40) return "Distracted / Weak Signal";
    if(awareness >= 60 && choice >= 70) return "Focused / Deliberate";
    if(choice >= 85) return "Overriding Risk / Pushing Limits";
    if(awareness >= 40) return "Aware / Adjusting";
    return "Aware but Low Power";
  }

  function updateLayerUIFromSim(data){
    if(!data) return;
    const idx = N_TURNS - 1;
    const c = data.conPerf[idx];
    const s = data.subStab[idx];
    const k = data.coupling[idx];

    const safety = Math.round(100 * clamp01(s * (1 - (data.flagsS[idx]?0.1:0))));
    const load   = Math.round(100 * clamp01(1 - s + (data.flagsS[idx]?0.2:0)));
    const aware  = Math.round(100 * c);
    const choice = Math.round(100 * k);

    subSafetyVal.textContent = safety;
    subLoadVal.textContent   = load;
    conAwarenessVal.textContent = aware;
    conChoiceVal.textContent    = choice;

    subStatusText.textContent = classifySubStatus(safety, load);
    conStatusText.textContent = classifyConStatus(aware, choice);
  }

  /* ---------- DRAWING ---------- */
  function drawThetaAnimated(ctx, canvas, Theta, flags, timeMs, colorBase){
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);

    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;
    for(let i=0;i<=4;i++){
      const y = h * i/4;
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }

    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.font = "10px system-ui";
    ctx.fillText("Θ", 4, 10);
    ctx.fillText("0", 4, h-4);
    ctx.fillText("1.0", 4, 12);

    const maxTheta = Math.max(...Theta,1);
    const minTheta = Math.min(...Theta,0);

    function xPos(i){
      return (w-40) * (i/(Theta.length-1)) + 30;
    }
    function yPos(v){
      const norm = (v - minTheta) / ((maxTheta-minTheta)||1);
      return h - 20 - norm*(h-40);
    }

    ctx.strokeStyle = colorBase || "#7bffb1";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<Theta.length;i++){
      const x = xPos(i);
      const y = yPos(Theta[i]);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    const phase = (Math.sin(timeMs/300) + 1)/2;
    for(let i=0;i<Theta.length;i++){
      if(flags[i]){
        const x = xPos(i);
        const y = yPos(Theta[i]);
        const radius = 3 + phase*3.5;
        const glowAlpha = 0.4 + phase*0.5;
        const grad = ctx.createRadialGradient(x,y,0,x,y,radius*2.4);
        grad.addColorStop(0, `rgba(255,255,200,${glowAlpha})`);
        grad.addColorStop(1, 'rgba(255,255,200,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x,y,radius*2.4,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#ffff9c";
        ctx.beginPath();
        ctx.arc(x,y,radius,0,Math.PI*2);
        ctx.fill();
      }
    }

    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(30,h-20);
    ctx.lineTo(w-10,h-20);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.fillText("turn", w-35,h-8);
  }

  function animationLoop(timestamp){
    if(chartCon){
      drawThetaAnimated(ctxCon, canvasCon, chartCon.Theta, chartCon.flags, timestamp, "#7bffb1");
    }
    if(chartSub){
      drawThetaAnimated(ctxSub, canvasSub, chartSub.Theta, chartSub.flags, timestamp, "#ffd37a");
    }
    requestAnimationFrame(animationLoop);
  }
  requestAnimationFrame(animationLoop);

  /* ---------- SIMULATION RUNNERS ---------- */
  function runSimulationFromInputs(){
    if(!envProfile){
      computeEnvironment();
    }
    if(!cosmicProfile){
      computeCosmicAlignment();
    }
    const scalars = computeHighLevelScalars();
    const timelines = buildTimelinesFromScalars(scalars);
    simData = timelines;
    fillMetricsTable(timelines);

    chartCon = {Theta: timelines.thetaC, flags: timelines.flagsC};
    chartSub = {Theta: timelines.thetaS, flags: timelines.flagsS};

    updateLayerUIFromSim(timelines);
    testOutputBox.textContent =
      "Simulation based on current profile + text + video + cosmic. " +
      "ConsciousPerformance=" + scalars.consciousPerformance.toFixed(2) +
      ", SubconsciousStability=" + scalars.subconsciousStability.toFixed(2) +
      ", CouplingStrength=" + scalars.couplingStrength.toFixed(2) +
      ", EmotionMatch=" + scalars.emoMatch.toFixed(2) +
      ", CosmicAlign=" + scalars.cosmicAlign.toFixed(2) + ".";
  }

  function runRandomBaseline(){
    const rand = makePRNG("random-baseline");
    envProfile = null;
    cosmicProfile = null;
    textAnalysis = null;
    videoAnalysis = null;

    const scalars = {
      consciousPerformance: 0.4 + 0.4*rand(),
      subconsciousStability: 0.4 + 0.4*rand(),
      couplingStrength: 0.4 + 0.4*rand(),
      alertnessAmplitude: 0.6,
      subconsciousNoise: 0.3,
      topDownControlStrength: 0.6,
      entrainmentMismatch: 0.3,
      emoMatch: 0.7,
      cosmicAlign: 0.7,
      cosmicDrift: 0.3
    };

    const timelines = buildTimelinesFromScalars(scalars);
    simData = timelines;
    fillMetricsTable(timelines);
    chartCon = {Theta: timelines.thetaC, flags: timelines.flagsC};
    chartSub = {Theta: timelines.thetaS, flags: timelines.flagsS};
    updateLayerUIFromSim(timelines);

    envSummary.textContent = "Random baseline: no real profile used.";
    cosmicSummary.textContent = "Random baseline: no cosmic alignment used.";
    textStatus.textContent = "Random baseline: no text used.";
    videoStatus.textContent = "Random baseline: no video used.";
    testOutputBox.textContent =
      "Random baseline run: compare later against real profile + text + video + cosmic runs.";
  }

  function resetAll(){
    envProfile = null;
    cosmicProfile = null;
    textAnalysis = null;
    videoAnalysis = null;
    simData = null;
    chartCon = null;
    chartSub = null;

    ctxCon.fillStyle = "#020617";
    ctxCon.fillRect(0,0,canvasCon.width,canvasCon.height);
    ctxSub.fillStyle = "#020617";
    ctxSub.fillRect(0,0,canvasSub.width,canvasSub.height);

    metricsTableBody.innerHTML = "";
    subStatusText.textContent = "—";
    subSafetyVal.textContent = "—";
    subLoadVal.textContent = "—";
    conStatusText.textContent = "—";
    conAwarenessVal.textContent = "—";
    conChoiceVal.textContent = "—";

    envSummary.textContent = "No environment computed yet.";
    cosmicSummary.textContent = "No cosmic alignment computed yet.";
    textStatus.textContent = "No paragraph analyzed yet.";
    textBitsBox.textContent = "";
    videoStatus.textContent = "No video loaded yet.";
    videoBitsBox.textContent = "";
    resetLogBox.innerHTML = "";
    testOutputBox.textContent = "";
  }

  function buildSimulationCSV(){
    if(!simData){
      return "No simulation data yet. Run a simulation first.";
    }
    const header = [
      "t",
      "ConsciousPerformance",
      "SubconsciousStability",
      "CouplingStrength",
      "ThetaConscious",
      "ThetaSubconscious",
      "zThetaConscious",
      "zThetaSubconscious",
      "EmergenceConscious",
      "EmergenceSubconscious"
    ];
    const lines = [header.join(",")];
    for(let t=0;t<N_TURNS;t++){
      const row = [
        t+1,
        simData.conPerf[t].toFixed(4),
        simData.subStab[t].toFixed(4),
        simData.coupling[t].toFixed(4),
        simData.thetaC[t].toFixed(4),
        simData.thetaS[t].toFixed(4),
        simData.zC[t].toFixed(4),
        simData.zS[t].toFixed(4),
        simData.flagsC[t] ? "YES" : "",
        simData.flagsS[t] ? "YES" : ""
      ];
      lines.push(row.join(","));
    }
    return lines.join("\n");
  }

  /* ---------- REFLEX / AWARENESS TESTS ---------- */
  reflexTestBtn.addEventListener('click', ()=>{
    if(!simData){
      testOutputBox.textContent = "Run any simulation first (baseline or from inputs).";
      return;
    }
    const idx = N_TURNS - 1;
    const s = simData.subStab[idx];
    const thetaS = simData.thetaS[idx];
    let msg;
    if(thetaS < 0.25 || s < 0.3){
      msg = "⛔ Subconscious Engine triggers a survival reset: overload or instability too high. Movement and risk are cut until conditions improve.";
      worldResetCount++;
      resetCountSpan.textContent = worldResetCount;
      appendResetLog(
        "Reset " + worldResetCount +
        ": Subconscious Engine forced a protection stop at turn " + (idx+1) +
        ". Conscious Captain later says: 'We survived. Adjust the mission.'"
      );
    }else if(thetaS < 0.45 || s < 0.5){
      msg = "⚠️ Subconscious Engine requests caution: reduce load, slow decisions, or restore sleep/light/cosmic alignment.";
    }else{
      msg = "✅ Subconscious Engine is stable: survival layer says it is safe to continue, while still monitoring for overload.";
    }
    testOutputBox.textContent = msg;
  });

  awarenessTestBtn.addEventListener('click', ()=>{
    if(!simData){
      testOutputBox.textContent = "Run any simulation first (baseline or from inputs).";
      return;
    }
    const idx = N_TURNS - 1;
    const c = simData.conPerf[idx];
    const k = simData.coupling[idx];
    let msg;
    if(c >= 0.6 && k >= 0.7){
      msg = "“I know I exist, I understand what just happened, and I can deliberately adjust my next move.” (Focused Conscious Captain)";
    }else if(c >= 0.4 && k >= 0.5){
      msg = "“I am still here. I nearly slipped, but I can describe the danger and adapt my plan.”";
    }else if(c >= 0.25){
      msg = "“Signal is weak. I know I exist, but I need recovery (sleep, light, or support) before strong decisions.”";
    }else{
      msg = "“Awareness is fading. External support is needed — like a pilot asking ground control for help.”";
    }
    testOutputBox.textContent = msg;
  });

  /* ---------- EVENT LISTENERS ---------- */
  computeEnvBtn.addEventListener('click', computeEnvironment);
  downloadProfileCSVBtn.addEventListener('click', ()=>{
    const csv = buildProfileCSV();
    downloadTextFile("rmk_profile_environment.csv", csv, "text/csv");
  });

  computeCosmicBtn.addEventListener('click', computeCosmicAlignment);

  textAnalyzeBtn.addEventListener('click', analyzeTextParagraph);
  textExportBtn.addEventListener('click', ()=>{
    if(!textAnalysis){
      textStatus.textContent = "Nothing to export yet — run the text analysis first.";
      return;
    }
    const csv = buildAnalysisCSV(textAnalysis, "text");
    downloadTextFile("rmk_text_analysis.csv", csv, "text/csv");
  });
  textLoadBtn.addEventListener('click', ()=> textAnalysisFileInput.click());
  textAnalysisFileInput.addEventListener('change', ()=>{
    if(textAnalysisFileInput.files && textAnalysisFileInput.files[0]){
      const file = textAnalysisFileInput.files[0];
      const reader = new FileReader();
      reader.onload = ev=>{
        try{
          const obj = parseAnalysisCSV(ev.target.result);
          textAnalysis = obj;
          const emoLines = EMOTION_NAMES
            .map(k => k + ": " + obj.emotions[k].toFixed(2))
            .join(" · ");
          const bitLine = obj.bits.map((b,i)=>((i+1)+":"+b)).join("  ");
          textStatus.textContent =
            "Loaded text analysis from CSV (dominant: " + (obj.dominant || "unknown") + ").";
          textBitsBox.textContent =
            "Bit-stream (40 turns, from CSV):\n" + bitLine +
            "\n\n27 emotion scores (0–1):\n" + emoLines;
        }catch(e){
          textStatus.textContent = "Could not parse text analysis CSV: " + e.message;
        }
      };
      reader.readAsText(file);
    }
  });
  textClearBtn.addEventListener('click', ()=>{
    textAnalysis = null;
    textStatus.textContent = "Text and text-analysis cleared. You can enter a new paragraph.";
    textBitsBox.textContent = "";
  });

  videoUploadBtn.addEventListener('click', ()=> videoFileInput.click());
  videoFileInput.addEventListener('change', ()=>{
    if(videoFileInput.files && videoFileInput.files[0]){
      analyzeVideoFile(videoFileInput.files[0]);
    }
  });
  videoAnalyzeBtn.addEventListener('click', ()=>{
    if(videoFileInput.files && videoFileInput.files[0]){
      analyzeVideoFile(videoFileInput.files[0]);
    }else if(videoAnalysis){
      videoStatus.textContent = "Video analysis already present (from CSV or last run). You can export or clear.";
    }else{
      videoStatus.textContent = "Please upload a video file first.";
    }
  });
  videoExportBtn.addEventListener('click', ()=>{
    if(!videoAnalysis){
      videoStatus.textContent = "Nothing to export yet — run the video analysis first.";
      return;
    }
    const csv = buildVideoCSV();
    downloadTextFile("rmk_video_analysis.csv", csv, "text/csv");
  });
  videoLoadBtn.addEventListener('click', ()=> videoAnalysisFileInput.click());
  videoAnalysisFileInput.addEventListener('change', ()=>{
    if(videoAnalysisFileInput.files && videoAnalysisFileInput.files[0]){
      const file = videoAnalysisFileInput.files[0];
      const reader = new FileReader();
      reader.onload = ev=>{
        try{
          const obj = parseVideoCSV(ev.target.result);
          videoAnalysis = obj;
          const emoLines = EMOTION_NAMES
            .map(k => k + ": " + obj.emotions[k].toFixed(2))
            .join(" · ");
          const bitLine = obj.bits.map((b,i)=>((i+1)+":"+b)).join("  ");
          videoStatus.textContent =
            "Loaded video analysis from CSV (dominant: " + (obj.dominant || "unknown") +
            ", VoiceArousal=" + obj.voiceArousal.toFixed(2) +
            ", FacialTension=" + obj.facialTension.toFixed(2) + ").";
          videoBitsBox.textContent =
            "Bit-stream (40 turns, from video CSV):\n" + bitLine +
            "\n\n27 emotion scores (0–1):\n" + emoLines;
        }catch(e){
          videoStatus.textContent = "Could not parse video analysis CSV: " + e.message;
        }
      };
      reader.readAsText(file);
    }
  });
  videoClearBtn.addEventListener('click', ()=>{
    videoAnalysis = null;
    videoStatus.textContent = "Video and video-analysis cleared. You can upload a new file.";
    videoBitsBox.textContent = "";
  });

  runFromInputsBtn.addEventListener('click', runSimulationFromInputs);
  runRandomBtn.addEventListener('click', runRandomBaseline);
  resetAllBtn.addEventListener('click', resetAll);
  printBtn.addEventListener('click', ()=> window.print());

  downloadSimCSVBtn.addEventListener('click', ()=>{
    const csv = buildSimulationCSV();
    downloadTextFile("rmk_conscious_subconscious_simulation.csv", csv, "text/csv");
  });
  downloadPNG_Con.addEventListener('click', ()=>{
    downloadCanvasPNG(canvasCon, "rmk_theta_conscious.png");
  });
  downloadPNG_Sub.addEventListener('click', ()=>{
    downloadCanvasPNG(canvasSub, "rmk_theta_subconscious.png");
  });

  /* ---------- INIT ---------- */
  initAgeSelect();
  refreshTimePanel();
  setInterval(refreshTimePanel, 1000 * 15); // update every 15 seconds

  // Initial random baseline so page is not empty
  runRandomBaseline();
})();
</script>
</body>
</html>
