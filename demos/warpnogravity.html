<!-- ======================= PART 1 / 5 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Geometry-Engine — 4D Earth↔Mars String-Path + Compression + Mag Shield (Live)</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#070b14;
    --panel:#0f172a;
    --panel2:#0b1222;
    --ink:#e5e7eb;
    --muted:#9aa4c7;
    --accent:#60a5fa;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --line:rgba(148,163,184,.22);
    --radius:16px;
    --shadow:0 18px 40px rgba(0,0,0,.45);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 800px at 20% -10%, #14203b, var(--bg));
    color:var(--ink);
  }
  .wrap{max-width:1480px;margin:18px auto;padding:14px}
  header{
    display:flex;flex-wrap:wrap;align-items:flex-end;gap:12px;
    padding:14px 16px;border:1px solid var(--line);border-radius:var(--radius);
    background: linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.80));
    box-shadow:var(--shadow);
  }
  header h1{margin:0;font-size:20px;letter-spacing:.2px}
  header .sub{color:var(--muted);font-size:12.5px;max-width:1040px;line-height:1.35}
  .row{display:grid;grid-template-columns: 490px 1fr; gap:12px; margin-top:12px}
  @media (max-width: 1180px){ .row{grid-template-columns:1fr} }
  .card{
    border:1px solid var(--line);
    border-radius:var(--radius);
    background: linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.80));
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .card .hd b{font-size:13px;letter-spacing:.25px}
  .pill{
    font-size:11px;color:var(--muted);
    padding:4px 8px;border:1px solid var(--line);
    border-radius:999px;background:rgba(2,6,23,.45)
  }
  .card .bd{padding:12px 14px}
  .grid2{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
  .grid3{display:grid;grid-template-columns: 1fr 1fr 1fr; gap:10px}
  @media (max-width: 980px){ .grid3{grid-template-columns:1fr} .grid2{grid-template-columns:1fr} }
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="range"]{width:100%}
  input[type="number"], input[type="datetime-local"], select{
    width:100%;
    padding:9px 10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:rgba(2,6,23,.55);
    color:var(--ink);
    outline:none;
  }
  .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  button{
    cursor:pointer;
    border:1px solid var(--line);
    color:var(--ink);
    background: rgba(2,6,23,.55);
    padding:10px 12px;
    border-radius:12px;
    font-weight:900;
  }
  button.primary{border-color:rgba(96,165,250,.6); box-shadow:0 0 0 2px rgba(96,165,250,.15) inset}
  button.good{border-color:rgba(52,211,153,.6); box-shadow:0 0 0 2px rgba(52,211,153,.12) inset}
  button.warn{border-color:rgba(251,191,36,.6); box-shadow:0 0 0 2px rgba(251,191,36,.10) inset}
  button.bad{border-color:rgba(251,113,133,.6); box-shadow:0 0 0 2px rgba(251,113,133,.10) inset}

  .kpi{
    border:1px solid var(--line);
    border-radius:14px;
    background: rgba(2,6,23,.45);
    padding:10px 12px;
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{margin-top:4px;font-size:15px;font-weight:900}
  .kpi .s{margin-top:4px;font-size:11px;color:var(--muted);line-height:1.25}
  .mono{font-family:var(--mono)}
  .bar{
    height:10px;border-radius:999px;border:1px solid var(--line);
    background: rgba(2,6,23,.55);
    overflow:hidden;
  }
  .bar > i{display:block;height:100%;width:0%}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  .rightCols{display:grid;grid-template-columns: 1.2fr .8fr; gap:12px}
  @media (max-width: 1180px){ .rightCols{grid-template-columns:1fr} }
  .log{
    height:170px; overflow:auto; padding:10px 12px;
    border-radius:14px;border:1px solid var(--line);
    background: rgba(2,6,23,.45);
    font-family:var(--mono); font-size:11px; color:#cfe3ff;
    white-space:pre-wrap;
  }
  .canvasWrap{
    border:1px solid var(--line);
    border-radius:14px;
    background: rgba(2,6,23,.35);
    overflow:hidden;
  }
  canvas{display:block;width:100%;height:280px}

  .noteBox{
    border:1px solid var(--line);
    border-radius:14px;
    background: rgba(2,6,23,.40);
    padding:10px 12px;
  }

  @media print{
    body{background:#fff;color:#000}
    header,.card{box-shadow:none}
    .pill,.btns, .small.noprint{display:none !important}
    .card{break-inside:avoid}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>CST Geometry-Engine — 4D Earth ↔ Mars + Space Compression + Magnetic Stabilization (Toy)</h1>
      <div class="sub">
        <b>Gravity-as-geometry test framing:</b> free-fall has ~zero proper-acceleration; what matters are <i>tidal gradients</i> (curvature).
        We place Earth/Mars as moving points in a <span class="mono">4D box (x,y,z,w)</span> where <span class="mono">w</span> is a time-like phase coordinate scaled to distance.
        The corridor compresses effective separation (<span class="mono">D_eff</span>) and uses a toy magnetic field to stabilize compression and deflect charged particle flux.
        <span class="mono">m = E/c²</span> is treated as an authority budget only (accounting).
      </div>
    </div>
    <span class="pill mono" id="statusPill">STATUS: READY</span>
  </header>

  <div class="row">
    <!-- LEFT: Controls -->
    <section class="card">
      <div class="hd">
        <b>Controls</b>
        <span class="pill mono" id="simRatePill">dt: 0.25 s</span>
      </div>
      <div class="bd">
        <div class="grid2">
          <div>
            <label>Start epoch (local time)</label>
            <input id="epoch" type="datetime-local" />
            <div class="small">Sets “now” for Earth/Mars 4D coordinates (toy ephemeris).</div>
          </div>
          <div>
            <label>Warp mode</label>
            <select id="warpMode">
              <option value="1" selected>Warp 1 (stable)</option>
              <option value="2">Warp 2 (aggressive)</option>
            </select>
            <div class="small">Warp 2 increases compression demand and particle flux stress (toy).</div>
          </div>

          <div>
            <label>Distance preset (demo nudge)</label>
            <select id="preset">
              <option value="auto" selected>Auto (from 4D coordinates)</option>
              <option value="opp">Opposition-like (closer)</option>
              <option value="avg">Average</option>
              <option value="conj">Conjunction-like (farther)</option>
            </select>
            <div class="small">“Auto” uses orbit geometry; presets only nudge the toy model.</div>
          </div>
          <div>
            <label>Base cruise (km/s)</label>
            <input id="baseV" type="number" min="1" max="300" step="1" value="24" />
            <div class="small">ETA uses <span class="mono">D_eff</span>, not raw distance.</div>
          </div>

          <div>
            <label>Corridor compression factor (1–50)</label>
            <input id="warpF" type="number" min="1" max="50" step="0.5" value="6" />
            <div class="small"><span class="mono">D_eff = D_4D / factor</span> (toy).</div>
          </div>
          <div>
            <label>Space-compression gain (0–1)</label>
            <input id="compGain" type="range" min="0" max="1" step="0.01" value="0.45" />
            <div class="small">Adds extra compression when time-bending is active (toy coupling).</div>
          </div>

          <div>
            <label>Field energy available (PJ)</label>
            <input id="EPJ" type="number" min="0" max="500000" step="100" value="8000" />
            <div class="small">Authority: <span class="mono">m_eq = E/c²</span> (accounting).</div>
          </div>
          <div>
            <label>String tension (0–1)</label>
            <input id="tension" type="range" min="0" max="1" step="0.01" value="0.55" />
            <div class="small">Higher = tighter corridor + less jitter loss.</div>
          </div>

          <div>
            <label>Magnetic stabilizer strength (0–1)</label>
            <input id="magK" type="range" min="0" max="1" step="0.01" value="0.60" />
            <div class="small">Higher = stronger stabilization + better charged-particle deflection.</div>
          </div>
          <div>
            <label>Particle environment (0–1)</label>
            <input id="env" type="range" min="0" max="1" step="0.01" value="0.35" />
            <div class="small">Toy radiation/particle intensity (solar wind + cosmic rays proxy).</div>
          </div>

          <div>
            <label>Perturbation (0–1)</label>
            <input id="pert" type="range" min="0" max="1" step="0.01" value="0.25" />
            <div class="small">Injects corridor jitter & clock drift (toy noise).</div>
          </div>
          <div>
            <label>Clock feedback gain (0–1)</label>
            <input id="gain" type="range" min="0" max="1" step="0.01" value="0.55" />
            <div class="small">Higher = stronger CST correction toward coherence.</div>
          </div>

          <div>
            <label>Scan window for “best departure” (days)</label>
            <input id="scanDays" type="number" min="5" max="1200" step="5" value="240" />
            <div class="small">Solver scans future epochs for a faster corridor (toy optimizer).</div>
          </div>
          <div>
            <label>Logging cadence</label>
            <select id="logEvery">
              <option value="1">Every tick</option>
              <option value="2" selected>Every 2 ticks</option>
              <option value="4">Every 4 ticks</option>
              <option value="8">Every 8 ticks</option>
            </select>
            <div class="small">Reduces CSV size.</div>
          </div>
        </div>

        <div class="btns">
          <button class="good" id="btnStart">Start</button>
          <button class="warn" id="btnStop">Stop</button>
          <button class="bad" id="btnReset">Reset</button>
          <button class="primary" id="btnSolve">Solve Fastest Path</button>
          <button class="primary" id="btnCSV">Download CSV</button>
          <button id="btnPrint">Print</button>
        </div>

        <div class="noteBox small noprint" style="margin-top:10px">
          <b>Live display fix:</b> “Progress” will look like <span class="mono">0.0%</span> at first if you only show one decimal, because 24 km/s is tiny vs AU scale.
          This version shows <span class="mono">progress</span> with <b>3 decimals</b>, and also shows <b>traveled km</b> so you can see it moving immediately.
          Also, UTC/CST/Ship are now shown with <b>milliseconds</b> + explicit <b>offset readouts</b>.
        </div>
      </div>
    </section>

    <!-- RIGHT: Dash -->
    <section class="rightCols">
      <div class="card">
        <div class="hd">
          <b>Live Flight Panels</b>
          <span class="pill mono" id="phasePill">PHASE: IDLE</span>
        </div>
        <div class="bd">
          <div class="grid3">
            <div class="kpi">
              <div class="t">Clock — UTC</div>
              <div class="v mono" id="utcV">--:--:--.---</div>
              <div class="s">Earth reference (display)</div>
            </div>
            <div class="kpi">
              <div class="t">Clock — CST</div>
              <div class="v mono" id="cstV">--:--:--.---</div>
              <div class="s"><span class="mono" id="cstOffV">Δ=0.000 ms</span> (toy offset vs UTC)</div>
            </div>
            <div class="kpi">
              <div class="t">Clock — Ship</div>
              <div class="v mono" id="shipV">--:--:--.---</div>
              <div class="s"><span class="mono" id="shipOffV">Δ=0.000 ms</span> (toy offset vs UTC)</div>
            </div>

            <div class="kpi">
              <div class="t">3D separation (x,y,z)</div>
              <div class="v mono" id="d3V">—</div>
              <div class="s">Raw space separation (AU + km)</div>
            </div>
            <div class="kpi">
              <div class="t">4D separation (x,y,z,w)</div>
              <div class="v mono" id="d4V">—</div>
              <div class="s">Includes time-like phase distance (w-scale)</div>
            </div>
            <div class="kpi">
              <div class="t">ETA (proper-time, toy)</div>
              <div class="v mono" id="etaV">—</div>
              <div class="s">Uses compressed <span class="mono">D_eff</span></div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid3">
            <div class="kpi">
              <div class="t">Progress</div>
              <div class="v mono" id="progV">0.000%</div>
              <div class="s">
                <div class="bar"><i id="progBar"></i></div>
                <div class="mono" id="trvV" style="margin-top:6px">traveled: 0 km</div>
              </div>
            </div>
            <div class="kpi">
              <div class="t">Earth 4D (x,y,z,w)</div>
              <div class="v mono" id="e4V">—</div>
              <div class="s">AU units</div>
            </div>
            <div class="kpi">
              <div class="t">Mars 4D (x,y,z,w)</div>
              <div class="v mono" id="m4V">—</div>
              <div class="s">AU units</div>
            </div>

            <div class="kpi">
              <div class="t">Phase angle (Earth→Mars)</div>
              <div class="v mono" id="phV">—</div>
              <div class="s">Used by solver (toy)</div>
            </div>
            <div class="kpi">
              <div class="t">Corridor stability</div>
              <div class="v mono" id="stabV">—</div>
              <div class="s"><div class="bar"><i id="stabBar"></i></div></div>
            </div>
            <div class="kpi">
              <div class="t">Tidal proxy (curvature gradient)</div>
              <div class="v mono" id="tidalV">—</div>
              <div class="s">High = “too tight” compression for current authority</div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid3">
            <div class="kpi">
              <div class="t">Geodesic Corridor Index</div>
              <div class="v mono" id="gciV">—</div>
              <div class="s">stability × coherence × authority × tension</div>
            </div>
            <div class="kpi">
              <div class="t">Clock drift (Ship − CST)</div>
              <div class="v mono" id="driftV">—</div>
              <div class="s">Shown in ms (live)</div>
            </div>
            <div class="kpi">
              <div class="t">“Gravity test” readout</div>
              <div class="v mono" id="gravTestV">—</div>
              <div class="s">Proper accel ≈ 0 in free-fall; curvature shows up as tidal</div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div class="kpi">
              <div class="t">Space compression (live)</div>
              <div class="v mono" id="compV">—</div>
              <div class="s"><span class="mono" id="effV">D_eff: —</span></div>
            </div>
            <div class="kpi">
              <div class="t">Magnetic stabilization (live)</div>
              <div class="v mono" id="magV">—</div>
              <div class="s">B-field, confinement, and stability coupling (toy)</div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div class="kpi">
              <div class="t">Particle defense (live)</div>
              <div class="v mono" id="shieldV">—</div>
              <div class="s"><span class="mono" id="hitsV">hits/s: —</span> · <span class="mono" id="hpV">shield: —</span></div>
            </div>
            <div class="kpi">
              <div class="t">Mini-map (moving ship marker)</div>
              <div class="canvasWrap"><canvas id="map" width="960" height="280"></canvas></div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="kpi">
            <div class="t">Event log</div>
            <div class="log" id="logBox"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <b>Model Notes</b>
          <span class="pill mono">Toy math</span>
        </div>
        <div class="bd">
          <div class="small">
            <b>Key “live” equations (toy):</b><br/>
            • <span class="mono">D3 = √(dx²+dy²+dz²)</span> (AU) and <span class="mono">D4 = √(dx²+dy²+dz²+dw²)</span> where <span class="mono">dw</span> is phase mapped into AU.<br/>
            • <span class="mono">D_eff = D4 / warpF / (1 + compGain·warpMode·coherence)</span> (compression couples to time-bending & coherence).<br/>
            • Magnetic stabilizer generates a toy <span class="mono">B</span>-field proportional to need and knob <span class="mono">magK</span>, improving stability and reducing hits.<br/>
            • “Gravity test” readout shows <span class="mono">properAccel</span> near 0 while <span class="mono">tidal</span> tracks curvature/gradient (conceptual GR framing).
          </div>
          <div style="height:10px"></div>
          <div class="small">
            <b>Reminder:</b> This is a demonstrator of your discussion (gravity-as-geometry + warp as curvature + stabilization/defense),
            not a validated propulsion model.
          </div>
        </div>
      </div>
    </section>
  </div>
<!-- ======================= PART 2 / 5 ======================= -->
<script>
"use strict";
const $ = (id)=>document.getElementById(id);

// ===== Constants =====
const c = 299792458;            // m/s
const PJ = 1e15;                // petajoule -> joule
const AU = 149597870700;        // meters
const DAY = 86400;              // seconds
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

// Toy orbital parameters (simple circular + small inclination)
const ORBIT = {
  earth: { a_AU: 1.000, period_d: 365.256, inc_deg: 0.000, phase0: 0.0 },
  mars:  { a_AU: 1.523, period_d: 686.980, inc_deg: 1.850, phase0: 0.35 }
};

// w-dimension scale (AU-equivalent distance per phase-radian)
const W = { wScale_AU: 0.20 };

// ===== Formatting =====
function fmt2(x){ return (Math.round(x*100)/100).toFixed(2); }
function fmt3(x){ return (Math.round(x*1000)/1000).toFixed(3); }
function hhmmssMs(date){
  const h=String(date.getHours()).padStart(2,"0");
  const m=String(date.getMinutes()).padStart(2,"0");
  const s=String(date.getSeconds()).padStart(2,"0");
  const ms=String(date.getMilliseconds()).padStart(3,"0");
  return `${h}:${m}:${s}.${ms}`;
}
function fmtHMS(sec){
  if (!isFinite(sec) || sec < 0) return "—";
  sec = Math.floor(sec);
  const d = Math.floor(sec/86400); sec -= d*86400;
  const h = Math.floor(sec/3600); sec -= h*3600;
  const m = Math.floor(sec/60);   sec -= m*60;
  const s = sec;
  if (d>0) return `${d}d ${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
}
function fmtAU(x){
  if (!isFinite(x)) return "—";
  return (x>=0?"+":"") + x.toFixed(4);
}
function fmtKmFromAU(au){
  const km = (au * AU) / 1000;
  if (!isFinite(km)) return "—";
  if (km >= 1e9) return (km/1e9).toFixed(3)+" Bkm";
  if (km >= 1e6) return (km/1e6).toFixed(3)+" Mkm";
  if (km >= 1e3) return (km/1e3).toFixed(1)+" kkm";
  return km.toFixed(0)+" km";
}
function setPill(id, txt, tone=""){
  const el=$(id);
  el.textContent = txt;
  el.style.borderColor = tone==="good" ? "rgba(52,211,153,.6)"
                      : tone==="warn" ? "rgba(251,191,36,.6)"
                      : tone==="bad"  ? "rgba(251,113,133,.6)"
                      : "rgba(148,163,184,.22)";
}
function pushLog(line){
  const ts = new Date();
  const msg = `[${hhmmssMs(ts)}] ${line}`;
  state.lastLog.push(msg);
  if (state.lastLog.length>18) state.lastLog.shift();
  $("logBox").textContent = state.lastLog.join("\n");
}

// ===== State =====
const state = {
  running:false,
  dt:0.25,
  t:0,
  tick:0,

  // knobs
  epoch_ms: Date.now(),
  warpMode: 1,
  preset: "auto",
  v_kms: 24,
  warpF: 6,
  compGain: 0.45,
  E_J: 8000*PJ,
  tension: 0.55,
  magK: 0.60,
  env: 0.35,
  pert: 0.25,
  gain: 0.55,
  scanDays: 240,
  logEvery: 2,

  // evolving
  drift_s: 0,
  shipClock_s: 0,
  cstClock_s: 0,
  stability: 1,
  tidal: 0,

  // compression + corridor
  coherence: 1,
  D3_AU: 0,
  D4_AU: 0,
  Deff_AU: 0,
  traveled_eff_AU: 0,

  // 4D coords
  earth4: {x:0,y:0,z:0,w:0, theta:0},
  mars4:  {x:0,y:0,z:0,w:0, theta:0},
  phase_deg: 0,

  // magnetic + defense
  B_T: 0,               // toy field strength
  confinement: 0,       // 0..1
  hitsPerS: 0,
  shieldHP: 1.0,        // 0..1
  shieldRegen: 0.0,

  // “gravity test”
  properAccel: 0,       // toy m/s^2
  curvature: 0,         // toy curvature metric 0..1

  // solver
  best: null,

  // logging
  csv: [],
  lastLog: []
};

// ===== Inputs =====
function setEpochDefault(){
  const d = new Date();
  d.setSeconds(0); d.setMilliseconds(0);
  const pad=(n)=>String(n).padStart(2,"0");
  $("epoch").value = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  state.epoch_ms = d.getTime();
}
function readInputs(){
  const raw = $("epoch").value;
  if (raw){
    const ms = new Date(raw).getTime();
    if (isFinite(ms)) state.epoch_ms = ms;
  }

  state.warpMode = Number($("warpMode").value||1) === 2 ? 2 : 1;
  state.preset = $("preset").value || "auto";
  state.v_kms = clamp(Number($("baseV").value||24), 1, 300);
  state.warpF = clamp(Number($("warpF").value||6), 1, 50);
  state.compGain = clamp(Number($("compGain").value||0.45), 0, 1);
  state.E_J = clamp(Number($("EPJ").value||0), 0, 500000) * PJ;

  state.tension = clamp(Number($("tension").value||0.55), 0, 1);
  state.magK = clamp(Number($("magK").value||0.60), 0, 1);
  state.env = clamp(Number($("env").value||0.35), 0, 1);

  state.pert = clamp(Number($("pert").value||0.25), 0, 1);
  state.gain = clamp(Number($("gain").value||0.55), 0, 1);

  state.scanDays = clamp(Number($("scanDays").value||240), 5, 1200);
  state.logEvery = Number($("logEvery").value||2);
}

// ===== Reset =====
function resetSim(keepInputs=true){
  if (keepInputs) readInputs();

  state.running=false;
  state.t=0; state.tick=0;
  state.traveled_eff_AU=0;

  state.drift_s=0; state.shipClock_s=0; state.cstClock_s=0;
  state.stability=1; state.tidal=0;
  state.B_T=0; state.confinement=0;
  state.hitsPerS=0; state.shieldHP=1.0; state.shieldRegen=0;
  state.properAccel=0; state.curvature=0;

  state.best=null;
  state.lastLog=[]; $("logBox").textContent="";

  state.csv=[];
  state.csv.push([
    "t_s",
    "epoch_ms",
    "warpMode",
    "earth_x_AU","earth_y_AU","earth_z_AU","earth_w_AU",
    "mars_x_AU","mars_y_AU","mars_z_AU","mars_w_AU",
    "phase_deg",
    "D3_AU","D4_AU","D_eff_AU",
    "progress_pct",
    "eta_s",
    "v_base_km_s",
    "warpF",
    "compGain",
    "tension",
    "magK",
    "B_T",
    "hitsPerS",
    "shieldHP",
    "E_J",
    "m_eq_kg",
    "stability",
    "tidal",
    "coherence",
    "drift_ship_minus_cst_s"
  ]);

  setPill("statusPill","STATUS: READY");
  setPill("phasePill","PHASE: IDLE");
  render();
  pushLog("Reset complete.");
}
</script>
<!-- ======================= PART 3 / 5 ======================= -->
<script>
// ===== 4D orbit model (toy) =====
function deg2rad(d){ return d*Math.PI/180; }
function rad2deg(r){ return r*180/Math.PI; }
function wrapPi(a){
  while (a > Math.PI) a -= 2*Math.PI;
  while (a < -Math.PI) a += 2*Math.PI;
  return a;
}
function planet4D(which, t_ms){
  const P = ORBIT[which];
  const t_days = (t_ms / 1000) / DAY;
  const omega = (2*Math.PI) / P.period_d;
  const theta = wrapPi(P.phase0 + omega * t_days);
  const r = P.a_AU;

  const x = r*Math.cos(theta);
  const y = r*Math.sin(theta);

  const inc = deg2rad(P.inc_deg);
  const z = y*Math.sin(inc);

  const w = (W.wScale_AU) * theta;

  return {x,y,z,w,theta};
}
function phaseAngleDeg(e, m){
  const d = wrapPi(m.theta - e.theta);
  return rad2deg(d);
}
function dist3AU(a,b){
  const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}
function dist4AU(a,b){
  const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z, dw=b.w-a.w;
  return Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
}

// preset multiplier
function presetMultiplier(){
  const p = state.preset;
  if (p==="opp") return 0.70;
  if (p==="avg") return 1.00;
  if (p==="conj")return 1.35;
  return 1.00;
}

// authority: m = E / c^2
function authorityKg(){ return state.E_J / (c*c); }

// compression factor coupling (time bend + coherence)
function compressionMultiplier(){
  // Warp 2 amplifies compression effect, but also increases stress
  const wm = state.warpMode; // 1 or 2
  const g = state.compGain;
  const coh = state.coherence;
  // 1 + compGain * warpMode * coherence
  return 1 + g * wm * (0.35 + 0.65*coh);
}

function updateEphemeris(){
  const t_ms = state.epoch_ms + (state.running ? (state.t*1000) : 0);
  const E = planet4D("earth", t_ms);
  const M = planet4D("mars",  t_ms);

  state.earth4 = E;
  state.mars4 = M;
  state.phase_deg = phaseAngleDeg(E, M);

  state.D3_AU = dist3AU(E,M) * presetMultiplier();
  state.D4_AU = dist4AU(E,M) * presetMultiplier();
}

function updateOneTick(){
  readInputs();
  state.tick++;
  state.t += state.dt;

  updateEphemeris();

  // --- Drift / coherence (live and visible) ---
  const n = (Math.random()*2 - 1);
  const driftInject = n * state.pert * (0.030 + 0.050*(1-state.tension)); // seconds/tick
  state.drift_s += driftInject;

  // feedback correction (stronger with gain and tension)
  const corrGain = (0.08 + 0.28*state.gain) * (0.55 + 0.45*state.tension);
  const corr = -corrGain * state.drift_s;
  state.drift_s += corr;

  // ship and CST offsets
  const oscNoise = (Math.random()*2 - 1) * state.pert * 0.0025;
  state.shipClock_s += (corr * 0.30) + oscNoise;
  state.cstClock_s  += (-driftInject * 0.20) + (corr * 0.70);

  // coherence from drift (0..1)
  state.coherence = clamp(1 - Math.abs(state.drift_s)/0.20, 0, 1);

  // --- Compression / corridor effective distance ---
  // baseline corridor shrink: D4 / warpF, then extra compressionMultiplier()
  const compMul = compressionMultiplier();
  // D_eff decreases as compMul increases
  state.Deff_AU = (state.D4_AU / state.warpF) / compMul;

  // --- Travel along corridor ---
  const v_ms = state.v_kms*1000;
  const v_AU_s = v_ms / AU;

  // tension reduces “loss”, warp 2 increases difficulty
  const wm = state.warpMode;
  const loss = (1 - state.tension) * state.pert * (0.22 + 0.18*wm);

  const d_eff = v_AU_s * state.dt * (1 - loss);
  state.traveled_eff_AU = clamp(state.traveled_eff_AU + d_eff, 0, state.Deff_AU);

  // --- Stability / tidal proxy (curvature stress) ---
  const auth = authorityKg();
  const authNorm = clamp(auth / 1e6, 0, 1);
  const aggress = clamp((state.warpF - 1)/49, 0, 1);

  // magnetic stabilization helps stability (computed next), but we need a “need” signal now:
  const need = clamp(0.35*aggress + 0.35*(1-state.coherence) + 0.30*state.pert + 0.20*(wm-1), 0, 1);

  // toy magnetic field demand: stronger when corridor is tight and noisy
  state.B_T = (0.02 + 0.25*state.magK) * need * (0.60 + 0.40*compMul); // Tesla (toy)
  // confinement (0..1)
  state.confinement = clamp(0.15 + 0.75*state.magK*need + 0.25*authNorm, 0, 1);

  // stability target: helped by tension, confinement, authority; hurt by perturb, warp2, aggressiveness
  const stTarget = clamp(
    0.20
    + 0.34*state.coherence
    + 0.20*authNorm
    + 0.18*state.tension
    + 0.22*state.confinement
    - 0.38*state.pert*(1-0.25*state.tension)
    - 0.28*(wm-1)
    - 0.30*aggress*(1-authNorm)*(1-0.35*state.tension),
    0, 1
  );
  state.stability += (stTarget - state.stability) * 0.20;

  // tidal proxy rises with compression demand and low stability
  state.tidal = clamp(
    0.10
    + 0.55*(1-state.stability)
    + 0.30*aggress*(1-authNorm)
    + 0.25*(compMul-1)
    + 0.15*(wm-1),
    0, 1
  );

  // --- Gravity “not a force” readout (conceptual) ---
  // properAccel ~ 0 when stable & coherent; curvature shows as tidal gradients
  state.curvature = clamp(0.25*state.tidal + 0.35*(compMul-1) + 0.20*aggress, 0, 1);
  state.properAccel = (1 - state.stability) * (0.20 + 0.40*state.pert + 0.20*(wm-1)); // m/s^2 (toy)

  // --- Particle defense ---
  // environment drives raw flux; warp2 increases flux; magnetic confinement reduces charged component
  const rawFlux = state.env * (1.0 + 0.55*(wm-1)) * (0.6 + 0.4*compMul); // toy
  const deflect = clamp(0.20 + 0.70*state.confinement, 0, 0.95);         // fraction deflected
  const chargedHits = rawFlux * (1 - deflect);
  const neutralHits = rawFlux * (0.25 + 0.20*(wm-1));                    // neutrals not deflected well (toy)
  state.hitsPerS = Math.max(0, (chargedHits + neutralHits) * 120);       // hits/s (toy scaling)

  // shield HP drains with hits; regenerates with authority + magnetic stability
  const drain = clamp(state.hitsPerS / 90000, 0, 0.08) * state.dt;       // per tick
  state.shieldRegen = (0.002 + 0.010*authNorm + 0.008*state.magK*state.coherence) * state.dt;
  state.shieldHP = clamp(state.shieldHP - drain + state.shieldRegen, 0, 1);

  // --- Logging ---
  const progress = (state.Deff_AU<=0) ? 0 : (state.traveled_eff_AU / state.Deff_AU);
  const rem_eff_AU = Math.max(0, state.Deff_AU - state.traveled_eff_AU);
  const eta_s = (rem_eff_AU*AU) / v_ms;

  if (state.tick % state.logEvery === 0){
    state.csv.push([
      state.t.toFixed(2),
      (state.epoch_ms + state.t*1000).toFixed(0),
      state.warpMode,
      state.earth4.x.toFixed(6), state.earth4.y.toFixed(6), state.earth4.z.toFixed(6), state.earth4.w.toFixed(6),
      state.mars4.x.toFixed(6),  state.mars4.y.toFixed(6),  state.mars4.z.toFixed(6),  state.mars4.w.toFixed(6),
      state.phase_deg.toFixed(3),
      state.D3_AU.toFixed(6),
      state.D4_AU.toFixed(6),
      state.Deff_AU.toFixed(6),
      (progress*100).toFixed(4),
      (isFinite(eta_s)?eta_s.toFixed(2):""),
      state.v_kms.toFixed(2),
      state.warpF.toFixed(2),
      state.compGain.toFixed(3),
      state.tension.toFixed(3),
      state.magK.toFixed(3),
      state.B_T.toFixed(6),
      state.hitsPerS.toFixed(2),
      state.shieldHP.toFixed(4),
      state.E_J.toFixed(0),
      auth.toFixed(6),
      state.stability.toFixed(4),
      state.tidal.toFixed(4),
      state.coherence.toFixed(4),
      state.drift_s.toFixed(6)
    ]);
  }

  // status / phase
  if (progress >= 1){
    state.running = false;
    setPill("statusPill","STATUS: ARRIVED","good");
    setPill("phasePill","PHASE: ARRIVAL","good");
    pushLog("Arrival reached (effective corridor completed).");
  } else {
    if (state.shieldHP < 0.25) setPill("statusPill","STATUS: SHIELD LOW","warn");
    else if (state.tidal > 0.75) setPill("statusPill","STATUS: TIDAL WARNING","warn");
    else if (state.stability < 0.35) setPill("statusPill","STATUS: STABILITY LOW","warn");
    else setPill("statusPill", state.running ? "STATUS: RUNNING" : "STATUS: PAUSED", state.running ? "" : "warn");
  }
}

// ===== Fastest path solver (toy scan) =====
function solveFastest(){
  readInputs();
  const now_ms = state.epoch_ms;
  const days = state.scanDays;

  const steps = Math.min(2400, Math.max(160, Math.floor(days*6)));
  const dt_ms = (days*DAY*1000) / steps;

  const v_ms = state.v_kms * 1000;
  const auth = authorityKg();
  const authNorm = clamp(auth / 1e6, 0, 1);

  let best = null;

  for (let i=0;i<=steps;i++){
    const t_ms = now_ms + i*dt_ms;
    const E = planet4D("earth", t_ms);
    const M = planet4D("mars",  t_ms);

    const D3 = dist3AU(E,M) * presetMultiplier();
    const D4 = dist4AU(E,M) * presetMultiplier();

    const phaseDeg = phaseAngleDeg(E,M);

    // approximate coherence in scan as “better when tension high and pert low”
    const cohApprox = clamp(0.85 + 0.12*state.tension - 0.25*state.pert, 0, 1);
    const compMul = 1 + state.compGain * state.warpMode * (0.35 + 0.65*cohApprox);
    const Deff = (D4 / state.warpF) / compMul;

    const eta = (Deff*AU) / v_ms;

    // phase soft target (demo only)
    const ideal = 44;
    const phaseErr = Math.abs(phaseDeg - ideal);
    const phasePenalty = (phaseErr/180) * (0.18 + 0.30*(1-state.tension)) * (eta*0.18);

    // stability penalty
    const aggress = clamp((state.warpF - 1)/49, 0, 1);
    const instability = (1-authNorm)*aggress*(1-state.tension) + state.pert*(0.25 + 0.15*(state.warpMode-1));
    const instPenalty = instability * (eta*0.22);

    // particle penalty
    const particle = state.env * (0.35 + 0.45*(state.warpMode-1)) * (1 - (0.20 + 0.50*state.magK));
    const partPenalty = particle * (eta*0.10);

    const score = eta + phasePenalty + instPenalty + partPenalty;

    if (!best || score < best.score){
      best = { depart_ms:t_ms, score, eta_s:eta, D3_AU:D3, D4_AU:D4, phase_deg:phaseDeg, Deff_AU:Deff };
    }
  }

  state.best = best;
  if (best){
    pushLog(`Solver: best departure (next ${days}d) = ${new Date(best.depart_ms).toLocaleString()} · ETA≈${fmtHMS(best.eta_s)} · phase≈${best.phase_deg.toFixed(1)}° · D3≈${best.D3_AU.toFixed(3)} AU`);
    setPill("phasePill","PHASE: SOLVED PATH","good");
  } else {
    pushLog("Solver: no solution (unexpected).");
    setPill("phasePill","PHASE: SOLVER FAIL","bad");
  }
  render();
}
</script>
<!-- ======================= PART 4 / 5 ======================= -->
<script>
// ===== Map drawing (Earth/Mars + moving ship marker) =====
function drawMap(){
  const cv = $("map");
  const ctx = cv.getContext("2d");
  const w = cv.width, h = cv.height;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "rgba(2,6,23,.45)";
  ctx.fillRect(0,0,w,h);

  // grid
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(148,163,184,.35)";
  for (let i=0;i<=10;i++){
    const x=(i/10)*w;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  for (let i=0;i<=6;i++){
    const y=(i/6)*h;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  const cx=w*0.52, cy=h*0.52;
  const scale=Math.min(w,h)*0.23;

  const px=(xAU)=>cx + xAU*scale;
  const py=(yAU)=>cy + yAU*scale;

  // orbits
  ctx.globalAlpha=0.80;
  ctx.lineWidth=2;
  const circle=(rAU, stroke)=>{
    ctx.strokeStyle=stroke;
    ctx.beginPath();
    for(let k=0;k<=360;k++){
      const a=k*Math.PI/180;
      const x=rAU*Math.cos(a), y=rAU*Math.sin(a);
      if(k===0) ctx.moveTo(px(x),py(y)); else ctx.lineTo(px(x),py(y));
    }
    ctx.stroke();
  };
  circle(ORBIT.earth.a_AU,"rgba(96,165,250,.45)");
  circle(ORBIT.mars.a_AU,"rgba(251,191,36,.45)");

  // sun
  ctx.globalAlpha=1;
  ctx.fillStyle="rgba(255,255,255,.9)";
  ctx.beginPath(); ctx.arc(px(0),py(0),6,0,Math.PI*2); ctx.fill();

  // Earth & Mars positions
  const E=state.earth4, M=state.mars4;
  ctx.fillStyle="rgba(96,165,250,.95)";
  ctx.beginPath(); ctx.arc(px(E.x),py(E.y),6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="rgba(251,191,36,.95)";
  ctx.beginPath(); ctx.arc(px(M.x),py(M.y),6,0,Math.PI*2); ctx.fill();

  // ship marker: interpolate along current Earth->Mars line using progress (live)
  const progress = (state.Deff_AU<=0) ? 0 : (state.traveled_eff_AU / state.Deff_AU);
  const sx = E.x + (M.x - E.x)*progress;
  const sy = E.y + (M.y - E.y)*progress;

  // corridor line
  ctx.globalAlpha=0.70;
  ctx.strokeStyle="rgba(226,232,240,.55)";
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(px(E.x),py(E.y)); ctx.lineTo(px(M.x),py(M.y)); ctx.stroke();

  // ship
  ctx.globalAlpha=1;
  ctx.fillStyle="rgba(52,211,153,.95)";
  ctx.beginPath(); ctx.arc(px(sx),py(sy),5,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,.55)";
  ctx.lineWidth=1;
  ctx.stroke();

  // best departure line (solver)
  if (state.best){
    const E2 = planet4D("earth", state.best.depart_ms);
    const M2 = planet4D("mars",  state.best.depart_ms);
    ctx.globalAlpha=0.35;
    ctx.strokeStyle="rgba(52,211,153,.75)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(px(E2.x),py(E2.y)); ctx.lineTo(px(M2.x),py(M2.y)); ctx.stroke();
  }

  // labels
  ctx.globalAlpha=0.95;
  ctx.fillStyle="rgba(226,232,240,.9)";
  ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText("Blue=Earth, Gold=Mars, Green=Ship (moves on Start)", 12, 18);
  ctx.fillText(`WarpMode=${state.warpMode}  warpF=${state.warpF.toFixed(2)}  D_eff=${state.Deff_AU.toFixed(4)} AU`, 12, 36);
}

// ===== Render panels (live) =====
function render(){
  // always update ephemeris so the map moves while running
  updateEphemeris();

  // clocks (with milliseconds)
  const now = new Date();
  $("utcV").textContent = hhmmssMs(now);

  const cstDate = new Date(now.getTime() + state.cstClock_s*1000);
  const shipDate = new Date(now.getTime() + state.shipClock_s*1000);

  $("cstV").textContent = hhmmssMs(cstDate);
  $("shipV").textContent = hhmmssMs(shipDate);

  $("cstOffV").textContent = `Δ=${(state.cstClock_s*1000).toFixed(3)} ms`;
  $("shipOffV").textContent = `Δ=${(state.shipClock_s*1000).toFixed(3)} ms`;

  // 4D coords
  $("e4V").textContent = `${fmtAU(state.earth4.x)}, ${fmtAU(state.earth4.y)}, ${fmtAU(state.earth4.z)}, ${fmtAU(state.earth4.w)}`;
  $("m4V").textContent = `${fmtAU(state.mars4.x)}, ${fmtAU(state.mars4.y)}, ${fmtAU(state.mars4.z)}, ${fmtAU(state.mars4.w)}`;

  // separations
  $("d3V").textContent = `${state.D3_AU.toFixed(4)} AU · ${fmtKmFromAU(state.D3_AU)}`;
  $("d4V").textContent = `${state.D4_AU.toFixed(4)} AU · ${fmtKmFromAU(state.D4_AU)}`;
  $("phV").textContent = `${state.phase_deg.toFixed(2)}°`;

  // compression
  const compMul = compressionMultiplier();
  const Deff = (state.D4_AU / state.warpF) / compMul;
  state.Deff_AU = Deff;

  $("compV").textContent = `mult=${compMul.toFixed(3)}  ·  shrink=${(1/compMul).toFixed(3)}`;
  $("effV").textContent = `D_eff=${Deff.toFixed(5)} AU · ${fmtKmFromAU(Deff)}`;

  // progress / traveled / remaining / eta
  const v_ms = state.v_kms*1000;
  const progress = (state.Deff_AU<=0) ? 0 : (state.traveled_eff_AU / state.Deff_AU);
  const rem_eff_AU = Math.max(0, state.Deff_AU - state.traveled_eff_AU);
  const eta_s = (rem_eff_AU*AU) / v_ms;

  $("etaV").textContent = fmtHMS(eta_s);

  $("progV").textContent = `${(progress*100).toFixed(3)}%`;
  $("progBar").style.width = clamp(progress*100,0,100) + "%";
  $("progBar").style.background =
    progress>0.98 ? "linear-gradient(90deg, rgba(52,211,153,.9), rgba(96,165,250,.9))"
                  : "linear-gradient(90deg, rgba(96,165,250,.9), rgba(52,211,153,.9))";

  const traveledKm = (state.traveled_eff_AU * AU) / 1000;
  $("trvV").textContent = `traveled: ${traveledKm.toFixed(1)} km  ·  remaining: ${fmtKmFromAU(rem_eff_AU)}`;

  // stability / tidal
  $("stabV").textContent = `${fmt2(state.stability)} / 1.00`;
  $("stabBar").style.width = clamp(state.stability*100,0,100) + "%";
  $("stabBar").style.background =
    state.stability>0.7 ? "linear-gradient(90deg, rgba(52,211,153,.95), rgba(52,211,153,.55))"
    : state.stability>0.4 ? "linear-gradient(90deg, rgba(251,191,36,.95), rgba(251,191,36,.55))"
    : "linear-gradient(90deg, rgba(251,113,133,.95), rgba(251,113,133,.55))";

  $("tidalV").textContent = `${fmt2(state.tidal)} / 1.00`;

  // corridor index
  const authNorm = clamp(authorityKg() / 1e6, 0, 1);
  const gci = clamp(
    0.08
    + 0.38*state.stability
    + 0.20*state.coherence
    + 0.12*authNorm
    + 0.16*state.tension
    + 0.06*state.confinement,
    0, 1
  );
  $("gciV").textContent = `${fmt2(gci)} / 1.00`;

  // drift in ms (more visibly “live”)
  $("driftV").textContent = `${(state.drift_s*1000>=0?"+":"")}${(state.drift_s*1000).toFixed(3)} ms`;

  // gravity test readout (conceptual GR framing)
  $("gravTestV").textContent = `proper≈${state.properAccel.toFixed(3)} m/s² · curvature≈${state.curvature.toFixed(3)} (0..1)`;

  // magnetic stabilizer panel
  $("magV").textContent = `B=${state.B_T.toFixed(4)} T · conf=${state.confinement.toFixed(3)} · coh=${state.coherence.toFixed(3)}`;

  // particle defense panel
  const shieldTone = state.shieldHP < 0.25 ? "LOW" : state.shieldHP < 0.55 ? "MID" : "OK";
  $("shieldV").textContent = `status=${shieldTone} · deflect≈${(clamp(0.20 + 0.70*state.confinement,0,0.95)*100).toFixed(1)}%`;
  $("hitsV").textContent = `hits/s: ${state.hitsPerS.toFixed(1)}`;
  $("hpV").textContent = `shield: ${(state.shieldHP*100).toFixed(1)}%`;

  // pills
  $("simRatePill").textContent = `dt: ${state.dt.toFixed(2)} s`;
  if (!state.running && progress>0 && progress<1) setPill("phasePill","PHASE: COAST / HOLD","warn");
  if (!state.running && progress===0 && !state.best) setPill("phasePill","PHASE: IDLE");
  if (state.running) setPill("phasePill","PHASE: CORRIDOR ACTIVE");

  drawMap();
}

// ===== Timer loop =====
let timer = null;
function start(){
  if (state.running) return;
  state.running = true;
  setPill("statusPill","STATUS: RUNNING");
  setPill("phasePill","PHASE: CORRIDOR ACTIVE");
  pushLog("Start: corridor + compression + magnetic stabilization engaged (toy).");
  if (timer) clearInterval(timer);
  timer = setInterval(()=>{
    if (!state.running) return;
    updateOneTick();
    render();
  }, state.dt*1000);
}
function stop(){
  if (!state.running) return;
  state.running = false;
  setPill("statusPill","STATUS: PAUSED","warn");
  setPill("phasePill","PHASE: COAST / HOLD","warn");
  pushLog("Stop: corridor paused.");
}
</script>
<!-- ======================= PART 5 / 5 ======================= -->
<script>
// ===== CSV + Print =====
function toCSV(rows){
  return rows.map(r => r.map(cell=>{
    const s = String(cell ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }).join(",")).join("\n");
}
function downloadCSV(){
  if (!state.csv || state.csv.length<2){
    pushLog("CSV: nothing to export yet.");
    return;
  }
  const blob = new Blob([toCSV(state.csv)], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `cst-4d-earth-mars-compression-shield-${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  pushLog(`CSV downloaded (${state.csv.length-1} rows).`);
}
function doPrint(){
  pushLog("Print: opening print dialog.");
  window.print();
}

// ===== Bind UI =====
$("btnStart").addEventListener("click", start);
$("btnStop").addEventListener("click", stop);
$("btnReset").addEventListener("click", ()=>resetSim(true));
$("btnSolve").addEventListener("click", solveFastest);
$("btnCSV").addEventListener("click", downloadCSV);
$("btnPrint").addEventListener("click", doPrint);

[
  "epoch","warpMode","preset","baseV","warpF","compGain",
  "EPJ","tension","magK","env","pert","gain","scanDays","logEvery"
].forEach(id=>{
  $(id).addEventListener("input", ()=>{
    if (!state.running){
      readInputs();
      updateEphemeris();
      pushLog(`Tuned: ${id} updated.`);
      render();
    }
  });
});

// ===== Initialize =====
(function init(){
  setEpochDefault();
  readInputs();
  resetSim(true);

  // keep the map/clocks moving even when paused (so it looks “live”)
  setInterval(()=>{ if (!state.running) render(); }, 200);

  pushLog("Ready. Start to move the ship marker toward Mars. Use Solve Fastest Path for best-departure (toy).");
})();
</script>

</div>
</body>
</html>
