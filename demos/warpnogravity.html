<!-- ======================= PART 1 / 5 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Geometry-Engine — 4D Earth↔Mars String-Path (Live Panels + CSV)</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#070b14;
    --panel:#0f172a;
    --panel2:#0b1222;
    --ink:#e5e7eb;
    --muted:#9aa4c7;
    --accent:#60a5fa;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --line:rgba(148,163,184,.22);
    --radius:16px;
    --shadow:0 18px 40px rgba(0,0,0,.45);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 800px at 20% -10%, #14203b, var(--bg));
    color:var(--ink);
  }
  .wrap{max-width:1400px;margin:18px auto;padding:14px}
  header{
    display:flex;flex-wrap:wrap;align-items:flex-end;gap:12px;
    padding:14px 16px;border:1px solid var(--line);border-radius:var(--radius);
    background: linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.80));
    box-shadow:var(--shadow);
  }
  header h1{margin:0;font-size:20px;letter-spacing:.2px}
  header .sub{color:var(--muted);font-size:12.5px;max-width:980px;line-height:1.35}
  .row{display:grid;grid-template-columns: 460px 1fr; gap:12px; margin-top:12px}
  @media (max-width: 1120px){ .row{grid-template-columns:1fr} }
  .card{
    border:1px solid var(--line);
    border-radius:var(--radius);
    background: linear-gradient(135deg, rgba(15,23,42,.96), rgba(15,23,42,.80));
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .card .hd b{font-size:13px;letter-spacing:.25px}
  .pill{
    font-size:11px;color:var(--muted);
    padding:4px 8px;border:1px solid var(--line);
    border-radius:999px;background:rgba(2,6,23,.45)
  }
  .card .bd{padding:12px 14px}
  .grid2{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
  .grid3{display:grid;grid-template-columns: 1fr 1fr 1fr; gap:10px}
  @media (max-width: 980px){ .grid3{grid-template-columns:1fr} .grid2{grid-template-columns:1fr} }
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="range"]{width:100%}
  input[type="number"], input[type="datetime-local"], select{
    width:100%;
    padding:9px 10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:rgba(2,6,23,.55);
    color:var(--ink);
    outline:none;
  }
  .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  button{
    cursor:pointer;
    border:1px solid var(--line);
    color:var(--ink);
    background: rgba(2,6,23,.55);
    padding:10px 12px;
    border-radius:12px;
    font-weight:800;
  }
  button.primary{border-color:rgba(96,165,250,.6); box-shadow:0 0 0 2px rgba(96,165,250,.15) inset}
  button.good{border-color:rgba(52,211,153,.6); box-shadow:0 0 0 2px rgba(52,211,153,.12) inset}
  button.warn{border-color:rgba(251,191,36,.6); box-shadow:0 0 0 2px rgba(251,191,36,.10) inset}
  button.bad{border-color:rgba(251,113,133,.6); box-shadow:0 0 0 2px rgba(251,113,133,.10) inset}
  .kpi{
    border:1px solid var(--line);
    border-radius:14px;
    background: rgba(2,6,23,.45);
    padding:10px 12px;
  }
  .kpi .t{font-size:11px;color:var(--muted)}
  .kpi .v{margin-top:4px;font-size:15px;font-weight:900}
  .kpi .s{margin-top:4px;font-size:11px;color:var(--muted);line-height:1.25}
  .mono{font-family:var(--mono)}
  .bar{
    height:10px;border-radius:999px;border:1px solid var(--line);
    background: rgba(2,6,23,.55);
    overflow:hidden;
  }
  .bar > i{display:block;height:100%;width:0%}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  .rightCols{display:grid;grid-template-columns: 1.2fr .8fr; gap:12px}
  @media (max-width: 1120px){ .rightCols{grid-template-columns:1fr} }
  .log{
    height:170px; overflow:auto; padding:10px 12px;
    border-radius:14px;border:1px solid var(--line);
    background: rgba(2,6,23,.45);
    font-family:var(--mono); font-size:11px; color:#cfe3ff;
    white-space:pre-wrap;
  }
  .canvasWrap{
    border:1px solid var(--line);
    border-radius:14px;
    background: rgba(2,6,23,.35);
    overflow:hidden;
  }
  canvas{display:block;width:100%;height:260px}

  /* Print */
  @media print{
    body{background:#fff;color:#000}
    header,.card{box-shadow:none}
    .pill,.btns, .small.noprint{display:none !important}
    .card{break-inside:avoid}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>CST Geometry-Engine — Earth ↔ Mars in a 4D Box (String-Path Toy)</h1>
      <div class="sub">
        <b>Gravity-as-geometry framing:</b> you don’t “feel a force,” you follow geodesics; strings/constraints can <i>bias</i> those paths.
        Here we treat Earth & Mars as moving points in a <span class="mono">4D (x,y,z,w)</span> box where <span class="mono">w</span> is a time-like phase coordinate.
        A “string corridor” computes a fast path by minimizing a toy 4D action (distance + phase alignment + stability).
        <span class="mono">m = E / c²</span> is used only as an “authority budget” accounting.
      </div>
    </div>
    <span class="pill mono" id="statusPill">STATUS: READY</span>
  </header>

  <div class="row">
    <!-- LEFT: Controls -->
    <section class="card">
      <div class="hd">
        <b>Controls</b>
        <span class="pill mono" id="simRatePill">dt: 0.25 s</span>
      </div>
      <div class="bd">
        <div class="grid2">
          <div>
            <label>Start epoch (local time)</label>
            <input id="epoch" type="datetime-local" />
            <div class="small">Sets the “now” for Earth/Mars coordinates (toy ephemeris).</div>
          </div>
          <div>
            <label>Distance preset (for quick demos)</label>
            <select id="preset">
              <option value="auto" selected>Auto (from 4D coordinates)</option>
              <option value="opp">Opposition-like (closer)</option>
              <option value="avg">Average</option>
              <option value="conj">Conjunction-like (farther)</option>
            </select>
            <div class="small">Preset only nudges the toy model; “Auto” uses orbit geometry directly.</div>
          </div>

          <div>
            <label>Base cruise (km/s) — corridor “free-fall” speed</label>
            <input id="baseV" type="number" min="1" max="200" step="1" value="24" />
            <div class="small">Effective ETA uses the <b>string corridor</b> distance, not raw separation.</div>
          </div>
          <div>
            <label>Corridor compression factor (1–50)</label>
            <input id="warpF" type="number" min="1" max="50" step="0.5" value="6" />
            <div class="small"><span class="mono">D_eff ≈ D_4D / factor</span> (toy: geometry reduces effective separation).</div>
          </div>

          <div>
            <label>Field energy available (PJ)</label>
            <input id="EPJ" type="number" min="0" max="500000" step="100" value="8000" />
            <div class="small">Authority budget: <span class="mono">m_eq = E/c²</span> (accounting only).</div>
          </div>
          <div>
            <label>String tension (0–1) — “constraint pull” strength</label>
            <input id="tension" type="range" min="0" max="1" step="0.01" value="0.55" />
            <div class="small">Higher tension = tighter corridor + stronger preference for shortest 4D path.</div>
          </div>

          <div>
            <label>Perturbation level (0–1)</label>
            <input id="pert" type="range" min="0" max="1" step="0.01" value="0.25" />
            <div class="small">Toy: injects jitter & clock drift (environment, GW-like noise, control errors).</div>
          </div>
          <div>
            <label>Clock feedback gain (0–1)</label>
            <input id="gain" type="range" min="0" max="1" step="0.01" value="0.55" />
            <div class="small">Higher = stronger CST correction back toward coherence.</div>
          </div>

          <div>
            <label>Scan window for “best departure” (days ahead)</label>
            <input id="scanDays" type="number" min="5" max="1200" step="5" value="240" />
            <div class="small">Finds a fast corridor time even if Mars is “far” right now (toy optimizer).</div>
          </div>
          <div>
            <label>Logging cadence</label>
            <select id="logEvery">
              <option value="1">Every tick</option>
              <option value="2" selected>Every 2 ticks</option>
              <option value="4">Every 4 ticks</option>
              <option value="8">Every 8 ticks</option>
            </select>
            <div class="small">Reduces CSV row count.</div>
          </div>
        </div>

        <div class="btns">
          <button class="good" id="btnStart">Start</button>
          <button class="warn" id="btnStop">Stop</button>
          <button class="bad" id="btnReset">Reset</button>
          <button class="primary" id="btnSolve">Solve Fastest Path</button>
          <button class="primary" id="btnCSV">Download CSV</button>
          <button id="btnPrint">Print</button>
        </div>

        <div class="small noprint" style="margin-top:10px">
          <b>Physics note (your top+string example):</b> the “string” applies a constraint that redirects motion; the top’s spin stays “up” until
          friction + wobble reduce stability. In this toy, “string tension” is a controllable constraint that biases a geodesic corridor. Gravity is treated as
          geometry (paths), not a pull.
        </div>
      </div>
    </section>

    <!-- RIGHT: Dash -->
    <section class="rightCols">
      <div class="card">
        <div class="hd">
          <b>Live Flight Panels</b>
          <span class="pill mono" id="phasePill">PHASE: IDLE</span>
        </div>
        <div class="bd">
          <div class="grid3">
            <div class="kpi">
              <div class="t">Clock — UTC</div>
              <div class="v mono" id="utcV">--:--:--</div>
              <div class="s">Earth reference (display only)</div>
            </div>
            <div class="kpi">
              <div class="t">Clock — CST</div>
              <div class="v mono" id="cstV">--:--:--</div>
              <div class="s">Toy: corrected by feedback (coherence control)</div>
            </div>
            <div class="kpi">
              <div class="t">Clock — Ship (local)</div>
              <div class="v mono" id="shipV">--:--:--</div>
              <div class="s">Toy oscillator + corridor correction</div>
            </div>

            <div class="kpi">
              <div class="t">4D Separation (raw)</div>
              <div class="v mono" id="d4V">—</div>
              <div class="s">Distance in (x,y,z,w) with w-scale (toy)</div>
            </div>
            <div class="kpi">
              <div class="t">ETA (proper-time, toy)</div>
              <div class="v mono" id="etaV">—</div>
              <div class="s">Uses <span class="mono">D_eff = D_4D / warpFactor</span></div>
            </div>
            <div class="kpi">
              <div class="t">Progress</div>
              <div class="v mono" id="progV">0.0%</div>
              <div class="s"><div class="bar"><i id="progBar"></i></div></div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid3">
            <div class="kpi">
              <div class="t">Earth 4D (x,y,z,w)</div>
              <div class="v mono" id="e4V">—</div>
              <div class="s">AU units (w in “AU-equivalent” via scale)</div>
            </div>
            <div class="kpi">
              <div class="t">Mars 4D (x,y,z,w)</div>
              <div class="v mono" id="m4V">—</div>
              <div class="s">Toy orbit inclinations included</div>
            </div>
            <div class="kpi">
              <div class="t">Phase angle (Earth→Mars)</div>
              <div class="v mono" id="phV">—</div>
              <div class="s">Used by the “fastest-path” solver (toy)</div>
            </div>

            <div class="kpi">
              <div class="t">Geodesic Corridor Index</div>
              <div class="v mono" id="gciV">—</div>
              <div class="s">Stability × coherence × authority × tension</div>
            </div>
            <div class="kpi">
              <div class="t">Clock drift (Ship − CST)</div>
              <div class="v mono" id="driftV">—</div>
              <div class="s">Perturbations push drift; feedback suppresses</div>
            </div>
            <div class="kpi">
              <div class="t">Stability & Tidal proxy</div>
              <div class="v mono" id="stabV">—</div>
              <div class="s">
                <div class="bar"><i id="stabBar"></i></div>
                <div class="mono" id="tidalV" style="margin-top:6px">—</div>
              </div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div class="kpi">
              <div class="t">Curvature authority (mass-equiv)</div>
              <div class="v mono" id="meqV">—</div>
              <div class="s"><span class="mono">m = E/c²</span> using E in joules (accounting)</div>
            </div>
            <div class="kpi">
              <div class="t">Effective corridor remaining</div>
              <div class="v mono" id="remV">—</div>
              <div class="s">D_eff remaining (toy), mapped to “progress”</div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="kpi">
            <div class="t">Mini-map (Sun-centered, toy orbits)</div>
            <div class="canvasWrap"><canvas id="map" width="900" height="260"></canvas></div>
          </div>

          <div style="height:10px"></div>

          <div class="kpi">
            <div class="t">Event log</div>
            <div class="log" id="logBox"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <b>Model Notes</b>
          <span class="pill mono">Toy math</span>
        </div>
        <div class="bd">
          <div class="small">
            <b>4D box:</b> planets are moving points <span class="mono">(x,y,z,w)</span>. Here <span class="mono">w</span> is a time-like phase coordinate turned into
            distance units with <span class="mono">wScale</span> (AU-equivalent).<br/>
            <b>4D separation:</b> <span class="mono">D_4D = √(dx²+dy²+dz² + (wScale·dw)²)</span> (toy).<br/>
            <b>Corridor:</b> <span class="mono">D_eff = D_4D / warpFactor</span>, then <span class="mono">ETA = D_eff / v</span>.<br/>
            <b>“String tension”:</b> biases the corridor to prefer shorter 4D action & suppress jitter (toy constraint strength).<br/>
            <b>Gravity not a force (your framing):</b> “fall” is following a path in curved spacetime; a string/top is an external constraint redirecting motion.<br/>
          </div>
          <div style="height:10px"></div>
          <div class="small">
            <b>Reminder:</b> This is a visualization of your document’s concepts (geometry-first + CST clock regulation + string-like constraints),
            not a physical navigation solution.
          </div>
        </div>
      </div>
    </section>
  </div>
<!-- ======================= PART 2 / 5 ======================= -->
<script>
"use strict";
const $ = (id)=>document.getElementById(id);

// ===== Constants =====
const c = 299792458;            // m/s
const PJ = 1e15;                // petajoule -> joule
const AU = 149597870700;        // meters
const DAY = 86400;              // seconds
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

// Toy orbital parameters (simple circular + small inclination)
const ORBIT = {
  earth: { a_AU: 1.000, period_d: 365.256, inc_deg: 0.000, phase0: 0.0 },
  mars:  { a_AU: 1.523, period_d: 686.980, inc_deg: 1.850, phase0: 0.35 } // phase0 just offsets
};

// w-dimension scale (AU-equivalent distance per phase-radian)
const W = {
  wScale_AU: 0.20,     // how “time-like” dimension contributes to 4D distance
  // interpret dw as phase difference (radians) or normalized time; we use phase-radians here
};

// ===== Formatting =====
function fmt2(x){ return (Math.round(x*100)/100).toFixed(2); }
function fmt1(x){ return (Math.round(x*10)/10).toFixed(1); }
function fmt0(x){ return Math.round(x).toString(); }

function hhmmss(date){
  const h=String(date.getHours()).padStart(2,"0");
  const m=String(date.getMinutes()).padStart(2,"0");
  const s=String(date.getSeconds()).padStart(2,"0");
  return `${h}:${m}:${s}`;
}
function fmtHMS(sec){
  if (!isFinite(sec) || sec < 0) return "—";
  sec = Math.floor(sec);
  const d = Math.floor(sec/86400); sec -= d*86400;
  const h = Math.floor(sec/3600); sec -= h*3600;
  const m = Math.floor(sec/60);   sec -= m*60;
  const s = sec;
  if (d>0) return `${d}d ${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
}
function fmtAU(x){
  if (!isFinite(x)) return "—";
  return (x>=0?"+":"") + x.toFixed(4);
}
function fmtKmFromAU(au){
  const m = au * AU;
  const km = m/1000;
  if (km >= 1e9) return (km/1e9).toFixed(3)+" Bkm";
  if (km >= 1e6) return (km/1e6).toFixed(3)+" Mkm";
  if (km >= 1e3) return (km/1e3).toFixed(1)+" kkm";
  return km.toFixed(0)+" km";
}

// ===== State =====
const state = {
  running:false,
  dt:0.25,                 // seconds per tick
  t:0,                     // sim seconds elapsed (ship proper time, toy)
  tick:0,

  // knobs
  epoch_ms: Date.now(),
  preset: "auto",
  v_kms: 24,
  warpF: 6,
  E_J: 8000*PJ,
  tension: 0.55,
  pert: 0.25,
  gain: 0.55,
  scanDays: 240,
  logEvery: 2,

  // evolving
  drift_s: 0,
  shipClock_s: 0,
  cstClock_s: 0,
  stability: 1,
  tidal: 0,

  // navigation / corridor progress
  D4_AU: 0,
  Deff_AU: 0,
  traveled_eff_AU: 0,

  // last computed
  earth4: {x:0,y:0,z:0,w:0, theta:0},
  mars4:  {x:0,y:0,z:0,w:0, theta:0},
  phase_deg: 0,

  // solver recommendation
  best: null, // { depart_ms, score, eta_s, D4_AU, phase_deg }

  // logging
  csv: [],
  lastLog: []
};

// ===== UI helpers =====
function setPill(id, txt, tone=""){
  const el=$(id);
  el.textContent = txt;
  el.style.borderColor = tone==="good" ? "rgba(52,211,153,.6)"
                      : tone==="warn" ? "rgba(251,191,36,.6)"
                      : tone==="bad"  ? "rgba(251,113,133,.6)"
                      : "rgba(148,163,184,.22)";
}
function pushLog(line){
  const ts = new Date();
  const msg = `[${hhmmss(ts)}] ${line}`;
  state.lastLog.push(msg);
  if (state.lastLog.length>16) state.lastLog.shift();
  $("logBox").textContent = state.lastLog.join("\n");
}

// ===== Inputs =====
function setEpochDefault(){
  // round to minute for nicer datetime-local value
  const d = new Date();
  d.setSeconds(0); d.setMilliseconds(0);
  const pad=(n)=>String(n).padStart(2,"0");
  const v = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  $("epoch").value = v;
  state.epoch_ms = d.getTime();
}
function readInputs(){
  // epoch
  const raw = $("epoch").value;
  if (raw){
    const ms = new Date(raw).getTime();
    if (isFinite(ms)) state.epoch_ms = ms;
  }

  state.preset = $("preset").value || "auto";
  state.v_kms = clamp(Number($("baseV").value||24), 1, 200);
  state.warpF = clamp(Number($("warpF").value||6), 1, 50);
  state.E_J   = clamp(Number($("EPJ").value||0), 0, 500000)*PJ;
  state.tension = clamp(Number($("tension").value||0.55), 0, 1);
  state.pert  = clamp(Number($("pert").value||0.25), 0, 1);
  state.gain  = clamp(Number($("gain").value||0.55), 0, 1);
  state.scanDays = clamp(Number($("scanDays").value||240), 5, 1200);
  state.logEvery = Number($("logEvery").value||2);
}

// ===== Reset =====
function resetSim(keepInputs=true){
  if (keepInputs) readInputs();

  state.running = false;
  state.t = 0;
  state.tick = 0;
  state.traveled_eff_AU = 0;

  state.drift_s = 0;
  state.shipClock_s = 0;
  state.cstClock_s = 0;

  state.stability = 1;
  state.tidal = 0;
  state.best = null;

  state.csv = [];
  state.lastLog = [];
  $("logBox").textContent = "";

  // CSV header
  state.csv.push([
    "t_s",
    "epoch_ms",
    "earth_x_AU","earth_y_AU","earth_z_AU","earth_w_AU",
    "mars_x_AU","mars_y_AU","mars_z_AU","mars_w_AU",
    "phase_deg",
    "D4_AU",
    "D_eff_AU",
    "progress_pct",
    "eta_s",
    "warpFactor",
    "v_base_km_s",
    "tension_0_1",
    "E_J",
    "m_eq_kg",
    "stability_0_1",
    "tidal_proxy_0_1",
    "clock_drift_ship_minus_cst_s",
    "cst_correction_s"
  ]);

  setPill("statusPill","STATUS: READY");
  setPill("phasePill","PHASE: IDLE");
  render();
  pushLog("Reset complete.");
}
</script>
<!-- ======================= PART 3 / 5 ======================= -->
<script>
// ===== 4D orbit model (toy) =====
function deg2rad(d){ return d*Math.PI/180; }
function rad2deg(r){ return r*180/Math.PI; }

// normalize angle to [-π, π]
function wrapPi(a){
  while (a > Math.PI) a -= 2*Math.PI;
  while (a < -Math.PI) a += 2*Math.PI;
  return a;
}

// Simple circular orbit with inclination => (x,y,z) in AU, and w as phase-radians scaled into AU
function planet4D(which, t_ms){
  const P = ORBIT[which];
  const t_days = (t_ms / 1000) / DAY;
  const omega = (2*Math.PI) / P.period_d;
  const theta = wrapPi(P.phase0 + omega * t_days);           // true anomaly (toy)
  const r = P.a_AU;

  // base ecliptic plane
  const x = r*Math.cos(theta);
  const y = r*Math.sin(theta);

  // inclination tilt around x-axis (toy)
  const inc = deg2rad(P.inc_deg);
  const z = y*Math.sin(inc);                 // crude, but gives a nonzero z

  // 4th coordinate: w = theta (phase) mapped into AU distance via wScale
  const w = (W.wScale_AU) * theta;

  return {x,y,z,w,theta};
}

// phase angle Earth→Mars (difference in orbital phase)
function phaseAngleDeg(e, m){
  const d = wrapPi(m.theta - e.theta);
  return rad2deg(d);
}

// raw 4D distance (AU) between two points
function dist4AU(a, b){
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dz = b.z - a.z;
  const dw = b.w - a.w; // already AU-equivalent
  return Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
}

// “preset” nudges (for demos): adjust effective distance multiplier
function presetMultiplier(){
  const p = state.preset;
  if (p==="opp") return 0.70;     // closer
  if (p==="avg") return 1.00;
  if (p==="conj")return 1.35;     // farther
  return 1.00;
}

// Authority: m = E / c^2
function computeAuthorityKg(){
  return state.E_J / (c*c);
}

// ===== toy corridor dynamics =====
function updateEphemerisNow(){
  const t_ms = state.epoch_ms + (state.running ? (state.t*1000) : 0); // while running, “time advances”
  const E4 = planet4D("earth", t_ms);
  const M4 = planet4D("mars", t_ms);

  state.earth4 = E4;
  state.mars4 = M4;
  state.phase_deg = phaseAngleDeg(E4, M4);

  const D4 = dist4AU(E4, M4) * presetMultiplier();
  state.D4_AU = D4;
  state.Deff_AU = (D4 / state.warpF);
}

// corridor stability, drift, and “string constraint” effects
function updateDynamicsOneTick(){
  readInputs();
  state.tick++;
  state.t += state.dt;

  updateEphemerisNow();

  // Travel along effective corridor at base cruise
  const v_ms = state.v_kms * 1000;
  const v_AU_s = v_ms / AU;
  const d_eff_AU = v_AU_s * state.dt;

  // string tension tightens the corridor (reduces “wobble loss”)
  const tension = state.tension;
  const loss = (1 - tension) * state.pert * 0.35; // toy loss factor

  state.traveled_eff_AU = clamp(state.traveled_eff_AU + d_eff_AU*(1 - loss), 0, state.Deff_AU);

  // authority & aggressiveness
  const authority = computeAuthorityKg();
  const authNorm = clamp(authority / 1e6, 0, 1);           // 1e6 kg-eq = “full” in toy units
  const aggress = clamp((state.warpF - 1) / 49, 0, 1);

  // perturbation noise
  const n1 = (Math.random()*2 - 1);
  const driftInject = n1 * state.pert * (0.020 + 0.050*(1-tension));  // seconds per tick
  state.drift_s += driftInject;

  // CST feedback correction (stronger when tension is high)
  const corrGain = (0.10 + 0.20*state.gain) * (0.60 + 0.40*tension);
  const corr = - corrGain * state.drift_s;
  state.drift_s += corr;

  // ship & CST clock offsets (toy)
  const oscNoise = (Math.random()*2 - 1) * state.pert * 0.002;
  state.shipClock_s += (corr * 0.35) + oscNoise;
  state.cstClock_s  += (-driftInject * 0.25) + (corr * 0.65);

  // Coherence from drift
  const coherence = clamp(1 - Math.abs(state.drift_s)/0.25, 0, 1);

  // Stability target: tension helps, perturb hurts, aggress hurts if authority low
  const stTarget = clamp(
    0.20
    + 0.45*coherence
    + 0.25*authNorm
    + 0.18*tension
    - 0.40*state.pert*(1-0.35*tension)
    - 0.35*aggress*(1-authNorm)*(1-0.45*tension),
    0, 1
  );
  state.stability += (stTarget - state.stability) * 0.18;

  // Tidal proxy: worse if aggressive + low stability/authority; tension reduces a bit
  state.tidal = clamp(
    0.12
    + 0.78*aggress*(1-authNorm)
    + 0.55*(1-state.stability)
    - 0.18*tension,
    0, 1
  );

  // logging
  const progress = (state.Deff_AU<=0) ? 0 : (state.traveled_eff_AU / state.Deff_AU);
  const rem_eff_AU = Math.max(0, state.Deff_AU - state.traveled_eff_AU);
  const eta_s = (rem_eff_AU*AU) / v_ms;

  if (state.tick % state.logEvery === 0){
    state.csv.push([
      state.t.toFixed(2),
      (state.epoch_ms + state.t*1000).toFixed(0),
      state.earth4.x.toFixed(6), state.earth4.y.toFixed(6), state.earth4.z.toFixed(6), state.earth4.w.toFixed(6),
      state.mars4.x.toFixed(6),  state.mars4.y.toFixed(6),  state.mars4.z.toFixed(6),  state.mars4.w.toFixed(6),
      state.phase_deg.toFixed(3),
      state.D4_AU.toFixed(6),
      state.Deff_AU.toFixed(6),
      (progress*100).toFixed(3),
      (isFinite(eta_s)?eta_s.toFixed(2):""),
      state.warpF.toFixed(2),
      state.v_kms.toFixed(2),
      state.tension.toFixed(3),
      state.E_J.toFixed(0),
      authority.toFixed(6),
      state.stability.toFixed(4),
      state.tidal.toFixed(4),
      state.drift_s.toFixed(6),
      corr.toFixed(6)
    ]);
  }

  // completion
  if (progress >= 1){
    state.running = false;
    setPill("statusPill","STATUS: ARRIVED","good");
    setPill("phasePill","PHASE: ARRIVAL","good");
    pushLog("Arrival reached (effective corridor completed).");
  } else {
    if (state.tidal > 0.70) setPill("statusPill","STATUS: TIDAL WARNING","warn");
    else if (state.stability < 0.35) setPill("statusPill","STATUS: STABILITY LOW","warn");
    else setPill("statusPill", state.running ? "STATUS: RUNNING" : "STATUS: PAUSED", state.running ? "" : "warn");
  }
}

// ===== “Fastest path” solver (toy optimizer) =====
// We scan forward in time and minimize a score:
// score = (D4/warpF)/v  + phasePenalty  + instabilityPenalty
function solveFastest(){
  readInputs();
  const now_ms = state.epoch_ms;
  const days = state.scanDays;
  const steps = Math.min(2400, Math.max(120, Math.floor(days*6))); // ~4 hours to 1 day resolution depending window
  const dt_ms = (days*DAY*1000) / steps;

  const v_ms = state.v_kms * 1000;
  const authority = computeAuthorityKg();
  const authNorm = clamp(authority / 1e6, 0, 1);

  let best = null;

  for (let i=0;i<=steps;i++){
    const t_ms = now_ms + i*dt_ms;

    const E4 = planet4D("earth", t_ms);
    const M4 = planet4D("mars",  t_ms);
    const phase = wrapPi(M4.theta - E4.theta);
    const phaseDeg = rad2deg(phase);

    const D4 = dist4AU(E4, M4) * presetMultiplier();
    const Deff = D4 / state.warpF;

    // base travel time
    const eta = (Deff*AU) / v_ms;

    // phase preference (toy): favor phase near an “ideal” angle
    // (real Hohmann uses ~44° lead for Mars, but we treat it as a soft target)
    const idealDeg = 44;
    const phaseErr = Math.abs(phaseDeg - idealDeg);
    const phasePenalty = (phaseErr/180) * (0.30 + 0.50*(1-state.tension)) * (eta*0.15);

    // instability penalty: aggressive + low authority raises risk
    const aggress = clamp((state.warpF - 1)/49, 0, 1);
    const instability = (1-authNorm)*aggress*(1-state.tension) + state.pert*0.35;
    const instabilityPenalty = instability * (eta*0.25);

    const score = eta + phasePenalty + instabilityPenalty;

    if (!best || score < best.score){
      best = { depart_ms: t_ms, score, eta_s: eta, D4_AU:D4, phase_deg: phaseDeg };
    }
  }

  state.best = best;

  if (best){
    const d = new Date(best.depart_ms);
    pushLog(`Solver: best departure in next ${fmt0(days)}d = ${d.toLocaleString()} · ETA≈${fmtHMS(best.eta_s)} · phase≈${best.phase_deg.toFixed(1)}° · D4≈${best.D4_AU.toFixed(3)} AU`);
    setPill("phasePill","PHASE: SOLVED PATH","good");
  } else {
    pushLog("Solver: no solution (unexpected).");
    setPill("phasePill","PHASE: SOLVER FAIL","bad");
  }

  render();
}
</script>
<!-- ======================= PART 4 / 5 ======================= -->
<script>
// ===== Rendering (UI + map) =====
function drawMap(){
  const cv = $("map");
  const ctx = cv.getContext("2d");
  const w = cv.width, h = cv.height;
  ctx.clearRect(0,0,w,h);

  // background grid
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(2,6,23,.45)";
  ctx.fillRect(0,0,w,h);

  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(148,163,184,.35)";
  for (let i=0;i<=10;i++){
    const x = (i/10)*w;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  for (let i=0;i<=6;i++){
    const y = (i/6)*h;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  // coordinate transform (AU -> pixels)
  const cx = w*0.52, cy = h*0.52;
  const scale = Math.min(w,h) * 0.23; // pixels per AU

  function px(xAU){ return cx + xAU*scale; }
  function py(yAU){ return cy + yAU*scale; }

  // orbits
  ctx.globalAlpha = 0.8;
  ctx.strokeStyle = "rgba(96,165,250,.45)";
  ctx.lineWidth = 2;

  function circle(rAU){
    ctx.beginPath();
    for (let k=0;k<=360;k++){
      const a = (k*Math.PI/180);
      const x = rAU*Math.cos(a), y = rAU*Math.sin(a);
      if (k===0) ctx.moveTo(px(x), py(y));
      else ctx.lineTo(px(x), py(y));
    }
    ctx.stroke();
  }
  circle(ORBIT.earth.a_AU);
  ctx.strokeStyle = "rgba(251,191,36,.45)";
  circle(ORBIT.mars.a_AU);

  // sun
  ctx.globalAlpha = 1;
  ctx.fillStyle = "rgba(255,255,255,.9)";
  ctx.beginPath(); ctx.arc(px(0), py(0), 6, 0, Math.PI*2); ctx.fill();

  // Earth & Mars
  const E = state.earth4, M = state.mars4;
  ctx.fillStyle = "rgba(96,165,250,.95)";
  ctx.beginPath(); ctx.arc(px(E.x), py(E.y), 6, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "rgba(251,191,36,.95)";
  ctx.beginPath(); ctx.arc(px(M.x), py(M.y), 6, 0, Math.PI*2); ctx.fill();

  // line between them
  ctx.globalAlpha = 0.75;
  ctx.strokeStyle = "rgba(226,232,240,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(px(E.x), py(E.y)); ctx.lineTo(px(M.x), py(M.y)); ctx.stroke();

  // best departure marker (if exists): show future positions in faint colors
  if (state.best){
    const E2 = planet4D("earth", state.best.depart_ms);
    const M2 = planet4D("mars",  state.best.depart_ms);
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(96,165,250,.55)";
    ctx.beginPath(); ctx.arc(px(E2.x), py(E2.y), 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(251,191,36,.55)";
    ctx.beginPath(); ctx.arc(px(M2.x), py(M2.y), 4, 0, Math.PI*2); ctx.fill();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(52,211,153,.75)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(px(E2.x), py(E2.y)); ctx.lineTo(px(M2.x), py(M2.y)); ctx.stroke();
  }

  // legend text
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(226,232,240,.9)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace";
  ctx.fillText("Sun-centered toy map (AU)", 12, 18);
  ctx.fillText("Blue=Earth, Gold=Mars, Green=line=solver best", 12, 36);
}

function render(){
  // clocks
  const now = new Date();
  $("utcV").textContent = hhmmss(now);
  const cstDate = new Date(now.getTime() + state.cstClock_s*1000);
  $("cstV").textContent = hhmmss(cstDate);
  const shipDate = new Date(now.getTime() + state.shipClock_s*1000);
  $("shipV").textContent = hhmmss(shipDate);

  // update ephemeris even while paused
  updateEphemerisNow();

  // 4D values
  $("e4V").textContent =
    `${fmtAU(state.earth4.x)}, ${fmtAU(state.earth4.y)}, ${fmtAU(state.earth4.z)}, ${fmtAU(state.earth4.w)}`;
  $("m4V").textContent =
    `${fmtAU(state.mars4.x)}, ${fmtAU(state.mars4.y)}, ${fmtAU(state.mars4.z)}, ${fmtAU(state.mars4.w)}`;

  $("phV").textContent = `${state.phase_deg.toFixed(2)}°`;
  $("d4V").textContent = `${state.D4_AU.toFixed(4)} AU  ·  ${fmtKmFromAU(state.D4_AU)}`;

  // progress / remaining / eta
  const v_ms = state.v_kms*1000;
  const progress = (state.Deff_AU<=0) ? 0 : (state.traveled_eff_AU / state.Deff_AU);
  const rem_eff_AU = Math.max(0, state.Deff_AU - state.traveled_eff_AU);
  const eta_s = (rem_eff_AU*AU) / v_ms;

  $("etaV").textContent = fmtHMS(eta_s);
  $("progV").textContent = fmt1(progress*100) + "%";
  $("progBar").style.width = clamp(progress*100,0,100) + "%";
  $("progBar").style.background =
    progress>0.98 ? "linear-gradient(90deg, rgba(52,211,153,.9), rgba(96,165,250,.9))"
                  : "linear-gradient(90deg, rgba(96,165,250,.9), rgba(52,211,153,.9))";

  $("remV").textContent =
    `${rem_eff_AU.toFixed(4)} AU eff  ·  (${fmtKmFromAU(rem_eff_AU)} remaining)`;

  // authority / stability / tidal
  const meq = computeAuthorityKg();
  $("meqV").textContent = `${meq.toExponential(6)} kg`;

  $("driftV").textContent = `${state.drift_s>=0?"+":""}${state.drift_s.toFixed(4)} s`;

  $("stabV").textContent = `${fmt2(state.stability)} / 1.00`;
  $("stabBar").style.width = clamp(state.stability*100,0,100) + "%";
  $("stabBar").style.background =
    state.stability>0.7 ? "linear-gradient(90deg, rgba(52,211,153,.95), rgba(52,211,153,.55))"
    : state.stability>0.4 ? "linear-gradient(90deg, rgba(251,191,36,.95), rgba(251,191,36,.55))"
    : "linear-gradient(90deg, rgba(251,113,133,.95), rgba(251,113,133,.55))";

  $("tidalV").textContent = `tidal=${fmt2(state.tidal)} / 1.00`;

  // Corridor Index (toy synthesis)
  const coherence = clamp(1 - Math.abs(state.drift_s)/0.25, 0, 1);
  const authNorm = clamp(meq / 1e6, 0, 1);
  const gci = clamp(
    0.08
    + 0.45*state.stability
    + 0.20*coherence
    + 0.12*authNorm
    + 0.15*state.tension,
    0, 1
  );
  $("gciV").textContent = `${fmt2(gci)} / 1.00`;

  // pills
  $("simRatePill").textContent = `dt: ${state.dt.toFixed(2)} s`;
  if (!state.running && progress>0 && progress<1) setPill("phasePill","PHASE: COAST / HOLD","warn");
  if (!state.running && progress===0 && !state.best) setPill("phasePill","PHASE: IDLE");
  if (state.running) setPill("phasePill","PHASE: CORRIDOR ACTIVE");

  drawMap();
}

// ===== Timer loop =====
let timer = null;
function start(){
  if (state.running) return;
  state.running = true;
  setPill("statusPill","STATUS: RUNNING");
  setPill("phasePill","PHASE: CORRIDOR ACTIVE");
  pushLog("Start: corridor regulation engaged (toy).");
  if (timer) clearInterval(timer);
  timer = setInterval(()=>{
    if (!state.running) return;
    updateDynamicsOneTick();
    render();
  }, state.dt*1000);
}
function stop(){
  if (!state.running) return;
  state.running = false;
  setPill("statusPill","STATUS: PAUSED","warn");
  setPill("phasePill","PHASE: COAST / HOLD","warn");
  pushLog("Stop: corridor regulation paused.");
}

// ===== CSV Download =====
function toCSV(rows){
  return rows.map(r => r.map(cell=>{
    const s = String(cell ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }).join(",")).join("\n");
}
function downloadCSV(){
  if (!state.csv || state.csv.length<2){
    pushLog("CSV: nothing to export yet.");
    return;
  }
  const csvText = toCSV(state.csv);
  const blob = new Blob([csvText], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `cst-4d-earth-mars-stringpath-${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  pushLog(`CSV downloaded (${state.csv.length-1} rows).`);
}

// ===== Print =====
function doPrint(){
  pushLog("Print: opening print dialog.");
  window.print();
}
</script>
<!-- ======================= PART 5 / 5 ======================= -->
<script>
// ===== Bind UI =====
$("btnStart").addEventListener("click", start);
$("btnStop").addEventListener("click", stop);
$("btnReset").addEventListener("click", ()=>resetSim(true));
$("btnSolve").addEventListener("click", solveFastest);
$("btnCSV").addEventListener("click", downloadCSV);
$("btnPrint").addEventListener("click", doPrint);

["epoch","preset","baseV","warpF","EPJ","tension","pert","gain","scanDays","logEvery"].forEach(id=>{
  $(id).addEventListener("input", ()=>{
    if (!state.running){
      readInputs();
      // recompute ephemeris instantly when paused
      updateEphemerisNow();
      pushLog(`Tuned: ${id} updated.`);
      render();
    }
  });
});

// ===== Initialize =====
(function init(){
  setEpochDefault();
  readInputs();
  resetSim(true);
  // show clocks immediately
  setInterval(()=>{ if (!state.running) render(); }, 250);
  pushLog("Ready. Choose epoch/preset, then Start. Use Solve Fastest Path for a best-departure suggestion.");
})();
</script>

</div>
</body>
</html>
