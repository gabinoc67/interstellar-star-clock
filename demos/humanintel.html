<!-- ======================= PART 1 / 4 ======================= -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Human Intelligence Continuum ‚Äî Dual-Clock + Demography + Biogeography + Branching + Regression</title>

<!-- Optional MathJax (kept safe + optional). If blocked, formulas still display as plain text. -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
:root{
  color-scheme: dark;
  --bg:#020617;
  --ink:#e5e7eb;
  --muted:#9ca3af;
  --line: rgba(148,163,184,.28);
  --brand:#38bdf8;
  --good:#34d399;
  --warn:#fbbf24;
  --bad:#fb7185;
  --vio:#a855f7;
  --shadow: 0 18px 45px rgba(0,0,0,.55);
  --radius: 18px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background: radial-gradient(circle at top, #020617 0, #000 55%, #000 100%);
  color:var(--ink);
}
header{
  padding:18px 22px;
  border-bottom:1px solid var(--line);
  background: radial-gradient(circle at top left, rgba(56,189,248,.95) 0, rgba(15,23,42,.92) 40%, #000 100%);
}
header h1{margin:0 0 6px;font-size:22px;letter-spacing:.03em}
header p{margin:4px 0;font-size:13px;color:#bae6fd}
header .sub{color:var(--muted);font-size:12px;line-height:1.35}

.wrap{padding:16px; max-width: 1560px; margin:0 auto;}
.grid{
  display:grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
  gap:14px;
  align-items:start;
}
.panel{
  background: radial-gradient(circle at top, rgba(56,189,248,.14), rgba(15,23,42,.98));
  border-radius: var(--radius);
  border:1px solid var(--line);
  box-shadow: var(--shadow);
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-width:0;
}
.panel h2{
  margin:0;
  font-size:15px;
  font-weight:650;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.badge{
  font-size:11px;
  padding:3px 8px;
  border-radius:999px;
  border:1px solid rgba(148,163,184,.35);
  background: rgba(2,6,23,.55);
  color:#cfefff;
}
.muted{color:var(--muted)}
.mini{font-size:12px; line-height:1.35}
.controls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}
input[type="text"], select{
  background: rgba(2,6,23,.55);
  border:1px solid rgba(148,163,184,.55);
  border-radius:999px;
  color:var(--ink);
  padding:7px 12px;
  font-size:13px;
  outline:none;
}
select{padding-right:30px}
.btn{
  cursor:pointer;
  user-select:none;
  border-radius:999px;
  padding:7px 12px;
  border:1px solid rgba(148,163,184,.55);
  background: rgba(2,6,23,.55);
  color:var(--ink);
  font-size:13px;
}
.btn:hover{border-color:rgba(56,189,248,.65)}
.btn.primary{border-color: rgba(56,189,248,.75); background: rgba(56,189,248,.10);}
.btn.warn{border-color: rgba(251,191,36,.75); background: rgba(251,191,36,.10);}
.toggle{
  display:flex; align-items:center; gap:8px;
  padding:6px 10px;
  border:1px solid rgba(148,163,184,.45);
  border-radius:999px;
  background: rgba(2,6,23,.45);
  font-size:12px;
}
.toggle input{transform: translateY(1px)}
hr.sep{border:0; border-top:1px solid rgba(148,163,184,.22); margin:2px 0;}

.tableWrap{max-height:460px; overflow:auto; border-radius:14px; border:1px solid rgba(148,163,184,.22)}
table{width:100%; border-collapse:collapse; font-size:12.5px}
th,td{padding:8px 9px; border-bottom:1px solid rgba(56,189,248,.18)}
th{
  position:sticky; top:0;
  background: rgba(2,6,23,.85);
  text-transform:uppercase;
  font-size:10.5px;
  letter-spacing:.06em;
  color:var(--muted);
  border-bottom:1px solid rgba(148,163,184,.25);
}
tbody tr{cursor:pointer}
tbody tr:hover{background:rgba(56,189,248,.12)}
tbody tr.active-row{background: radial-gradient(circle at left, rgba(125,211,252,.30), rgba(15,23,42,.95));}

.kpiRow{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
.kpi{
  border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.35);
  padding:10px;
}
.kpi .label{font-size:11px;color:var(--muted)}
.kpi .value{font-size:18px;font-weight:700;margin-top:2px}
.kpi .hint{font-size:11px;color:#b7c7d8;margin-top:4px}

.bar-row{display:flex;align-items:center;gap:10px;margin:3px 0}
.bar-label{width:168px;font-size:11.5px;color:var(--muted)}
.bar-track{
  flex:1;height:8px;border-radius:999px;
  background:rgba(2,6,23,.55);
  border:1px solid rgba(148,163,184,.22);
  overflow:hidden;
}
.bar-fill{height:100%;border-radius:999px}

.card{
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.35);
  border-radius:14px;
  padding:10px;
  min-width:0;
}
.twoCol{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
canvas, svg{
  width:100%;
  height:auto;
  border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.30);
}
.sliderRow{
  display:grid;
  grid-template-columns: 170px 1fr 64px;
  align-items:center;
  gap:10px;
  margin:6px 0;
}
.sliderRow label{font-size:11.5px;color:var(--muted)}
.sliderRow input[type="range"]{width:100%}
.sliderRow .num{font-family: var(--mono); font-size:11.5px; color:#cfe7ff; text-align:right;}

.heat{
  display:grid;
  grid-template-columns: repeat(10, 1fr);
  gap:3px;
  padding:6px;
  border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.25);
}
.cell{aspect-ratio: 1 / 1;border-radius:5px;border:1px solid rgba(148,163,184,.10);}

.callout{
  border-radius:14px;
  border:1px solid rgba(56,189,248,.30);
  background: rgba(56,189,248,.08);
  padding:10px;
}
.footer{
  margin-top:14px;
  padding:14px;
  border-radius: var(--radius);
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.35);
}

/* Biogeography */
.mapGrid{display:grid; grid-template-columns: 1.3fr .9fr; gap:10px;}
.mapLegend{display:flex; flex-direction:column; gap:10px;}
.pill{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding:8px 10px; border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.35);
  font-size:12px;
}
.pill .name{color:#cfefff}
.pill .val{font-family:var(--mono); color:#cfe7ff}
.tag{
  font-size:11px; padding:2px 8px; border-radius:999px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.35);
  color:#cfefff;
}
.smallBtnRow{display:flex; gap:8px; flex-wrap:wrap}

/* Event log */
.logWrap{
  max-height:220px;
  overflow:auto;
  border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.25);
  padding:8px;
}
.logItem{
  padding:7px 8px;
  border-radius:12px;
  border:1px solid rgba(148,163,184,.12);
  background: rgba(2,6,23,.28);
  margin-bottom:6px;
}
.logTop{
  display:flex; justify-content:space-between; gap:10px;
  font-size:11px; color:rgba(186,230,253,.90);
  font-family: var(--mono);
}
.logMsg{font-size:12px; color:#dbeafe; margin-top:4px; line-height:1.35}

/* Formula viewer */
.formulaBox{
  border-radius:14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(2,6,23,.25);
  padding:10px;
  overflow:auto;
  max-height: 360px;
}
.formulaBlock{
  border-radius:12px;
  border:1px solid rgba(148,163,184,.15);
  background: rgba(2,6,23,.28);
  padding:10px;
  margin:10px 0;
}
.formulaTitle{
  display:flex; justify-content:space-between; gap:10px; align-items:center;
  font-size:12px; color:#cfefff; font-weight:700;
}
.codeLike{
  font-family: var(--mono);
  font-size: 11.5px;
  color: #dbeafe;
  white-space: pre-wrap;
  line-height: 1.35;
  margin-top: 8px;
}
.subst{
  font-family: var(--mono);
  font-size: 11.5px;
  color: #cfe7ff;
  margin-top: 8px;
}
.noteTiny{font-size:11px;color:#b7c7d8; margin-top:6px; line-height:1.35}

/* Print-only */
@media print{
  header, .footer, .controls, #tableHint, #mapHint, .toggle, #eventLogCard, #formulaCard { display:none !important; }
  body{ background:#fff !important; color:#000 !important; }
  .panel{ box-shadow:none !important; background:#fff !important; border:1px solid #bbb !important; }
  .card{ background:#fff !important; border:1px solid #ccc !important; }
  .muted{ color:#333 !important; }
  canvas, svg{ border:1px solid #ccc !important; }
  .grid{ gap:10px !important; }
}

@media(max-width: 980px){
  .grid{grid-template-columns:1fr}
  .tableWrap{max-height:340px}
  .kpiRow{grid-template-columns:1fr}
  .twoCol{grid-template-columns:1fr}
  .mapGrid{grid-template-columns:1fr}
}
</style>
</head>

<body>
<header>
  <h1>Human Intelligence Continuum</h1>
  <p>
    A grounded, non-teleological model: <strong>dual evolutionary clocks</strong>, <strong>demography</strong>, <strong>biogeography</strong>,
    <strong>multi-hominid branching</strong>, <strong>regression/shocks</strong>, and <strong>distribution-based intelligence</strong>.
  </p>
  <p class="sub">
    Instrument layer: <strong>Terminal Q</strong> (phase-discipline gate), <strong>Structural Synchrony S<sub>Moio</sub></strong> (coherence proxy),
    <strong>OFN/TCFQ</strong> (Œæ=3/4, Œ≤=1/4) + <strong>W‚ÇÇ¬≤</strong> convergence dial. Includes <strong>Show formulas</strong> for audit.
  </p>
</header>

<div class="wrap">
  <div class="grid">

    <!-- LEFT COLUMN -->
    <div class="col">
      <section class="panel">
        <h2>üìú Timeline & Stages <span class="badge" id="modeBadge">Mode: Coupled (Bio√óCulture)</span></h2>

        <div class="controls">
          <input id="searchBox" type="text" placeholder="search year, region, hominid, idea‚Ä¶" />
          <select id="modeSelect" title="Evolution engine mode">
            <option value="coupled">Coupled (Bio √ó Culture)</option>
            <option value="bio">Biological emphasis</option>
            <option value="culture">Cultural emphasis</option>
          </select>

          <span class="toggle" title="Show definitions, assumptions, and provenance">
            <input id="reviewerToggle" type="checkbox" />
            <label for="reviewerToggle">Reviewer Mode</label>
          </span>

          <button class="btn" id="resetTuning">Reset tuning</button>
          <button class="btn primary" id="printSelected">Print selected</button>
        </div>

        <div class="callout mini muted">
          <strong>Model stance:</strong> acceleration is explained by Bio‚ÜîCulture crossover + external memory density; demography/biogeography control retention & diffusion; branching is explicit; regression is allowed under shocks.
        </div>

        <div class="tableWrap">
          <table>
            <thead>
              <tr>
                <th>Year</th>
                <th>Region</th>
                <th>Lineage</th>
                <th>Key advance</th>
                <th>Physics maturity</th>
                <th>Retention</th>
              </tr>
            </thead>
            <tbody id="eventTable"></tbody>
          </table>
        </div>

        <div class="mini muted" id="tableHint">Click a row to update all panels. Pinned region is included in Print Selected.</div>
      </section>

      <section class="panel">
        <h2>üëµ Longevity & Intergenerational Teaching <span class="badge">Grandmother / teaching fit</span></h2>
        <div class="mini muted">
          Adds age-structure logic: complex skills persist when learning time fits within lifespan + elder teaching window.
        </div>

        <div class="sliderRow">
          <label for="lifespanSlider">Average lifespan</label>
          <input id="lifespanSlider" type="range" min="15" max="80" step="1" />
          <div class="num" id="lifespanNum">‚Äî</div>
        </div>
        <div class="sliderRow">
          <label for="learnSlider">Skill learning years</label>
          <input id="learnSlider" type="range" min="1" max="30" step="1" />
          <div class="num" id="learnNum">‚Äî</div>
        </div>
        <div class="sliderRow">
          <label for="elderSlider">Elder teaching years</label>
          <input id="elderSlider" type="range" min="0" max="25" step="1" />
          <div class="num" id="elderNum">‚Äî</div>
        </div>

        <div id="longevityBars"></div>
      </section>

      <section class="panel">
        <h2>üß¨ Multi-Hominid Branch View <span class="badge">Non-linear selection landscape</span></h2>
        <div class="mini muted">
          Adds explicit non-sapiens tracks. Extinction is modeled as buffers + network reach + volatility‚Äînot ‚Äúinferiority.‚Äù
        </div>

        <div class="controls">
          <select id="speciesSelect" title="Select lineage">
            <option value="sapiens">Homo sapiens</option>
            <option value="neanderthal">Neanderthals</option>
            <option value="denisovan">Denisovans</option>
            <option value="hybrid">Hybrid / Admixed populations</option>
          </select>
          <button class="btn primary" id="compareAll">Compare all</button>
        </div>

        <svg id="branchSvg" viewBox="0 0 900 220"></svg>
        <div id="speciesBars"></div>
      </section>

      <section class="panel">
        <h2>üßØ Regression, Shocks & Local Optima <span class="badge">Anti-teleology</span></h2>
        <div class="mini muted">Adds collapses, dead-ends, and regressions‚Äîprogress is survivability-weighted.</div>

        <div class="sliderRow">
          <label for="shockSlider">Environmental shock</label>
          <input id="shockSlider" type="range" min="0" max="10" step="1" />
          <div class="num" id="shockNum">‚Äî</div>
        </div>
        <div class="sliderRow">
          <label for="resilienceSlider">Resilience policy</label>
          <input id="resilienceSlider" type="range" min="0" max="10" step="1" />
          <div class="num" id="resilienceNum">‚Äî</div>
        </div>

        <div id="riskBars"></div>
        <div class="mini muted" id="riskNote"></div>
      </section>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="col">
      <section class="panel">
        <h2>üß† Results & Interpretation <span class="badge" id="selectedBadge">No stage selected</span></h2>

        <div class="kpiRow">
          <div class="kpi">
            <div class="label">Computed intelligence index</div>
            <div class="value" id="kpiInt">‚Äî</div>
            <div class="hint">Core (Bio‚ÜîCulture) √ó retention √ó teaching fit. No ‚Äúdestiny curve.‚Äù</div>
          </div>
          <div class="kpi">
            <div class="label">Collapse probability</div>
            <div class="value" id="kpiCollapse">‚Äî</div>
            <div class="hint">Higher when fragility + shock exceed resilience.</div>
          </div>
        </div>

        <div class="twoCol">
          <div class="card">
            <div class="mini muted"><strong>Dual-clock crossover</strong> (biological ‚Üí cultural)</div>
            <canvas id="crossoverCanvas" width="900" height="260"></canvas>
            <div class="mini muted">Explains ‚Äúacceleration‚Äù: external memory crosses a threshold, then cultural clock dominates.</div>
          </div>

          <div class="card">
            <div class="mini muted"><strong>Intelligence as a distribution</strong> (not a scalar)</div>
            <div id="distBars"></div>
            <div class="mini muted">Toolmaking ‚Ä¢ Social ‚Ä¢ Symbolic ‚Ä¢ Planning ‚Ä¢ Environmental modeling.</div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <h2 style="margin:0 0 6px; font-size:14px;">üß† Efficiency-first Perception (Compression Panel)</h2>

          <div class="callout mini muted" style="margin:6px 0 8px;">
            <strong>Design principle (model claim, not measurement):</strong>
            perception stability can emerge from efficient compression: prune excess detail, keep a manageable world-model.
          </div>

          <div class="sliderRow">
            <label for="signalSlider">Signal load (inputs)</label>
            <input id="signalSlider" type="range" min="0" max="10" step="1" />
            <div class="num" id="signalNum">‚Äî</div>
          </div>

          <div class="sliderRow">
            <label for="accuracySlider">Accuracy demand</label>
            <input id="accuracySlider" type="range" min="0" max="10" step="1" />
            <div class="num" id="accuracyNum">‚Äî</div>
          </div>

          <div id="perceptionBars"></div>
          <div class="mini muted" id="perceptionNote"></div>
        </div>

        <div class="card" style="margin-top:10px;">
          <h2 style="margin:0 0 6px; font-size:14px;">üßø Terminal Q / Structural Synchrony / OFN‚ÄìTCFQ (Instrument Layer)</h2>

          <div class="callout mini muted" style="margin:6px 0 10px;">
            <strong>Important:</strong> These meters are <em>derived</em> from your slider settings + presets (a control-panel metaphor).
            They are not presented as lab measurements.
          </div>

          <div class="twoCol">
            <div class="card" style="padding:10px;">
              <div class="mini muted"><strong>Terminal Q (Pivot gate)</strong></div>

              <div class="sliderRow">
                <label for="terminalQSlider">Phase-discipline readiness (Q)</label>
                <input id="terminalQSlider" type="range" min="0" max="100" step="1" />
                <div class="num" id="terminalQNum">‚Äî</div>
              </div>

              <div id="terminalQBars"></div>

              <div class="mini muted" id="terminalQGateNote"></div>

              <div class="toggle" style="margin-top:8px;" title="When OFF: interpret as phase-only mode; geometry is not the active description">
                <input id="metricToggle" type="checkbox" />
                <label for="metricToggle">Einstein metric emergent (ON/OFF)</label>
              </div>
            </div>

            <div class="card" style="padding:10px;">
              <div class="mini muted"><strong>Structural Synchrony S<sub>Moio</sub></strong></div>

              <div class="controls" style="margin-top:6px;">
                <select id="materialSelect" title="Material stack preset (simulation preset)">
                  <option value="aln_mo">AlN on Molybdenum (preset)</option>
                  <option value="sic_ti">SiC on Titanium (preset)</option>
                  <option value="graphene_cu">Graphene on Copper (preset)</option>
                  <option value="generic">Generic composite (preset)</option>
                </select>
              </div>

              <div id="smoioBars" style="margin-top:6px;"></div>

              <div class="mini muted" id="smoioNote"></div>
            </div>
          </div>

          <hr class="sep"/>

          <div class="twoCol">
            <div class="card" style="padding:10px;">
              <div class="mini muted"><strong>OFN / TCFQ constants (display)</strong></div>
              <div class="mini muted">
                Œæ = <span style="font-family:var(--mono);color:#cfe7ff">3/4</span> ¬∑
                Œ≤ = <span style="font-family:var(--mono);color:#cfe7ff">1/4</span>
                <span class="muted"> (treated as model parameters here)</span>
              </div>
              <div id="ofnBars" style="margin-top:8px;"></div>
              <div class="mini muted" id="ofnNote"></div>

              <div class="toggle" style="margin-top:10px;" title="Shows the exact equations and live substituted values used for audit">
                <input id="formulaToggle" type="checkbox" />
                <label for="formulaToggle">Show formulas (audit)</label>
              </div>
            </div>

            <div class="card" style="padding:10px;" id="eventLogCard">
              <div class="mini muted" style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
                <strong>Event Log</strong>
                <button class="btn" id="clearLog">Clear</button>
              </div>
              <div class="logWrap" id="eventLog"></div>
              <div class="mini muted" style="margin-top:6px;">
                Logs changes so reviewers can see what inputs caused what outputs.
              </div>
            </div>
          </div>

          <div class="card" id="formulaCard" style="margin-top:10px; display:none;">
            <div class="mini muted" style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
              <strong>Formula Audit (exact equations + live substitution)</strong>
              <span class="badge">Transparent math</span>
            </div>
            <div class="formulaBox" id="formulaBox"></div>
            <div class="noteTiny">
              If MathJax loads, LaTeX lines render; otherwise, the plain-text equations and substitutions still show.
            </div>
          </div>
        </div>

        <hr class="sep" />

        <div class="card">
          <h2 style="margin:0 0 6px; font-size:14px;">üß¨ Demography & Network Density</h2>
          <div class="mini muted">Innovation needs a critical mass; contact prevents local knowledge loss.</div>

          <div class="sliderRow">
            <label for="popSlider">Effective population</label>
            <input id="popSlider" type="range" min="1" max="10" step="1" />
            <div class="num" id="popNum">‚Äî</div>
          </div>
          <div class="sliderRow">
            <label for="contactSlider">Inter-group contact</label>
            <input id="contactSlider" type="range" min="0" max="10" step="1" />
            <div class="num" id="contactNum">‚Äî</div>
          </div>
          <div class="sliderRow">
            <label for="lossSlider">Knowledge loss risk</label>
            <input id="lossSlider" type="range" min="0" max="10" step="1" />
            <div class="num" id="lossNum">‚Äî</div>
          </div>

          <div class="mini muted" style="margin-top:6px;"><strong>Retention heat map</strong></div>
          <div class="heat" id="heatMap"></div>
        </div>

        <hr class="sep" />

        <div class="card">
          <h2 style="margin:0 0 6px; font-size:14px;">üåç Biogeography Distribution Map</h2>
          <div class="mini muted">
            Adds regionality: model is not a single global line. Click a region to pin it; shift-click clears.
          </div>

          <div class="mapGrid" style="margin-top:8px;">
            <div>
              <svg id="worldMap" viewBox="0 0 900 440"></svg>
              <div class="mini muted" id="mapHint">Pinned region is included in Print Selected.</div>
            </div>
            <div class="mapLegend">
              <div class="pill"><div class="name">Pinned region</div><div class="val" id="pinName">None</div></div>
              <div class="pill"><div class="name">Pinned retention</div><div class="val" id="pinRetention">‚Äî</div></div>
              <div class="pill"><div class="name">Pinned intensity</div><div class="val" id="pinIntensity">‚Äî</div></div>
              <div class="pill"><div class="name">Diffusion pressure</div><div class="val" id="pinDiffusion">‚Äî</div></div>
              <div class="smallBtnRow">
                <span class="tag">Nodes: 10</span>
                <span class="tag">Links: contact</span>
                <span class="tag">Friction: distance</span>
              </div>
              <div class="mini muted">
                Regional intensity = retention √ó hubness √ó diffusion. Map is schematic, not GIS.
              </div>
            </div>
          </div>
        </div>

        <div class="footer" id="reviewerBox" style="display:none;">
          <h2 style="margin:0 0 6px; font-size:14px;">üßæ Reviewer Mode Notes (definitions + provenance)</h2>
          <div class="mini muted" id="reviewerText"></div>
        </div>

        <div id="printArea" style="display:none;"></div>
      </section>

      <div class="footer">
        <div class="mini muted">
          <strong>Printing:</strong> select a stage, optionally pin a region, then click <em>Print selected</em> to print a clean report.
        </div>
      </div>

    </div>
  </div>
</div>
<!-- ======================= PART 2 / 4 ======================= -->
<script>
/* Everything runs after DOM is ready (prevents "null element" crashes). */
window.addEventListener("DOMContentLoaded", () => {

/* ========= Utilities ========= */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const lerp=(a,b,t)=>a+(b-a)*t;
const sigmoid=(x)=>1/(1+Math.exp(-x));
const norm10=(x)=>clamp(x/10,0,1);
const fmtPct=(x)=>`${Math.round(x*100)}%`;
const f3=(x)=>Number.isFinite(x)?x.toFixed(3):"‚Äî";
const f4=(x)=>Number.isFinite(x)?x.toFixed(4):"‚Äî";

function hslColor(v){
  const hue = lerp(0,120,clamp(v,0,1));
  return `hsl(${hue} 85% 45%)`;
}
function barRow(label,val,color){
  const w = clamp(val,0,1)*100;
  return `
    <div class="bar-row">
      <div class="bar-label">${label}</div>
      <div class="bar-track">
        <div class="bar-fill" style="width:${w}%;background:${color}"></div>
      </div>
    </div>`;
}

/* ========= Stage Data (illustrative knobs; not measurements) ========= */
const stages = [
  {id:"s0",year:"~300,000 BCE",region:"East Africa",lineage:"Homo sapiens (early)",
   advance:"Symbolic scaffolding, language",physics:"Implicit / Embodied Physics",
   why:"Embodied mastery exists long before formal equations; cultural storage is limited, so knowledge is fragile regionally.",
   constraint:4, info:3, tools:2, imagination:7,
   plasticity:7, brainLimit:4, symbolRate:2, externalMemory:1, teachingEff:2,
   pop:2, contact:2, loss:7, lifespan:28, learnYears:6, elderYears:3,
   dist:{tool:3,social:6,symbolic:4,planning:5,env:5}, shock:4, resilience:2
  },
  {id:"s1",year:"~40,000 BCE",region:"Europe & Central Asia",lineage:"H. sapiens + Neanderthals (overlap)",
   advance:"Art, music, compound tools",physics:"Implicit mechanics ‚Üí proto-formal heuristics",
   why:"Network density and contact control retention; coexisting lineages can be sophisticated without being ‚Äúlinear steps.‚Äù",
   constraint:8, info:5, tools:4, imagination:9,
   plasticity:7, brainLimit:5, symbolRate:5, externalMemory:3, teachingEff:5,
   pop:3, contact:4, loss:6, lifespan:30, learnYears:8, elderYears:4,
   dist:{tool:5,social:6,symbolic:7,planning:7,env:6}, shock:7, resilience:3
  },
  {id:"s2",year:"~10,000 BCE",region:"Fertile Crescent",lineage:"Homo sapiens",
   advance:"Agriculture, settlement, writing precursors",physics:"Measurement & counting (proto-formal)",
   why:"Surplus increases specialization; external memory rises; acceleration is cultural (exosomatic), not genetic.",
   constraint:5, info:7, tools:6, imagination:7,
   plasticity:6, brainLimit:6, symbolRate:7, externalMemory:6, teachingEff:7,
   pop:6, contact:6, loss:4, lifespan:32, learnYears:10, elderYears:5,
   dist:{tool:6,social:7,symbolic:7,planning:7,env:6}, shock:5, resilience:5
  },
  {id:"s3",year:"~600 BCE",region:"Mediterranean",lineage:"Homo sapiens",
   advance:"Logic, axioms, debate culture",physics:"Formal reasoning",
   why:"Formalism reduces loss by compressing knowledge into symbols; institutions stabilize transmission.",
   constraint:3, info:8, tools:5, imagination:8,
   plasticity:5, brainLimit:6, symbolRate:8, externalMemory:7, teachingEff:7,
   pop:6, contact:7, loss:3, lifespan:35, learnYears:12, elderYears:6,
   dist:{tool:5,social:7,symbolic:8,planning:8,env:7}, shock:3, resilience:6
  },
  {id:"s4",year:"1687",region:"England",lineage:"Homo sapiens",
   advance:"Classical mechanics",physics:"Predictive physics (models ‚Üí predictions)",
   why:"Instrumentation + publishing increase cultural storage; knowledge becomes more resilient to local shocks.",
   constraint:2, info:8, tools:6, imagination:7,
   plasticity:5, brainLimit:6, symbolRate:8, externalMemory:8, teachingEff:8,
   pop:7, contact:8, loss:2, lifespan:40, learnYears:14, elderYears:8,
   dist:{tool:7,social:6,symbolic:8,planning:7,env:8}, shock:2, resilience:7
  },
  {id:"s5",year:"1905",region:"Europe",lineage:"Homo sapiens",
   advance:"Relativity (conceptual reframing)",physics:"Spacetime physics (formal + counterfactual)",
   why:"Global networks expand contact; formal tools enable counterfactual reasoning without assuming teleology.",
   constraint:2, info:9, tools:6, imagination:9,
   plasticity:5, brainLimit:6, symbolRate:9, externalMemory:9, teachingEff:8,
   pop:8, contact:8, loss:2, lifespan:50, learnYears:16, elderYears:10,
   dist:{tool:7,social:6,symbolic:9,planning:8,env:8}, shock:2, resilience:7
  },
  {id:"s6",year:"2020s",region:"Global",lineage:"Homo sapiens",
   advance:"Human‚ÄìAI co-reasoning",physics:"Tool-augmented physics (simulation)",
   why:"Acceleration is computational + cultural storage. Still vulnerable to institutional fragility and shocks.",
   constraint:6, info:10, tools:10, imagination:9,
   plasticity:5, brainLimit:6, symbolRate:10, externalMemory:10, teachingEff:9,
   pop:9, contact:10, loss:3, lifespan:72, learnYears:18, elderYears:14,
   dist:{tool:9,social:7,symbolic:9,planning:9,env:9}, shock:4, resilience:6
  },
  {id:"s7",year:"Future",region:"Planetary / Space-based",lineage:"Multiple lineages / designed intelligence",
   advance:"Spacetime engineering (hypothesis)",physics:"Experimental spacetime control (hypothesis)",
   why:"If achieved, it emerges from durable institutions + tooling + ethics‚Äînot from ‚Äúinevitable progress.‚Äù",
   constraint:7, info:10, tools:10, imagination:10,
   plasticity:5, brainLimit:6, symbolRate:10, externalMemory:10, teachingEff:10,
   pop:10, contact:10, loss:2, lifespan:80, learnYears:22, elderYears:18,
   dist:{tool:10,social:8,symbolic:10,planning:10,env:10}, shock:3, resilience:8
  }
];

/* ========= Multi-hominid model knobs ========= */
const species = {
  sapiens:{name:"Homo sapiens", buf:7, net:7, vol:5, sym:8, tool:8},
  neanderthal:{name:"Neanderthals", buf:4, net:4, vol:7, sym:6, tool:7},
  denisovan:{name:"Denisovans", buf:3, net:3, vol:7, sym:5, tool:6},
  hybrid:{name:"Hybrid / Admixed", buf:5, net:6, vol:6, sym:7, tool:7}
};

/* ========= Engine functions ========= */
function bioCapacity(s){
  const lifeN = clamp((s.lifespan-15)/(80-15),0,1);
  return (norm10(s.plasticity)*0.45 + norm10(s.brainLimit)*0.25 + lifeN*0.30);
}
function culturalStorage(s){
  return (norm10(s.symbolRate)*0.33 + norm10(s.externalMemory)*0.42 + norm10(s.teachingEff)*0.25);
}
function retentionScore(pop, contact, loss){
  const p = norm10(pop), c = norm10(contact), l = norm10(loss);
  const critical = sigmoid((pop-4)*0.9);
  const raw = (0.55*p + 0.35*c) * (1 - 0.55*l) * critical;
  return clamp(raw,0,1);
}
function longevityTeachingFactor(lifespan, learnYears, elderYears){
  const productive = clamp(lifespan-12,0,80);
  const teachWindow = clamp(productive*0.25 + elderYears, 0, 80);
  const fit = clamp((teachWindow - learnYears)/Math.max(learnYears,1), -2, 2);
  return clamp(sigmoid(fit*1.2),0,1);
}
function collapseProbability(s, ret, teach){
  const shock = norm10(s.shock);
  const resilience = norm10(s.resilience);
  const fragility = clamp(1 - (0.62*ret + 0.38*teach), 0, 1);
  const x = (0.60*shock + 0.55*fragility - 0.55*resilience);
  return clamp(sigmoid((x-0.35)*3.2), 0, 1);
}
function intelligenceIndex(s, mode, ret, teach){
  const bio = bioCapacity(s);
  const cul = culturalStorage(s);
  const ext = norm10(s.externalMemory);
  const crossover = sigmoid((ext - 0.45)*7);

  let core;
  if(mode==="bio"){
    core = bio * (0.65 + 0.35*(1-crossover)) + cul*0.10;
  }else if(mode==="culture"){
    core = cul * (0.65 + 0.35*crossover) + bio*0.10;
  }else{
    core = (bio*0.55 + cul*0.65) * (0.75 + 0.25*crossover);
  }
  return clamp(core * (0.60 + 0.40*ret) * (0.65 + 0.35*teach), 0, 1);
}

/* ========= Perception: Efficiency vs Accuracy ========= */
function perceptionCompression(signalLoad, accuracyDemand, brainLimit){
  const loadN = norm10(signalLoad);
  const accN  = norm10(accuracyDemand);
  const brainN = norm10(brainLimit);

  const eff = clamp(0.62*loadN + 0.28*(1-accN) + 0.10*(1-brainN), 0, 1);
  const compression = clamp(sigmoid((eff - accN)*4.2), 0, 1);
  const perceivedStability = clamp(0.20 + 0.80*compression*(1 - 0.35*loadN), 0, 1);
  const errorSensitivity = clamp(1 - compression, 0, 1);
  const processingCost = clamp(0.20 + 0.80*loadN*(1 - 0.55*compression), 0, 1);

  return {compression, perceivedStability, errorSensitivity, processingCost, eff, loadN, accN, brainN};
}

/* ========= Instrument layer (Terminal Q / S_Moio / OFN) ========= */
const OFN_CONST = { xi: 0.75, beta: 0.25 };

const materialPresets = {
  aln_mo:        {name:"AlN on Molybdenum", base:0.86, damp:0.18, note:"High stiffness & thermal stability (preset metaphor)."},
  sic_ti:        {name:"SiC on Titanium",   base:0.78, damp:0.22, note:"Good high-temp performance (preset metaphor)."},
  graphene_cu:   {name:"Graphene on Copper",base:0.72, damp:0.28, note:"High conductivity, more mismatch risk (preset metaphor)."},
  generic:       {name:"Generic composite", base:0.68, damp:0.30, note:"Baseline placeholder preset (metaphor)."}
};

function terminalQModel(Q, idx, ret, teach, collapse, P, metricEmergent){
  const q = clamp(Q,0,1);
  const survivability = clamp((ret*0.46 + teach*0.34 + (1-collapse)*0.20), 0, 1);
  const coherence = clamp(1 - Math.abs(P.perceivedStability - (1-P.errorSensitivity))*0.75, 0, 1);
  const gateScore = clamp(0.40*q + 0.25*idx + 0.20*survivability + 0.15*coherence, 0, 1);
  const gateOpen = (gateScore > 0.72) && (collapse < 0.42) && (q > 0.62);
  const label = metricEmergent ? "Geometry-enabled gate" : "Phase-adjacency gate";
  return {q, survivability, coherence, gateScore, gateOpen, label};
}

function smoioModel(presetKey, Qm, idx, ret, teach, collapse, P, metricEmergent){
  const preset = materialPresets[presetKey] || materialPresets.generic;
  const phaseAssist = clamp(0.55*Qm.q + 0.25*Qm.coherence + 0.20*(1-collapse), 0, 1);
  const costPenalty = clamp(P.processingCost*0.35 + collapse*0.35 + (1-ret)*0.30, 0, 1);
  let S = clamp(preset.base*(0.55 + 0.45*phaseAssist) * (1 - preset.damp*costPenalty), 0, 1);
  if(!metricEmergent) S = clamp(S*0.96, 0, 1);
  const residualKm = clamp((1 - S)*0.12, 0, 0.12);
  return {preset, S, residualKm, phaseAssist, costPenalty};
}

function ofnModel(Qm, Sm, idx, ret, teach, collapse, P, metricEmergent){
  const entropy = clamp(0.55*collapse + 0.25*P.processingCost + 0.20*(1 - Sm.S), 0, 1);
  const w2 = clamp(1 - (0.62*Qm.gateScore + 0.18*idx + 0.20*(1-entropy)), 0, 1);
  const adjacency = (w2 < 0.33) && (Qm.q > 0.58);
  const note = metricEmergent
    ? "Metric-emergent ON: interpret W‚ÇÇ¬≤ as distance between geometry-enabled states (metaphor)."
    : "Metric-emergent OFF: interpret W‚ÇÇ¬≤ as phase-only adjacency distance (metaphor).";
  return {entropy, w2, adjacency, note};
}

/* ========= Crossover plot helper points ========= */
const timePoints = [{t:"~300k"},{t:"~40k"},{t:"~10k"},{t:"~600"},{t:"1687"},{t:"1905"},{t:"2020"},{t:"fut"}];

/* ========= Biogeography ========= */
const worldMap = document.getElementById("worldMap");
const pinName = document.getElementById("pinName");
const pinRetention = document.getElementById("pinRetention");
const pinIntensity = document.getElementById("pinIntensity");
const pinDiffusion = document.getElementById("pinDiffusion");

let pinnedRegionId = null;

const regions = [
  {id:"eaf", name:"East Africa",     x:430, y:240, hub:0.75, stab:0.70, fric:0.20},
  {id:"naf", name:"North Africa",    x:430, y:195, hub:0.65, stab:0.55, fric:0.25},
  {id:"lev", name:"Levant",          x:480, y:190, hub:0.85, stab:0.60, fric:0.18},
  {id:"eur", name:"Europe",          x:500, y:150, hub:0.80, stab:0.55, fric:0.22},
  {id:"csa", name:"Central Asia",    x:560, y:165, hub:0.55, stab:0.45, fric:0.35},
  {id:"sas", name:"South Asia",      x:600, y:225, hub:0.75, stab:0.55, fric:0.30},
  {id:"eas", name:"East Asia",       x:680, y:185, hub:0.85, stab:0.55, fric:0.25},
  {id:"sea", name:"SE Asia",         x:660, y:255, hub:0.70, stab:0.50, fric:0.30},
  {id:"aus", name:"Australia",       x:740, y:330, hub:0.40, stab:0.40, fric:0.55},
  {id:"ame", name:"Americas",        x:250, y:210, hub:0.60, stab:0.45, fric:0.50}
];
const links = [
  ["eaf","naf"],["naf","lev"],["lev","eur"],["lev","csa"],["csa","eas"],["csa","sas"],["sas","sea"],["sea","eas"],
  ["sea","aus"],["eas","ame"],["eur","ame"],["eaf","lev"],["sas","eas"]
];

function computeRegional(s, mode){
  const retGlobal = retentionScore(s.pop, s.contact, s.loss);
  const teach = longevityTeachingFactor(s.lifespan, s.learnYears, s.elderYears);
  const idx = intelligenceIndex(s, mode, retGlobal, teach);

  const contactN = norm10(s.contact);
  const diffusion = clamp(0.25 + 0.75*contactN, 0, 1);
  const lossN = norm10(s.loss);

  const computed = regions.map(r=>{
    const fricEff = clamp(r.fric * (1 - 0.55*contactN), 0, 1);
    const baseRet = retGlobal * r.stab * (1 - fricEff);
    const localRet = clamp(baseRet * (1 - 0.35*lossN) * (0.70 + 0.30*r.hub), 0, 1);
    const intensity = clamp(idx * localRet * (0.55 + 0.45*r.hub) * (0.50 + 0.50*diffusion), 0, 1);
    return { ...r, friction:fricEff, retention:localRet, intensity:intensity, diffusion, idx, retGlobal };
  });

  const linkStrength = links.map(([a,b])=>{
    const A = computed.find(x=>x.id===a);
    const B = computed.find(x=>x.id===b);
    const base = (A.intensity + B.intensity)/2;
    const dist = Math.hypot(A.x-B.x, A.y-B.y);
    const distN = clamp(dist/600, 0, 1);
    const strength = clamp(base * (1 - 0.55*distN) * (0.55 + 0.45*contactN), 0, 1);
    return {a,b,strength};
  });

  return {computed, linkStrength, idx, retGlobal, diffusion, teach};
}

function mapBg(){
  return `
    <defs>
      <radialGradient id="ocean" cx="35%" cy="25%" r="80%">
        <stop offset="0%" stop-color="rgba(56,189,248,.10)"/>
        <stop offset="55%" stop-color="rgba(2,6,23,.55)"/>
        <stop offset="100%" stop-color="rgba(2,6,23,.85)"/>
      </radialGradient>
      <filter id="glow">
        <feGaussianBlur stdDeviation="2.5" result="blur"/>
        <feMerge>
          <feMergeNode in="blur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <rect x="0" y="0" width="900" height="440" fill="url(#ocean)"/>
    <!-- schematic continents -->
    <path d="M160,120 C220,80 320,80 370,120 C410,155 410,220 360,260 C320,290 240,280 210,240 C170,200 120,165 160,120 Z"
      fill="rgba(148,163,184,.10)" stroke="rgba(148,163,184,.10)"/>
    <path d="M420,110 C470,70 560,70 610,110 C650,145 660,200 620,245 C580,285 500,300 455,260 C420,228 390,160 420,110 Z"
      fill="rgba(148,163,184,.10)" stroke="rgba(148,163,184,.10)"/>
    <path d="M650,250 C700,220 780,235 810,280 C830,315 810,360 765,375 C720,390 670,370 650,330 C635,300 630,275 650,250 Z"
      fill="rgba(148,163,184,.10)" stroke="rgba(148,163,184,.10)"/>
    <path d="M420,250 C450,230 500,235 525,265 C545,290 540,330 510,350 C475,372 435,360 420,330 C405,300 400,275 420,250 Z"
      fill="rgba(148,163,184,.08)" stroke="rgba(148,163,184,.08)"/>
    <text x="16" y="22" fill="rgba(156,163,175,.95)" font-size="12">Regional distribution (schematic; not GIS)</text>
  `;
}

function renderWorldMap(model){
  if(!worldMap) return;
  const {computed, linkStrength} = model;

  const linkSvg = linkStrength.map(L=>{
    const A = computed.find(r=>r.id===L.a);
    const B = computed.find(r=>r.id===L.b);
    const alpha = lerp(0.05, 0.55, L.strength);
    const width = lerp(0.8, 3.8, L.strength);
    return `<line x1="${A.x}" y1="${A.y}" x2="${B.x}" y2="${B.y}"
      stroke="rgba(56,189,248,${alpha})" stroke-width="${width}" stroke-linecap="round"/>`;
  }).join("");

  const nodesSvg = computed.map(r=>{
    const pin = (pinnedRegionId===r.id);
    const rad = pin ? 11 : 9;
    const stroke = pin ? "rgba(236,72,153,.95)" : "rgba(229,231,235,.25)";
    const strokeW = pin ? 2.5 : 1.2;
    const glow = pin ? `filter="url(#glow)"` : "";
    const title = `${r.name}
Intensity: ${Math.round(r.intensity*100)}%
Retention: ${Math.round(r.retention*100)}%
Friction: ${Math.round(r.friction*100)}%`;
    return `
      <g class="node" data-id="${r.id}" style="cursor:pointer">
        <circle cx="${r.x}" cy="${r.y}" r="${rad}" fill="${hslColor(r.intensity)}"
          stroke="${stroke}" stroke-width="${strokeW}" ${glow}>
          <title>${title}</title>
        </circle>
        <text x="${r.x+14}" y="${r.y+4}" font-size="12" fill="rgba(229,231,235,.85)">${r.name}</text>
      </g>`;
  }).join("");

  worldMap.innerHTML = `${mapBg()}${linkSvg}${nodesSvg}`;

  worldMap.querySelectorAll(".node").forEach(g=>{
    g.addEventListener("click", (ev)=>{
      const id = g.getAttribute("data-id");
      if(ev.shiftKey) pinnedRegionId = null;
      else pinnedRegionId = (pinnedRegionId===id) ? null : id;
      updatePinnedRegion(model);
      renderWorldMap(model);
    });
  });
}

function updatePinnedRegion(model){
  if(!pinName || !pinRetention || !pinIntensity || !pinDiffusion) return;
  const {computed, diffusion} = model;
  if(!pinnedRegionId){
    pinName.textContent = "None";
    pinRetention.textContent = "‚Äî";
    pinIntensity.textContent = "‚Äî";
    pinDiffusion.textContent = `${Math.round(diffusion*100)}%`;
    return;
  }
  const r = computed.find(x=>x.id===pinnedRegionId);
  pinName.textContent = r.name;
  pinRetention.textContent = `${Math.round(r.retention*100)}%`;
  pinIntensity.textContent = `${Math.round(r.intensity*100)}%`;
  pinDiffusion.textContent = `${Math.round(r.diffusion*100)}%`;
}

/* ========= Crossover plot ========= */
const canvas = document.getElementById("crossoverCanvas");
const ctx = canvas ? canvas.getContext("2d") : null;

function drawCrossover(selected){
  if(!canvas || !ctx) return;
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "rgba(2,6,23,.25)";
  ctx.fillRect(0,0,w,h);

  const padL=46, padR=14, padT=18, padB=34;
  const gx0=padL, gx1=w-padR, gy0=padT, gy1=h-padB;

  ctx.strokeStyle="rgba(148,163,184,.22)";
  ctx.lineWidth=1;
  for(let i=0;i<=5;i++){
    const y = lerp(gy1, gy0, i/5);
    ctx.beginPath(); ctx.moveTo(gx0,y); ctx.lineTo(gx1,y); ctx.stroke();
  }

  const xs = timePoints.map((_,i)=> lerp(gx0,gx1, i/(timePoints.length-1)) );
  ctx.fillStyle="rgba(156,163,175,.95)";
  ctx.font="11px "+getComputedStyle(document.body).fontFamily;
  timePoints.forEach((p,i)=> ctx.fillText(p.t, xs[i]-10, h-12));

  if(!selected){
    ctx.fillStyle="rgba(186,230,253,.85)";
    ctx.font="12px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText("Select a stage to plot Bio vs Culture contributions.", gx0+10, gy0+20);
    return;
  }

  const baseBio = bioCapacity(selected);
  const baseCul = culturalStorage(selected);

  const series = timePoints.map((_,i)=>{
    const t = i/(timePoints.length-1);
    const culRamp = sigmoid((t-0.40)*8);
    const bio = clamp(lerp(baseBio*0.95, baseBio*1.05, t*0.35),0,1);
    const cul = clamp(baseCul * lerp(0.35, 1.25, culRamp),0,1);
    return {bio, cul};
  });

  function plot(getY, stroke){
    ctx.strokeStyle=stroke;
    ctx.lineWidth=2.4;
    ctx.beginPath();
    series.forEach((pt,i)=>{
      const x = xs[i];
      const y = lerp(gy1, gy0, getY(pt));
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }
  plot(pt=>pt.bio, "rgba(34,211,238,.95)");
  plot(pt=>pt.cul, "rgba(74,222,128,.95)");
}
</script>
<!-- ======================= PART 3 / 4 ======================= -->
<script>
/* ========= DOM refs ========= */
const $ = (id)=>document.getElementById(id);

const tableBody = $("eventTable");
const searchBox = $("searchBox");
const modeSelect = $("modeSelect");
const modeBadge = $("modeBadge");
const reviewerToggle = $("reviewerToggle");
const reviewerBox = $("reviewerBox");
const reviewerText = $("reviewerText");
const resetTuningBtn = $("resetTuning");
const printBtn = $("printSelected");
const printArea = $("printArea");

const selectedBadge = $("selectedBadge");
const kpiInt = $("kpiInt");
const kpiCollapse = $("kpiCollapse");
const distBars = $("distBars");

const popSlider = $("popSlider");
const contactSlider = $("contactSlider");
const lossSlider = $("lossSlider");
const popNum = $("popNum");
const contactNum = $("contactNum");
const lossNum = $("lossNum");
const heatMap = $("heatMap");

const lifespanSlider = $("lifespanSlider");
const learnSlider = $("learnSlider");
const elderSlider = $("elderSlider");
const lifespanNum = $("lifespanNum");
const learnNum = $("learnNum");
const elderNum = $("elderNum");
const longevityBars = $("longevityBars");

const shockSlider = $("shockSlider");
const resilienceSlider = $("resilienceSlider");
const shockNum = $("shockNum");
const resilienceNum = $("resilienceNum");
const riskBars = $("riskBars");
const riskNote = $("riskNote");

/* Branch */
const speciesSelect = $("speciesSelect");
const compareAllBtn = $("compareAll");
const branchSvg = $("branchSvg");
const speciesBars = $("speciesBars");

/* Perception */
const signalSlider = $("signalSlider");
const accuracySlider = $("accuracySlider");
const signalNum = $("signalNum");
const accuracyNum = $("accuracyNum");
const perceptionBars = $("perceptionBars");
const perceptionNote = $("perceptionNote");

/* Instrument layer */
const terminalQSlider = $("terminalQSlider");
const terminalQNum = $("terminalQNum");
const terminalQBars = $("terminalQBars");
const terminalQGateNote = $("terminalQGateNote");
const metricToggle = $("metricToggle");

const materialSelect = $("materialSelect");
const smoioBars = $("smoioBars");
const smoioNote = $("smoioNote");

const ofnBars = $("ofnBars");
const ofnNote = $("ofnNote");

/* Event log */
const eventLog = $("eventLog");
const clearLogBtn = $("clearLog");

/* Formula viewer */
const formulaToggle = $("formulaToggle");
const formulaCard = $("formulaCard");
const formulaBox = $("formulaBox");

let selectedStage = null;
let compareAll = false;

/* ========= Reviewer text ========= */
const reviewerCopy = `
<strong>What the stage ‚Äúdata‚Äù is:</strong><br>
‚Ä¢ Stage rows are <em>illustrative summaries</em> of widely-known milestones (Upper Paleolithic symbolic culture, Neolithic agriculture, classical formal reasoning, Newton 1687, Einstein 1905, modern simulation/AI).<br>
‚Ä¢ Numerical fields inside stages (constraint/info/tools/etc.) are <em>heuristic knobs</em> used to drive the demo‚Äî<strong>not measurements</strong>.<br><br>

<strong>What the sliders represent:</strong><br>
‚Ä¢ Sliders are user-controlled ‚Äúwhat-if‚Äù parameters (population/contact/loss; lifespan/learning/elder teaching; shock/resilience; perception compression tradeoff).<br>
‚Ä¢ Outputs are computed from these inputs via the functions in the script (retentionScore, intelligenceIndex, collapseProbability, etc.).<br><br>

<strong>Biogeography:</strong><br>
‚Ä¢ The map is a <em>schematic</em> node network (not GIS). Nodes represent regions; link strengths depend on contact and distance proxies.<br><br>

<strong>Terminal Q / S<sub>Moio</sub> / OFN layer:</strong><br>
‚Ä¢ These are <em>derived meters</em> computed from your existing outputs + a material preset + a metric-emergent toggle.<br>
‚Ä¢ Œæ=3/4 and Œ≤=1/4 are displayed as <em>model parameters</em> in this UI, not experimentally established constants here.<br><br>

<strong>Why acceleration happens (no magic jumps):</strong><br>
‚Ä¢ Two coupled clocks: slow <em>biological</em> + fast <em>cultural</em> (external memory). When external memory crosses a threshold, growth becomes network-driven.<br><br>

<strong>Non-linear history:</strong><br>
‚Ä¢ Multi-hominid branching is explicit; regression is allowed under shocks; progress is survivability-weighted (anti-teleology).
`;

/* ========= Event log ========= */
let logItems = [];
function nowStamp(){
  const d = new Date();
  return d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
}
function pushLog(msg){
  logItems.unshift({t: nowStamp(), msg});
  logItems = logItems.slice(0, 18);
  renderLog();
}
function renderLog(){
  if(!eventLog) return;
  eventLog.innerHTML = logItems.map(x=>`
    <div class="logItem">
      <div class="logTop"><span>${x.t}</span><span>event</span></div>
      <div class="logMsg">${x.msg}</div>
    </div>
  `).join("") || `<div class="mini muted">No events yet. Select a stage or move a slider.</div>`;
}
if(clearLogBtn){
  clearLogBtn.addEventListener("click", ()=>{
    logItems = [];
    renderLog();
  });
}

/* ========= UI helpers ========= */
function updateModeBadge(){
  if(!modeBadge || !modeSelect) return;
  const m = modeSelect.value;
  const label = m==="bio" ? "Biological emphasis" : (m==="culture" ? "Cultural emphasis" : "Coupled (Bio√óCulture)");
  modeBadge.textContent = "Mode: " + label;
}
function syncSliderLabels(){
  if(popNum) popNum.textContent = `${popSlider.value}/10`;
  if(contactNum) contactNum.textContent = `${contactSlider.value}/10`;
  if(lossNum) lossNum.textContent = `${lossSlider.value}/10`;

  if(lifespanNum) lifespanNum.textContent = `${lifespanSlider.value}y`;
  if(learnNum) learnNum.textContent = `${learnSlider.value}y`;
  if(elderNum) elderNum.textContent = `${elderSlider.value}y`;

  if(shockNum) shockNum.textContent = `${shockSlider.value}/10`;
  if(resilienceNum) resilienceNum.textContent = `${resilienceSlider.value}/10`;

  if(signalNum) signalNum.textContent = `${signalSlider.value}/10`;
  if(accuracyNum) accuracyNum.textContent = `${accuracySlider.value}/10`;

  if(terminalQNum) terminalQNum.textContent = `${terminalQSlider.value}/100`;
}

function renderDistributionBars(s){
  if(!distBars) return;
  const d = s.dist;
  distBars.innerHTML = `
    ${barRow("Toolmaking", norm10(d.tool), "linear-gradient(to right, rgba(34,197,94,.95), rgba(74,222,128,.95))")}
    ${barRow("Social reasoning", norm10(d.social), "linear-gradient(to right, rgba(56,189,248,.95), rgba(34,197,94,.95))")}
    ${barRow("Symbolic compression", norm10(d.symbolic), "linear-gradient(to right, rgba(168,85,247,.95), rgba(56,189,248,.95))")}
    ${barRow("Long-term planning", norm10(d.planning), "linear-gradient(to right, rgba(251,191,36,.95), rgba(236,72,153,.95))")}
    ${barRow("Environmental modeling", norm10(d.env), "linear-gradient(to right, rgba(234,179,8,.95), rgba(34,197,94,.95))")}
  `;
}

function renderHeat(loss){
  if(!heatMap) return;
  heatMap.innerHTML="";
  for(let r=10;r>=1;r--){
    for(let c=0;c<=9;c++){
      const ret = retentionScore(r, c, loss);
      const div = document.createElement("div");
      div.className="cell";
      div.style.background = hslColor(ret);
      div.title = `pop ${r}, contact ${c}, loss ${loss} ‚Üí retention ${Math.round(ret*100)}%`;
      heatMap.appendChild(div);
    }
  }
}

function renderLongevityBars(lifespan, learnYears, elderYears){
  if(!longevityBars) return longevityTeachingFactor(lifespan, learnYears, elderYears);
  const teach = longevityTeachingFactor(lifespan, learnYears, elderYears);
  const productive = clamp(lifespan-12,0,80);
  const teachWindow = clamp(productive*0.25 + elderYears, 0, 80);

  longevityBars.innerHTML = `
    ${barRow("Teaching fit (0‚Äì1)", teach, `linear-gradient(to right, rgba(239,68,68,.95), rgba(74,222,128,.95))`)}
    ${barRow("Teach window vs learning", clamp(teachWindow/Math.max(learnYears,1),0,1),
      "linear-gradient(to right, rgba(56,189,248,.95), rgba(74,222,128,.95))")}
    <div class="mini muted" style="margin-top:6px;">
      Productive years: <span style="font-family:var(--mono);color:#cfe7ff">${productive.toFixed(0)}y</span> ¬∑
      Teaching window: <span style="font-family:var(--mono);color:#cfe7ff">${teachWindow.toFixed(1)}y</span>.
    </div>
  `;
  return teach;
}

function renderRiskBars(s, ret, teach){
  if(!riskBars || !riskNote) return collapseProbability(s, ret, teach);
  const collapse = collapseProbability(s, ret, teach);
  const fragility = clamp(1 - (0.62*ret + 0.38*teach), 0, 1);
  const shock = norm10(s.shock);
  const resilience = norm10(s.resilience);

  riskBars.innerHTML = `
    ${barRow("Retention stability", ret, "linear-gradient(to right, rgba(239,68,68,.95), rgba(74,222,128,.95))")}
    ${barRow("Knowledge fragility", fragility, "linear-gradient(to right, rgba(74,222,128,.95), rgba(251,113,133,.95))")}
    ${barRow("Shock intensity", shock, "linear-gradient(to right, rgba(100,116,139,.95), rgba(251,113,133,.95))")}
    ${barRow("Resilience policy", resilience, "linear-gradient(to right, rgba(251,191,36,.95), rgba(34,197,94,.95))")}
    ${barRow("Collapse probability", collapse, "linear-gradient(to right, rgba(251,191,36,.95), rgba(251,113,133,.95))")}
  `;
  const note = collapse < 0.33
    ? "Low: institutions + buffers likely preserve complex knowledge."
    : collapse < 0.66
      ? "Medium: regression is plausible; complex systems are fragile under shocks."
      : "High: collapses likely; knowledge may fragment and require rediscovery.";
  riskNote.innerHTML = `<strong style="color:#cfefff">Interpretation:</strong> <span class="muted">${note}</span>`;
  return collapse;
}

/* ========= Perception panel ========= */
function renderPerceptionPanel(s){
  const signal = +signalSlider.value;
  const acc = +accuracySlider.value;
  const P = perceptionCompression(signal, acc, s.brainLimit);

  if(perceptionBars){
    perceptionBars.innerHTML = `
      ${barRow("Compression / pruning", P.compression, "linear-gradient(to right, rgba(56,189,248,.95), rgba(74,222,128,.95))")}
      ${barRow("Perceived stability", P.perceivedStability, "linear-gradient(to right, rgba(74,222,128,.95), rgba(56,189,248,.95))")}
      ${barRow("Error sensitivity", P.errorSensitivity, "linear-gradient(to right, rgba(251,191,36,.95), rgba(236,72,153,.95))")}
      ${barRow("Processing cost proxy", P.processingCost, "linear-gradient(to right, rgba(168,85,247,.95), rgba(56,189,248,.95))")}
    `;
  }

  if(perceptionNote){
    const line = P.compression > 0.66
      ? "High compression: coherent feel, but fine detail is discarded (prune/decay dominates)."
      : P.compression > 0.33
        ? "Balanced: stable perception with moderate error-checking."
        : "Low compression: higher accuracy pursuit, higher mismatch salience.";
    perceptionNote.innerHTML = `<strong style="color:#cfefff">Readout:</strong> <span class="muted">${line}</span>`;
  }
  return P;
}
</script>
<!-- ======================= PART 4 / 4 ======================= -->
<script>
/* ========= Branch SVG ========= */
function renderBranchSvg(selectedKey){
  if(!branchSvg) return;
  const lines = {
    sapiens:{y:70, x0:70, x1:860, start:"~300k", end:"Now+"},
    neanderthal:{y:120, x0:210, x1:560, start:"~400k", end:"~40k"},
    denisovan:{y:160, x0:260, x1:520, start:"~300k", end:"~50k?"},
    hybrid:{y:195, x0:380, x1:820, start:"~60k", end:"Now"}
  };
  const highlight = (k)=> k===selectedKey ? "rgba(56,189,248,.95)" : "rgba(148,163,184,.35)";
  const thick = (k)=> k===selectedKey ? 4 : 2;

  branchSvg.innerHTML = `
    <rect x="0" y="0" width="900" height="220" fill="rgba(2,6,23,.25)"/>
    <text x="16" y="22" fill="rgba(156,163,175,.95)" font-size="12">Branching view (schematic)</text>
    ${Object.keys(lines).map(k=>{
      const L = lines[k];
      const name = species[k].name;
      return `
        <line x1="${L.x0}" y1="${L.y}" x2="${L.x1}" y2="${L.y}"
          stroke="${highlight(k)}" stroke-width="${thick(k)}" stroke-linecap="round"/>
        <circle cx="${L.x0}" cy="${L.y}" r="5" fill="${highlight(k)}"/>
        <text x="${L.x0+10}" y="${L.y-8}" fill="rgba(229,231,235,.85)" font-size="12">${name}</text>
        <text x="${L.x0+10}" y="${L.y+14}" fill="rgba(156,163,175,.95)" font-size="11">${L.start} ‚Üí ${L.end}</text>
      `;
    }).join("")}
    <path d="M 520 120 C 620 105, 690 85, 770 70"
      stroke="rgba(168,85,247,.70)" stroke-width="2" fill="none" stroke-dasharray="6 6"/>
    <text x="560" y="98" fill="rgba(168,85,247,.85)" font-size="11">admixture / gene flow</text>
  `;
}

function renderSpeciesBars(selectedKey){
  if(!speciesBars) return;
  const s = species[selectedKey];
  const buf = norm10(s.buf), net = norm10(s.net), vol = norm10(s.vol), sym = norm10(s.sym), tool = norm10(s.tool);

  let html = `
    ${barRow("Population buffer", buf, "linear-gradient(to right, rgba(239,68,68,.95), rgba(74,222,128,.95))")}
    ${barRow("Network reach", net, "linear-gradient(to right, rgba(56,189,248,.95), rgba(74,222,128,.95))")}
    ${barRow("Environmental volatility", vol, "linear-gradient(to right, rgba(100,116,139,.95), rgba(251,113,133,.95))")}
    ${barRow("Symbolic culture", sym, "linear-gradient(to right, rgba(168,85,247,.95), rgba(236,72,153,.95))")}
    ${barRow("Tool sophistication", tool, "linear-gradient(to right, rgba(34,197,94,.95), rgba(74,222,128,.95))")}
  `;

  if(compareAll){
    const keys = Object.keys(species);
    const rows = keys.map(k=>{
      const X = species[k];
      return `<tr>
        <td>${X.name}</td>
        <td style="font-family:var(--mono)">${X.buf}/10</td>
        <td style="font-family:var(--mono)">${X.net}/10</td>
        <td style="font-family:var(--mono)">${X.vol}/10</td>
        <td style="font-family:var(--mono)">${X.sym}/10</td>
        <td style="font-family:var(--mono)">${X.tool}/10</td>
      </tr>`;
    }).join("");
    html += `
      <div class="mini muted" style="margin-top:10px;"><strong>Compare all lineages</strong></div>
      <div style="overflow:auto;border-radius:14px;border:1px solid rgba(148,163,184,.22);">
        <table style="width:100%;border-collapse:collapse;font-size:12px;">
          <thead>
            <tr>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Lineage</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Buffer</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Reach</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Volatility</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Symbol</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid rgba(148,163,184,.22);">Tools</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    `;
  }

  speciesBars.innerHTML = html;
}

/* ========= Instrument layer render + logs + formulas ========= */
let prevGateOpen = null;
let prevAdj = null;

function renderInstrumentLayer(s, idx, ret, teach, collapse, P){
  const Q = (+terminalQSlider.value)/100;
  const metricEmergent = !!metricToggle.checked;
  const presetKey = materialSelect.value;

  const Qm = terminalQModel(Q, idx, ret, teach, collapse, P, metricEmergent);

  if(terminalQBars){
    terminalQBars.innerHTML = `
      ${barRow("Q readiness", Qm.q, "linear-gradient(to right, rgba(251,113,133,.95), rgba(74,222,128,.95))")}
      ${barRow("Survivability weight", Qm.survivability, "linear-gradient(to right, rgba(56,189,248,.95), rgba(74,222,128,.95))")}
      ${barRow("Coherence proxy", Qm.coherence, "linear-gradient(to right, rgba(168,85,247,.95), rgba(56,189,248,.95))")}
      ${barRow("Gate score", Qm.gateScore, "linear-gradient(to right, rgba(251,191,36,.95), rgba(34,197,94,.95))")}
    `;
  }
  if(terminalQGateNote){
    terminalQGateNote.innerHTML = `
      <strong style="color:#cfefff">Gate:</strong>
      <span class="muted">${Qm.label} ‚Üí ${Qm.gateOpen ? "<span style='color:var(--good)'>OPEN</span>" : "<span style='color:var(--warn)'>CLOSED</span>"}</span>
    `;
  }

  const Sm = smoioModel(presetKey, Qm, idx, ret, teach, collapse, P, metricEmergent);
  if(smoioBars){
    smoioBars.innerHTML = `
      ${barRow("S‚ÇçMoio‚Çé synchrony", Sm.S, "linear-gradient(to right, rgba(251,113,133,.95), rgba(74,222,128,.95))")}
      ${barRow("Residual error proxy", 1 - (Sm.residualKm/0.12), "linear-gradient(to right, rgba(56,189,248,.95), rgba(74,222,128,.95))")}
    `;
  }
  if(smoioNote){
    smoioNote.innerHTML = `
      Preset: <span style="font-family:var(--mono);color:#cfe7ff">${Sm.preset.name}</span><br>
      <span class="muted">${Sm.preset.note}</span><br>
      <strong style="color:#cfefff">Residual (proxy):</strong>
      <span style="font-family:var(--mono);color:#cfe7ff">${Sm.residualKm.toFixed(4)} km</span>
      <span class="muted"> (display mapping; not a measurement)</span>
    `;
  }

  const Om = ofnModel(Qm, Sm, idx, ret, teach, collapse, P, metricEmergent);
  if(ofnBars){
    ofnBars.innerHTML = `
      ${barRow("Entropy score", Om.entropy, "linear-gradient(to right, rgba(74,222,128,.95), rgba(251,113,133,.95))")}
      ${barRow("W‚ÇÇ¬≤ distance", Om.w2, "linear-gradient(to right, rgba(34,197,94,.95), rgba(251,191,36,.95))")}
    `;
  }
  if(ofnNote){
    ofnNote.innerHTML = `
      <span class="muted">${Om.note}</span><br>
      <strong style="color:#cfefff">Adjacency:</strong>
      <span class="muted">${Om.adjacency ? "<span style='color:var(--good)'>PERMITTED</span>" : "<span style='color:var(--warn)'>NOT YET</span>"}</span>
    `;
  }

  // Log threshold flips
  if(prevGateOpen === null) prevGateOpen = Qm.gateOpen;
  if(prevAdj === null) prevAdj = Om.adjacency;

  if(Qm.gateOpen !== prevGateOpen){
    pushLog(Qm.gateOpen
      ? "Terminal Q gate opened: phase-discipline + survivability cleared threshold."
      : "Terminal Q gate closed: conditions fell below threshold."
    );
    prevGateOpen = Qm.gateOpen;
  }
  if(Om.adjacency !== prevAdj){
    pushLog(Om.adjacency
      ? "W‚ÇÇ¬≤ below threshold: adjacency step permitted (model threshold crossed)."
      : "W‚ÇÇ¬≤ rose: adjacency step no longer permitted (model threshold)."
    );
    prevAdj = Om.adjacency;
  }

  // Update formula viewer (if open)
  renderFormulaAudit({idx, ret, teach, collapse, P, Qm, Sm, Om, metricEmergent});

  return {Qm, Sm, Om, metricEmergent};
}

/* ========= Formula Audit ========= */
function renderFormulaAudit(state){
  if(!formulaToggle || !formulaCard || !formulaBox) return;
  if(!formulaToggle.checked){
    formulaCard.style.display = "none";
    return;
  }
  formulaCard.style.display = "block";

  const {idx, ret, teach, collapse, P, Qm, Sm, Om, metricEmergent} = state;
  const q = Qm.q;
  const surv = Qm.survivability;
  const coh = Qm.coherence;
  const gate = Qm.gateScore;

  const blocks = [];

  blocks.push(`
    <div class="formulaBlock">
      <div class="formulaTitle">
        <span>Terminal Q module</span>
        <span class="badge">${metricEmergent ? "metric-emergent ON" : "metric-emergent OFF"}</span>
      </div>

      <div class="codeLike">
Plain equations:
survivability = 0.46¬∑ret + 0.34¬∑teach + 0.20¬∑(1-collapse)
coherence     = 1 - 0.75¬∑| perceivedStability - (1 - errorSensitivity) |
gateScore     = clamp( 0.40¬∑q + 0.25¬∑idx + 0.20¬∑survivability + 0.15¬∑coherence , 0, 1 )
gateOpen      = (gateScore > 0.72) AND (collapse < 0.42) AND (q > 0.62)

LaTeX (optional rendering):
$S_v = 0.46\\,r + 0.34\\,t + 0.20(1-c)$
$C_h = 1 - 0.75\\,|p_s - (1-e_s)|$
$G = \\mathrm{clip}(0.40q + 0.25I + 0.20S_v + 0.15C_h)$
      </div>

      <div class="subst">
Substitution:
ret=r=${f3(ret)}, teach=t=${f3(teach)}, collapse=c=${f3(collapse)}, idx=I=${f3(idx)}
perceivedStability=ps=${f3(P.perceivedStability)}, errorSensitivity=es=${f3(P.errorSensitivity)}
q=${f3(q)}

Computed:
survivability=${f3(surv)}
coherence=${f3(coh)}
gateScore=${f3(gate)}
gateOpen=${Qm.gateOpen ? "TRUE" : "FALSE"}
      </div>
    </div>
  `);

  blocks.push(`
    <div class="formulaBlock">
      <div class="formulaTitle">
        <span>S‚ÇçMoio‚Çé structural synchrony</span>
        <span class="badge">preset: ${Sm.preset.name}</span>
      </div>

      <div class="codeLike">
Plain equations:
phaseAssist  = clamp( 0.55¬∑q + 0.25¬∑coherence + 0.20¬∑(1-collapse), 0, 1 )
costPenalty  = clamp( 0.35¬∑processingCost + 0.35¬∑collapse + 0.30¬∑(1-ret), 0, 1 )
S            = clamp( base¬∑(0.55 + 0.45¬∑phaseAssist)¬∑(1 - damp¬∑costPenalty), 0, 1 )
if metricEmergent == false then S = 0.96¬∑S
residualKm   = (1 - S)¬∑0.12   (display mapping / proxy)

LaTeX (optional):
$A=\\mathrm{clip}(0.55q+0.25C_h+0.20(1-c))$
$K=\\mathrm{clip}(0.35p_c+0.35c+0.30(1-r))$
$S=\\mathrm{clip}(b(0.55+0.45A)(1-dK))$
      </div>

      <div class="subst">
Substitution:
q=${f3(q)}, coherence=${f3(coh)}, collapse=${f3(collapse)}, ret=${f3(ret)}
processingCost=pc=${f3(P.processingCost)}
base=b=${f3(Sm.preset.base)}, damp=d=${f3(Sm.preset.damp)}
phaseAssist=A=${f3(Sm.phaseAssist)}, costPenalty=K=${f3(Sm.costPenalty)}
metricEmergent=${metricEmergent ? "TRUE" : "FALSE"}

Computed:
S_Moio=${f3(Sm.S)}
residualKm=${f4(Sm.residualKm)}
      </div>
    </div>
  `);

  blocks.push(`
    <div class="formulaBlock">
      <div class="formulaTitle">
        <span>Entropy + W‚ÇÇ¬≤ distance</span>
        <span class="badge">OFN: Œæ=${OFN_CONST.xi}, Œ≤=${OFN_CONST.beta}</span>
      </div>

      <div class="codeLike">
Plain equations:
entropy = clamp( 0.55¬∑collapse + 0.25¬∑processingCost + 0.20¬∑(1 - S), 0, 1 )
W2^2    = clamp( 1 - (0.62¬∑gateScore + 0.18¬∑idx + 0.20¬∑(1-entropy)), 0, 1 )
adjacent = (W2^2 < 0.33) AND (q > 0.58)

LaTeX (optional):
$H=\\mathrm{clip}(0.55c+0.25p_c+0.20(1-S))$
$W_2^2=\\mathrm{clip}(1-(0.62G+0.18I+0.20(1-H)))$
      </div>

      <div class="subst">
Substitution:
collapse=c=${f3(collapse)}, processingCost=pc=${f3(P.processingCost)}, S=${f3(Sm.S)}
gateScore=G=${f3(gate)}, idx=I=${f3(idx)}, q=${f3(q)}

Computed:
entropy H=${f3(Om.entropy)}
W2^2=${f3(Om.w2)}
adjacency=${Om.adjacency ? "TRUE" : "FALSE"}
      </div>
    </div>
  `);

  blocks.push(`
    <div class="formulaBlock">
      <div class="formulaTitle">
        <span>Perception compression (inputs feeding coherence)</span>
        <span class="badge">auxiliary</span>
      </div>

      <div class="codeLike">
Plain equations:
eff         = clip(0.62¬∑loadN + 0.28¬∑(1-accN) + 0.10¬∑(1-brainN))
compression = clip( sigmoid( (eff - accN)¬∑4.2 ) )
perceivedStability = clip( 0.20 + 0.80¬∑compression¬∑(1 - 0.35¬∑loadN) )
errorSensitivity   = clip( 1 - compression )
processingCost     = clip( 0.20 + 0.80¬∑loadN¬∑(1 - 0.55¬∑compression) )
      </div>

      <div class="subst">
Substitution:
signalLoad=${signalSlider.value}/10 ‚Üí loadN=${f3(P.loadN)}
accuracyDemand=${accuracySlider.value}/10 ‚Üí accN=${f3(P.accN)}
brainLimit(stage)=${selectedStage ? selectedStage.brainLimit : "‚Äî"} ‚Üí brainN=${f3(P.brainN)}

Computed:
eff=${f3(P.eff)}
compression=${f3(P.compression)}
perceivedStability=${f3(P.perceivedStability)}
errorSensitivity=${f3(P.errorSensitivity)}
processingCost=${f3(P.processingCost)}
      </div>
    </div>
  `);

  formulaBox.innerHTML = blocks.join("");

  if(window.MathJax && window.MathJax.typeset){
    try{ window.MathJax.typeset(); }catch(e){}
  }
}

/* ========= Table render ========= */
function renderTable(){
  if(!tableBody) return;
  tableBody.innerHTML="";
  const q = (searchBox?.value || "").trim().toLowerCase();
  stages.filter(s=>{
    if(!q) return true;
    const blob = (s.year+" "+s.region+" "+s.lineage+" "+s.advance+" "+s.physics+" "+s.why).toLowerCase();
    return blob.includes(q);
  }).forEach(s=>{
    const tr = document.createElement("tr");
    const ret = retentionScore(s.pop, s.contact, s.loss);
    tr.innerHTML = `
      <td>${s.year}</td>
      <td>${s.region}</td>
      <td>${s.lineage}</td>
      <td>${s.advance}</td>
      <td>${s.physics}</td>
      <td style="font-family:var(--mono); color:${hslColor(ret)}">${Math.round(ret*100)}%</td>
    `;
    tr.onclick = ()=>selectStage(s, tr);
    if(selectedStage && selectedStage.id===s.id) tr.classList.add("active-row");
    tableBody.appendChild(tr);
  });
}

/* ========= Print report ========= */
function renderPrintArea(snapshot){
  if(!printArea) return;
  const s = snapshot.stage;
  const pinned = snapshot.pinned;
  const P = snapshot.P;
  const Inst = snapshot.inst;

  const pinnedHtml = pinned ? `
    <h3 style="margin:10px 0 6px;">Pinned Region Snapshot</h3>
    <div><strong>${pinned.name}</strong></div>
    <ul>
      <li>Retention: ${Math.round(pinned.retention*100)}%</li>
      <li>Innovation intensity: ${Math.round(pinned.intensity*100)}%</li>
      <li>Diffusion pressure: ${Math.round(pinned.diffusion*100)}%</li>
      <li>Friction: ${Math.round(pinned.friction*100)}%</li>
    </ul>
  ` : `<h3 style="margin:10px 0 6px;">Pinned Region Snapshot</h3><div>None</div>`;

  printArea.innerHTML = `
    <div style="font-family:Arial, sans-serif; color:#000;">
      <h1 style="margin:0 0 6px;">Human Intelligence Continuum ‚Äî Selected Stage Report</h1>
      <div style="color:#333;">Generated: ${new Date().toLocaleString()}</div>

      <h2 style="margin:12px 0 6px;">Stage</h2>
      <div><strong>${s.lineage}</strong> ‚Äî ${s.year}</div>
      <div style="margin-top:4px;"><strong>Region:</strong> ${s.region}</div>
      <div style="margin-top:4px;"><strong>Advance:</strong> ${s.advance}</div>
      <div style="margin-top:4px;"><strong>Physics maturity:</strong> ${s.physics}</div>
      <div style="margin-top:6px;color:#333;">${s.why}</div>

      <h2 style="margin:12px 0 6px;">Computed Results</h2>
      <ul>
        <li><strong>Intelligence index:</strong> ${Math.round(snapshot.idx*100)}/100</li>
        <li><strong>Retention (global):</strong> ${Math.round(snapshot.ret*100)}%</li>
        <li><strong>Teaching fit:</strong> ${Math.round(snapshot.teach*100)}%</li>
        <li><strong>Collapse probability:</strong> ${Math.round(snapshot.collapse*100)}%</li>
      </ul>

      <h2 style="margin:12px 0 6px;">Perception Compression</h2>
      <ul>
        <li><strong>Signal load:</strong> ${signalSlider.value}/10</li>
        <li><strong>Accuracy demand:</strong> ${accuracySlider.value}/10</li>
        <li><strong>Compression:</strong> ${Math.round(P.compression*100)}%</li>
        <li><strong>Perceived stability:</strong> ${Math.round(P.perceivedStability*100)}%</li>
        <li><strong>Error sensitivity:</strong> ${Math.round(P.errorSensitivity*100)}%</li>
        <li><strong>Processing cost proxy:</strong> ${Math.round(P.processingCost*100)}%</li>
      </ul>

      <h2 style="margin:12px 0 6px;">Terminal Q / S‚ÇçMoio‚Çé / OFN‚ÄìTCFQ (Instrument Layer)</h2>
      <ul>
        <li><strong>Terminal Q:</strong> ${terminalQSlider.value}/100</li>
        <li><strong>Gate:</strong> ${Inst.Qm.gateOpen ? "OPEN" : "CLOSED"} (${Inst.Qm.label})</li>
        <li><strong>S‚ÇçMoio‚Çé:</strong> ${Inst.Sm.S.toFixed(3)}</li>
        <li><strong>Residual (proxy):</strong> ${Inst.Sm.residualKm.toFixed(4)} km</li>
        <li><strong>Entropy score:</strong> ${Inst.Om.entropy.toFixed(3)}</li>
        <li><strong>W‚ÇÇ¬≤ distance:</strong> ${Inst.Om.w2.toFixed(3)}</li>
        <li><strong>Adjacency:</strong> ${Inst.Om.adjacency ? "PERMITTED" : "NOT YET"}</li>
        <li><strong>Metric emergent:</strong> ${Inst.metricEmergent ? "ON" : "OFF"}</li>
      </ul>

      ${pinnedHtml}

      <p style="margin-top:12px;color:#333;">
        Provenance note: stage fields are illustrative knobs; map is schematic; outputs are computed from the visible functions + your slider settings.
      </p>
    </div>
  `;
}

/* ========= Main recompute loop ========= */
function recalcAndRenderAll(logReason=null){
  updateModeBadge();
  syncSliderLabels();

  if(!selectedStage) selectedStage = stages[0];

  const s = {...selectedStage};
  s.pop = +popSlider.value;
  s.contact = +contactSlider.value;
  s.loss = +lossSlider.value;

  s.lifespan = +lifespanSlider.value;
  s.learnYears = +learnSlider.value;
  s.elderYears = +elderSlider.value;

  s.shock = +shockSlider.value;
  s.resilience = +resilienceSlider.value;

  const ret = retentionScore(s.pop, s.contact, s.loss);
  const teach = renderLongevityBars(s.lifespan, s.learnYears, s.elderYears);
  const collapse = renderRiskBars(s, ret, teach);
  const idx = intelligenceIndex(s, modeSelect.value, ret, teach);

  if(kpiInt) kpiInt.textContent = `${Math.round(idx*100)}/100`;
  if(kpiCollapse) kpiCollapse.textContent = fmtPct(collapse);

  renderDistributionBars(s);
  drawCrossover(s);
  renderHeat(+lossSlider.value);

  const P = renderPerceptionPanel(s);

  renderBranchSvg(speciesSelect.value);
  renderSpeciesBars(speciesSelect.value);

  const model = computeRegional(s, modeSelect.value);
  renderWorldMap(model);
  updatePinnedRegion(model);

  if(reviewerBox) reviewerBox.style.display = reviewerToggle.checked ? "block" : "none";
  if(reviewerText) reviewerText.innerHTML = reviewerCopy;

  const Inst = renderInstrumentLayer(s, idx, ret, teach, collapse, P);

  const pinned = pinnedRegionId ? model.computed.find(r=>r.id===pinnedRegionId) : null;
  renderPrintArea({stage:s, mode:modeSelect.value, idx, ret, teach, collapse, pinned, P, inst:Inst});

  renderTable();
  if(logReason) pushLog(logReason);
}

/* ========= Selection + slider sync ========= */
function setSlidersFromStage(s){
  popSlider.value = s.pop;
  contactSlider.value = s.contact;
  lossSlider.value = s.loss;

  lifespanSlider.value = s.lifespan;
  learnSlider.value = s.learnYears;
  elderSlider.value = s.elderYears;

  shockSlider.value = s.shock;
  resilienceSlider.value = s.resilience;

  syncSliderLabels();
  renderHeat(+lossSlider.value);
}

function selectStage(s, tr){
  selectedStage = s;
  document.querySelectorAll("tbody tr").forEach(r=>r.classList.remove("active-row"));
  tr.classList.add("active-row");
  if(selectedBadge) selectedBadge.textContent = `${s.lineage} ¬∑ ${s.year}`;
  setSlidersFromStage(s);
  recalcAndRenderAll(`Stage selected: ${s.year} ‚Äî ${s.region} ‚Äî ${s.advance}`);
}

/* ========= Wiring ========= */
if(searchBox) searchBox.addEventListener("input", renderTable);

if(modeSelect) modeSelect.addEventListener("change", ()=>recalcAndRenderAll(`Mode changed: ${modeSelect.value}`));
if(reviewerToggle) reviewerToggle.addEventListener("change", ()=>recalcAndRenderAll(`Reviewer Mode: ${reviewerToggle.checked ? "ON" : "OFF"}`));

[
  popSlider, contactSlider, lossSlider,
  lifespanSlider, learnSlider, elderSlider,
  shockSlider, resilienceSlider,
  signalSlider, accuracySlider,
  terminalQSlider
].forEach(el=>{
  if(el) el.addEventListener("input", ()=>recalcAndRenderAll());
});

if(metricToggle){
  metricToggle.addEventListener("change", ()=>{
    recalcAndRenderAll(`Einstein metric emergent: ${metricToggle.checked ? "ON" : "OFF"}`);
  });
}
if(materialSelect){
  materialSelect.addEventListener("change", ()=>{
    const preset = materialPresets[materialSelect.value]?.name || "preset";
    recalcAndRenderAll(`Material preset changed: ${preset}`);
  });
}

if(speciesSelect){
  speciesSelect.addEventListener("change", ()=>{
    compareAll = false;
    if(compareAllBtn) compareAllBtn.textContent = "Compare all";
    recalcAndRenderAll(`Lineage view: ${speciesSelect.value}`);
  });
}
if(compareAllBtn){
  compareAllBtn.addEventListener("click", ()=>{
    compareAll = !compareAll;
    compareAllBtn.textContent = compareAll ? "Close compare" : "Compare all";
    recalcAndRenderAll(compareAll ? "Compare all lineages: ON" : "Compare all lineages: OFF");
  });
}

if(formulaToggle){
  formulaToggle.addEventListener("change", ()=>{
    pushLog(formulaToggle.checked
      ? "Formula audit opened: equations + live substitutions visible."
      : "Formula audit closed."
    );
    recalcAndRenderAll();
  });
}

if(resetTuningBtn){
  resetTuningBtn.addEventListener("click", ()=>{
    pinnedRegionId = null;
    compareAll = false;
    if(compareAllBtn) compareAllBtn.textContent = "Compare all";
    if(!selectedStage) selectedStage = stages[0];
    setSlidersFromStage(selectedStage);

    signalSlider.value = 6;
    accuracySlider.value = 5;
    terminalQSlider.value = 72;
    metricToggle.checked = true;
    materialSelect.value = "aln_mo";
    if(formulaToggle) formulaToggle.checked = false;

    prevGateOpen = null;
    prevAdj = null;

    recalcAndRenderAll("Reset tuning to defaults.");
  });
}

if(printBtn){
  printBtn.addEventListener("click", ()=>{
    if(!printArea) return;
    printArea.style.display = "block";
    setTimeout(()=>{
      window.print();
      setTimeout(()=>{ printArea.style.display = "none"; }, 250);
    }, 50);
  });
}

/* ========= Boot ========= */
function boot(){
  selectedStage = stages[0];
  if(selectedBadge) selectedBadge.textContent = `${selectedStage.lineage} ¬∑ ${selectedStage.year}`;

  // defaults
  signalSlider.value = 6;
  accuracySlider.value = 5;
  terminalQSlider.value = 72;
  metricToggle.checked = true;
  materialSelect.value = "aln_mo";
  if(formulaToggle) formulaToggle.checked = false;

  setSlidersFromStage(selectedStage);
  renderTable();

  const firstRow = document.querySelector("#eventTable tr");
  if(firstRow) firstRow.classList.add("active-row");

  pushLog("Boot: initialized model + instrument layer + formula audit toggle.");
  recalcAndRenderAll();
}

/* ========= Minimal sanity check (helps when something is missing) ========= */
const mustIds = ["eventTable","modeSelect","popSlider","worldMap","crossoverCanvas","terminalQSlider"];
const missing = mustIds.filter(id=>!document.getElementById(id));
if(missing.length){
  console.warn("Missing required elements:", missing);
  pushLog("Warning: missing elements detected ‚Äî check that you pasted all 4 parts into one file.");
}

boot();

/* Close DOMContentLoaded wrapper */
});
</script>

</body>
</html>
