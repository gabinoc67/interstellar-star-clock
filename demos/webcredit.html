<!-- ======================= PART 1 / 4 =======================
Reality-Grounded Search Engine (UPDATED)
+ Facts-only toggle + Minimum trust slider + Spelling/grammar penalty
========================================================== -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Reality-Grounded Search — Trust Graph + Falsification</title>

<style>
:root{
  color-scheme: dark;
  --bg:#020617;
  --panel:#0f172a;
  --ink:#e5e7eb;
  --muted:#9ca3af;
  --line:rgba(148,163,184,.25);
  --good:#22c55e;
  --warn:#f59e0b;
  --mid:#38bdf8;
  --bad:#fb7185;
  --radius:16px;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:radial-gradient(circle at top,#020617,#000 70%);
  color:var(--ink);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
}
.wrap{max-width:1450px;margin:18px auto;padding:14px}
h1{margin:0 0 6px;font-size:22px}
.sub{color:var(--muted);font-size:13px;max-width:1100px;line-height:1.35}

.grid{
  display:grid;
  grid-template-columns:420px 1fr;
  gap:14px;
}
@media(max-width:1100px){ .grid{grid-template-columns:1fr} }

.card{
  background:linear-gradient(180deg,var(--panel),#020617);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:12px;
}
.card h2{margin:0 0 10px;font-size:15px}
hr{border:none;border-top:1px solid var(--line);margin:12px 0}

button, input, textarea, select{
  border-radius:12px;
  border:1px solid var(--line);
  background:#020617;
  color:var(--ink);
  font-weight:800;
}
button{
  padding:9px 12px;
  cursor:pointer;
}
button.primary{border-color:var(--mid);background:rgba(56,189,248,.10)}
button.warn{border-color:var(--warn)}
button.bad{border-color:var(--bad)}
button.good{border-color:var(--good)}
button:disabled{opacity:.55;cursor:not-allowed}

.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.small{font-size:12px;color:var(--muted);line-height:1.35}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;border:1px solid var(--line);padding:2px 6px;border-radius:8px;color:var(--ink);background:rgba(255,255,255,.03)}
label{font-size:12px;color:var(--muted);font-weight:800}
.check{display:flex;gap:8px;align-items:center}
.check input{width:18px;height:18px}
input[type="range"]{width:220px}

table{width:100%;border-collapse:collapse;font-size:12px}
th,td{padding:6px;border-bottom:1px solid var(--line);text-align:left;vertical-align:top}
th{color:#cbd5e1;font-weight:900}

.tag{
  display:inline-block;
  padding:3px 8px;
  border-radius:999px;
  font-size:11px;
  border:1px solid var(--line);
  margin-right:6px;
}
.goodTag{border-color:var(--good);color:#bbf7d0}
.warnTag{border-color:var(--warn);color:#fde68a}
.midTag{border-color:var(--mid);color:#bae6fd}
.badTag{border-color:var(--bad);color:#fecdd3}

.canvasWrap{margin-top:8px}
canvas{width:100%;height:260px;border-radius:12px;border:1px solid var(--line);background:rgba(0,0,0,.15)}

textarea{
  width:100%;
  min-height:120px;
  padding:10px;
  font-weight:700;
  font-size:12px;
  line-height:1.35;
  resize:vertical;
}
input[type="text"]{
  padding:10px 12px;
  font-weight:900;
  width:min(560px,100%);
}

.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border:1px solid var(--line);border-radius:12px;
  background:rgba(255,255,255,.03);
}
.meter{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;color:#cbd5e1}

.printOnly{display:none}
@media print{
  body{background:#fff;color:#000}
  .wrap{max-width:none}
  .noPrint{display:none !important}
  .printOnly{display:block}
  .card{background:#fff;border-color:#bbb}
  table{font-size:11px}
  th,td{border-bottom:1px solid #ccc}
}
</style>
</head>

<body>
<div class="wrap">
  <h1>Reality-Grounded Search Engine</h1>
  <div class="sub">
    This system never blocks IPs. It ranks claims by <b>provenance scoring</b> (+/– points),
    <b>language quality</b> (including spelling/grammar signals), <b>corroboration</b>, and <b>contradiction penalties</b>.
    “Verified” here means <b>high confidence by rules</b> (not absolute truth).
  </div>

  <!-- CONTROLS -->
  <div class="row noPrint" style="margin:12px 0">
    <button class="primary" id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button class="warn" id="stopBtn">Stop</button>
    <button class="bad" id="resetBtn">Reset</button>
    <button id="printBtn">Print Report</button>
    <button id="csvBtn">Export CSV</button>
  </div>

  <div class="grid">

    <!-- LEFT -->
    <div class="card">
      <h2>Explanation</h2>
      <div class="small">
        <b>Truth isn’t detected</b>; instead, claims are narrowed using:
        <br/>• <b>Provenance trust</b> (source history) +/–
        <br/>• <b>Language quality</b> (too many misspellings / chaotic grammar reduces confidence)
        <br/>• <b>Independent corroboration</b> (other sources saying similar things)
        <br/>• <b>Contradiction penalties</b> (“debunked/false alarm/no damage” style evidence)
        <hr/>
        <b>How long should search run?</b>
        Accuracy improves when you have <b>enough corroboration events</b>.
        A good rule is to collect <span class="kbd">20–50 matched articles</span> (or several minutes of feed flow)
        before trusting the distribution strongly. With only 1–3 articles, results are volatile.
      </div>

      <hr/>

      <h2>Search (Fetch real articles via RSS)</h2>
      <div class="small">
        Enter keywords. The engine fetches from the feed list and ranks results.
        Tip: narrow queries (e.g., <span class="kbd">“Houston power outage”</span>) for tighter corroboration.
      </div>

      <div class="row" style="margin-top:10px">
        <input id="queryInput" type="text" placeholder="Search query (keywords)..." />
        <button class="good" id="searchBtn">Search</button>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="check badge" title="Only show items classified Verified or Likely (and above trust threshold).">
          <input id="factsOnlyToggle" type="checkbox" checked />
          <label for="factsOnlyToggle" style="margin:0;color:var(--ink)">Only show Verified + Likely</label>
        </div>

        <div class="badge" title="Hide items from sources below this trust score.">
          <label for="minTrust" style="margin:0">Min trust</label>
          <input id="minTrust" type="range" min="0" max="1" step="0.01" value="0.55" />
          <span class="meter" id="minTrustLabel">0.55</span>
        </div>
      </div>

      <div class="small" style="margin-top:10px">
        RSS feeds (one per line). Add/remove feeds anytime.
      </div>
      <textarea id="feedsBox"></textarea>

      <div class="row" style="margin-top:10px">
        <span class="tag goodTag">Verified</span>
        <span class="tag warnTag">Likely</span>
        <span class="tag midTag">Narrative</span>
        <span class="tag badTag">Rejected</span>
      </div>

      <hr/>

      <h2>Trust Graph (Sources)</h2>
      <div class="small">
        Trust rises with corroboration and falls with contradictions.
      </div>

      <table style="margin-top:10px">
        <thead><tr><th>Source</th><th>Trust</th></tr></thead>
        <tbody id="trustTable"></tbody>
      </table>
    </div>

    <!-- RIGHT -->
    <div>
      <div class="card">
        <h2>Reality Signal Distribution</h2>
        <div class="small">
          Bar chart of classifications in the session. (Filtering affects the table, not the raw counts.)
        </div>
        <div class="canvasWrap">
          <canvas id="signalChart"></canvas>
        </div>
      </div>

      <div class="card" style="margin-top:14px">
        <h2>Articles / Events</h2>
        <table>
          <thead>
            <tr>
              <th>Time</th>
              <th>Title / Claim</th>
              <th>Source</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="eventTable"></tbody>
        </table>

        <div class="printOnly" style="margin-top:12px">
          <b>Printed Audit</b>: This report shows classifications + trust scores at print time.
        </div>
      </div>
    </div>

  </div>
</div>
<!-- ======================= PART 2 / 4 =======================
Core State + Scoring (with spelling/grammar penalty)
========================================================== -->
<script>
// ===================== GLOBAL STATE =====================
let timeTick = 0;
let running = false;
let timer = null;

const trustGraph = Object.create(null);
const events = [];

// Raw session counts (not filtered)
const counts = { Verified:0, Likely:0, Narrative:0, Rejected:0 };

// Default RSS feeds (editable)
const DEFAULT_FEEDS = [
  "https://www.theguardian.com/world/rss",
  "https://feeds.bbci.co.uk/news/world/rss.xml",
  "https://feeds.npr.org/1004/rss.xml",
  "https://www.usgs.gov/feeds/earthquakes/feed",
  "https://www.noaa.gov/rss.xml",
  "https://www.nasa.gov/rss/dyn/breaking_news.rss"
];
document.getElementById("feedsBox").value = DEFAULT_FEEDS.join("\n");

// UI filter controls
const factsOnlyToggle = document.getElementById("factsOnlyToggle");
const minTrust = document.getElementById("minTrust");
const minTrustLabel = document.getElementById("minTrustLabel");
minTrustLabel.textContent = Number(minTrust.value).toFixed(2);
minTrust.oninput = () => { minTrustLabel.textContent = Number(minTrust.value).toFixed(2); renderAll(); };
factsOnlyToggle.onchange = () => renderAll();

// ===================== SIMULATION SOURCES =====================
const simSources = [
  { name: "Gov Infrastructure Feed", type: "institutional", baseTrust: 0.72 },
  { name: "Major News Outlet", type: "institutional", baseTrust: 0.62 },
  { name: "Utility Operator Bulletin", type: "institutional", baseTrust: 0.78 },
  { name: "Independent Research Blog", type: "civilian", baseTrust: 0.42 },
  { name: "Civilian Eyewitness Post", type: "civilian", baseTrust: 0.36 },
  { name: "Bot Content Farm", type: "noise", baseTrust: 0.15 }
];

const simClaims = [
  "Building destroyed",
  "Power grid instability",
  "Explosion reported",
  "Flooding in urban area",
  "Infrastructure disruption",
  "Fire reported near facility"
];

function ensureSource(sourceKey, typeHint="unknown", baseTrust=0.45){
  if (!trustGraph[sourceKey]){
    trustGraph[sourceKey] = {
      trust: baseTrust,
      contradictions: 0,
      confirmations: 0,
      type: typeHint
    };
  }
}
simSources.forEach(s => ensureSource(s.name, s.type, s.baseTrust));

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function rand(min,max){ return min + Math.random()*(max-min); }

function tokenize(s){
  return (s||"")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g," ")
    .split(/\s+/)
    .filter(x => x.length >= 4);
}

function overlapCount(a,b){
  const setB = new Set(b);
  let c = 0;
  a.forEach(x => { if (setB.has(x)) c++; });
  return c;
}

// ===================== SPELLING/GRAMMAR SIGNAL (LIGHTWEIGHT HEURISTIC) =====================
// We cannot run a full dictionary offline reliably, so we use heuristic cues:
// - high non-letter ratio
// - repeated punctuation
// - lots of ALL CAPS words
// - "keyboard smash" tokens (many consonants) or very long tokens
// - excessive repeated characters
function writingQualityScore(text, sourceType){
  const t = (text||"").trim();
  if (!t) return 0.55;

  const len = t.length;
  const letters = (t.match(/[A-Za-z]/g)||[]).length;
  const digits = (t.match(/[0-9]/g)||[]).length;
  const punct  = len - letters - digits - (t.match(/\s/g)||[]).length;

  const nonLetterRatio = len ? (punct / len) : 0;
  const allCapsWords = (t.match(/\b[A-Z]{4,}\b/g)||[]).length;
  const multiPunct = (t.match(/([!?.,])\1{2,}/g)||[]).length;
  const stretched = (t.match(/([a-zA-Z])\1{3,}/g)||[]).length;

  // suspicious long tokens or consonant-heavy tokens
  const words = t.split(/\s+/).filter(Boolean);
  let weird = 0;
  for (const w of words){
    const w2 = w.replace(/[^A-Za-z]/g,"");
    if (w2.length >= 18) weird++;
    if (/[bcdfghjklmnpqrstvwxz]{6,}/i.test(w2)) weird++;
  }

  // baseline by source type (institutional tends to be cleaner)
  let base = 0.62;
  if (sourceType === "institutional") base = 0.78;
  if (sourceType === "civilian") base = 0.60;
  if (sourceType === "noise") base = 0.30;

  // penalties
  let penalty = 0;
  penalty += Math.min(0.35, nonLetterRatio * 0.9);
  penalty += Math.min(0.18, allCapsWords * 0.03);
  penalty += Math.min(0.18, multiPunct * 0.06);
  penalty += Math.min(0.18, stretched * 0.05);
  penalty += Math.min(0.22, weird * 0.02);

  // clamp
  return clamp01(base - penalty + rand(-0.03, 0.03));
}

// Tone / sensational penalty
function toneScore(text, sourceType){
  const t = (text||"").toLowerCase();
  const sensational = [
    "shocking","insane","unbelievable","100%","guaranteed","secret",
    "they don't want you to know","hoax","proof!!!","wake up"
  ];
  let penalty = 0;
  sensational.forEach(w => { if (t.includes(w)) penalty += 0.08; });

  let base = 0.58;
  if (sourceType === "institutional") base = 0.74;
  if (sourceType === "civilian") base = 0.62;
  if (sourceType === "noise") base = 0.28;

  return clamp01(base - penalty + rand(-0.03, 0.03));
}

// Corroboration (keyword overlap in recent events)
function corroborationScore(sourceKey, text){
  const recent = events.slice(-30);
  const tokens = tokenize(text).slice(0, 16);
  if (!tokens.length) return 0;

  let hits = 0;
  recent.forEach(e => {
    if (e.source === sourceKey) return;
    const t2 = tokenize((e.claim||"") + " " + (e.title||""));
    const overlap = overlapCount(tokens, t2);
    if (overlap >= 3 && e.result !== "Rejected") hits++;
  });

  return Math.min(hits / 3, 1);
}

// Contradiction markers (light heuristic)
function contradictionHit(text){
  const t = (text||"").toLowerCase();
  const neg = ["no damage","false alarm","debunked","did not happen","hoax","misleading","incorrect report","retracted"];
  for (const w of neg){ if (t.includes(w)) return true; }
  return false;
}

// ===================== CLASSIFICATION =====================
function classifyItem(item){
  ensureSource(item.source, item.sourceType || "unknown", item.baseTrust ?? 0.45);
  const node = trustGraph[item.source];

  const text = (item.claim||"") + " " + (item.title||"") + " " + (item.snippet||"");
  const trust = node.trust;

  const quality = writingQualityScore(text, node.type);   // spelling/grammar signal
  const tone = toneScore(text, node.type);
  const corr = corroborationScore(item.source, text);
  const contrad = contradictionHit(text);

  // Combined language score: quality weighted slightly more than tone
  const lang = clamp01(0.60*quality + 0.40*tone);

  // Weighted confidence
  const confidence = (0.46 * trust) + (0.32 * lang) + (0.22 * corr);

  let result = "Narrative";

  // Strong falsification rule
  if (contrad){
    result = "Rejected";
    node.trust = clamp01(node.trust - 0.11);
    node.contradictions++;
  } else {
    if (confidence >= 0.80 && corr >= 0.66){
      result = "Verified";
      node.trust = clamp01(node.trust + 0.04);
      node.confirmations++;
    } else if (confidence >= 0.60){
      result = "Likely";
      node.trust = clamp01(node.trust + 0.02);
      if (corr > 0.33) node.confirmations++;
    } else {
      result = "Narrative";
      node.trust = clamp01(node.trust - 0.01);
    }
  }

  return { result, confidence, trust: node.trust, lang, quality, tone, corr, contrad };
}

// ===================== SIM EVENT =====================
function generateSimEvent(){
  const src = simSources[Math.floor(Math.random()*simSources.length)];
  const claim = simClaims[Math.floor(Math.random()*simClaims.length)];

  const item = {
    kind: "sim",
    time: timeTick,
    source: src.name,
    sourceType: src.type,
    baseTrust: src.baseTrust,
    claim: claim,
    title: "",
    snippet: ""
  };

  const out = classifyItem(item);
  item.result = out.result;
  item.meta = out;

  events.push(item);
  counts[item.result]++;
  renderAll();
}

// ===================== RENDER =====================
function escapeHtml(s){
  return (s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function resultTag(r){
  const cls =
    r === "Verified" ? "goodTag" :
    r === "Likely" ? "warnTag" :
    r === "Rejected" ? "badTag" : "midTag";
  return `<span class="tag ${cls}">${r}</span>`;
}

function renderEventTable(){
  const tbody = document.getElementById("eventTable");
  tbody.innerHTML = "";

  const factsOnly = factsOnlyToggle.checked;
  const minT = Number(minTrust.value);

  const list = events.slice().reverse().filter(e => {
    const t = trustGraph[e.source]?.trust ?? 0;
    if (t < minT) return false;
    if (!factsOnly) return true;
    return (e.result === "Verified" || e.result === "Likely");
  }).slice(0, 40);

  list.forEach(e => {
    const row = document.createElement("tr");
    const title = e.title || e.claim || "(no title)";

    const tScore = (trustGraph[e.source]?.trust ?? 0).toFixed(2);
    const metaLine = e.meta
      ? `trust ${tScore} • conf ${(e.meta.confidence||0).toFixed(2)} • lang ${(e.meta.lang||0).toFixed(2)} • corr ${(e.meta.corr||0).toFixed(2)}`
      : `trust ${tScore}`;

    row.innerHTML = `
      <td>${e.time}</td>
      <td>
        <div style="font-weight:900">${escapeHtml(title)}</div>
        ${e.link ? `<div class="small">${escapeHtml(e.link)}</div>` : ``}
        ${e.snippet ? `<div class="small">${escapeHtml(e.snippet)}</div>` : ``}
        <div class="small">${escapeHtml(metaLine)}</div>
      </td>
      <td>${escapeHtml(e.source)}</td>
      <td>${resultTag(e.result)}</td>
    `;
    tbody.appendChild(row);
  });
}

function renderTrustTable(){
  const tbody = document.getElementById("trustTable");
  tbody.innerHTML = "";

  Object.entries(trustGraph)
    .sort((a,b) => b[1].trust - a[1].trust)
    .slice(0, 50)
    .forEach(([name,data]) => {
      const trend =
        data.trust >= 0.70 ? "goodTag" :
        data.trust >= 0.42 ? "warnTag" : "badTag";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(name)}</td>
        <td>
          <span class="tag ${trend}">${data.trust.toFixed(2)}</span>
          <div class="small">✓ ${data.confirmations} &nbsp;|&nbsp; ✗ ${data.contradictions}</div>
        </td>
      `;
      tbody.appendChild(tr);
    });
}

function renderAll(){
  renderTrustTable();
  renderEventTable();
  drawSignalChart();
}

// ===================== CONTROLS =====================
const startBtn = document.getElementById("startBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn  = document.getElementById("stopBtn");
const resetBtn = document.getElementById("resetBtn");
const csvBtn   = document.getElementById("csvBtn");
const printBtn = document.getElementById("printBtn");

function startLoop(){
  if (running) return;
  running = true;
  timer = setInterval(() => {
    timeTick++;
    generateSimEvent();
  }, 900);
}
function pauseLoop(){ running = false; clearInterval(timer); timer = null; }
function stopLoop(){ pauseLoop(); }

function resetAll(){
  pauseLoop();
  timeTick = 0;
  events.length = 0;
  counts.Verified = counts.Likely = counts.Narrative = counts.Rejected = 0;

  Object.keys(trustGraph).forEach(k => delete trustGraph[k]);
  simSources.forEach(s => ensureSource(s.name, s.type, s.baseTrust));

  renderAll();
}

startBtn.onclick = startLoop;
pauseBtn.onclick = pauseLoop;
stopBtn.onclick  = stopLoop;
resetBtn.onclick = resetAll;

printBtn.onclick = () => window.print();
</script>
<!-- ======================= PART 3 / 4 =======================
RSS SEARCH (Fetch) + Classification + CSV Export
========================================================== -->
<script>
// ===================== RSS FETCH (CORS-SAFE proxy) =====================
// Note: If the proxy is down, some feeds may fail. Add alternative feeds as needed.
async function fetchText(url){
  const prox = "https://api.allorigins.win/raw?url=" + encodeURIComponent(url);
  const res = await fetch(prox, { cache: "no-store" });
  if (!res.ok) throw new Error("Fetch failed: " + res.status);
  return await res.text();
}

function parseRss(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "text/xml");
  const items = Array.from(xml.querySelectorAll("item"));
  return items.map(it => {
    const title = it.querySelector("title")?.textContent?.trim() || "";
    const link  = it.querySelector("link")?.textContent?.trim() || "";
    const desc  = (it.querySelector("description")?.textContent || "").replace(/<[^>]*>/g," ").trim();
    const pub   = it.querySelector("pubDate")?.textContent?.trim() || "";
    return { title, link, desc, pub };
  });
}

function sourceNameFromFeedUrl(feedUrl){
  try{
    const u = new URL(feedUrl);
    return u.hostname.replace(/^www\./,"");
  }catch{
    return feedUrl.slice(0,50);
  }
}

function typeGuessFromSource(sourceName){
  const s = (sourceName||"").toLowerCase();
  if (s.endsWith(".gov") || s.includes("usgs") || s.includes("noaa") || s.includes("nasa")) return "institutional";
  if (s.includes("bbc") || s.includes("guardian") || s.includes("npr")) return "institutional";
  return "civilian";
}

async function runSearch(){
  const qRaw = (document.getElementById("queryInput").value || "").trim();
  const q = qRaw.toLowerCase();

  const feedLines = document.getElementById("feedsBox").value
    .split("\n").map(x => x.trim()).filter(Boolean);

  if (!q){
    alert("Type a search query first.");
    return;
  }
  if (!feedLines.length){
    alert("Add at least one RSS feed URL.");
    return;
  }

  // NOTE: A “more accurate” distribution needs more samples.
  // This run collects whatever matches across your feeds now.
  const pulled = [];

  for (const feed of feedLines){
    try{
      const xml = await fetchText(feed);
      const items = parseRss(xml);
      const srcName = sourceNameFromFeedUrl(feed);
      const srcType = typeGuessFromSource(srcName);

      const baseTrust =
        srcType === "institutional" ? 0.70 :
        srcType === "civilian" ? 0.52 : 0.35;

      ensureSource(srcName, srcType, baseTrust);

      items.forEach(it => {
        const hay = (it.title + " " + it.desc).toLowerCase();
        if (!hay.includes(q)) return;

        pulled.push({
          kind: "rss",
          time: ++timeTick,
          source: srcName,
          sourceType: srcType,
          baseTrust,
          title: it.title,
          claim: "",
          snippet: it.desc.slice(0, 240),
          link: it.link,
          pubDate: it.pub
        });
      });
    }catch(err){
      const srcName = sourceNameFromFeedUrl(feed);
      ensureSource(srcName, "unknown", 0.42);
      trustGraph[srcName].trust = clamp01(trustGraph[srcName].trust - 0.03);
    }
  }

  if (!pulled.length){
    events.push({
      kind:"note",
      time: ++timeTick,
      source:"system",
      title:"No matches found",
      claim:`Query "${qRaw}" returned 0 matches. Try different keywords or add feeds.`,
      snippet:"",
      result:"Narrative"
    });
    counts.Narrative++;
    renderAll();
    return;
  }

  // Classify
  pulled.forEach(item => {
    const out = classifyItem(item);
    item.result = out.result;
    item.meta = out;
    events.push(item);
    counts[item.result]++;
  });

  // Add summary note
  const v = pulled.filter(x => x.result === "Verified").length;
  const l = pulled.filter(x => x.result === "Likely").length;
  const n = pulled.filter(x => x.result === "Narrative").length;
  const r = pulled.filter(x => x.result === "Rejected").length;

  events.push({
    kind:"note",
    time: ++timeTick,
    source:"system",
    title:"Search summary",
    claim:`Query: "${qRaw}" • Pulled ${pulled.length} matches → Verified ${v}, Likely ${l}, Narrative ${n}, Rejected ${r}.`,
    snippet:"Tip: For more stable confidence, run multiple queries or expand feed list until you have ~20–50 matches on the same topic.",
    result: (v>0 || l>0) ? "Likely" : "Narrative"
  });
  counts[events[events.length-1].result]++;

  renderAll();
}

document.getElementById("searchBtn").onclick = runSearch;

// ===================== CSV EXPORT =====================
csvBtn.addEventListener("click", () => {
  let csv = "time,kind,source,result,title_or_claim,link,pubDate,trust,confidence,lang,quality,tone,corroboration,contradicted\n";
  events.forEach(e => {
    const trust = (trustGraph[e.source]?.trust ?? 0).toFixed(2);
    const m = e.meta || {};
    const title = (e.title || e.claim || "").replaceAll('"','""');
    const link = (e.link || "").replaceAll('"','""');
    const pub  = (e.pubDate || "").replaceAll('"','""');

    csv += `${e.time},${e.kind||""},"${e.source||""}",${e.result||""},"${title}","${link}","${pub}",${trust},${m.confidence??""},${m.lang??""},${m.quality??""},${m.tone??""},${m.corr??""},${m.contrad??""}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "reality_grounded_search_audit.csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
<!-- ======================= PART 4 / 4 =======================
WORKING CHART + RESIZE FIX + FIRST RENDER
========================================================== -->
<script>
const chartCanvas = document.getElementById("signalChart");
const ctx = chartCanvas.getContext("2d");

function getCss(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || "#38bdf8";
}

// Make canvas match CSS box size in real pixels
function fitCanvasToBox(){
  const rect = chartCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  chartCanvas.width  = Math.max(320, Math.floor(rect.width * dpr));
  chartCanvas.height = Math.max(200, Math.floor(rect.height * dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function drawSignalChart(){
  fitCanvasToBox();
  const w = chartCanvas.getBoundingClientRect().width;
  const h = chartCanvas.getBoundingClientRect().height;

  ctx.clearRect(0, 0, w, h);

  const bars = [
    { label:"Verified",  value:counts.Verified,  color:getCss("--good") },
    { label:"Likely",    value:counts.Likely,    color:getCss("--warn") },
    { label:"Narrative", value:counts.Narrative, color:getCss("--mid")  },
    { label:"Rejected",  value:counts.Rejected,  color:getCss("--bad")  }
  ];

  const maxVal = Math.max(...bars.map(b=>b.value), 1);
  const pad = 18;
  const gap = 16;
  const usableW = w - pad*2;
  const barW = Math.max(40, Math.floor((usableW - gap*(bars.length-1))/bars.length));
  const baseY = h - 34;

  // axis
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "rgba(148,163,184,.35)";
  ctx.fillRect(pad, baseY, usableW, 1);
  ctx.globalAlpha = 1;

  bars.forEach((b,i) => {
    const bh = (b.value / maxVal) * (h - 70);
    const x = pad + i*(barW + gap);
    const y = baseY - bh;

    ctx.fillStyle = b.color;
    ctx.fillRect(x, y, barW, bh);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px system-ui";
    ctx.fillText(b.label, x, h - 12);
    ctx.fillText(String(b.value), x + Math.floor(barW*0.35), Math.max(14, y - 6));
  });
}

window.addEventListener("resize", () => drawSignalChart());

// First render
renderAll();
drawSignalChart();
</script>

</body>
</html>
