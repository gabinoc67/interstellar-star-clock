<!-- ======================= PART 1 / 4 =======================
Reality-Grounded Search Engine (FIXED + UPGRADED)
- Reset clears feeds box + query + results
- Search uses ALL keywords (AND), not loose matches
- Clickable “Facts-only Articles” panel (Verified/Likely + thresholds)
- Separates Simulation from Web Search (simulation OFF by default)
- Adds “AI-like text” risk signal (NOT IP detection)
========================================================== -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Reality-Grounded Search — Trust Graph + Falsification</title>

<style>
:root{
  color-scheme: dark;
  --bg:#020617;
  --panel:#0f172a;
  --ink:#e5e7eb;
  --muted:#9ca3af;
  --line:rgba(148,163,184,.25);
  --good:#22c55e;
  --warn:#f59e0b;
  --mid:#38bdf8;
  --bad:#fb7185;
  --radius:16px;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:radial-gradient(circle at top,#020617,#000 70%);
  color:var(--ink);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
}
.wrap{max-width:1500px;margin:18px auto;padding:14px}
h1{margin:0 0 6px;font-size:22px}
.sub{color:var(--muted);font-size:13px;max-width:1200px;line-height:1.35}

.grid{
  display:grid;
  grid-template-columns:460px 1fr;
  gap:14px;
}
@media(max-width:1150px){ .grid{grid-template-columns:1fr} }

.card{
  background:linear-gradient(180deg,var(--panel),#020617);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:12px;
}
.card h2{margin:0 0 10px;font-size:15px}
hr{border:none;border-top:1px solid var(--line);margin:12px 0}

button, input, textarea, select{
  border-radius:12px;
  border:1px solid var(--line);
  background:#020617;
  color:var(--ink);
  font-weight:800;
}
button{padding:9px 12px;cursor:pointer}
button.primary{border-color:var(--mid);background:rgba(56,189,248,.10)}
button.warn{border-color:var(--warn)}
button.bad{border-color:var(--bad)}
button.good{border-color:var(--good)}
button:disabled{opacity:.55;cursor:not-allowed}

.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.small{font-size:12px;color:var(--muted);line-height:1.35}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;border:1px solid var(--line);padding:2px 6px;border-radius:8px;color:var(--ink);background:rgba(255,255,255,.03)}
label{font-size:12px;color:var(--muted);font-weight:800}
.check{display:flex;gap:8px;align-items:center}
.check input{width:18px;height:18px}
input[type="range"]{width:220px}

table{width:100%;border-collapse:collapse;font-size:12px}
th,td{padding:6px;border-bottom:1px solid var(--line);text-align:left;vertical-align:top}
th{color:#cbd5e1;font-weight:900}

.tag{
  display:inline-block;
  padding:3px 8px;
  border-radius:999px;
  font-size:11px;
  border:1px solid var(--line);
  margin-right:6px;
}
.goodTag{border-color:var(--good);color:#bbf7d0}
.warnTag{border-color:var(--warn);color:#fde68a}
.midTag{border-color:var(--mid);color:#bae6fd}
.badTag{border-color:var(--bad);color:#fecdd3}

.canvasWrap{margin-top:8px}
canvas{width:100%;height:260px;border-radius:12px;border:1px solid var(--line);background:rgba(0,0,0,.15)}

textarea{
  width:100%;
  min-height:120px;
  padding:10px;
  font-weight:700;
  font-size:12px;
  line-height:1.35;
  resize:vertical;
}
input[type="text"]{
  padding:10px 12px;
  font-weight:900;
  width:min(560px,100%);
}

.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border:1px solid var(--line);border-radius:12px;
  background:rgba(255,255,255,.03);
}
.meter{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;color:#cbd5e1}

a{color:#93c5fd;text-decoration:none}
a:hover{text-decoration:underline}

.printOnly{display:none}
@media print{
  body{background:#fff;color:#000}
  .wrap{max-width:none}
  .noPrint{display:none !important}
  .printOnly{display:block}
  .card{background:#fff;border-color:#bbb}
  table{font-size:11px}
  th,td{border-bottom:1px solid #ccc}
  a{color:#000;text-decoration:underline}
}
</style>
</head>

<body>
<div class="wrap">
  <h1>Reality-Grounded Search Engine</h1>
  <div class="sub">
    This tool does <b>not</b> block IP addresses. It ranks sources and articles using: provenance (+/– points),
    corroboration, contradiction penalties, writing quality, and an <b>AI-like text risk signal</b>.
    <b>Important:</b> “AI-like” here is a writing-pattern heuristic (not true IP tracing).
  </div>

  <!-- CONTROLS -->
  <div class="row noPrint" style="margin:12px 0">
    <button class="primary" id="startBtn">Start Simulation</button>
    <button id="pauseBtn">Pause</button>
    <button class="warn" id="stopBtn">Stop</button>
    <button class="bad" id="resetBtn">Reset</button>
    <button id="printBtn">Print Report</button>
    <button id="csvBtn">Export CSV</button>
  </div>

  <div class="grid">

    <!-- LEFT -->
    <div class="card">
      <h2>Web Search (RSS) — Facts-First Output</h2>
      <div class="small">
        Type multiple keywords. The search requires <b>ALL</b> keywords to appear (AND matching).
        Example: <span class="kbd">flood houston highway</span>
        <br/>If you want exact phrases, use quotes: <span class="kbd">"power outage" houston</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="queryInput" type="text" placeholder='Search keywords (e.g., "power outage" houston)' />
        <button class="good" id="searchBtn">Search Feeds</button>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="check badge" title="Shows only Verified/Likely items in the tables below (facts-first).">
          <input id="factsOnlyToggle" type="checkbox" checked />
          <label for="factsOnlyToggle" style="margin:0;color:var(--ink)">Only show Verified + Likely</label>
        </div>

        <div class="badge" title="Hide items from sources below this trust score.">
          <label for="minTrust" style="margin:0">Min trust</label>
          <input id="minTrust" type="range" min="0" max="1" step="0.01" value="0.55" />
          <span class="meter" id="minTrustLabel">0.55</span>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="badge" title="Penalize articles that look strongly AI-generated (generic repetitive phrasing, uniform structure).">
          <label for="maxAi" style="margin:0">Max AI-like risk</label>
          <input id="maxAi" type="range" min="0" max="1" step="0.01" value="0.70" />
          <span class="meter" id="maxAiLabel">0.70</span>
        </div>

        <div class="check badge" title="If OFF, web search results stay clean (no simulation noise). Recommended OFF.">
          <input id="includeSimToggle" type="checkbox" />
          <label for="includeSimToggle" style="margin:0;color:var(--ink)">Include Simulation items in lists</label>
        </div>
      </div>

      <hr/>

      <h2>Facts-only Articles (click to read)</h2>
      <div class="small">
        This panel shows a clickable list filtered by:
        Verified/Likely + Min trust + Max AI-like risk.
      </div>
      <table style="margin-top:10px">
        <thead>
          <tr>
            <th>Result</th>
            <th>Article</th>
            <th>Source</th>
          </tr>
        </thead>
        <tbody id="factsTable"></tbody>
      </table>

      <hr/>

      <h2>RSS feeds (one per line)</h2>
      <div class="small">
        Reset will restore this list to defaults.
      </div>
      <textarea id="feedsBox"></textarea>

      <hr/>

      <h2>Trust Graph (Sources)</h2>
      <table style="margin-top:10px">
        <thead><tr><th>Source</th><th>Trust</th></tr></thead>
        <tbody id="trustTable"></tbody>
      </table>
    </div>

    <!-- RIGHT -->
    <div>
      <div class="card">
        <h2>Reality Signal Distribution</h2>
        <div class="small">
          Bar chart of all classifications ingested in the session (RSS + simulation). Filtering affects the tables, not counts.
        </div>
        <div class="canvasWrap">
          <canvas id="signalChart"></canvas>
        </div>
      </div>

      <div class="card" style="margin-top:14px">
        <h2>Articles / Events (clickable)</h2>
        <div class="small">
          This table respects your filters (facts-only + trust threshold + AI-risk cap).
        </div>
        <table style="margin-top:10px">
          <thead>
            <tr>
              <th>Time</th>
              <th>Title / Claim</th>
              <th>Source</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="eventTable"></tbody>
        </table>

        <div class="printOnly" style="margin-top:12px">
          <b>Printed Audit</b>: Shows classifications + scores at print time.
        </div>
      </div>
    </div>

  </div>
</div>
<!-- ======================= PART 2 / 4 =======================
Core State + Scoring (spelling/grammar + AI-like signal)
========================================================== -->
<script>
// ===================== GLOBAL STATE =====================
let timeTick = 0;
let running = false;
let timer = null;

const trustGraph = Object.create(null);
const events = []; // rss + sim + notes
const counts = { Verified:0, Likely:0, Narrative:0, Rejected:0 };

// ===================== DEFAULT FEEDS =====================
const DEFAULT_FEEDS = [
  "https://feeds.bbci.co.uk/news/world/rss.xml",
  "https://www.theguardian.com/world/rss",
  "https://feeds.npr.org/1004/rss.xml",
  "https://www.usgs.gov/feeds/earthquakes/feed",
  "https://www.noaa.gov/rss.xml",
  "https://www.nasa.gov/rss/dyn/breaking_news.rss"
];

// Seed the feed box
const feedsBox = document.getElementById("feedsBox");
feedsBox.value = DEFAULT_FEEDS.join("\n");

// ===================== UI CONTROLS =====================
const factsOnlyToggle = document.getElementById("factsOnlyToggle");
const minTrust = document.getElementById("minTrust");
const minTrustLabel = document.getElementById("minTrustLabel");
const maxAi = document.getElementById("maxAi");
const maxAiLabel = document.getElementById("maxAiLabel");
const includeSimToggle = document.getElementById("includeSimToggle");
const queryInput = document.getElementById("queryInput");

function syncSliders(){
  minTrustLabel.textContent = Number(minTrust.value).toFixed(2);
  maxAiLabel.textContent = Number(maxAi.value).toFixed(2);
}
syncSliders();

minTrust.oninput = () => { syncSliders(); renderAll(); };
maxAi.oninput = () => { syncSliders(); renderAll(); };
factsOnlyToggle.onchange = () => renderAll();
includeSimToggle.onchange = () => renderAll();

// ===================== SIMULATION SOURCES (ONLY if you press Start Simulation) =====================
const simSources = [
  { name: "Gov Infrastructure Feed", type: "institutional", baseTrust: 0.72 },
  { name: "Major News Outlet", type: "institutional", baseTrust: 0.62 },
  { name: "Utility Operator Bulletin", type: "institutional", baseTrust: 0.78 },
  { name: "Independent Research Blog", type: "civilian", baseTrust: 0.42 },
  { name: "Civilian Eyewitness Post", type: "civilian", baseTrust: 0.36 },
  { name: "Bot Content Farm", type: "noise", baseTrust: 0.15 }
];
const simClaims = [
  "Building destroyed",
  "Power grid instability",
  "Explosion reported",
  "Flooding in urban area",
  "Infrastructure disruption",
  "Fire reported near facility"
];

// ===================== UTILS =====================
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function rand(min,max){ return min + Math.random()*(max-min); }

function ensureSource(sourceKey, typeHint="unknown", baseTrust=0.45){
  if (!trustGraph[sourceKey]){
    trustGraph[sourceKey] = {
      trust: baseTrust,
      contradictions: 0,
      confirmations: 0,
      type: typeHint
    };
  }
}

// Initialize sim sources into trust graph (fine even if simulation never used)
simSources.forEach(s => ensureSource(s.name, s.type, s.baseTrust));

function escapeHtml(s){
  return (s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function tokenize(s){
  return (s||"")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g," ")
    .split(/\s+/)
    .filter(x => x.length >= 3);
}

function overlapCount(a,b){
  const setB = new Set(b);
  let c = 0;
  a.forEach(x => { if (setB.has(x)) c++; });
  return c;
}

// ===================== WRITING QUALITY SIGNAL (misspelling/grammar proxy) =====================
function writingQualityScore(text, sourceType){
  const t = (text||"").trim();
  if (!t) return 0.55;

  const len = t.length;
  const letters = (t.match(/[A-Za-z]/g)||[]).length;
  const digits = (t.match(/[0-9]/g)||[]).length;
  const spaces = (t.match(/\s/g)||[]).length;
  const punct  = Math.max(0, len - letters - digits - spaces);

  const nonLetterRatio = len ? (punct / len) : 0;
  const allCapsWords = (t.match(/\b[A-Z]{4,}\b/g)||[]).length;
  const multiPunct = (t.match(/([!?.,])\1{2,}/g)||[]).length;
  const stretched = (t.match(/([a-zA-Z])\1{3,}/g)||[]).length;

  const words = t.split(/\s+/).filter(Boolean);
  let weird = 0;
  for (const w of words){
    const w2 = w.replace(/[^A-Za-z]/g,"");
    if (w2.length >= 18) weird++;
    if (/[bcdfghjklmnpqrstvwxz]{6,}/i.test(w2)) weird++;
  }

  let base = 0.62;
  if (sourceType === "institutional") base = 0.78;
  if (sourceType === "civilian") base = 0.60;
  if (sourceType === "noise") base = 0.30;

  let penalty = 0;
  penalty += Math.min(0.35, nonLetterRatio * 0.9);
  penalty += Math.min(0.18, allCapsWords * 0.03);
  penalty += Math.min(0.18, multiPunct * 0.06);
  penalty += Math.min(0.18, stretched * 0.05);
  penalty += Math.min(0.22, weird * 0.02);

  return clamp01(base - penalty + rand(-0.02, 0.02));
}

// ===================== AI-LIKE TEXT RISK (heuristic, NOT IP) =====================
// Looks for: generic filler phrases, repetition, overly even structure, “template voice”
function aiLikeRiskScore(text){
  const t = (text||"").toLowerCase();
  if (!t.trim()) return 0.25;

  const phrases = [
    "in today’s world","it is important to note","this article explores",
    "delve into","moreover","furthermore","additionally","as an ai",
    "overall","in conclusion","key takeaway","unlock","game-changer"
  ];
  let hits = 0;
  for (const p of phrases) if (t.includes(p)) hits++;

  // repetition: repeated 3+ word sequences (rough)
  const tokens = tokenize(t);
  let rep = 0;
  const seen = new Map();
  for (let i=0;i<tokens.length-2;i++){
    const tri = tokens[i]+" "+tokens[i+1]+" "+tokens[i+2];
    seen.set(tri, (seen.get(tri)||0)+1);
  }
  for (const v of seen.values()) if (v >= 2) rep++;

  // very long generic paragraphs penalty
  const avgWordLen = tokens.length ? (tokens.join("").length / tokens.length) : 5;
  const tooGeneric = (hits >= 2) ? 0.18 : 0;
  const repPenalty = Math.min(0.30, rep * 0.03);
  const lenPenalty = (tokens.length > 220) ? 0.10 : 0;

  // baseline risk
  let risk = 0.28 + tooGeneric + repPenalty + lenPenalty;

  // odd “perfect smoothness”: low punctuation and high length can be templated
  const punctCount = (t.match(/[.!?]/g)||[]).length;
  if (tokens.length > 160 && punctCount < 6) risk += 0.10;

  // clamp to 0..1
  return clamp01(risk);
}

// ===================== OTHER SIGNALS =====================
function toneScore(text, sourceType){
  const t = (text||"").toLowerCase();
  const sensational = [
    "shocking","insane","unbelievable","100%","guaranteed","secret",
    "they don't want you to know","hoax","proof!!!","wake up"
  ];
  let penalty = 0;
  sensational.forEach(w => { if (t.includes(w)) penalty += 0.08; });

  let base = 0.58;
  if (sourceType === "institutional") base = 0.74;
  if (sourceType === "civilian") base = 0.62;
  if (sourceType === "noise") base = 0.28;

  return clamp01(base - penalty + rand(-0.02, 0.02));
}

function corroborationScore(sourceKey, text){
  const recent = events.slice(-35);
  const tokens = tokenize(text).slice(0, 18);
  if (!tokens.length) return 0;

  let hits = 0;
  recent.forEach(e => {
    if (e.source === sourceKey) return;
    if (e.result === "Rejected") return;
    const t2 = tokenize((e.claim||"") + " " + (e.title||"") + " " + (e.snippet||""));
    const overlap = overlapCount(tokens, t2);
    if (overlap >= 3) hits++;
  });

  return Math.min(hits / 3, 1);
}

function contradictionHit(text){
  const t = (text||"").toLowerCase();
  const neg = [
    "no damage","false alarm","debunked","did not happen","hoax",
    "misleading","incorrect report","retracted","not true","fabricated"
  ];
  for (const w of neg){ if (t.includes(w)) return true; }
  return false;
}

// ===================== CLASSIFICATION =====================
function classifyItem(item){
  ensureSource(item.source, item.sourceType || "unknown", item.baseTrust ?? 0.45);
  const node = trustGraph[item.source];

  const text = (item.claim||"") + " " + (item.title||"") + " " + (item.snippet||"");
  const trust = node.trust;

  const quality = writingQualityScore(text, node.type);
  const tone = toneScore(text, node.type);
  const corr = corroborationScore(item.source, text);
  const contrad = contradictionHit(text);

  const aiRisk = aiLikeRiskScore(text);

  // Language score: quality + tone, then penalize by AI-risk
  const langRaw = clamp01(0.60*quality + 0.40*tone);
  const lang = clamp01(langRaw - (aiRisk * 0.20));

  // confidence
  const confidence = (0.46 * trust) + (0.32 * lang) + (0.22 * corr);

  let result = "Narrative";

  if (contrad){
    result = "Rejected";
    node.trust = clamp01(node.trust - 0.11);
    node.contradictions++;
  } else {
    if (confidence >= 0.80 && corr >= 0.66 && aiRisk <= 0.75){
      result = "Verified";
      node.trust = clamp01(node.trust + 0.04);
      node.confirmations++;
    } else if (confidence >= 0.60){
      result = "Likely";
      node.trust = clamp01(node.trust + 0.02);
      if (corr > 0.33) node.confirmations++;
    } else {
      result = "Narrative";
      node.trust = clamp01(node.trust - 0.01);
    }
  }

  return { result, confidence, trust: node.trust, lang, quality, tone, corr, contrad, aiRisk };
}

// ===================== SIMULATION (ONLY when you press Start Simulation) =====================
function generateSimEvent(){
  const src = simSources[Math.floor(Math.random()*simSources.length)];
  const claim = simClaims[Math.floor(Math.random()*simClaims.length)];

  const item = {
    kind: "sim",
    time: timeTick,
    source: src.name,
    sourceType: src.type,
    baseTrust: src.baseTrust,
    claim: claim,
    title: "",
    snippet: "",
    link: ""
  };

  const out = classifyItem(item);
  item.result = out.result;
  item.meta = out;

  events.push(item);
  counts[item.result]++;
  renderAll();
}

// ===================== CONTROLS =====================
const startBtn = document.getElementById("startBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn  = document.getElementById("stopBtn");
const resetBtn = document.getElementById("resetBtn");
const csvBtn   = document.getElementById("csvBtn");
const printBtn = document.getElementById("printBtn");

function startLoop(){
  if (running) return;
  running = true;
  timer = setInterval(() => {
    timeTick++;
    generateSimEvent();
  }, 900);
}
function pauseLoop(){ running = false; clearInterval(timer); timer = null; }
function stopLoop(){ pauseLoop(); }

// RESET FIX: clears feeds + query + tables + counts + events
function resetAll(){
  stopLoop();
  timeTick = 0;
  events.length = 0;
  counts.Verified = counts.Likely = counts.Narrative = counts.Rejected = 0;

  // Restore default feeds + clear query
  feedsBox.value = DEFAULT_FEEDS.join("\n");
  queryInput.value = "";

  // Reset trust graph
  Object.keys(trustGraph).forEach(k => delete trustGraph[k]);
  simSources.forEach(s => ensureSource(s.name, s.type, s.baseTrust));

  renderAll();
}

startBtn.onclick = startLoop;
pauseBtn.onclick = pauseLoop;
stopBtn.onclick  = stopLoop;
resetBtn.onclick = resetAll;

printBtn.onclick = () => window.print();

// ===================== RENDER HELPERS =====================
function resultTag(r){
  const cls =
    r === "Verified" ? "goodTag" :
    r === "Likely" ? "warnTag" :
    r === "Rejected" ? "badTag" : "midTag";
  return `<span class="tag ${cls}">${r}</span>`;
}

// Filtering logic for tables
function passesFilters(e){
  const factsOnly = factsOnlyToggle.checked;
  const minT = Number(minTrust.value);
  const maxAiT = Number(maxAi.value);
  const includeSim = includeSimToggle.checked;

  // Hide simulation items unless user opts in
  if (!includeSim && e.kind === "sim") return false;

  const t = trustGraph[e.source]?.trust ?? 0;
  if (t < minT) return false;

  const ai = e.meta?.aiRisk ?? 0.0;
  if (ai > maxAiT) return false;

  if (!factsOnly) return true;
  return (e.result === "Verified" || e.result === "Likely");
}

function renderFactsPanel(){
  const tbody = document.getElementById("factsTable");
  tbody.innerHTML = "";

  const items = events
    .filter(e => e.kind === "rss" && passesFilters(e))
    .slice()
    .sort((a,b) => (b.meta?.confidence||0) - (a.meta?.confidence||0))
    .slice(0, 25);

  if (!items.length){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="3" class="small">No facts-only articles yet. Run a search, or lower filters.</td>`;
    tbody.appendChild(tr);
    return;
  }

  items.forEach(e => {
    const tr = document.createElement("tr");
    const title = e.title || "(no title)";
    const href = e.link || "";
    tr.innerHTML = `
      <td>${resultTag(e.result)}</td>
      <td>
        ${href ? `<a href="${escapeHtml(href)}" target="_blank" rel="noopener">${escapeHtml(title)}</a>` : escapeHtml(title)}
        <div class="small">conf ${(e.meta?.confidence||0).toFixed(2)} • lang ${(e.meta?.lang||0).toFixed(2)} • ai ${(e.meta?.aiRisk||0).toFixed(2)} • corr ${(e.meta?.corr||0).toFixed(2)}</div>
      </td>
      <td>${escapeHtml(e.source)}</td>
    `;
    tbody.appendChild(tr);
  });
}

function renderEventTable(){
  const tbody = document.getElementById("eventTable");
  tbody.innerHTML = "";

  const list = events.slice().reverse().filter(passesFilters).slice(0, 50);

  if (!list.length){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="small">No matching items. Run Search Feeds, or lower filters.</td>`;
    tbody.appendChild(tr);
    return;
  }

  list.forEach(e => {
    const tr = document.createElement("tr");
    const title = e.title || e.claim || "(no title)";
    const tScore = (trustGraph[e.source]?.trust ?? 0).toFixed(2);
    const m = e.meta || {};
    const metaLine = `trust ${tScore} • conf ${(m.confidence||0).toFixed(2)} • lang ${(m.lang||0).toFixed(2)} • ai ${(m.aiRisk||0).toFixed(2)} • corr ${(m.corr||0).toFixed(2)}`;

    tr.innerHTML = `
      <td>${e.time}</td>
      <td>
        <div style="font-weight:900">
          ${e.link ? `<a href="${escapeHtml(e.link)}" target="_blank" rel="noopener">${escapeHtml(title)}</a>` : escapeHtml(title)}
        </div>
        ${e.pubDate ? `<div class="small">pub: ${escapeHtml(e.pubDate)}</div>` : ``}
        ${e.snippet ? `<div class="small">${escapeHtml(e.snippet)}</div>` : ``}
        <div class="small">${escapeHtml(metaLine)}</div>
      </td>
      <td>${escapeHtml(e.source)}</td>
      <td>${resultTag(e.result)}</td>
    `;
    tbody.appendChild(tr);
  });
}

function renderTrustTable(){
  const tbody = document.getElementById("trustTable");
  tbody.innerHTML = "";

  Object.entries(trustGraph)
    .sort((a,b) => b[1].trust - a[1].trust)
    .slice(0, 60)
    .forEach(([name,data]) => {
      const trend =
        data.trust >= 0.70 ? "goodTag" :
        data.trust >= 0.42 ? "warnTag" : "badTag";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(name)}</td>
        <td>
          <span class="tag ${trend}">${data.trust.toFixed(2)}</span>
          <div class="small">✓ ${data.confirmations} &nbsp;|&nbsp; ✗ ${data.contradictions}</div>
        </td>
      `;
      tbody.appendChild(tr);
    });
}

function renderAll(){
  renderFactsPanel();
  renderEventTable();
  renderTrustTable();
  drawSignalChart();
}
</script>
<!-- ======================= PART 3 / 4 =======================
RSS SEARCH (AND-keywords) + Clickable articles
========================================================== -->
<script>
// ===================== RSS FETCH (CORS proxy) =====================
// Note: Proxy availability can vary; you can swap proxies if needed.
async function fetchText(url){
  const prox = "https://api.allorigins.win/raw?url=" + encodeURIComponent(url);
  const res = await fetch(prox, { cache: "no-store" });
  if (!res.ok) throw new Error("Fetch failed: " + res.status);
  return await res.text();
}

function parseRss(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "text/xml");
  const items = Array.from(xml.querySelectorAll("item"));
  return items.map(it => {
    const title = it.querySelector("title")?.textContent?.trim() || "";
    const link  = it.querySelector("link")?.textContent?.trim() || "";
    const desc  = (it.querySelector("description")?.textContent || "").replace(/<[^>]*>/g," ").trim();
    const pub   = it.querySelector("pubDate")?.textContent?.trim() || "";
    return { title, link, desc, pub };
  });
}

function sourceNameFromFeedUrl(feedUrl){
  try{
    const u = new URL(feedUrl);
    return u.hostname.replace(/^www\./,"");
  }catch{
    return feedUrl.slice(0,50);
  }
}

function typeGuessFromSource(sourceName){
  const s = (sourceName||"").toLowerCase();
  if (s.endsWith(".gov") || s.includes("usgs") || s.includes("noaa") || s.includes("nasa")) return "institutional";
  if (s.includes("bbc") || s.includes("guardian") || s.includes("npr")) return "institutional";
  return "civilian";
}

// Parse query into AND-terms, supporting "quoted phrases"
function parseQueryTerms(qRaw){
  const q = (qRaw||"").trim();
  if (!q) return [];
  const terms = [];
  const re = /"([^"]+)"|(\S+)/g;
  let m;
  while ((m = re.exec(q)) !== null){
    const term = (m[1] || m[2] || "").trim().toLowerCase();
    if (term) terms.push(term);
  }
  return terms;
}

// AND-match: all terms must appear in text
function matchesAllTerms(text, terms){
  const hay = (text||"").toLowerCase();
  return terms.every(t => hay.includes(t));
}

async function runSearch(){
  const qRaw = (queryInput.value || "").trim();
  const terms = parseQueryTerms(qRaw);

  const feedLines = feedsBox.value.split("\n").map(x => x.trim()).filter(Boolean);

  if (!terms.length){
    alert("Type keywords first. Example: flood houston highway  OR  \"power outage\" houston");
    return;
  }
  if (!feedLines.length){
    alert("Add at least one RSS feed URL.");
    return;
  }

  const pulled = [];
  const termPreview = terms.join(" + ");

  // Add a note event (so you see what the system searched)
  events.push({
    kind:"note",
    time: ++timeTick,
    source:"system",
    title:`Search started: ${termPreview}`,
    claim:"",
    snippet:"",
    link:"",
    pubDate:"",
    result:"Narrative",
    meta:{ confidence:0.5, lang:0.5, corr:0, aiRisk:0.2 }
  });
  counts.Narrative++;

  for (const feed of feedLines){
    try{
      const xml = await fetchText(feed);
      const items = parseRss(xml);

      const srcName = sourceNameFromFeedUrl(feed);
      const srcType = typeGuessFromSource(srcName);

      const baseTrust =
        srcType === "institutional" ? 0.70 :
        srcType === "civilian" ? 0.52 : 0.35;

      ensureSource(srcName, srcType, baseTrust);

      items.forEach(it => {
        const blob = (it.title + " " + it.desc);
        if (!matchesAllTerms(blob, terms)) return;

        pulled.push({
          kind: "rss",
          time: ++timeTick,
          source: srcName,
          sourceType: srcType,
          baseTrust,
          title: it.title,
          claim: "",
          snippet: it.desc.slice(0, 260),
          link: it.link,
          pubDate: it.pub
        });
      });
    }catch(err){
      const srcName = sourceNameFromFeedUrl(feed);
      ensureSource(srcName, "unknown", 0.42);
      trustGraph[srcName].trust = clamp01(trustGraph[srcName].trust - 0.03);
    }
  }

  if (!pulled.length){
    events.push({
      kind:"note",
      time: ++timeTick,
      source:"system",
      title:"No matches found",
      claim:`No RSS items matched ALL terms: ${termPreview}`,
      snippet:"Try fewer terms, add a location term, or add more feeds.",
      link:"",
      pubDate:"",
      result:"Narrative",
      meta:{ confidence:0.45, lang:0.5, corr:0, aiRisk:0.2 }
    });
    counts.Narrative++;
    renderAll();
    return;
  }

  // Classify pulled items
  pulled.forEach(item => {
    const out = classifyItem(item);
    item.result = out.result;
    item.meta = out;
    events.push(item);
    counts[item.result]++;
  });

  // Summary note
  const v = pulled.filter(x => x.result === "Verified").length;
  const l = pulled.filter(x => x.result === "Likely").length;
  const n = pulled.filter(x => x.result === "Narrative").length;
  const r = pulled.filter(x => x.result === "Rejected").length;

  events.push({
    kind:"note",
    time: ++timeTick,
    source:"system",
    title:"Search summary",
    claim:`Terms: ${termPreview} • Matches: ${pulled.length} → Verified ${v}, Likely ${l}, Narrative ${n}, Rejected ${r}`,
    snippet:"Tip: For more stable confidence, expand feeds or run 2–3 related searches and compare overlap.",
    link:"",
    pubDate:"",
    result: (v>0 || l>0) ? "Likely" : "Narrative",
    meta:{ confidence:0.62, lang:0.65, corr:0.33, aiRisk:0.2 }
  });
  counts[events[events.length-1].result]++;

  renderAll();
}

document.getElementById("searchBtn").onclick = runSearch;

// ===================== CSV EXPORT =====================
csvBtn.addEventListener("click", () => {
  let csv = "time,kind,source,result,title_or_claim,link,pubDate,trust,confidence,lang,quality,tone,corroboration,ai_risk,contradicted\n";
  events.forEach(e => {
    const trust = (trustGraph[e.source]?.trust ?? 0).toFixed(2);
    const m = e.meta || {};
    const title = (e.title || e.claim || "").replaceAll('"','""');
    const link = (e.link || "").replaceAll('"','""');
    const pub  = (e.pubDate || "").replaceAll('"','""');

    csv += `${e.time},${e.kind||""},"${e.source||""}",${e.result||""},"${title}","${link}","${pub}",${trust},${m.confidence??""},${m.lang??""},${m.quality??""},${m.tone??""},${m.corr??""},${m.aiRisk??""},${m.contrad??""}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "reality_grounded_search_audit.csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
<!-- ======================= PART 4 / 4 =======================
WORKING CHART + RESIZE FIX + FIRST RENDER
========================================================== -->
<script>
const chartCanvas = document.getElementById("signalChart");
const ctx = chartCanvas.getContext("2d");

function getCss(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || "#38bdf8";
}

function fitCanvasToBox(){
  const rect = chartCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  chartCanvas.width  = Math.max(320, Math.floor(rect.width * dpr));
  chartCanvas.height = Math.max(200, Math.floor(rect.height * dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function drawSignalChart(){
  fitCanvasToBox();
  const w = chartCanvas.getBoundingClientRect().width;
  const h = chartCanvas.getBoundingClientRect().height;

  ctx.clearRect(0, 0, w, h);

  const bars = [
    { label:"Verified",  value:counts.Verified,  color:getCss("--good") },
    { label:"Likely",    value:counts.Likely,    color:getCss("--warn") },
    { label:"Narrative", value:counts.Narrative, color:getCss("--mid")  },
    { label:"Rejected",  value:counts.Rejected,  color:getCss("--bad")  }
  ];

  const maxVal = Math.max(...bars.map(b=>b.value), 1);
  const pad = 18;
  const gap = 16;
  const usableW = w - pad*2;
  const barW = Math.max(40, Math.floor((usableW - gap*(bars.length-1))/bars.length));
  const baseY = h - 34;

  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "rgba(148,163,184,.35)";
  ctx.fillRect(pad, baseY, usableW, 1);
  ctx.globalAlpha = 1;

  bars.forEach((b,i) => {
    const bh = (b.value / maxVal) * (h - 70);
    const x = pad + i*(barW + gap);
    const y = baseY - bh;

    ctx.fillStyle = b.color;
    ctx.fillRect(x, y, barW, bh);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px system-ui";
    ctx.fillText(b.label, x, h - 12);
    ctx.fillText(String(b.value), x + Math.floor(barW*0.35), Math.max(14, y - 6));
  });
}

window.addEventListener("resize", () => drawSignalChart());

// Initial render
renderAll();
drawSignalChart();
</script>

</body>
</html>
