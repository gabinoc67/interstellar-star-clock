<!-- ======================= PART 1 / 3 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Facts-Only Live RSS Monitor (Audit-Grade)</title>

<style>
:root{
  --bg:#070b14;
  --panel:#0f172a;
  --ink:#e5e7eb;
  --muted:#9aa4c7;
  --accent:#60a5fa;
  --good:#34d399;
  --warn:#fbbf24;
  --bad:#fb7185;
  --line:rgba(148,163,184,.25);
  --radius:16px;
  --mono: ui-monospace, Consolas, monospace;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font-family:system-ui,Segoe UI,Roboto,Arial;
}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
.wrap{max-width:1200px;margin:20px auto;padding:14px}
.card{
  background:var(--panel);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:14px;
  margin-bottom:14px;
}
h1{margin:0 0 8px;font-size:22px}
h3{margin:0 0 10px;font-size:14px;color:var(--muted);letter-spacing:.2px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.grid2{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
@media (max-width:980px){ .grid2{grid-template-columns:1fr} }

input,textarea,select,button{
  background:#020617;
  color:var(--ink);
  border:1px solid var(--line);
  border-radius:10px;
  padding:8px 10px;
}
textarea{min-height:140px;width:100%;font-family:var(--mono)}
button{
  background:linear-gradient(180deg,#60a5fa,#3b82f6);
  color:#020617;
  font-weight:900;
  cursor:pointer;
  border:0;
}
button.secondary{
  background:#111827;
  color:var(--ink);
  border:1px solid var(--line);
}
.small{font-size:12px;color:var(--muted)}
.kpi{
  display:flex;gap:10px;flex-wrap:wrap;margin-top:10px
}
.pill{
  border:1px solid var(--line);
  border-radius:999px;
  padding:6px 10px;
  font-size:12px;
  color:var(--muted);
}
.pill b{color:var(--ink)}
table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
}
th,td{
  border-bottom:1px solid var(--line);
  padding:10px 8px;
  vertical-align:top;
}
th{color:var(--muted);font-size:11px;text-transform:uppercase;letter-spacing:.12em}
.status{
  font-family:var(--mono);
  font-size:12px;
  white-space:pre-wrap;
  color:var(--muted);
}
.tag{
  display:inline-block;
  padding:3px 8px;
  border-radius:999px;
  font-size:11px;
  border:1px solid var(--line);
  margin-right:6px;
}
.good{color:var(--good)}
.warn{color:var(--warn)}
.bad{color:var(--bad)}
.muted{color:var(--muted)}
details{
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
  background:rgba(2,6,23,.35);
}
summary{cursor:pointer;font-weight:800;color:var(--ink)}
hr.sep{border:0;border-top:1px solid var(--line);margin:12px 0}
</style>
</head>

<body>
<div class="wrap">
  <h1>Facts-Only Live RSS Monitor <span class="muted" style="font-size:12px;font-weight:700">(Audit-Grade scoring)</span></h1>

  <div class="grid2">
    <div class="card">
      <div class="row">
        <input id="query" placeholder='EXAMPLE: Minnesota groups ICE   (or #earthquake #tsunami nasa)'
               style="flex:1;min-width:260px"/>
        <select id="mode" title="Direct may fail due to CORS. Proxy is recommended.">
          <option value="proxy">CORS Proxy (recommended)</option>
          <option value="direct">Direct (may fail)</option>
        </select>
      </div>

      <div class="row" style="margin-top:10px">
        <label class="small"><input id="strictAll" type="checkbox" checked/> Require ALL words (strict match)</label>
        <label class="small"><input id="checkMeta" type="checkbox" checked/> Verify meta-tags (proxy)</label>
        <label class="small"><input id="factsOnly" type="checkbox" checked/> Facts-only filter</label>
      </div>

      <div class="row" style="margin-top:10px">
        <label class="small">Min Trust:
          <input id="minTrust" type="number" min="0" max="100" value="80" style="width:90px"/>
        </label>
        <label class="small">Max AI-risk:
          <input id="maxAi" type="number" min="0" max="100" value="45" style="width:90px"/>
        </label>
        <label class="small">Max Results:
          <input id="maxRows" type="number" min="10" max="200" value="60" style="width:90px"/>
        </label>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnStart">Start</button>
        <button id="btnPause" class="secondary">Pause</button>
        <button id="btnStop" class="secondary">Stop</button>
        <button id="btnReset" class="secondary">Reset</button>
      </div>

      <div class="kpi">
        <div class="pill"><b id="kFeeds">0</b> feeds</div>
        <div class="pill"><b id="kFetched">0</b> items fetched</div>
        <div class="pill"><b id="kMatched">0</b> matched</div>
        <div class="pill"><b id="kShown">0</b> shown</div>
      </div>

      <hr class="sep"/>

      <details open>
        <summary>Explain: Why “default feeds” exist (and why you may add more)</summary>
        <div class="small" style="margin-top:10px;line-height:1.55">
          <b>Default feeds</b> are your “known-good baseline.” They matter because a facts-only engine needs at least a few
          publishers that (1) publish consistently, (2) have clear identity, and (3) are accountable (government/science outlets
          or long-lived newsroom orgs). If your feed list is empty or untrusted, the system can’t reliably test
          <i>provenance → consistency → contradictions</i> and you’ll see “No matches.”
          <br/><br/>
          You can (and should) add more feeds—just remember: your scoring is only as strong as the feed sources you provide.
          This monitor ranks results using:
          <br/>
          <span class="tag">Relevance</span> strict keyword/hashtag matching
          <span class="tag">Trust</span> domain baseline score
          <span class="tag">Quality</span> misspell/grammar penalties
          <span class="tag">AI-risk</span> “AI-like” wording heuristics
          <span class="tag">Meta verify</span> checks article meta tags (when accessible via proxy)
          <br/><br/>
          <b>About IP scoring:</b> browsers usually can’t see real origin IPs (CDNs/proxies hide them, CORS blocks headers).
          So we score by <b>domain identity + evidence signals</b>. If you later run this in a server (Node/Python),
          you can add real IP/DNS/ASN reputation safely.
        </div>
      </details>
    </div>

    <div class="card">
      <h3>RSS Feeds (one per line)</h3>
      <textarea id="feeds"></textarea>
      <div class="small" style="margin-top:8px;line-height:1.55">
        Tip: add official sources (gov/science/major newsrooms) first.
        Avoid “random aggregator” feeds unless you lower trust and manually verify.
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Articles (live)</h3>
    <table>
      <thead>
        <tr>
          <th>Status</th>
          <th>Score</th>
          <th>Article</th>
          <th>Source</th>
          <th>Signals</th>
        </tr>
      </thead>
      <tbody id="results">
        <tr><td colspan="5" class="muted">Waiting…</td></tr>
      </tbody>
    </table>
  </div>

  <div class="card status" id="status">Idle.</div>
</div>
<!-- ======================= PART 2 / 3 ======================= -->
<script>
/* ========= DEFAULT FEEDS (baseline) =========
   You can add more. These are stable/public and usually higher-accountability. */
const DEFAULT_FEEDS = [
  // Science / official monitoring
  "https://www.usgs.gov/feeds/earthquakes/feed",
  "https://www.noaa.gov/rss.xml",
  "https://www.nasa.gov/rss/dyn/breaking_news.rss",
  "https://www.cdc.gov/media/rss.htm",
  "https://www.fema.gov/feeds/rss.xml",
  // Major public newsrooms
  "https://feeds.bbci.co.uk/news/world/rss.xml",
  "https://feeds.npr.org/1004/rss.xml",
  // International orgs
  "https://www.who.int/feeds/entity/csr/don/en/rss.xml",
  "https://news.un.org/feed/subscribe/en/news/all/rss.xml"
].join("\n");

/* ========= TRUST BASELINE (domain → score) =========
   You can tune these. Unknown domains default to 50. */
const TRUST = {
  "usgs.gov":95,
  "noaa.gov":95,
  "nasa.gov":95,
  "cdc.gov":92,
  "fema.gov":92,
  "who.int":90,
  "news.un.org":88,
  "bbc.co.uk":85,
  "npr.org":85
};

let timer = null;
let paused = false;
let cycleNo = 0;

const $ = id => document.getElementById(id);
function setStatus(t){ $("status").textContent = t; }
function norm(s){ return (s||"").toLowerCase(); }

function hostFromUrl(u){
  try{ return new URL(u).hostname.replace(/^www\./,""); }catch{ return ""; }
}
function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

/* ========= KEYWORD PARSING =========
   Words: Minnesota groups ICE
   Hashtags: #tsunami #earthquake
*/
function parseKeys(q){
  const raw = (q||"").trim();
  if(!raw) return {words:[], tags:[]};
  const parts = raw.split(/\s+/).filter(Boolean);
  const words = [];
  const tags = [];
  for(const p of parts){
    if(p.startsWith("#") && p.length>1) tags.push(norm(p.slice(1)));
    else words.push(norm(p));
  }
  return {words, tags};
}

function textBlob(item){
  return norm([item.title,item.desc,item.sourceTitle||"",item.link,item.host].join(" "));
}

/* ========= STRICT MATCH =========
   If strictAll checked: ALL words must appear in title+desc+source fields.
   Hashtags match by tag token presence (we search for the tag word too).
*/
function matchesQuery(item, keys, strictAll){
  const blob = textBlob(item);
  if(keys.words.length===0 && keys.tags.length===0) return false;

  const wordHit = w => blob.includes(w);
  const tagHit  = t => blob.includes(t);

  if(strictAll){
    for(const w of keys.words){ if(!wordHit(w)) return false; }
    for(const t of keys.tags){ if(!tagHit(t)) return false; }
    return true;
  }else{
    // loose: any word or tag
    for(const w of keys.words){ if(wordHit(w)) return true; }
    for(const t of keys.tags){ if(tagHit(t)) return true; }
    return false;
  }
}

/* ========= QUALITY HEURISTICS =========
   These are simple (not perfect). Goal: penalize sloppy / botty / AI-ish content.
*/
const AI_PHRASES = [
  "as an ai", "as a language model", "i can't browse", "in conclusion",
  "overall, it is important", "delve into", "a tapestry", "cutting-edge",
  "ever-evolving", "unprecedented", "robust framework", "comprehensive overview"
];

const CLICKBAIT = [
  "shocking", "you won't believe", "secret", "revealed", "miracle",
  "must see", "guaranteed", "insane", "unbelievable"
];

function countSuspiciousPunct(s){
  s = s || "";
  const bangs = (s.match(/!/g)||[]).length;
  const ques  = (s.match(/\?/g)||[]).length;
  const capsWords = (s.match(/\b[A-Z]{5,}\b/g)||[]).length;
  return {bangs, ques, capsWords};
}

/* super-light misspell proxy: repeated letters + no-vowel tokens + long gibberish tokens */
function misspellRisk(text){
  const t = (text||"").replace(/<[^>]*>/g," ").replace(/\s+/g," ").trim();
  if(!t) return 0;
  const tokens = t.split(" ").slice(0,220);

  let weird = 0;
  for(const tok0 of tokens){
    const tok = tok0.replace(/[^a-zA-Z]/g,"");
    if(!tok) continue;
    if(tok.length>=12 && !/[aeiouyAEIOUY]/.test(tok)) weird++;
    if(/([a-zA-Z])\1\1\1/.test(tok)) weird++; // aaaa
    if(tok.length>=18) weird++;
  }
  // scale 0..100
  const ratio = weird / Math.max(1, tokens.length);
  return Math.min(100, Math.round(ratio * 260));
}

/* grammar proxy: too many sentence fragments, too many double spaces, etc */
function grammarRisk(text){
  const t = (text||"").replace(/<[^>]*>/g," ").replace(/\s+/g," ").trim();
  if(!t) return 0;
  const doubleSpace = (t.match(/  +/g)||[]).length;
  const fragments = (t.match(/\b(and|but|so|because)\b/gi)||[]).length > 14 ? 1 : 0;
  const avgLen = t.length / Math.max(1,(t.match(/[.!?]/g)||[]).length);
  let r = 0;
  if(doubleSpace>4) r += 15;
  if(fragments) r += 10;
  if(avgLen>260) r += 15;
  return Math.min(100, r);
}

function aiRisk(text){
  const t = norm((text||"").replace(/<[^>]*>/g," "));
  let r = 0;
  for(const p of AI_PHRASES){ if(t.includes(p)) r += 12; }
  // “style” signals: too many em dashes, too polished + vague
  r += (t.match(/—/g)||[]).length * 4;
  const vague = (t.match(/\b(important|significant|notably|various|numerous|moreover|therefore)\b/g)||[]).length;
  r += Math.min(30, vague * 2);
  return Math.min(100, r);
}

function clickbaitRisk(text){
  const t = norm((text||"").replace(/<[^>]*>/g," "));
  let r = 0;
  for(const p of CLICKBAIT){ if(t.includes(p)) r += 10; }
  const {bangs, capsWords} = countSuspiciousPunct(text||"");
  r += Math.min(30, bangs * 3 + capsWords * 2);
  return Math.min(100, r);
}

/* ========= “FACTS-ONLY” FILTER =========
   Heuristic: prefer items that contain at least one concrete signal:
   numbers, named orgs, places, dates, or official language.
*/
function factsSignal(text){
  const t = (text||"").replace(/<[^>]*>/g," ");
  const hasNum = /\b\d{2,}\b/.test(t);
  const hasDate = /\b(20\d{2}|19\d{2}|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/i.test(t);
  const hasOfficial = /\b(usgs|noaa|nasa|cdc|fema|who|united nations|reuters|associated press|imf)\b/i.test(t);
  const hasLocation = /\b(minnesota|city|county|state|province|utc|km|miles|magnitude)\b/i.test(t);
  const score = (hasNum?1:0) + (hasDate?1:0) + (hasOfficial?1:0) + (hasLocation?1:0);
  return Math.min(100, score * 25);
}

/* ========= SCORING EQUATION =========
   relevance: strict match gate + weighted hits
   trust: domain baseline
   quality: penalize misspell/grammar/clickbait
   ai: penalize ai-like wording
   meta: bonus if meta-tags confirm keywords (when available)
*/
function computeScore(item, keys, meta){
  const trust = TRUST[item.host] ?? 50;

  // relevance weight (more weight for title hits)
  const title = norm(item.title);
  const desc  = norm(item.desc);
  let rel = 0;
  for(const w of keys.words){
    if(title.includes(w)) rel += 6;
    else if(desc.includes(w)) rel += 3;
  }
  for(const t of keys.tags){
    if(title.includes(t)) rel += 5;
    else if(desc.includes(t)) rel += 2;
  }
  rel = Math.min(100, rel * 2); // scale to ~0..100

  const miss = misspellRisk(item.title+" "+item.desc);
  const gram = grammarRisk(item.title+" "+item.desc);
  const cb   = clickbaitRisk(item.title+" "+item.desc);
  const ai   = aiRisk(item.title+" "+item.desc);
  const fact = factsSignal(item.title+" "+item.desc);

  // meta verification bonus (0..12)
  let metaBonus = 0;
  if(meta && meta.hitAll) metaBonus = 12;
  else if(meta && meta.hitAny) metaBonus = 6;

  // penalty/bonus aggregation into a “quality” factor 0..1
  const penalty = (miss*0.35 + gram*0.25 + cb*0.30 + ai*0.25);
  const quality = Math.max(0.10, 1 - (penalty/160)); // keep floor so we still rank

  // facts-only boost gate
  const factsBoost = 0.7 + (fact/100)*0.6; // 0.7..1.3

  // FINAL: (relevance * trust) scaled, times quality, times factsBoost, plus meta bonus
  const raw = (rel/100) * (trust/100);
  const final = (raw * 100) * quality * factsBoost + metaBonus;

  return {
    trust, rel, miss, gram, cb, ai, fact,
    metaBonus,
    final: Math.max(0, Math.round(final * 10) / 10)
  };
}

/* ========= FETCH HELPERS ========= */
async function fetchText(url){
  const mode = $("mode").value;
  const u = mode==="proxy"
    ? "https://api.allorigins.win/raw?url=" + encodeURIComponent(url)
    : url;
  const r = await fetch(u, {cache:"no-store"});
  return await r.text();
}

/* RSS fetch */
async function fetchFeed(feedUrl){
  const xmlText = await fetchText(feedUrl);
  const d = new DOMParser().parseFromString(xmlText,"text/xml");
  const channelTitle = d.querySelector("channel>title")?.textContent || "";
  const items = [...d.querySelectorAll("item")].map(it => ({
    title: it.querySelector("title")?.textContent || "",
    link:  it.querySelector("link")?.textContent || "",
    desc:  it.querySelector("description")?.textContent || "",
    pub:   it.querySelector("pubDate")?.textContent || "",
    sourceTitle: channelTitle
  }));
  return items;
}

/* Meta verify: try to fetch article HTML (proxy recommended). */
function extractMeta(html){
  try{
    const doc = new DOMParser().parseFromString(html,"text/html");
    const meta = {};
    const pick = name => doc.querySelector(`meta[name="${name}"]`)?.content
                      || doc.querySelector(`meta[property="${name}"]`)?.content
                      || "";
    meta.title = (doc.querySelector("title")?.textContent || "").trim();
    meta.description = pick("description") || pick("og:description");
    meta.keywords = pick("keywords");
    meta.ogTitle = pick("og:title");
    meta.ogSite = pick("og:site_name");
    meta.all = norm([meta.title, meta.description, meta.keywords, meta.ogTitle, meta.ogSite].join(" "));
    return meta;
  }catch{ return {all:""}; }
}

function metaHit(metaAll, keys){
  const hitWord = w => metaAll.includes(w);
  let hitAny = false;
  let hitAll = true;

  for(const w of keys.words){
    if(hitWord(w)) hitAny = true;
    else hitAll = false;
  }
  for(const t of keys.tags){
    if(hitWord(t)) hitAny = true;
    else hitAll = false;
  }
  return {hitAny, hitAll};
}
</script>
<!-- ======================= PART 3 / 3 ======================= -->
<script>
async function scoreWithMeta(item, keys){
  if(!$("checkMeta").checked) return {meta:null};

  // Avoid heavy work when direct mode is used (often blocked).
  // We still attempt if proxy.
  if($("mode").value !== "proxy") return {meta:null};

  try{
    const html = await fetchText(item.link);
    const meta = extractMeta(html);
    const hits = metaHit(meta.all || "", keys);
    return {meta:{...hits}};
  }catch{
    return {meta:null};
  }
}

function statusLabel(trust){
  if(trust>=90) return {txt:"Verified", cls:"good"};
  if(trust>=80) return {txt:"Likely", cls:"warn"};
  return {txt:"Unverified", cls:"bad"};
}

function signalBadges(s, meta){
  const out = [];
  out.push(`<span class="tag">Rel ${Math.round(s.rel)}</span>`);
  out.push(`<span class="tag">Trust ${Math.round(s.trust)}</span>`);
  out.push(`<span class="tag">Miss ${Math.round(s.miss)}</span>`);
  out.push(`<span class="tag">Gram ${Math.round(s.gram)}</span>`);
  out.push(`<span class="tag">AI ${Math.round(s.ai)}</span>`);
  out.push(`<span class="tag">Facts ${Math.round(s.fact)}</span>`);
  if(meta){
    out.push(`<span class="tag">${meta.hitAll ? "Meta:ALL" : (meta.hitAny ? "Meta:some" : "Meta:none")}</span>`);
  }else{
    out.push(`<span class="tag muted">Meta:skip</span>`);
  }
  return out.join(" ");
}

async function runCycle(){
  if(paused) return;

  cycleNo++;
  const keys = parseKeys($("query").value);
  const strictAll = $("strictAll").checked;

  const feeds = $("feeds").value.split("\n").map(s=>s.trim()).filter(Boolean);
  $("kFeeds").textContent = String(feeds.length);

  const minTrust = Math.max(0, Math.min(100, +$("minTrust").value || 0));
  const maxAi    = Math.max(0, Math.min(100, +$("maxAi").value || 100));
  const maxRows  = Math.max(10, Math.min(200, +$("maxRows").value || 60));

  let fetched = 0;
  let matched = [];
  let errors = 0;

  // Pull RSS items
  for(const f of feeds){
    try{
      const items = await fetchFeed(f);
      fetched += items.length;

      for(const it of items){
        const h = hostFromUrl(it.link) || hostFromUrl(f) || "";
        const item = {...it, host:h, feed:f};

        // Must match query strictly (ALL words by default)
        if(!matchesQuery(item, keys, strictAll)) continue;

        matched.push(item);
      }
    }catch(e){
      errors++;
    }
  }

  // Meta verify + scoring (limit meta checks for speed)
  // We'll meta-check the first 40 matched items.
  const metaCap = 40;
  const scored = [];
  for(let i=0;i<matched.length;i++){
    const item = matched[i];
    const trust = TRUST[item.host] ?? 50;

    // Optional facts-only gate: must have some facts signal AND not look super-AI-ish.
    const prelimText = item.title+" "+item.desc;
    const fact = factsSignal(prelimText);
    const ai   = aiRisk(prelimText);

    if($("factsOnly").checked){
      if(fact < 25) continue;
    }

    if(trust < minTrust) continue;
    if(ai > maxAi) continue;

    const meta = (i<metaCap) ? (await scoreWithMeta(item, keys)).meta : null;
    const s = computeScore(item, keys, meta);

    // If strictAll is enabled, optionally require meta “hitAny” when meta is available
    if($("checkMeta").checked && meta && strictAll && !meta.hitAny){
      // meta disagrees with the topic; downrank hard (but don’t delete completely)
      s.final = Math.max(0, s.final - 18);
    }

    scored.push({...item, meta, score:s});
  }

  scored.sort((a,b)=>b.score.final - a.score.final);

  // Render
  const tb = $("results");
  const rows = scored.slice(0, maxRows);

  tb.innerHTML = rows.map(r=>{
    const lbl = statusLabel(r.score.trust);
    const safeTitle = escapeHtml(r.title || "(untitled)");
    const safeHost  = escapeHtml(r.host || "");
    const safeFeed  = escapeHtml(hostFromUrl(r.feed) || r.feed);

    return `
      <tr>
        <td class="${lbl.cls}">${lbl.txt}</td>
        <td><b>${r.score.final.toFixed(1)}</b></td>
        <td>
          <a href="${r.link}" target="_blank" rel="noopener">${safeTitle}</a>
          <div class="small muted" style="margin-top:4px">
            ${escapeHtml(r.pub || "")}
          </div>
        </td>
        <td>
          <div><b>${safeHost || "unknown"}</b></div>
          <div class="small muted">feed: ${safeFeed}</div>
        </td>
        <td>${signalBadges(r.score, r.meta)}</td>
      </tr>
    `;
  }).join("") || `<tr><td colspan="5">No matches (try different words or lower filters).</td></tr>`;

  $("kFetched").textContent = String(fetched);
  $("kMatched").textContent = String(matched.length);
  $("kShown").textContent   = String(rows.length);

  setStatus(
`Live cycle: ${cycleNo}
Mode: ${$("mode").value}   StrictAll: ${strictAll}   MetaVerify: ${$("checkMeta").checked}
Query words: [${keys.words.join(", ")}]  tags: [${keys.tags.join(", ")}]
Feeds: ${feeds.length}   Items fetched: ${fetched}   Matched: ${matched.length}   Scored: ${scored.length}
Errors: ${errors}
Notes:
- Browser cannot reliably “score by IP”; using domain + content + meta verification.
- For stronger IP/ASN reputation scoring, run a server-side collector (Node/Python).`
  );
}

$("btnStart").onclick = ()=>{
  if(timer) return;
  paused=false;
  runCycle();
  timer=setInterval(runCycle, 15000);
  setStatus("Started live search.");
};

$("btnPause").onclick = ()=>{
  paused=!paused;
  setStatus(paused ? "Paused." : "Resumed.");
};

$("btnStop").onclick = ()=>{
  clearInterval(timer);
  timer=null;
  setStatus("Stopped.");
};

$("btnReset").onclick = ()=>{
  clearInterval(timer);
  timer=null;
  paused=false;

  $("feeds").value = DEFAULT_FEEDS;
  $("query").value = "";
  $("strictAll").checked = true;
  $("checkMeta").checked = true;
  $("factsOnly").checked = true;
  $("minTrust").value = 80;
  $("maxAi").value = 45;
  $("maxRows").value = 60;

  $("results").innerHTML = `<tr><td colspan="5">Reset complete. Default feeds restored.</td></tr>`;
  $("kFeeds").textContent="0";
  $("kFetched").textContent="0";
  $("kMatched").textContent="0";
  $("kShown").textContent="0";
  setStatus("Reset complete. Default feeds restored.");
};

(function init(){
  $("feeds").value = DEFAULT_FEEDS;
  $("kFeeds").textContent = String($("feeds").value.split("\n").filter(Boolean).length);
})();
</script>

</body>
</html>
