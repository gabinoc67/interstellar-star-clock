<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Warp Control Center ‚Äî Layout Update + Clock Cards + GR Validator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#070b12; --panel:#0c1424; --glass:#0d1a31cc; --edge:#27406b;
    --text:#eaf2ff; --muted:#a7b9df; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
    --ui-scale:1; --fs:16px; --pad:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:
      radial-gradient(1200px 800px at 10% -10%, #112240 0%, transparent 60%),
      radial-gradient(900px 900px at 120% -20%, #0b1b33 0%, transparent 50%),
      var(--bg);
    color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;font-size:var(--fs);
  }
  .viewportScale{transform:scale(var(--ui-scale));transform-origin:top left;width:calc(100%/var(--ui-scale))}
  .wrap{max-width:1350px;margin:0 auto;padding:var(--pad)}
  .glass{background:linear-gradient(180deg,#0b1528aa,#0b152880),radial-gradient(600px 200px at 20% -30%,#15305f55,transparent 60%);backdrop-filter:blur(6px)}
  .panel{border:1px solid var(--edge);border-radius:12px;padding:calc(var(--pad) - 2px);box-shadow:0 12px 28px rgba(0,0,0,.45)}
  h1,h2,h3{margin:.4rem 0}
  .grid{display:grid;gap:10px}

  /* New 3-column with right stack (trajectory + polar map) */
  .rowTop{
    display:grid;
    grid-template-columns:1.05fr 1fr 1.1fr; /* left, center, right */
    gap:10px;
    align-items:start;
  }
  .rightStack{display:grid;gap:10px; grid-template-columns:1fr;} /* stacks trajectory + polar map */
  @media (max-width:1200px){ .rowTop{grid-template-columns:1fr} }

  .controls label{display:flex;align-items:center;gap:8px;margin:6px 0;color:var(--muted);font-size:.95rem}
  select,input[type="number"],input[type="range"]{background:#0b1220;color:#eaf2ff;border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem}
  input[type="range"]{width:200px}
  button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:8px 10px;margin:4px;border-radius:8px;cursor:pointer}
  #startBtn{background:#00ccff;color:#00131a;border:none} #stopBtn{background:#64748b}
  #resetBtn{background:#fb923c;border:none} #exportBtn{background:#7c3aed;border:none}
  .lights{display:flex;gap:8px;flex-wrap:wrap}
  .light{display:flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.88rem}
  .dot{width:10px;height:10px;border-radius:50%}
  .good .dot{background:var(--good)} .warn .dot{background:var(--warn)} .bad .dot{background:var(--bad)}
  .meter{display:flex;align-items:center;gap:8px;margin:4px 0}
  .bar{height:10px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}
  .fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}
  .stat{font-variant-numeric:tabular-nums;font-size:.88rem;color:var(--muted)}
  canvas{background:linear-gradient(180deg,#091323,#0a1322);border:1px solid #2b3a5a;border-radius:10px;max-width:100%}
  .pill{display:inline-block;padding:.1rem .4rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}
  .legend{color:var(--muted);font-size:.88rem;margin-top:6px}
  .hdrline{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .toggle{display:flex;align-items:center;gap:10px;color:#a7b9df;font-size:.9rem}
  .badge{border:1px solid #3b4f77;border-radius:999px;padding:2px 8px;color:#93c5fd;background:#0b1220}
  body.compact{--fs:14px;--pad:8px}
  body.compact input[type="range"]{width:160px}
  body.compact button{padding:6px 8px}

  /* Clock cards */
  .clockGrid{
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:8px;
  }
  @media (max-width:1200px){ .clockGrid{grid-template-columns:repeat(2,1fr)} }
  .clockCard{
    background:#0b1220;border:1px solid #304166;border-radius:12px;padding:8px;
    display:grid;gap:4px; align-content:start;
  }
  .clockHdr{display:flex;justify-content:space-between;align-items:center}
  .clockTitle{font-weight:600}
  .status{font-size:.8rem;border:1px solid #36507d;border-radius:999px;padding:2px 6px}
  .status.good{color:#0f0;border-color:#256f2a} .status.warn{color:#222;background:#facc15} .status.bad{color:#fff;background:#ef4444}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:.86rem;color:#cfe2ff}

  /* GR panel mini grid */
  .kv2{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:.9rem}
</style>
</head>
<body>
<div id="root" class="viewportScale">
  <div class="wrap grid">
    <div class="hdrline">
      <h1>üöÄ Warp Control Center</h1>
      <div class="toggle">
        <label>UI Scale <input id="uiScale" type="range" min="70" max="120" value="95"> <span id="uiScaleVal" class="badge">95%</span></label>
        <label>Compact <input id="compact" type="checkbox" checked></label>
        <label>Engineer Mode <input id="engMode" type="checkbox"></label>
        <label>Sound <input id="soundOn" type="checkbox" checked></label>
        <span class="badge">GV Panel v3.1 + GR</span>
      </div>
    </div>

    <div class="rowTop">
      <!-- LEFT: Flight Plan -->
      <div class="panel glass">
        <h2>Flight Plan</h2>
        <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px">
          <label>Warp Speed
            <select id="warpSpeed"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option></select>
          </label>
          <label>Destination
            <select id="destination"><option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option></select>
          </label>
          <label>Warp Law Exponent (n) <input id="warpExp" type="number" step="0.1" value="3"></label>
          <label>Speed Scale (√óc) <input id="warpScale" type="number" step="0.1" value="1"></label>
          <label>IST Day 0 (years ago) <input id="istDay0Years" type="number" step="1" value="45500000000"></label>
          <label>Baseline Days / IST Year <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25"></label>
        </div>
        <div class="lights">
          <div class="light good" id="lightBubble"><span class="dot"></span>Bubble Stability</div>
          <div class="light good" id="lightPower"><span class="dot"></span>Power Margin</div>
          <div class="light good" id="lightVector"><span class="dot"></span>Vector Balance</div>
          <div class="light good" id="lightNav"><span class="dot"></span>Nav Solution</div>
        </div>
        <div style="margin-top:6px">
          <button id="startBtn">‚ñ∂Ô∏è Start</button>
          <button id="stopBtn">‚è∏Ô∏è Stop</button>
          <button id="resetBtn">üîÑ Engage Warp</button>
          <button id="exportBtn">üìÑ Export Log</button>
        </div>
        <div class="legend" id="beacon">‚è≥ Waiting for start‚Ä¶</div>
      </div>

      <!-- CENTER: Gravity Vectoring Engine -->
      <div class="panel glass">
        <h2>Gravity Vectoring Engine</h2>
        <div class="controls">
          <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
          <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
          <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
          <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
          <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
          <label>Intake Mode
            <select id="intakeMode">
              <option value="balanced">Balanced (¬±)</option>
              <option value="positive">Positive Gravity Capture</option>
              <option value="negative">Negative Gravity Capture</option>
            </select>
          </label>
        </div>
        <h3>Power Allocation</h3>
        <div class="meter"><span class="stat" style="width:140px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
        <div class="meter"><span class="stat" style="width:140px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
        <div class="meter"><span class="stat" style="width:140px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>

        <div id="engPanel" style="display:none;margin-top:8px;border-top:1px solid #2b3a5a;padding-top:8px">
          <h3>Engineer Readouts</h3>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px">
            <div class="stat" id="rdGradient">GradientFactor: ‚Äî</div>
            <div class="stat" id="rdStability">Bubble Stability: ‚Äî</div>
            <div class="stat" id="rdCoilI">Coil Current (arb): ‚Äî</div>
            <div class="stat" id="rdContain">Containment Margin: ‚Äî</div>
            <div class="stat" id="rdWall">Wall Thickness (m est.): ‚Äî</div>
            <div class="stat" id="rdNegE">Neg. Energy Density (J/m¬≥ est.): ‚Äî</div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Trajectory & Polar Map stack -->
      <div class="rightStack">
        <div class="panel glass">
          <h2>Trajectory & Field Vectors</h2>
          <canvas id="curveCanvas"></canvas>
          <div class="legend" id="curveLegend">‚Äî</div>
        </div>
        <div class="panel glass">
          <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
          <canvas id="orbitCanvas"></canvas>
          <div class="legend" id="orbitLegend">‚Äî</div>
        </div>
      </div>
    </div>

    <!-- Orbit Table (kept compact) -->
    <div class="panel glass">
      <h2>IST Orbital Tracker (Live)</h2>
      <div class="legend">Formation offsets (Myr after Day 0): Sun 0; Mercury 5; Venus 30; Earth 27; Mars 10; Jupiter 1; Saturn 3; Uranus 15; Neptune 20; Pluto 30.</div>
      <div id="orbit-rows" class="grid" style="grid-template-columns:repeat(2,1fr);gap:8px"></div>
    </div>

    <!-- Clocks as label cards -->
    <div class="panel glass">
      <h2>Clock Sync (C1‚ÄìC5) + Arrival CST/IST</h2>
      <div class="clockGrid" id="clockGrid"></div>
    </div>

    <!-- Minimal GR Validator (EM ‚Äúmagnetic pressure‚Äù driven) -->
    <div class="panel glass">
      <h2>Minimal GR Validator (Weak-Field, Real-Time)</h2>
      <div class="grid" style="grid-template-columns:1fr 1fr;gap:10px">
        <div class="kv2">
          <div>g<sub>tt</sub> min (1+2Œ¶/c¬≤)</div><div id="gr_gtt">‚Äî</div>
          <div>œÅ<sub>eff</sub> min / max (kg/m¬≥)</div><div id="gr_rho">‚Äî</div>
          <div>Ricci proxy R (1/m¬≤)</div><div id="gr_R">‚Äî</div>
          <div>Kretschmann proxy (1/m‚Å¥)</div><div id="gr_K">‚Äî</div>
          <div>NEC / WEC / SEC</div><div id="gr_ec">‚Äî</div>
          <div>Bubble Horizons</div><div id="gr_hor">‚Äî</div>
        </div>
        <div>
          <canvas id="grCanvas"></canvas>
          <div class="legend">Œ¶ slice across bubble center. Color: blue (‚àí) to red (+). EM field energy supplies curvature.</div>
        </div>
      </div>
      <div style="margin-top:6px">
        <button id="exportGR">üìÑ Export GR Report</button>
      </div>
    </div>

  </div>
</div>

<script>
/* ========= Core constants ========= */
const AU_M=1.495978707e11, C_MPS=299792458, G=6.67430e-11;
const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
const $=id=>document.getElementById(id);

/* ========= Sim state ========= */
let simulationRunning=false, shipProgress=0, shipArrived=false;
let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null;
let tIST0=performance.now();

/* ========= Audio ========= */
let ac=null; function tone(type="good"){ if(!$("soundOn").checked) return;
  if(!ac){ try{ ac=new (window.AudioContext||window.webkitAudioContext)(); }catch{} } if(!ac) return;
  const o=ac.createOscillator(), g=ac.createGain(); const f= type==="good"?880:type==="warn"?520:320;
  o.frequency.value=f; o.type="sine"; g.gain.setValueAtTime(0.001, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.07, ac.currentTime+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+0.18);
  o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+0.2);
}
function setLight(el,level){ const was=el.dataset.level||"good"; if(was!==level){ el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level); tone(level==="good"?"good":level==="warn"?"warn":"bad"); } }

/* ========= IST & Orbits ========= */
function IST_INPUT(){ return Number($("istDay0Years").value||45500000000); }
function DPY_INPUT(){ return Number($("baselineDaysPerYear").value||365.25); }
function IST_snapshot(){ const dpy=DPY_INPUT(), spy=dpy*86400; const elapsed=(performance.now()-tIST0)/1000/spy; const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy; return {istYears, istDays, dpy, spy}; }
function planetAgeYears(name,iy){ return Math.max(0, iy - (formationOffsetMyr[name]||0)*1e6); }
function trueAnomalyFrac(name,iy,dpy){ const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name]; if(!T) return 0; const N=pd/T; return N-Math.floor(N); }
function orbitsFor(name,pd){ const T=orbitalDays[name]; if(!T) return null; const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T; return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T}; }

/* ========= Dynamic engine (thermal/sag/jitter) ========= */
let lastFrameTime=performance.now();
const engineState={ t:0, temp:0, sag:0, containNeed:0.22, jitter:0 };
function stepEngineDynamics(dt, running){
  if(!running){ engineState.temp=Math.max(0,engineState.temp-0.30*dt); engineState.sag=Math.max(0,engineState.sag-0.25*dt); engineState.jitter*=0.85; engineState.containNeed=0.22+0.06*engineState.temp; return; }
  engineState.t+=dt;
  engineState.temp=Math.min(1,engineState.temp+0.06*dt);
  const baseSag=0.02+0.04*engineState.temp, ripple=0.01*Math.sin(0.7*engineState.t);
  engineState.sag=Math.max(0, baseSag + ripple);
  engineState.containNeed=0.22+0.06*engineState.temp;
  const biasMag=Math.hypot(Number($("lrBias").value||0)/100, Number($("udBias").value||0)/100);
  engineState.jitter = 0.01 + 0.03*biasMag + 0.01*Math.sin(3.0*engineState.t) + 0.006*(Math.random()-0.5);
  engineState.jitter = Math.max(0, Math.min(0.08, engineState.jitter));
}

/* ========= Engine + Warp law ========= */
function warpInputs(){ return { warp:Number($("warpSpeed").value||1), exp:Number($("warpExp").value||3), scale:Number($("warpScale").value||1) }; }
function engineInputs(){
  const reactorMW_in=Number($("reactorMW").value||5000);
  const front=Number($("frontPct").value||0)/100, rear=Number($("rearPct").value||0)/100;
  const lr=Number($("lrBias").value||0)/100, ud=Number($("udBias").value||0)/100;
  const mode=$("intakeMode").value;

  const reactorMW = reactorMW_in * (1 - engineState.sag);

  const vecDemand=Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  let coilsPct=Math.max(0.35, 0.55 - 0.25*vecDemand);
  let containPct=Math.max(engineState.containNeed, 0.20);
  let vanesPct=Math.min(0.35, 1 - coilsPct - containPct);
  const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; }

  $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`;
  $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`;
  $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`;

  let stability=1.0;
  if (containPct < engineState.containNeed) stability -= 0.40*(engineState.containNeed - containPct)/engineState.containNeed;
  const biasMag=Math.hypot(lr,ud); stability -= 0.30*Math.max(0, biasMag-0.3)/0.7;
  if (rear<front) stability -= 0.20*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability -= engineState.jitter;
  stability = Math.max(0, Math.min(1, stability));

  const grad=Math.max(0,(rear-front));
  let gradBoost=coilsPct*(0.5+0.5*grad);
  gradBoost *= (1 - 0.20*engineState.temp);
  const gradientFactor = stability * (0.35 + 0.9*gradBoost);

  setLight($("lightBubble"), stability>0.75?"good":stability>0.45?"warn":"bad");
  setLight($("lightPower"), "good");
  setLight($("lightVector"), biasMag<0.6?"good":biasMag<0.85?"warn":"bad");

  if($("engMode").checked){
    $("engPanel").style.display="block";
    const coilI=(coilsPct*reactorMW)*5, wallM=1/(0.25+gradientFactor)*4, containMargin=(containPct-engineState.containNeed)*100, negE=-(gradientFactor*reactorMW)*1.2e3;
    $("rdGradient").textContent=`GradientFactor: ${gradientFactor.toFixed(3)}`;
    $("rdStability").textContent=`Bubble Stability: ${stability.toFixed(3)}`;
    $("rdCoilI").textContent=`Coil Current (arb): ${coilI.toFixed(0)}`;
    $("rdContain").textContent=`Containment Margin: ${containMargin.toFixed(1)}% (need ${(engineState.containNeed*100).toFixed(1)}%)`;
    $("rdWall").textContent=`Wall Thickness (est): ${wallM.toFixed(2)} m`;
    $("rdNegE").textContent=`Neg. Energy Density (est): ${negE.toExponential(3)} J/m¬≥`;
  } else { $("engPanel").style.display="none"; }

  $("frontLbl").textContent=Math.round(front*100)+"%";
  $("rearLbl").textContent =Math.round(rear*100)+"%";
  $("lrLbl").textContent   =Math.round(lr*100)+"%";
  $("udLbl").textContent   =Math.round(ud*100)+"%";

  return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, gradientFactor, stability, mode};
}

/* ========= Travel ETA ========= */
function computeETASeconds(){
  const { istYears, dpy } = IST_snapshot();
  const dest=$("destination").value;
  const { warp, exp, scale } = warpInputs();
  const eng=engineInputs();

  const thE=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;
  const r1=orbitAU.Earth, r2=orbitAU[dest];
  const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD-thE));
  const v=C_MPS*scale*Math.pow(warp,exp)*Math.max(0.05,eng.gradientFactor);
  const eta = (dAU*AU_M)/Math.max(v,1e-3);

  setLight($("lightNav"), isFinite(eta)?(eta<86400?"good":"warn"):"bad");
  return { eta, dAU, v };
}

/* ========= Orbit Table & Polar Map (420√ó420 base) ========= */
const orbitCanvas=$("orbitCanvas"), octx=orbitCanvas.getContext("2d");
const orbitRadiiPx={Mars:110,Jupiter:155,Saturn:195,Pluto:230};
function updateOrbitTable(){
  const {istYears,dpy}=IST_snapshot(); const dest=$("destination").value;
  const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
  const pY=planetAgeYears(dest,istYears), pD=pY*dpy, o=orbitsFor(dest,pD)||{};
  const rows=$("orbit-rows"); rows.innerHTML = `
    <div class="panel" style="background:#0b1220;border:1px solid #304166">
      <div><strong>Sun</strong></div>
      <div class="stat">${(sY/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(sY).toLocaleString()} y ‚Ä¢ ${Math.floor(sD).toLocaleString()} d</div>
    </div>
    <div class="panel" style="background:#0b1220;border:1px solid #304166">
      <div><strong>${dest}</strong></div>
      <div class="stat">${(pY/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(pY).toLocaleString()} y ‚Ä¢ ${Math.floor(pD).toLocaleString()} d</div>
      <div class="stat">Orbits: ${o.completed!=null?o.completed.toLocaleString():"‚Äî"} ‚Üí Curr: ${o.completed!=null?(o.completed+1).toLocaleString():"‚Äî"}</div>
      <div class="stat">Progress: <span class="pill">${o.frac!=null?(o.frac*100).toFixed(2)+"%":"‚Äî"}</span></div>
      <div class="stat">Day: ${o.daysInto!=null?("~"+Math.floor(o.daysInto).toLocaleString()+" / "+Math.floor(o.yearLen).toLocaleString()+" d"):"‚Äî"}</div>
    </div>`;
  drawOrbitView();
}
function drawOrbitView(){
  const {istYears,dpy}=IST_snapshot(); const dest=$("destination").value;
  const w=orbitCanvas.width,h=orbitCanvas.height,cx=w/2,cy=h/2;
  octx.clearRect(0,0,w,h);
  octx.beginPath(); octx.arc(cx,cy,10,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.shadowColor="#ffb703"; octx.shadowBlur=12; octx.fill(); octx.shadowBlur=0;
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun",cx-14,cy-16);
  ["Mars","Jupiter","Saturn","Pluto"].forEach(p=>{
    const r=orbitRadiiPx[p]; octx.beginPath(); octx.arc(cx,cy,r,0,Math.PI*2);
    octx.strokeStyle=p===dest?"#ffffff":"#3c4a6a"; octx.lineWidth=p===dest?2:1; octx.stroke();
    octx.fillStyle="#98a9cc"; octx.fillText(p,cx+r+8,cy-2);
  });
  const fracNow=trueAnomalyFrac(dest,istYears,dpy), thNow=fracNow*Math.PI*2, rPx=orbitRadiiPx[dest]||180;
  const px=cx+rPx*Math.cos(thNow), py=cy+rPx*Math.sin(thNow);
  octx.beginPath(); octx.arc(px,py,5,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.shadowColor="#22d3ee"; octx.shadowBlur=9; octx.fill(); octx.shadowBlur=0;
  octx.beginPath(); octx.moveTo(cx,cy); octx.lineTo(px,py); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();

  const {eta,dAU}=computeETASeconds();
  const T=orbitalDays[dest], dFrac=eta/(T*86400), thArr=(thNow+dFrac*Math.PI*2)%(Math.PI*2);
  const ax=cx+rPx*Math.cos(thArr), ay=cy+rPx*Math.sin(thArr);
  octx.beginPath(); octx.arc(ax,ay,5,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.shadowColor="#22c55e"; octx.shadowBlur=11; octx.fill(); octx.shadowBlur=0;
  octx.beginPath(); octx.moveTo(cx,cy); octx.lineTo(ax,ay); octx.strokeStyle="#22c55e"; octx.lineWidth=1.5; octx.stroke();

  const degNow=(thNow*180/Math.PI+360)%360, degArr=(thArr*180/Math.PI+360)%360; let d=degArr-degNow; if(d<0)d+=360;
  $("orbitLegend").textContent=`${dest} ‚Ä¢ Now: ${degNow.toFixed(2)}¬∞ ‚Ä¢ ETA: ${degArr.toFixed(2)}¬∞ ‚Ä¢ Œî: ${d.toFixed(2)}¬∞ ‚Ä¢ Dist: ${dAU.toFixed(3)} AU`;
}

/* ========= Curve & Vectors ========= */
const curveCanvas=$("curveCanvas"), ctx=curveCanvas.getContext("2d");
function drawCurve(){
  const warp=Number($("warpSpeed").value||1); const eng=engineInputs();
  const arcHeight=90/Math.max(1, warp*(0.8+0.6*eng.stability));
  const startX=90, endX=curveCanvas.width-80, baseY=curveCanvas.height-80;

  ctx.clearRect(0,0,curveCanvas.width,curveCanvas.height);
  const dest=$("destination").value;
  ctx.beginPath(); ctx.arc(startX,baseY,10,0,Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-22, baseY+22);
  ctx.beginPath(); ctx.arc(endX,baseY,9,0,Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(dest, endX-25, baseY+22);

  ctx.beginPath(); ctx.moveTo(startX,baseY);
  ctx.quadraticCurveTo((startX+endX)/2, baseY-arcHeight*3, endX, baseY);
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  const t=shipProgress, mx=(startX+endX)/2, ctrlY=baseY-arcHeight*3;
  const sx=(1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy=(1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;
  ctx.beginPath(); ctx.arc(sx,sy,7,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowColor=ctx.fillStyle; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;

  const arrow=(x,y,dx,dy,color)=>{ const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const ex=x+dx, ey=y+dy;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-6*ux+3*uy,ey-6*uy-3*ux); ctx.lineTo(ex-6*ux-3*uy,ey-6*uy+3*ux); ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  };
  const f=$("frontPct").value/100, r=$("rearPct").value/100, lr=$("lrBias").value/100, ud=$("udBias").value/100;
  const k=Math.min(60, curveCanvas.height*0.18);
  arrow(sx,sy, 0,-k*r,"#22c55e");
  arrow(sx,sy, 0, k*f,"#f97316");
  arrow(sx,sy, k*lr,0,"#8b5cf6");
  arrow(sx,sy, 0,-k*ud,"#38bdf8");

  $("curveLegend").textContent=`Vectors ‚Äî Rear ${Math.round(r*100)}% | Front ${Math.round(f*100)}% | LR ${Math.round(lr*100)}% | UD ${Math.round(ud*100)}%`;
}

/* ========= Clocks as cards ========= */
const clocks=[
  { id:"C1", location:"Biometric Zone", purpose:"Crew/Local Systems", drift:0 },
  { id:"C2", location:"Warp Shell Edge", purpose:"Phase Monitor", drift:3 },
  { id:"C3", location:"AI Core/NavCore", purpose:"Navigation Timing", drift:0 },
  { id:"C4", location:"CST Dome Earth", purpose:"Master Anchor", drift:0 },
  { id:"C5", location:"Mid-Bubble DriftEye", purpose:"Diagnostics", drift:-6 }
];
function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function renderClockCards(eta, arrISTstr, arrCSTms){
  const grid=$("clockGrid"); grid.innerHTML="";
  const base=Date.now(); let total=0;
  clocks.forEach(c=>{
    if(simulationRunning) c.drift += Math.random()*2 - 1;
    const local=base + c.drift; const d=c.drift.toFixed(2); total += Math.abs(c.drift);
    let status="good", label="‚úÖ Synced";
    if(Math.abs(c.drift)>5){status="warn"; label="‚ö†Ô∏è Drift";}
    if(Math.abs(c.drift)>10){status="bad"; label="‚ùå Unsafe";}
    const card=document.createElement("div");
    card.className="clockCard";
    card.innerHTML=`
      <div class="clockHdr">
        <div class="clockTitle">${c.id} ‚Ä¢ ${c.location}</div>
        <div class="status ${status}">${label}</div>
      </div>
      <div class="kv">
        <div>Purpose</div><div>${c.purpose}</div>
        <div>CST</div><div>${fmtClock(base)}</div>
        <div>Local</div><div>${fmtClock(local)}</div>
        <div>Œî</div><div>${d} ms</div>
        <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
        <div>Arrival IST</div><div>${arrISTstr}</div>
      </div>`;
    grid.appendChild(card);
  });
  const avg=total/clocks.length;
  return avg;
}

/* ========= Minimal GR Validator (EM-driven) ========= */
const grCanvas = $("grCanvas"), grx = grCanvas.getContext("2d");
const GR = { nx: 160, ny: 64, L: 1200, sigma: 180, scalePhi: 1.0e10 };
function buildPotentialGrid(){
  // Treat EM magnetic pressure as effective potential shaping (toy). Uses front/rear + biases.
  const eng=engineInputs();
  const front=eng.front, rear=eng.rear, lr=eng.lr, ud=eng.ud;
  const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma;
  const A_r = rear*1.2e14; const A_f = front*1.2e14;
  const x0 = 220 + 120*rear; const y0 =  80*ud; const xskew = 80*lr;

  const phi = new Float64Array(nx*ny);
  for(let j=0;j<ny;j++){
    const y=(j-ny/2)*dy;
    for(let i=0;i<nx;i++){
      const x=(i-nx/2)*dx;
      const rRear2=(x + x0 + xskew)**2 + (y - y0)**2;
      const rFront2=(x - x0 + xskew)**2 + (y + y0)**2;
      phi[i+j*nx] = (-A_r*Math.exp(-rRear2/s2) + A_f*Math.exp(-rFront2/s2))/GR.scalePhi;
    }
  }
  return {phi, dx, dy};
}
function laplacian(phi,i,j,nx,ny,dx,dy){
  const idx=i+j*nx, c=phi[idx];
  const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx];
  const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx];
  return (l-2*c+r)/(dx*dx)+(u-2*c+d)/(dy*dy);
}
function grad2(phi,i,j,nx,ny,dx,dy){
  const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx];
  const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx];
  const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy};
}
function validateGR(){
  const {phi, dx, dy} = buildPotentialGrid();
  const nx=GR.nx, ny=GR.ny, fourPiG = 4*Math.PI*G;
  let gttMin=+1, rhoMin=+1e99, rhoMax=-1e99, Rsum=0, Ksum=0, violNEC=false, violWEC=false, violSEC=false, horizons=0;

  // draw center strip
  const w=Math.max(320, Math.floor(nx*2)), h=120; grCanvas.width=w; grCanvas.height=h;
  grx.clearRect(0,0,w,h);
  let phiMin=+1e99, phiMax=-1e99; for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; }
  const span=Math.max(1e-12, phiMax-phiMin);

  for(let j=1;j<ny-1;j++){
    for(let i=1;i<nx-1;i++){
      const idx=i+j*nx, ph=phi[idx];
      const lap=laplacian(phi,i,j,nx,ny,dx,dy);
      const rho= lap / fourPiG; if(rho<rhoMin)rhoMin=rho; if(rho>rhoMax)rhoMax=rho;
      const {g2}=grad2(phi,i,j,nx,ny,dx,dy);
      const p = (g2)/(8*Math.PI*G); // toy pressure from EM field gradient energy

      const NEC=(rho + p/C_MPS**2)>=0, WEC=(rho>=0)&&NEC, SEC=(rho + 3*p/C_MPS**2)>=0;
      if(!NEC) violNEC=true; if(!WEC) violWEC=true; if(!SEC) violSEC=true;

      const gtt = 1 + 2*ph/(C_MPS*C_MPS);
      if(gtt<gttMin) gttMin=gtt; if(gtt<=0) horizons++;

      const R = lap/(C_MPS*C_MPS);
      const K = R*R + (g2*g2)/(C_MPS**4);
      Rsum+=Math.abs(R); Ksum+=K;

      if(j===Math.floor(ny/2)){
        const x=Math.floor((i/nx)*w), t=(ph - phiMin)/span;
        const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t));
        grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,h);
      }
    }
  }
  $("gr_gtt").textContent = gttMin.toFixed(6);
  $("gr_rho").textContent = `${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}`;
  $("gr_R").textContent   = (Rsum/(nx*ny)).toExponential(3);
  $("gr_K").textContent   = (Ksum/(nx*ny)).toExponential(3);
  $("gr_ec").textContent  = `${violNEC?"‚ùå NEC":"‚úÖ NEC"} ‚Ä¢ ${violWEC?"‚ùå WEC":"‚úÖ WEC"} ‚Ä¢ ${violSEC?"‚ùå SEC":"‚úÖ SEC"}`;
  $("gr_hor").textContent = horizons>0 ? `‚ö†Ô∏è ${horizons} cells (g_tt‚â§0)` : "None";
}

/* ========= Animation ========= */
function animate(){
  if(!simulationRunning || shipArrived) return;
  const now=performance.now(); const dt=(now - lastFrameTime)/1000; lastFrameTime=now;
  stepEngineDynamics(dt, true);

  const {warp}=warpInputs(); const eng=engineInputs();
  const speed=Math.max(0.05,eng.gradientFactor)*Math.min(1,0.6+0.7*eng.stability);
  shipProgress += 0.00045*Math.pow(warp,0.85)*(0.8+0.6*speed);
  if(shipProgress>=1){ shipProgress=1; shipArrived=true; tone("good"); stopAll(); }

  drawCurve(); drawOrbitView(); validateGR();
  animationFrame=requestAnimationFrame(animate);
}

/* ========= Controls / Beacon ========= */
const flightLog=[];
function updateAllStatus(){
  const {eta,dAU,v}=computeETASeconds();
  const base=Date.now(), arrCST=base+eta*1000;
  const {istYears,spy}=IST_snapshot(); const arrIST=istYears + eta/spy;
  const arrISTstr=`${(arrIST/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(arrIST).toLocaleString()} y`;
  const avg=renderClockCards(eta, arrISTstr, arrCST);
  const warp=Number($("warpSpeed").value||1), dest=$("destination").value;
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
  $("beacon").textContent=`üõ∞Ô∏è Warp ${warp} ‚Üí ${dest} | Dist ${dAU.toFixed(3)} AU | v ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Avg Drift ${avg.toFixed(2)} ms`;
  flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});
}
function startAll(){
  if(simulationRunning) return;
  simulationRunning=true; shipArrived=false; shipProgress=0; tone("good");
  lastFrameTime=performance.now();
  driftInterval=setInterval(updateAllStatus,600);
  beaconInterval=setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); },2000);
  orbitInterval=setInterval(()=>{ updateOrbitTable(); drawOrbitView(); },900);
  animationFrame=requestAnimationFrame(animate);
}
function stopAll(){
  simulationRunning=false;
  clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval);
  cancelAnimationFrame(animationFrame);
  stepEngineDynamics(0.2,false); tone("warn");
}
function resetAll(){
  stopAll(); shipProgress=0; shipArrived=false; clocks.forEach(c=>c.drift=0); tIST0=performance.now();
  engineState.t=0; engineState.temp=0; engineState.sag=0; engineState.containNeed=0.22; engineState.jitter=0;
  $("beacon").textContent="‚è≥ Waiting for start‚Ä¶";
  updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus();
}
function exportLog(){ const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"], ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
  const csv=rows.map(r=>r.join(",")).join("\n"); const blob=new Blob([csv],{type:"text/csv"}); const a=document.createElement("a");
  a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click(); }
$("exportBtn").onclick=exportLog;

/* ========= GR Report Export ========= */
$("exportGR").onclick = ()=>{
  validateGR();
  const { eta, dAU, v } = computeETASeconds();
  const txt = [
    "Minimal GR Validator Report (EM-driven)",
    "---------------------------------------",
    `g_tt min: ${$("gr_gtt").textContent}`,
    `rho_eff min/max (kg/m^3): ${$("gr_rho").textContent}`,
    `Ricci proxy (avg): ${$("gr_R").textContent}`,
    `Kretschmann proxy (avg): ${$("gr_K").textContent}`,
    `Energy Conditions: ${$("gr_ec").textContent}`,
    `Bubble Horizons: ${$("gr_hor").textContent}`,
    "",
    `ETA: ${(eta>=3600?(eta/3600).toFixed(2)+" h":eta.toFixed(1)+" s")} | Dist: ${dAU.toFixed(3)} AU | v/c: ${(v/C_MPS).toFixed(2)}`
  ].join("\n");
  const blob=new Blob([txt],{type:"text/plain"}); const a=document.createElement("a");
  a.href=URL.createObjectURL(blob); a.download="gr_report.txt"; a.click();
};

/* ========= UI SCALE & INIT ========= */
const rootEl=document.documentElement, scaleEl=$("uiScale");
const curveBase={w:820,h:320}, orbitBase={w:420,h:420};
function applyScale(){
  const pct = Number(scaleEl.value||100);
  rootEl.style.setProperty('--ui-scale', (pct/100).toString());
  $("uiScaleVal").textContent = pct+"%";
  const s = pct/100;
  const curveCanvasEl=$("curveCanvas"), orbitCanvasEl=$("orbitCanvas"), grCanvasEl=$("grCanvas");
  curveCanvasEl.width = Math.round(curveBase.w*s); curveCanvasEl.height= Math.round(curveBase.h*s);
  orbitCanvasEl.width = Math.round(orbitBase.w*s); orbitCanvasEl.height= Math.round(orbitBase.h*s);
  grCanvasEl.width = Math.max(320, Math.round(320*s)); grCanvasEl.height = Math.max(120, Math.round(120*s));
  drawCurve(); drawOrbitView(); validateGR(); updateAllStatus();
}
$("compact").addEventListener("change",(e)=>{ if(e.target.checked) document.body.classList.add("compact"); else document.body.classList.remove("compact"); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); });
scaleEl.addEventListener("input", applyScale);
$("startBtn").onclick=startAll; $("stopBtn").onclick=stopAll; $("resetBtn").onclick=resetAll;

["warpSpeed","warpExp","warpScale","destination","istDay0Years","baselineDaysPerYear","reactorMW","frontPct","rearPct","lrBias","udBias","intakeMode","engMode","soundOn"]
  .forEach(id=>$(id).addEventListener("input", ()=>{ tIST0=performance.now(); updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); }));

/* Init */
window.onload=()=>{ document.body.classList.add("compact"); applyScale(); updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); };
</script>
</body>
</html>
