<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Warp Control Center ‚Äî Gravity-Vector Warp Drive (ETA + Clocks)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0a0f17; --panel:#0f1626; --card:#121a2c; --edge:#24314d;
    --text:#e6eefc; --muted:#9fb0d8; --accent:#7dd3fc; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
    --cyan:#06b6d4; --green:#22c55e; --orange:#fb923c;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  h1,h2,h3{margin:.4rem 0}
  .grid{display:grid;gap:10px}
  .wrap{max-width:1300px;margin:0 auto;padding:12px}
  .panel{background:var(--panel);border:1px solid var(--edge);border-radius:12px;padding:10px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .row2{grid-template-columns:1fr 1fr}
  .row3{grid-template-columns:1fr 1fr 1fr}
  .row4{grid-template-columns:repeat(4,1fr)}
  .controls label{display:flex;align-items:center;gap:8px;margin:6px 0;color:var(--muted);font-size:.95rem}
  select,input[type="number"],input[type="range"]{
    background:#0b1220;color:var(--text);border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem
  }
  input[type="range"]{width:220px}
  button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:8px 12px;margin:5px;border-radius:8px;cursor:pointer}
  #startBtn{background:#00ccff;color:#00131a;border:none} #stopBtn{background:#64748b}
  #resetBtn{background:#fb923c;border:none} #exportBtn{background:#7c3aed}
  .lights{display:flex;gap:10px;flex-wrap:wrap}
  .light{display:flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.9rem}
  .dot{width:10px;height:10px;border-radius:50%}
  .good .dot{background:var(--good)} .warn .dot{background:var(--warn)} .bad .dot{background:var(--bad)}
  .meter{display:flex;align-items:center;gap:8px;margin:4px 0}
  .bar{height:10px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}
  .fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}
  .stat{font-variant-numeric:tabular-nums;font-size:.9rem;color:var(--muted)}
  canvas{background:#0b1120;border:1px solid #2b3a5a;border-radius:12px}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid #2b3a5a;padding:8px;font-size:.92rem}
  th{background:#0e1627;color:#cfe2ff}
  .pill{display:inline-block;padding:.15rem .45rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}
  .legend{color:var(--muted);font-size:.9rem;margin-top:6px}
  .note{color:var(--muted);font-size:.85rem}
  @media (max-width:1100px){ .row3,.row4{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="wrap grid row3">
  <!-- LEFT: Flight & Warp Setup -->
  <div class="panel">
    <h2>Flight Plan</h2>
    <div class="grid row2 controls">
      <label>Warp Speed
        <select id="warpSpeed">
          <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option>
          <option value="4">Warp 4</option><option value="5">Warp 5</option><option value="6">Warp 6</option>
          <option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option>
          <option value="10">Warp 10</option>
        </select>
      </label>
      <label>Destination
        <select id="destination">
          <option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option>
        </select>
      </label>
      <label>Warp Law Exponent (n)
        <input id="warpExp" type="number" step="0.1" value="3">
      </label>
      <label>Speed Scale (√óc)
        <input id="warpScale" type="number" step="0.1" value="1">
      </label>
      <label>IST Day 0 (years ago)
        <input id="istDay0Years" type="number" step="1" value="45500000000">
      </label>
      <label>Baseline Days / IST Year
        <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25">
      </label>
    </div>

    <div class="lights" id="statusLights">
      <div class="light good" id="lightBubble"><span class="dot"></span>Bubble Stability</div>
      <div class="light good" id="lightPower"><span class="dot"></span>Power Margin</div>
      <div class="light good" id="lightVector"><span class="dot"></span>Vector Balance</div>
      <div class="light good" id="lightNav"><span class="dot"></span>Nav Solution</div>
    </div>

    <div style="margin-top:6px">
      <button id="startBtn">‚ñ∂Ô∏è Start</button>
      <button id="stopBtn">‚è∏Ô∏è Stop</button>
      <button id="resetBtn">üîÑ Engage Warp</button>
      <button id="exportBtn">üìÑ Export Log</button>
    </div>
    <div class="legend" id="beacon">‚è≥ Waiting for start‚Ä¶</div>
  </div>

  <!-- CENTER: Gravity Vectoring Engine -->
  <div class="panel">
    <h2>Gravity Vectoring Engine</h2>
    <div class="controls">
      <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
      <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
      <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
      <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
      <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
      <label>Intake Mode
        <select id="intakeMode">
          <option value="balanced">Balanced (¬±)</option>
          <option value="positive">Positive Gravity Capture</option>
          <option value="negative">Negative Gravity Capture</option>
        </select>
      </label>
    </div>

    <h3>Power Allocation</h3>
    <div class="meter"><span class="stat" style="width:150px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
    <div class="meter"><span class="stat" style="width:150px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
    <div class="meter"><span class="stat" style="width:150px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>
    <div class="note">Tip: Stability needs enough **Containment**. Speed responds to **Coils √ó (Rear ‚àí Front)**. Steering uses **Vanes** + bias.</div>
  </div>

  <!-- RIGHT: Visuals -->
  <div class="panel">
    <h2>Trajectory & Field Vectors</h2>
    <canvas id="curveCanvas" width="800" height="300"></canvas>
    <div class="legend" id="curveLegend">‚Äî</div>
  </div>

  <!-- ORBIT & ORBITAL TABLE -->
  <div class="panel">
    <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
    <canvas id="orbitCanvas" width="500" height="500"></canvas>
    <div class="legend" id="orbitLegend">‚Äî</div>
  </div>

  <div class="panel">
    <h2>IST Orbital Tracker (Live)</h2>
    <table>
      <thead>
        <tr><th>Body</th><th>Age Since Creation</th><th>Orbits Completed</th><th>Current Orbit</th><th>Progress</th><th>Days into Orbit / Orbit Length</th></tr>
      </thead>
      <tbody id="orbit-body"></tbody>
    </table>
    <div class="note">Formation offsets (Myr after Day 0): Sun 0; Mercury 5; Venus 30; Earth 27; Mars 10; Jupiter 1; Saturn 3; Uranus 15; Neptune 20; Pluto 30.</div>
  </div>

  <!-- CLOCKS -->
  <div class="panel">
    <h2>Clock Sync (C1‚ÄìC5) + Arrival CST/IST</h2>
    <table>
      <thead>
        <tr>
          <th>Clock ID</th><th>Location</th><th>Purpose</th>
          <th>CST Time</th><th>Local Clock Time</th><th>Œî from CST (ms)</th><th>Status</th>
          <th>Arrival CST</th><th>Arrival IST</th>
        </tr>
      </thead>
      <tbody id="clock-table-body"></tbody>
    </table>
  </div>
</div>

<script>
/* ==============================
   Constants & Planet Data
============================== */
const AU_M   = 1.495978707e11;    // meters
const C_MPS  = 299792458;         // m/s
const orbitAU = { Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays = {
  Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980,
  Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560
};
const formationOffsetMyr = { Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };

/* ==============================
   DOM Shortcuts
============================== */
const $ = (id) => document.getElementById(id);

/* ==============================
   State & Utility
============================== */
let simulationRunning = false, shipProgress = 0, shipArrived = false;
let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null;

const log = [];
const clocks = [
  { id:"C1", location:"Biometric Zone", purpose:"Medium Crew/Local Systems", drift:0 },
  { id:"C2", location:"Warp Shell Edge", purpose:"Phase Monitor Field Timing", drift:3 },
  { id:"C3", location:"AI Core/NavCore", purpose:"Critical Navigation Timing", drift:0 },
  { id:"C4", location:"CST Dome Earth", purpose:"Top Priority Anchor", drift:0 },
  { id:"C5", location:"Mid-Bubble DriftEye", purpose:"High Diagnostics/Protection", drift:-6 }
];

function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function setLight(el, level){ el.classList.remove("good","warn","bad"); el.classList.add(level); }

/* ==============================
   IST Timebase
============================== */
let tIST0 = performance.now();
function IST_INPUT(){ return Number($("istDay0Years").value || 45500000000); }
function DPY_INPUT(){ return Number($("baselineDaysPerYear").value || 365.25); }
function IST_snapshot(){
  const dpy = DPY_INPUT();
  const spy = dpy * 86400;
  const elapsedYears = (performance.now()-tIST0)/1000/spy;
  const istYears = IST_INPUT() + elapsedYears;
  const istDays  = istYears * dpy;
  return {istYears, istDays, dpy, spy};
}
function planetAgeYears(name, istYears){ return Math.max(0, istYears - (formationOffsetMyr[name]||0)*1_000_000); }
function trueAnomalyFrac(name, istYears, dpy){
  const pYears = planetAgeYears(name, istYears);
  const pDays  = pYears * dpy;
  const T = orbitalDays[name]; if(!T) return 0;
  const N = pDays/T; return N - Math.floor(N);
}
function orbitsFor(name, pDays){
  const T = orbitalDays[name]; if(!T) return null;
  const tot = pDays/T, comp = Math.max(0, Math.floor(tot));
  const frac = tot-comp; return {totalOrbits:tot, completed:comp, frac, daysInto:frac*T, yearLen:T};
}

/* ==============================
   Warp Law & Gravity Vectoring
============================== */
function warpInputs(){
  return {
    warp: Number($("warpSpeed").value||1),
    exp:  Number($("warpExp").value||3),
    scale:Number($("warpScale").value||1),
  };
}
function engineInputs(){
  const reactorMW = Number($("reactorMW").value||5000);
  // Fixed split heuristics based on slider emphasis:
  const front = Number($("frontPct").value||0)/100;
  const rear  = Number($("rearPct").value||0)/100;
  const lr    = Number($("lrBias").value||0)/100;
  const ud    = Number($("udBias").value||0)/100;
  const mode  = $("intakeMode").value;

  // Power allocation model (normalized proportions)
  // Keep coils >= containment; vanes scale with |lr|+|ud| and |rear-front|
  const vecDemand = Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  const coilsPct = Math.max(0.35, 0.55 - 0.25*vecDemand);
  const containPct = Math.max(0.20, 0.25 - 0.10*(rear-front<0?1:0)); // more containment if front>rear (braking)
  const vanesPct = Math.min(0.35, 1 - coilsPct - containPct);

  // Update UI meters
  $("mCoils").style.width = `${coilsPct*100}%`; $("mCoilsVal").textContent = `${(coilsPct*reactorMW).toFixed(0)} MW`;
  $("mVanes").style.width = `${vanesPct*100}%`; $("mVanesVal").textContent = `${(vanesPct*reactorMW).toFixed(0)} MW`;
  $("mContain").style.width= `${containPct*100}%`; $("mContainVal").textContent= `${(containPct*reactorMW).toFixed(0)} MW`;

  // Bubble stability heuristic
  let stability = 1.0;
  // Penalize low containment
  if (containPct < 0.22) stability -= 0.25*(0.22-containPct)/0.22;
  // Penalize extreme bias
  const biasMag = Math.hypot(lr,ud);
  stability -= 0.3*Math.max(0, biasMag-0.3)/0.7;
  // Penalize front>rear (net braking) and mode conflicts
  if (rear < front) stability -= 0.2*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability = Math.max(0, Math.min(1, stability));

  // Effective gradient factor for speed (0..>1)
  // Rear-front drives forward; coils power boosts; stability gates
  const grad = Math.max(0, (rear - front));           // 0..1
  const gradBoost = coilsPct * (0.5 + 0.5*grad);      // 0..~0.55
  const gradientFactor = stability * (0.35 + 0.9*gradBoost); // ~0.35..~1.0

  // Vector deflection (lateral/vertical)
  const deflect = { lr, ud, magnitude: Math.min(1, Math.hypot(lr,ud)) };

  // Status lights
  setLight($("lightBubble"), stability>0.75 ? "good" : stability>0.45 ? "warn" : "bad");
  const powerOk = reactorMW*(coilsPct+vanesPct+containPct) >= 0.99*reactorMW; // always true‚Äîplaceholder for real margins
  setLight($("lightPower"), powerOk ? "good" : "warn");
  setLight($("lightVector"), deflect.magnitude<0.6 ? "good" : deflect.magnitude<0.85 ? "warn" : "bad");

  return { reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, gradientFactor, stability, deflect, mode };
}

/* ==============================
   Realistic ETA (distance-based)
============================== */
function computeETASeconds(){
  const { istYears, dpy } = IST_snapshot();
  const dest = $("destination").value;
  const { warp, exp, scale } = warpInputs();
  const eng = engineInputs();

  // Angles (radians)
  const thetaEarth = trueAnomalyFrac("Earth", istYears, dpy) * Math.PI*2;
  const thetaDest  = trueAnomalyFrac(dest, istYears, dpy)  * Math.PI*2;

  // AU distances (circular)
  const r1 = orbitAU.Earth, r2 = orbitAU[dest];
  const dAU = Math.sqrt(r1*r1 + r2*r2 - 2*r1*r2*Math.cos(thetaDest - thetaEarth));
  const dM  = dAU * AU_M;

  // Warp velocity with gravity vectoring factor
  const v = C_MPS * scale * Math.pow(warp, exp) * Math.max(0.05, eng.gradientFactor);
  const eta = dM / Math.max(v, 1e-3);

  // Nav light: solution OK if ETA finite & <= few hours at high warp
  setLight($("lightNav"), isFinite(eta) ? (eta<86400 ? "good" : "warn") : "bad");

  return { eta, dAU, v };
}

/* ==============================
   ORBIT TABLE & POLAR VIEW
============================== */
function updateOrbitTable(){
  const { istYears, dpy } = IST_snapshot();
  const destination = $("destination").value;
  const rows = [];

  // Sun age
  const sY = planetAgeYears("Sun", istYears), sD = sY * dpy;
  rows.push({body:"Sun", age:`${(sY/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(sY).toLocaleString()} y ‚Ä¢ ${Math.floor(sD).toLocaleString()} d`, comp:"‚Äî", curr:"‚Äî", prog:"‚Äî", into:"‚Äî"});

  // Destination
  const pY = planetAgeYears(destination, istYears), pD = pY * dpy;
  const o = orbitsFor(destination, pD)||{};
  const percent = o.frac!=null ? (o.frac*100).toFixed(2)+"%" : "‚Äî";
  const row = {
    body: destination,
    age: `${(pY/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(pY).toLocaleString()} y ‚Ä¢ ${Math.floor(pD).toLocaleString()} d`,
    comp: o.completed!=null ? o.completed.toLocaleString() : "‚Äî",
    curr: o.completed!=null ? (o.completed+1).toLocaleString() : "‚Äî",
    prog: percent,
    into: o.daysInto!=null ? `~${Math.floor(o.daysInto).toLocaleString()} / ${Math.floor(o.yearLen).toLocaleString()} d` : "‚Äî",
  };

  const tbody = $("orbit-body");
  tbody.innerHTML = `
    <tr><td>${rows[0].body}</td><td>${rows[0].age}</td><td>${rows[0].comp}</td><td>${rows[0].curr}</td><td>${rows[0].prog}</td><td>${rows[0].into}</td></tr>
    <tr><td>${row.body}</td><td>${row.age}</td><td>${row.comp}</td><td>${row.curr}</td><td><span class="pill">${row.prog}</span></td><td>${row.into}</td></tr>
  `;
  drawOrbitView();
}

const orbitCanvas = $("orbitCanvas"); const octx = orbitCanvas.getContext("2d");
const orbitRadiiPx = { Mars:120, Jupiter:170, Saturn:210, Pluto:240 };
function drawOrbitView(){
  const { istYears, dpy } = IST_snapshot();
  const dest = $("destination").value;
  const w=orbitCanvas.width, h=orbitCanvas.height, cx=w/2, cy=h/2;

  octx.clearRect(0,0,w,h);
  // Sun
  octx.beginPath(); octx.arc(cx,cy,12,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.shadowColor="#ffb703"; octx.shadowBlur=14; octx.fill(); octx.shadowBlur=0;
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun", cx-14, cy-18);

  ["Mars","Jupiter","Saturn","Pluto"].forEach(p=>{
    const r=orbitRadiiPx[p];
    octx.beginPath(); octx.arc(cx,cy,r,0,Math.PI*2);
    octx.strokeStyle = p===dest ? "#ffffff" : "#3c4a6a"; octx.lineWidth = p===dest ? 2 : 1; octx.stroke();
    octx.fillStyle="#98a9cc"; octx.fillText(p, cx+r+8, cy-2);
  });

  const fracNow = trueAnomalyFrac(dest, istYears, dpy), thetaNow = fracNow*Math.PI*2;
  const rPx = orbitRadiiPx[dest]||180;
  // Current (blue)
  const px = cx + rPx*Math.cos(thetaNow), py = cy + rPx*Math.sin(thetaNow);
  octx.beginPath(); octx.arc(px,py,6,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.shadowColor="#22d3ee"; octx.shadowBlur=10; octx.fill(); octx.shadowBlur=0;
  octx.beginPath(); octx.moveTo(cx,cy); octx.lineTo(px,py); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();

  // Arrival marker
  const { eta, dAU } = computeETASeconds();
  const T = orbitalDays[dest]; const dFrac = eta / (T*86400);
  const thetaArr = (thetaNow + dFrac*Math.PI*2)%(Math.PI*2);
  const ax = cx + rPx*Math.cos(thetaArr), ay = cy + rPx*Math.sin(thetaArr);
  octx.beginPath(); octx.arc(ax,ay,6,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.shadowColor="#22c55e"; octx.shadowBlur=12; octx.fill(); octx.shadowBlur=0;
  octx.beginPath(); octx.moveTo(cx,cy); octx.lineTo(ax,ay); octx.strokeStyle="#22c55e"; octx.lineWidth=1.5; octx.stroke();

  const angleNowDeg = (thetaNow*180/Math.PI+360)%360;
  const angleArrDeg = (thetaArr*180/Math.PI+360)%360;
  let delta = angleArrDeg-angleNowDeg; if(delta<0) delta+=360;
  $("orbitLegend").textContent = `${dest} ‚Ä¢ Now: ${angleNowDeg.toFixed(2)}¬∞ ‚Ä¢ ETA: ${angleArrDeg.toFixed(2)}¬∞ ‚Ä¢ Œî: ${delta.toFixed(2)}¬∞ ‚Ä¢ Dist: ${dAU.toFixed(3)} AU`;
}

/* ==============================
   Curve Canvas (trajectory + vectors)
============================== */
const curveCanvas = $("curveCanvas"); const ctx = curveCanvas.getContext("2d");
const startX=90, endX=710, baseY=220; // visual path
function drawCurve(){
  const warp = Number($("warpSpeed").value||1);
  const eng = engineInputs();
  const arcHeight = 90 / Math.max(1, warp*(0.8+0.6*eng.stability)); // faster warp flattens arc a bit

  ctx.clearRect(0,0,curveCanvas.width,curveCanvas.height);

  // Earth & Destination nodes
  const destination = $("destination").value;
  ctx.beginPath(); ctx.arc(startX, baseY, 12, 0, Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-22, baseY+26);

  ctx.beginPath(); ctx.arc(endX, baseY, 10, 0, Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(destination, endX-30, baseY+26);

  // Warp arc
  ctx.beginPath();
  ctx.moveTo(startX, baseY);
  ctx.quadraticCurveTo( (startX+endX)/2, baseY - arcHeight*3, endX, baseY );
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  // Ship along arc (progress influenced by engine)
  const t = shipProgress;
  const mx = (startX+endX)/2, ctrlY = baseY - arcHeight*3;
  const sx = (1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy = (1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;

  ctx.beginPath(); ctx.arc(sx,sy,8,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9";
  ctx.shadowColor = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowBlur=10; ctx.fill(); ctx.shadowBlur=0;

  // Vector arrows (front/rear and lateral/vertical)
  const arrow = (x,y,dx,dy,color)=>{ const len= Math.hypot(dx,dy)||1; const ux=dx/len, uy=dy/len;
    const ex = x+dx, ey = y+dy; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey);
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    // head
    ctx.beginPath(); ctx.moveTo(ex,ey);
    ctx.lineTo(ex-6*ux+3*uy, ey-6*uy-3*ux);
    ctx.lineTo(ex-6*ux-3*uy, ey-6*uy+3*ux);
    ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  };

  // Scale arrows by engine settings
  const fMag = $("frontPct").value/100, rMag = $("rearPct").value/100;
  const lr = $("lrBias").value/100, ud = $("udBias").value/100;
  const k = 60; // visual scale
  arrow(sx, sy,  0, -k*rMag, "#22c55e");   // rear expansion (up toward control point)
  arrow(sx, sy,  0,  k*fMag, "#f97316");   // front contraction (down)
  arrow(sx, sy,  k*lr, 0, "#a78bfa");      // left/right bias
  arrow(sx, sy,  0, -k*ud, "#38bdf8");     // up/down bias

  $("curveLegend").textContent = `Vectors ‚Äî Rear: ${(rMag*100).toFixed(0)}% | Front: ${(fMag*100).toFixed(0)}% | LR: ${(lr*100).toFixed(0)}% | UD: ${(ud*100).toFixed(0)}%`;
}

/* ==============================
   Animation
============================== */
function animate(){
  if(!simulationRunning || shipArrived) return;
  // Advance progress based on warp law & gravity engine
  const { warp, exp, scale } = warpInputs();
  const eng = engineInputs();
  const speedFactor = Math.max(0.05, eng.gradientFactor) * Math.min(1, 0.6 + 0.7*eng.stability);
  const step = 0.00045 * Math.pow(warp, 0.85) * (0.8 + 0.6*speedFactor); // tuned for smooth UI motion

  shipProgress += step;
  if(shipProgress >= 1){ shipProgress=1; shipArrived=true; stopAll(); }

  drawCurve();
  drawOrbitView();
  animationFrame = requestAnimationFrame(animate);
}

/* ==============================
   Clocks + Arrival Time
============================== */
function updateClocks(){
  const tbody = $("clock-table-body"); tbody.innerHTML = "";
  const base = Date.now();
  const { eta } = computeETASeconds(); const arrMs = base + eta*1000;

  const { istYears, spy, dpy } = IST_snapshot();
  const arrISTyears = istYears + eta/spy;
  const arrISTstr = `${(arrISTyears/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(arrISTyears).toLocaleString()} y`;

  let totalDrift=0;
  clocks.forEach(c=>{
    if(simulationRunning) c.drift += Math.random()*2 - 1;
    const local = base + c.drift; const delta = c.drift.toFixed(2);
    totalDrift += Math.abs(c.drift);
    let cls="good", status="‚úÖ Synced";
    if(Math.abs(c.drift)>5){ cls="warn"; status="‚ö†Ô∏è Drift"; }
    if(Math.abs(c.drift)>10){ cls="bad"; status="‚ùå Unsafe"; }

    tbody.innerHTML += `
      <tr class="${cls}">
        <td>${c.id}</td><td>${c.location}</td><td>${c.purpose}</td>
        <td>${fmtClock(base)}</td><td>${fmtClock(local)}</td><td>${delta}</td><td>${status}</td>
        <td>${fmtClock(arrMs)}</td><td>${arrISTstr}</td>
      </tr>`;
  });

  const avgDrift = totalDrift / clocks.length;
  const { dAU, v } = computeETASeconds();
  const warp = Number($("warpSpeed").value||1), dest = $("destination").value;
  const etaStr = eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
  $("beacon").textContent = `üõ∞Ô∏è Warp ${warp} ‚Üí ${dest} | Dist ${dAU.toFixed(3)} AU | v ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Avg Drift ${avgDrift.toFixed(2)} ms`;

  log.push({ t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3) });
}

/* ==============================
   Controls & Events
============================== */
function startAll(){
  if(simulationRunning) return;
  simulationRunning = true; shipArrived=false; shipProgress=0;
  driftInterval = setInterval(updateClocks, 500);
  beaconInterval= setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); }, 2000);
  orbitInterval = setInterval(()=>{ updateOrbitTable(); drawOrbitView(); }, 600);
  animationFrame = requestAnimationFrame(animate);
}
function stopAll(){
  simulationRunning=false;
  clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval);
  cancelAnimationFrame(animationFrame);
}
function resetAll(){
  stopAll(); shipProgress=0; shipArrived=false; log.length=0; clocks.forEach(c=>c.drift=0);
  $("beacon").textContent="‚è≥ Waiting for start‚Ä¶"; tIST0=performance.now();
  updateClocks(); updateOrbitTable(); drawCurve(); drawOrbitView();
}
function exportLog(){
  const rows = [["Time","Warp","Destination","ETA","Distance(AU)"], ...log.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU])];
  const csv = rows.map(r=>r.join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv"}); const a = document.createElement("a");
  a.href = URL.createObjectURL(blob); a.download = "warp_log.csv"; a.click();
}

// Bind buttons
$("startBtn").onclick = startAll; $("stopBtn").onclick = stopAll; $("resetBtn").onclick = resetAll; $("exportBtn").onclick = exportLog;

// Reactive inputs
["warpSpeed","warpExp","warpScale","destination","istDay0Years","baselineDaysPerYear","reactorMW","frontPct","rearPct","lrBias","udBias","intakeMode"].forEach(id=>{
  $(id).addEventListener("input", ()=>{
    $("frontLbl").textContent = `${$("frontPct").value}%`;
    $("rearLbl").textContent  = `${$("rearPct").value}%`;
    $("lrLbl").textContent    = `${$("lrBias").value}%`;
    $("udLbl").textContent    = `${$("udBias").value}%`;
    tIST0 = performance.now(); // keeps IST continuity fresh for timebase changes
    updateClocks(); updateOrbitTable(); drawCurve(); drawOrbitView();
  });
});

// Initial UI sync
window.onload = ()=>{ $("frontLbl").textContent=$("frontPct").value+"%"; $("rearLbl").textContent=$("rearPct").value+"%"; $("lrLbl").textContent=$("lrBias").value+"%"; $("udLbl").textContent=$("udBias").value+"%";
  updateClocks(); updateOrbitTable(); drawCurve(); drawOrbitView();
};
</script>
</body>
</html>
