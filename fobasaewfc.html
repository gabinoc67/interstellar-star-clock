<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FOBAS + AEWFC ‚Äî Warp Field Breach Arrest (CST-Synced)</title>
<meta name="description" content="Field Oscillation Breach Arrest System + Acoustic-Electro-Wave Field Control. Live demo showing noise, plasma, EM, and photon coordination to stabilize a breach under CST timing."/>
<meta name="robots" content="index,follow"/>
<meta name="theme-color" content="#0b1220"/>

<style>
  :root{
    --bg:#070a12; --panel:#0d1322; --ink:#e8eefc; --muted:#a7b4d1; --accent:#6ee7ff;
    --ok:#3ae89a; --warn:#ffd166; --bad:#ff6b8b; --ring:#7ad3ff; --em:#7effc4; --photon:#ffd1a3; --plasma:#a0a9ff;
    --border:#1e2a45;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:radial-gradient(1400px 900px at 70% 10%,#0b1220 0%,#070a12 60%,#060910 100%);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  a{color:var(--accent);text-decoration:none}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;padding:12px 0}
  h1{margin:0;font-size:20px;letter-spacing:.2px}
  .pill{display:inline-block;font-size:.8rem;padding:.15rem .6rem;border-radius:999px;background:#0f1a33;color:#d9eeff;border:1px solid #1b335e;margin-left:6px}
  .grid{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width: 980px){ .grid{grid-template-columns: 320px 1fr} }

  .card{background:linear-gradient(180deg,#0c1528 0%,#0b1121 100%);border:1px solid var(--border);border-radius:14px;padding:12px}
  .card h2{margin:.2rem 0 .5rem;font-size:16px}
  .sub{color:var(--muted);font-size:.92rem;margin:.25rem 0 .6rem}

  /* Controls */
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:#0f1a33;color:var(--ink);cursor:pointer}
  .btn:hover{border-color:#2a4270}
  .btn.primary{background:#0d2447;border-color:#2a5fa1;box-shadow:0 0 0 3px rgba(110,231,255,.12)}
  .btn.warn{background:#2b1e00;border-color:#6a4b00}
  .btn.ghost{background:transparent}
  .group{margin:.5rem 0}
  label{display:block;font-size:.85rem;color:var(--muted);margin:.35rem 0 .15rem}
  input[type="range"]{width:100%}
  .kv{display:flex;justify-content:space-between;font-size:.86rem;color:var(--muted);margin-top:.15rem}

  /* Gauges */
  .gauges{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  @media(min-width: 700px){ .gauges{grid-template-columns:repeat(4,1fr)} }
  .gauge{background:#0a1326;border:1px solid var(--border);border-radius:12px;padding:8px}
  .gauge h3{margin:.15rem 0 .3rem;font-size:.9rem}
  .bar{height:8px;border-radius:999px;background:#0f2040;overflow:hidden;border:1px solid #1d325a}
  .bar > span{display:block;height:100%;background:linear-gradient(90deg,#79d8ff,#9bf4ff)}
  .badge{display:inline-block;padding:.2rem .5rem;border-radius:999px;border:1px solid #27466e;font-size:.78rem;margin-left:6px}
  .status{font-weight:700}
  .status.ok{color:var(--ok)}
  .status.warn{color:var(--warn)}
  .status.bad{color:var(--bad)}

  /* Viz area */
  .viz{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width: 980px){ .viz{grid-template-columns:1.2fr .8fr} }
  canvas{width:100%;height:280px;background:linear-gradient(180deg,#061024,#071022);border:1px solid #1a2c4d;border-radius:12px}
  .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:.85rem;color:var(--muted)}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:.15rem .5rem;border:1px solid var(--border);border-radius:999px;background:#0b152b}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.acoustic{background:#87e0ff}
  .dot.em{background:var(--em)}
  .dot.plasma{background:var(--plasma)}
  .dot.photon{background:var(--photon)}
  .dot.forbid{background:#ff8e9f}

  /* Wave dividers and blinking */
  .wave{height:3px;background:linear-gradient(90deg,transparent,#79d8ff,transparent);filter:drop-shadow(0 0 6px #79d8ff);animation:wave 2s linear infinite}
  @keyframes wave{0%{background-position:0 0}100%{background-position:200px 0}}
  .blink{animation:blink 1s steps(1,end) infinite}
  @keyframes blink{50%{opacity:.35}}

  /* Logs */
  .logs{height:260px;overflow:auto;background:#081021;border:1px solid #1a2c4d;border-radius:12px;padding:8px;font-family:ui-monospace,Consolas,monospace;font-size:.85rem;line-height:1.35}
  .log-ok{color:#8ff5c4}
  .log-warn{color:#ffd98a}
  .log-bad{color:#ff9da9}

  /* Footer row */
  footer{margin-top:14px;color:var(--muted);font-size:.85rem;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>FOBAS + AEWFC <span class="pill">Warp Field Breach Arrest (CST-Synced)</span></h1>
    <div class="row">
      <button id="btnPrint" class="btn ghost" title="Print this run">üñ®Ô∏è Print</button>
      <button id="btnExport" class="btn ghost" title="Export log">‚¨áÔ∏è Export Log</button>
    </div>
  </header>

  <div class="grid">
    <!-- LEFT: Controls -->
    <aside class="card">
      <h2>Controls</h2>
      <p class="sub">Run the 5:00 demo (or speed it up) and watch the system stabilize the compromised compartment.</p>

      <div class="row">
        <button id="btnStart" class="btn primary">‚ñ∂ Start Demo (5:00)</button>
        <button id="btnPause" class="btn">‚è∏ Pause</button>
        <button id="btnReset" class="btn">‚ü≤ Reset</button>
      </div>

      <div class="row group">
        <label for="speed">Speed</label>
        <select id="speed" class="btn">
          <option value="1">1√ó (real time)</option>
          <option value="2">2√ó</option>
          <option value="4" selected>4√ó</option>
          <option value="8">8√ó</option>
        </select>
        <div class="kv"><span>Elapsed</span><span id="clock">00:00</span></div>
      </div>

      <div class="row group">
        <label for="breachSide">Breach Side</label>
        <select id="breachSide" class="btn">
          <option value="none">None</option>
          <option value="port" selected>Port (Left)</option>
          <option value="starboard">Starboard (Right)</option>
        </select>
        <label><input type="checkbox" id="autoMode" checked/> Auto stabilize</label>
      </div>

      <div class="group">
        <label>Noise (Acoustic) Power ‚Äî dB</label>
        <input id="noise" type="range" min="0" max="140" step="1" value="40"/>
        <div class="kv"><span>Engine/Reactors acoustic output</span><span id="noiseV">40 dB</span></div>
      </div>
      <div class="group">
        <label>Plasma Field ‚Äî %</label>
        <input id="plasma" type="range" min="0" max="100" step="1" value="20"/>
        <div class="kv"><span>Electro-plasma shaping</span><span id="plasmaV">20%</span></div>
      </div>
      <div class="group">
        <label>EM Envelope ‚Äî %</label>
        <input id="em" type="range" min="0" max="100" step="1" value="25"/>
        <div class="kv"><span>Field shapers / coils</span><span id="emV">25%</span></div>
      </div>
      <div class="group">
        <label>Photon Flux ‚Äî %</label>
        <input id="photon" type="range" min="0" max="100" step="1" value="15"/>
        <div class="kv"><span>Detection lasers / radiative pressure</span><span id="photonV">15%</span></div>
      </div>
      <div class="group">
        <label>Feedback Gain (AEWFC)</label>
        <input id="gain" type="range" min="0" max="2.0" step="0.05" value="0.80"/>
        <div class="kv"><span>Acoustic-Electro-Wave control loop</span><span id="gainV">0.80</span></div>
      </div>

      <div class="wave"></div>

      <h2>Status</h2>
      <div class="gauges">
        <div class="gauge">
          <h3>Compartment Pressure <span id="pressPct">‚Äî</span></h3>
          <div class="bar"><span id="pressBar" style="width:0%"></span></div>
          <div class="kv"><span>Leakage</span><span id="leakPct">‚Äî</span></div>
        </div>
        <div class="gauge">
          <h3>Gravity Hold <span id="gHold">‚Äî</span></h3>
          <div class="bar"><span id="gBar" style="width:0%"></span></div>
          <div class="kv"><span>Target</span><span>1.00 g</span></div>
        </div>
        <div class="gauge">
          <h3>Field Stability <span id="stabBadge" class="status">‚Äî</span></h3>
          <div class="bar"><span id="stabBar" style="width:0%"></span></div>
          <div class="kv"><span>Residual</span><span id="resid">‚Äî</span></div>
        </div>
        <div class="gauge">
          <h3>Forbidden Region Proximity</h3>
          <div class="bar"><span id="forbidBar" style="width:0%"></span></div>
          <div class="kv"><span>Mask</span><span id="forbidTxt">Clear</span></div>
        </div>
      </div>
    </aside>

    <!-- RIGHT: Viz + Logs -->
    <section class="viz">
      <div class="card">
        <h2>Compartment Diagram & Field Overlay</h2>
        <p class="sub">Left/Right bays; breach shows as a blinking hole. Field intensity ramps on the compromised side, coordinated by AEWFC.</p>
        <div class="legend">
          <span class="chip"><span class="dot acoustic"></span> Acoustic</span>
          <span class="chip"><span class="dot em"></span> EM</span>
          <span class="chip"><span class="dot plasma"></span> Plasma</span>
          <span class="chip"><span class="dot photon"></span> Photons</span>
          <span class="chip"><span class="dot forbid"></span> Forbidden mask</span>
        </div>
        <canvas id="viz"></canvas>
        <div class="wave blink"></div>
      </div>

      <div class="card">
        <h2>Navigation Stack Logs</h2>
        <p class="sub">Pass/Fail steps, residuals, and auto-tuning events with CST timestamps.</p>
        <div class="logs" id="logs" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <footer>
    <p>CST clock: <span id="cst"></span> ‚Ä¢ Demo script: breach ‚Üí arrest ‚Üí hold ‚Ä¢ Credit: Gabino Casanova</p>
  </footer>
</div>

<script>
/* ======= Utility ======= */
const $ = (id)=>document.getElementById(id);
const logs = $("logs");
const nowCST = ()=> {
  // Approx CST (no DST rules here, simple UTC-6 fallback) ‚Äî for display only
  const d = new Date();
  const utc = d.getTime() + (d.getTimezoneOffset()*60000);
  const cst = new Date(utc - (6*3600*1000));
  return cst;
};
const fmtTime = (t)=>t.toString().padStart(2,"0");
function log(line, level="ok"){
  const el = document.createElement('div');
  el.className = level==="ok" ? "log-ok" : level==="warn" ? "log-warn" : "log-bad";
  el.textContent = `[${nowCST().toISOString()}] ${line}`;
  logs.appendChild(el);
  logs.scrollTop = logs.scrollHeight;
}
function setBadge(el, text, level){
  el.textContent = text;
  el.classList.remove("ok","warn","bad");
  el.classList.add(level);
}

/* ======= State ======= */
const state = {
  running:false,
  paused:false,
  t:0,             // seconds
  TMAX: 300,       // 5 minutes
  speed:4,         // default 4√ó
  breachSide:"port", // none | port | starboard
  auto:true,
  noise:40, plasma:20, em:25, photon:15, gain:0.80,
  pressure:1.00,   // 0..1
  leak:0.00,       // 0..1
  ghold:1.00,      // g
  stability:0.25,  // 0..1 (1=stable)
  residual:0.50,   // 0..1
  forbid:0.10,     // 0..1 proximity
  history:[]
};

/* ======= Elements ======= */
const noise = $("noise"), plasma=$("plasma"), em=$("em"), photon=$("photon"), gain=$("gain");
const noiseV=$("noiseV"), plasmaV=$("plasmaV"), emV=$("emV"), photonV=$("photonV"), gainV=$("gainV");
const pressBar=$("pressBar"), stabBar=$("stabBar"), gBar=$("gBar"), forbidBar=$("forbidBar");
const pressPct=$("pressPct"), leakPct=$("leakPct"), gHold=$("gHold"), resid=$("resid"), stabBadge=$("stabBadge"), forbidTxt=$("forbidTxt");
const speed = $("speed"), breachSide=$("breachSide"), autoMode=$("autoMode"), clock=$("clock"), cst=$("cst");

/* ======= Controls binding ======= */
function bindSlider(sl, lab, unit, stKey){
  const update=()=>{ lab.textContent = sl.value + unit; state[stKey] = parseFloat(sl.value) };
  sl.addEventListener('input', update, {passive:true}); update();
}
bindSlider(noise, noiseV, " dB", "noise");
bindSlider(plasma, plasmaV, "%", "plasma");
bindSlider(em, emV, "%", "em");
bindSlider(photon, photonV, "%", "photon");
bindSlider(gain, gainV, "", "gain"); // gainV shows numeric

speed.addEventListener('change', ()=>{ state.speed = parseFloat(speed.value); log(`Speed set to ${state.speed}√ó`,"warn"); }, {passive:true});
breachSide.addEventListener('change', ()=>{ state.breachSide = breachSide.value; log(`Breach side: ${state.breachSide}`,"warn"); }, {passive:true});
autoMode.addEventListener('change', ()=>{ state.auto = autoMode.checked; log(`Auto mode: ${state.auto ? "ON":"OFF"}`,"warn"); }, {passive:true});

/* ======= Buttons ======= */
$("btnStart").addEventListener('click', startDemo);
$("btnPause").addEventListener('click', ()=>{ state.paused = !state.paused; log(state.paused?"Paused":"Resumed","warn"); });
$("btnReset").addEventListener('click', resetDemo);
$("btnPrint").addEventListener('click', ()=>window.print());
$("btnExport").addEventListener('click', exportLog);

/* ======= Viz ======= */
const canvas = $("viz");
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(280 * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas); resizeCanvas();

function drawViz(){
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);

  // Background gradient
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,"#081433"); g.addColorStop(1,"#081127");
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  // Ship compartments (left/right)
  const pad=14, gap=10;
  const bayW = (w - pad*2 - gap) / 2, bayH = h - pad*2;
  const left = {x:pad, y:pad, w:bayW, h:bayH};
  const right = {x:pad + bayW + gap, y:pad, w:bayW, h:bayH};

  // Draw bays
  ctx.strokeStyle="#24426f"; ctx.lineWidth=2;
  ctx.fillStyle="#0a1735";
  ctx.beginPath(); ctx.roundRect(left.x,left.y,left.w,left.h,10); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.roundRect(right.x,right.y,right.w,right.h,10); ctx.fill(); ctx.stroke();

  // Labels
  ctx.fillStyle="#a9c6f9"; ctx.font="12px system-ui";
  ctx.fillText("PORT BAY", left.x+8, left.y+16);
  ctx.fillText("STARBOARD BAY", right.x+8, right.y+16);

  // Field intensity overlays (stronger on compromised side)
  const lIntensity = state.breachSide==="port" ? fieldIntensity() : fieldBase();
  const rIntensity = state.breachSide==="starboard" ? fieldIntensity() : fieldBase();

  overlayField(left, lIntensity);
  overlayField(right, rIntensity);

  // Breach hole indicator
  if(state.breachSide!=="none"){
    const bx = state.breachSide==="port" ? left.x + left.w - 18 : right.x + 18;
    const by = (left.y + left.h/2) + Math.sin(state.t*2*Math.PI/2)*8;
    ctx.fillStyle = "rgba(255,120,120,0.95)";
    ctx.beginPath(); ctx.arc(bx,by,6,0,Math.PI*2); ctx.fill();
    // Blinking ring
    ctx.strokeStyle = "rgba(255,120,120,0.5)"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(bx,by,10 + (state.t%1)*6,0,Math.PI*2); ctx.stroke();
  }

  // Forbidden region mask (visualized as translucent red zones near strong curvature)
  const maskAlpha = 0.1 + 0.35*state.forbid;
  ctx.fillStyle = `rgba(255,80,100,${maskAlpha})`;
  const maskW = 40 + 120*state.forbid;
  ctx.fillRect(w/2 - maskW/2, pad, maskW, bayH);

  // Wave indicators on edges (acoustic/EM/plasma/photons)
  drawEdgeWave(left,  true);
  drawEdgeWave(right, false);

  // HUD text
  ctx.fillStyle="#cfe6ff";
  ctx.fillText(`Acoustic ${Math.round(state.noise)} dB  |  EM ${Math.round(state.em)}%  |  Plasma ${Math.round(state.plasma)}%  |  Photons ${Math.round(state.photon)}%  |  Gain ${state.gain.toFixed(2)}`, pad, h - 10);
}

function overlayField(rect, intensity){
  const grd = ctx.createLinearGradient(rect.x,rect.y,rect.x+rect.w,rect.y);
  grd.addColorStop(0, `rgba(126,255,196,${0.05*intensity})`); // EM tint
  grd.addColorStop(0.5, `rgba(160,169,255,${0.06*intensity})`); // Plasma tint
  grd.addColorStop(1, `rgba(255,209,163,${0.05*intensity})`); // Photon tint
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.roundRect(rect.x+2,rect.y+2,rect.w-4,rect.h-4,9); ctx.fill();

  // Field rings
  ctx.strokeStyle = `rgba(122,211,255,${0.25*intensity})`;
  ctx.lineWidth=1.5;
  const cx = rect.x + rect.w/2, cy = rect.y + rect.h/2;
  const t = state.t;
  for(let i=0;i<5;i++){
    ctx.beginPath();
    ctx.arc(cx,cy, 18 + i*16 + (t*10 % 16), 0, Math.PI*2);
    ctx.stroke();
  }
}

function drawEdgeWave(rect, isLeft){
  const y = rect.y + rect.h - 36;
  const x0 = rect.x + (isLeft?10:rect.w-150);
  const w = 140, h = 24;

  // Acoustic bar
  drawWaveBar(x0, y, w, 4, state.noise/140, "#87e0ff");
  // EM
  drawWaveBar(x0, y+6, w, 4, state.em/100, "rgba(126,255,196,0.95)");
  // Plasma
  drawWaveBar(x0, y+12, w, 4, state.plasma/100, "rgba(160,169,255,0.95)");
  // Photons
  drawWaveBar(x0, y+18, w, 4, state.photon/100, "rgba(255,209,163,0.95)");
}

function drawWaveBar(x,y,w,h,amp,color){
  ctx.fillStyle = "#09142c";
  ctx.fillRect(x,y,w,h);
  const fill = Math.max(2, Math.floor(w*amp));
  ctx.fillStyle = color;
  ctx.fillRect(x,y,fill,h);
}

function fieldBase(){ return 0.25; }
function fieldIntensity(){
  // Weighted by controls and residual (more residual ‚áí more drive)
  const drive = (state.noise/140)*0.35 + (state.em/100)*0.30 + (state.plasma/100)*0.25 + (state.photon/100)*0.10;
  return Math.min(1, 0.15 + 0.9*drive + 0.25*state.residual);
}

/* ======= Demo dynamics ======= */
let raf;
function loop(ts){
  if(!state.running || state.paused){ raf = requestAnimationFrame(loop); drawFrame(); return; }

  // advance time
  const dt = 0.05 * state.speed; // sim step
  state.t += dt;
  if(state.t >= state.TMAX){ state.running=false; log("Demo complete ‚Äî corridor stable and held for mission duration.","ok"); }

  // Leak model: if breach present, leak rises with residual; otherwise decays
  const hasBreach = state.breachSide!=="none";
  const targetLeak = hasBreach ? 0.60*(1 - state.stability) : 0.02;
  state.leak += (targetLeak - state.leak) * 0.05 * state.speed;

  // Pressure drops with leak; arrested by field intensity and gain (AEWFC)
  const arrest = Math.min(1, (fieldIntensity()*state.gain)*0.9);
  state.pressure += ((1 - state.leak) * 0.015 + arrest*0.02 - 0.02) * (hasBreach?0.7:1.0);
  state.pressure = Math.max(0, Math.min(1, state.pressure));

  // Gravity hold slightly disturbed by residuals; AEWFC corrects
  const gErr = 1 - state.ghold;
  state.ghold += (-gErr + 0.12*(arrest - state.residual)) * 0.05;

  // Residual falls when gain & fields are sufficient; rises if leak overwhelms
  const drive = (state.noise/140 + state.em/100 + state.plasma/100 + state.photon/100)/4;
  const dRes = (-0.03*drive*state.gain + 0.015*state.leak);
  state.residual = Math.max(0, Math.min(1, state.residual + dRes));

  // Stability increases as residual falls and pressure holds
  const sTarget = Math.max(0, Math.min(1, 0.25 + 0.6*(1 - state.residual) + 0.15*state.pressure - 0.1*state.leak));
  state.stability += (sTarget - state.stability) * 0.08;

  // Forbidden region proximity increases with overdrive; decrease as residual settles
  const over = Math.max(0, drive*state.gain - 0.9);
  const forbTarget = Math.min(1, 0.05 + 0.6*over + 0.15*state.residual);
  state.forbid += (forbTarget - state.forbid) * 0.06;

  // Auto mode: gently ramp controls to meet target stability
  if(state.auto && hasBreach){
    const need = 1 - state.stability;
    state.noise = Math.min(140, state.noise + 6*need);
    state.em    = Math.min(100, state.em + 3*need);
    state.plasma= Math.min(100, state.plasma + 2.5*need);
    state.photon= Math.min(100, state.photon + 1.5*need);
    // mirror to sliders/ui labels occasionally
    if(Math.random()<0.25){
      noise.value=state.noise; noiseV.textContent=`${Math.round(state.noise)} dB`;
      em.value=state.em; emV.textContent=`${Math.round(state.em)}%`;
      plasma.value=state.plasma; plasmaV.textContent=`${Math.round(state.plasma)}%`;
      photon.value=state.photon; photonV.textContent=`${Math.round(state.photon)}%`;
    }
  }

  // Scripted milestones
  scriptedMilestones();

  drawFrame();
  raf = requestAnimationFrame(loop);
}
function drawFrame(){
  // Gauges
  pressBar.style.width = (state.pressure*100).toFixed(0)+"%";
  gBar.style.width = Math.min(100, Math.max(0, state.ghold*100)).toFixed(0)+"%";
  stabBar.style.width = (state.stability*100).toFixed(0)+"%";
  forbidBar.style.width = (state.forbid*100).toFixed(0)+"%";
  pressPct.textContent = (state.pressure*100).toFixed(0)+"%";
  leakPct.textContent = (state.leak*100).toFixed(0)+"%";
  gHold.textContent = state.ghold.toFixed(2)+" g";
  resid.textContent = state.residual.toFixed(2);

  // Status badge
  let badge="‚Äî", lvl="warn";
  if(state.stability>0.80 && state.forbid<0.45 && state.pressure>0.85){ badge="Stable"; lvl="ok"; }
  else if(state.stability>0.50){ badge="At Risk"; lvl="warn"; }
  else { badge="Fail"; lvl="bad"; }
  setBadge(stabBadge, badge, lvl);

  forbidTxt.textContent = state.forbid<0.35 ? "Clear" : state.forbid<0.65 ? "Caution" : "Too High";

  // Clock and CST
  const mm = Math.floor(state.t/60), ss = Math.floor(state.t%60);
  clock.textContent = `${fmtTime(mm)}:${fmtTime(ss)}`;
  cst.textContent = nowCST().toLocaleString();

  // Draw viz
  drawViz();
}

/* ======= Scripted milestones for clarity ======= */
let lastMark = -1;
function scriptedMilestones(){
  const t = Math.floor(state.t);

  if(t!==lastMark){
    // Only log on first visit to each second
    lastMark=t;

    if(t===0){ log("Demo start ‚Äî monitoring nominal conditions.","ok"); }
    if(t===3){ log("Breach detected on PORT side ‚Äî pressure dropping, leak rising.","bad"); }
    if(t===4){ state.breachSide="port"; breachSide.value="port"; }
    if(t===6){ log("AEWFC: ramping acoustic / plasma / EM / photon on compromised side.","warn"); }
    if(t===10){ log(`Gain ${state.gain.toFixed(2)} engaged; feedback loop online.`,"ok"); }
    if(t===30){ log("Residual falling; gravity hold recovering.","ok"); }
    if(t===60){ log("Pressure approaching safe corridor; forbidden proximity nominal.","ok"); }
    if(t===120){ log("Stability > 0.70 ‚Äî maintaining hold during repair window.","ok"); }
    if(t===180){ log("Hull patch simulated ‚Äî leak trending down.","ok"); state.leak *= 0.7; }
    if(t===240){ log("Residual < 0.20 ‚Äî preparing to taper drive.","ok"); state.auto && (state.gain = Math.max(0.65, state.gain-0.1)); gain.value=state.gain; gainV.textContent=state.gain.toFixed(2); }
    if(t===299){ log("Mission window satisfied ‚Äî corridor remained stable.","ok"); }
  }
}

/* ======= Start/Reset/Export ======= */
function startDemo(){
  if(!state.running){
    resetDemo(false);
    state.running=true; state.paused=false;
    log("Starting 5-minute script. Speed: "+state.speed+"√ó","warn");
  }else{
    state.paused=false;
  }
}
function resetDemo(withLog=true){
  state.running=false; state.paused=false;
  state.t=0; state.speed=parseFloat(speed.value)||4;
  state.breachSide = breachSide.value;
  state.auto = autoMode.checked;
  state.noise=40; state.plasma=20; state.em=25; state.photon=15; state.gain=0.80;
  state.pressure=1.00; state.leak=0.00; state.ghold=1.00; state.stability=0.25; state.residual=0.50; state.forbid=0.10;

  // reset sliders UI
  noise.value=state.noise; noiseV.textContent=`${state.noise} dB`;
  plasma.value=state.plasma; plasmaV.textContent=`${state.plasma}%`;
  em.value=state.em; emV.textContent=`${state.em}%`;
  photon.value=state.photon; photonV.textContent=`${state.photon}%`;
  gain.value=state.gain; gainV.textContent=state.gain.toFixed(2);

  if(withLog){ logs.innerHTML=""; log("Reset complete.","warn"); }
  drawFrame();
}
function exportLog(){
  const lines = [...logs.querySelectorAll('div')].map(d=>d.textContent).join("\n");
  const blob = new Blob([lines], {type:"text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `FOBAS_AEWFC_log_${Date.now()}.txt`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* ======= Kickoff ======= */
resetDemo(false);
(function tickCST(){
  cst.textContent = nowCST().toLocaleString();
  setTimeout(tickCST, 1000);
})();
(function rafStart(){ raf = requestAnimationFrame(loop); })();
</script>
</body>
</html>
