<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Warp Control ‚Äî Even Grid + Compact Panels (v3.5)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#070b12; --panel:#0c1424; --glass:#0d1a31cc; --edge:#27406b;
    --text:#eaf2ff; --muted:#a7b9df; --good:#22c55e; --warn:#facc15; --bad:#ef4444;
    --ui-scale:1; --fs:14px; --pad:8px; --gap:8px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:
      radial-gradient(1200px 800px at 10% -10%, #112240 0%, transparent 60%),
      radial-gradient(900px 900px at 120% -20%, #0b1b33 0%, transparent 50%),
      var(--bg);
    color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;font-size:var(--fs);
  }
  .viewportScale{transform:scale(var(--ui-scale));transform-origin:top left;width:calc(100%/var(--ui-scale))}
  .wrap{max-width:1400px;margin:0 auto;padding:var(--pad)}
  .glass{background:linear-gradient(180deg,#0b1528aa,#0b152880),radial-gradient(600px 200px at 20% -30%,#15305f55,transparent 60%);backdrop-filter:blur(6px)}
  .panel{border:1px solid var(--edge);border-radius:12px;padding:calc(var(--pad) - 1px);box-shadow:0 10px 24px rgba(0,0,0,.42)}
  h1,h2,h3{margin:.35rem 0}
  .grid{display:grid;gap:var(--gap)}

  /* Even grid with tighter footprint */
  .evenGrid{
    display:grid;
    grid-template-columns: repeat(4, minmax(260px, 1fr));
    gap:var(--gap);
    align-items:start;
  }
  @media (max-width:1250px){ .evenGrid{ grid-template-columns: repeat(3, minmax(260px, 1fr)); } }
  @media (max-width:980px){ .evenGrid{ grid-template-columns: repeat(2, minmax(260px, 1fr)); } }
  @media (max-width:640px){ .evenGrid{ grid-template-columns: 1fr; } }

  .span-all{grid-column:1 / -1}

  .controls label{display:flex;align-items:center;gap:8px;margin:6px 0;color:var(--muted);font-size:.95rem}
  select,input[type="number"],input[type="range"]{background:#0b1220;color:#eaf2ff;border:1px solid #34425f;border-radius:8px;padding:6px 8px;font-size:.95rem}
  input[type="range"]{width:160px}
  button{background:#1b2a44;border:1px solid #304166;color:#e6eefc;padding:7px 9px;margin:3px;border-radius:8px;cursor:pointer}
  #startBtn{background:#00ccff;color:#00131a;border:none} #stopBtn{background:#64748b}
  #resetBtn{background:#fb923c;border:none} #exportBtn{background:#7c3aed;border:none}
  .lights{display:flex;gap:8px;flex-wrap:wrap}
  .light{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;font-size:.85rem}
  .dot{width:9px;height:9px;border-radius:50%}
  .good .dot{background:var(--good)} .warn .dot{background:var(--warn)} .bad .dot{background:var(--bad)}
  .meter{display:flex;align-items:center;gap:8px;margin:4px 0}
  .bar{height:9px;background:#0b1220;border:1px solid #334155;border-radius:6px;overflow:hidden;flex:1}
  .fill{height:100%;background:linear-gradient(90deg,#60a5fa,#22d3ee)}
  .stat{font-variant-numeric:tabular-nums;font-size:.86rem;color:var(--muted)}
  canvas{background:linear-gradient(180deg,#091323,#0a1322);border:1px solid #2b3a5a;border-radius:10px;max-width:100%;display:block}
  .pill{display:inline-block;padding:.1rem .4rem;border:1px solid #36507d;border-radius:999px;font-size:.8rem;color:#a5f3fc}
  .legend{color:var(--muted);font-size:.84rem;margin-top:6px}
  .hdrline{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .toggle{display:flex;align-items:center;gap:10px;color:#a7b9df;font-size:.9rem}
  .badge{border:1px solid #3b4f77;border-radius:999px;padding:2px 8px;color:#93c5fd;background:#0b1220}

  /* Clock cards OUTSIDE a big panel, compact and even */
  .clockSection{margin-top:6px}
  .clockHeader{display:flex;align-items:center;justify-content:space-between;margin:2px 0 6px}
  .clockGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap)}
  @media (max-width:1200px){ .clockGrid{grid-template-columns:repeat(3,1fr)} }
  @media (max-width:820px){ .clockGrid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:520px){ .clockGrid{grid-template-columns:1fr} }
  .clockCard{background:#0b1220;border:1px solid #304166;border-radius:12px;padding:8px;display:grid;gap:4px; align-content:start}
  .clockHdr{display:flex;justify-content:space-between;align-items:center}
  .clockTitle{font-weight:600}
  .status{font-size:.78rem;border:1px solid #36507d;border-radius:999px;padding:2px 6px}
  .status.good{color:#0f0;border-color:#256f2a} .status.warn{color:#222;background:#facc15} .status.bad{color:#fff;background:#ef4444}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:.84rem;color:#cfe2ff}

  /* Smaller canvases to waste less space, still readable */
  #curveCanvas{width:100%;height:200px}
  #orbitCanvas{width:100%;height:280px}
  #debrisCanvas{width:100%;height:180px}
  #starfieldCanvas{width:100%;height:160px;background:radial-gradient(160px 105px at 50% 60%, #0a1322 0%, #08101d 65%, #060d18 100%)}
  #shieldCanvas{width:100%;height:160px}
  #grCanvas{width:100%;height:110px}
</style>
</head>
<body>
<div class="viewportScale">
  <div class="wrap grid">
    <div class="hdrline">
      <h1>üöÄ Warp Control Center</h1>
      <div class="toggle">
        <label>UI Scale <input id="uiScale" type="range" min="70" max="120" value="90"> <span id="uiScaleVal" class="badge">90%</span></label>
        <label>Sound <input id="soundOn" type="checkbox" checked></label>
        <span class="badge">Even Grid Build v3.5</span>
      </div>
    </div>

    <!-- EVEN GRID PANELS (tighter, 4 columns on wide screens) -->
    <section class="evenGrid">
      <!-- 1 -->
      <div class="panel glass">
        <h2>Flight Plan</h2>
        <div class="grid" style="grid-template-columns:1fr 1fr;gap:6px">
          <label>Warp Speed
            <select id="warpSpeed"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option></select>
          </label>
          <label>Destination
            <select id="destination"><option>Mars</option><option>Jupiter</option><option>Saturn</option><option>Pluto</option></select>
          </label>
          <label>Warp Law (n) <input id="warpExp" type="number" step="0.1" value="3"></label>
          <label>Speed Scale (√óc) <input id="warpScale" type="number" step="0.1" value="1"></label>
          <label>IST Day 0 (yrs ago) <input id="istDay0Years" type="number" step="1" value="45500000000"></label>
          <label>Days / IST year <input id="baselineDaysPerYear" type="number" step="0.001" value="365.25"></label>
        </div>
        <div class="lights" style="margin-top:6px">
          <div class="light good" id="lightBubble"><span class="dot"></span>Bubble</div>
          <div class="light good" id="lightPower"><span class="dot"></span>Power</div>
          <div class="light good" id="lightVector"><span class="dot"></span>Vector</div>
          <div class="light good" id="lightNav"><span class="dot"></span>Nav</div>
        </div>
        <div style="margin-top:6px">
          <button id="startBtn">‚ñ∂Ô∏è Start</button>
          <button id="stopBtn">‚è∏Ô∏è Stop</button>
          <button id="resetBtn">üîÑ Engage Warp</button>
          <button id="exportBtn">üìÑ Export Log</button>
        </div>
        <div class="legend" id="beacon">‚è≥ Waiting‚Ä¶</div>
      </div>

      <!-- 2 -->
      <div class="panel glass">
        <h2>Gravity Vectoring Engine</h2>
        <div class="controls">
          <label>Reactor Output (MW) <input id="reactorMW" type="number" value="5000" step="50"></label>
          <label>Front Contraction % <input id="frontPct" type="range" min="0" max="100" value="35"><span class="stat" id="frontLbl"></span></label>
          <label>Rear Expansion % <input id="rearPct" type="range" min="0" max="100" value="65"><span class="stat" id="rearLbl"></span></label>
          <label>Left / Right Bias % <input id="lrBias" type="range" min="-50" max="50" value="0"><span class="stat" id="lrLbl"></span></label>
          <label>Up / Down Bias % <input id="udBias" type="range" min="-50" max="50" value="0"><span class="stat" id="udLbl"></span></label>
          <label>Intake Mode
            <select id="intakeMode">
              <option value="balanced">Balanced (¬±)</option>
              <option value="positive">Positive Gravity Capture</option>
              <option value="negative">Negative Gravity Capture</option>
            </select>
          </label>
        </div>
        <h3>Power Allocation</h3>
        <div class="meter"><span class="stat" style="width:120px">Field Coils</span><div class="bar"><div id="mCoils" class="fill" style="width:48%"></div></div><span class="stat" id="mCoilsVal"></span></div>
        <div class="meter"><span class="stat" style="width:120px">Vectoring Vanes</span><div class="bar"><div id="mVanes" class="fill" style="width:32%"></div></div><span class="stat" id="mVanesVal"></span></div>
        <div class="meter"><span class="stat" style="width:120px">Containment</span><div class="bar"><div id="mContain" class="fill" style="width:20%"></div></div><span class="stat" id="mContainVal"></span></div>
      </div>

      <!-- 3 -->
      <div class="panel glass">
        <h2>Trajectory & Field Vectors</h2>
        <canvas id="curveCanvas"></canvas>
        <div class="legend" id="curveLegend">‚Äî</div>
      </div>

      <!-- 4 -->
      <div class="panel glass">
        <h2>Heliocentric Polar Map (Now vs Arrival)</h2>
        <canvas id="orbitCanvas"></canvas>
        <div class="legend" id="orbitLegend">‚Äî</div>
      </div>

      <!-- 5 -->
      <div class="panel glass">
        <h2>Debris Defense Field</h2>
        <canvas id="debrisCanvas"></canvas>
        <div class="legend" id="debrisLegend">‚Äî</div>
      </div>

      <!-- 6 -->
      <div class="panel glass">
        <h2>Warp Starfield Window</h2>
        <canvas id="starfieldCanvas"></canvas>
        <div class="legend" id="starfieldLegend">‚Äî</div>
      </div>

      <!-- 7 -->
      <div class="panel glass">
        <h2>Shield Bubble Box</h2>
        <canvas id="shieldCanvas"></canvas>
        <div class="legend" id="shieldLegend">‚Äî</div>
      </div>

      <!-- 8 -->
      <div class="panel glass">
        <h2>Einstein Tensor Mini</h2>
        <canvas id="grCanvas"></canvas>
        <div class="legend" id="grMini">G<sub>ŒºŒΩ</sub> ‚âà (curvature proxies) ‚Ä¢ EM energy density used for T<sub>ŒºŒΩ</sub> (NEC/WEC/SEC OK unless g<sub>tt</sub>‚â§0)</div>
        <div class="legend">g<sub>tt</sub> min: <span id="gr_gtt">‚Äî</span> ‚Ä¢ œÅ<sub>em</sub> min/max: <span id="gr_rho">‚Äî</span> ‚Ä¢ EC: <span id="gr_ec">‚Äî</span> ‚Ä¢ Horizons: <span id="gr_hor">‚Äî</span></div>
      </div>

      <!-- 9 (compact info cards) -->
      <div class="panel glass span-all">
        <h2>IST Orbital Tracker (Live)</h2>
        <div id="orbit-rows" class="grid" style="grid-template-columns:repeat(4,1fr);gap:var(--gap)"></div>
      </div>

    </section>

    <!-- 10: CLOCKS moved OUT of a big panel, evenly spaced cards -->
    <section class="clockSection span-all">
      <div class="clockHeader">
        <h2>Clock Sync (C1‚ÄìC5) + Arrival CST/IST</h2>
        <span class="badge">Compact view</span>
      </div>
      <div class="clockGrid" id="clockGrid"></div>
    </section>

  </div>
</div>

<script>
/* ====== Constants / helpers ====== */
const AU_M=1.495978707e11, C_MPS=299792458, G=6.67430e-11, MU0=4*Math.PI*1e-7;
const orbitAU={ Earth:1.0, Mars:1.524, Jupiter:5.204, Saturn:9.582, Pluto:39.48 };
const orbitalDays={ Mercury:87.969, Venus:224.701, Earth:365.256, Mars:686.980, Jupiter:4332.59, Saturn:10759.22, Uranus:30685, Neptune:60190, Pluto:90560 };
const formationOffsetMyr={ Sun:0, Mercury:5, Venus:30, Earth:27, Mars:10, Jupiter:1, Saturn:3, Uranus:15, Neptune:20, Pluto:30 };
const $=id=>document.getElementById(id);
let ac=null; function tone(kind="good"){ if(!$("soundOn").checked) return; if(!ac){try{ac=new (window.AudioContext||window.webkitAudioContext)();}catch{}}
  if(!ac) return; const o=ac.createOscillator(), g=ac.createGain(); o.type="sine"; o.frequency.value= kind==="good"?880:kind==="warn"?520:320;
  g.gain.value=.001; o.connect(g).connect(ac.destination); o.start();
  g.gain.exponentialRampToValueAtTime(.07, ac.currentTime+.02); g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+.18); o.stop(ac.currentTime+.2);
}
function setLight(el,level){ const was=el.dataset.level||"good"; if(was!==level){ el.dataset.level=level; el.classList.remove("good","warn","bad"); el.classList.add(level); tone(level==="good"?"good":level==="warn"?"warn":"bad"); } }

/* ====== IST time, orbits ====== */
let tIST0=performance.now();
function IST_INPUT(){ return Number($("istDay0Years").value||45500000000); }
function DPY_INPUT(){ return Number($("baselineDaysPerYear").value||365.25); }
function IST_snapshot(){ const dpy=DPY_INPUT(), spy=dpy*86400; const elapsed=(performance.now()-tIST0)/1000/spy; const istYears=IST_INPUT()+elapsed, istDays=istYears*dpy; return {istYears, istDays, dpy, spy}; }
function planetAgeYears(name,iy){ return Math.max(0, iy - (formationOffsetMyr[name]||0)*1e6); }
function trueAnomalyFrac(name,iy,dpy){ const py=planetAgeYears(name,iy), pd=py*dpy, T=orbitalDays[name]; if(!T) return 0; const N=pd/T; return N-Math.floor(N); }
function orbitsFor(name,pd){ const T=orbitalDays[name]; if(!T) return null; const tot=pd/T, comp=Math.max(0,Math.floor(tot)), frac=tot-comp, daysInto=frac*T; return {totalOrbits:tot,completed:comp,frac,daysInto,yearLen:T}; }

/* ====== Engine dynamics ====== */
let simulationRunning=false, shipProgress=0, shipArrived=false;
let driftInterval=null, beaconInterval=null, orbitInterval=null, animationFrame=null, lastFrameTime=performance.now();
const engineState={ t:0, temp:0, sag:0, containNeed:0.22, jitter:0 };
function stepEngineDynamics(dt, running){
  if(!running){ engineState.temp=Math.max(0,engineState.temp-0.30*dt); engineState.sag=Math.max(0,engineState.sag-0.25*dt); engineState.jitter*=0.85; engineState.containNeed=0.22+0.06*engineState.temp; return; }
  engineState.t+=dt; engineState.temp=Math.min(1,engineState.temp+0.06*dt);
  const baseSag=0.02+0.04*engineState.temp, ripple=0.01*Math.sin(0.7*engineState.t);
  engineState.sag=Math.max(0, baseSag + ripple);
  engineState.containNeed=0.22+0.06*engineState.temp;
  const biasMag=Math.hypot(Number($("lrBias").value||0)/100, Number($("udBias").value||0)/100);
  engineState.jitter = 0.01 + 0.03*biasMag + 0.01*Math.sin(3*engineState.t) + 0.006*(Math.random()-0.5);
  engineState.jitter = Math.max(0, Math.min(0.08, engineState.jitter));
}
function warpInputs(){ return { warp:Number($("warpSpeed").value||1), exp:Number($("warpExp").value||3), scale:Number($("warpScale").value||1) }; }
function engineInputs(){
  const reactorMW_in=Number($("reactorMW").value||5000);
  const front=Number($("frontPct").value||0)/100, rear=Number($("rearPct").value||0)/100;
  const lr=Number($("lrBias").value||0)/100, ud=Number($("udBias").value||0)/100;
  const mode=$("intakeMode").value;
  const reactorMW = reactorMW_in * (1 - engineState.sag);

  const vecDemand=Math.min(1, 0.4 + 0.6*(Math.abs(lr)+Math.abs(ud)+Math.abs(rear-front)));
  let coilsPct=Math.max(0.35, 0.55 - 0.25*vecDemand);
  let containPct=Math.max(engineState.containNeed, 0.20);
  let vanesPct=Math.min(0.35, 1 - coilsPct - containPct);
  const sum=coilsPct+containPct+vanesPct; if(sum>1){ const k=1/sum; coilsPct*=k; containPct*=k; vanesPct*=k; }

  $("mCoils").style.width=`${coilsPct*100}%`; $("mCoilsVal").textContent=`${(coilsPct*reactorMW).toFixed(0)} MW`;
  $("mVanes").style.width=`${vanesPct*100}%`; $("mVanesVal").textContent=`${(vanesPct*reactorMW).toFixed(0)} MW`;
  $("mContain").style.width=`${containPct*100}%`; $("mContainVal").textContent=`${(containPct*reactorMW).toFixed(0)} MW`;

  let stability=1.0;
  if (containPct < engineState.containNeed) stability -= 0.40*(engineState.containNeed - containPct)/engineState.containNeed;
  const biasMag=Math.hypot(lr,ud); stability -= 0.30*Math.max(0, biasMag-0.3)/0.7;
  if (rear<front) stability -= 0.20*(front-rear);
  if (mode==="positive" && rear<front) stability -= 0.05;
  if (mode==="negative" && rear>front) stability -= 0.05;
  stability -= engineState.jitter;
  stability = Math.max(0, Math.min(1, stability));

  const grad=Math.max(0,(rear-front));
  let gradBoost=coilsPct*(0.5+0.5*grad);
  gradBoost *= (1 - 0.20*engineState.temp);
  const gradientFactor = stability * (0.35 + 0.9*gradBoost);

  setLight($("lightBubble"), stability>0.75?"good":stability>0.45?"warn":"bad");
  setLight($("lightPower"), "good");
  setLight($("lightVector"), biasMag<0.6?"good":biasMag<0.85?"warn":"bad");

  $("frontLbl").textContent=Math.round(front*100)+"%";
  $("rearLbl").textContent =Math.round(rear*100)+"%";
  $("lrLbl").textContent   =Math.round(lr*100)+"%";
  $("udLbl").textContent   =Math.round(ud*100)+"%";

  return {reactorMW, front, rear, lr, ud, coilsPct, containPct, vanesPct, gradientFactor, stability, mode};
}

/* ====== ETA / distance ====== */
function computeETASeconds(){
  const { istYears, dpy } = IST_snapshot();
  const dest=$("destination").value;
  const { warp, exp, scale } = warpInputs();
  const eng=engineInputs();
  const thE=trueAnomalyFrac("Earth",istYears,dpy)*Math.PI*2;
  const thD=trueAnomalyFrac(dest, istYears,dpy)*Math.PI*2;
  const r1=orbitAU.Earth, r2=orbitAU[dest];
  const dAU=Math.sqrt(r1*r1+r2*r2-2*r1*r2*Math.cos(thD-thE));
  const v=C_MPS*scale*Math.pow(warp,exp)*Math.max(0.05,eng.gradientFactor);
  const eta = (dAU*AU_M)/Math.max(v,1e-3);
  setLight($("lightNav"), isFinite(eta)?(eta<86400?"good":"warn"):"bad");
  return { eta, dAU, v, thE, thD, r1, r2 };
}

/* ====== Orbit Tracker (compact 4 cards) ====== */
function updateOrbitTable(){
  const {istYears,dpy}=IST_snapshot();
  const dest=$("destination").value;

  const sY=planetAgeYears("Sun",istYears), sD=sY*dpy;
  const eY=planetAgeYears("Earth",istYears), eD=eY*dpy;
  const eO=orbitsFor("Earth", eD)||{completed:0,frac:0,daysInto:0,yearLen:365.256};
  const pY=planetAgeYears(dest,istYears), pD=pY*dpy;
  const pO=orbitsFor(dest,pD)||{completed:0,frac:0,daysInto:0,yearLen:orbitalDays[dest]||0};

  const {eta,dAU,v}=computeETASeconds();
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";

  const card=(title,lines)=>`
    <div class="panel" style="background:#0b1220;border:1px solid #304166;padding:8px">
      <div style="font-weight:600;margin-bottom:4px">${title}</div>
      ${lines.map(t=>`<div class="stat">${t}</div>`).join("")}
    </div>`;
  $("orbit-rows").innerHTML = [
    card("Sun", [
      `${(sY/1e9).toFixed(6)} Ga`,
      `${Math.floor(sY).toLocaleString()} y`,
      `${Math.floor(sD).toLocaleString()} d`
    ]),
    card("Earth", [
      `Orbits: ${eO.completed.toLocaleString()}`,
      `Progress: <span class="pill">${(eO.frac*100).toFixed(1)}%</span>`,
      `Day ${Math.floor(eO.daysInto)} / ${Math.floor(eO.yearLen)}`
    ]),
    card(dest, [
      `Age: ${(pY/1e9).toFixed(6)} Ga`,
      `Orbits: ${pO.completed.toLocaleString()}`,
      `Day ${Math.floor(pO.daysInto)} / ${Math.floor(pO.yearLen)}`
    ]),
    card("Trip", [
      `Dist: ${dAU.toFixed(3)} AU`,
      `v: ${(v/C_MPS).toFixed(2)} c`,
      `ETA: ${etaStr}`
    ])
  ].join("");
}

/* ====== Polar Map (auto-zoom) ====== */
const orbitCanvas=$("orbitCanvas"), octx=orbitCanvas.getContext("2d");
function drawOrbitView(){
  const {istYears,dpy}=IST_snapshot(); const dest=$("destination").value;
  const {eta, thE, thD, r1, r2}=computeETASeconds();
  const w=orbitCanvas.width=orbitCanvas.clientWidth, h=orbitCanvas.height=orbitCanvas.clientHeight, cx=w/2, cy=h/2, minDim=Math.min(w,h);

  const maxR = Math.max(r1, r2);
  const RmaxPx = Math.max(120, minDim*0.38);
  const scale = RmaxPx / Math.max(maxR, 0.01);

  octx.clearRect(0,0,w,h);

  // Sun
  octx.beginPath(); octx.arc(cx,cy,7,0,Math.PI*2); octx.fillStyle="#ffb703"; octx.fill();
  octx.fillStyle="#cfe2ff"; octx.fillText("Sun",cx-14,cy-12);

  // Orbits
  const rE=r1*scale, rD=r2*scale;
  octx.beginPath(); octx.arc(cx,cy,rE,0,Math.PI*2); octx.strokeStyle="#6aa9ff"; octx.lineWidth=1; octx.stroke();
  octx.beginPath(); octx.arc(cx,cy,rD,0,Math.PI*2); octx.strokeStyle="#ffffff"; octx.lineWidth=1.1; octx.stroke();

  // Now positions
  const Ex=cx+rE*Math.cos(thE), Ey=cy+rE*Math.sin(thE);
  const Dx=cx+rD*Math.cos(thD), Dy=cy+rD*Math.sin(thD);
  octx.beginPath(); octx.arc(Ex,Ey,3.5,0,Math.PI*2); octx.fillStyle="#22d3ee"; octx.fill();
  octx.beginPath(); octx.arc(Dx,Dy,3.5,0,Math.PI*2); octx.fillStyle="#22c55e"; octx.fill();

  // Arrival
  const Td=orbitalDays[dest]*86400, dTh=(eta/Td)*Math.PI*2;
  const thArr=(thD+dTh)%(Math.PI*2);
  const Ax=cx+rD*Math.cos(thArr), Ay=cy+rD*Math.sin(thArr);
  octx.beginPath(); octx.arc(Ax,Ay,4.5,0,Math.PI*2); octx.fillStyle="#16a34a"; octx.fill();

  // Labels
  octx.fillStyle="#9fb4d9"; octx.fillText("Earth r="+r1.toFixed(2)+" AU", cx+rE+6, cy-2);
  octx.fillStyle="#9fd9b1"; octx.fillText(dest+" r="+r2.toFixed(2)+" AU", cx+rD+6, cy+12);

  const degNow=(thD*180/Math.PI+360)%360, degArr=(thArr*180/Math.PI+360)%360; let d=degArr-degNow; if(d<0)d+=360;
  $("orbitLegend").textContent=`Now ${degNow.toFixed(1)}¬∞ ‚Üí ETA ${degArr.toFixed(1)}¬∞ ‚Ä¢ Œî ${d.toFixed(1)}¬∞`;
}

/* ====== Curve & vectors (smaller) ====== */
const curveCanvas=$("curveCanvas"), ctx=curveCanvas.getContext("2d");
function drawCurve(){
  const w=curveCanvas.width=curveCanvas.clientWidth, h=curveCanvas.height=curveCanvas.clientHeight;
  const warp=Number($("warpSpeed").value||1); const eng=engineInputs();
  const arcHeight=Math.max(32, 60/Math.max(1, warp*(0.8+0.6*eng.stability)));
  const startX=60, endX=w-60, baseY=h-46;

  ctx.clearRect(0,0,w,h);
  const dest=$("destination").value;
  ctx.beginPath(); ctx.arc(startX,baseY,7,0,Math.PI*2); ctx.fillStyle="#3b82f6"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText("Earth", startX-20, baseY+18);
  ctx.beginPath(); ctx.arc(endX,baseY,6.5,0,Math.PI*2); ctx.fillStyle="#f59e0b"; ctx.fill();
  ctx.fillStyle="#cfe2ff"; ctx.fillText(dest, endX-22, baseY+18);

  ctx.beginPath(); ctx.moveTo(startX,baseY);
  ctx.quadraticCurveTo((startX+endX)/2, baseY-arcHeight*3, endX, baseY);
  ctx.strokeStyle="#ef4444"; ctx.lineWidth=2; ctx.stroke();

  const t=shipProgress, mx=(startX+endX)/2, ctrlY=baseY-arcHeight*3;
  const sx=(1-t)**2*startX + 2*(1-t)*t*mx + t**2*endX;
  const sy=(1-t)**2*baseY   + 2*(1-t)*t*ctrlY + t**2*baseY;
  ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2);
  ctx.fillStyle = shipArrived ? "#22c55e" : "#67e8f9"; ctx.shadowColor=ctx.fillStyle; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;

  const arrow=(x,y,dx,dy,color)=>{ const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const ex=x+dx, ey=y+dy;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ex,ey); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-6*ux+3*uy,ey-6*uy-3*ux); ctx.lineTo(ex-6*ux-3*uy,ey-6*uy+3*ux); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); };
  const f=$("frontPct").value/100, r=$("rearPct").value/100, lr=$("lrBias").value/100, ud=$("udBias").value/100; const k=Math.min(44, h*0.18);
  arrow(sx,sy, 0,-k*r,"#22c55e");
  arrow(sx,sy, 0, k*f,"#f97316");
  arrow(sx,sy, k*lr,0,"#8b5cf6");
  arrow(sx,sy, 0,-k*ud,"#38bdf8");

  $("curveLegend").textContent=`Rear ${Math.round(r*100)}% ‚Ä¢ Front ${Math.round(f*100)}% ‚Ä¢ LR ${Math.round(lr*100)}% ‚Ä¢ UD ${Math.round(ud*100)}%`;
}

/* ====== Clocks ====== */
const clocks=[
  { id:"C1", location:"Biometric", purpose:"Crew/Local", drift:0 },
  { id:"C2", location:"Warp Edge", purpose:"Phase Monitor", drift:3 },
  { id:"C3", location:"NavCore",   purpose:"Navigation", drift:0 },
  { id:"C4", location:"CST Earth", purpose:"Master Anchor", drift:0 },
  { id:"C5", location:"DriftEye",  purpose:"Diagnostics", drift:-6 }
];
function fmtClock(ms){ return new Date(ms).toISOString().substr(11,12); }
function renderClockCards(arrISTstr, arrCSTms){
  const grid=$("clockGrid"); grid.innerHTML="";
  const base=Date.now(); let total=0;
  clocks.forEach(c=>{
    if(simulationRunning) c.drift += Math.random()*2 - 1;
    const local=base + c.drift; const d=c.drift.toFixed(2); total += Math.abs(c.drift);
    let status="good", label="‚úÖ Synced"; if(Math.abs(c.drift)>5){status="warn"; label="‚ö† Drift";} if(Math.abs(c.drift)>10){status="bad"; label="‚ùå Unsafe";}
    const card=document.createElement("div");
    card.className="clockCard";
    card.innerHTML=`
      <div class="clockHdr">
        <div class="clockTitle">${c.id} ‚Ä¢ ${c.location}</div>
        <div class="status ${status}">${label}</div>
      </div>
      <div class="kv">
        <div>Purpose</div><div>${c.purpose}</div>
        <div>CST</div><div>${fmtClock(base)}</div>
        <div>Local</div><div>${fmtClock(local)}</div>
        <div>Œî</div><div>${d} ms</div>
        <div>Arrival CST</div><div>${fmtClock(arrCSTms)}</div>
        <div>Arrival IST</div><div>${arrISTstr}</div>
      </div>`;
    grid.appendChild(card);
  });
  return total/clocks.length;
}

/* ====== GR (Einstein Tensor Mini) ====== */
const grCanvas = $("grCanvas"), grx = grCanvas.getContext("2d");
const GR = { nx: 120, ny: 48, L: 900, sigma: 150, scalePhi: 1.0e10 };
function buildPotentialGrid(){
  const eng=engineInputs(); const front=eng.front, rear=eng.rear, lr=eng.lr, ud=eng.ud;
  const nx=GR.nx, ny=GR.ny, L=GR.L, dx=L/nx, dy=L/ny, s2=GR.sigma*GR.sigma;
  const A_r = rear*1.2e14, A_f = front*1.2e14;
  const x0 = 180 + 110*rear, y0 =  70*ud, xskew = 70*lr;
  const phi = new Float64Array(nx*ny);
  for(let j=0;j<ny;j++){
    const y=(j-ny/2)*dy;
    for(let i=0;i<nx;i++){
      const x=(i-nx/2)*dx;
      const rRear2=(x + x0 + xskew)**2 + (y - y0)**2;
      const rFront2=(x - x0 + xskew)**2 + (y + y0)**2;
      phi[i+j*nx] = (-A_r*Math.exp(-rRear2/s2) + A_f*Math.exp(-rFront2/s2))/GR.scalePhi;
    }
  }
  return {phi, dx, dy};
}
function laplacian(phi,i,j,nx,ny,dx,dy){ const idx=i+j*nx,c=phi[idx]; const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx]; const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx]; return (l-2*c+r)/(dx*dx)+(u-2*c+d)/(dy*dy); }
function grad2(phi,i,j,nx,ny,dx,dy){ const l=phi[(i>0?i-1:0)+j*nx], r=phi[(i<nx-1?i+1:nx-1)+j*nx]; const u=phi[i+(j>0?j-1:0)*nx], d=phi[i+(j<ny-1?j+1:ny-1)*nx]; const gx=(r-l)/(2*dx), gy=(d-u)/(2*dy); return {gx,gy,g2:gx*gx+gy*gy}; }
function validateGR(){
  const {phi, dx, dy} = buildPotentialGrid();
  const nx=GR.nx, ny=GR.ny;
  let gttMin=+1, phiMin=+1e99, phiMax=-1e99;
  for(let k=0;k<phi.length;k++){ const v=phi[k]; if(v<phiMin)phiMin=v; if(v>phiMax)phiMax=v; }
  const span=Math.max(1e-12, phiMax-phiMin);

  grCanvas.width=grCanvas.clientWidth; grCanvas.height=110; grx.clearRect(0,0,grCanvas.width,grCanvas.height);

  let rhoMin=+1e99, rhoMax=-1e99, horizons=0;

  for(let j=1;j<ny-1;j++){
    for(let i=1;i<nx-1;i++){
      const lap = laplacian(phi,i,j,nx,ny,dx,dy);
      const {g2} = grad2(phi,i,j,nx,ny,dx,dy);
      const E2=g2; const rho_em = E2/(2*MU0*C_MPS*C_MPS); if(rho_em<rhoMin)rhoMin=rho_em; if(rho_em>rhoMax)rhoMax=rho_em;
      const ph=phi[i+j*nx]; const gtt=1 + 2*ph/(C_MPS*C_MPS); if(gtt<gttMin)gttMin=gtt; if(gtt<=0)horizons++;

      if(j===Math.floor(ny/2)){
        const x=Math.floor((i/nx)*grCanvas.width), t=(ph - phiMin)/span; const r=Math.floor(255*Math.max(0,2*t-1)), b=Math.floor(255*Math.max(0,1-2*t)); grx.fillStyle=`rgb(${r},0,${b})`; grx.fillRect(x,0,2,110);
      }
    }
  }
  $("gr_gtt").textContent = gttMin.toFixed(6);
  $("gr_rho").textContent = `${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}`;
  $("gr_ec").textContent  = `‚úÖ NEC ‚Ä¢ ‚úÖ WEC ‚Ä¢ ‚úÖ SEC`;
  $("gr_hor").textContent = horizons>0 ? `‚ö† ${horizons}` : "None";
}

/* ====== Starfield ====== */
(function(){
  const cvs=$("starfieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const STAR_COUNT=160, STAR_MIN_Z=0.15, STAR_MAX_Z=1.0, DIR={x:0,y:1}, bubble={ r:40, glow:12 }, ship={ w:11, h:16 };
  const stars=new Array(STAR_COUNT).fill(0).map(seed); let raf=null, last=performance.now(), paused=false;
  function seed(){ return {x:(Math.random()*W())-0.5*W(), y:(Math.random()*H())-0.5*H(), z:STAR_MIN_Z+Math.random()*(STAR_MAX_Z-STAR_MIN_Z), tw:Math.random()*Math.PI*2}; }
  function rec(s){ s.x=(Math.random()*W())-0.5*W(); s.y=-0.55*H(); s.z=STAR_MIN_Z+Math.random()*(STAR_MAX_Z-STAR_MIN_Z); s.tw=Math.random()*Math.PI*2; }
  function speedFactor(){ let warp=Number($("warpSpeed").value||1); let grad=0.6; try{ const e=engineInputs(); grad=Math.max(0.05,Math.min(1.2,e.gradientFactor)); }catch{} return Math.pow(Math.max(1,warp),1.35)*grad; }
  function step(dt){ const flow=26*speedFactor(); for(const s of stars){ const v=flow*(1.2-0.8*s.z); s.x+=DIR.x*v*dt; s.y+=DIR.y*v*dt; s.tw+=3.2*dt; if(s.y>0.58*H()) rec(s); } }
  function draw(){
    ctx.clearRect(0,0,W(),H()); ctx.save(); ctx.translate(CX(),CY());
    const vis=speedFactor(); const streak=1.0+(vis/12)*(26/100);
    for(const s of stars){ const sz=1+1.5*(1-s.z), a=0.35+0.55*Math.abs(Math.sin(s.tw)); const bright=Math.min(1,a+0.25*(1-s.z));
      ctx.fillStyle=`rgba(255,255,255,${bright})`; ctx.fillRect(s.x,s.y,sz,sz);
      ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(s.x-DIR.x*streak*7*(1-s.z), s.y-DIR.y*streak*7*(1-s.z));
      ctx.strokeStyle=`rgba(200,220,255,${0.22+0.42*(1-s.z)})`; ctx.lineWidth=1; ctx.stroke();
    }
    ctx.restore();
    const cx=CX(), cy=CY();
    const g=ctx.createRadialGradient(cx,cy,bubble.r*0.6, cx,cy,bubble.r+bubble.glow); g.addColorStop(0,"rgba(120,220,255,0.18)"); g.addColorStop(1,"rgba(80,180,255,0.02)");
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,bubble.r + bubble.glow,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx,cy,bubble.r,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.2; ctx.stroke();
    ctx.save(); ctx.translate(cx,cy+3); ctx.beginPath(); ctx.moveTo(0,-ship.h*0.9); ctx.lineTo(ship.w*0.55,ship.h*0.8); ctx.lineTo(-ship.w*0.55,ship.h*0.8); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill();
    ctx.beginPath(); ctx.moveTo(0,-ship.h*0.55); ctx.lineTo(0,ship.h*0.6); ctx.strokeStyle="#60a5fa"; ctx.lineWidth=1; ctx.stroke(); ctx.restore();
    $("starfieldLegend").textContent=`Visual √ó${vis.toFixed(2)} (warp ${$("warpSpeed").value})`;
  }
  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.starfieldControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Debris + Shield integration ====== */
(function(){
  const cvs=$("debrisCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  let last=performance.now(), raf=null, paused=false;
  const bubble={ r:46 }; const debris=[]; const MAX_DEBRIS=24;
  function seed(){ debris.length=0; for(let i=0;i<MAX_DEBRIS;i++){ const ang=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100;
    debris.push({ x:CX()+R*Math.cos(ang), y:CY()+R*Math.sin(ang), vx:-(38+Math.random()*55)*Math.cos(ang), vy:-(38+Math.random()*55)*Math.sin(ang), q:(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7), alive:true }); } }
  seed();
  function alloc(){ const e=engineInputs(); const tot=e.reactorMW||5000; const {warp}=warpInputs(); const g=e.gradientFactor||0.5;
    let pre=Math.min(.50,.25+.03*warp+.2*g), skin=Math.min(.35,.20+.10*g), grid=Math.max(.10,1-pre-skin); return { MW:{pre:pre*tot, skin:skin*tot, grid:grid*tot}, frac:{pre,skin,grid} }; }
  function step(dt){
    const {MW,frac}=alloc(); const preF=6*Math.sqrt(MW.pre+1), skinB=4*Math.sqrt(MW.skin+1);
    for(const d of debris){ if(!d.alive) continue; const dx=d.x-CX(), dy=d.y-CY(), r=Math.hypot(dx,dy)+1e-6, nx=dx/r, ny=dy/r;
      if(ny<-0.2){ d.vx+=nx*preF*dt*0.08; d.vy+=ny*preF*dt*0.08; }
      if(r<bubble.r*1.5 && Math.abs(d.q)>0){ const kick=skinB*0.12*dt, tx=-ny, ty=nx; d.vx+=tx*kick*Math.sign(d.q); d.vy+=ty*kick*Math.sign(d.q); }
      if(r<bubble.r*1.06){ const hitProb=Math.min(0.95,0.25+frac.grid*0.8); const ang=Math.atan2(dy,dx);
        if(window.shieldBox && window.shieldBox.hit){ const intensity=Math.min(1, (Math.hypot(d.vx,d.vy)/110)); window.shieldBox.hit(ang,intensity); }
        if(Math.random()<hitProb) d.alive=false; }
      d.x+=d.vx*dt; d.y+=d.vy*dt;
      if(!d.alive || d.x<-180 || d.x>W()+180 || d.y<-180 || d.y>H()+180){ if(Math.random()<0.02){ const a=Math.random()*Math.PI*2, R=Math.max(W(),H())*0.55+Math.random()*100; d.x=CX()+R*Math.cos(a); d.y=CY()+R*Math.sin(a); d.vx=-(38+Math.random()*55)*Math.cos(a); d.vy=-(38+Math.random()*55)*Math.sin(a); d.q=(Math.random()<.5?-1:1)*(1e-9+Math.random()*1e-7); d.alive=true; } }
    }
    const ahead=debris.filter(d=>d.alive && d.y<CY()-bubble.r*1.4 && Math.abs(d.x-CX())<bubble.r*1.1);
    const hold=ahead.length>6, adjust=!hold && ahead.length>3; let msg=`Defense MW ‚Äî Pre:${MW.pre.toFixed(0)} | Skin:${MW.skin.toFixed(0)} | Grid:${MW.grid.toFixed(0)} `;
    msg += hold? "‚Ä¢ HOLD":"‚Ä¢ "+(adjust?"ADJUST":"CLEAR"); $("debrisLegend").textContent=msg; if(hold) setLight($("lightNav"),"warn");
  }
  function draw(){
    ctx.clearRect(0,0,W(),H());
    ctx.beginPath(); ctx.arc(CX(),CY(),bubble.r,0,Math.PI*2); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=1.3; ctx.stroke();
    // cone
    ctx.beginPath(); ctx.moveTo(CX(),CY()); ctx.arc(CX(),CY(), bubble.r*2.2, -Math.PI*0.95, -Math.PI*0.05, false); ctx.closePath();
    ctx.fillStyle="rgba(252,211,77,.15)"; ctx.fill();
    // halo
    ctx.beginPath(); ctx.arc(CX(),CY(),bubble.r*1.15,0,Math.PI*2); ctx.strokeStyle="rgba(56,189,248,.18)"; ctx.lineWidth=8; ctx.stroke();
    // grid dots
    for(let i=0;i<12;i++){ const a=Math.random()*Math.PI*2; const rx=CX()+bubble.r*1.03*Math.cos(a), ry=CY()+bubble.r*1.03*Math.sin(a); ctx.fillStyle="rgba(99,102,241,.2)"; ctx.beginPath(); ctx.arc(rx,ry,2,0,Math.PI*2); ctx.fill(); }
    // ship
    ctx.beginPath(); ctx.arc(CX(),CY(),3.3,0,Math.PI*2); ctx.fillStyle="#cfe2ff"; ctx.fill();
    // debris
    for(const d of debris){ if(!d.alive) continue; ctx.fillStyle=Math.abs(d.q)>0?"#fca5a5":"#e5e7eb"; ctx.beginPath(); ctx.arc(d.x,d.y,1.6,0,Math.PI*2); ctx.fill(); }
  }
  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; step(dt); draw(); raf=requestAnimationFrame(loop); }
  window.debrisControl={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); } };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Shield Box (sector integrity) ====== */
(function(){
  const cvs=$("shieldCanvas"); if(!cvs) return; const ctx=cvs.getContext("2d");
  const W=()=>{cvs.width=cvs.clientWidth; return cvs.width;}, H=()=>{cvs.height=cvs.clientHeight; return cvs.height;}, CX=()=>W()/2, CY=()=>H()/2;
  const SECT=12; const sectors=new Array(SECT).fill(1); let flashes=[]; let paused=false, raf=null, last=performance.now();
  function warpScale(){ const w=Number(($("warpSpeed").value)||1); return Math.min(1.3, 0.82 + 0.05*w); }
  function bubbleRadius(){ return 36*warpScale(); }
  function repair(dt){ for(let i=0;i<SECT;i++){ sectors[i]=Math.min(1, sectors[i]+0.08*dt); } flashes=flashes.filter(f=>{ f.t-=dt; return f.t>0; }); }
  function draw(){
    const cx=CX(), cy=CY(), R=bubbleRadius(); cvs.width=W(); cvs.height=H();
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const glow=ctx.createRadialGradient(cx,cy,R*.6, cx,cy,R+12); glow.addColorStop(0,`rgba(120,220,255,${0.1+0.12*sectors.reduce((a,b)=>a+b,0)/SECT})`); glow.addColorStop(1,"rgba(80,180,255,0.02)");
    ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(cx,cy,R+12,0,Math.PI*2); ctx.fill();
    for(let i=0;i<SECT;i++){ const t0=(i/SECT)*Math.PI*2, t1=((i+1)/SECT)*Math.PI*2, s=sectors[i];
      ctx.beginPath(); ctx.arc(cx,cy,R, t0,t1); ctx.strokeStyle=s>0.66?"#7dd3fc":s>0.33?"#facc15":"#ef4444"; ctx.lineWidth=2.2+2.2*s; ctx.stroke();}
    ctx.beginPath(); ctx.moveTo(cx, cy-R*0.65); ctx.lineTo(cx+9, cy+10); ctx.lineTo(cx-9, cy+10); ctx.closePath(); ctx.fillStyle="#cfe2ff"; ctx.fill();
    for(const f of flashes){ const a=Math.max(0,Math.min(1,f.t/.25)); ctx.beginPath(); ctx.arc(f.x,f.y, 5+9*(1-a), 0,Math.PI*2); ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.8; ctx.stroke(); }
    $("shieldLegend").textContent=`Shield ${(sectors.reduce((a,b)=>a+b,0)/SECT*100).toFixed(0)}% ‚Ä¢ R ${R.toFixed(1)} ‚Ä¢ warp ${$("warpSpeed").value}`;
  }
  function loop(n){ if(paused) return; const dt=Math.min(0.05,(n-last)/1000); last=n; repair(dt); draw(); raf=requestAnimationFrame(loop); }
  function hit(theta,intensity){ const rot=theta+Math.PI/2; let idx=Math.floor((((rot%(2*Math.PI))+2*Math.PI)%(2*Math.PI))/(2*Math.PI)*SECT); idx=Math.max(0,Math.min(SECT-1,idx)); sectors[idx]=Math.max(0,sectors[idx]-0.35*Math.max(0.2,intensity)); const R=bubbleRadius(); flashes.push({x:CX()+R*Math.cos(theta), y:CY()+R*Math.sin(theta), t:.25}); }
  window.shieldBox={ start(){ if(paused){ paused=false; last=performance.now(); raf=requestAnimationFrame(loop);} }, stop(){ paused=true; if(raf) cancelAnimationFrame(raf); }, hit };
  paused=false; last=performance.now(); raf=requestAnimationFrame(loop);
})();

/* ====== Status / lifecycle ====== */
const flightLog=[];
function updateAllStatus(){
  const {eta,dAU,v}=computeETASeconds();
  const base=Date.now(), arrCST=base+eta*1000;
  const {istYears,spy}=IST_snapshot(); const arrIST=istYears + eta/spy;
  const arrISTstr=`${(arrIST/1e9).toFixed(6)} Ga ‚Ä¢ ${Math.floor(arrIST).toLocaleString()} y`;
  const avg=renderClockCards(arrISTstr, arrCST);
  const warp=Number($("warpSpeed").value||1), dest=$("destination").value;
  const etaStr=eta>=3600 ? (eta/3600).toFixed(2)+" h" : eta.toFixed(1)+" s";
  $("beacon").textContent=`üõ∞Ô∏è Warp ${warp} ‚Üí ${dest} | ${dAU.toFixed(3)} AU | ${(v/C_MPS).toFixed(2)} c | ETA ${etaStr} | Drift ${avg.toFixed(2)} ms`;
  flightLog.push({t:new Date().toISOString(), warp, dest, eta:etaStr, distAU:dAU.toFixed(3), vOverC:(v/C_MPS).toFixed(2)});
}
const rootEl=document.documentElement, scaleEl=$("uiScale");
function applyScale(){ const pct=Number(scaleEl.value||90); rootEl.style.setProperty('--ui-scale',(pct/100).toString()); $("uiScaleVal").textContent=pct+"%";
  drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); if(window._refreshStarfield) window._refreshStarfield(); }
function startAll(){ if(simulationRunning) return; simulationRunning=true; shipArrived=false; shipProgress=0; tone("good");
  lastFrameTime=performance.now(); driftInterval=setInterval(updateAllStatus,700);
  beaconInterval=setInterval(()=>{ clocks.forEach(c=>{ if(c.id!=="C4") c.drift*=0.1; }); },2000);
  orbitInterval=setInterval(()=>{ updateOrbitTable(); drawOrbitView(); },1200);
  animationFrame=requestAnimationFrame(animate);
  if(window.starfieldControl) window.starfieldControl.start();
  if(window.debrisControl) window.debrisControl.start();
  if(window.shieldBox) window.shieldBox.start();
}
function stopAll(){ simulationRunning=false; clearInterval(driftInterval); clearInterval(beaconInterval); clearInterval(orbitInterval); cancelAnimationFrame(animationFrame);
  stepEngineDynamics(0.2,false); tone("warn"); if(window.starfieldControl) window.starfieldControl.stop(); if(window.debrisControl) window.debrisControl.stop(); if(window.shieldBox) window.shieldBox.stop(); }
function resetAll(){ stopAll(); shipProgress=0; shipArrived=false; clocks.forEach(c=>c.drift=0); tIST0=performance.now(); engineState.t=0; engineState.temp=0; engineState.sag=0; engineState.containNeed=0.22; engineState.jitter=0;
  $("beacon").textContent="‚è≥ Waiting‚Ä¶"; updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); }
function exportLog(){ const rows=[["Time","Warp","Destination","ETA","Distance(AU)","v/c"], ...flightLog.map(e=>[e.t,e.warp,e.dest,e.eta,e.distAU,e.vOverC])];
  const csv=rows.map(r=>r.join(",")).join("\n"); const blob=new Blob([csv],{type:"text/csv"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="warp_log.csv"; a.click(); }
$("exportBtn").onclick=exportLog;
$("startBtn").onclick=startAll; $("stopBtn").onclick=stopAll; $("resetBtn").onclick=resetAll;
["warpSpeed","warpExp","warpScale","destination","istDay0Years","baselineDaysPerYear","reactorMW","frontPct","rearPct","lrBias","udBias","intakeMode","soundOn"]
  .forEach(id=>$(id).addEventListener("input", ()=>{ tIST0=performance.now(); updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); }));

/* ====== Ship motion (trajectory) + GR refresh ====== */
function animate(){ if(!simulationRunning || shipArrived) return; const now=performance.now(); const dt=(now-lastFrameTime)/1000; lastFrameTime=now;
  stepEngineDynamics(dt,true); const {warp}=warpInputs(); const eng=engineInputs();
  const speed=Math.max(0.05,eng.gradientFactor)*Math.min(1,0.6+0.7*eng.stability);
  shipProgress += 0.00050*Math.pow(warp,0.82)*(0.8+0.6*speed);
  if(shipProgress>=1){ shipProgress=1; shipArrived=true; tone("good"); stopAll(); }
  drawCurve(); drawOrbitView(); validateGR(); animationFrame=requestAnimationFrame(animate); }

/* ====== Init ====== */
window.onload=()=>{ applyScale(); updateOrbitTable(); drawCurve(); drawOrbitView(); validateGR(); updateAllStatus(); };
</script>
</body>
</html>
