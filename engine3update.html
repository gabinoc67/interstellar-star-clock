<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Warp Engine + FTL Jump Planner (CST / SR / GR / RA–Dec)</title>
<style>
  *{box-sizing:border-box}
  html,body{
    margin:0;
    background:#0b1020;
    color:#eaf0ff;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  a{color:#9bb4ff}
  .wrap{max-width:1800px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:16px;align-items:start}
  .panel{
    background:#12183a;
    border:1px solid #22305c;
    border-radius:16px;
    padding:14px;
    box-shadow:0 6px 18px rgba(0,0,0,.25)
  }
  h1{margin:.2rem 0 .4rem;font-size:26px}
  h2{margin:.4rem 0 .3rem;font-size:16px;color:#b8c4ff}
  h3{margin:.3rem 0 .25rem;font-size:14px;color:#cfe2ff}
  label{display:block;margin:.4rem 0 .25rem;color:#b8c4ff}
  input[type=range]{width:100%}
  input[type=number], select{
    width:100%;
    background:#0e1536;
    border:1px solid #233155;
    border-radius:10px;
    padding:6px 8px;
    color:#eaf0ff;
  }
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .stats{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
  .stat{background:#0e1536;border:1px solid #22305c;border-radius:12px;padding:8px}
  .big{font-size:22px;font-weight:600}
  .muted{font-size:12px;color:#b8c4ff}
  canvas{
    width:100%;
    height:900px;
    background:radial-gradient(1600px 900px at 50% 50%, #0f1740 0%, #0b1020 60%);
    border-radius:14px;
  }
  .legend{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
  .legend div{display:flex;align-items:center;gap:8px;color:#b8c4ff;font-size:12px}
  .dot{width:12px;height:12px;border-radius:50%}
  .note{color:#b8c4ff;font-size:12px;margin-top:8px}
  button{
    background:#1a245a;
    color:#eaf0ff;
    border:1px solid #22305c;
    border-radius:10px;
    padding:8px 10px;
    cursor:pointer;
    font-size:13px;
  }
  button:hover{filter:brightness(1.1)}
  .tests{margin-top:10px;font-size:12px;color:#b8c4ff}
  .telemetry{margin-top:10px;border-top:1px solid #22305c;padding-top:10px}
  .trow{display:grid;grid-template-columns:170px 1fr 88px;gap:8px;align-items:center;margin:6px 0}
  .tname{color:#b8c4ff;font-size:13px}
  .tval{font-variant-numeric:tabular-nums;font-size:13px;text-align:right}
  .gauge{height:8px;background:#0e1536;border:1px solid #22305c;border-radius:16px;overflow:hidden}
  .gauge>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#6bd1ff,#9bb4ff)}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .clockbox{background:#0e1536;border:1px solid #22305c;border-radius:10px;padding:8px;font-size:12px}
  .panel.steps{margin-top:16px}
  .steps ol{margin:.4rem 0 .2rem;padding-left:1.1rem}
  .steps li{margin:.25rem 0}
  .badge{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #2a3a78;
    font-size:11px;
    color:#a9b6ff;
    background:#0d1540;
  }
  .two-col{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
  .datatable{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:12px;border:1px solid #22305c;background:#0e1536}
  .datatable caption{caption-side:top;text-align:left;padding:8px 10px;color:#b8c4ff;font-weight:600}
  .datatable th,.datatable td{padding:8px 10px;border-bottom:1px solid #1b2852;font-size:12px;vertical-align:top}
  .datatable th{color:#cfe2ff;text-align:left;background:#101c47;font-weight:600;position:sticky;top:0}
  .datatable tr:last-child td{border-bottom:0}
  .datatable tbody tr:hover{background:#0f1a3d}
  .list{margin:.25rem 0 .5rem;padding-left:1.1rem}
  .list li{margin:.25rem 0}
  .eq{font-family:ui-monospace,Consolas,monospace;font-size:12px;background:#0e1536;padding:4px 6px;border-radius:6px;border:1px solid #233155;display:inline-block;margin-top:2px}

  /* Jump planner + planet panel */
  .jump-grid{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;margin-top:8px}
  .jump-box{
    background:#0e1536;
    border:1px solid #22305c;
    border-radius:12px;
    padding:10px;
    font-size:12px;
  }
  .jump-box h3{margin:0 0 6px;font-size:14px;color:#cfe2ff}
  .jump-row{display:grid;grid-template-columns:130px 1fr;gap:4px;margin:3px 0;font-size:12px}
  .jump-label{color:#9fb3ff}
  .jump-value{font-variant-numeric:tabular-nums}
  #orbitMap{
    width:100%;
    height:260px;
    background:radial-gradient(circle at center,#111b3f 0,#070b16 60%);
    border-radius:12px;
  }

  /* Small toggle + ghosted sliders */
  .toggle{
    display:flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    color:#b8c4ff;
  }
  .toggle input{
    accent-color:#8fb4ff;
    width:16px;
    height:16px;
  }
  .ghosted{
    opacity:.45;
    pointer-events:none;
  }

  @media (max-width: 1200px){
    .grid{grid-template-columns:1fr}
    .two-col{grid-template-columns:1fr}
    .jump-grid{grid-template-columns:1fr}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Warp Engine + CST FTL Jump Planner (SR/GR/RA–Dec)</h1>
    <p class="note">
      Engine structure is unchanged: same coils, reactors, nozzle, and telemetry. New SR/GR / sidereal / RA–Dec / light-time
      equations only drive the <strong>timing, jump planner and CST clock math</strong>, not the core geometry.
    </p>

    <div class="grid">
      <!-- ===== LEFT: CONTROL + TELEMETRY PANEL ===== -->
      <div class="panel">
        <h2>Controls</h2>
        <label for="warp">Warp Factor (1 to 10)</label>
        <input id="warp" type="range" min="1" max="10" step="1" value="3"/>
        <div class="row" style="margin-top:4px">
          <button id="play">Play</button>
          <button id="pause">Pause</button>
          <button id="reset">Reset</button>
          <label style="margin-left:auto;display:flex;align-items:center;gap:6px">
            <input id="labels" type="checkbox" checked/> Show labels
          </label>
        </div>
        <div class="stats">
          <div class="stat"><div class="big" id="speed">x3.0</div><div class="muted">Animation speed</div></div>
          <div class="stat"><div class="big" id="field">1.6 x D</div><div class="muted">Field radius vs engine</div></div>
          <div class="stat"><div class="big" id="temp">Warm</div><div class="muted">Heat/Cool balance</div></div>
          <div class="stat"><div class="big" id="time">1.00 x</div><div class="muted">Clock rate (visual)</div></div>
        </div>

        <!-- Energy Gradient Trim Panel -->
        <h2 style="margin-top:10px">Energy Gradient Trim</h2>
        <p class="note">
          Front vs rear sets contraction/expansion, left vs right keeps the shell centered, and warp vs shield tunes the hull-panel
          super field that combines warp curvature and radiation shielding. Side engines and panels close these gradients into a
          <strong>toroidal shell</strong> around the ship, recirculating energy instead of wasting it.
        </p>

        <div class="row" style="align-items:center;margin:4px 0 2px;">
          <span class="muted">Gradient Control Mode:</span>
          <label class="toggle">
            <input id="gradMode" type="checkbox" />
            <span id="gradModeLabel">Manual Trim</span>
          </label>
        </div>

        <div id="grad_sliders">
          <label for="grad_frontRear">Front vs Rear Gradient (contraction / expansion)</label>
          <input id="grad_frontRear" type="range" min="0.70" max="1.30" step="0.01" value="1.00"/>
          <label for="grad_leftRight">Left / Right Balance</label>
          <input id="grad_leftRight" type="range" min="-0.30" max="0.30" step="0.01" value="0.00"/>
          <label for="grad_warpShield">Warp vs Shield Emphasis</label>
          <input id="grad_warpShield" type="range" min="0" max="1" step="0.01" value="0.50"/>
        </div>

        <div class="legend">
          <div><span class="dot" style="background:#9bb4ff"></span> Photon/ion stream</div>
          <div><span class="dot" style="background:#33e1b5"></span> Magnetic field lines</div>
          <div><span class="dot" style="background:#ffcc66"></span> Heat tracers</div>
          <div><span class="dot" style="background:#6bd1ff"></span> Coolant (water) tracers</div>
          <div><span class="dot" style="background:#b26bff"></span> Entanglement particles</div>
          <div><span class="dot" style="background:#ffdca8"></span> Plasma light cone</div>
          <div><span class="dot" style="background:#8aff9b"></span> Detection lasers</div>
        </div>
        <div id="tests" class="tests">Self-tests running…</div>

        <!-- Real-time Telemetry (SR/GR/CST + gradient-aware) -->
        <div class="telemetry">
          <h2>Real-time Telemetry</h2>
          <div class="trow"><div class="tname">Animation Speed</div><div class="gauge"><span id="g_speed"></span></div><div id="v_speed" class="tval">x1.0</div></div>
          <div class="trow"><div class="tname">Field Radius (×D)</div><div class="gauge"><span id="g_field"></span></div><div id="v_field" class="tval">1.20</div></div>
          <div class="trow"><div class="tname">Field Shield (%)</div><div class="gauge"><span id="g_fshield"></span></div><div id="v_fshield" class="tval">0%</div></div>
          <div class="trow"><div class="tname">Field Stretch (rx/ry)</div><div class="gauge"><span id="g_fstretch"></span></div><div id="v_fstretch" class="tval">0/0</div></div>

          <!-- Energy Gradient Telemetry -->
          <div class="trow"><div class="tname">Gradient Front/Rear</div><div class="gauge"><span id="g_gradFR"></span></div><div id="v_gradFR" class="tval">1.00×</div></div>
          <div class="trow"><div class="tname">L/R Balance</div><div class="gauge"><span id="g_gradLR"></span></div><div id="v_gradLR" class="tval">0.00</div></div>
          <div class="trow"><div class="tname">Warp vs Shield Mix</div><div class="gauge"><span id="g_gradWS"></span></div><div id="v_gradWS" class="tval">50/50</div></div>

          <div class="trow"><div class="tname">Clock Rate (warp / SR·GR)</div><div class="gauge"><span id="g_clock"></span></div><div id="v_clock" class="tval">1.00×</div></div>

          <div class="trow"><div class="tname">Photon/Ion Rate</div><div class="gauge"><span id="g_phot"></span></div><div id="v_phot" class="tval">0/s</div></div>
          <div class="trow"><div class="tname">Mag Field Strength</div><div class="gauge"><span id="g_mag"></span></div><div id="v_mag" class="tval">0.0</div></div>

          <div class="trow"><div class="tname">Core Temp (°C)</div><div class="gauge"><span id="g_tcore"></span></div><div id="v_tcore" class="tval">0°C</div></div>
          <div class="trow"><div class="tname">Coolant Temp (°C)</div><div class="gauge"><span id="g_tcool"></span></div><div id="v_tcool" class="tval">0°C</div></div>

          <div class="trow"><div class="tname">Entangle Channel</div><div class="gauge"><span id="g_ent"></span></div><div id="v_ent" class="tval">0 /s</div></div>
          <div class="trow"><div class="tname">Plasma Cone Len</div><div class="gauge"><span id="g_plen"></span></div><div id="v_plen" class="tval">0 u</div></div>
          <div class="trow"><div class="tname">Plasma Cone Rad</div><div class="gauge"><span id="g_prad"></span></div><div id="v_prad" class="tval">0 u</div></div>
          <div class="trow"><div class="tname">Plasma Wave Intensity</div><div class="gauge"><span id="g_pwave"></span></div><div id="v_pwave" class="tval">0.0</div></div>

          <div class="subgrid">
            <div class="clockbox"><div><strong>Outside Time (UTC)</strong></div><div id="clk_utc">--:--:--</div></div>
            <div class="clockbox"><div><strong>Engine Sync (CST)</strong></div><div id="clk_cst">--:--:--</div></div>
            <div class="clockbox" style="grid-column:1 / span 2">
              <div><strong>Warp-Adjusted Proper Time</strong> (SR·GR·warp)</div>
              <div id="clk_warp">--:--:--</div>
            </div>
          </div>
        </div>
      </div>

      <!-- ===== RIGHT: ENGINE CANVAS PANEL ===== -->
      <div class="panel">
        <canvas id="view" width="1600" height="900"></canvas>
      </div>
    </div>

    <!-- ===== ENGINE THEORY PANEL ===== -->
    <div class="panel steps">
      <h2>How this engine operates (conceptual sequence, no exotic matter)</h2>
      <ol>
        <li><strong>Intake & Magnetic Fan</strong> modulate vacuum-air circulation and seed flow to compression.</li>
        <li><strong>Compression Stages</strong> raise density/pressure via staged EM shaping and piping.</li>
        <li><strong>Reactors</strong> supply power; <strong>Electro-plasma</strong> is generated and routed.</li>
        <li><strong>Warp coils / Field shapers</strong> modulate vacuum fluctuation and form the field bubble.</li>
        <li><strong>Entangled feedback + Atomic clocks (CST sync)</strong> stabilize timing; sensors/lasers regulate pulses.</li>
        <li><strong>Nozzle & Thermal management</strong> direct exhaust; water cooling maintains safe operation.</li>
      </ol>
      <p class="note">
        Labels include: Negative-energy <em>modulator</em>, Pulse Control, AFT Power Ramp / Gradually, Gravitational Stabilization Panel,
        Quantum Vertex Dampers (F/R/U/D/L/R), Detection Lasers, plus ZPO rings, Casimir arrays, Tachyon node, CTC Guard, Positron port,
        Limestone–granite resonator, and an exotic-matter bypass used only as an EM stress analogue (no fake physics constants).
      </p>
    </div>

    <!-- ===== ENGINE LAYER TABLE + NOTES ===== -->
    <div class="panel">
      <div class="two-col">
        <div>
          <table class="datatable" aria-label="Engine Layer mapping">
            <caption>Engine Layer ↔ Physics Basis ↔ Function</caption>
            <thead>
              <tr>
                <th scope="col">Layer</th>
                <th scope="col">Physics Basis</th>
                <th scope="col">Function in Warp Engine</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>Zero-Point Field</td><td>Quantum vacuum energy</td><td>Energy substrate for spacetime curvature</td></tr>
              <tr><td>Casimir / Lamb Shift</td><td>Boundary-tuned vacuum modes</td><td>Field stabilization and feedback</td></tr>
              <tr><td>Tachyon Domain (mirror frame)</td><td>Analogue superluminal frame</td><td>Temporal symmetry & feedback channel</td></tr>
              <tr><td>Zero-Point Oscillators (ZPO)</td><td>Vacuum resonance arrays</td><td>Field propulsion and bubble maintenance</td></tr>
              <tr><td>CST Time</td><td>Global timing lattice</td><td>Navigation stability across spacetime frames</td></tr>
            </tbody>
          </table>
          <p class="note" style="margin-top:8px">
            <span class="badge">Live Link</span> These layers correspond to the animated telemetry (field radius, clock rate,
            plasma vectors). The SR/GR/sidereal/RA–Dec/light-time math only feeds the timing and jump planning layer.
          </p>
        </div>

        <div>
          <h2>Warp-Drive Energy Symmetry — Technical Notes</h2>
          <ul class="list">
            <li><strong>Core theory:</strong> Warp bubble arises from phased <em>vacuum-energy gradients</em> driven by ZPO rings with CST-locked timing.</li>
            <li><strong>Vacuum field & CST synchronization:</strong> Atomic clocks phase-lock ZPF oscillators; CST anchors re-entry to the correct frame.</li>
            <li><strong>Positron roles:</strong> Pair-production channels act as <em>plasma charge balancers</em> and diagnostic beacons in high-field regimes.</li>
            <li><strong>Exotic-matter bypass:</strong> Effective negative pressure via <em>Casimir cavities</em> and phase-shifted EM stress—no literal exotic matter.</li>
            <li><strong>Limestone–granite resonance:</strong> Piezoelectric & acoustic coupling prototypes (granite/quartz) for low-frequency field seeding.</li>
            <li><strong>Toroidal field shell:</strong> Side engines and hull gradient panels close the warp field into a torus, recirculating flux and smoothing front/back curvature.</li>
            <li><strong>Temporal vs spatial warp:</strong> <em>rx/ry</em> stretch controls spatial lensing; clock rate + SR/GR terms visualize temporal dilation.</li>
            <li><strong>Closed Timelike Curves:</strong> CTCs can arise if temporal curvature exceeds stability; CST feedback limits the range and damps loops.</li>
          </ul>
          <p class="note">
            In this prototype, <strong>local plasma never exceeds c</strong>. Apparent superluminal motion comes from geometry
            (warp factor + CST map), not from matter breaking Einstein.
          </p>
        </div>
      </div>
    </div>
    <!-- ===== FTL JUMP PLANNER + PLANET TRIP PANEL ===== -->
    <div class="panel">
      <h2>FTL Jump Planner & CST Jump Report</h2>
      <p class="note">
        This panel bolts your <strong>cosmic clock equations</strong> onto the engine: SR time dilation, GR gravitational slowing,
        sidereal drift, RA/Dec mapping and light-time delay. It computes a jump and shows a dot traveling from Earth to the selected planet.
      </p>

      <div class="jump-grid">
        <!-- LEFT: INPUTS + REPORT -->
        <div class="jump-box">
          <h3>Jump Inputs (CST + SR/GR)</h3>
          <label>Distance to Target (light-years)</label>
          <input id="jp_dist" type="number" step="0.01" value="4.20"/>

          <label style="margin-top:6px">Target RA (hours)</label>
          <input id="jp_ra" type="number" step="0.0001" value="14.6590"/>

          <label style="margin-top:6px">Target Dec (deg)</label>
          <input id="jp_dec" type="number" step="0.0001" value="-60.8353"/>

          <label style="margin-top:6px">Gravity Regime</label>
          <select id="jp_grav">
            <option value="earth">Near Earth orbit</option>
            <option value="sun" selected>Near Sun orbit</option>
            <option value="deep">Deep interstellar (low GR)</option>
          </select>

          <label style="margin-top:6px">Sidereal Drift Start (days since J2000)</label>
          <input id="jp_drift" type="number" step="1" value="9200"/>

          <div class="row" style="margin-top:10px">
            <button id="jp_run">Start Trip / Compute Jump</button>
            <button id="jp_reset" style="margin-left:auto">Reset Jump</button>
          </div>

          <div id="jp_status" class="note" style="margin-top:6px">
            Idle — waiting for CST jump.
          </div>

          <div class="jump-box" style="margin-top:10px">
            <h3>Jump Report (CST Frame)</h3>
            <div class="jump-row"><div class="jump-label">CST alignment:</div><div class="jump-value" id="jp_align">—</div></div>
            <div class="jump-row"><div class="jump-label">Departure (CST):</div><div class="jump-value" id="jp_dep">—</div></div>
            <div class="jump-row"><div class="jump-label">Arrival (CST coord.):</div><div class="jump-value" id="jp_arr">—</div></div>
            <div class="jump-row"><div class="jump-label">Ship proper time:</div><div class="jump-value" id="jp_ship">—</div></div>
            <div class="jump-row"><div class="jump-label">Distance:</div><div class="jump-value" id="jp_dline">—</div></div>
            <div class="jump-row"><div class="jump-label">Apparent velocity:</div><div class="jump-value" id="jp_vapp">—</div></div>
            <div class="jump-row"><div class="jump-label">Time dilation (SR×GR):</div><div class="jump-value" id="jp_gamma">—</div></div>
            <div class="jump-row"><div class="jump-label">Sidereal drift applied:</div><div class="jump-value" id="jp_sid">—</div></div>
            <div class="jump-row"><div class="jump-label">Re-entry position error:</div><div class="jump-value" id="jp_err">—</div></div>
            <div class="jump-row"><div class="jump-label">Vector alignment:</div><div class="jump-value" id="jp_vec">—</div></div>
          </div>
        </div>

        <!-- RIGHT: EARTH→PLANET JUMP MAP -->
        <div class="jump-box">
          <h3>Re-entry Accuracy Map — Earth → Planet</h3>
          <label>Target Planet</label>
          <select id="pl_target">
            <option value="mercury">Mercury</option>
            <option value="venus">Venus</option>
            <option value="mars" selected>Mars</option>
            <option value="jupiter">Jupiter</option>
            <option value="saturn">Saturn</option>
            <option value="uranus">Uranus</option>
            <option value="neptune">Neptune</option>
            <option value="pluto">Pluto</option>
          </select>

          <canvas id="orbitMap" width="420" height="260"></canvas>

          <div class="jump-row" style="margin-top:6px">
            <div class="jump-label">Trip progress:</div>
            <div class="jump-value" id="pl_progress">0%</div>
          </div>
          <div class="jump-row">
            <div class="jump-label">Static anchor:</div>
            <div class="jump-value">Earth stays fixed; only the jump dot moves to the chosen planet.</div>
          </div>
          <p class="note" style="margin-top:4px">
            When you press <strong>Start Trip / Compute Jump</strong>, the engine uses the same SR/GR/CST / RA–Dec
            math to plan the jump, then the dot travels from Earth to the selected planet on this map.
          </p>
        </div>
      </div>
    </div>

    <!-- ===== SENSORS & GRADIENT FEEDBACK PANEL ===== -->
    <div class="panel">
      <h2>Sensors & Gradient Feedback — How the Engine Auto-Tunes</h2>
      <p class="note">
        In live operation the gradient sliders are <strong>targets</strong>, not manual knobs. Sensor arrays feed the controller,
        which trims front/rear, left/right, and warp vs shield automatically to keep the shell smooth, centered, and safe.
        The toroidal hull field closes these trims into a continuous loop.
      </p>
      <table class="datatable" aria-label="Sensors and Gradient Feedback Mapping">
        <caption>Sensors → Telemetry → Gradient Trim Channels</caption>
        <thead>
          <tr>
            <th>Sensor Channel</th>
            <th>What it Measures</th>
            <th>Gradient Trim it Feeds</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Field Probes (Bow / Stern)</td>
            <td>Local curvature, field radius and stretch ahead/behind the ship</td>
            <td>
              <strong>Front vs Rear Gradient</strong><br/>
              • If bow curvature is too weak → increase front contraction.<br/>
              • If wake turbulence is high → soften rear expansion.
            </td>
          </tr>
          <tr>
            <td>Hull Strain Gauges & Inertial Frame Sensors</td>
            <td>Torsion, shear, and differential g-load across the hull & decks</td>
            <td>
              <strong>Left / Right Balance</strong><br/>
              • Detects yaw/roll trends in the warp shell.<br/>
              • Auto-centers the shell by boosting the “low” side coil gradient.
            </td>
          </tr>
          <tr>
            <td>Radiation Detectors (Gamma / Solar / Cosmic)</td>
            <td>Incoming particle and EM flux, flare signatures, cosmic ray spikes</td>
            <td>
              <strong>Warp vs Shield Mix</strong><br/>
              • Quiet interstellar space → more energy to warp geometry.<br/>
              • Solar flare / radiation belt → bias power into the shield envelope.
            </td>
          </tr>
          <tr>
            <td>Nav Error Vector (CST / RA–Dec)</td>
            <td>Difference between planned vs measured re-entry vector and timing</td>
            <td>
              <strong>All three trims</strong><br/>
              • Fine-tunes front/rear for timing, left/right for pointing,<br/>
              • and shield mix if crossing high-radiation corridors.
            </td>
          </tr>
          <tr>
            <td>Thermal & Stefan–Boltzmann Monitors</td>
            <td>Core temperature, radiative flux from coils and panels</td>
            <td>
              <strong>Warp vs Shield & Power Ceiling</strong><br/>
              • Uses <span class="eq">F = σT⁴</span> to predict radiative load.<br/>
              • If emission exceeds safe limits → cap warp factor or boost cooling.
            </td>
          </tr>
        </tbody>
      </table>
      <p class="note">
        In a full CST controller, the “Energy Gradient Trim” sliders in the UI would be driven by these sensors: the crew sets
        <em>targets</em> (e.g., “stable cruise, 1 g, high shield”), and the feedback loop keeps the warp shell locked on that profile.
      </p>
    </div>
    <!-- ===== SCIENTIFIC ENHANCEMENTS FOR THE INTERSTELLAR STAR CLOCK ===== -->
    <div class="panel">
      <h2>Scientific Enhancements for the Interstellar Star Clock & Warp Drive</h2>
      <p class="note">
        These equations sit behind the CST clock and warp navigation. They convert poetry into physics while keeping your
        bold vision intact — time slippage, star coordinates, and energy gradients all feed one unified engine.
      </p>

      <h3>1. Time Dilation (Special Relativity)</h3>
      <div class="eq">Δt' = Δt × √(1 - v² / c²)</div>
      <ul class="list">
        <li><strong>Clock layer:</strong> Used to adjust ship proper time vs CST when plasma streams move at a fraction of <em>c</em> inside the engine.</li>
        <li><strong>Navigation:</strong> High-velocity segments of a jump arc show reduced proper time; CST keeps the crew anchored to the master cosmic clock.</li>
      </ul>

      <h3>2. Gravitational Time Dilation (General Relativity)</h3>
      <div class="eq">Δt' = Δt × √(1 - 2GM / (r c²))</div>
      <ul class="list">
        <li><strong>Clock layer:</strong> Used when the ship operates near stars, planets, or compact objects; CST compensates for slower clocks in deeper wells.</li>
        <li><strong>Warp control:</strong> The engine avoids curvature regimes where GR plus warp geometry could create unstable CTC-like loops.</li>
      </ul>

      <h3>3. Star Coordinate Mapping (RA / Dec → 3D)</h3>
      <div class="eq">
        x = cos(δ) × cos(α),&nbsp;
        y = cos(δ) × sin(α),&nbsp;
        z = sin(δ)
      </div>
      <ul class="list">
        <li><strong>Star clock:</strong> Anchors each star to a fixed direction on the celestial sphere at a given epoch.</li>
        <li><strong>Warp navigation:</strong> Converts RA/Dec into a 3D target vector for the FTL jump planner; the CST engine rides curvature along that vector.</li>
      </ul>

      <h3>4. Sidereal Clock Adjustment</h3>
      <div class="eq">Sidereal Day = 23h 56m 4.1s</div>
      <ul class="list">
        <li><strong>Clock layer:</strong> The CST clock keeps both solar time and sidereal time; over years, the tiny offset accumulates into real star drift.</li>
        <li><strong>Warp navigation:</strong> Corrects star positions for drift since J2000 so the RA/Dec map stays aligned over long deep-time jumps.</li>
      </ul>

      <h3>5. Light-Time Correction</h3>
      <div class="eq">t = d / c</div>
      <ul class="list">
        <li><strong>Star clock:</strong> Shows how “old” the light is from each star; your constellations become time-delayed snapshots.</li>
        <li><strong>Warp comms:</strong> Compares conventional light-time to instantaneous entanglement or warp-burst signals in your communication panels.</li>
      </ul>

      <h3>6. Stefan–Boltzmann Law (Radiative Heat from Coils & Panels)</h3>
      <div class="eq">F = σ T⁴</div>
      <ul class="list">
        <li><strong>Engine core:</strong> Predicts heat flux from hot coils, plasma chambers, and gradient panels as a function of temperature.</li>
        <li><strong>Safety / Shield mix:</strong> When radiative flux approaches structural limits, the controller shifts energy from warp geometry into cooling and shielding.</li>
        <li><strong>Telemetry:</strong> The “Core Temp” and “Coolant Temp” readouts conceptually trace back to this T⁴ scaling.</li>
      </ul>

      <h3>7. Hamiltonian Operator (Energy of the Warp Field)</h3>
      <div class="eq">Ĥ ψ = E ψ</div>
      <ul class="list">
        <li><strong>Field layer:</strong> Treats the warp shell and vacuum modes as a quantum system with a Hamiltonian that encodes all energy terms (plasma, EM, vacuum).</li>
        <li><strong>Gradient design:</strong> By choosing a Hamiltonian with stable eigenmodes, you bias the engine toward field configurations that maintain a smooth bubble.</li>
        <li><strong>CST integration:</strong> The CST clock can be thought of as following the phase evolution of the warp state vector over long-duration missions.</li>
      </ul>

      <h3>8. Wave Equation (Propagation of Warp & Shield Fields)</h3>
      <div class="eq">∂²ψ/∂t² = c² ∇²ψ  &nbsp; (classical form)</div>
      <ul class="list">
        <li><strong>Field geometry:</strong> Describes how disturbances in EM, plasma, and vacuum modes propagate through the warp shell.</li>
        <li><strong>Gradient control:</strong> The controller uses an internal wave model so pulses launched by the coils arrive in phase at the front vs rear shell.</li>
        <li><strong>Shield shaping:</strong> Radiation and particle shielding are engineered as standing-wave solutions that wrap the hull in a stable harmonic envelope.</li>
      </ul>

      <p class="note">
        Together, these equations let the Interstellar Star Clock do more than tell time: it <em>predicts</em> how time, energy, and geometry interact.
        Your warp engine sits on top of this clock, using CST to keep energy gradients, curvature, and crew experience in sync.
      </p>
    </div>

<script>
// ===== Utility =====
const TAU = Math.PI*2;
const lerp=(a,b,t)=>a+(b-a)*t;
function drawText(ctx, s, x, y, align){
  ctx.fillStyle='#eaf0ff';
  ctx.textAlign=align||'left';
  ctx.textBaseline='middle';
  ctx.font='12px system-ui,Segoe UI,Roboto,Arial';
  ctx.fillText(s,x,y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function fmt(n,dec){ return n.toFixed(dec||0); }
function fmtLarge(n){
  var a=Math.abs(n);
  if(a>=1e12) return (n/1e12).toFixed(2)+' T';
  if(a>=1e9)  return (n/1e9 ).toFixed(2)+' G';
  if(a>=1e6)  return (n/1e6 ).toFixed(2)+' M';
  if(a>=1e3)  return (n/1e3 ).toFixed(1)+' K';
  return n.toFixed(0);
}

// ===== Helpers with physics-aware timing =====
function computeSpeedMult(w){ return lerp(1, 6, (w-1)/9); }
function computeFieldRadius(w){ return lerp(1.2, 2.6, (w-1)/9); }
function computeHeatLevel(w){ return lerp(0.35, 1.0, (w-1)/9); }
function computeCoolLevel(w){ return 1 - computeHeatLevel(w)*0.5; }
function computePlasmaLength(w){ return Math.round( lerp(90, 260, (w-1)/9) ); }
function computePlasmaRadius(w){ return Math.round( lerp(10, 36, (w-1)/9) ); }
function computeEntangleRate(w){ return lerp(0.6, 3.2, (w-1)/9); }
function computeFieldAspectX(w){ return lerp(1.0, 1.9, (w-1)/9); }
function computeFieldAspectY(w){ return lerp(0.9, 0.6, (w-1)/9); }
function computeStability(w){
  var s = 1 - (w-1)/12;
  if(s<0.55) s=0.55;
  return s;
}

// simple SR speed fraction for telemetry & jump layer
function localSpeedFrac(w){
  // plasma stays subluminal: between 0.2 c and ~0.92 c
  return clamp(0.2 + 0.08*(w-1), 0.2, 0.92);
}
function gammaSR(w){
  const v = localSpeedFrac(w);
  return 1/Math.sqrt(1-v*v);         // SR: γ = 1/sqrt(1 - v²/c²)
}
function gammaGR_regime(reg){
  // tiny but real gravitational slowing factors; approximated for demo
  if(reg === 'earth') return 1.0000000003;
  if(reg === 'sun')   return 1.0000020;
  if(reg === 'deep')  return 1.0;
  return 1.0;
}
function combinedClockRate(w, reg){
  const warpScale = lerp(1, 1.6, (w-1)/9); // geometry stretch
  const gSR = gammaSR(w);
  const gGR = gammaGR_regime(reg);
  const rate = 1/(warpScale * gSR * gGR);
  return rate; // < 1 => ship clock slower than CST
}

// Temps (conceptual mapping)
function computeCoreTempC(w){ return Math.round( 200 + computeHeatLevel(w)*1000 + computeSpeedMult(w)*40 ); }
function computeCoolantTempC(w){ return Math.round( 25 + computeCoolLevel(w)*300 ); }

// ===== Layout (expanded canvas geometry) =====
const layout = {
  centerY: 450,
  startX: 110,
  length: 900,
  bodyR: 120,
  fanX: 85,
  stages: [
    {len:160, r:120, name:'Intake / Pre-Compression'},
    {len:120, r:112, name:'Compression Stage A'},
    {len:100, r:104, name:'Compression Stage B'},
    {len: 80, r: 96, name:'Compression Stage C'},
    {len: 70, r: 88, name:'Warp Coils / Field Shapers'},
    {len: 70, r: 80, name:'Reactors (Electro-Plasma)'},
    {len: 60, r: 72, name:'Photon/Plasma Mixer'},
    {len: 50, r: 64, name:'Nozzle Coupler'}
  ],
  nozzle:{len:160, r0:60, r1:14, name:'Exhaust Nozzle'},
  coils:[{xOff:-18, name:'Field Coil L'},{xOff:36, name:'Field Coil R'}]
};
let xx=layout.startX;
layout.stages = layout.stages.map(function(s){
  var out={x0:xx,x1:xx+s.len,len:s.len,r:s.r,name:s.name};
  xx+=s.len; return out;
});
layout.nozzle.x0 = xx;
layout.nozzle.x1 = xx + layout.nozzle.len;

// ===== State =====
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let running = true;
let t0 = performance.now();
let fanAngle = 0;
let fps = 60;
let warpClock = Date.now();

// particle arrays
let particles = [], heat = [], cool = [], entangle = [], pipes = [];

// Controls
const warpEl   = document.getElementById('warp');
const speedEl  = document.getElementById('speed');
const fieldEl  = document.getElementById('field');
const tempEl   = document.getElementById('temp');
const timeEl   = document.getElementById('time');
const labelsEl = document.getElementById('labels');

// Gradient trim controls
const gradFrontRearEl  = document.getElementById('grad_frontRear');
const gradLeftRightEl  = document.getElementById('grad_leftRight');
const gradWarpShieldEl = document.getElementById('grad_warpShield');

// Gradient mode controls
const gradModeEl      = document.getElementById('gradMode');
const gradModeLabelEl = document.getElementById('gradModeLabel');
const gradSlidersBox  = document.getElementById('grad_sliders');
let autoTrim = false;

// Telemetry DOM
const v_speed=document.getElementById('v_speed'), g_speed=document.getElementById('g_speed');
const v_field=document.getElementById('v_field'), g_field=document.getElementById('g_field');
const v_fshield=document.getElementById('v_fshield'), g_fshield=document.getElementById('g_fshield');
const v_fstretch=document.getElementById('v_fstretch'), g_fstretch=document.getElementById('g_fstretch');

const v_gradFR=document.getElementById('v_gradFR'), g_gradFR=document.getElementById('g_gradFR');
const v_gradLR=document.getElementById('v_gradLR'), g_gradLR=document.getElementById('g_gradLR');
const v_gradWS=document.getElementById('v_gradWS'), g_gradWS=document.getElementById('g_gradWS');

const v_clock=document.getElementById('v_clock'), g_clock=document.getElementById('g_clock');
const v_phot=document.getElementById('v_phot'), g_phot=document.getElementById('g_phot');
const v_mag=document.getElementById('v_mag'), g_mag=document.getElementById('g_mag');
const v_tcore=document.getElementById('v_tcore'), g_tcore=document.getElementById('g_tcore');
const v_tcool=document.getElementById('v_tcool'), g_tcool=document.getElementById('g_tcool');
const v_ent=document.getElementById('v_ent'), g_ent=document.getElementById('g_ent');
const v_plen=document.getElementById('v_plen'), g_plen=document.getElementById('g_plen');
const v_prad=document.getElementById('v_prad'), g_prad=document.getElementById('g_prad');
const v_pwave=document.getElementById('v_pwave'), g_pwave=document.getElementById('g_pwave');
const clkUTC=document.getElementById('clk_utc');
const clkCST=document.getElementById('clk_cst');
const clkWarp=document.getElementById('clk_warp');

function warpFactor(){ return parseInt(warpEl.value,10); }
function speedMult(){ return computeSpeedMult(warpFactor()); }
function fieldRadius(){ return computeFieldRadius(warpFactor()); }
function heatLevel(){ return computeHeatLevel(warpFactor()); }
function coolLevel(){ return computeCoolLevel(warpFactor()); }

// gradient helpers
function gradFrontRear(){ return parseFloat(gradFrontRearEl.value)||1; }
function gradLeftRight(){ return parseFloat(gradLeftRightEl.value)||0; }
function gradWarpShield(){ return clamp(parseFloat(gradWarpShieldEl.value)||0.5,0,1); }

function updateHUD(){
  speedEl.textContent = 'x'+speedMult().toFixed(1);
  fieldEl.textContent = fieldRadius().toFixed(1)+' x D';
  tempEl.textContent  = heatLevel()>0.7? 'Hot' : (heatLevel()>0.5? 'Warm' : 'Cool');
  const reg = 'sun'; // default SR/GR reference for HUD
  const rate = combinedClockRate(warpFactor(), reg);
  timeEl.textContent = rate.toFixed(2)+' x';
}
updateHUD();
warpEl.addEventListener('input', updateHUD);

// Toggle mode UI
function updateGradModeUI(){
  if(autoTrim){
    gradModeLabelEl.textContent = 'Sensor Auto-Trim';
    gradSlidersBox.classList.add('ghosted');
    gradFrontRearEl.disabled  = true;
    gradLeftRightEl.disabled  = true;
    gradWarpShieldEl.disabled = true;
  }else{
    gradModeLabelEl.textContent = 'Manual Trim';
    gradSlidersBox.classList.remove('ghosted');
    gradFrontRearEl.disabled  = false;
    gradLeftRightEl.disabled  = false;
    gradWarpShieldEl.disabled = false;
  }
}
autoTrim = false;
updateGradModeUI();

gradModeEl.addEventListener('change', ()=>{
  autoTrim = gradModeEl.checked;
  updateGradModeUI();
});

document.getElementById('pause').onclick=function(){running=false;};
document.getElementById('play').onclick=function(){
  if(!running){
    running=true;
    t0=performance.now();
    loop();
  }
};
document.getElementById('reset').onclick=function(){
  particles.length=0; heat.length=0; cool.length=0; entangle.length=0; pipes.length=0; fanAngle=0;
};

// ===== Streams & Pipes =====
function spawnParticle(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.6;
  var x0 = layout.startX+10;
  var v = 0.6 + Math.random()*0.7;
  particles.push({x:x0,y:y,v:v,life:0});
}
function spawnHeat(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.4;
  var xh = layout.stages[4].x0 + Math.random()*(layout.nozzle.x1 - layout.stages[4].x0);
  heat.push({x:xh,y:y,life:0});
}
function spawnCool(){
  var y = layout.centerY + (Math.random()*2-1)*layout.bodyR*0.7;
  var xc = layout.stages[0].x0 + Math.random()*(layout.stages[2].x1-layout.stages[0].x0);
  cool.push({x:xc,y:y,life:0});
}
function spawnEntangle(){
  var baseX = layout.stages[5].x0 + Math.random()*40;
  var phase = Math.random()*TAU;
  entangle.push({x:baseX, y:layout.centerY, phase:phase, life:0});
}
function initPipes(){
  pipes = [];
  for(var i=0;i<layout.stages.length-1;i++){
    var s = layout.stages[i];
    var nx = s.x1;
    pipes.push({x0:nx-6,y0:layout.centerY+28,x1:nx+6,y1:layout.centerY+28,phase:Math.random()*TAU});
  }
}
initPipes();

// ===== Draw helpers =====
function drawCylinder(x0,x1,rTop,rBot){
  var grd = ctx.createLinearGradient(0, layout.centerY-rTop, 0, layout.centerY+rBot);
  grd.addColorStop(0, '#2a334d');
  grd.addColorStop(0.5,'#9fb1ff22');
  grd.addColorStop(1, '#0e132b');
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY - rTop);
  ctx.lineTo(x1, layout.centerY + rBot);
  ctx.lineTo(x0, layout.centerY + rBot);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.strokeStyle = '#cfe2ff33';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x1, layout.centerY-rTop);
  ctx.lineTo(x1, layout.centerY+rBot);
  ctx.stroke();
}
function drawNozzle(nz){
  var x0=nz.x0,x1=nz.x1,r0=nz.r0,r1=nz.r1;
  var grd = ctx.createLinearGradient(x0,layout.centerY,x1,layout.centerY);
  grd.addColorStop(0,'#2a334d');
  grd.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=grd;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - r0);
  ctx.lineTo(x1, layout.centerY - r1);
  ctx.lineTo(x1, layout.centerY + r1);
  ctx.lineTo(x0, layout.centerY + r0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.stroke();
}
function drawCoil(xOff){
  var x = layout.startX + xOff;
  ctx.strokeStyle='#a6b8ffaa';
  ctx.lineWidth=8;
  ctx.beginPath();
  ctx.moveTo(x, layout.centerY-48);
  ctx.lineTo(x, layout.centerY+48);
  ctx.stroke();
  ctx.lineWidth=3;
  ctx.strokeStyle='#5ea8ffaa';
  for(var i=-3;i<=3;i++){
    ctx.beginPath();
    ctx.arc(x, layout.centerY + i*12, 22+Math.abs(i)*2, 0, TAU);
    ctx.stroke();
  }
}
function drawFan(angle){
  var cx = layout.fanX, cy = layout.centerY;
  ctx.fillStyle='#a4b2d8';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, TAU);
  ctx.fill();
  for(var i=0;i<6;i++){
    var a = angle + i*TAU/6;
    var r1=14, r2=52;
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath();
    ctx.fill();
  }
}

// field uses gradient trim (front/rear, left/right) and auto-trim
function drawField(){
  var D = layout.bodyR*2;
  var base = fieldRadius()*D*0.35;
  var ax = computeFieldAspectX(warpFactor());
  var ay = computeFieldAspectY(warpFactor());

  // manual target values
  var gFR = gradFrontRear();   // 1.0 = symmetric; >1 front-focused
  var gLR = gradLeftRight();   // negative = left, positive = right

  // auto-trim overlay: sensors gently reshape the toroidal shell
  if(autoTrim){
    var t = performance.now()*0.00025;
    gFR += 0.04*Math.sin(t*1.2);       // gentle breathing in contraction/expansion
    gLR *= 0.45;                       // sensors pull left/right closer to center
  }

  ctx.strokeStyle='#33e1b588';
  ctx.lineWidth=2;

  var cx = layout.startX+layout.length*0.65 + gLR*40; // left/right trim shifts center

  for(var i=0;i<6;i++){
    var rx = base*ax + i*22;
    var ry = base*ay + i*10;

    // mild front-bias stretch: changes horizontal reach to emulate arrow-like curvature
    var frontBias = 1 + (gFR-1)*0.6;
    var localCx   = cx + (i-2)*4*(gFR-1); // slight skew to show front vs rear emphasis

    ctx.beginPath();
    ctx.ellipse(localCx, layout.centerY, rx*frontBias, ry, 0, 0, TAU);
    ctx.stroke();
  }
}

function drawTimeLegendLeft(){
  var x=40;
  var y=120;
  var lines=['UTC','CST (engine sync)','Interstellar (CST map)','Universal Time','UTA'];
  for(var i=0;i<lines.length;i++){
    drawText(ctx, lines[i], x, y+i*20, 'left');
  }
}
function drawCSTClock(){
  var x = layout.stages[3].x0+12;
  var y = layout.centerY-22;
  ctx.fillStyle='#0e1536';
  ctx.strokeStyle='#22305c';
  ctx.lineWidth=1;
  ctx.fillRect(x,y,150,32);
  ctx.strokeRect(x,y,150,32);
  drawText(ctx,'Atomic Clock (CST)', x+6, y+16, 'left');
}
function drawStatusLabel(){
  var x = layout.nozzle.x0-40;
  var y = layout.centerY- layout.bodyR - 58;
  var warp = warpFactor();
  var stab = computeStability(warp);
  var s = 'Warp '+warp+' | Stability '+stab.toFixed(2);
  drawText(ctx, s, x, y, 'left');
}
function labelFromTo(text, ax, ay, tx, ty){
  ctx.strokeStyle='#9bb4ff66';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(ax,ay);
  ctx.lineTo(tx,ty);
  ctx.stroke();
  drawText(ctx, text, tx+4, ty, 'left');
}

// Labels (engine structure unchanged, plus gradient/toroidal labels)
function drawLabels(){
  const topY = layout.centerY - layout.bodyR - 42;
  const botY = layout.centerY + layout.bodyR + 44;

  const s0=layout.stages[0], s1=layout.stages[1], s2=layout.stages[2],
        s3=layout.stages[3], s4=layout.stages[4], s5=layout.stages[5],
        s6=layout.stages[6];

  labelFromTo('Vacuum Intake', s0.x0+12, layout.centerY- s0.r, s0.x0-120, topY-6);
  labelFromTo('Magnetic Fan (negative-energy modulator)', layout.fanX, layout.centerY-34, s0.x0-120, topY+12);
  labelFromTo('Modulates Vacuum Air Circulation', s1.x0+6, layout.centerY- s1.r, s1.x0-10, topY+34);
  labelFromTo('Compression A/B/C', s2.x1-10, layout.centerY- s2.r, s2.x0-30, topY+54);
  labelFromTo('Modulates Vacuum Fluctuation', s4.x0+6, layout.centerY- s4.r, s4.x0-18, topY+74);
  labelFromTo('Reactors (Electro-plasma)', s5.x0+10, layout.centerY- s5.r, s5.x0+80, topY+94);
  labelFromTo('Photon/Plasma Mixer', s6.x0+10, layout.centerY- s6.r, s6.x0+140, topY+114);

  labelFromTo('Entanglement Feedback Loop', s5.x0+24, layout.centerY+16, s5.x0-40, botY);
  labelFromTo('Atomic Clocks (CST) + Entangled Feedback', s3.x0+20, layout.centerY, s3.x0-80, botY+24);
  labelFromTo('Pulse Control', s4.x1-8, layout.centerY+8, s4.x1+30, botY+48);
  labelFromTo('AFT Power Ramp', layout.nozzle.x0-10, layout.centerY+6, layout.nozzle.x0+40, botY+72);
  labelFromTo('AFT Power Ramp (Gradually)', layout.nozzle.x0+20, layout.centerY+22, layout.nozzle.x0+150, botY+96);
  labelFromTo('Gravitational Stabilization Panel', s2.x0+20, layout.centerY+ s2.r, s2.x0-40, botY+120);
  labelFromTo('Quantum Vertex Dampers (F/R/U/D/L/R)', s4.x0+20, layout.centerY+ s4.r, s4.x0+140, botY+144);
  labelFromTo('Detection Lasers (particles)', s1.x1-10, layout.centerY+ s1.r, s1.x1+110, botY+168);
  labelFromTo('Thermal Management (Water Cooling)', s5.x1-8, layout.centerY+ s5.r, s5.x1+160, botY+192);

  // research labels
  labelFromTo('ZPF Oscillator Rings (ZPO)', s4.x0+12, layout.centerY- s4.r+10, s4.x0-130, topY+136);
  labelFromTo('Casimir Microarrays', s3.x1-6, layout.centerY- s3.r+6, s3.x1+28, topY+156);
  labelFromTo('Tachyon Feedback Node', s5.x0+6, layout.centerY+12, s5.x0-140, botY+210);
  labelFromTo('CTC Guard (CST Damping)', s3.x0+8, layout.centerY+8, s3.x0-160, botY+234);
  labelFromTo('Positron Diagnostic Port', s6.x1-6, layout.centerY- s6.r+6, s6.x1+70, topY+176);
  labelFromTo('Limestone–Granite Resonator', s0.x0+20, layout.centerY+ s0.r-8, s0.x0-170, botY+208);

  const cx = layout.startX+layout.length*0.65;
  labelFromTo('Temporal vs Spatial Warp (rx/ry vs clock)', cx, layout.centerY - computeFieldRadius(warpFactor())*layout.bodyR*0.35 - 22, cx-180, topY-20);
  labelFromTo('Exotic-Matter Bypass (EM stress / Casimir)', s4.x1-6, layout.centerY+ s4.r-10, s4.x1+60, botY+180);

  // gradient / toroidal shell labels
  labelFromTo('Forward Gradient Panel (Contraction Field)', s4.x0+40, layout.centerY- s4.r-6, s4.x0+110, topY-24);
  labelFromTo('Aft Gradient Panel (Expansion Dump)', layout.nozzle.x0+40, layout.centerY+ layout.nozzle.r0, layout.nozzle.x0+170, botY+216);
  const cxField = layout.startX+layout.length*0.65;
  labelFromTo('Hull Gradient Emitters (Toroidal Warp–Shield Shell)', cxField, layout.centerY+ computeFieldRadius(warpFactor())*layout.bodyR*0.35+10, cxField+120, botY+252);
}

function drawCoreGlow(){
  var g = ctx.createLinearGradient(layout.startX, layout.centerY, layout.nozzle.x1, layout.centerY);
  g.addColorStop(0,'#a9bbff00');
  g.addColorStop(0.4,'#9bb4ff22');
  g.addColorStop(0.8,'#eaf0ff44');
  ctx.fillStyle=g;
  ctx.fillRect(layout.startX, layout.centerY-12, layout.nozzle.x1-layout.startX, 24);
}
function drawPlasmaCone(){
  var len = computePlasmaLength(warpFactor());
  var baseR = computePlasmaRadius(warpFactor());
  var x0 = layout.nozzle.x1;
  var x1 = x0 + len;
  var grad = ctx.createLinearGradient(x0, layout.centerY, x1, layout.centerY);
  grad.addColorStop(0, 'rgba(255,220,168,0.65)');
  grad.addColorStop(0.3, 'rgba(255,220,168,0.35)');
  grad.addColorStop(1, 'rgba(255,220,168,0.02)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x0, layout.centerY - baseR);
  ctx.lineTo(x1, layout.centerY - baseR*0.35);
  ctx.lineTo(x1, layout.centerY + baseR*0.35);
  ctx.lineTo(x0, layout.centerY + baseR);
  ctx.closePath();
  ctx.fill();
}
function drawPipes(){
  for(var i=0;i<pipes.length;i++){
    var p = pipes[i];
    ctx.strokeStyle='#6bd1ff';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x0, p.y0);
    ctx.lineTo(p.x1, p.y1);
    ctx.stroke();
    var n=4;
    for(var k=0;k<n;k++){
      var t = ((k/n) + (performance.now()*0.0005) ) % 1;
      var xx = p.x0 + (p.x1-p.x0)*t;
      var yy = p.y0 + (p.y1-p.y0)*t;
      ctx.fillStyle='#9bb4ff';
      ctx.beginPath();
      ctx.arc(xx, yy, 2, 0, TAU);
      ctx.fill();
    }
  }
}
function drawCoolingLoops(){
  var y = layout.centerY + layout.bodyR - 16;
  ctx.strokeStyle='#6bd1ff';
  ctx.lineWidth=2;
  ctx.beginPath();
  var x0 = layout.startX+10;
  ctx.moveTo(x0,y);
  for(var x1 = x0; x1 < layout.nozzle.x0-10; x1 += 32){
    ctx.lineTo(x1+16, y+6);
    ctx.lineTo(x1+32, y);
  }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b';
  ctx.lineWidth=1;
  var cxF = layout.startX - 20;
  var cxR = layout.nozzle.x1 + 20;
  var cy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(cxF, cy-44); ctx.lineTo(cxF-34, cy-44);
  ctx.moveTo(cxF, cy+44); ctx.lineTo(cxF-34, cy+44);
  ctx.moveTo(cxR, cy-34); ctx.lineTo(cxR+34, cy-34);
  ctx.moveTo(cxR, cy+34); ctx.lineTo(cxR+34, cy+34);
  ctx.stroke();

  var ccx = layout.startX+layout.length*0.65;
  var ccy = layout.centerY;
  ctx.beginPath();
  ctx.moveTo(ccx-16, ccy); ctx.lineTo(ccx+16, ccy);
  ctx.moveTo(ccx, ccy-16); ctx.lineTo(ccx, ccy+16);
  ctx.stroke();
}

// ===== Telemetry Update =====
function setGauge(span, frac){ span.style.width = (clamp(frac,0,1)*100).toFixed(0)+'%'; }
function updateTelemetry(dt){
  var w  = warpFactor();
  var sm = speedMult();
  var fr = fieldRadius();
  var hl = heatLevel();
  var cl = coolLevel();

  var instFps = (dt>0)? 1000/dt : 60;
  fps = fps*0.9 + instFps*0.1;

  var vLocal = localSpeedFrac(w);
  var gSR = gammaSR(w);
  var gGR = gammaGR_regime('sun'); // reference Sun-orbit regime
  var effClockRate = combinedClockRate(w,'sun');

  var p_phot = 0.7*sm;
  var p_ent  = 0.25*computeEntangleRate(w);
  var pWave  = (0.2*sm);

  var perSec = function(p){ return p * fps; };
  var mag = fr*sm;

  // gradient trim values (targets)
  var gFR = gradFrontRear();
  var gLR = gradLeftRight();
  var gWS = gradWarpShield();

  // auto-trim overlay for telemetry (like sensors nudging toward safe band)
  if(autoTrim){
    var t = performance.now()*0.0002;
    gFR += 0.04*Math.sin(t*1.4);
    gLR *= 0.45;
    gWS = clamp(gWS + 0.12*Math.sin(t*0.7), 0.25, 0.85);
  }

  var D = layout.bodyR*2;
  var base = fr*D*0.35;
  var ax = computeFieldAspectX(w);
  var ay = computeFieldAspectY(w);
  var rx = base*ax + 2*22;
  var ry = base*ay + 2*10;

  var coreC = computeCoreTempC(w);
  var coolC = computeCoolantTempC(w);

  v_speed.textContent = 'x'+sm.toFixed(1); setGauge(g_speed, (sm-1)/(6-1));
  v_field.textContent = fr.toFixed(2); setGauge(g_field, (fr-1.2)/(2.6-1.2));

  // shield fraction now modulated by warp vs shield emphasis
  var shieldFracRaw = (fr-1.2)/(2.6-1.2);
  var shieldFrac    = clamp(shieldFracRaw + (1-gWS)*0.3,0,1);

  v_fshield.textContent = Math.round(shieldFrac*100)+'%'; setGauge(g_fshield, shieldFrac);
  v_fstretch.textContent = fmt(rx,0)+' / '+fmt(ry,0); setGauge(g_fstretch, clamp(rx/(base*1.9+2*22),0,1));

  // gradient telemetry
  v_gradFR.textContent = gFR.toFixed(2)+'×';
  setGauge(g_gradFR, clamp(Math.abs(gFR-1)/0.3,0,1));
  v_gradLR.textContent = (gLR>=0?'+':'')+gLR.toFixed(2);
  setGauge(g_gradLR, Math.abs(gLR)/0.3);
  var warpPct   = Math.round(gWS*100);
  var shieldPct = 100-warpPct;
  v_gradWS.textContent = warpPct+'% warp / '+shieldPct+'% shield';
  setGauge(g_gradWS, gWS);

  v_clock.textContent = effClockRate.toFixed(3)+'×'; setGauge(g_clock, 1-effClockRate);
  v_phot.textContent = fmtLarge(perSec(p_phot))+' /s'; setGauge(g_phot, Math.min(perSec(p_phot)/3000,1));
  v_mag.textContent = mag.toFixed(2); setGauge(g_mag, Math.min(mag/6.0,1));

  v_tcore.textContent = coreC+' °C'; setGauge(g_tcore, Math.min(coreC/1500,1));
  v_tcool.textContent = coolC+' °C'; setGauge(g_tcool, Math.min(coolC/400,1));

  var entPerSec = perSec(p_ent);
  var entScaled = entPerSec>=1e9? (entPerSec/1e9).toFixed(2)+' G/s'
                 : entPerSec>=1e6? (entPerSec/1e6).toFixed(2)+' M/s'
                 : Math.round(entPerSec)+' /s';
  v_ent.textContent = entScaled; setGauge(g_ent, Math.min(entPerSec/3.2e6,1));

  var plen = computePlasmaLength(w); v_plen.textContent = plen+' u'; setGauge(g_plen, (plen-90)/(260-90));
  var prad = computePlasmaRadius(w); v_prad.textContent = prad+' u'; setGauge(g_prad, (prad-10)/(36-10));
  v_pwave.textContent = pWave.toFixed(2); setGauge(g_pwave, Math.min(pWave/1.2,1));

  var now = Date.now();
  clkUTC.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'UTC'});
  clkCST.textContent  = new Date(now).toLocaleTimeString('en-US',{hour12:false,timeZone:'America/Chicago'});

  // Warp-adjusted proper time clock: integrate CST time scaled by effClockRate
  warpClock += dt * effClockRate;
  clkWarp.textContent = new Date(warpClock).toLocaleTimeString('en-US',{hour12:false});
}

// ===== Render Loop =====
function render(dt){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawField();
  for(var i=0;i<layout.stages.length;i++){
    var s = layout.stages[i];
    drawCylinder(s.x0, s.x1, s.r, s.r);
  }
  drawNozzle(layout.nozzle);
  drawCoreGlow();
  for(var j=0;j<layout.coils.length;j++){ drawCoil(layout.coils[j].xOff); }
  drawFan(fanAngle);

  var pmult = speedMult();
  if(Math.random()<0.7*pmult) spawnParticle();
  for(var p=0;p<particles.length;p++){
    var pt = particles[p];
    pt.x += (1.9*pmult + pt.v)*1.2;
    pt.y += Math.sin((pt.x+pt.y)*0.01)*0.22*pmult;
    pt.life += dt;
  }
  particles = particles.filter(function(pt){ return pt.x < layout.nozzle.x1+560; });
  ctx.fillStyle='#9bb4ff';
  for(var q=0;q<particles.length;q++){
    ctx.globalAlpha=0.7;
    ctx.fillRect(particles[q].x, particles[q].y, 3, 2);
    ctx.globalAlpha=1;
  }

  if(Math.random()<0.25*pmult*heatLevel()) spawnHeat();
  if(Math.random()<0.25*pmult*coolLevel()) spawnCool();
  for(var h=0;h<heat.length;h++){ heat[h].life+=dt; heat[h].x+= 1.0*pmult; }
  for(var c0=0;c0<cool.length;c0++){ cool[c0].life+=dt; cool[c0].x+= 0.7*pmult; }
  heat = heat.filter(function(it){ return it.x<layout.nozzle.x1; });
  cool = cool.filter(function(it){ return it.x<layout.stages[3].x1; });
  for(var h2=0;h2<heat.length;h2++){
    ctx.fillStyle='#ffcc66';
    ctx.beginPath();
    ctx.arc(heat[h2].x,heat[h2].y,2+Math.sin(heat[h2].life*0.02)*1.5,0,TAU);
    ctx.fill();
  }
  for(var c2=0;c2<cool.length;c2++){
    ctx.fillStyle='#6bd1ff';
    ctx.beginPath();
    ctx.arc(cool[c2].x,cool[c2].y,2+Math.cos(cool[c2].life*0.02)*1.2,0,TAU);
    ctx.fill();
  }

  if(Math.random()<computeEntangleRate(warpFactor())*0.25) spawnEntangle();
  for(var e=0;e<entangle.length;e++){
    var en = entangle[e];
    en.life+=dt;
    en.x += 1.2*pmult;
    var amp = 26 + 8*Math.sin(en.life*0.01);
    var wv = 0.026*pmult;
    var yy = layout.centerY + Math.sin(en.phase + en.x*wv)*amp;
    ctx.fillStyle='#b26bff';
    ctx.beginPath();
    ctx.arc(en.x, yy, 2.2, 0, TAU);
    ctx.fill();
  }
  entangle = entangle.filter(function(en){ return en.x < layout.nozzle.x1 + 300; });

  drawPlasmaCone();
  drawPipes();
  drawCoolingLoops();
  drawLasers();

  drawTimeLegendLeft();
  drawCSTClock();
  drawStatusLabel();
  if(labelsEl.checked) drawLabels();
}

function loop(){
  if(!running) return;
  var now = performance.now();
  var dt = now - t0;
  t0 = now;
  fanAngle += 0.005 * dt * speedMult();
  render(dt);
  updateTelemetry(dt);
  requestAnimationFrame(loop);
}
loop();

// ===== Self-Tests =====
(function runTests(){
  var results = [];
  function ok(name,cond){ results.push((cond?'PASS ':'FAIL ')+name); }
  ok('speed increases', computeSpeedMult(10) > computeSpeedMult(1));
  ok('field grows', computeFieldRadius(10) > computeFieldRadius(1));
  ok('plasma length grows', computePlasmaLength(10) > computePlasmaLength(1));
  ok('plasma radius grows', computePlasmaRadius(10) > computePlasmaRadius(1));
  ok('entangle rate grows', computeEntangleRate(10) > computeEntangleRate(1));
  ok('field stretches wider', computeFieldAspectX(10) > computeFieldAspectX(1));
  var el = document.getElementById('tests');
  if(el){ el.textContent = 'Self-tests: ' + results.join(' | '); }
})();
</script>
<script>
// ===== FTL Jump Planner + Planet Map (uses same SR/GR/CST physics) =====
(function(){
  const distEl  = document.getElementById('jp_dist');
  const raEl    = document.getElementById('jp_ra');
  const decEl   = document.getElementById('jp_dec');
  const gravEl  = document.getElementById('jp_grav');
  const driftEl = document.getElementById('jp_drift');
  const statusEl= document.getElementById('jp_status');

  const alignEl = document.getElementById('jp_align');
  const depEl   = document.getElementById('jp_dep');
  const arrEl   = document.getElementById('jp_arr');
  const shipEl  = document.getElementById('jp_ship');
  const dlineEl = document.getElementById('jp_dline');
  const vappEl  = document.getElementById('jp_vapp');
  const gammaEl = document.getElementById('jp_gamma');
  const sidEl   = document.getElementById('jp_sid');
  const errEl   = document.getElementById('jp_err');
  const vecEl   = document.getElementById('jp_vec');

  const btnRun  = document.getElementById('jp_run');
  const btnReset= document.getElementById('jp_reset');

  const orbitCanvas = document.getElementById('orbitMap');
  const octx = orbitCanvas.getContext('2d');
  const plSel = document.getElementById('pl_target');
  const progEl= document.getElementById('pl_progress');

  // planet table with AU for info only; visual radius compressed so all fit
  const PLANETS = {
    mercury:{name:'Mercury', au:0.39},
    venus  :{name:'Venus',   au:0.72},
    earth  :{name:'Earth',   au:1.00},
    mars   :{name:'Mars',    au:1.52},
    jupiter:{name:'Jupiter', au:5.20},
    saturn :{name:'Saturn',  au:9.58},
    uranus :{name:'Uranus',  au:19.2},
    neptune:{name:'Neptune', au:30.1},
    pluto  :{name:'Pluto',   au:39.5}
  };
  const PLANET_ORDER = ['mercury','venus','earth','mars','jupiter','saturn','uranus','neptune','pluto'];

  let tripRunning=false;
  let tripT=0;
  let lastTripNow=performance.now();
  let tripDurationMs=10000; // will be set from jump physics (coordYears)

  function siderealDriftSeconds(days){
    const deltaPerDay = 24*3600 - (23*3600+56*60+4.1); // ≈ 235.9 s per day
    return days*deltaPerDay;
  }

  function formatDate(d){
    return d.toLocaleString('en-US',{
      timeZone:'America/Chicago',
      year:'numeric',month:'2-digit',day:'2-digit',
      hour:'2-digit',minute:'2-digit',second:'2-digit',
      hour12:false
    });
  }

  function computeJump(){
    const distLy = Math.max(0, parseFloat(distEl.value)||0);
    const raH    = parseFloat(raEl.value)||0;
    const decDeg = parseFloat(decEl.value)||0;
    const gravReg= gravEl.value;
    const driftDays = Math.max(0, parseFloat(driftEl.value)||0);

    if(distLy<=0){
      statusEl.textContent='Enter a distance > 0 light-years.';
      return null;
    }

    const warp = warpFactor();
    const vLocal = localSpeedFrac(warp);      // fraction of c
    const gSR = gammaSR(warp);
    const gGR = gammaGR_regime(gravReg);

    // coordinate CST travel time with warp geometry compression
    const coordYears = distLy / (warp * vLocal);          // apparent CST coord time
    const coordMs    = coordYears * 365.25*86400*1000;

    // ship proper time with SR·GR dilation
    const shipYears = coordYears / (gSR*gGR);

    // apparent velocity from CST: v_app = distance / coord time
    const vAppFrac = distLy/coordYears; // in units of c (since c=1 in ly/yr)
    const vAppClamped = Math.min(vAppFrac, 5.0); // cap at 5c for display

    // sidereal drift info
    const driftSec = siderealDriftSeconds(driftDays);

    // sky direction from RA/Dec (3D unit vector)
    const alpha = raH * (Math.PI/12); // hours→radians
    const delta = decDeg * (Math.PI/180);
    const nx = Math.cos(delta)*Math.cos(alpha);
    const ny = Math.cos(delta)*Math.sin(alpha);
    const nz = Math.sin(delta);

    // CST alignment rating: base on warp and sidereal age
    let align = 50 + 5*(warp-1) - 0.001*driftDays - 5*Math.abs(nz);
    align = clamp(align,0,100);

    // re-entry error in AU (smaller if alignment high)
    const errAU = (110-align)/20;
    const vecAlign = align;

    const now = new Date();
    const depCST = now;
    const arrCST = new Date(now.getTime()+coordMs);

    // animation duration derived from coordYears
    let baseYears = coordYears;
    if(baseYears < 0.1) baseYears = 0.1;
    if(baseYears > 30)  baseYears = 30;

    // Map [0.1, 30] years to roughly [6s, 22s] animation
    const minDur = 6000;
    const maxDur = 22000;
    const norm   = (baseYears - 0.1) / (30 - 0.1);
    tripDurationMs = minDur + norm * (maxDur - minDur);

    return {
      distLy, coordYears, shipYears,
      vAppClamped, vLocal,
      gSR,gGR,
      driftDays, driftSec,
      align, errAU, vecAlign,
      depCST, arrCST,
      dir:{x:nx,y:ny,z:nz}
    };
  }

  function updateReport(res){
    if(!res){
      alignEl.textContent=depEl.textContent=arrEl.textContent='—';
      shipEl.textContent=dlineEl.textContent=vappEl.textContent='—';
      gammaEl.textContent=sidEl.textContent=errEl.textContent=vecEl.textContent='—';
      return;
    }

    alignEl.textContent = res.align.toFixed(1)+' / 100';
    depEl.textContent   = formatDate(res.depCST);
    arrEl.textContent   = formatDate(res.arrCST);
    shipEl.textContent  = res.shipYears.toFixed(3)+' yr (ship frame)';
    dlineEl.textContent = res.distLy.toFixed(3)+' ly';
    vappEl.textContent  = res.vAppClamped.toFixed(2)+' c (apparent), local '+res.vLocal.toFixed(2)+' c';
    gammaEl.textContent = 'γ_SR='+res.gSR.toFixed(3)+', γ_GR='+res.gGR.toFixed(6)+', net rate≈'+(1/(res.gSR*res.gGR)).toFixed(3);
    sidEl.textContent   = res.driftDays.toFixed(0)+' days since J2000 → '+res.driftSec.toFixed(1)+' s sky drift';
    errEl.textContent   = res.errAU.toFixed(3)+' AU (est.)';
    vecEl.textContent   = res.vecAlign.toFixed(1)+' % alignment';
  }

  function resetReport(){
    updateReport(null);
    statusEl.textContent='Idle — waiting for CST jump.';
  }

  // ==== Orbit / planet map ====
  function drawMapBackground(targetKey, progress){
    const W = orbitCanvas.width;
    const H = orbitCanvas.height;
    octx.clearRect(0,0,W,H);

    const cx = W/2;
    const cy = H/2 + 4;                 // center a little below middle
    const scale = Math.min(W,H)/2.4;    // overall scaling

    // Compressed radii so Sun, Earth & all planets fit panel
    const earthIndex = PLANET_ORDER.indexOf('earth');
    const targetIndex= PLANET_ORDER.indexOf(targetKey);
    const baseR = scale*0.45;          // Earth orbit radius
    const step  = 14;                  // spacing between orbits

    const earthR = baseR;
    let targR    = baseR + (targetIndex-earthIndex)*step;
    if(targR < baseR*0.6) targR = baseR*0.6;           // inner planets still visible
    if(targR > Math.min(W,H)/2 - 16) targR = Math.min(W,H)/2 - 16; // keep inside window

    const target = PLANETS[targetKey];

    // Sun
    octx.fillStyle='#ffd27a';
    octx.beginPath();
    octx.arc(cx,cy,8,0,TAU);
    octx.fill();

    // Earth orbit & target orbit
    octx.strokeStyle='#2f3d6f';
    octx.lineWidth=1;
    octx.beginPath();
    octx.arc(cx,cy,earthR,0,TAU);
    octx.stroke();

    octx.strokeStyle='#45548a';
    octx.beginPath();
    octx.arc(cx,cy,targR,0,TAU);
    octx.stroke();

    // Earth fixed at +x
    const eX = cx + earthR;
    const eY = cy;
    octx.fillStyle='#6bd1ff';
    octx.beginPath();
    octx.arc(eX,eY,4,0,TAU);
    octx.fill();

    // Target planet at fixed phase angle
    const angle = -Math.PI/4;
    const pX = cx + targR*Math.cos(angle);
    const pY = cy + targR*Math.sin(angle);
    octx.fillStyle='#9bb4ff';
    octx.beginPath();
    octx.arc(pX,pY,4,0,TAU);
    octx.fill();

    // line Earth→target
    octx.strokeStyle='#556bff88';
    octx.lineWidth=1.2;
    octx.beginPath();
    octx.moveTo(eX,eY);
    octx.lineTo(pX,pY);
    octx.stroke();

    // ship dot along that line
    const t = clamp(progress,0,1);
    const sX = eX + (pX-eX)*t;
    const sY = eY + (pY-eY)*t;
    octx.fillStyle = '#33e1b5';
    octx.beginPath();
    octx.arc(sX,sY,3.2,0,TAU);
    octx.fill();

    // labels
    octx.fillStyle='#eaf0ff';
    octx.font='9px system-ui';
    octx.textAlign='left';
    octx.fillText('Sun', cx+10, cy-6);
    octx.fillText('Earth (static)', eX-40, eY-9);
    octx.fillText(target.name+' orbit', cx+targR*Math.cos(angle)-26, cy+targR*Math.sin(angle)-8);
  }

  drawMapBackground(plSel.value,0);

  function tripLoop(){
    const now = performance.now();
    const dt = now - lastTripNow;
    lastTripNow = now;

    if(tripRunning){
      const dur = tripDurationMs>0 ? tripDurationMs : 10000;
      tripT += dt / dur;
      if(tripT>=1){
        tripT = 1;
        tripRunning=false;
        statusEl.textContent='Jump complete — CST re-entry reached for this target.';
      }
    }

    drawMapBackground(plSel.value, tripT);
    progEl.textContent = Math.round(tripT*100)+'%';

    requestAnimationFrame(tripLoop);
  }
  tripLoop();

  btnRun.addEventListener('click', ()=>{
    const res = computeJump();
    if(!res) return;
    updateReport(res);
    statusEl.textContent='Jump computed — SR/GR + CST + RA/Dec applied. Dot now traveling Earth → '+PLANETS[plSel.value].name+'. Local plasma stays < c; apparent FTL comes from warp geometry and CST mapping.';
    // reset and start planet trip with new duration from jump physics
    tripT = 0;
    tripRunning = true;
    lastTripNow = performance.now();
  });

  btnReset.addEventListener('click', ()=>{
    distEl.value  = 4.20;
    raEl.value    = 14.6590;
    decEl.value   = -60.8353;
    gravEl.value  = 'sun';
    driftEl.value = 9200;
    tripT = 0;
    tripRunning = false;
    tripDurationMs = 10000;
    drawMapBackground(plSel.value,0);
    progEl.textContent='0%';
    resetReport();
  });

  plSel.addEventListener('change', ()=>{
    drawMapBackground(plSel.value, tripT);
  });
})();
</script>
</body>
</html>
