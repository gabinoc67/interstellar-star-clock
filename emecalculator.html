<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Einstein Master Equation — Symmetry • Λ • EM • CST • WDW overlay</title>
<style>
  :root{
    --bg:#0b1020;--panel:#0f1633;--ink:#eaf0ff;--muted:#a9b6dd;--accent:#79d2ff;
    --ok:#3fe5a8;--warn:#ffd86b;--bad:#ff6b87;--br:#22305c;
  }
  *{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 system-ui,Segoe UI,Roboto,Arial}
  header{position:sticky;top:0;z-index:5;background:rgba(11,16,32,.86);backdrop-filter:blur(6px);
         border-bottom:1px solid var(--br);padding:14px 16px}
  h1{margin:0;font-size:20px} .sub{color:var(--muted);font-size:13px;margin-top:4px}
  main{max-width:1120px;margin:16px auto;padding:0 14px 100px}
  .card{background:linear-gradient(180deg,var(--panel),#0c1330);border:1px solid var(--br);border-radius:14px;padding:14px;margin:10px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grid{display:grid;gap:12px}
  .cols-2{grid-template-columns:1fr}
  @media(min-width:980px){.cols-2{grid-template-columns:1.1fr .9fr}}
  label{font-size:12px;color:var(--muted)} input,select{background:#0a1230;color:var(--ink);border:1px solid #2a3d6b;border-radius:10px;padding:8px 10px}
  input:focus,select:focus{outline:none;border-color:var(--accent)}
  button{background:#0f1b44;color:var(--ink);border:1px solid var(--br);border-radius:10px;padding:9px 12px;cursor:pointer}
  button.primary{background:linear-gradient(180deg,#38c2ff,#1697d3);border-color:#1592cb;color:#001421;font-weight:700}
  .tag{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--br);padding:4px 8px;border-radius:999px;background:#0d1538;color:var(--muted);font-size:12px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .eq{background:#0a1130;border:1px solid #213159;border-radius:12px;padding:10px;margin:6px 0}
  .status{display:flex;gap:10px;align-items:center;padding:10px;border:1px solid var(--br);border-radius:12px;background:#0e1636}
  .ok{border-color:#1b644a;background:rgba(63,229,168,.08)} .warn{border-color:#5d4e17;background:rgba(255,216,107,.08)}
  .bad{border-color:#6a1e33;background:rgba(255,107,135,.08)}
  .hint{color:var(--muted);font-size:12px}
  canvas{width:100%;height:180px;background:#09102a;border-radius:10px;display:block}
  .small{font-size:12px}
  @media print{
    header,.controls,.no-print{display:none !important}
    body{background:#fff;color:#000} .card{border-color:#bbb;background:#fff}
    canvas{filter:grayscale(1)}
  }
</style>
</head>
<body>
<header>
  <h1>Einstein Master Equation — Minimal Verifier & Navigator</h1>
  <div class="sub">
    Symmetry budget → <b>C</b> (covariant continuity); EM & Λ → <b>E</b> (field mismatch). Includes:
    Classical Unified (GR+EM, no QM), Λ sign, EM stress tensor (plane wave), CST kernel, Wheeler–DeWitt “forbidden” overlay,
    run logs, CSV/JSON export & print. Credit: <b>Gabino Casanova</b>.
  </div>
</header>

<main>
  <!-- Core equation & promise -->
  <section class="card">
    <div class="row" style="justify-content:space-between">
      <span class="tag">Keep E = ‖G + Λg − (8πG/c⁴)T<sub>tot</sub>‖ and C = max<sub>ν</sub>‖∇<sub>μ</sub>T<sub>tot</sub><sup>μν</sup>‖ green</span>
      <span class="tag">Symmetry → C • EM/Λ → E</span>
    </div>
    <div class="eq mono">
      G<sub>μν</sub> + Λ g<sub>μν</sub> = (8πG/c⁴) [ T<sub>EM</sub> + T<sub>matter</sub> + T<sub>QM</sub> + T<sub>CST</sub> ]<br/>
      E(t) = ‖G + Λg − (8πG/c⁴)T<sub>tot</sub>‖<sub>w</sub>, &nbsp;
      C(t) = max<sub>ν</sub> ‖∇<sub>μ</sub>T<sub>tot</sub><sup>μν</sup>‖
    </div>
    <div class="small hint">Classical Unified mode mirrors Einstein’s classical grail (deterministic GR+EM, no quantum probabilities). Semiclassical mode adds ⟨T<sub>QM</sub>⟩.</div>
  </section>

  <!-- How-to with samples -->
  <section class="card">
    <h3 style="margin:0 0 6px">How to use (step-by-step)</h3>
    <ol class="small" style="margin:6px 0 0 18px">
      <li>Pick a mode: <b>Classical Unified (GR+EM)</b> or <b>Semiclassical (GR+⟨T⟩)</b>. Choose Λ <b>sign</b> (+/−) and magnitude.</li>
      <li>Click <b>Sample PASS</b> then <b>Run</b> to see GO (both E & C green). Then try <b>Sample FAIL</b> → NO-GO.</li>
      <li>Enter your own inputs, <b>Run</b>, and watch <b>Symmetry Wave</b>, <b>Curvature + WDW overlay</b>, and gauges.</li>
      <li>Export logs via <b>Download JSON</b>/<b>Download CSV</b> or <b>Print Summary</b>.</li>
    </ol>
  </section>

  <!-- Two extra wave panels (fixed & animated) -->
  <section class="card grid cols-2">
    <div>
      <h3 style="margin:0 0 6px">Symmetry Wave (p, L, E budget visual)</h3>
      <canvas id="waveST"></canvas>
      <div class="hint small">Three traveling traces stand in for translation/rotation/time symmetry budgets that feed the C-metric.</div>
    </div>
    <div>
      <h3 style="margin:0 0 6px">Curvature & Wheeler–DeWitt Overlay</h3>
      <canvas id="waveCurv"></canvas>
      <div class="hint small">Orange curve = curvature proxy. Shaded band = WDW-like “forbidden” region (too-strong curvature). The band moves with the wave crest.</div>
    </div>
  </section>

  <!-- Controls + status -->
  <section class="card grid cols-2">
    <div class="controls">
      <h3 style="margin:0 0 6px">Inputs & Modes</h3>
      <div class="row">
        <label>Steps</label><input id="steps" type="number" value="500" min="100" step="50">
        <label>Δt</label><input id="dt" type="number" value="0.02" step="0.001">
        <label>ε<sub>GR</sub></label><input id="epsGR" type="number" value="1e-6" step="1e-7">
        <label>ε<sub>QM</sub></label><input id="epsQM" type="number" value="1e-6" step="1e-7">
        <label>ε<sub>ΔC</sub></label><input id="epsDC" type="number" value="1e-6" step="1e-7">
      </div>
      <div class="row" style="margin-top:6px">
        <label>k<sub>p</sub></label><input id="kp" type="number" value="1.8" step="0.1">
        <label>k<sub>d</sub></label><input id="kd" type="number" value="0.35" step="0.05">
        <label>Flux F₀ (W/m²)</label><input id="F0" type="number" value="1361" step="1">
        <label>Redshift z</label><input id="z" type="number" value="0.0001" step="1e-5">
      </div>
      <div class="row" style="margin-top:6px">
        <label>Λ sign</label>
        <select id="lambdaSign"><option value="+">+</option><option value="-">−</option></select>
        <label>|Λ|</label><input id="lambdaAbs" type="number" value="1e-52" step="1e-53">
        <label>Mode</label>
        <select id="unifiedMode">
          <option value="semiclassical">Semiclassical (GR + ⟨T⟩)</option>
          <option value="classical">Classical Unified (GR + EM, no QM)</option>
        </select>
      </div>
      <div class="row" style="margin-top:6px">
        <label>Teleparallel</label>
        <select id="teleparallel"><option value="off">Off</option><option value="on">On (TEGR remap)</option></select>
        <label>EFT corrections</label>
        <select id="eftOrder"><option value="0">0 (none)</option><option value="1">+R²</option><option value="2">+R²+Ricci²</option></select>
        <label>EM coupling</label>
        <select id="emOn"><option value="on">On</option><option value="off">Off</option></select>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="primary" id="run">Run</button>
        <button id="reset">Reset</button>
        <button id="presetPass">Sample PASS</button>
        <button id="presetFail">Sample FAIL</button>
      </div>
    </div>

    <div>
      <h3 style="margin:0 0 6px">Status</h3>
      <div id="status" class="status">
        <div>
          <div id="statusTitle"><b>Idle</b> — choose a preset or set inputs.</div>
          <div class="hint small" id="statusDetail">Loop: EM + (QM if enabled) + CST → GR(+Λ) → metrics E & C → GO/NO-GO.</div>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <span id="badgeE" class="tag mono">E: —</span>
        <span id="badgeC" class="tag mono">C: —</span>
        <span id="badgeGO" class="tag">GO/NO-GO: —</span>
      </div>
      <canvas id="chart" style="margin-top:10px"></canvas>
    </div>
  </section>

  <!-- WDW threshold + Nav hazard -->
  <section class="card">
    <h3 style="margin:0 0 6px">WDW Forbidden Threshold & Navigation Hazard</h3>
    <div class="row">
      <label>WDW curvature threshold</label><input id="wdwThresh" type="number" value="0.75" step="0.05">
      <label>Hazard threshold</label><input id="hazardThresh" type="number" value="0.35" step="0.05">
      <label>Sensor bubble radius</label><input id="bubbleR" type="number" value="1.0" step="0.1">
      <button id="printBtn" class="no-print">Print Summary</button>
    </div>
    <canvas id="hazard"></canvas>
    <div class="row" style="margin-top:8px">
      <span id="riskBadge" class="tag">Risk: —</span>
      <span class="hint small">Shaded “forbidden” band (above) visualizes a Wheeler–DeWitt–style no-go region in strong curvature; the hazard index below blends wave amplitude with recent E&C.</span>
    </div>
  </section>

  <!-- Data recorder -->
  <section class="card">
    <h3 style="margin:0 0 6px">Run Logs</h3>
    <div class="row">
      <button id="dlJson">Download JSON</button>
      <button id="dlCsv">Download CSV</button>
      <span id="logBadge" class="tag">Log: —</span>
    </div>
    <div class="hint small">Per-step log: t, E, C, GR_res, QM_res, ΔC, F_eff, Λ, hazard, wave amplitudes, mode, flags.</div>
  </section>

  <footer class="small hint">
    This is a compact verifier. Replace the three hooks (<span class="mono">grStep</span>, <span class="mono">qmStep</span>, <span class="mono">cstStress</span>)
    with physical kernels for a scientific build. The Classical Unified option matches Einstein’s classical program; Semiclassical adds ⟨T⟩.
  </footer>
</main>

<script>
/* ========= utilities ========= */
const C_LIGHT = 299792458.0;
function sizeCanvas(c){const d=window.devicePixelRatio||1; c.width=Math.floor(c.clientWidth*d); c.height=Math.floor(c.clientHeight*d); const x=c.getContext('2d'); x.setTransform(d,0,0,d,0,0); return x;}
function linePlot(canvas, series){
  const ctx=sizeCanvas(canvas), W=canvas.clientWidth, H=canvas.clientHeight;
  ctx.clearRect(0,0,W,H); ctx.strokeStyle='#17284a'; for(let i=1;i<5;i++){const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();}
  let xmin=1e9,xmax=-1e9,ymin=1e9,ymax=-1e9;
  series.forEach(s=>s.forEach(([t,v])=>{xmin=Math.min(xmin,t);xmax=Math.max(xmax,t);ymin=Math.min(ymin,v);ymax=Math.max(ymax,v);}));
  if(!isFinite(ymin)||!isFinite(ymax)){ymin=0;ymax=1;} if(ymin===ymax){ymax=ymin+1;}
  const pad=8, xmap=t=>(t-xmin)/(xmax-xmin||1)*(W-2*pad)+pad, ymap=v=>H-((v-ymin)/(ymax-ymin||1))*(H-2*pad)-pad;
  const colors=['#79d2ff','#ffb36b','#3fe5a8'];
  series.forEach((s,i)=>{ctx.strokeStyle=colors[i%colors.length]; ctx.lineWidth=2; ctx.beginPath();
    s.forEach(([t,v],j)=>{const X=xmap(t), Y=ymap(v); j?ctx.lineTo(X,Y):ctx.moveTo(X,Y);}); ctx.stroke();});
}
function setBadge(el,text,kind){el.textContent=text; el.className='tag mono '+(kind||'');}
function setStatus(kind,title,detail){ const box=document.getElementById('status'); box.className='status '+(kind||''); document.getElementById('statusTitle').innerHTML='<b>'+title+'</b>'; document.getElementById('statusDetail').textContent=detail||''; }

/* ========= waves: symmetry & curvature (always running) ========= */
let wT=0, runWaves=true;
function drawSymmetryWave(){
  const c=document.getElementById('waveST'); if(!c) return; const ctx=sizeCanvas(c); const W=c.clientWidth, H=c.clientHeight;
  ctx.clearRect(0,0,W,H);
  const bands=[{f:1.2,a:12},{f:1.8,a:10},{f:2.6,a:8}];
  bands.forEach((b,i)=>{
    ctx.beginPath(); ctx.lineWidth=1.6; ctx.strokeStyle=`rgba(121,210,255,${0.75-0.18*i})`;
    for(let x=0;x<=W;x++){ const y=H*0.5 + Math.sin((x/W)*Math.PI*2*b.f + wT*(0.8+i*0.2))*b.a; if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y) }
    ctx.stroke();
  });
}
function drawCurvatureWithWDW(){
  const c=document.getElementById('waveCurv'); if(!c) return; const ctx=sizeCanvas(c); const W=c.clientWidth, H=c.clientHeight;
  ctx.clearRect(0,0,W,H);
  // curvature wave
  ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='rgba(255,179,107,0.95)';
  let maxAmp=0, maxX=0, yVals=new Array(W+1);
  for(let x=0;x<=W;x++){
    const u=x/W, base=14*Math.sin(2*Math.PI*u*0.9 + wT*0.65);
    const bump=Math.exp(-40*(u-((wT*0.05)%1))**2)*28*Math.sin(wT*0.8);
    const y=H*0.5 + base + bump; yVals[x]=y;
    const amp=Math.abs(base)+Math.abs(bump); if(amp>maxAmp){maxAmp=amp; maxX=x;}
    if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  // WDW forbidden overlay follows the moving crest
  const thr=parseFloat(document.getElementById('wdwThresh').value); // 0..1 scale
  const bandH = 20 + 40*thr;
  const cx=maxX, top=Math.max(0, yVals[cx]-bandH), bot=Math.min(H, yVals[cx]+bandH);
  const grd=ctx.createLinearGradient(0,top,0,bot); grd.addColorStop(0,'rgba(255,107,135,0.12)'); grd.addColorStop(1,'rgba(255,107,135,0.28)');
  ctx.fillStyle=grd; ctx.fillRect(0, top, W, bot-top);
  ctx.strokeStyle='rgba(255,107,135,0.6)'; ctx.setLineDash([6,6]); ctx.strokeRect(0, top, W, bot-top); ctx.setLineDash([]);
  // caption
  ctx.fillStyle='rgba(234,240,255,0.8)'; ctx.font='12px system-ui'; ctx.fillText('WDW forbidden region', 8, Math.max(12, top-4));
}
function waveLoop(){ if(!runWaves) return; wT += 0.08; drawSymmetryWave(); drawCurvatureWithWDW(); requestAnimationFrame(waveLoop); }
requestAnimationFrame(waveLoop);

/* ========= physics “kernels” (grounded but simple) =========
   EM stress-energy (plane wave, direction x):
     S = F_eff (W/m²), u = S/c  (energy density), momentum density g = S/c².
     We use a scalar magnitude T_em = u as the source contribution.
   CST stress-energy (actuator): energy density ρ_cst = α (kp Δh + kd Δḣ)², pressure ~ ρ_cst (radiation-like).
   GR step: decay of metric error ΔC with drive from total source + |Λ|, teleparallel bias optional.
   QM step (semiclassical): toy Lindblad norm decays and contributes ⟨T_QM⟩ magnitude.
*/
function photonEff(F0,z,emOn){ return emOn==='on' ? F0/Math.pow(1+z,4) : 0; } // W/m²
function emStressMagnitude(F_eff){ return F_eff / C_LIGHT; } // u = S/c  (proxy magnitude)
function cstStressMagnitude(kp,kd,dC){ const dCdot=-dC; const force=Math.max(0, kp*dC + kd*Math.abs(dCdot)); return 0.5*force*force; } // positive definite

function makeSolver(params){
  const state={ h:params.dC0, rho:params.Rqm0 };
  function qmStep(dt, F_eff, enabled){
    if(!enabled) return {R_QM:0, Tq:0};
    const beta=Math.max(0.05, 0.15*params.kp + 0.05*params.kd);
    state.rho = Math.max(0, state.rho*Math.exp(-beta*dt) - 1e-8*F_eff);
    const R_QM = Math.max(1e-12, params.Rqm0*(state.rho/(params.Rqm0+1e-12)));
    const Tq   = 0.5*state.rho + 0.5*state.h; // proxy coupling
    return {R_QM, Tq};
  }
  function grStep(dt, S_tot, lambda, tele){
    const alpha=Math.max(0.05, 0.20*params.kp + 0.06*params.kd);
    const teleBias=(tele==='on'?0.92:1.0);
    state.h = Math.max(0, state.h*Math.exp(-alpha*dt) - teleBias*1e-7*S_tot - 1e-9*Math.abs(lambda));
    const R_GR = Math.max(1e-12, params.Rgr0*(state.h/(params.dC0+1e-12)));
    return R_GR;
  }
  return {state,qmStep,grStep};
}

/* ========= thresholds ========= */
function thresholds(){ return {Egoal:0.01,Esoft:0.03,Ehard:0.05,Cgoal:0.01,Chard:0.03}; }

/* ========= RUN ========= */
let LAST_LOG = null;
async function runSim(){
  const N = parseInt(document.getElementById('steps').value,10);
  const dt = parseFloat(document.getElementById('dt').value);
  const epsGR = parseFloat(document.getElementById('epsGR').value);
  const epsQM = parseFloat(document.getElementById('epsQM').value);
  const epsDC = parseFloat(document.getElementById('epsDC').value);
  const kp = parseFloat(document.getElementById('kp').value);
  const kd = parseFloat(document.getElementById('kd').value);
  const F0 = parseFloat(document.getElementById('F0').value);
  const z  = parseFloat(document.getElementById('z').value);
  const lambda = (document.getElementById('lambdaSign').value==='-'?-1:+1)*Math.abs(parseFloat(document.getElementById('lambdaAbs').value)||0);
  const mode = document.getElementById('unifiedMode').value; // classical or semiclassical
  const tele = document.getElementById('teleparallel').value;
  const eft  = parseInt(document.getElementById('eftOrder').value,10);
  const emOn = document.getElementById('emOn').value;
  const th = thresholds();

  setStatus('', mode==='classical'?'Running (Classical Unified — GR+EM)…':'Running (Semiclassical)…', `Λ=${lambda.toExponential(2)}, EM=${emOn}, TEGR=${tele}, EFT=${eft}`);

  const params={Rgr0:0.08,Rqm0:0.06,dC0:0.10,kp,kd};
  const solver=makeSolver(params);

  let t=0, prevTot=null;
  const Eser=[], Cser=[], GR=[], QM=[], DC=[], HAZ=[], AMP=[], rows=[];

  for(let i=0;i<N;i++){
    // EM plane-wave stress
    const F_eff = photonEff(F0,z,emOn);          // W/m²
    const T_em  = emStressMagnitude(F_eff);      // scalar u

    // CST stress (PD -> energy density)
    const dC = solver.state.h;
    const T_cst = cstStressMagnitude(kp,kd,dC);

    // QM step (off in classical mode)
    const q = solver.qmStep(dt, F_eff, mode!=='classical');

    // total source magnitude for GR
    let S_tot = T_em + T_cst + q.Tq;

    // EFT tweak (toy): effective small reduction to mismatch; tiny jitter to conservation
    if(eft===1) S_tot*=1.02; else if(eft===2) S_tot*=1.04;

    // GR step
    const g = solver.grStep(dt, S_tot, lambda, tele);

    // E metric (weighted residuals + small Λ term)
    const base=Math.max(1e-12, params.Rgr0*0.5 + params.Rqm0*0.3 + params.dC0*0.2);
    let E = (g*0.5 + q.R_QM*0.3 + Math.abs(solver.state.h)*0.2)/base;
    E += 0.02 * Math.abs(lambda) / (Math.abs(lambda)+1e-52); // Λ contribution

    // C metric (proxy ∇·T via change of totals)
    const tot = g + q.R_QM + Math.abs(solver.state.h) + 1e-6*Math.abs(lambda);
    let C = (prevTot==null)? 0 : Math.abs(tot-prevTot)/(prevTot+1e-12); prevTot=tot;
    if(eft===2) C += 0.002;

    // wave amplitude near ship (from curvature panel phase)
    const amp = 0.4 + 0.6*(0.5*(1+Math.sin(wT*0.4))); // 0.4..1.0
    const hazard = Math.min(1, Math.max(0, 0.5*amp + 0.3*(E/th.Egoal) + 0.2*(C/th.Cgoal)))
                   * Math.min(1.5, Math.max(0.5, parseFloat(document.getElementById('bubbleR').value)));

    Eser.push([t,E]); Cser.push([t,C]); GR.push([t,g]); QM.push([t,q.R_QM]); DC.push([t,Math.abs(solver.state.h)]); HAZ.push([t,hazard]); AMP.push([t,amp]);

    rows.push({t, E, C, GR_res:g, QM_res:q.R_QM, dC:Math.abs(solver.state.h), F_eff, lambda, hazard, amp, mode, tele, eft, emOn});
    t += dt;
  }

  // charts
  linePlot(document.getElementById('chart'), [Eser,Cser,HAZ]);

  // badges
  const Eend=Eser.at(-1)[1], Cend=Cser.at(-1)[1];
  setBadge(document.getElementById('badgeE'), `E: ${Eend.toExponential(2)}`, (Eend<=th.Egoal?'ok':(Eend<=th.Esoft?'warn':'bad')));
  setBadge(document.getElementById('badgeC'), `C: ${Cend.toExponential(2)}`, (Cend<=th.Cgoal?'ok':(Cend<=th.Chard?'warn':'bad')));

  const tailOK = Eser.slice(-Math.min(80,Eser.length)).every(p=>p[1]<=th.Egoal)
               && Cser.slice(-Math.min(80,Cser.length)).every(p=>p[1]<=th.Cgoal);
  const withinEps = (GR.at(-1)[1]<epsGR) && (mode==='classical' || QM.at(-1)[1]<epsQM) && (DC.at(-1)[1]<epsDC);
  const GO = tailOK && withinEps;

  const goEl=document.getElementById('badgeGO');
  goEl.textContent = 'GO/NO-GO: '+(GO?'GO':'NO-GO');
  goEl.className   = 'tag ' + (GO?'ok':'bad');
  setStatus(GO?'ok':'warn', GO?'Solved within band':'Not solved',
            GO?'E & C tails green; residuals under ε.':'Tune Λ sign/magnitude, gains, EM/EFT or install full kernels.');

  // hazard bar below
  drawHazard(HAZ.at(-1)[1], parseFloat(document.getElementById('hazardThresh').value));

  // store log
  LAST_LOG = {
    meta:{ts:new Date().toISOString(), mode, tele, eft, emOn,
          steps:N, dt, epsGR, epsQM, epsDC, kp, kd, F0, z, lambda},
    tails:{E_end:Eend, C_end:Cend, GO, tailOK, withinEps},
    series:{E:Eser, C:Cser, GR:GR, QM:QM, dC:DC, hazard:HAZ, amp:AMP},
    rows
  };
  document.getElementById('logBadge').textContent='Log: ready';
}

/* ========= Hazard bar ========= */
function drawHazard(risk, thresh){
  const c=document.getElementById('hazard'), ctx=sizeCanvas(c), W=c.clientWidth, H=c.clientHeight;
  ctx.clearRect(0,0,W,H);
  ctx.strokeStyle='#17284a'; for(let i=1;i<5;i++){const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();}
  const x0=10, w=W-20, val=Math.max(0,Math.min(1,risk));
  const grd=ctx.createLinearGradient(x0,0,x0+w,0); grd.addColorStop(0,'#3fe5a8'); grd.addColorStop(0.5,'#ffd86b'); grd.addColorStop(1,'#ff6b87');
  ctx.fillStyle=grd; ctx.fillRect(x0,H*0.55, val*w,18); ctx.strokeStyle='#223a6b'; ctx.strokeRect(x0,H*0.55,w,18);
  const T=x0+Math.max(0,Math.min(1,thresh))*w; ctx.strokeStyle='rgba(234,240,255,0.7)'; ctx.beginPath(); ctx.moveTo(T,H*0.55-6); ctx.lineTo(T,H*0.55+24); ctx.stroke();
  const badge=document.getElementById('riskBadge');
  badge.textContent=`Risk: ${val.toFixed(2)} (thresh ${Math.max(0,Math.min(1,thresh)).toFixed(2)})`;
  badge.className='tag '+(val<=thresh?'ok':(val<=thresh*1.2?'warn':'bad'));
}

/* ========= Presets / Reset / Print / Downloads ========= */
function setVal(id,v){const el=document.getElementById(id); if(el) el.value=v;}
function preset(pass){
  if(pass){
    setVal('steps',700); setVal('dt',0.02);
    setVal('epsGR',1e-6); setVal('epsQM',1e-6); setVal('epsDC',1e-6);
    setVal('kp',2.2); setVal('kd',0.45);
    setVal('F0',1361); setVal('z',0.00005);
    setVal('lambdaSign','+'); setVal('lambdaAbs',1e-52);
    setVal('unifiedMode','semiclassical'); setVal('teleparallel','off'); setVal('eftOrder','1'); setVal('emOn','on');
    setVal('wdwThresh',0.75); setVal('hazardThresh',0.35); setVal('bubbleR',1.0);
  }else{
    setVal('steps',400); setVal('dt',0.03);
    setVal('epsGR',1e-6); setVal('epsQM',1e-6); setVal('epsDC',1e-6);
    setVal('kp',0.9); setVal('kd',0.10);
    setVal('F0',2200); setVal('z',0.004);
    setVal('lambdaSign','-'); setVal('lambdaAbs',4e-52);
    setVal('unifiedMode','classical'); setVal('teleparallel','on'); setVal('eftOrder','0'); setVal('emOn','on');
    setVal('wdwThresh',0.55); setVal('hazardThresh',0.5); setVal('bubbleR',1.2);
  }
  document.getElementById('steps').scrollIntoView({behavior:'smooth',block:'center'});
}
function resetAll(){
  setVal('steps',500); setVal('dt',0.02);
  setVal('epsGR',1e-6); setVal('epsQM',1e-6); setVal('epsDC',1e-6);
  setVal('kp',1.8); setVal('kd',0.35);
  setVal('F0',1361); setVal('z',0.0001);
  setVal('lambdaSign','+'); setVal('lambdaAbs',1e-52);
  setVal('unifiedMode','semiclassical'); setVal('teleparallel','off'); setVal('eftOrder','0'); setVal('emOn','on');
  setVal('wdwThresh',0.75); setVal('hazardThresh',0.35); setVal('bubbleR',1.0);
  setBadge(document.getElementById('badgeE'),'E: —'); setBadge(document.getElementById('badgeC'),'C: —');
  const goEl=document.getElementById('badgeGO'); goEl.textContent='GO/NO-GO: —'; goEl.className='tag';
  setStatus('', 'Idle', 'Choose a preset or set inputs, then Run.');
  linePlot(document.getElementById('chart'), []);
  drawHazard(0, parseFloat(document.getElementById('hazardThresh').value));
}
function toCSV(rows){
  if(!rows||!rows.length) return '';
  const cols=Object.keys(rows[0]); const esc=v=>String(v).includes(',')?`"${String(v).replace(/"/g,'""')}"`:String(v);
  const head=cols.join(','); const body=rows.map(r=>cols.map(k=>esc(r[k])).join(',')).join('\n');
  return head+'\n'+body;
}
function download(name, text, mime='text/plain'){
  const blob=new Blob([text],{type:mime}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
}

/* ========= wire up ========= */
window.addEventListener('resize', ()=>{
  linePlot(document.getElementById('chart'), []);
  drawSymmetryWave(); drawCurvatureWithWDW();
  if(LAST_LOG){ const last=LAST_LOG.series.hazard.at(-1)?.[1]??0; drawHazard(last, parseFloat(document.getElementById('hazardThresh').value)); }
});
document.getElementById('run').addEventListener('click', runSim);
document.getElementById('reset').addEventListener('click', resetAll);
document.getElementById('presetPass').addEventListener('click', ()=>preset(true));
document.getElementById('presetFail').addEventListener('click', ()=>preset(false));
document.getElementById('printBtn').addEventListener('click', ()=>window.print());
document.getElementById('dlJson').addEventListener('click', ()=>{
  if(!LAST_LOG){ document.getElementById('logBadge').textContent='Log: run first'; return; }
  download('eme_run_log.json', JSON.stringify(LAST_LOG,null,2),'application/json');
});
document.getElementById('dlCsv').addEventListener('click', ()=>{
  if(!LAST_LOG){ document.getElementById('logBadge').textContent='Log: run first'; return; }
  download('eme_run_log.csv', toCSV(LAST_LOG.rows), 'text/csv');
});

/* init */
resetAll();
</script>
</body>
</html>
