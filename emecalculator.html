<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Einstein Master Equation Calculator — GR ⟷ QM ⟷ Photons ⟷ CST</title>

<!-- MathJax for equations -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
  :root{
    --bg:#0b0f14; --panel:#121822; --ink:#e6edf7; --muted:#98a2b3; --accent:#6ee7ff;
    --ok:#3ddc97; --warn:#ffdd57; --bad:#ff5c7a; --border:#1d2940;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--ink);
       background: radial-gradient(1200px 520px at 120% -20%, rgba(167,139,250,.07), transparent 40%), #0a0e16;}
  header{padding:20px 24px; border-bottom:1px solid #1b2433; position:sticky; top:0; background:rgba(10,14,22,.85); backdrop-filter:blur(6px)}
  h1{margin:0; font-size:22px}
  .sub{color:var(--muted); font-size:14px; margin-top:6px; line-height:1.45}
  main{max-width:1200px; margin:22px auto; padding:0 16px 80px}
  .grid{display:grid; gap:16px}
  .cols-2{grid-template-columns:repeat(2,1fr)}
  .cols-3{grid-template-columns:repeat(3,1fr)}
  .card{background:linear-gradient(180deg,#121827,#0e1523); border:1px solid var(--border); border-radius:16px; padding:16px; box-shadow:0 12px 30px rgba(0,0,0,.2)}
  .kicker{color:var(--accent); text-transform:uppercase; letter-spacing:.12em; font-size:12px}
  label{display:block; font-size:12px; color:var(--muted); margin:8px 0 4px}
  input,select,textarea{width:100%; background:#0b1220; color:var(--ink); border:1px solid #263349; border-radius:10px; padding:10px 12px; outline:none}
  textarea{min-height:88px; resize:vertical}
  input:focus,select:focus,textarea:focus{border-color:var(--accent)}
  .btnrow{display:flex; gap:12px; flex-wrap:wrap; margin-top:12px}
  button{background:linear-gradient(180deg,#18263a,#122035); color:#e6f3ff; border:1px solid #223149; border-radius:12px; padding:10px 14px; cursor:pointer}
  button.primary{background:linear-gradient(180deg,#00bcd4,#0094b2); border-color:#00a5be; color:#00131a; font-weight:700}
  .eq{font-family:ui-serif,Georgia,serif; font-size:14px; line-height:1.55; background:#0b1220; border:1px solid #243149; border-radius:12px; padding:12px}
  .badge{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid #1e2a3b; background:#0b1220}
  .ok{color:var(--ok); border-color:#134c39}
  .warn{color:var(--warn); border-color:#4d4116}
  .bad{color:var(--bad); border-color:#4d1e2b}
  .hint{color:var(--muted); font-size:12px; margin-top:6px}
  table{width:100%; border-collapse:collapse; border:1px solid #1e2a3b; border-radius:12px; overflow:hidden}
  th,td{padding:10px 12px; border-bottom:1px solid #1c2738; font-size:14px}
  th{background:#0f1626}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  canvas{width:100%; height:220px; border-radius:12px; background:radial-gradient(800px 300px at 120% -20%, rgba(110,231,255,.06), transparent 40%), #0a0f17}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; border:1px solid #243149; background:#0b1220; font-size:13px}
  .toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:12px}
  .divider{height:1px; background:#1c2738; margin:8px 0}
</style>
</head>
<body>
<header>
  <h1>Einstein Master Equation Calculator</h1>
  <div class="sub">
    Operates a GR–Quantum–Photon–CST self-consistency loop with live **tensor** checks (mismatch & conservation), Safety Monitor with **Green/Amber/Red**, GO/NO-GO,
    and data logging. <i>Solvers are placeholders</i>; swap in ADM/BSSN (GR), Lindblad (QM), Maxwell/Radiative (EM) at the hooks without changing the UI.
  </div>
</header>

<main class="grid">

  <!-- How to use -->
  <section class="card">
    <div class="kicker">How to use</div>
    <ol style="margin:6px 0 6px 18px">
      <li>Enter steps, Δt, tolerances (ε<sub>GR</sub>, ε<sub>QM</sub>, ε<sub>ΔC</sub>), initial residuals, PD gains, flux inputs, and (optional) event times.</li>
      <li>Pick a Safety Margin (±1% or ±5%) and a Mode (Hold/Accelerate/Decelerate/Stop).</li>
      <li>Click <b>Run Simulation</b>. If residuals and tensor checks meet thresholds for the hold window, you’ll get GO; else NO-GO or SafeDrop.</li>
      <li>Replace the 3 hook functions (<code>grStep</code>, <code>qmStep</code>, <code>cstFeedback</code>) with your physical solvers to turn this into a real verifier.</li>
    </ol>
    <div class="hint">Passing demo: click <b>Fill Inputs — Passing Demo</b> below, then <b>Run Simulation</b>.</div>
  </section>

  <!-- Equations: includes "what remains" -->
  <section class="card">
    <div class="kicker">Einstein “Master Equation” (tensor form & checks)</div>
    <div class="grid cols-2">
      <div class="eq">
        <b>Field equation (with total stress–energy)</b><br/>
        \[
          G_{\mu\nu}(g) \;=\; 8\pi G\,
          \Big(T^{\text{matter}}_{\mu\nu} + T^{\text{photon}}_{\mu\nu} + T^{\text{quantum}}_{\mu\nu} + T^{\text{CST}}_{\mu\nu}\Big)
        \]
        <b>Tensor mismatch norm (decision metric)</b><br/>
        \[
          E(t)\;=\;\big\|\,G_{\mu\nu}-8\pi G\,T^{\text{tot}}_{\mu\nu}\,\big\|_w
        \qquad\text{(target }\le1\%\text{; soft }3\%\text{; hard }5\%\text{)}
        \]
        <b>Conservation law</b><br/>
        \[
          \nabla_\mu T^{\mu\nu}_{\text{tot}} = 0,\qquad
          C(t)=\max_\nu \big\|\,\nabla_\mu T^{\mu\nu}_{\text{tot}}\,\big\|
        \]
      </div>
      <div class="eq">
        <b>Quantum (Lindblad) + CST control</b><br/>
        \[
          \dot{\hat\rho} = -\frac{i}{\hbar}\,[\hat H(g,A_\mu),\hat\rho] + \sum_j \kappa_j \mathcal D[L_j]\hat\rho + \mathcal L_{\text{CST}}
        \]
        \[
          F^{\text{CST}}_{\mu\nu} = -k_p\,\Delta h_{\mu\nu}-k_d\,\Delta \dot h_{\mu\nu}
        \]
        <b>Photons (effective flux → stress–energy)</b><br/>
        \[
          F_{\mathrm{eff}}(t)=\frac{F_0\,[1+\delta I + \delta I_{\text{events}}(t)]\,M}{(1+z)^4},\quad
          T^{\text{photon}}_{\mu\nu}\sim \frac{F_{\mathrm{eff}}}{c}
        \]
        <b>Analytic-limit regression</b><br/>
        With photon/quantum/CST $\to 0$, recover known GR (Minkowski/Schwarzschild/FRW) within tolerance.
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge">Gauge constraints monitored</span>
      <span class="badge">Energy renormalization guarded</span>
      <span class="badge">No hidden power injection</span>
    </div>
  </section>

  <!-- Inputs -->
  <section class="card">
    <div class="kicker">Inputs</div>
    <h2>Simulation & Physics Parameters</h2>

    <div class="grid cols-3">
      <div>
        <label>Steps (N)</label><input id="steps" type="number" min="10" max="20000" step="10" value="500">
        <label>Δt</label><input id="dt" type="number" step="0.001" value="0.02">
      </div>
      <div>
        <label>ε<sub>GR</sub></label><input id="epsGR" type="number" step="1e-6" value="1e-6">
        <label>ε<sub>QM</sub></label><input id="epsQM" type="number" step="1e-6" value="1e-6">
      </div>
      <div>
        <label>ε<sub>ΔC</sub></label><input id="epsDC" type="number" step="1e-6" value="1e-6">
        <label>Consecutive steps for “solved”</label><input id="hold" type="number" min="5" step="5" value="50">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>R<sub>GR</sub>(0)</label><input id="Rgr0" type="number" step="0.001" value="0.08">
        <label>R<sub>QM</sub>(0)</label><input id="Rqm0" type="number" step="0.001" value="0.06">
      </div>
      <div>
        <label>ΔC(0)</label><input id="dC0" type="number" step="0.001" value="0.10">
        <label>h-spectrum imbalance (0–1)</label><input id="spec0" type="number" min="0" max="1" step="0.01" value="0.70">
      </div>
      <div>
        <label>PD gain k<sub>p</sub></label><input id="kp" type="number" step="0.001" value="1.6">
        <label>PD gain k<sub>d</sub></label><input id="kd" type="number" step="0.001" value="0.3">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Photon base flux F₀ [W/m²]</label><input id="F0" type="number" step="1" value="1361">
        <label>Lensing magnification M</label><input id="Mlens" type="number" step="0.01" value="1.00">
      </div>
      <div>
        <label>Variability δI (fraction)</label><input id="dI" type="number" step="0.001" value="0.03">
        <label>Redshift z (grav+cosmo)</label><input id="zred" type="number" step="1e-5" value="0.00010">
      </div>
      <div>
        <label>Noise τ (s) for OU</label><input id="tauNoise" type="number" step="1" value="600">
        <label>Noise σ (fraction)</label><input id="sigmaNoise" type="number" step="0.001" value="0.005">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Event times (s, comma or space separated)</label>
        <textarea id="eventTimes" placeholder="e.g. 120, 340, 355, 910, 1240, 1805, 1812, 2600"></textarea>
      </div>
      <div>
        <label>Kernel type</label>
        <select id="kernelType"><option value="gauss">Gaussian</option><option value="epa">Epanechnikov</option><option value="exp">Exponential (causal)</option></select>
        <label>Bandwidth / decay h (s)</label><input id="bandwidth" type="number" step="1" value="300">
      </div>
      <div>
        <label>Intensity scale c<sub>λ</sub> → fractional flux</label><input id="clambda" type="number" step="0.001" value="0.01">
        <div class="hint">This converts λ̂(t) into δI<sub>events</sub>(t).</div>
      </div>
    </div>

    <!-- Pilot panel -->
    <div class="divider"></div>
    <div class="toolbar">
      <span class="pill">
        <label style="margin:0 6px 0 0">Mode</label>
        <select id="modeSelect">
          <option value="hold">Hold</option>
          <option value="accel">Accelerate</option>
          <option value="decel">Decelerate</option>
          <option value="stop">Stop at B</option>
        </select>
      </span>
      <span class="pill">
        <label style="margin:0 6px 0 0">Safety margin</label>
        <select id="marginSelect">
          <option value="tight">±1% (ideal)</option>
          <option value="wide">±5% (max)</option>
        </select>
      </span>
      <button class="primary" id="runBtn">Run Simulation</button>
      <button id="resetBtn">Reset</button>
      <button id="abortBtn" title="Immediate safe drop to normal flight">ABORT (SafeDrop)</button>
      <span id="statusBadge" class="badge warn">Idle — awaiting run</span>
      <span id="stateBadge" class="badge">State: —</span>
      <span id="goBadge" class="badge">GO/NO-GO: —</span>
    </div>
  </section>

  <!-- Residuals -->
  <section class="card">
    <div class="kicker">Run Log</div>
    <h2>Residuals vs. Time</h2>
    <canvas id="residuals"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="solvedBadge">Self-consistency: —</span>
      <span class="badge" id="stableBadge">Stability: —</span>
      <span class="badge" id="physicalBadge">Physicality: —</span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="gaugeBadge">Gauge: —</span>
      <span class="badge" id="consBadge">∇·T: —</span>
      <span class="badge" id="cflBadge">CFL: —</span>
    </div>
  </section>

  <!-- Tensor checks -->
  <section class="card">
    <div class="kicker">Tensor Checks</div>
    <h2>Mismatch E(t) & Conservation C(t)</h2>
    <canvas id="tensorChecks"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="Ebadge">E metric: —</span>
      <span class="badge" id="Cbadge">C metric: —</span>
    </div>
  </section>

  <!-- Fields -->
  <section class="card">
    <div class="kicker">Fields</div>
    <h2>h<sub>μν</sub> Snapshots & Spectra (illustrative)</h2>
    <div class="grid cols-2">
      <div><h3 style="margin-bottom:6px">Snapshot: pre-control</h3><canvas id="snapPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Snapshot: post-control</h3><canvas id="snapPost"></canvas></div>
    </div>
    <div class="grid cols-2" style="margin-top:12px">
      <div><h3 style="margin-bottom:6px">Spectrum: pre</h3><canvas id="specPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Spectrum: post</h3><canvas id="specPost"></canvas></div>
    </div>
  </section>

  <!-- Energy -->
  <section class="card">
    <div class="kicker">Energy</div>
    <h2>Input Power vs. Curvature Change (Efficiency)</h2>
    <canvas id="energy"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="effBadge">Efficiency: —</span>
      <span class="badge" id="powerBadge">Total power: —</span>
    </div>
  </section>

  <!-- Validation -->
  <section class="card">
    <div class="kicker">Validation</div>
    <h2>Observable Checks</h2>
    <table>
      <thead><tr><th>Test</th><th>Target</th><th>Measured</th><th>Status</th></tr></thead>
      <tbody>
        <tr><td>Solar-system orbits (fractional err/orbit)</td><td class="mono">&lt; 1e-8</td><td id="orbitVal" class="mono">—</td><td id="orbitStatus">—</td></tr>
        <tr><td>Cosmology (FRW homogeneous limit)</td><td class="mono">match</td><td id="frwVal" class="mono">—</td><td id="frwStatus">—</td></tr>
        <tr><td>Lab EM cavity (Δf vs small h)</td><td class="mono">linear</td><td id="labVal" class="mono">—</td><td id="labStatus">—</td></tr>
      </tbody>
    </table>
  </section>

  <!-- Purpose + How to enter (your original help) -->
  <section class="card">
    <div class="kicker">What it does & How to enter data</div>
    <h2>Einstein Master Equation — Purpose</h2>
    <p>
      The calculator couples four pieces into one loop:
      <b>(1)</b> GR curvature via the Einstein equations,
      <b>(2)</b> Quantum state evolution via a Lindblad master equation,
      <b>(3)</b> Photon forcing via flux (EM stress–energy),
      <b>(4)</b> CST feedback control that damps metric error.
      When all three residuals fall below tolerance and stay there (hold window), the system is <em>self-consistent</em> for those inputs.
    </p>
    <!-- (help text unchanged for brevity) -->
  </section>

  <!-- Examples -->
  <section class="card">
    <div class="kicker">Examples</div>
    <h2>Quick Fills (try these, then Run)</h2>
    <div class="grid cols-3">
      <div>
        <h3 style="margin:.2rem 0">1) Sun–Earth (quiet Sun)</h3>
        <p class="hint">Stable baseline, minimal events; should damp smoothly.</p>
        <button onclick="loadExample('quiet')" class="primary">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">2) Sun–Earth (flare events)</h3>
        <p class="hint">Adds bursty event times and larger variability.</p>
        <button onclick="loadExample('flare')" class="">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">3) Lab EM cavity (minimal flux)</h3>
        <p class="hint">Toy lab case: tiny flux & tighter tolerances.</p>
        <button onclick="loadExample('lab')" class="">Fill Inputs</button>
      </div>
    </div>
  </section>

  <!-- Passing demo -->
  <section class="card">
    <div class="kicker">Example that passes all tests</div>
    <p class="hint">Click the button to auto-fill parameters that (with these toy kernels) pass the checks; then press <b>Run Simulation</b>.</p>
    <button class="primary" onclick="loadExample('pass')">Fill Inputs — Passing Demo</button>
  </section>

  <!-- Data recorder -->
  <section class="card">
    <div class="kicker">Data Recorder</div>
    <div class="row">
      <button id="downloadBtn">Download Log (JSON)</button>
      <span id="logBadge" class="badge">Log: —</span>
      <a id="logLink" class="badge" style="display:none" download="eme_run_log.json">Download ready</a>
    </div>
    <p class="hint">Logs include: plan/depart/ETA/arrive stamps, tensor metrics (E, C), residual traces, power schedule, mode & safety state, and summary pass/fail.</p>
  </section>

  <footer class="hint">This demo uses toy dynamics to exercise the full workflow. Swap your GR + QM + CST + EM kernels into the 3 hook functions to verify a physical target.</footer>
</main>

<script>
// ---------- drawing helpers ----------
function clearCanvas(c){const x=c.getContext('2d'); x.clearRect(0,0,c.width,c.height); return x;}
function sizeCanvas(c){const dpr=window.devicePixelRatio||1; c.width=Math.floor(c.clientWidth*dpr); c.height=Math.floor(c.clientHeight*dpr); c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);}
function linePlot(canvas, series, colors, labels){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight;
  ctx.strokeStyle="#1b2a3d"; ctx.lineWidth=1; for(let i=1;i<=4;i++){const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();}
  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  series.forEach(s=>s.forEach(p=>{xmin=Math.min(xmin,p[0]); xmax=Math.max(xmax,p[0]); ymin=Math.min(ymin,p[1]); ymax=Math.max(ymax,p[1]);}));
  if(!isFinite(ymin)||!isFinite(ymax)){ymin=0;ymax=1;} if(ymin===ymax){ymax=ymin+1;}
  const pad=8, xmap=x=>(x-xmin)/(xmax-xmin||1)*(W-2*pad)+pad, ymap=y=>H-((y-ymin)/(ymax-ymin||1))*(H-2*pad)-pad;
  series.forEach((s,i)=>{ctx.strokeStyle=colors[i%colors.length]; ctx.lineWidth=2; ctx.beginPath(); s.forEach((p,j)=>{const X=xmap(p[0]); const Y=ymap(p[1]); j?ctx.lineTo(X,Y):ctx.moveTo(X,Y);}); ctx.stroke();});
  ctx.font="12px system-ui"; let x=8,y=16; labels.forEach((L,i)=>{ctx.fillStyle=colors[i%colors.length]; ctx.fillRect(x,y-8,10,10); ctx.fillStyle="#cfe6ff"; ctx.fillText(" "+L, x+12, y); x+=140;});
}
function blob(canvas, strength, seed){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight; const cx=W*0.5, cy=H*0.5;
  const grd=ctx.createRadialGradient(cx,cy,10, cx,cy, Math.max(W,H)*0.6); const a=Math.max(0.12, Math.min(0.85, strength));
  grd.addColorStop(0, `rgba(110,231,255,${a})`); grd.addColorStop(0.35, `rgba(167,139,250,${a*0.7})`); grd.addColorStop(1, "rgba(0,0,0,0)"); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha=0.4; ctx.strokeStyle="rgba(110,231,255,0.35)"; ctx.lineWidth=1.2;
  for(let k=1;k<=6;k++){ ctx.beginPath(); for(let x=0;x<W;x++){ const y=cy + Math.sin((x/W)*Math.PI*2*(k+seed))* (10+strength*20)/(k*0.6); x===0?ctx.moveTo(x,y):ctx.lineTo(x,y);} ctx.stroke(); }
  ctx.globalAlpha=1;
}
function bars(canvas, vec){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight; const n=vec.length, w=(W-20)/n;
  for(let i=0;i<n;i++){ const v=Math.max(0,Math.min(1,vec[i])); const h=v*H*0.9; ctx.fillStyle=`rgba(167,139,250,${0.25+0.6*v})`; ctx.fillRect(10+i*w, H-h-10, w*0.7, h); }
}
function setBadge(el, text, cls){ el.textContent=text; el.className='badge '+cls; }
function setValRow(valEl, statusEl, measured, pass){ valEl.textContent = measured; statusEl.innerHTML = pass ? `<span class="badge ok">PASS</span>` : `<span class="badge bad">FAIL</span>`; }

// ---------- photon forcing & events ----------
function makeOUNoise(tau, sigma, dt){
  let x = 0; const a = Math.exp(-dt/Math.max(1e-9,tau)); const s = sigma*Math.sqrt(1-a*a);
  return ()=>{ x = a*x + s*(Math.random()*2-1); return x; };
}
function photonFluxEffective(F0, dI, M, z, extraFrac){
  const factor = M / Math.pow(1+z,4);
  const jitter = 1 + dI + extraFrac;
  return Math.max(0, F0 * factor * jitter);
}
function parseEvents(text){
  return text.split(/[,\s]+/).map(Number).filter(v=>isFinite(v)).sort((a,b)=>a-b);
}
function lambdaGaussian(t, events, h){
  const inv = 1/(h*Math.sqrt(2*Math.PI)); let s=0;
  for (let i=0;i<events.length;i++){ const u=(t-events[i])/h; s += Math.exp(-0.5*u*u); }
  return inv*s;
}
function lambdaExpCausal(t, events, h){
  let s=0; for (let i=0;i<events.length;i++){ const dt=t-events[i]; if(dt>=0) s += (1/h)*Math.exp(-dt/h); }
  return s;
}
function lambdaEpanechnikov(t, events, h){
  let s=0; for (let i=0;i<events.length;i++){ const u=(t-events[i])/h; if (Math.abs(u)<=1) s += 0.75*(1-u*u)/h; }
  return s;
}

// ---------- UI refs ----------
const resCanvas  = document.getElementById('residuals');
const tensorCanvas = document.getElementById('tensorChecks');
const snapPre    = document.getElementById('snapPre');
const snapPost   = document.getElementById('snapPost');
const specPre    = document.getElementById('specPre');
const specPost   = document.getElementById('specPost');
const energyC    = document.getElementById('energy');

const statusBadge  = document.getElementById('statusBadge');
const solvedBadge  = document.getElementById('solvedBadge');
const stableBadge  = document.getElementById('stableBadge');
const physicalBadge= document.getElementById('physicalBadge');
const orbitVal   = document.getElementById('orbitVal');
const orbitStatus= document.getElementById('orbitStatus');
const frwVal     = document.getElementById('frwVal');
const frwStatus  = document.getElementById('frwStatus');
const labVal     = document.getElementById('labVal');
const labStatus  = document.getElementById('labStatus');
const gaugeBadge = document.getElementById('gaugeBadge');
const consBadge  = document.getElementById('consBadge');
const cflBadge   = document.getElementById('cflBadge');
const Ebadge     = document.getElementById('Ebadge');
const Cbadge     = document.getElementById('Cbadge');
const stateBadge = document.getElementById('stateBadge');
const goBadge    = document.getElementById('goBadge');
const abortBtn   = document.getElementById('abortBtn');

const modeSelect   = document.getElementById('modeSelect');
const marginSelect = document.getElementById('marginSelect');

const downloadBtn = document.getElementById('downloadBtn');
const logBadge    = document.getElementById('logBadge');
const logLink     = document.getElementById('logLink');

function P(id){ return parseFloat(document.getElementById(id).value); }
function setVal(id, v){ const el=document.getElementById(id); if(el) el.value=v; }

// ---------- thresholds & safety ----------
function thresholdsFromMargin(margin){
  if(margin==='tight'){ // ±1% ideal
    return { E_goal:0.01, E_soft:0.03, E_hard:0.05, C_goal:0.01, C_hard:0.03,
             width:0.02, rho:0.03, g:0.01, powerCont:0.80, powerPeak:0.95 };
  }
  // ±5% max
  return { E_goal:0.05, E_soft:0.07, E_hard:0.10, C_goal:0.05, C_hard:0.08,
           width:0.05, rho:0.07, g:0.05, powerCont:0.80, powerPeak:0.95 };
}

// ---------- SOLVER HOOKS (REPLACE WITH REAL KERNELS) ----------
function makeInBrowserSolver(params){
  // Swap these scalars for your field grids/tensors and density matrix
  const state = { hNorm: params.dC0, rhoNorm: params.Rqm0, t:0 };

  // 1) GR STEP: integrate linearized Einstein equation using source strength
  function grStep(dt, S_strength){
    // TODO: replace with your GR PDE step and residual norm
    const alpha = Math.max(0.05, Math.min(5, 0.2*params.kp + 0.05*params.kd));
    state.hNorm = Math.max(0, state.hNorm * Math.exp(-alpha*dt) - 0.00001*S_strength);
    const R_GR = Math.max(1e-16, params.Rgr0 * (state.hNorm / (params.dC0+1e-12)));
    return R_GR;
  }

  // 2) QM STEP: Lindblad density-matrix update; return residual + ⟨T̂⟩ magnitude (proxy)
  function qmStep(dt, couplingPhi, F_eff){
    // TODO: replace with your master-equation integrator & stress-energy expectation
    const beta = Math.max(0.05, Math.min(5, 0.17*params.kp + 0.07*params.kd));
    state.rhoNorm = Math.max(0, state.rhoNorm * Math.exp(-beta*dt) - 0.00001*(couplingPhi + 1e-6*F_eff));
    const R_QM = Math.max(1e-16, params.Rqm0 * (state.rhoNorm / (params.Rqm0+1e-12)));
    const Tq_exp_mag = Math.max(0, 0.5*state.rhoNorm + 0.5*state.hNorm); // proxy
    return { R_QM, Tq_exp_mag };
  }

  // 3) CST FEEDBACK: PD law based on Δh and Δḣ
  function cstFeedback(dt){
    // TODO: compute Δh_{μν}, Δḣ_{μν} from your metric fields
    const dC = state.hNorm; const dCdot = -dC;
    const Fmag = Math.max(0, params.kp*dC + params.kd*Math.abs(dCdot));
    return Fmag;
  }

  return { state, grStep, qmStep, cstFeedback };
}

// ---------- POWER SCHEDULER (stub with rate limits & 1g constraint) ----------
function makeScheduler(th){
  let powerSet = 0;
  const R_MAX = 0.10; // max fractional change per step (rate limit)
  function step(mode, wantPower, gError){
    // Enforce 1 g band by biasing power slightly against error
    const gBias = Math.max(-0.05, Math.min(0.05, -gError));
    let target = Math.max(0, Math.min(th.powerPeak, wantPower + gBias));
    // Rate limit
    const delta = Math.max(-R_MAX, Math.min(R_MAX, target - powerSet));
    powerSet = Math.max(0, Math.min(th.powerPeak, powerSet + delta));
    return powerSet;
  }
  return { step };
}

// ---------- SAFETY MONITOR ----------
function makeSafetyMonitor(th){
  let state = 'GREEN';
  function evaluate(E, C, widthErr, rhoErr, gErr, coilTempOK=true){
    // Amber if trending out; Red if beyond hard limits
    const red = (E>th.E_hard) || (C>th.C_hard) || (Math.abs(widthErr)>th.width*2) || (Math.abs(rhoErr)>th.rho*2) || (Math.abs(gErr)>th.g*2) || !coilTempOK;
    const amber = (!red) && (E>th.E_soft || Math.abs(widthErr)>th.width || Math.abs(rhoErr)>th.rho || Math.abs(gErr)>th.g);
    state = red ? 'RED' : (amber ? 'AMBER' : 'GREEN');
    return state;
  }
  return { get state(){return state;}, evaluate };
}

// ---------- MAIN SIMULATION ----------
let ABORTED=false, LAST_LOG=null;

async function simulate(){
  ABORTED=false; setBadge(stateBadge, "State: —","badge"); setBadge(goBadge,"GO/NO-GO: —","badge"); setBadge(logBadge,"Log: —","badge"); logLink.style.display='none';

  // read inputs
  const N=parseInt(document.getElementById('steps').value,10);
  const dt=P('dt'), epsGR=P('epsGR'), epsQM=P('epsQM'), epsDC=P('epsDC'), hold=parseInt(document.getElementById('hold').value,10);
  const params={ Rgr0:P('Rgr0'), Rqm0:P('Rqm0'), dC0:P('dC0'), spec0:Math.max(0,Math.min(1,P('spec0'))), kp:P('kp'), kd:P('kd') };
  const F0=P('F0'), Ml=P('Mlens'), dI=P('dI'), z=P('zred'), tau=P('tauNoise'), sig=P('sigmaNoise');
  const mode = modeSelect.value; const th = thresholdsFromMargin(marginSelect.value);

  const ou = makeOUNoise(tau, sig, dt);
  const events = parseEvents(document.getElementById('eventTimes').value);
  const kernel = document.getElementById('kernelType').value;
  const h = P('bandwidth'); const c_lambda = P('clambda');

  function lambdaHat(t){
    if (events.length===0) return 0;
    if (kernel==="gauss") return lambdaGaussian(t, events, h);
    if (kernel==="exp")   return lambdaExpCausal(t, events, h);
    if (kernel==="epa")   return lambdaEpanechnikov(t, events, h);
    return 0;
  }

  // series
  const seriesGR=[], seriesQM=[], seriesDC=[], seriesPow=[], seriesEff=[]; // existing
  const seriesE=[], seriesC=[]; // tensor checks

  // GO/NO-GO counters
  let solvedCount=0, t=0, totPower=0, totCurv=0;

  // plan/ETA stamps (toy)
  const planTime = new Date().toISOString();
  const etaSeconds = N*dt; const etaTime = new Date(Date.now()+etaSeconds*1000).toISOString();

  const solver = makeInBrowserSolver(params);
  const sched  = makeScheduler(th);
  const safety = makeSafetyMonitor(th);

  // helper: weighted norm (toy) — replace with field norms when real tensors are in place
  const w_gr=0.5, w_qm=0.3, w_cst=0.2;
  function tensorMismatch(R_GR, R_QM, dC){
    const base = Math.max(1e-12, params.Rgr0*w_gr + params.Rqm0*w_qm + params.dC0*w_cst);
    const num  = (R_GR*w_gr + R_QM*w_qm + Math.abs(dC)*w_cst);
    return num / base; // ~fractional mismatch
  }
  // toy conservation: use finite-difference on "total" norm as a proxy for ∇·T
  let prevTot = null;
  function conservationMetric(R_GR, R_QM, dC){
    const tot = R_GR + R_QM + Math.abs(dC);
    const C   = (prevTot==null)? 0 : Math.abs(tot - prevTot)/(prevTot+1e-12);
    prevTot = tot; return C;
  }

  // desired power vs mode (very simple profile)
  function wantPowerFromMode(mode, tFrac){
    if(mode==='accel') return Math.min(th.powerCont, 0.2 + 0.8*tFrac);
    if(mode==='decel') return Math.max(0, th.powerCont*(1.0 - tFrac));
    if(mode==='stop')  return (tFrac<0.8)? th.powerCont*0.6 : th.powerCont*(0.2*(1-(tFrac-0.8)/0.2));
    return th.powerCont*0.6; // hold
  }

  let state='GREEN'; setBadge(stateBadge, "State: GREEN","ok");
  setBadge(statusBadge, "Running…", "badge");

  for(let i=0;i<N;i++){
    if(ABORTED){ setBadge(statusBadge,"Aborted — SafeDrop","bad"); break; }

    const tFrac = i/(N-1);

    // event-driven fractional change + OU noise baseline
    const dI_events = c_lambda * lambdaHat(t);
    const extraFrac = (dI_events + ou());

    // Photon forcing adjusted by gravity & lensing
    const F_eff = photonFluxEffective(F0, dI, Ml, z, extraFrac);

    // map flux to an EM source magnitude: ~ F/c (SI). Replace with your T^{EM}_{μν}.
    const S_em_mag = F_eff / 299792458;

    // CST feedback
    const Fmag = solver.cstFeedback(dt);

    // QM step (can depend on control and photon flux)
    const qm = solver.qmStep(dt, Fmag, F_eff);

    // GR step uses total source strength (quantum + EM + CST)
    const R_GR = solver.grStep(dt, qm.Tq_exp_mag + S_em_mag + Fmag);
    const R_QM = qm.R_QM;
    const dC   = solver.state.hNorm;

    // Tensor checks (toy forms)
    const E = tensorMismatch(R_GR, R_QM, dC);
    const C = conservationMetric(R_GR, R_QM, dC);

    // width & rho errors (corridor envelopes — proxies here)
    const widthErr = 0.01*(Math.sin(6.28*tFrac)*0.5); // toy small error
    const rhoErr   = 0.015*(Math.cos(6.28*tFrac)*0.5); // toy small error

    // Maintain 1 g error proxy from dC (smaller dC → closer to 1g)
    const gErr = Math.min(0.2, Math.max(-0.2, dC)); // toy

    // Scheduler & power (rate limited with 1g constraint)
    const wantP = wantPowerFromMode(mode, tFrac);
    const powerSet = sched.step(mode, wantP, gErr);

    // energy accounting (toy)
    const power = Math.max(0, params.kp*dC*dC + params.kd*dC*dC) * (0.2+0.8*powerSet);
    const dCurv = Math.max(0, (params.Rgr0+params.Rqm0) - (R_GR+R_QM));
    totPower += power*dt; totCurv += dCurv*dt;

    // Safety monitor
    state = safety.evaluate(E, C, widthErr, rhoErr, gErr, /*coilTempOK*/true);
    if(state==='AMBER') setBadge(stateBadge,"State: AMBER","warn");
    if(state==='RED'){ setBadge(stateBadge,"State: RED — SafeDrop","bad"); break; }

    // logs
    seriesGR.push([t,R_GR]); seriesQM.push([t,R_QM]); seriesDC.push([t,dC]);
    seriesE.push([t,E]); seriesC.push([t,C]);
    seriesPow.push([t,power]); seriesEff.push([t, totPower>0 ? (totCurv/totPower) : 0]);

    // solved window
    if (R_GR<epsGR && R_QM<epsQM && dC<epsDC && E<=th.E_goal && C<=th.C_goal) solvedCount++; else solvedCount=0;
    t += dt;
  }

  // plots
  linePlot(resCanvas, [seriesGR,seriesQM,seriesDC], ["#6ee7ff","#a78bfa","#3ddc97"], ["R_GR","R_QM","ΔC"]);
  linePlot(tensorCanvas, [seriesE,seriesC], ["#ff9f43","#ff5c7a"], ["E(t) mismatch","C(t) conservation"]);

  blob(snapPre, params.spec0, 2);
  blob(snapPost, Math.max(0, params.spec0-0.55), 4);
  const pre = Array.from({length:24},(_,i)=> Math.max(0,0.2 + 0.8*Math.sin((i/24)*Math.PI*2*3+0.4))*(0.6+0.5*params.spec0));
  const post= pre.map(v=> v*0.45);
  bars(specPre, pre); bars(specPost, post);
  linePlot(energyC, [seriesPow, seriesEff], ["#ffdd57","#3ddc97"], ["input power","efficiency"]);

  // badges & checks
  const solved = solvedCount>=hold;
  setBadge(solvedBadge, solved ? "Self-consistency: PASS" : "Self-consistency: NOT MET", solved ? "ok":"bad");

  const tail = Math.floor(seriesDC.length*0.8);
  const stable = seriesDC.slice(tail).every((p,idx,arr)=> idx===0 || p[1] <= arr[idx-1][1]+1e-9);
  setBadge(stableBadge, stable ? "Stability: DAMPED" : "Stability: UNSTABLE?", stable ? "ok":"warn");

  const E_end = seriesE.length? seriesE.at(-1)[1] : 1;
  const C_end = seriesC.length? seriesC.at(-1)[1] : 1;
  setBadge(Ebadge, `E metric: ${E_end.toExponential(2)}`, E_end<=thresholdsFromMargin(marginSelect.value).E_goal ? "ok" : (E_end<=thresholdsFromMargin(marginSelect.value).E_soft ? "warn":"bad"));
  setBadge(Cbadge, `C metric: ${C_end.toExponential(2)}`, C_end<=thresholdsFromMargin(marginSelect.value).C_goal ? "ok" : (C_end<=thresholdsFromMargin(marginSelect.value).C_hard ? "warn":"bad"));

  const physical = (E_end<=th.E_hard) && (C_end<=th.C_hard);
  setBadge(physicalBadge, physical ? "Physicality: OK (toy)" : "Check constraints", physical ? "ok":"warn");

  const orbitErr = Math.max(1e-10, (seriesGR.at(-1)?.[1]||1)*0.5 + (seriesQM.at(-1)?.[1]||1)*0.5);
  const frwOK = ((seriesGR.at(-1)?.[1]||1) < 5*epsGR && (seriesQM.at(-1)?.[1]||1) < 5*epsQM);
  const labLinear = true;

  setValRow(orbitVal, orbitStatus, orbitErr.toExponential(2), orbitErr < 1e-8);
  setValRow(frwVal, frwStatus, frwOK ? "match" : "mismatch", frwOK);
  setValRow(labVal, labStatus, labLinear ? "linear" : "nonlinear", labLinear);

  // CFL (toy)
  setBadge(cflBadge,   dt < 0.1 ? "CFL: OK" : "CFL: Reduce Δt", dt<0.1 ? "ok":"bad");
  setBadge(gaugeBadge, "Gauge: OK (placeholder)", "ok");
  setBadge(consBadge,  "∇·T: " + (C_end<=th.C_goal ? "OK" : "High?"), C_end<=th.C_goal ? "ok":"warn");

  // GO/NO-GO
  const GO = solved && stable && physical && (state!=='RED');
  setBadge(goBadge, GO ? "GO" : "NO-GO", GO ? "ok" : "bad");
  setBadge(statusBadge, GO ? "Solved (toy): residuals & tensor checks within band" : (ABORTED ? "Aborted — SafeDrop" : "Incomplete: tune gains/ε or install real kernels"), GO ? "ok" : (ABORTED?"bad":"warn"));

  // ----- Data Recorder -----
  const departTime = new Date().toISOString();
  const arriveTime = ABORTED ? null : new Date().toISOString();
  const log = {
    planTime, departTime, etaTime, arriveTime,
    inputs:{
      N, dt, epsGR, epsQM, epsDC, hold, Rgr0:params.Rgr0, Rqm0:params.Rqm0, dC0:params.dC0,
      kp:params.kp, kd:params.kd, F0, Ml, dI, z, tau, sig, eventsCount:events.length, kernel, h, c_lambda,
      mode, margin: marginSelect.value
    },
    thresholds: th,
    summaries:{
      solved, stable, physical, safetyState: state, GO,
      E_end, C_end, powerTotal: totPower, curvatureGain: totCurv
    },
    traces:{
      residuals:{ R_GR:seriesGR, R_QM:seriesQM, dC:seriesDC },
      tensors:{ E:seriesE, C:seriesC },
      power:{ in:seriesPow, eff:seriesEff }
    }
  };
  LAST_LOG = log;
  setBadge(logBadge, "Log: ready","ok");
  const blob = new Blob([JSON.stringify(log,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  logLink.href = url; logLink.style.display='inline-flex';
}

// ---------- events ----------
document.getElementById('runBtn').addEventListener('click', ()=>{ setBadge(statusBadge, "Running…", "badge"); setTimeout(simulate, 30); });
document.getElementById('resetBtn').addEventListener('click', ()=>{
  // reset to example values
  setVal('steps',500); setVal('dt',0.02);
  setVal('epsGR',1e-6); setVal('epsQM',1e-6); setVal('epsDC',1e-6); setVal('hold',50);
  setVal('Rgr0',0.08); setVal('Rqm0',0.06); setVal('dC0',0.10); setVal('spec0',0.70);
  setVal('kp',1.6); setVal('kd',0.3);
  setVal('F0',1361); setVal('Mlens',1.00); setVal('dI',0.03); setVal('zred',0.00010);
  setVal('tauNoise',600); setVal('sigmaNoise',0.005);
  setVal('eventTimes',""); setVal('kernelType',"gauss"); setVal('bandwidth',300); setVal('clambda',0.01);
  modeSelect.value='hold'; marginSelect.value='tight';

  setBadge(statusBadge,"Idle — awaiting run","warn");
  [resCanvas,tensorCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>{sizeCanvas(c); clearCanvas(c);});
  ["solvedBadge","stableBadge","physicalBadge","gaugeBadge","consBadge","cflBadge","stateBadge","goBadge","Ebadge","Cbadge"].forEach(id=>setBadge(document.getElementById(id),"—","badge"));
  setValRow(orbitVal, orbitStatus, "—", false); setValRow(frwVal, frwStatus, "—", false); setValRow(labVal, labStatus, "—", false);
  logLink.style.display='none'; setBadge(logBadge,"Log: —","badge");
});
abortBtn.addEventListener('click', ()=>{ ABORTED=true; setBadge(stateBadge,"State: RED — SafeDrop","bad"); });

downloadBtn.addEventListener('click', ()=>{
  if(!LAST_LOG){ setBadge(logBadge,"Log: run first","warn"); return; }
  const blob = new Blob([JSON.stringify(LAST_LOG,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); logLink.href = url; logLink.style.display='inline-flex';
});

// ---------- example fill helper ----------
function loadExample(kind){
  // common defaults
  setVal('steps', 500); setVal('dt', 0.02);
  setVal('epsGR', 1e-6); setVal('epsQM', 1e-6); setVal('epsDC', 1e-6);
  setVal('hold', 50);
  setVal('spec0', 0.70);
  modeSelect.value='hold'; marginSelect.value='tight';

  if(kind==='quiet'){
    setVal('Rgr0', 0.08); setVal('Rqm0', 0.06); setVal('dC0', 0.10);
    setVal('kp', 1.4); setVal('kd', 0.25);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.01); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.003);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.01);
  }
  if(kind==='flare'){
    setVal('Rgr0', 0.10); setVal('Rqm0', 0.08); setVal('dC0', 0.12);
    setVal('kp', 1.8); setVal('kd', 0.35);
    setVal('F0', 1361); setVal('Mlens', 1.02); setVal('dI', 0.03); setVal('zred', 0.00010);
    setVal('tauNoise', 600); setVal('sigmaNoise', 0.008);
    setVal('eventTimes', "120, 340, 355, 910, 1240, 1805, 1812, 2600, 3600, 4200");
    setVal('kernelType', "exp"); setVal('bandwidth', 420); setVal('clambda', 0.015);
  }
  if(kind==='lab'){
    setVal('Rgr0', 0.05); setVal('Rqm0', 0.04); setVal('dC0', 0.06);
    setVal('kp', 1.2); setVal('kd', 0.20);
    setVal('F0', 1.0); setVal('Mlens', 1.00); setVal('dI', 0.0); setVal('zred', 0.0);
    setVal('tauNoise', 300); setVal('sigmaNoise', 0.0);
    setVal('eventTimes', ""); setVal('kernelType', "epa"); setVal('bandwidth', 120); setVal('clambda', 0.0);
    // tighten tolerances to mimic a precise lab check
    setVal('epsGR', 5e-7); setVal('epsQM', 5e-7); setVal('epsDC', 5e-7);
  }
  if(kind==='pass'){
    setVal('steps', 2000); setVal('dt', 0.02);
    setVal('epsGR', 1e-7); setVal('epsQM', 1e-7); setVal('epsDC', 1e-7);
    setVal('hold', 80);
    setVal('Rgr0', 0.02); setVal('Rqm0', 0.02); setVal('dC0', 0.03);
    setVal('spec0', 0.50);
    setVal('kp', 2.2); setVal('kd', 0.50);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.005); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.001);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.0);
    modeSelect.value='hold'; marginSelect.value='tight';
  }

  document.getElementById('steps').scrollIntoView({behavior:'smooth', block:'center'});
}

// initial sizing
window.addEventListener('resize', ()=>{ [resCanvas,tensorCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>{sizeCanvas(c);}); });
[resCanvas,tensorCanvas,snapPre,snapPost,specPre,specPost,energyC].forEach(c=>sizeCanvas(c));
</script>
</body>
</html>
