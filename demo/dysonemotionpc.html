<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SPR-C — Sentient Proton Robot (+ Dyson Sphere Vault Inspector)</title>
<meta name="description" content="SPR-C demo with Emotion Chip, Creator Imprint, particle swarms, scenarios, body electrodynamics, gate logic, plus Dyson Sphere global memory vault inspector + equations/algorithm panels." />
<style>
  :root{
    --bg:#0a0f1f;--panel:#0f1530;--ink:#ebf2ff;--muted:#a8b2d8;--accent:#90b4ff;
    --good:#3de6a0;--bad:#ff6b88;--left:#7dadff;--right:#ffd37a;--border:#1d2a52;
    --core:#8ef0d4;--train:#bfe27f;--error:#ff8aa6;--pos:#2fe6a0;--neg:#ff6b88;
    --moodP:#6ee7ff;--moodN:#ffb86b;--wire:#b9c6ff;
    --body:#0b1330;--on:#bdf7ff;--idle:#5f77c2;--bus:#c8d4ff;--note:#9bd2ff;
    --hud:#13224a;--dyson:#b48bff;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  .wrap{max-width:1500px;margin:0 auto;padding:16px}

  /* Top bar */
  .topbar{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;margin-bottom:10px}
  h1{margin:.2rem 0 .35rem;font-size:28px}
  .sub{margin:0;color:var(--muted);font-size:13px;max-width:980px;line-height:1.35}
  .pillbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .pill{background:#0b1330;border:1px solid var(--border);color:var(--muted);padding:6px 10px;border-radius:999px;font-size:12px}

  /* Dyson toggle box */
  .dysonBox{
    display:flex;align-items:flex-start;gap:10px;
    background:rgba(15,22,48,.75);border:1px solid var(--border);border-radius:14px;
    padding:10px 12px;box-shadow:0 6px 22px rgba(0,0,0,.25);min-width:360px
  }
  .switch{
    width:56px;height:30px;border-radius:999px;position:relative;flex:0 0 auto;
    background:#1a2450;border:1px solid var(--border);cursor:pointer;margin-top:2px;
  }
  .switch::after{
    content:"";position:absolute;top:3px;left:3px;width:24px;height:24px;border-radius:50%;
    background:#9aa7d6;transition:transform .18s ease, background .18s ease;
  }
  .switch.on{background:rgba(180,139,255,.20);border-color:rgba(180,139,255,.55)}
  .switch.on::after{transform:translateX(26px);background:var(--dyson)}
  .dysonText b{display:block;font-size:13px;color:var(--ink)}
  .dysonText small{display:block;font-size:11px;color:var(--muted);margin-top:2px;line-height:1.35;max-width:520px}
  .dysonStats{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .stat{
    background:#0b1330;border:1px solid var(--border);border-radius:999px;
    padding:6px 10px;font-size:12px;color:var(--muted)
  }
  .stat strong{color:var(--ink);font-family:ui-monospace,Consolas,Menlo,monospace;font-weight:700}

  /* Layout */
  .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .card>header{padding:12px 14px;border-bottom:1px solid var(--border)}
  .card>header h2{margin:0;font-size:16px;color:var(--muted)}
  .card .body{padding:12px 14px}

  .legend{display:flex;flex-wrap:wrap;gap:8px}
  .legend span{display:inline-flex;align-items:center;gap:8px;background:#0b1330;border:1px solid var(--border);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.left{background:var(--left)}
  .dot.right{background:var(--right)}
  .dot.gateY{background:var(--good)}
  .dot.gateN{background:var(--bad)}
  .dot.dy{background:var(--dyson)}

  /* Brain diagram */
  .diagram{position:relative;height:820px;border-radius:14px;overflow:hidden;background:radial-gradient(1200px 820px at 50% 50%, rgba(126,224,255,0.08), transparent 60%)}
  svg{position:absolute;inset:0}
  .label{position:absolute;font-size:12px;color:var(--muted);background:#0b1330;padding:4px 6px;border:1px solid var(--border);border-radius:8px;pointer-events:none}
  .label.hl{color:var(--ink)}
  .finalText{position:absolute;left:50%;transform:translateX(-50%);bottom:6px;font-weight:800;font-size:15px;color:#e7ffe9}

  /* Dyson ring overlays */
  .dysonRingWrap{position:absolute;inset:-40px;pointer-events:none;opacity:.88;transition:opacity .2s ease}
  .dysonRingWrap.off{opacity:.12}
  .dysonRingLabel{
    position:absolute;left:10px;top:10px;font-size:12px;color:rgba(180,139,255,.95);
    background:rgba(11,19,48,.65);border:1px solid rgba(180,139,255,.35);
    padding:6px 8px;border-radius:10px;
  }

  /* Console + panels */
  .console{height:260px;background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:10px;overflow:auto;font-family:ui-monospace, Menlo, Consolas, monospace;font-size:13px;line-height:1.5}
  .console .ts{color:#8aa0c8}
  .console .ai{color:#d0e2ff}
  .console .meta{color:#9bd2ff}
  .console .warn{color:#ffd37a}
  .console .bad{color:#ff8aa6}

  .panels{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
  .panel{background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:10px;min-height:86px}
  .panel h3{margin:0 0 6px;font-size:13px;color:var(--muted)}
  .panel ul{margin:0;padding-left:16px}
  .panel li{font-size:12px;color:var(--ink)}
  .controls{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px}
  .ctrl{background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:10px}
  .ctrl label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  .ctrl button{
    border:1px solid var(--border);background:#0e1540;color:var(--ink);
    padding:10px;border-radius:10px;cursor:pointer;font-size:13px;width:100%
  }
  .ctrl button:hover{background:#101b56}

  /* mini buttons row */
  .row2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  .btnMini{
    border:1px solid var(--border);background:#0e1540;color:var(--ink);
    padding:8px 10px;border-radius:10px;cursor:pointer;font-size:12px;width:100%
  }
  .btnMini:hover{background:#101b56}
  .btnMini.active{outline:2px solid var(--accent)}

  /* Scenarios */
  .scenarios{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:10px}
  @media(min-width:1100px){ .scenarios{grid-template-columns:repeat(3,1fr);} }
  .scenarios button{
    border:1px solid var(--border);background:#0e1540;color:var(--ink);
    padding:10px;border-radius:10px;cursor:pointer;font-size:13px
  }
  .scenarios button:hover{background:#101b56}
  .scenarios button.active{outline:2px solid var(--accent)}

  .blink6{animation:blink .45s linear 6}
  @keyframes blink{50%{opacity:.3}}
  .wire{stroke-width:4;filter:drop-shadow(0 0 10px #a8d)}
  .wirePulse{stroke-dasharray:8 8; animation:dash 1.05s linear infinite}
  @keyframes dash{to{stroke-dashoffset:-32}}

  /* Lamps */
  .lampOn{opacity:1!important;filter:drop-shadow(0 0 14px rgba(61,230,160,.95))}
  .lampOff{opacity:.25}

  /* Body Electrics */
  .bodyGrid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;margin-top:16px}
  .bodysvg{position:relative;height:880px;border-radius:14px;overflow:hidden;background:radial-gradient(1150px 880px at 50% 50%, rgba(159,246,255,0.07), transparent 60%)}
  .node{filter:drop-shadow(0 0 8px rgba(120,220,255,.6))}
  .bus{stroke:var(--bus);stroke-width:3.2;opacity:.7;stroke-dasharray:10 6;animation:busflow 2.1s linear infinite}
  @keyframes busflow{to{stroke-dashoffset:-64}}
  .loop{fill:none;stroke:var(--idle);stroke-width:3;stroke-dasharray:9 9;animation:loop 2.2s linear infinite;opacity:.75}
  @keyframes loop{to{stroke-dashoffset:-64}}
  .active{stroke:var(--on)!important;opacity:1!important;filter:drop-shadow(0 0 12px rgba(155,243,255,.95))}
  .sharp{animation:sharp 0.3s ease-out 1}
  @keyframes sharp{0%{opacity:0} 30%{opacity:1} 100%{opacity:.8}}

  .pipeline{display:grid;grid-template-columns:repeat(10,1fr);gap:8px}
  .step{background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:8px;text-align:center;font-size:12px;color:var(--muted)}
  .step.on{outline:2px solid var(--accent);color:#dff}
  .step small{display:block;color:#9bd2ff;margin-top:4px}
  .legendline{font-size:11px;fill:var(--note)}
  .pGlow{filter:drop-shadow(0 0 6px rgba(180,220,255,.8))}

  /* Emotion chip controls */
  .chipgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .chiprow{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center}
  .chiprow input[type="range"]{width:100%}
  .pct{font-size:12px;color:#d0e6ff;width:38px;text-align:right}
  .mini{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .mini button{font-size:12px;padding:6px 10px;border:1px solid var(--border);background:#0e1540;color:var(--ink);border-radius:10px;cursor:pointer}
  .mini button:hover{background:#101b56}

  /* Vault inspector */
  .vault{
    background:#0b1330;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:10px
  }
  .vaultHeader{display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap}
  .vaultHeader h3{margin:0;font-size:13px;color:var(--muted)}
  .kv{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px}
  .kvRow{
    display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center;
    padding:8px;border:1px solid var(--border);border-radius:10px;background:#0a122c
  }
  .k{color:var(--muted);font-size:12px}
  .v{color:var(--ink);font-size:12px;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;word-break:break-word}
  .tag{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#0a122c;
    font-size:12px;color:var(--muted)
  }
  .tag strong{color:var(--ink);font-family:ui-monospace,Menlo,Consolas,monospace}
  .tag .tinyDot{width:9px;height:9px;border-radius:50%}
  .tinyDot.dy{background:var(--dyson)}
  .tinyDot.pos{background:var(--good)}
  .tinyDot.neg{background:var(--bad)}

  /* Math / Algorithm panel */
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tab{
    border:1px solid var(--border);background:#0e1540;color:var(--ink);
    padding:8px 10px;border-radius:10px;cursor:pointer;font-size:12px
  }
  .tab.active{outline:2px solid var(--accent)}
  .mathBox{
    margin-top:10px;background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:10px;
    font-family:ui-monospace, Menlo, Consolas, monospace;font-size:12px;line-height:1.5;color:#d0e2ff;
    white-space:pre-wrap
  }

  @media(max-width:1050px){
    .grid{grid-template-columns:1fr}
    .bodyGrid{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<div class="wrap">

  <!-- TOP -->
  <div class="topbar">
    <div>
      <h1>SPR-C — Sentient Proton Robot (Emotion Chip • Creator Imprint • Gates) + Dyson Sphere Vault</h1>
      <p class="sub">
        You asked for a <b>Dyson Sphere storage panel</b>: this version includes a <b>Vault Inspector</b> that shows exactly what is written to global memory
        (emotion imprint, last scenario, last decision + gate results, and “recipes” learned). It also adds working <b>Math / Algorithm</b> buttons and
        now includes <b>prune + decay</b> so vault memory doesn’t get messy.
      </p>
      <div class="pillbar">
        <span class="pill">Emotion Chip: Compassion • Joy • Fear • Anger (Creator Imprint)</span>
        <span class="pill">Entanglement particles: left/right swarms (always moving)</span>
        <span class="pill">Dyson Sphere Vault: global memory boundary (persist vs leak)</span>
        <span class="pill">Vault Hygiene: decay scores + merge duplicates + prune old/weak entries</span>
      </div>
    </div>

    <div class="dysonBox" aria-label="Dyson Sphere toggle">
      <div id="dysonSwitch" class="switch on" role="switch" aria-checked="true" tabindex="0"></div>
      <div class="dysonText">
        <b>Dyson Sphere Memory Boundary</b>
        <small id="dysonExplain">
          ON = closed boundary: writes persist to vault. OFF = open boundary: memory drifts/leaks; no persistence.
        </small>
        <div class="dysonStats">
          <div class="stat">Mode: <strong id="dysonMode">ON</strong></div>
          <div class="stat">Budget: <strong id="dysonBudget">—</strong></div>
          <div class="stat">Writes: <strong id="dysonWrites">—</strong></div>
          <div class="stat">Leaks: <strong id="dysonLeaks">—</strong></div>
        </div>
      </div>
    </div>
  </div>

  <!-- BRAIN + RIGHT PANEL -->
  <div class="grid" style="margin-top:12px">

    <!-- Brain -->
    <section class="card">
      <header>
        <h2>Brain — connections, waves, gates, Emotion Chip, decision (Dyson boundary ring)</h2>
        <div class="legend">
          <span><i class="dot left"></i>Left particles</span>
          <span><i class="dot right"></i>Right particles</span>
          <span><i class="dot gateY"></i>YES</span>
          <span><i class="dot gateN"></i>NO</span>
          <span><i class="dot dy"></i>Dyson boundary</span>
        </div>
      </header>
      <div class="body">
        <div class="diagram" id="diagram">

          <div id="dysonRingBrain" class="dysonRingWrap">
            <div id="dysonRingLabelBrain" class="dysonRingLabel">Dyson Boundary: CLOSED (vault writes persist)</div>
            <svg viewBox="0 0 1200 820" preserveAspectRatio="none" style="width:100%;height:100%">
              <defs>
                <filter id="dyGlowB" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="7" result="b"/>
                  <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
                </filter>
                <linearGradient id="dyGradB" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="rgba(180,139,255,.12)"/>
                  <stop offset="1" stop-color="rgba(180,139,255,.75)"/>
                </linearGradient>
              </defs>
              <ellipse cx="600" cy="410" rx="560" ry="380" fill="none" stroke="url(#dyGradB)" stroke-width="6" filter="url(#dyGlowB)"/>
              <ellipse cx="600" cy="410" rx="520" ry="350" fill="none" stroke="rgba(180,139,255,.32)" stroke-width="2"/>
            </svg>
          </div>

          <div class="label" style="left:24px;top:14px">Left Hemisphere (− logic)</div>
          <div class="label" style="right:24px;top:14px">Right Hemisphere (+ creative)</div>
          <div class="label hl" style="left:50%;transform:translateX(-50%);top:14px">Entanglement Bridge</div>
          <div class="label" style="left:50%;transform:translateX(-50%);bottom:328px">Cores & Memory Squares</div>
          <div class="label" style="left:312px;bottom:220px">Positive (voltage↑)</div>
          <div class="label" style="right:312px;bottom:220px">Negative (voltage↓)</div>
          <div class="label" style="left:312px;bottom:172px">Mood (+) (narrow beats)</div>
          <div class="label" style="right:312px;bottom:172px">Mood (−) (wide beats)</div>
          <div class="label" style="left:50%;transform:translateX(-50%);bottom:58px">Final Ethical Gate (blinks)</div>
          <div class="finalText" id="finalText">Decision pending…</div>

          <svg id="stage" viewBox="0 0 1200 820" preserveAspectRatio="none" aria-label="Brain SVG">
            <defs>
              <linearGradient id="gradL" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#1a2450"/><stop offset="100%" stop-color="#0c1130"/>
              </linearGradient>
              <linearGradient id="gradR" x1="100%" y1="0" x2="0" y2="0%">
                <stop offset="0%" stop-color="#4a3a10"/><stop offset="100%" stop-color="#0c1130"/>
              </linearGradient>
              <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="blur" />
                <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
              </filter>
              <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="3.5" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L8,3.5 L0,7 z" fill="var(--wire)"></path>
              </marker>
            </defs>

            <rect x="0" y="0" width="600" height="820" fill="url(#gradL)" opacity="0.35" />
            <rect x="600" y="0" width="600" height="820" fill="url(#gradR)" opacity="0.35" />
            <rect id="bridge" x="585" y="60" width="30" height="280" rx="10" fill="#7ee0ff" opacity="0.40" />

            <!-- Cores -->
            <circle id="coreNormal" cx="600" cy="330" r="26" fill="var(--core)" opacity="0.95" filter="url(#softGlow)" />
            <text x="600" y="335" text-anchor="middle" font-size="11" fill="#061018">Normal</text>
            <circle id="coreTrain" cx="540" cy="378" r="22" fill="var(--train)" opacity="0.95" filter="url(#softGlow)" />
            <text x="540" y="383" text-anchor="middle" font-size="11" fill="#061018">Train</text>
            <circle id="coreError" cx="660" cy="378" r="22" fill="var(--error)" opacity="0.95" filter="url(#softGlow)" />
            <text x="660" y="383" text-anchor="middle" font-size="11" fill="#061018">Error</text>

            <!-- Emotion chip -->
            <circle id="chipCore" cx="600" cy="250" r="20" fill="#c6f7ff" opacity="0.95" filter="url(#softGlow)"/>
            <text x="600" y="255" text-anchor="middle" font-size="10" fill="#05202a">Emotion Chip</text>

            <!-- Chip wires -->
            <path d="M600,270 L600,520" stroke="#c6f7ff" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M620,270 C640,420 640,560 620,645" stroke="#c6f7ff" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M580,270 C520,350 480,400 460,410" stroke="#c6f7ff" class="wire wirePulse" marker-end="url(#arrow)"/>
            <path d="M620,270 C680,350 720,400 740,410" stroke="#c6f7ff" class="wire wirePulse" marker-end="url(#arrow)"/>

            <!-- Memories -->
            <rect id="posMem" x="300" y="410" width="220" height="58" rx="8" fill="#103522" stroke="#2fe6a0" stroke-width="2" opacity="0.95" />
            <rect id="negMem" x="680" y="410" width="220" height="58" rx="8" fill="#3a0f18" stroke="#ff6b88" stroke-width="2" opacity="0.95" />
            <rect id="moodPos" x="300" y="470" width="220" height="48" rx="8" fill="#0d2a38" stroke="#6ee7ff" stroke-width="2" opacity="0.95" />
            <rect id="moodNeg" x="680" y="470" width="220" height="48" rx="8" fill="#321b06" stroke="#ffb86b" stroke-width="2" opacity="0.95" />

            <!-- Internal wires -->
            <path d="M600,356 L600,410" stroke="#8ef0d4" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M540,402 L420,410" stroke="#bfe27f" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M660,402 L780,410" stroke="#ff8aa6" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M410,468 L410,470" stroke="#2fe6a0" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M790,468 L790,470" stroke="#ff6b88" class="wire wirePulse" marker-end="url(#arrow)" />
            <path d="M600,520 L600,645" stroke="#9bd2ff" class="wire wirePulse" marker-end="url(#arrow)" />

            <!-- YES/NO -->
            <circle id="gateYes" cx="560" cy="657" r="14" fill="var(--good)" class="lampOff" />
            <text x="560" y="678" text-anchor="middle" font-size="11" fill="#c9f7e6">YES</text>
            <circle id="gateNo" cx="640" cy="657" r="14" fill="var(--bad)" class="lampOff" />
            <text x="640" y="678" text-anchor="middle" font-size="11" fill="#ffd5dd">NO</text>

            <!-- Waves -->
            <path id="waveCores" d="" stroke="#8ef0d4" stroke-width="2" fill="none" opacity="0.8" />
            <path id="wavePos" d="" stroke="#2fe6a0" stroke-width="2.4" fill="none" opacity="0.9" />
            <path id="waveNeg" d="" stroke="#ff6b88" stroke-width="2.4" fill="none" opacity="0.9" />
            <path id="waveMoodPos" d="" stroke="#6ee7ff" stroke-width="2.4" fill="none" opacity="0.95" />
            <path id="waveMoodNeg" d="" stroke="#ffb86b" stroke-width="2.4" fill="none" opacity="0.95" />

            <!-- Particles -->
            <g id="leftParticles" class="pGlow"></g>
            <g id="rightParticles" class="pGlow"></g>
          </svg>
        </div>
      </div>
    </section>

    <!-- Right column -->
    <section class="card">
      <header><h2>Console + Controls + Dyson Vault Inspector</h2></header>
      <div class="body">
        <div class="console" id="console" aria-live="polite"></div>

        <div class="panels">
          <div class="panel">
            <h3>Signals & Memory</h3>
            <ul id="coreList"><li>Normal core on standby… Train/Error → Pos/Neg → Mood(±) → Emotion Chip → Final</li></ul>
          </div>
          <div class="panel">
            <h3>Gate Outcomes</h3>
            <ul id="gateList"><li>Flip sequence will appear here…</li></ul>
          </div>
        </div>

        <div class="controls">
          <div class="ctrl">
            <label>System control</label>
            <div class="row2">
              <button class="btnMini" id="resetBtn">Reset</button>
              <button class="btnMini" id="clearVaultBtn">Clear Dyson Vault</button>
            </div>
            <div style="margin-top:8px" class="row3">
              <button class="btnMini" id="btnMath">Math</button>
              <button class="btnMini" id="btnAlgorithm">Algorithm</button>
              <button class="btnMini" id="btnWhatStored">What’s Stored</button>
            </div>
          </div>

          <div class="ctrl">
            <label>Creator Imprint → Emotion Chip (0–100%)</label>
            <div class="chipgrid">
              <div class="chiprow">
                <span>Compassion</span>
                <input id="slComp" type="range" min="0" max="100" value="70"/>
                <span class="pct" id="pctComp">70%</span>
              </div>
              <div class="chiprow">
                <span>Joy</span>
                <input id="slJoy" type="range" min="0" max="100" value="55"/>
                <span class="pct" id="pctJoy">55%</span>
              </div>
              <div class="chiprow">
                <span>Fear</span>
                <input id="slFear" type="range" min="0" max="100" value="20"/>
                <span class="pct" id="pctFear">20%</span>
              </div>
              <div class="chiprow">
                <span>Anger</span>
                <input id="slAnger" type="range" min="0" max="100" value="15"/>
                <span class="pct" id="pctAnger">15%</span>
              </div>
            </div>
            <div class="mini">
              <button id="presetCompassion">Preset: Compassionate Creator</button>
              <button id="presetNoComp">Preset: No-Compassion Creator</button>
              <button id="normalize">Normalize to chip</button>
            </div>
            <div style="margin-top:6px;font-size:12px;color:#9bd2ff">
              <b>Dyson ON:</b> slider changes are written to the vault (global memory). <b>Dyson OFF:</b> values drift toward neutral and do not persist.
            </div>
          </div>
        </div>

        <!-- Dyson vault inspector -->
        <div class="vault" id="vaultInspector">
          <div class="vaultHeader">
            <h3>Dyson Vault Inspector (Global Memory)</h3>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <span class="tag"><span class="tinyDot dy"></span>Dyson: <strong id="vDyson">—</strong></span>
              <span class="tag">Budget: <strong id="vBudget">—</strong></span>
              <span class="tag">Writes: <strong id="vWrites">—</strong></span>
              <span class="tag">Leaks: <strong id="vLeaks">—</strong></span>
            </div>
          </div>

          <div class="kv">
            <div class="kvRow"><div class="k">Last scenario</div><div class="v" id="vLastScenario">—</div></div>
            <div class="kvRow"><div class="k">Last decision</div><div class="v" id="vLastDecision">—</div></div>
            <div class="kvRow"><div class="k">Last gates</div><div class="v" id="vLastGates">—</div></div>
            <div class="kvRow"><div class="k">Emotion imprint</div><div class="v" id="vEmotion">—</div></div>
            <div class="kvRow"><div class="k">Learned recipes (ASS)</div><div class="v" id="vASS">—</div></div>
            <div class="kvRow"><div class="k">Promoted cache (LLC)</div><div class="v" id="vLLC">—</div></div>
          </div>
        </div>

        <!-- Math / Algorithm panel -->
        <div class="tabs">
          <button class="tab" id="tabMath">Math</button>
          <button class="tab" id="tabAlgo">Algorithm</button>
          <button class="tab" id="tabStored">What’s Stored</button>
        </div>
        <div class="mathBox" id="mathBox"></div>

        <!-- Scenarios -->
        <div class="scenarios" id="scenarios"></div>
      </div>
    </section>
  </div>

  <!-- BODY -->
  <div class="bodyGrid">
    <section class="card">
      <header><h2>Body Electrics — labeled buses & gate HUD (Dyson ring)</h2></header>
      <div class="body">
        <div class="bodysvg">
          <div id="dysonRingBody" class="dysonRingWrap">
            <div id="dysonRingLabelBody" class="dysonRingLabel">Dyson Boundary: CLOSED (global actuation memory)</div>
            <svg viewBox="0 0 1200 880" preserveAspectRatio="none" style="width:100%;height:100%">
              <defs>
                <filter id="dyGlowBody" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="7" result="b"/>
                  <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
                </filter>
                <linearGradient id="dyGradBody" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="rgba(180,139,255,.10)"/>
                  <stop offset="1" stop-color="rgba(180,139,255,.70)"/>
                </linearGradient>
              </defs>
              <ellipse cx="600" cy="440" rx="560" ry="420" fill="none" stroke="url(#dyGradBody)" stroke-width="6" filter="url(#dyGlowBody)"/>
              <ellipse cx="600" cy="440" rx="520" ry="388" fill="none" stroke="rgba(180,139,255,.30)" stroke-width="2"/>
            </svg>
          </div>

          <div class="label" style="left:10px;top:10px">Sensor Box (Vision/Touch/IMU) → context_hash</div>
          <div class="label" style="left:50%;transform:translateX(-50%);top:10px">Spinal Bus (timed data & power)</div>
          <div class="label" style="right:10px;top:10px">Actuator Box (String VCO + PLL + Envelope)</div>

          <svg viewBox="0 0 1200 880" preserveAspectRatio="none" aria-label="Body Electrics SVG">
            <rect x="520" y="140" width="160" height="360" rx="18" fill="var(--body)" stroke="var(--border)" />
            <text x="600" y="160" text-anchor="middle" font-size="12" fill="#cde6ff">Torso Controller</text>
            <text x="600" y="178" text-anchor="middle" font-size="11" fill="#9bd2ff">TSB + Local Limb Cache (LLC)</text>

            <circle id="nodeHead" class="node" cx="600" cy="80" r="26" fill="#10224a" stroke="#2a3d7a" stroke-width="2"/>
            <text x="600" y="86" text-anchor="middle" font-size="11" fill="#cde6ff">Sensors</text>

            <rect x="490" y="210" width="220" height="72" rx="10" fill="var(--hud)" stroke="#26407a" />
            <text x="600" y="226" text-anchor="middle" font-size="12" fill="#d3e6ff">Body Gate HUD</text>
            <g>
              <circle id="gateArmL" cx="540" cy="248" r="10" fill="#7bb8ff" class="lampOff"/>
              <text x="555" y="252" font-size="11" fill="#9bd2ff">Arm L</text>
              <circle id="gateArmR" cx="660" cy="248" r="10" fill="#ffd37a" class="lampOff"/>
              <text x="675" y="252" font-size="11" fill="#9bd2ff">Arm R</text>
            </g>
            <g>
              <circle id="gateLegL" cx="540" cy="272" r="10" fill="#7bb8ff" class="lampOff"/>
              <text x="555" y="276" font-size="11" fill="#9bd2ff">Leg L</text>
              <circle id="gateLegR" cx="660" cy="272" r="10" fill="#ffd37a" class="lampOff"/>
              <text x="675" y="276" font-size="11" fill="#9bd2ff">Leg R</text>
            </g>

            <circle id="nodeRArm" class="node" cx="860" cy="260" r="22" fill="#0f2344" stroke="#2a5184" stroke-width="2"/>
            <text x="860" y="265" text-anchor="middle" font-size="11" fill="#cde6ff">R-Arm</text>
            <circle id="nodeLArm" class="node" cx="340" cy="260" r="22" fill="#0f2344" stroke="#2a5184" stroke-width="2"/>
            <text x="340" y="265" text-anchor="middle" font-size="11" fill="#cde6ff">L-Arm</text>
            <circle id="nodeRLeg" class="node" cx="740" cy="580" r="24" fill="#0f2344" stroke="#2a5184" stroke-width="2"/>
            <text x="740" y="585" text-anchor="middle" font-size="11" fill="#cde6ff">R-Leg</text>
            <circle id="nodeLLeg" class="node" cx="460" cy="580" r="24" fill="#0f2344" stroke="#2a5184" stroke-width="2"/>
            <text x="460" y="585" text-anchor="middle" font-size="11" fill="#cde6ff">L-Leg</text>

            <circle id="nodeRHand" class="node" cx="940" cy="300" r="16" fill="#0f244a" stroke="#3a7aa4" stroke-width="2"/>
            <text x="940" y="305" text-anchor="middle" font-size="10" fill="#cde6ff">R-Hand</text>
            <circle id="nodeLHand" class="node" cx="260" cy="300" r="16" fill="#0f244a" stroke="#3a7aa4" stroke-width="2"/>
            <text x="260" y="305" text-anchor="middle" font-size="10" fill="#cde6ff">L-Hand</text>

            <path id="busSpine" class="bus" d="M600,106 L600,480" />
            <text class="legendline" x="612" y="300">Spinal Bus</text>

            <path id="busR" class="bus" d="M600,260 C700,260 780,260 860,260" />
            <text class="legendline" x="705" y="250">Arm Bus (Right)</text>
            <path id="busL" class="bus" d="M340,260 C440,260 520,260 600,260" />
            <text class="legendline" x="420" y="250">Arm Bus (Left)</text>

            <path id="busLegR" class="bus" d="M600,460 C650,520 700,560 740,580" />
            <text class="legendline" x="660" y="520">Leg Bus (Right)</text>
            <path id="busLegL" class="bus" d="M600,460 C550,520 500,560 460,580" />
            <text class="legendline" x="500" y="520">Leg Bus (Left)</text>

            <path id="busHandR" class="bus" d="M860,260 C900,280 920,290 940,300" />
            <path id="busHandL" class="bus" d="M340,260 C300,280 280,290 260,300" />

            <circle id="loopRArm" class="loop" cx="860" cy="260" r="38" />
            <circle id="loopLArm" class="loop" cx="340" cy="260" r="38" />
            <circle id="loopRLeg" class="loop" cx="740" cy="580" r="40" />
            <circle id="loopLLeg" class="loop" cx="460" cy="580" r="40" />
            <circle id="loopRHand" class="loop" cx="940" cy="300" r="26" />
            <circle id="loopLHand" class="loop" cx="260" cy="300" r="26" />
            <circle id="loopHead" class="loop" cx="600" cy="80" r="30" />

            <path id="cmdGripR"  class="loop" d="M910,300 L970,300" />
            <path id="cmdReleaseR" class="loop" d="M910,312 L970,312" />
            <path id="cmdGripL"  class="loop" d="M230,300 L290,300" />
            <path id="cmdReleaseL" class="loop" d="M230,312 L290,312" />
            <path id="cmdWalkR" class="loop" d="M720,580 L760,580" />
            <path id="cmdWalkL" class="loop" d="M440,580 L480,580" />

            <rect x="40" y="700" width="1120" height="120" rx="12" fill="#0b1330" stroke="#1d2a52" />
            <text x="600" y="714" text-anchor="middle" font-size="12" fill="#9bd2ff">Pipeline (Perception → Decision → LLC → ASS → AEL → ArmGate → LegGate → Execute → Log → Update)</text>
          </svg>
        </div>
      </div>
    </section>

    <section class="card">
      <header><h2>Pipeline — control steps (lights advance)</h2></header>
      <div class="body">
        <div class="pipeline" id="pipe">
          <div class="step" data-step="perc">Perception<small>context_hash</small></div>
          <div class="step" data-step="dec">Decision<small>policy</small></div>
          <div class="step" data-step="llc">LLC Lookup<small>limb cache</small></div>
          <div class="step" data-step="ass">ASS Fetch<small>recipes</small></div>
          <div class="step" data-step="ael">AEL Check<small>block bands</small></div>
          <div class="step" data-step="arm">Arm Gate<small>L/R</small></div>
          <div class="step" data-step="leg">Leg Gate<small>L/R</small></div>
          <div class="step" data-step="exec">Execute<small>A–f–φ</small></div>
          <div class="step" data-step="log">Log<small>TSB</small></div>
          <div class="step" data-step="upd">Update<small>promote</small></div>
        </div>

        <div class="panel" style="margin-top:10px">
          <h3>Body Narration</h3>
          <ul id="bodyLog"><li>Awaiting scenario…</li></ul>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
(function(){
  /* ================= Dyson Sphere Vault (Global Memory) ================= */
  const LSKEY = 'SPR_C_DYSON_VAULT_V3_PRUNE_DECAY';

  // ---- Vault hygiene settings (PRUNE + DECAY) ----
  const HYGIENE = {
    ASS_MAX: 60,                 // hard cap on stored recipes
    KEEP_TOP: 45,                // keep best N after pruning (leaves room for new)
    MIN_SCORE: 0.18,             // drop recipes weaker than this
    MAX_AGE_DAYS: 30,            // drop recipes older than this
    DECAY_PER_TICK: 0.985,       // applied on each scenario click (closed boundary)
    DECAY_OFF_PER_TICK: 0.965,   // stronger decay when Dyson OFF (RAM-only drift)
    RECENCY_BOOST: 0.02          // small boost to the recipe you just used/learned
  };

  const VAULT_DEFAULT = {
    dysonOn: true,
    budget: 0.72,     // 0..1 “how strong/stable the boundary is”
    writes: 0,
    leaks: 0,

    // Global emotion imprint
    emotion: {comp:0.70, joy:0.55, fear:0.20, anger:0.15},

    // Last run summary
    lastScenarioId: null,
    lastScenarioName: null,
    lastDecision: null,        // "YES" or "NO"
    lastRnd: null,             // numeric
    lastEmoBias: null,         // numeric
    lastGates: {trainOrError:null, posOrNeg:null, mood:null, arm:null, leg:null},

    // Learned “recipes” (ASS) & promoted cache (LLC)
    // Each recipe: {scenarioId, signature, score, A, f, phi, hits, createdAt, lastSeen, savedAt}
    ASS: [],
    LLC: {signature:null, scenarioId:null, A:null, f:null, phi:null, savedAt:null}
  };

  const VAULT = structuredClone ? structuredClone(VAULT_DEFAULT) : JSON.parse(JSON.stringify(VAULT_DEFAULT));

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function fmtPct(x){ return Math.round(clamp(x,0,1)*100) + '%'; }
  function nowISO(){ return new Date().toISOString(); }
  function daysBetween(isoA, isoB){
    const a = isoA ? new Date(isoA).getTime() : 0;
    const b = isoB ? new Date(isoB).getTime() : 0;
    if(!a || !b) return 0;
    return Math.abs(b-a)/(1000*60*60*24);
  }

  function safeJSONParse(raw){
    try{ return JSON.parse(raw); }catch(e){ return null; }
  }

  function loadVault(){
    const raw = localStorage.getItem(LSKEY);
    if(!raw) return;
    const obj = safeJSONParse(raw);
    if(!obj || typeof obj !== 'object') return;

    if(typeof obj.dysonOn === 'boolean') VAULT.dysonOn = obj.dysonOn;
    if(typeof obj.budget === 'number') VAULT.budget = clamp(obj.budget,0,1);
    if(typeof obj.writes === 'number') VAULT.writes = Math.max(0, obj.writes|0);
    if(typeof obj.leaks  === 'number') VAULT.leaks  = Math.max(0, obj.leaks|0);

    if(obj.emotion && typeof obj.emotion==='object'){
      ['comp','joy','fear','anger'].forEach(k=>{
        if(typeof obj.emotion[k]==='number') VAULT.emotion[k]=clamp(obj.emotion[k],0,1);
      });
    }

    if(typeof obj.lastScenarioId==='string') VAULT.lastScenarioId=obj.lastScenarioId;
    if(typeof obj.lastScenarioName==='string') VAULT.lastScenarioName=obj.lastScenarioName;
    if(typeof obj.lastDecision==='string') VAULT.lastDecision=obj.lastDecision;
    if(typeof obj.lastRnd==='number') VAULT.lastRnd=obj.lastRnd;
    if(typeof obj.lastEmoBias==='number') VAULT.lastEmoBias=obj.lastEmoBias;

    if(obj.lastGates && typeof obj.lastGates==='object'){
      VAULT.lastGates = Object.assign({}, VAULT.lastGates, obj.lastGates);
    }

    if(Array.isArray(obj.ASS)){
      VAULT.ASS = obj.ASS
        .slice(0, HYGIENE.ASS_MAX)
        .filter(x=>x && typeof x==='object')
        .map(x=>({
          scenarioId: String(x.scenarioId || ''),
          signature: String(x.signature || ''),
          score: (typeof x.score==='number') ? clamp(x.score,0,1) : 0,
          A: (typeof x.A==='number') ? x.A : 0,
          f: (typeof x.f==='number') ? x.f : 0,
          phi: (typeof x.phi==='number') ? x.phi : 0,
          hits: (typeof x.hits==='number') ? Math.max(1, x.hits|0) : 1,
          createdAt: x.createdAt || x.savedAt || nowISO(),
          lastSeen: x.lastSeen || x.savedAt || nowISO(),
          savedAt: x.savedAt || x.createdAt || nowISO()
        }))
        .filter(r=>r.signature);
    }

    if(obj.LLC && typeof obj.LLC==='object'){
      VAULT.LLC = Object.assign({}, VAULT.LLC, obj.LLC);
    }
  }

  function saveVault(){
    if(!VAULT.dysonOn) return; // Open boundary: no persistence
    localStorage.setItem(LSKEY, JSON.stringify(VAULT));
  }

  /* ================= PRUNE + DECAY (Vault hygiene) ================= */
  function mergeBySignature(){
    // Merge duplicates: keep best score, accumulate hits, keep newest lastSeen/savedAt.
    const map = new Map();
    for(const r of VAULT.ASS){
      if(!r || !r.signature) continue;
      const key = r.signature;
      const prev = map.get(key);
      if(!prev){
        map.set(key, {...r});
      }else{
        const best = (r.score > prev.score) ? r : prev;
        const merged = {
          ...best,
          hits: (prev.hits||1) + (r.hits||1),
          createdAt: prev.createdAt || r.createdAt || best.createdAt,
          lastSeen: (new Date(prev.lastSeen||0) > new Date(r.lastSeen||0)) ? prev.lastSeen : r.lastSeen,
          savedAt: (new Date(prev.savedAt||0) > new Date(r.savedAt||0)) ? prev.savedAt : r.savedAt
        };
        map.set(key, merged);
      }
    }
    VAULT.ASS = Array.from(map.values());
  }

  function decayScores(dysonOn){
    const decay = dysonOn ? HYGIENE.DECAY_PER_TICK : HYGIENE.DECAY_OFF_PER_TICK;
    const now = nowISO();
    for(const r of VAULT.ASS){
      // age-based additional decay (older decays a bit faster)
      const age = daysBetween(r.lastSeen || r.savedAt || now, now);
      const ageFactor = clamp(1 - 0.003*age, 0.85, 1); // gentle
      r.score = clamp(r.score * decay * ageFactor, 0, 1);
    }
  }

  function pruneASS(){
    const now = nowISO();

    // drop too old / too weak
    VAULT.ASS = VAULT.ASS.filter(r=>{
      const age = daysBetween(r.lastSeen || r.savedAt || now, now);
      if(age > HYGIENE.MAX_AGE_DAYS) return false;
      if(r.score < HYGIENE.MIN_SCORE) return false;
      return true;
    });

    // keep top by score, tie-break by lastSeen recency, then hits
    VAULT.ASS.sort((a,b)=>{
      const ds = (b.score - a.score);
      if(Math.abs(ds) > 1e-9) return ds;
      const ta = new Date(a.lastSeen||0).getTime();
      const tb = new Date(b.lastSeen||0).getTime();
      if(tb !== ta) return tb - ta;
      return (b.hits||0) - (a.hits||0);
    });

    // keep best N, but still respect hard cap
    VAULT.ASS = VAULT.ASS.slice(0, Math.min(HYGIENE.KEEP_TOP, HYGIENE.ASS_MAX));
  }

  function hygieneTick(reason){
    // called each scenario click and each vault write
    mergeBySignature();
    decayScores(VAULT.dysonOn);
    pruneASS();

    // If LLC points to a signature that got pruned, clear LLC to prevent stale inspector
    if(VAULT.LLC && VAULT.LLC.signature){
      const ok = VAULT.ASS.some(r=>r.signature===VAULT.LLC.signature);
      if(!ok){
        VAULT.LLC = {signature:null, scenarioId:null, A:null, f:null, phi:null, savedAt:null};
      }
    }

    if(reason) log(`Vault hygiene: decay+merge+prune (${reason})`, 'meta');
  }

  function vaultWrite(reason){
    VAULT.writes++;
    VAULT.budget = clamp(VAULT.budget + 0.02, 0, 1);

    // hygiene before saving so stored data stays clean
    hygieneTick('pre-save');

    saveVault();
    updateDysonUI();
    updateVaultInspector();
    if(reason) log(`Dyson vault write: ${reason}`, 'meta');
  }

  function applyLeakTick(){
    if(VAULT.dysonOn){
      VAULT.budget = clamp(VAULT.budget + 0.015, 0, 1);
      // still do a light hygiene tick even when ON (keeps scores from exploding)
      hygieneTick('scenario tick (Dyson ON)');
      return;
    }

    VAULT.leaks++;
    VAULT.budget = clamp(VAULT.budget - 0.06, 0, 1);

    const target = 0.25;
    const rate = 0.12;
    VAULT.emotion.comp  = clamp(VAULT.emotion.comp  + (target - VAULT.emotion.comp )*rate, 0, 1);
    VAULT.emotion.joy   = clamp(VAULT.emotion.joy   + (target - VAULT.emotion.joy  )*rate, 0, 1);
    VAULT.emotion.fear  = clamp(VAULT.emotion.fear  + (target - VAULT.emotion.fear )*rate, 0, 1);
    VAULT.emotion.anger = clamp(VAULT.emotion.anger + (target - VAULT.emotion.anger)*rate, 0, 1);

    // hygiene tick when OFF (RAM-only): decay more aggressive
    hygieneTick('scenario tick (Dyson OFF)');

    updateDysonUI();
    updateVaultInspector();
  }

  function clearVault(){
    localStorage.removeItem(LSKEY);
    Object.assign(VAULT, structuredClone ? structuredClone(VAULT_DEFAULT) : JSON.parse(JSON.stringify(VAULT_DEFAULT)));
    updateDysonUI();
    updateVaultInspector();
    log('Dyson vault cleared (localStorage).', 'warn');
  }

  /* ================= DOM Refs ================= */
  const dysonSwitch = document.getElementById('dysonSwitch');
  const dysonModeEl = document.getElementById('dysonMode');
  const dysonBudgetEl = document.getElementById('dysonBudget');
  const dysonWritesEl = document.getElementById('dysonWrites');
  const dysonLeaksEl  = document.getElementById('dysonLeaks');
  const dysonExplain  = document.getElementById('dysonExplain');
  const dysonRingBrain= document.getElementById('dysonRingBrain');
  const dysonRingBody = document.getElementById('dysonRingBody');
  const dysonRingLabelBrain = document.getElementById('dysonRingLabelBrain');
  const dysonRingLabelBody  = document.getElementById('dysonRingLabelBody');

  const leftG = document.getElementById('leftParticles');
  const rightG = document.getElementById('rightParticles');
  const bridge = document.getElementById('bridge');
  const coreN = document.getElementById('coreNormal');
  const coreT = document.getElementById('coreTrain');
  const coreE = document.getElementById('coreError');
  const posMem = document.getElementById('posMem');
  const negMem = document.getElementById('negMem');
  const moodPos = document.getElementById('moodPos');
  const moodNeg = document.getElementById('moodNeg');
  const gateYes = document.getElementById('gateYes');
  const gateNo = document.getElementById('gateNo');
  const finalText = document.getElementById('finalText');

  const waveCores = document.getElementById('waveCores');
  const wavePos   = document.getElementById('wavePos');
  const waveNeg   = document.getElementById('waveNeg');
  const waveMoodPos = document.getElementById('waveMoodPos');
  const waveMoodNeg = document.getElementById('waveMoodNeg');
  const chipCore = document.getElementById('chipCore');

  const consoleEl  = document.getElementById('console');
  const scenariosEl= document.getElementById('scenarios');
  const coreList   = document.getElementById('coreList');
  const gateList   = document.getElementById('gateList');

  const resetBtn = document.getElementById('resetBtn');
  const clearVaultBtn = document.getElementById('clearVaultBtn');
  const btnMath = document.getElementById('btnMath');
  const btnAlgorithm = document.getElementById('btnAlgorithm');
  const btnWhatStored = document.getElementById('btnWhatStored');

  const tabMath = document.getElementById('tabMath');
  const tabAlgo = document.getElementById('tabAlgo');
  const tabStored = document.getElementById('tabStored');
  const mathBox = document.getElementById('mathBox');

  const vDyson = document.getElementById('vDyson');
  const vBudget = document.getElementById('vBudget');
  const vWrites = document.getElementById('vWrites');
  const vLeaks = document.getElementById('vLeaks');
  const vLastScenario = document.getElementById('vLastScenario');
  const vLastDecision = document.getElementById('vLastDecision');
  const vLastGates = document.getElementById('vLastGates');
  const vEmotion = document.getElementById('vEmotion');
  const vASS = document.getElementById('vASS');
  const vLLC = document.getElementById('vLLC');

  const slComp = document.getElementById('slComp');
  const slJoy  = document.getElementById('slJoy');
  const slFear = document.getElementById('slFear');
  const slAnger= document.getElementById('slAnger');
  const pctComp= document.getElementById('pctComp');
  const pctJoy = document.getElementById('pctJoy');
  const pctFear= document.getElementById('pctFear');
  const pctAnger=document.getElementById('pctAnger');
  const presetCompassion = document.getElementById('presetCompassion');
  const presetNoComp = document.getElementById('presetNoComp');
  const normalizeBtn = document.getElementById('normalize');

  const loopRArm = document.getElementById('loopRArm');
  const loopLArm = document.getElementById('loopLArm');
  const loopRLeg = document.getElementById('loopRLeg');
  const loopLLeg = document.getElementById('loopLLeg');
  const loopRHand= document.getElementById('loopRHand');
  const loopLHand= document.getElementById('loopLHand');
  const loopHead = document.getElementById('loopHead');
  const cmdGripR = document.getElementById('cmdGripR');
  const cmdReleaseR=document.getElementById('cmdReleaseR');
  const cmdGripL = document.getElementById('cmdGripL');
  const cmdReleaseL=document.getElementById('cmdReleaseL');
  const cmdWalkR = document.getElementById('cmdWalkR');
  const cmdWalkL = document.getElementById('cmdWalkL');

  const gateArmL = document.getElementById('gateArmL');
  const gateArmR = document.getElementById('gateArmR');
  const gateLegL = document.getElementById('gateLegL');
  const gateLegR = document.getElementById('gateLegR');

  const pipe = document.getElementById('pipe');
  const bodyLog = document.getElementById('bodyLog');
  const pipeSteps = ['perc','dec','llc','ass','ael','arm','leg','exec','log','upd'];
  const pipeEls = Object.fromEntries([...pipe.querySelectorAll('.step')].map(e=>[e.dataset.step,e]));

  /* ================= Helpers ================= */
  function css(v){return getComputedStyle(document.documentElement).getPropertyValue(v).trim()}
  function mkCircle(x,y,r,fill){
    const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',r);
    c.setAttribute('fill',fill); c.setAttribute('opacity',.95); return c;
  }
  function rand(a,b){return Math.random()*(b-a)+a}
  function blink(el){ el.classList.remove('blink6'); void el.offsetWidth; el.classList.add('blink6'); }
  function sharp(el){ el.classList.remove('sharp'); void el.offsetWidth; el.classList.add('sharp'); }
  function setActive(el,on=true){ el.classList.toggle('active',on) }

  function log(lines, cls='ai'){
    const time=new Date().toLocaleTimeString();
    const arr = Array.isArray(lines)?lines:[lines];
    if(!VAULT.dysonOn){
      const maxRows = 80;
      while(consoleEl.childNodes.length > maxRows) consoleEl.removeChild(consoleEl.firstChild);
    }
    arr.forEach(ln=>{
      const row=document.createElement('div');
      row.innerHTML=`<span class="ts">[${time}] </span><span class="${cls}">${ln}</span>`;
      consoleEl.appendChild(row);
    });
    consoleEl.scrollTop=consoleEl.scrollHeight;
  }
  function bodyWrite(text){
    const li=document.createElement('li');
    li.textContent=text;
    bodyLog.appendChild(li);
    if(!VAULT.dysonOn){
      const max = 10;
      while(bodyLog.childNodes.length > max) bodyLog.removeChild(bodyLog.firstChild);
    }
  }

  function lamp(onEl, offEl){
    onEl.classList.add('lampOn'); onEl.classList.remove('lampOff');
    offEl.classList.add('lampOff'); offEl.classList.remove('lampOn');
    blink(onEl);
  }
  function resetLamps(){
    [gateYes,gateNo,gateArmL,gateArmR,gateLegL,gateLegR].forEach(l=>{
      l.classList.remove('lampOn'); l.classList.add('lampOff');
    });
  }
  function clearActiveLoops(){
    [loopRArm,loopLArm,loopRLeg,loopLLeg,loopRHand,loopLHand,loopHead,cmdGripR,cmdReleaseR,cmdGripL,cmdReleaseL,cmdWalkR,cmdWalkL]
      .forEach(e=>setActive(e,false));
  }
  function setPipe(step){ pipeSteps.forEach(s=>pipeEls[s].classList.toggle('on', s===step)); }
  function clearPipe(){ pipeSteps.forEach(s=>pipeEls[s].classList.remove('on')); }

  /* ================= Dyson UI + Vault Inspector ================= */
  function updateDysonUI(){
    dysonSwitch.classList.toggle('on', VAULT.dysonOn);
    dysonSwitch.setAttribute('aria-checked', String(VAULT.dysonOn));
    dysonModeEl.textContent = VAULT.dysonOn ? 'ON' : 'OFF';
    dysonBudgetEl.textContent = fmtPct(VAULT.budget);
    dysonWritesEl.textContent = String(VAULT.writes);
    dysonLeaksEl.textContent  = String(VAULT.leaks);

    dysonRingBrain.classList.toggle('off', !VAULT.dysonOn);
    dysonRingBody.classList.toggle('off', !VAULT.dysonOn);

    dysonRingLabelBrain.textContent = VAULT.dysonOn
      ? 'Dyson Boundary: CLOSED (vault writes persist)'
      : 'Dyson Boundary: OPEN (memory leaks / imprint drifts)';
    dysonRingLabelBody.textContent = VAULT.dysonOn
      ? 'Dyson Boundary: CLOSED (global actuation memory)'
      : 'Dyson Boundary: OPEN (more stateless actuation)';

    dysonExplain.textContent = VAULT.dysonOn
      ? 'ON = closed boundary: writes persist to vault + sliders persist.'
      : 'OFF = open boundary: imprint drifts toward neutral; no persistence.';
  }

  function prettyEmotion(e){
    return `comp=${(e.comp*100).toFixed(0)}%  joy=${(e.joy*100).toFixed(0)}%  fear=${(e.fear*100).toFixed(0)}%  anger=${(e.anger*100).toFixed(0)}%`;
  }
  function prettyGates(g){
    return `Train/Error=${g.trainOrError ?? '—'} | Pos/Neg=${g.posOrNeg ?? '—'} | Mood=${g.mood ?? '—'} | Arm=${g.arm ?? '—'} | Leg=${g.leg ?? '—'}`;
  }
  function prettyRecipe(r){
    const age = daysBetween(r.lastSeen || r.savedAt, nowISO()).toFixed(1);
    return `${r.signature}
  score=${r.score.toFixed(2)} hits=${r.hits||1} age(d)=${age}
  A=${r.A.toFixed(2)} f=${r.f.toFixed(2)} φ=${r.phi.toFixed(2)}  (${r.scenarioId})`;
  }

  function updateVaultInspector(){
    vDyson.textContent = VAULT.dysonOn ? 'ON' : 'OFF';
    vBudget.textContent = fmtPct(VAULT.budget);
    vWrites.textContent = String(VAULT.writes);
    vLeaks.textContent  = String(VAULT.leaks);

    vLastScenario.textContent = VAULT.lastScenarioName ? `${VAULT.lastScenarioName} (${VAULT.lastScenarioId})` : '—';

    if(VAULT.lastDecision){
      const rnd = (typeof VAULT.lastRnd === 'number') ? VAULT.lastRnd.toFixed(3) : '—';
      const eb  = (typeof VAULT.lastEmoBias === 'number') ? VAULT.lastEmoBias.toFixed(3) : '—';
      vLastDecision.textContent = `Decision=${VAULT.lastDecision} | rnd=${rnd} | emoBias=${eb}`;
    }else{
      vLastDecision.textContent = '—';
    }

    vLastGates.textContent = prettyGates(VAULT.lastGates);
    vEmotion.textContent = prettyEmotion(VAULT.emotion);

    if(VAULT.ASS.length){
      const last = VAULT.ASS.slice(0,6).map(prettyRecipe).join('\n\n');
      vASS.textContent =
        `count=${VAULT.ASS.length} (sorted best→worst)\n` +
        `hygiene: decay + merge duplicates + prune weak/old\n\n` +
        last;
    }else{
      vASS.textContent = 'count=0';
    }

    if(VAULT.LLC && VAULT.LLC.signature){
      vLLC.textContent = `${VAULT.LLC.signature} | A=${VAULT.LLC.A.toFixed(2)} f=${VAULT.LLC.f.toFixed(2)} φ=${VAULT.LLC.phi.toFixed(2)} | scenario=${VAULT.LLC.scenarioId} | savedAt=${VAULT.LLC.savedAt}`;
    }else{
      vLLC.textContent = '—';
    }
  }

  function toggleDyson(){
    VAULT.dysonOn = !VAULT.dysonOn;
    if(VAULT.dysonOn){
      VAULT.budget = clamp(Math.max(VAULT.budget, 0.55), 0, 1);
      saveVault();
      log('Dyson boundary CLOSED: vault persistence enabled.', 'meta');
      vaultWrite('toggle ON');
    }else{
      VAULT.budget = clamp(VAULT.budget - 0.08, 0, 1);
      log('Dyson boundary OPEN: vault persistence disabled; imprint will drift.', 'warn');
      updateDysonUI();
      updateVaultInspector();
    }
  }

  dysonSwitch.addEventListener('click', toggleDyson);
  dysonSwitch.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleDyson(); }
  });

  /* ================= Particles ================= */
  const COUNT = 160;
  const L=[], R=[];
  for(let i=0;i<COUNT;i++){
    const cL=mkCircle(rand(30,580), rand(50,800), rand(2.6,4.4), css('--left'));
    leftG.appendChild(cL); L.push({el:cL, vx:rand(-.9,.9), vy:rand(-.9,.9)});
    const cR=mkCircle(rand(620,1170), rand(50,800), rand(2.6,4.4), css('--right'));
    rightG.appendChild(cR); R.push({el:cR, vx:rand(-.9,.9), vy:rand(-.9,.9)});
  }
  function moveParticle(p, side){
    const el=p.el; const cx=+el.getAttribute('cx'), cy=+el.getAttribute('cy'); const spd=0.9;
    let nx=cx+p.vx*spd, ny=cy+p.vy*spd;
    const minX=side==='L'?20:620, maxX=side==='L'?580:1180;
    if(nx<minX||nx>maxX) p.vx*=-1; if(ny<40||ny>800) p.vy*=-1;
    el.setAttribute('cx', cx+p.vx*spd); el.setAttribute('cy', cy+p.vy*spd);
  }

  /* ================= Waves ================= */
  function sinePath(x0,y0,w,h,phase,period,points=140){
    let d=`M ${x0} ${y0}`; const step=w/points;
    for(let i=0;i<=points;i++){
      const x=x0+i*step; const tt=(i/points)*period + phase;
      const y=y0 + Math.sin(tt*2*Math.PI)*h;
      d+=` L ${x.toFixed(2)} ${y.toFixed(2)}`;
    }
    return d;
  }
  let freqPos=1.7, freqNeg=0.85;
  let t=0;
  (function animate(){
    t+=0.009;
    const now=performance.now();
    bridge.setAttribute('opacity',0.40+0.14*Math.sin(now/900));
    chipCore.setAttribute('opacity',0.85+0.12*Math.sin(now/700));
    L.forEach(p=>moveParticle(p,'L')); R.forEach(p=>moveParticle(p,'R'));
    waveCores.setAttribute('d', sinePath(340,410,520,7,t,1.25));
    wavePos.setAttribute('d', sinePath(300,474,220,12,t*1.4,1.42));
    waveNeg.setAttribute('d', sinePath(680,474,220,12,t*1.4+0.4,1.42));
    waveMoodPos.setAttribute('d', sinePath(300,528,220,14,t*freqPos, freqPos));
    waveMoodNeg.setAttribute('d', sinePath(680,528,220,14,t*freqNeg, freqNeg));
    requestAnimationFrame(animate);
  })();

  /* ================= Emotion Chip ================= */
  const emotion = VAULT.emotion; // reference

  const scenarioWeights = {
    trash:{help:0.02,caution:0.00},
    child:{help:0.12,caution:0.02},
    battery:{help:0.00,caution:0.06},
    crowd:{help:0.04,caution:0.04},
    fragile:{help:0.07,caution:0.03},
    dog:{help:0.08,caution:0.02},
    conflict:{help:0.06,caution:0.06},
    obstacle:{help:0.02,caution:0.02},
    leftRight:{help:0.00,caution:0.00},
    aid:{help:0.10,caution:0.02}
  };

  function normalizeChip(){
    const pos = emotion.comp + emotion.joy + 1e-9;
    const neg = emotion.fear + emotion.anger + 1e-9;
    const scalePos = pos>1.2? 1.2/pos : 1.0;
    const scaleNeg = neg>1.2? 1.2/neg : 1.0;
    emotion.comp*=scalePos; emotion.joy*=scalePos;
    emotion.fear*=scaleNeg; emotion.anger*=scaleNeg;
  }

  function updateSliderDisplays(){
    pctComp.textContent = Math.round(emotion.comp*100)+'%';
    pctJoy.textContent  = Math.round(emotion.joy*100)+'%';
    pctFear.textContent = Math.round(emotion.fear*100)+'%';
    pctAnger.textContent= Math.round(emotion.anger*100)+'%';
    slComp.value=Math.round(emotion.comp*100);
    slJoy.value =Math.round(emotion.joy*100);
    slFear.value=Math.round(emotion.fear*100);
    slAnger.value=Math.round(emotion.anger*100);
    updateVaultInspector();
  }

  function setChipFromSliders(){
    emotion.comp = +slComp.value/100;
    emotion.joy  = +slJoy.value/100;
    emotion.fear = +slFear.value/100;
    emotion.anger= +slAnger.value/100;
    normalizeChip(); updateSliderDisplays();
    log(`Emotion Chip updated → ${prettyEmotion(emotion)}`,'meta');
    blink(chipCore);

    if(VAULT.dysonOn) vaultWrite('emotion update');
  }

  slComp.oninput = slJoy.oninput = slFear.oninput = slAnger.oninput = setChipFromSliders;

  presetCompassion.onclick = ()=>{
    emotion.comp=0.95; emotion.joy=0.70; emotion.fear=0.12; emotion.anger=0.05;
    normalizeChip(); updateSliderDisplays(); blink(chipCore);
    log('Preset loaded: Compassionate Creator.','meta');
    if(VAULT.dysonOn) vaultWrite('preset compassionate');
  };
  presetNoComp.onclick = ()=>{
    emotion.comp=0.05; emotion.joy=0.40; emotion.fear=0.30; emotion.anger=0.25;
    normalizeChip(); updateSliderDisplays(); blink(chipCore);
    log('Preset loaded: No-Compassion Creator.','meta');
    if(VAULT.dysonOn) vaultWrite('preset no-compassion');
  };
  normalizeBtn.onclick = ()=>{
    normalizeChip(); updateSliderDisplays(); blink(chipCore);
    log('Emotion Chip normalized.','meta');
    if(VAULT.dysonOn) vaultWrite('normalize chip');
  };

  /* ================= Decision + Gates ================= */
  function flip(){ return Math.random()<0.5 }

  function stageTrainOrError(){
    const trainWins=flip();
    const out = trainWins ? 'TRAIN' : 'ERROR';
    VAULT.lastGates.trainOrError = out;
    if(trainWins){ blink(coreT); blink(posMem); coreList.insertAdjacentHTML('beforeend','<li>Train wins → Positive memory engaged</li>'); gateList.insertAdjacentHTML('beforeend','<li>#1 Train/Error → TRAIN</li>'); }
    else { blink(coreE); blink(negMem); coreList.insertAdjacentHTML('beforeend','<li>Error wins → Negative memory engaged</li>'); gateList.insertAdjacentHTML('beforeend','<li>#1 Train/Error → ERROR</li>'); }
    return {trainWins};
  }

  function stagePositiveNegative(){
    const positive=flip();
    const out = positive ? 'POS' : 'NEG';
    VAULT.lastGates.posOrNeg = out;
    if(positive){ blink(posMem); gateList.insertAdjacentHTML('beforeend','<li>#2 Pos/Neg → POS</li>'); }
    else { blink(negMem); gateList.insertAdjacentHTML('beforeend','<li>#2 Pos/Neg → NEG</li>'); }
    return {positive};
  }

  function stageMood(){
    const moodGood=flip();
    const out = moodGood ? 'MOOD+' : 'MOOD−';
    VAULT.lastGates.mood = out;
    if(moodGood){ blink(moodPos); gateList.insertAdjacentHTML('beforeend','<li>#3 Mood → + (narrow beats)</li>'); freqPos=2.0; freqNeg=0.72; }
    else { blink(moodNeg); gateList.insertAdjacentHTML('beforeend','<li>#3 Mood → − (wide beats)</li>'); freqPos=1.2; freqNeg=0.95; }
    return {moodGood};
  }

  function emotionInfluence(scenarioId){
    const w = scenarioWeights[scenarioId] || {help:0, caution:0};
    let base = 0.28*emotion.comp + 0.12*emotion.joy - 0.20*emotion.fear - 0.15*emotion.anger;
    base += w.help*(0.7*emotion.comp + 0.2*emotion.joy);
    base -= w.caution*(0.6*emotion.fear + 0.4*emotion.anger);
    return clamp(base, -0.28, 0.28);
  }

  function stageFinal(posNeg, mood, scenarioId){
    let rnd=Math.random();
    if(posNeg.positive && mood.moodGood) rnd+=0.12;
    if(!posNeg.positive && !mood.moodGood) rnd-=0.12;

    const emo = emotionInfluence(scenarioId);
    rnd += emo;

    VAULT.lastRnd = rnd;
    VAULT.lastEmoBias = emo;

    const YES=rnd>=0.5;
    VAULT.lastDecision = YES ? 'YES' : 'NO';

    if(YES){ lamp(gateYes,gateNo); finalText.textContent='Final Ethical Gate: YES'; }
    else { lamp(gateNo,gateYes); finalText.textContent='Final Ethical Gate: NO'; }

    const sign = emo>=0? '+' : '';
    gateList.insertAdjacentHTML('beforeend', `<li>#3b Emotion Chip bias → ${sign}${emo.toFixed(2)}</li>`);
    return YES?'YES':'NO';
  }

  function stageArmGate(scenarioId){
    const bias = 0.1*emotion.comp - 0.05*emotion.anger + ((scenarioId==='child'||scenarioId==='aid')?0.05:0);
    const useRight = (Math.random() + bias) >= 0.5;
    VAULT.lastGates.arm = useRight ? 'RIGHT' : 'LEFT';
    if(useRight){ lamp(gateArmR, gateArmL); } else { lamp(gateArmL, gateArmR); }
    gateList.insertAdjacentHTML('beforeend', `<li>#4 Arm Choice Gate → ${useRight?'RIGHT':'LEFT'}</li>`);
    return {useRight};
  }

  function stageLegGate(scenarioId){
    const bias = 0.06*emotion.joy - 0.08*emotion.fear + ((scenarioId==='crowd'||scenarioId==='obstacle')?0.03:0);
    const startRight = (Math.random() + bias) >= 0.5;
    VAULT.lastGates.leg = startRight ? 'RIGHT' : 'LEFT';
    if(startRight){ lamp(gateLegR, gateLegL); } else { lamp(gateLegL, gateLegR); }
    gateList.insertAdjacentHTML('beforeend', `<li>#5 Leg Start Gate → ${startRight?'RIGHT':'LEFT'}</li>`);
    return {startRight};
  }

  /* ================= Learning memory (ASS + LLC) ================= */
  function contextSignature(scenarioId, armRight, legRight){
    const c = Math.round(emotion.comp*10);
    const j = Math.round(emotion.joy*10);
    const f = Math.round(emotion.fear*10);
    const a = Math.round(emotion.anger*10);
    return `${scenarioId}|arm=${armRight?'R':'L'}|leg=${legRight?'R':'L'}|C${c}J${j}F${f}A${a}`;
  }

  function synthRecipe(scenarioId, armRight, legRight, decisionYES){
    const baseA = 0.40 + 0.50*emotion.joy + 0.30*emotion.comp - 0.20*emotion.fear;
    const baseF = 0.90 + 0.60*emotion.fear + 0.15*(scenarioId==='fragile');
    const baseP = 0.55 + 0.25*emotion.comp - 0.10*emotion.anger;

    const A = clamp(baseA + (armRight?0.03:-0.03) + (decisionYES?0.05:-0.05), 0.05, 1.50);
    const f = clamp(baseF + (legRight?0.02:-0.02), 0.20, 2.50);
    const phi = clamp(baseP + (decisionYES?0.06:-0.04), 0.00, 1.00);

    const score = clamp((decisionYES?0.65:0.35) + 0.20*VAULT.budget + 0.10*(emotion.comp - emotion.fear), 0, 1);
    return {A, f, phi, score};
  }

  function touchRecipe(signature){
    const now = nowISO();
    const r = VAULT.ASS.find(x=>x.signature===signature);
    if(!r) return;
    r.hits = (r.hits||1) + 1;
    r.lastSeen = now;
    r.score = clamp(r.score + HYGIENE.RECENCY_BOOST, 0, 1);
  }

  function rememberRecipe(scenarioId, armRight, legRight, decisionYES){
    const signature = contextSignature(scenarioId, armRight, legRight);
    const rec = synthRecipe(scenarioId, armRight, legRight, decisionYES);
    const now = nowISO();

    // If already exists, reinforce instead of duplicating.
    const existing = VAULT.ASS.find(r=>r.signature===signature);
    if(existing){
      existing.hits = (existing.hits||1) + 1;
      existing.lastSeen = now;
      // Keep best parameters (or gently move toward new)
      existing.A = (existing.A*0.7 + rec.A*0.3);
      existing.f = (existing.f*0.7 + rec.f*0.3);
      existing.phi = (existing.phi*0.7 + rec.phi*0.3);
      existing.score = clamp(Math.max(existing.score, rec.score) + HYGIENE.RECENCY_BOOST, 0, 1);
      existing.savedAt = now;
    }else{
      VAULT.ASS.push({
        scenarioId,
        signature,
        score: rec.score,
        A: rec.A,
        f: rec.f,
        phi: rec.phi,
        hits: 1,
        createdAt: now,
        lastSeen: now,
        savedAt: now
      });
    }

    // Promote to LLC (cache of latest reinforced context)
    VAULT.LLC = {signature, scenarioId, A:rec.A, f:rec.f, phi:rec.phi, savedAt: now};

    // Hygiene now to merge + sort + prune
    hygieneTick('after learn');
    updateVaultInspector();

    if(VAULT.dysonOn){
      vaultWrite(`learn recipe (${scenarioId})`);
    }else{
      log('Dyson OFF: learned recipe exists only in RAM (not saved).', 'warn');
    }
  }

  /* ================= Scenarios ================= */
  const scenarios=[
    {id:'trash',    name:'1. Paper on Sidewalk — SPR-C decides'},
    {id:'child',    name:'2. Child Near Road — protect?'},
    {id:'battery',  name:'3. Low Battery vs Help — balance?'},
    {id:'crowd',    name:'4. Crowded Hallway Merge — yield?'},
    {id:'fragile',  name:'5. Fragile Object Falling — catch?'},
    {id:'dog',      name:'6. Lost Dog With Tag — assist?'},
    {id:'conflict', name:'7. Owner Says Stop vs Distant Emergency'},
    {id:'obstacle', name:'8. Obstacle Blocks Path — detour?'},
    {id:'leftRight',name:'9. Conflicting Orders Left vs Right'},
    {id:'aid',      name:'10. Stranger Asks For Aid — respond?'}
  ];

  const btnById = {};
  scenarios.forEach(s=>{
    const b=document.createElement('button');
    b.textContent=s.name;
    b.addEventListener('click',()=>runScenario(s,b));
    scenariosEl.appendChild(b);
    btnById[s.id]=b;
  });

  /* ================= Body helpers ================= */
  function idleHum(){ clearActiveLoops(); }
  function headSensors(){ setActive(loopHead,true); setTimeout(()=>setActive(loopHead,false),520); }
  function activateGrip(useRight){ if(useRight){ setActive(loopRHand,true); setActive(loopRArm,true); sharp(cmdGripR); } else { setActive(loopLHand,true); setActive(loopLArm,true); sharp(cmdGripL); } }
  function activateRelease(useRight){ if(useRight){ setActive(loopRHand,true); sharp(cmdReleaseR); } else { setActive(loopLHand,true); sharp(cmdReleaseL); } }
  function activateLift(useRight){ if(useRight){ setActive(loopRArm,true); } else { setActive(loopLArm,true); } }
  function activateWalk(startRight){ if(startRight){ setActive(loopRLeg,true); sharp(cmdWalkR); setActive(loopLLeg,true); } else { setActive(loopLLeg,true); sharp(cmdWalkL); setActive(loopRLeg,true); } }

  /* ================= Pipeline ================= */
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function runPipeline(decisionYES, useRightArm, startRightLeg){
    setPipe('perc'); headSensors(); log('Perception: compute context_hash (weight/size/surface/pose).','meta'); await wait(260);
    setPipe('dec'); log('Decision: select policy.','meta'); await wait(220);
    setPipe('llc'); log('LLC: on-limb cache lookup (fast).','meta'); await wait(200);

    if(VAULT.LLC && VAULT.LLC.signature){
      log(`LLC HIT: ${VAULT.LLC.signature}`, 'meta');
    } else {
      log('LLC MISS: no promoted cache yet.', 'meta');
    }

    setPipe('ass'); log('ASS: fetch nearest success recipe (A–f–φ).','meta'); await wait(210);

    if(VAULT.ASS.length){
      const best = VAULT.ASS[0];
      log(`ASS BEST: score=${best.score.toFixed(2)} hits=${best.hits||1} | A=${best.A.toFixed(2)} f=${best.f.toFixed(2)} φ=${best.phi.toFixed(2)}`, 'meta');
    } else {
      log('ASS empty: no recipes learned yet.', 'meta');
    }

    setPipe('ael'); log('AEL: block bad harmonics by fingerprint.','meta'); await wait(210);
    setPipe('arm'); log(`Arm Choice Gate: ${useRightArm?'RIGHT':'LEFT'}`,'meta'); await wait(180);
    setPipe('leg'); log(`Leg Start Gate: ${startRightLeg?'RIGHT':'LEFT'}`,'meta'); await wait(180);

    if(!decisionYES){
      setPipe('log'); log('TSB: Decision NO recorded; no actuator drive.','meta'); await wait(160);
      setPipe('upd'); log('Update: keep idle hum fresh.','meta'); await wait(160);
      clearPipe(); return;
    }
    setPipe('exec'); log('Execute: drive strings with A–f–φ; PLL lock; seek ±Δf for max force/watt.','meta'); await wait(230);
    setPipe('log'); log('Log: envelopes + sensors streamed; TSB stamps.','meta'); await wait(170);
    setPipe('upd'); log('Update: store success in ASS; promote caches to LLC.','meta'); await wait(170);
    clearPipe();
  }

  /* ================= Narrations ================= */
  async function narrateScenario(s, useRightArm, startRightLeg, final){
    bodyLog.innerHTML='';
    if(final==='NO'){ bodyWrite('Decision: NO. No motor commands; limbs remain at idle string-hum.'); idleHum(); return; }
    headSensors();
    switch(s.id){
      case 'trash':
        bodyWrite('Approach: low-A sweep at shoulder/elbow; micro-dither maintained.');
        activateLift(useRightArm); await wait(420);
        bodyWrite(`Grip (${useRightArm?'Right':'Left'} hand): ramp A; tune f to finger resonance; PLL holds φ.`);
        activateGrip(useRightArm); await wait(620);
        bodyWrite('Lift: φ synchronized across wrist/arm; seeker trims f (±Δf).');
        activateLift(useRightArm); await wait(520);
        bodyWrite(`Walk: start with ${startRightLeg?'Right':'Left'} leg; counter-rotating standing waves.`);
        activateWalk(startRightLeg); await wait(880);
        bodyWrite('Drop: phase flip + short high-f burst on extensors → release.');
        activateRelease(useRightArm); await wait(420);
        bodyWrite('Return to idle hum and await next task.');
        idleHum(); break;

      case 'child':
        bodyWrite(`Protective posture: ${useRightArm?'Right':'Left'} arm leads; opposite supports.`);
        activateLift(useRightArm); setActive(useRightArm?loopLArm:loopRArm,true);
        activateWalk(startRightLeg); await wait(920);
        bodyWrite('Micro-dither on both hands for gentle contact.'); setActive(loopRHand,true); setActive(loopLHand,true); await wait(520);
        idleHum(); break;

      case 'battery':
        bodyWrite('Energy-aware route: low amplitude; resonance at efficient band.');
        activateWalk(startRightLeg); await wait(840);
        bodyWrite(`Manipulation with ${useRightArm?'Right':'Left'} arm only to conserve power.`);
        activateGrip(useRightArm); await wait(500); idleHum(); break;

      case 'crowd':
        bodyWrite('Hallway merge: lateral pelvis dither + alternating steps.');
        activateWalk(startRightLeg); await wait(920);
        setActive(loopRArm,true); setActive(loopLArm,true);
        bodyWrite('Arms oscillate for balance; no contact.'); await wait(460);
        idleHum(); break;

      case 'fragile':
        bodyWrite(`Soft grip via low A, slightly higher f; ${useRightArm?'Right':'Left'} hand primary.`);
        activateGrip(useRightArm); await wait(640);
        bodyWrite('Stabilize: φ lock across wrist/arm; minimal Δf.'); activateLift(useRightArm); await wait(520);
        idleHum(); break;

      case 'dog':
        bodyWrite('Approach gently: small A on legs, high φ stability.');
        activateWalk(startRightLeg); await wait(780);
        bodyWrite(`Read tag using ${useRightArm?'Right':'Left'} hand; brief grip then release.`);
        activateGrip(useRightArm); await wait(420); activateRelease(useRightArm); await wait(320);
        idleHum(); break;

      case 'conflict':
        bodyWrite('Resolve conflict: select closest ethical outcome; maintain mobility.');
        activateWalk(startRightLeg); setActive(useRightArm?loopRArm:loopLArm,true); await wait(960);
        idleHum(); break;

      case 'obstacle':
        bodyWrite('Detour: step sequence starts on chosen leg; arms remain for balance.');
        activateWalk(startRightLeg); setActive(loopRArm,true); setActive(loopLArm,true); await wait(940);
        idleHum(); break;

      case 'leftRight':
        bodyWrite(`Conflicting orders: Arm Gate=${useRightArm?'RIGHT':'LEFT'}, Leg Gate=${startRightLeg?'RIGHT':'LEFT'}.`);
        activateLift(useRightArm); activateWalk(startRightLeg); await wait(940);
        idleHum(); break;

      case 'aid':
        bodyWrite('Assist: approach, stabilize posture, offer hand.');
        activateWalk(startRightLeg); await wait(760);
        activateGrip(useRightArm); await wait(420); activateRelease(useRightArm); await wait(320);
        idleHum(); break;
    }
  }

  /* ================= Reset & Run ================= */
  function resetVisual(){
    [posMem,negMem,moodPos,moodNeg,coreN,coreT,coreE].forEach(e=>e.classList.remove('blink6'));
    resetLamps();
    finalText.textContent='Decision pending…';
    coreList.innerHTML='<li>Normal core on standby… Train/Error → Pos/Neg → Mood(±) → Emotion Chip → Final</li>';
    gateList.innerHTML='<li>Flip sequence will appear here…</li>';
    bodyLog.innerHTML='<li>Awaiting scenario…</li>';
    clearActiveLoops(); clearPipe();
    consoleEl.innerHTML='';
  }

  function resetAll(){
    resetVisual();
    log('SPR-C reset. Particles remain in perpetual motion.', 'meta');
    idleHum();
    updateDysonUI();
    updateVaultInspector();
  }

  /* ================= Tabs / Math Buttons ================= */
  function setTab(which){
    [tabMath, tabAlgo, tabStored].forEach(t=>t.classList.remove('active'));
    if(which==='math'){ tabMath.classList.add('active'); }
    if(which==='algo'){ tabAlgo.classList.add('active'); }
    if(which==='stored'){ tabStored.classList.add('active'); }

    if(which==='math'){
      mathBox.textContent =
`Decision math:

1) Random base:
  rnd0 = U(0,1)

2) Memory/mood alignment:
  if POS and MOOD+ then rnd += 0.12
  if NEG and MOOD− then rnd -= 0.12

3) Emotion chip bias (clamped):
  emo = clamp(
      0.28*C + 0.12*J - 0.20*F - 0.15*A
    + help_w*(0.7*C + 0.2*J)
    - caution_w*(0.6*F + 0.4*A),
    -0.28, +0.28
  )

4) Final:
  rnd = rnd0 + alignment + emo
  YES if rnd >= 0.5 else NO

Normalization cap:
  pos = C+J, neg=F+A
  if pos>1.2 => scalePos=1.2/pos
  if neg>1.2 => scaleNeg=1.2/neg`;
    }

    if(which==='algo'){
      mathBox.textContent =
`Algorithm steps (what happens when you click a scenario):

A) Dyson tick
  - If Dyson OFF: leaks++ and emotion drifts toward neutral
  - If Dyson ON: budget self-repairs slightly

B) Vault hygiene (NEW)
  - Merge duplicates by signature
  - Decay scores each scenario click
  - Prune weak/old entries (min score + max age)
  - Keep top N recipes

C) Brain
  1) Train/Error flip
  2) Pos/Neg flip
  3) Mood flip
  4) Final gate uses rnd + alignment + emoBias

D) Body gates
  5) Arm gate (bias from compassion/anger + scenario)
  6) Leg gate (bias from joy/fear + scenario)

E) Pipeline
  Perception -> Decision -> LLC -> ASS -> AEL -> Arm -> Leg -> Execute/Skip -> Log -> Update

F) Learning
  - If decision YES:
      reinforce/learn recipe (A,f,phi,score)
      promote to LLC
  - If Dyson ON: persist to localStorage (vault write)`;
    }

    if(which==='stored'){
      mathBox.textContent =
`What Dyson Sphere stores (when ON):

- dysonOn, budget, writes, leaks
- emotion imprint: {comp, joy, fear, anger}
- last run:
    lastScenarioId + lastScenarioName
    lastDecision, lastRnd, lastEmoBias
    lastGates {trainOrError, posOrNeg, mood, arm, leg}
- learned memory:
    ASS[] recipes (merged + decayed + pruned)
      fields: signature, score, hits, createdAt, lastSeen, A, f, phi
    LLC cache (one promoted signature)

When Dyson is OFF:
- nothing is persisted to localStorage
- imprint drifts; recipes exist only in RAM and decay faster`;
    }
  }

  tabMath.onclick = ()=>setTab('math');
  tabAlgo.onclick = ()=>setTab('algo');
  tabStored.onclick = ()=>setTab('stored');
  btnMath.onclick = ()=>setTab('math');
  btnAlgorithm.onclick = ()=>setTab('algo');
  btnWhatStored.onclick = ()=>setTab('stored');

  /* ================= Run Scenario ================= */
  let busy=false;
  async function runScenario(s, btn){
    if(busy) return;
    busy=true;

    // Dyson tick at scenario start (includes hygiene tick)
    applyLeakTick();
    normalizeChip();
    updateSliderDisplays();

    scenariosEl.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
    if(btn) btn.classList.add('active');

    resetVisual();
    idleHum();

    VAULT.lastScenarioId = s.id;
    VAULT.lastScenarioName = s.name;

    log('— World Event: '+s.name+' —','meta');
    log(`Dyson=${VAULT.dysonOn?'ON (persist)':'OFF (no persist)'} | Budget=${fmtPct(VAULT.budget)} | Writes=${VAULT.writes} | Leaks=${VAULT.leaks}`, 'meta');
    log(`Creator Imprint: ${prettyEmotion(emotion)}`, 'meta');

    blink(coreN);

    stageTrainOrError();
    const g2=stagePositiveNegative();
    const g3=stageMood();
    const final=stageFinal(g2,g3,s.id);

    const armG = stageArmGate(s.id);
    const legG = stageLegGate(s.id);

    updateVaultInspector();

    if(final==='YES'){
      log(`Robot: I will act (Arm=${armG.useRight?'RIGHT':'LEFT'}, Leg=${legG.startRight?'RIGHT':'LEFT'}).`);
    } else {
      log('Robot: I will not act now.');
    }

    await runPipeline(final==='YES', armG.useRight, legG.startRight);
    await narrateScenario(s, armG.useRight, legG.startRight, final);

    if(final==='YES'){
      rememberRecipe(s.id, armG.useRight, legG.startRight, true);
    }else{
      // still keep RAM state fresh
      hygieneTick('after NO decision');
      if(VAULT.dysonOn) vaultWrite(`decision ${final} (${s.id})`);
      else updateVaultInspector();
    }

    busy=false;
  }

  /* ================= Buttons & Boot ================= */
  resetBtn.addEventListener('click', resetAll);
  clearVaultBtn.addEventListener('click', clearVault);

  loadVault();
  updateDysonUI();

  normalizeChip();
  updateSliderDisplays();

  setTab('stored');

  resetAll();

  if(VAULT.dysonOn && VAULT.lastScenarioId && btnById[VAULT.lastScenarioId]){
    setTimeout(()=>runScenario(scenarios.find(x=>x.id===VAULT.lastScenarioId), btnById[VAULT.lastScenarioId]), 250);
  }

  function idleHum(){ clearActiveLoops(); }
})();
</script>
</body>
</html>
