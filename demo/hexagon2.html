<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Fix + Î¦-HNS Hex Lattice + Nested Hexes + Spiral Trace + Inspector</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;

    /* Dyson Sphere ring colors */
    --dysonRing: rgba(255, 200, 60, 0.62);
    --dysonRing2: rgba(255, 200, 60, 0.18);
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;align-items:center;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:190px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }
  .switch{
    display:flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:10px;
    border:1px solid var(--btnb);background:var(--panel2);
    font-size:12px;
    user-select:none;
  }
  .switch input{transform:scale(1.05);}
  .inspector{
    margin-top:10px;
    background:rgba(8,14,22,0.55);
    border:1px solid rgba(45,71,100,0.70);
    border-radius:12px;
    padding:10px;
  }
  .inspector .title{font-weight:800;font-size:13px;letter-spacing:.2px;margin-bottom:6px;}
  .kv{display:grid;grid-template-columns:120px 1fr;gap:4px 10px;font-size:12px;opacity:.92;}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}

  /* Dyson Sphere mini card */
  .dysonBox{
    margin-top:10px;
    border:1px solid var(--btnb);
    background:rgba(9,14,22,0.55);
    border-radius:12px;
    padding:10px;
  }
  .dyRead{
    margin-top:6px;
    font-size:12px;
    opacity:.92;
    line-height:1.35;
  }
  .dyRead b{opacity:1}

  /* Log header row */
  .logHead{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    margin-top:8px;
  }
  .logHead h3{margin:0;}
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Hexagon Fix + Î¦-HNS: Hex Lattice + Nested Hexes + Spiral Trace + Inspector</h2>

    <div class="row">
      <button id="step">+1 side</button>
      <button id="step5">+5 sides</button>
      <button id="reset">Reset (N=6)</button>
      <button id="auto">Auto â†’ circle mirror</button>
    </div>

    <div class="row">
      <span class="pill" id="nPill">N: 6</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
      <span class="pill" id="matchPill">Match: â€”</span>
      <span class="pill" id="statusPill">Status: â€”</span>
    </div>

    <div class="row">
      <label class="switch"><input id="constraintView" type="checkbox" /> Constraint View</label>

      <label class="switch"><input id="latticeView" type="checkbox" checked /> Hex Lattice</label>

      <label class="switch" title="When ON, lattice drawing is clipped strictly inside the domain circle.">
        <input id="latticeClip" type="checkbox" checked />
        Lattice in Circle
      </label>

      <label class="switch"><input id="glyphView" type="checkbox" checked /> Glyph Memory</label>
    </div>

    <div class="row">
      <label class="switch" title="Draws multiple nested hexagon frames (paper-style).">
        <input id="nestedHex" type="checkbox" checked />
        Nested Hexagons
      </label>

      <label class="switch" title="Draws a spiral trace through the lattice (snapped to nodes).">
        <input id="spiralOn" type="checkbox" checked />
        Lattice Spiral Trace
      </label>
    </div>

    <div class="row">
      <label class="switch"><input id="inspectOn" type="checkbox" checked /> Click-to-Inspect</label>
      <label class="switch"><input id="pinSel" type="checkbox" /> Pin selection</label>
      <button id="unpin">Unpin</button>
    </div>

    <div class="row">
      <button id="stressBtn">Failure Inject</button>
      <button id="clearMem">Clear Glyph Memory</button>
    </div>

    <!-- Dyson Sphere controls -->
    <div class="dysonBox">
      <h3 style="margin:0 0 6px;">Dyson Sphere (Outer Boundary)</h3>
      <div class="row" style="margin:6px 0 0;">
        <label class="switch" title="Draw an outer boundary ring representing a Dyson sphere / capture shell.">
          <input id="dysonOn" type="checkbox" />
          Dyson Sphere
        </label>
      </div>

      <label>Dyson radius scale: <span id="dysonScaleVal"></span></label>
      <input id="dysonScale" type="range" min="1.10" max="3.00" step="0.01" value="2.20" />

      <label>Capture fraction (%): <span id="dysonCapVal"></span></label>
      <input id="dysonCap" type="range" min="0" max="100" step="1" value="100" />

      <label>Star luminosity (W):</label>
      <input id="dysonLum" type="number" value="3.828e26" step="1e24" style="width:180px;" />

      <div class="dyRead" id="dysonRead">
        <div><b>Captured power:</b> <span id="dysonPower">â€”</span></div>
        <div><b>Flux at shell:</b> <span id="dysonFlux">â€”</span></div>
      </div>
    </div>

    <label>Polygon sides N: <span id="nVal"></span></label>
    <input id="N" type="range" min="6" max="240" step="1" value="6" />

    <label>Intent radius a: <span id="aVal"></span></label>
    <input id="a" type="range" min="80" max="420" value="260" />

    <label>Container radius R: <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="520" value="300" />

    <label>Regulation strength k: <span id="kVal"></span></label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="1.10" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">1.10</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <label style="margin-top:12px;">CST Phase Alignment Ï†â‚›â‚œ: <span id="phiBig">0.00</span></label>
    <input id="phi" type="range" min="0" max="1" step="0.01" value="0.00" />
    <div class="small" id="phiHint" style="margin-top:6px;"></div>

    <h3>Î¦-HNS Memory Controls</h3>

    <label>Collapse threshold Î¸Ï•: <span id="thetaVal"></span></label>
    <input id="theta" type="range" min="0.20" max="1.00" step="0.01" value="0.62" />

    <label>Surplus gain: <span id="gainVal"></span></label>
    <input id="gain" type="range" min="0.20" max="2.00" step="0.01" value="1.00" />

    <label>Surplus leak: <span id="leakVal"></span></label>
    <input id="leak" type="range" min="0.00" max="0.12" step="0.001" value="0.028" />

    <div class="inspector">
      <div class="title">Node Inspector</div>
      <div class="kv">
        <div><b>Selected</b></div><div class="mono" id="selId">â€”</div>
        <div><b>q,r</b></div><div class="mono" id="selQR">â€”</div>
        <div><b>v</b></div><div class="mono" id="selV">â€”</div>
        <div><b>surplus</b></div><div class="mono" id="selS">â€”</div>
        <div><b>locked</b></div><div class="mono" id="selLock">â€”</div>
        <div><b>glyph</b></div><div class="mono" id="selGlyph">â€”</div>
        <div><b>distâ†’center</b></div><div class="mono" id="selDist">â€”</div>
      </div>
      <div class="small" style="margin-top:6px;opacity:.85;">
        Tip: to create more locked glyphs faster â†’ Î¸Ï•â‰ˆ0.35, gainâ‰ˆ1.30, leakâ‰ˆ0.02. Raise Ï†â‚›â‚œ to make memory more selective.
      </div>
    </div>

    <div class="logHead">
      <h3>Step log</h3>
      <div class="row" style="margin:0;">
        <button id="dlCSV" title="Download the step log as a CSV file">Download CSV</button>
      </div>
    </div>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const $ = (id)=>document.getElementById(id);

  const NEl=$("N"), aEl=$("a"), REl=$("R"), kEl=$("k"), phiEl=$("phi");
  const thetaEl=$("theta"), gainEl=$("gain"), leakEl=$("leak");

  const nVal=$("nVal"), aVal=$("aVal"), RVal=$("RVal"), kVal=$("kVal");
  const thetaVal=$("thetaVal"), gainVal=$("gainVal"), leakVal=$("leakVal");

  const nPill=$("nPill"), modePill=$("modePill"), matchPill=$("matchPill"), statusPill=$("statusPill");
  const kBig=$("kBig"), kFill=$("kFill"), kText=$("kText");
  const phiBig=$("phiBig"), phiHint=$("phiHint");

  const constraintViewEl=$("constraintView");
  const latticeViewEl=$("latticeView");
  const latticeClipEl=$("latticeClip");
  const glyphViewEl=$("glyphView");
  const nestedHexEl=$("nestedHex");
  const spiralOnEl=$("spiralOn");

  const inspectOnEl=$("inspectOn");
  const pinSelEl=$("pinSel");
  const unpinBtn=$("unpin");

  const stressBtn=$("stressBtn");
  const clearMemBtn=$("clearMem");
  const dlCSVBtn=$("dlCSV");

  // Dyson UI
  const dysonOnEl=$("dysonOn");
  const dysonScaleEl=$("dysonScale");
  const dysonScaleValEl=$("dysonScaleVal");
  const dysonCapEl=$("dysonCap");
  const dysonCapValEl=$("dysonCapVal");
  const dysonLumEl=$("dysonLum");
  const dysonPowerEl=$("dysonPower");
  const dysonFluxEl=$("dysonFlux");

  const selIdEl=$("selId"), selQREl=$("selQR"), selVEl=$("selV"), selSEl=$("selS"),
        selLockEl=$("selLock"), selGlyphEl=$("selGlyph"), selDistEl=$("selDist");

  const logEl=$("log");

  // --- Live log + CSV ---
  const logEntries = [];
  const nowISO = () => new Date().toISOString();
  const log=(t)=>{
    const entry = { time: nowISO(), msg: String(t) };
    logEntries.push(entry);
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  };

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // DPR handling (fixes click/overlay issues on some browsers)
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function setDPR(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(canvas.clientWidth * DPR);
    const h = Math.floor(canvas.clientHeight * DPR);
    canvas.width = w;
    canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(DPR, DPR); // draw in CSS pixels
  }

  function cssW(){ return canvas.width / DPR; }
  function cssH(){ return canvas.height / DPR; }

  function polygonVertices(cx,cy,rad,n,rot=0){
    const pts=[];
    const offset=-Math.PI/6 + rot;
    for(let i=0;i<n;i++){
      const ang=(Math.PI*2)*(i/n)+offset;
      pts.push([cx+rad*Math.cos(ang), cy+rad*Math.sin(ang)]);
    }
    return pts;
  }
  function drawPolygon(pts, fill=true){
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    if(fill) ctx.fill();
    ctx.stroke();
  }
  function circleMatchPercent(N){
    const ratio=(N*Math.sin((2*Math.PI)/N))/(2*Math.PI);
    return 100*ratio;
  }
  function regulatedRadius(a,R,k){
    if(a<=R) return {rad:a, regulated:false, s:1};
    const s=Math.pow(R/a,k);
    return {rad:a*s, regulated:true, s};
  }
  function strokeForK(regulated,k){
    const t=clamp((k-0.50)/2.00,0,1);
    const cool={r:69,g:103,b:132}, warm={r:182,g:139,b:46};
    const r=Math.round(cool.r*(1-t)+warm.r*t);
    const g=Math.round(cool.g*(1-t)+warm.g*t);
    const b=Math.round(cool.b*(1-t)+warm.b*t);
    const a=regulated?(0.75+0.20*t):(0.55+0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }
  function updateKUI(regulated){
    const k=+kEl.value;
    kVal.textContent = k.toFixed(2);
    kBig.textContent=k.toFixed(2);
    const pct=clamp(((k-0.50)/2.00)*100,0,100);
    kFill.style.width=pct.toFixed(1)+"%";
    let label="Soft clamp.";
    if(k>=1.00 && k<1.50) label="Balanced clamp.";
    if(k>=1.50 && k<2.10) label="Strong clamp.";
    if(k>=2.10) label="Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent=label;
  }
  function updatePills(regulated,N,matchPct){
    nPill.textContent=`N: ${N}`;
    modePill.textContent=`Mode: ${regulated?"Regulation":"Geometry"}`;
    modePill.style.borderColor=regulated?"#b68b2e":"#2d4764";
    modePill.style.background=regulated?"#221a0a":"#0c131d";
    matchPill.textContent=`Match: ${matchPct.toFixed(1)}%`;
  }

  // ---------- Dyson Sphere helpers ----------
  function fmtSI(x){
    if(!isFinite(x)) return "â€”";
    const ax=Math.abs(x);
    if(ax>=1e24) return (x/1e24).toFixed(3)+"e24";
    if(ax>=1e18) return (x/1e18).toFixed(3)+"e18";
    if(ax>=1e12) return (x/1e12).toFixed(3)+"e12";
    if(ax>=1e9)  return (x/1e9 ).toFixed(3)+"e9";
    if(ax>=1e6)  return (x/1e6 ).toFixed(3)+"e6";
    if(ax>=1e3)  return (x/1e3 ).toFixed(3)+"e3";
    return x.toFixed(3);
  }
  function updateDysonUI(){
    dysonScaleValEl.textContent = (+dysonScaleEl.value).toFixed(2) + "Ã—R";
    dysonCapValEl.textContent = (+dysonCapEl.value).toFixed(0);

    const cap = (+dysonCapEl.value)/100;
    const L = Number(dysonLumEl.value);
    const captured = L * cap;

    const rRel = +dysonScaleEl.value;
    const areaRel = 4*Math.PI*rRel*rRel;
    const fluxRel = L / areaRel;

    dysonPowerEl.textContent = fmtSI(captured) + " W";
    dysonFluxEl.textContent  = fmtSI(fluxRel) + " W / (4Ï€ (RÂ·scale)^2)";
  }

  function drawDysonSphere(cx,cy,R){
    if(!dysonOnEl.checked) return;

    const scale = +dysonScaleEl.value;
    const dyR = R * scale;

    ctx.save();
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(cx,cy,dyR,0,Math.PI*2);
    ctx.lineWidth = Math.max(2, R*0.022);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dysonRing') || "rgba(255,200,60,.62)";
    ctx.stroke();

    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(cx,cy,dyR + ctx.lineWidth*2.1,0,Math.PI*2);
    ctx.lineWidth = ctx.lineWidth*2.2;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dysonRing2') || "rgba(255,200,60,.18)";
    ctx.stroke();

    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 1.3;
    ctx.strokeStyle = "rgba(255,225,140,0.35)";
    const ticks=24;
    for(let i=0;i<ticks;i++){
      const a = (i/ticks)*Math.PI*2;
      const x1 = cx + (dyR-8)*Math.cos(a);
      const y1 = cy + (dyR-8)*Math.sin(a);
      const x2 = cx + (dyR+8)*Math.cos(a);
      const y2 = cy + (dyR+8)*Math.sin(a);
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    // Label + live numbers on the Dyson ring
    ctx.globalAlpha = 0.9;
    ctx.fillStyle="rgba(232,238,246,0.85)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const cap = (+dysonCapEl.value);
    ctx.fillText(`Dyson Shell: scale=${scale.toFixed(2)}Ã—R  capture=${cap.toFixed(0)}%`, 14, 74);

    ctx.restore();
  }

  // ---------- Pillars ----------
  const pillars=[
    { key:"Maxwell", short:"M" },
    { key:"Einstein", short:"E" },
    { key:"Feynman", short:"F" },
    { key:"Turing", short:"T" },
    { key:"vonNeumann", short:"V" },
    { key:"Shannon", short:"S" },
  ];

  let stressInject=false;
  let t0=performance.now();

  function stressColor(s){
    if(s<0.5){
      const t=s/0.5;
      const r=Math.round(lerp(42,214,t));
      const g=Math.round(lerp(163,166,t));
      const b=Math.round(lerp(74,58,t));
      return `rgb(${r},${g},${b})`;
    }else{
      const t=(s-0.5)/0.5;
      const r=Math.round(lerp(214,208,t));
      const g=Math.round(lerp(166,74,t));
      const b=Math.round(lerp(58,74,t));
      return `rgb(${r},${g},${b})`;
    }
  }

  function computeStresses({N,a,R,k,phi,regulated}){
    const match=circleMatchPercent(N)/100;
    const coarseness=clamp(1-match,0,1);
    const overflow=clamp((a-R)/Math.max(1,R),0,1);
    const kPressure=clamp(Math.abs(k-1.0)/1.5,0,1);
    const clampActive=regulated?1:0;

    const deco=(1-phi);
    const damp=lerp(1.0,0.55,phi);

    let inj=0;
    if(stressInject){
      const tt=(performance.now()-t0)/1000;
      inj=0.5+0.5*Math.sin(tt*2.3);
    }

    const base={
      Maxwell:    0.15 + 0.55*overflow + 0.25*coarseness + 0.10*inj,
      Einstein:   0.18 + 0.60*overflow + 0.30*deco      + 0.06*clampActive + 0.08*inj,
      Shannon:    0.14 + 0.50*coarseness + 0.40*deco    + 0.08*overflow + 0.06*inj,
      vonNeumann: 0.16 + 0.55*kPressure + 0.20*deco     + 0.08*clampActive + 0.07*inj,
      Turing:     0.16 + 0.45*kPressure + 0.35*coarseness + 0.10*inj,
      Feynman:    0.18 + 0.45*coarseness + 0.55*deco    + 0.08*overflow + 0.10*inj,
    };

    const keys=["Maxwell","Einstein","Feynman","Turing","vonNeumann","Shannon"];
    let s=keys.map(k=>base[k]);

    const steps=2;
    const c=lerp(0.22,0.12,phi);
    for(let it=0;it<steps;it++){
      const next=s.slice();
      for(let i=0;i<keys.length;i++){
        const L=s[(i-1+keys.length)%keys.length];
        const Rr=s[(i+1)%keys.length];
        const coupled=(s[i]+c*(L+Rr))/(1+2*c);
        next[i]=clamp(coupled*damp,0,1);
      }
      s=next;
    }

    const out={};
    for(let i=0;i<keys.length;i++) out[keys[i]]=s[i];

    return {out,coarseness,overflow,deco,match};
  }

  // ---------- HEX LATTICE + MEMORY ----------
  const HEX={ size:14, dirs:[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]] };
  const GLYPHS=["ð’®","ð’ž","à¸€","ð’¦","Ï•","âŸ¡","âŠ•","âˆ¿","âˆž","â—‡","â–£","âœ¶"];
  const FALLBACKS=["S","C","H","K","Ï†","*","+","~","âˆž","â—‡","â–£","*"];

  let lattice={ nodes:[], map:new Map(), builtFor:{w:0,h:0,R:0,size:HEX.size} };
  let selected={ idx:-1, pinned:false };
  let lastCenter={ cx:0, cy:0, R:0 };

  const keyQR=(q,r)=>q+","+r;
  function axialToPixel(q,r,size){
    const x=size*Math.sqrt(3)*(q+r/2);
    const y=size*1.5*r;
    return [x,y];
  }

  function buildHexLattice(cx,cy,R){
    const size=clamp(Math.round(R/22),10,16);
    HEX.size=size;
    lattice.nodes=[];
    lattice.map=new Map();
    lattice.builtFor={ w:cssW(), h:cssH(), R, size };

    const max=Math.ceil(R/(size*1.15));
    for(let r=-max;r<=max;r++){
      for(let q=-max;q<=max;q++){
        const [dx,dy]=axialToPixel(q,r,size);
        const d=Math.hypot(dx,dy);
        if(d<=R-size*0.3){
          const idx=lattice.nodes.length;
          lattice.map.set(keyQR(q,r),idx);
          lattice.nodes.push({
            q,r, x:cx+dx, y:cy+dy,
            v:0,v2:0,
            surplus:0,s2:0,
            locked:false, glyph:"", glyphIdx:-1,
            nei:[]
          });
        }
      }
    }
    for(const n of lattice.nodes){
      n.nei.length=0;
      for(const [dq,dr] of HEX.dirs){
        const j=lattice.map.get(keyQR(n.q+dq,n.r+dr));
        if(j!==undefined) n.nei.push(j);
      }
    }
    if(selected.idx>=lattice.nodes.length) selected.idx=-1;

    log(`LATTICE: built ${lattice.nodes.length} nodes (hex size=${size}px).`);
    log("â€”");
  }

  function ensureLatticeBuilt(cx,cy,R,force=false){
    const bf=lattice.builtFor;
    const changed = force || !lattice.nodes.length ||
      Math.abs(bf.R-R)>0.5 ||
      Math.abs(bf.w-cssW())>0.5 ||
      Math.abs(bf.h-cssH())>0.5;
    if(changed) buildHexLattice(cx,cy,R);
  }

  function clearLatticeMemory(){
    for(const n of lattice.nodes){
      n.surplus=0; n.locked=false; n.glyph=""; n.glyphIdx=-1;
    }
  }

  function injectSourcesToLattice(pillarPts, pillarStress, phi){
    const influence=clamp(lattice.builtFor.R*0.40,120,260);
    const inv2=1/(influence*influence);
    const injScale=lerp(1.00,0.70,phi);

    for(const node of lattice.nodes){
      let s=0,wsum=0;
      for(let i=0;i<pillarPts.length;i++){
        const [px,py]=pillarPts[i];
        const dx=node.x-px, dy=node.y-py;
        const w=Math.exp(-(dx*dx+dy*dy)*inv2);
        wsum+=w; s+=w*pillarStress[i];
      }
      const src=wsum>0?(s/wsum):0;
      const blend=node.locked?0.10:0.18;
      node.v=clamp(lerp(node.v, src*injScale, blend),0,1);
    }
  }

  function injectFailure(phi){
    if(!stressInject || !lattice.nodes.length) return;

    const R=lattice.builtFor.R;
    const cx=cssW()/2, cy=cssH()/2;
    const targetX=cx+R*0.35, targetY=cy-R*0.20;

    let best=-1, bestD=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-targetX, dy=n.y-targetY;
      const d2=dx*dx+dy*dy;
      if(d2<bestD){bestD=d2; best=i;}
    }
    if(best<0) return;

    const tt=(performance.now()-t0)/1000;
    const osc=0.5+0.5*Math.sin(tt*3.2);
    const amp=lerp(0.35,0.18,phi);
    lattice.nodes[best].v=clamp(lattice.nodes[best].v+osc*amp,0,1);
  }

  function propagateLatticeAndMemory(phi){
    const coupling=lerp(0.28,0.12,phi);
    const damping=lerp(0.985,0.92,phi);

    const thetaBase=+thetaEl.value;
    const gain=+gainEl.value;
    const leak=+leakEl.value;

    const thetaEff=clamp(thetaBase+0.08*phi,0.20,1.00);
    const gainEff=gain*lerp(1.0,0.78,phi);
    const leakEff=leak*lerp(1.0,0.75,phi);

    const microSteps=2;

    for(let step=0; step<microSteps; step++){
      for(const n of lattice.nodes){
        let avg=0;
        const m=n.nei.length||1;
        for(const j of n.nei) avg+=lattice.nodes[j].v;
        avg/=m;
        const stiff=n.locked?0.65:1.0;
        const mixed=n.v+(coupling*stiff)*(avg-n.v);
        n.v2=clamp(mixed*damping,0,1);
      }
      for(const n of lattice.nodes) n.v=n.v2;

      for(const n of lattice.nodes){
        const lockFactor=n.locked?0.25:1.0;
        const add=n.v*0.030*gainEff*lockFactor;
        const dec=n.surplus*leakEff;
        n.s2=clamp(n.surplus+add-dec,0,1.25);
      }

      for(const n of lattice.nodes){
        n.surplus=n.s2;
        if(!n.locked && n.surplus>=thetaEff){
          n.locked=true;
          const idx=Math.abs((n.q*31+n.r*17)%GLYPHS.length);
          n.glyphIdx=idx;
          n.glyph=GLYPHS[idx]||"";
        }
      }
    }

    return {thetaEff, gainEff};
  }

  function drawLattice(){
    const showGlyphs=glyphViewEl.checked;

    if(latticeClipEl.checked){
      const cx=lastCenter.cx, cy=lastCenter.cy, R=lastCenter.R;
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx,cy,R-1,0,Math.PI*2);
      ctx.clip();
    } else {
      ctx.save();
    }

    ctx.globalAlpha=0.95;

    for(const n of lattice.nodes){
      const s=n.v;
      const mem=clamp(n.surplus,0,1);
      const hot=Math.max(s, mem*0.85);
      if(hot<0.03 && !n.locked) continue;

      ctx.fillStyle=stressColor(clamp(hot,0,1));
      const r=(n.locked?2.3:1.4)+2.0*hot;
      ctx.beginPath();
      ctx.arc(n.x,n.y,r,0,Math.PI*2);
      ctx.fill();

      if(n.locked){
        ctx.strokeStyle="rgba(232,238,246,0.40)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.arc(n.x,n.y,r+1.6,0,Math.PI*2);
        ctx.stroke();
      }
    }

    if(showGlyphs){
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font="900 11px system-ui, Segoe UI, Arial";
      let drawn=0;
      const MAX=320;
      for(const n of lattice.nodes){
        if(!n.locked) continue;
        if(drawn++>MAX) break;
        const g=n.glyph || FALLBACKS[(n.glyphIdx>=0?n.glyphIdx:0)%FALLBACKS.length];
        ctx.fillStyle="rgba(7,16,25,0.90)";
        ctx.fillText(g,n.x,n.y);
      }
    }

    // selected highlight
    if(selected.idx>=0 && lattice.nodes[selected.idx]){
      const n=lattice.nodes[selected.idx];
      ctx.strokeStyle="rgba(232,238,246,0.90)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(n.x,n.y,10,0,Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawNestedHexes(cx,cy,R){
    if(!nestedHexEl.checked) return;
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.lineWidth=1.2;

    const rings=6;
    for(let i=1;i<=rings;i++){
      const t=i/(rings+1);
      const rad=R*(0.18 + 0.78*t);
      const rot = (i%2===0) ? 0 : (Math.PI/12);
      const pts=polygonVertices(cx,cy,rad,6,rot);
      ctx.strokeStyle = (i===rings) ? "rgba(232,238,246,0.28)" : "rgba(120,150,180,0.22)";
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let k=1;k<pts.length;k++) ctx.lineTo(pts[k][0],pts[k][1]);
      ctx.closePath();
      ctx.stroke();
    }

    ctx.restore();
  }

  function pickNearestNode(px,py){
    if(!lattice.nodes.length) return -1;
    let best=-1, bestD2=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-px, dy=n.y-py;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){bestD2=d2; best=i;}
    }
    // more forgiving pick radius (fixes â€œcanâ€™t selectâ€)
    const rPick=Math.max(16, HEX.size*2.2);
    if(bestD2 <= rPick*rPick) return best;
    return -1;
  }

  function drawLatticeSpiral(cx,cy,R){
    if(!spiralOnEl.checked) return;
    if(!lattice.nodes.length) return;

    if(latticeClipEl.checked){
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx,cy,R-1,0,Math.PI*2);
      ctx.clip();
    } else {
      ctx.save();
    }

    const turns = 3.2;
    const samples = 220;
    const rMax = R*0.92;

    let path = [];
    let lastIdx = -1;

    for(let i=0;i<samples;i++){
      const t = i/(samples-1);
      const ang = t * turns * 2*Math.PI;
      const rad = t * rMax;
      const px = cx + rad*Math.cos(ang);
      const py = cy + rad*Math.sin(ang);

      let best=-1, bestD2=1e18;
      for(let j=0;j<lattice.nodes.length;j++){
        const n=lattice.nodes[j];
        const dx=n.x-px, dy=n.y-py;
        const d2=dx*dx+dy*dy;
        if(d2<bestD2){bestD2=d2; best=j;}
      }
      if(best>=0 && best!==lastIdx){
        path.push(best);
        lastIdx=best;
      }
    }

    ctx.globalAlpha = 0.65;
    ctx.lineWidth = 2.0;
    ctx.strokeStyle = "rgba(182,139,46,0.75)";
    ctx.beginPath();
    for(let i=0;i<path.length;i++){
      const n=lattice.nodes[path[i]];
      if(i===0) ctx.moveTo(n.x,n.y);
      else ctx.lineTo(n.x,n.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(232,238,246,0.20)";
    for(let i=0;i<path.length;i+=14){
      const n=lattice.nodes[path[i]];
      ctx.beginPath();
      ctx.arc(n.x,n.y,3.2,0,Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  // âœ… FIX: restore labels + live numbers on constraint circles
  function drawConstraintOverlay(cx,cy,R,rr,stressPack){
    const rad=Math.min(rr.rad,R*0.78);
    const pts=polygonVertices(cx,cy,rad,6);

    // frame
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.strokeStyle="rgba(120,150,180,0.35)";
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    const order=["Maxwell","Einstein","Feynman","Turing","vonNeumann","Shannon"];

    // title
    ctx.fillStyle="rgba(232,238,246,0.85)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.fillText("Constraint Pillars (live):", 14, 56);

    // nodes with labels + values
    for(let i=0;i<6;i++){
      const key=order[i];
      const s=stressPack.out[key];
      const [x,y]=pts[i];
      const col=stressColor(s);

      // pill node
      ctx.fillStyle=col;
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(x,y,16,0,Math.PI*2); ctx.fill(); ctx.stroke();

      // letter
      ctx.fillStyle="#071019";
      ctx.font="900 13px system-ui, Segoe UI, Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(pillars[i].short,x,y);

      // label + number (outside the circle)
      const dx = x - cx, dy = y - cy;
      const d = Math.max(1, Math.hypot(dx,dy));
      const ox = x + (dx/d)*26;
      const oy = y + (dy/d)*26;

      ctx.fillStyle="rgba(232,238,246,0.88)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.textAlign = (dx>=0) ? "left" : "right";
      ctx.textBaseline="middle";
      const name = key === "vonNeumann" ? "vonN" : key;
      ctx.fillText(`${name}: ${s.toFixed(2)}`, ox, oy);
    }

    // reset align
    ctx.textAlign="left"; ctx.textBaseline="alphabetic";
  }

  function setInspector(idx){
    if(idx<0 || !lattice.nodes[idx]){
      selIdEl.textContent="â€”"; selQREl.textContent="â€”"; selVEl.textContent="â€”";
      selSEl.textContent="â€”"; selLockEl.textContent="â€”"; selGlyphEl.textContent="â€”"; selDistEl.textContent="â€”";
      return;
    }
    const n=lattice.nodes[idx];
    selIdEl.textContent=String(idx);
    selQREl.textContent=`${n.q}, ${n.r}`;
    selVEl.textContent=n.v.toFixed(3);
    selSEl.textContent=n.surplus.toFixed(3);
    selLockEl.textContent=n.locked?"true":"false";
    const g = n.glyph || (n.glyphIdx>=0 ? FALLBACKS[n.glyphIdx%FALLBACKS.length] : "");
    selGlyphEl.textContent=n.locked?g:"â€”";
    const dx=n.x-lastCenter.cx, dy=n.y-lastCenter.cy;
    selDistEl.textContent=Math.hypot(dx,dy).toFixed(1);
  }

  canvas.addEventListener("click",(ev)=>{
    if(!inspectOnEl.checked) return;
    if(!latticeViewEl.checked) return;
    if(!lattice.nodes.length) return;

    const rect=canvas.getBoundingClientRect();
    const px=ev.clientX-rect.left;
    const py=ev.clientY-rect.top;

    const idx=pickNearestNode(px,py);
    if(idx<0) return;

    selected.idx=idx;
    selected.pinned = pinSelEl.checked;
    setInspector(idx);

    const n=lattice.nodes[idx];
    log(`INSPECT: idx=${idx} q,r=(${n.q},${n.r}) v=${n.v.toFixed(3)} s=${n.surplus.toFixed(3)} locked=${n.locked} glyph=${n.glyph||""}`);
    log("â€”");

    // force a draw so the highlight is immediate even when animation is off
    draw(false);
  });

  unpinBtn.addEventListener("click",()=>{
    selected.pinned=false;
    pinSelEl.checked=false;
    log("Inspector: unpinned.");
    log("â€”");
    draw(false);
  });

  function draw(forceRebuild=false){
    // âœ… ensure all "live" panel numbers always update
    const N=parseInt(NEl.value,10);
    const a=+aEl.value;
    const R=+REl.value;
    const k=+kEl.value;
    const phi=+phiEl.value;

    nVal.textContent=N;
    aVal.textContent=a.toFixed(0);
    RVal.textContent=R.toFixed(0);
    phiBig.textContent=phi.toFixed(2);

    thetaVal.textContent=(+thetaEl.value).toFixed(2);
    gainVal.textContent=(+gainEl.value).toFixed(2);
    leakVal.textContent=(+leakEl.value).toFixed(3);

    if(phi<0.20) phiHint.textContent="Ï†â‚›â‚œ low: strong coupling â†’ wider spread + more collapse.";
    else if(phi<0.60) phiHint.textContent="Ï†â‚›â‚œ moderate: partial phase-locking reduces spread + collapse density.";
    else phiHint.textContent="Ï†â‚›â‚œ high: strong damping â†’ more selective memory.";

    updateDysonUI();

    const w=cssW(), h=cssH();
    ctx.clearRect(0,0,w,h);

    const cx=w/2, cy=h/2;
    lastCenter={cx,cy,R};

    // Dyson first
    drawDysonSphere(cx,cy,R);

    // domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

    // nested frames
    drawNestedHexes(cx,cy,R);

    // clamp
    const rr=regulatedRadius(a,R,k);
    updateKUI(rr.regulated);

    // pills
    const matchPct=circleMatchPercent(N);
    updatePills(rr.regulated,N,matchPct);

    // main N-gon
    const pts=polygonVertices(cx,cy,rr.rad,N);
    ctx.fillStyle=rr.regulated?"#0f2236":"#0d1a2a";
    ctx.strokeStyle=strokeForK(rr.regulated,k);
    ctx.lineWidth=2;
    drawPolygon(pts,true);

    // mirror circle at polygon radius
    ctx.globalAlpha=0.45;
    ctx.strokeStyle="rgba(232,238,246,0.35)";
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(cx,cy,rr.rad,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;

    // stresses
    const needLattice=latticeViewEl.checked;
    const needConstraint=constraintViewEl.checked;
    let stressPack=null;
    if(needLattice || needConstraint){
      stressPack=computeStresses({N,a,R,k,phi,regulated:rr.regulated});
    }

    // lattice
    if(needLattice && stressPack){
      ensureLatticeBuilt(cx,cy,R,forceRebuild);

      const rad=Math.min(rr.rad,R*0.78);
      const pillarPts=polygonVertices(cx,cy,rad,6);
      const order=["Maxwell","Einstein","Feynman","Turing","vonNeumann","Shannon"];
      const pillarStress=order.map(k=>stressPack.out[k]??0);

      injectSourcesToLattice(pillarPts,pillarStress,phi);
      injectFailure(phi);

      const eff=propagateLatticeAndMemory(phi);
      drawLattice();
      drawLatticeSpiral(cx,cy,R);

      const lockedCount=lattice.nodes.reduce((acc,n)=>acc+(n.locked?1:0),0);
      statusPill.textContent=`Status: nodes=${lattice.nodes.length} locked=${lockedCount}`;

      // âœ… keep inspector live even while animating
      if(selected.idx>=0) setInspector(selected.idx);

      // on-canvas lattice label + live numbers
      ctx.fillStyle="rgba(232,238,246,0.78)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.fillText(
        `Hex Lattice: locked=${lockedCount}  Î¸Ï•â‰ˆ${eff.thetaEff.toFixed(2)}  gainâ‰ˆ${eff.gainEff.toFixed(2)}  leak=${(+leakEl.value).toFixed(3)}  Ï†â‚›â‚œ=${phi.toFixed(2)}`,
        14, 92
      );
    } else {
      statusPill.textContent="Status: lattice OFF";
      // if lattice is off, also clear inspector (optional)
      if(!selected.pinned){
        selected.idx=-1;
        setInspector(-1);
      }
    }

    // constraint overlay (with labels + numbers)
    if(needConstraint && stressPack){
      drawConstraintOverlay(cx,cy,R,rr,stressPack);
    }

    // diagnostics top-left
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const geomMsg = rr.regulated
      ? `Clamp ACTIVE: a=${a.toFixed(0)} > R=${R.toFixed(0)} â†’ s=(R/a)^k=${rr.s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No clamp: a=${a.toFixed(0)} â‰¤ R=${R.toFixed(0)} (k=${k.toFixed(2)})`;
    ctx.fillText(geomMsg, 14, 18);
    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText(`Boundary refinement: N=${N}, circle-match â‰ˆ ${matchPct.toFixed(1)}%`, 14, 36);
  }

  function setN(v){ NEl.value=String(clamp(v,6,240)); draw(); }

  $("step").onclick=()=>{
    const N=parseInt(NEl.value,10);
    setN(N+1);
    log(`STEP: N=${N+1} matchâ‰ˆ${circleMatchPercent(N+1).toFixed(2)}%`);
    log("â€”");
  };
  $("step5").onclick=()=>{
    const N=parseInt(NEl.value,10);
    setN(N+5);
    log(`STEP: N=${N+5} matchâ‰ˆ${circleMatchPercent(N+5).toFixed(2)}%`);
    log("â€”");
  };
  $("reset").onclick=()=>{
    setN(6);
    selected.idx=-1;
    setInspector(-1);
    logEl.textContent="";
    logEntries.length = 0;

    // âœ… exact reset message you asked for
    log("RESET: N=6. Lattice + nested hex + spiral can be toggled.");
    log("â€”");

    // rebuild lattice fresh (only if lattice is on)
    draw(true);
  };
  $("auto").onclick=()=>{
    let N=parseInt(NEl.value,10);
    for(let it=0;it<400;it++){
      if(circleMatchPercent(N)>=99.6) break;
      N++; if(N>=240) break;
    }
    setN(N);
    log(`AUTO: Nâ†’${N} matchâ‰ˆ${circleMatchPercent(N).toFixed(2)}%`);
    log("â€”");
  };

  stressBtn.onclick=()=>{
    stressInject=!stressInject;
    stressBtn.textContent = stressInject ? "Failure Inject: ON" : "Failure Inject";
    log(`Failure Inject: ${stressInject?"ON":"OFF"}`);
    log("â€”");
    draw();
  };

  clearMemBtn.onclick=()=>{
    if(!lattice.nodes.length){
      log("Clear requested but lattice not built yet. Turn Hex Lattice ON.");
      log("â€”");
      return;
    }
    clearLatticeMemory();
    log("Memory cleared.");
    log("â€”");
    draw();
  };

  // âœ… CSV download for the step log
  dlCSVBtn.onclick=()=>{
    const header = ["time","message"];
    const rows = logEntries.map(e=>{
      const msg = String(e.msg).replaceAll('"','""');
      return `"${e.time}","${msg}"`;
    });
    const csv = header.join(",") + "\n" + rows.join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "hexara_step_log.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    log("CSV: downloaded hexara_step_log.csv");
    log("â€”");
  };

  // sliders update
  [NEl,aEl,REl,kEl,phiEl,thetaEl,gainEl,leakEl,dysonScaleEl,dysonCapEl,dysonLumEl].forEach(el=>{
    el.addEventListener("input",()=>draw());
  });

  // toggles
  [constraintViewEl,latticeViewEl,latticeClipEl,glyphViewEl,nestedHexEl,spiralOnEl,inspectOnEl,pinSelEl,dysonOnEl].forEach(el=>{
    el.addEventListener("change",()=>draw(true));
  });

  function resize(){
    setDPR();
    draw(true);
  }
  window.addEventListener("resize",resize);

  function tick(){
    const animate = latticeViewEl.checked || stressInject;
    if(animate) draw();
    requestAnimationFrame(tick);
  }

  // init
  log("INIT: Turn ON/OFF Nested Hexagons + Spiral Trace to match the paper diagrams.");
  log("FIX: Constraint View now shows labels + live values around the circle.");
  log("FIX: Node Inspector selection is easier to click and updates immediately.");
  log("NEW: Step log has a Download CSV button.");
  log("â€”");

  resize();
  draw(true);    // âœ… force immediate live numbers
  tick();
})();
</script>
</body>
</html>
