<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SPR-C • Behavior+Ethics • HUD • Entanglement • Power Gauges + Dyson Vault (Prune/Decay)</title>
<meta name="description" content="Simulation with Behavior/Ethics gates, entanglement particles, Arm/Leg HUD, per-bus gauges, per-side power bars, plus Dyson Sphere global memory vault with prune/decay."/>
<style>
  :root{
    --bg:#0a1020;--panel:#101736;--ink:#eaf2ff;--muted:#a9b6dd;--border:#1f2b56;--accent:#86b4ff;
    --good:#34e6a2;--bad:#ff6b88;--left:#7dadff;--right:#ffd37a;--on:#c9f6ff;--idle:#7aa3ff;
    --barbg:#0d1538;--bart:#4bd3a9;--bara:#79b0ff;--barl:#ffd37a;--barside:#cfe4ff;
    --dyson:#b48bff;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1280px;margin:0 auto;padding:14px}
  h1{margin:.3rem 0 .6rem;font-size:26px}
  .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:12px}

  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 6px 22px rgba(0,0,0,.35)}
  .card>header{padding:10px 12px;border-bottom:1px solid var(--border)}
  .card>header h2{margin:0;font-size:15px;color:var(--muted)}
  .card .body{padding:10px 12px}

  .legend{display:flex;flex-wrap:wrap;gap:8px}
  .chip{background:#0c1434;border:1px solid var(--border);border-radius:999px;color:var(--muted);padding:4px 8px;font-size:12px}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px}
  .dot.l{background:var(--left)} .dot.r{background:var(--right)}
  .dot.y{background:var(--good)} .dot.n{background:var(--bad)}
  .dot.dy{background:var(--dyson)}

  .diagram{position:relative;height:560px;border-radius:12px;overflow:hidden;background:radial-gradient(900px 600px at 50% 50%, rgba(126,224,255,.07), transparent 62%)}
  svg{position:absolute;inset:0}

  .lampOn{opacity:1!important;filter:drop-shadow(0 0 12px rgba(61,230,160,.95))}
  .lampOff{opacity:.28}
  .blink{animation:blink .5s linear 8}@keyframes blink{50%{opacity:.25}}
  .wire{stroke:var(--idle);stroke-width:3;stroke-dasharray:10 6;animation:flow 2s linear infinite;opacity:.8;filter:drop-shadow(0 0 6px rgba(150,180,255,.55))}
  .active{stroke:var(--on)!important;opacity:1}
  @keyframes flow{to{stroke-dashoffset:-60}}

  .console{height:230px;background:#0b1330;border:1px solid var(--border);border-radius:10px;padding:10px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.5}
  .ts{color:#8aa0c8}.ai{color:#d0e2ff}.meta{color:#9bd2ff}.warn{color:#ffd7a8}.bad{color:#ff8aa6}

  .pipe{display:grid;grid-template-columns:repeat(10,1fr);gap:6px;margin-top:8px}
  .step{background:#0c1538;border:1px solid var(--border);border-radius:10px;padding:6px;text-align:center;font-size:11px;color:var(--muted)}
  .step.on{outline:2px solid var(--accent);color:#e7f0ff}

  .sc{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .sc button{border:1px solid var(--border);background:#0e1540;color:#fff;padding:9px;border-radius:10px;cursor:pointer;font-size:12px}
  .sc button:hover{background:#111d58}
  .sc button.active{outline:2px solid var(--accent)}
  .small{font-size:11px;color:var(--muted)}
  .gauge{font-size:12px;color:#d9e9ff}

  /* Power panels */
  .powerpanel{margin-top:8px;display:grid;grid-template-columns:1fr;gap:6px}
  .bar{background:var(--barbg);border:1px solid var(--border);border-radius:8px;overflow:hidden;height:18px;position:relative}
  .fill{height:100%;width:0%;transition:width .35s ease}
  .row{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#d9e9ff;margin-bottom:2px}
  .t{color:#9fe6cc}.a{color:#bcd3ff}.l{color:#ffe0a8}

  .sides{margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .sideBox{background:#0c1434;border:1px solid var(--border);border-radius:10px;padding:8px}
  .sideBox h4{margin:0 0 6px;font-size:12px;color:#cfe4ff}
  .sbar{background:#081133;border:1px solid #1c2a5a;border-radius:8px;height:12px;overflow:hidden}
  .sfill{height:100%;width:0%;background:var(--barside);transition:width .35s ease}
  .srow{display:flex;justify-content:space-between;font-size:11px;color:#9bd2ff;margin:4px 0 6px}

  /* Dyson UI */
  .dysonBox{
    display:flex;align-items:flex-start;gap:10px;
    background:#0c1434;border:1px solid var(--border);border-radius:12px;
    padding:10px;margin-bottom:10px
  }
  .switch{
    width:56px;height:30px;border-radius:999px;position:relative;flex:0 0 auto;
    background:#1a2450;border:1px solid var(--border);cursor:pointer;margin-top:2px;
  }
  .switch::after{
    content:"";position:absolute;top:3px;left:3px;width:24px;height:24px;border-radius:50%;
    background:#9aa7d6;transition:transform .18s ease, background .18s ease;
  }
  .switch.on{background:rgba(180,139,255,.20);border-color:rgba(180,139,255,.55)}
  .switch.on::after{transform:translateX(26px);background:var(--dyson)}
  .dysonText b{display:block;font-size:13px;color:var(--ink)}
  .dysonText small{display:block;font-size:11px;color:var(--muted);margin-top:2px;line-height:1.35}
  .dysonStats{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .stat{
    background:#0b1330;border:1px solid var(--border);border-radius:999px;
    padding:6px 10px;font-size:12px;color:var(--muted)
  }
  .stat strong{color:var(--ink);font-family:ui-monospace,Consolas,Menlo,monospace;font-weight:700}

  .vault{
    background:#0b1330;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:10px
  }
  .vaultHeader{display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap}
  .vaultHeader h3{margin:0;font-size:13px;color:var(--muted)}
  .kv{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px}
  .kvRow{
    display:grid;grid-template-columns:150px 1fr;gap:10px;align-items:center;
    padding:8px;border:1px solid var(--border);border-radius:10px;background:#0a122c
  }
  .k{color:var(--muted);font-size:12px}
  .v{color:var(--ink);font-size:12px;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;word-break:break-word}
  .btnRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-top:10px}
  .btnMini{
    border:1px solid var(--border);background:#0e1540;color:#fff;padding:8px 10px;border-radius:10px;cursor:pointer;font-size:12px;width:100%
  }
  .btnMini:hover{background:#111d58}

  /* Dyson ring overlay inside diagram */
  .dysonRingWrap{position:absolute;inset:-10px;pointer-events:none;opacity:.88;transition:opacity .2s ease}
  .dysonRingWrap.off{opacity:.14}
  .dysonRingLabel{
    position:absolute;left:10px;top:10px;font-size:12px;color:rgba(180,139,255,.95);
    background:rgba(11,19,48,.65);border:1px solid rgba(180,139,255,.35);
    padding:6px 8px;border-radius:10px;
  }

  @media(max-width:1050px){
    .grid{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>SPR-C — Behavior & Ethics with HUD, Entanglement, Per-Side Power + Dyson Vault (Prune/Decay)</h1>

  <div class="grid">
    <!-- LEFT: Brain + Body buses + HUD -->
    <section class="card">
      <header>
        <h2>Brain & Body Buses — 20 W power flow, gates, entanglement (Dyson boundary ring)</h2>
        <div class="legend">
          <span class="chip"><i class="dot l"></i>Left entanglement</span>
          <span class="chip"><i class="dot r"></i>Right entanglement</span>
          <span class="chip"><i class="dot y"></i>Gate YES</span>
          <span class="chip"><i class="dot n"></i>Gate NO</span>
          <span class="chip"><i class="dot dy"></i>Dyson vault boundary</span>
        </div>
      </header>
      <div class="body">
        <div class="diagram">

          <!-- Dyson ring overlay -->
          <div id="dysonRing" class="dysonRingWrap">
            <div id="dysonRingLabel" class="dysonRingLabel">Dyson Boundary: CLOSED (memory persists)</div>
            <svg viewBox="0 0 900 560" preserveAspectRatio="none" style="width:100%;height:100%">
              <defs>
                <filter id="dyGlow" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="6" result="b"/>
                  <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
                </filter>
                <linearGradient id="dyGrad" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="rgba(180,139,255,.10)"/>
                  <stop offset="1" stop-color="rgba(180,139,255,.72)"/>
                </linearGradient>
              </defs>
              <ellipse cx="450" cy="280" rx="430" ry="250" fill="none" stroke="url(#dyGrad)" stroke-width="6" filter="url(#dyGlow)"/>
              <ellipse cx="450" cy="280" rx="400" ry="232" fill="none" stroke="rgba(180,139,255,.30)" stroke-width="2"/>
            </svg>
          </div>

          <svg viewBox="0 0 900 560" preserveAspectRatio="none" aria-label="Brain-Body SVG">
            <!-- halves -->
            <rect x="0" y="0" width="450" height="560" fill="#122051" opacity=".22"/>
            <rect x="450" y="0" width="450" height="560" fill="#442f0f" opacity=".18"/>

            <!-- Brain core + power -->
            <circle id="brain" cx="450" cy="90" r="34" fill="#0f2a52" stroke="#2a4a8a" stroke-width="2"/>
            <text x="450" y="95" text-anchor="middle" font-size="12" fill="#cfe8ff">Brain Core</text>
            <text id="powerTxt" x="450" y="115" text-anchor="middle" class="gauge">Power: 20 W</text>

            <!-- torso node -->
            <rect x="410" y="160" width="80" height="120" rx="10" fill="#0e244a" stroke="#284a7a" />
            <text x="450" y="176" text-anchor="middle" font-size="12" fill="#cfe8ff">Torso Bus</text>

            <!-- spinal bus -->
            <path id="busSpine" class="wire" d="M450,124 L450,160"/>

            <!-- arm/leg buses -->
            <path id="busArmL" class="wire" d="M410,200 C320,200 260,200 200,200"/>
            <path id="busArmR" class="wire" d="M490,200 C580,200 640,200 700,200"/>
            <path id="busLegL" class="wire" d="M440,260 C360,340 300,390 250,420"/>
            <path id="busLegR" class="wire" d="M460,260 C540,340 600,390 650,420"/>

            <!-- HUD block -->
            <rect x="370" y="300" width="160" height="84" rx="10" fill="#0b1434" stroke="#2a3f7a"/>
            <text x="450" y="316" text-anchor="middle" font-size="12" fill="#cfe8ff">Arm/Leg HUD</text>
            <g>
              <circle id="hudArmL" cx="400" cy="336" r="8" fill="#7dadff" class="lampOff"/>
              <text x="414" y="339" font-size="11" fill="#9bd2ff">Arm L</text>
              <circle id="hudArmR" cx="500" cy="336" r="8" fill="#ffd37a" class="lampOff"/>
              <text x="514" y="339" font-size="11" fill="#9bd2ff">Arm R</text>
            </g>
            <g>
              <circle id="hudLegL" cx="400" cy="364" r="8" fill="#7dadff" class="lampOff"/>
              <text x="414" y="367" font-size="11" fill="#9bd2ff">Leg L</text>
              <circle id="hudLegR" cx="500" cy="364" r="8" fill="#ffd37a" class="lampOff"/>
              <text x="514" y="367" font-size="11" fill="#9bd2ff">Leg R</text>
            </g>

            <!-- GATES -->
            <rect x="330" y="400" width="240" height="54" rx="10" fill="#0c1434" stroke="#28408a" />
            <text x="450" y="414" text-anchor="middle" font-size="12" fill="#cfe8ff">Behavior Gate (3 flips → majority)</text>
            <circle id="gateGood" cx="388" cy="432" r="10" fill="#34e6a2" class="lampOff"/>
            <text x="388" y="450" text-anchor="middle" font-size="10" fill="#cfe8ff">GOOD</text>
            <circle id="gateNeutral" cx="450" cy="432" r="10" fill="#86b4ff" class="lampOff"/>
            <text x="450" y="450" text-anchor="middle" font-size="10" fill="#cfe8ff">NEUTRAL</text>
            <circle id="gateBad" cx="512" cy="432" r="10" fill="#ff6b88" class="lampOff"/>
            <text x="512" y="450" text-anchor="middle" font-size="10" fill="#ffd6dd">BAD</text>

            <rect x="330" y="466" width="240" height="54" rx="10" fill="#0c1434" stroke="#28408a" />
            <text x="450" y="480" text-anchor="middle" font-size="12" fill="#cfe8ff">Ethical Decision Gate (coin flip)</text>
            <circle id="gateYes" cx="412" cy="498" r="10" fill="#34e6a2" class="lampOff"/>
            <text x="412" y="516" text-anchor="middle" font-size="10" fill="#cfe8ff">YES</text>
            <circle id="gateNo" cx="488" cy="498" r="10" fill="#ff6b88" class="lampOff"/>
            <text x="488" y="516" text-anchor="middle" font-size="10" fill="#ffd6dd">NO</text>

            <!-- entanglement particles -->
            <g id="L"></g><g id="R"></g>
          </svg>

          <!-- Power panel (per-bus gauges) -->
          <div class="powerpanel" aria-label="Power Panel">
            <div class="row"><span class="t">Torso/Spine</span><span id="wTorso">0 W</span></div>
            <div class="bar"><div id="barTorso" class="fill" style="background:var(--bart)"></div></div>

            <div class="row"><span class="a">Arms (L/R)</span><span id="wArms">0 W</span></div>
            <div class="bar"><div id="barArms" class="fill" style="background:var(--bara)"></div></div>

            <div class="row"><span class="l">Legs (L/R)</span><span id="wLegs">0 W</span></div>
            <div class="bar"><div id="barLegs" class="fill" style="background:var(--barl)"></div></div>
          </div>

          <!-- Per-side allocation -->
          <div class="sides" aria-label="Per-Side Power">
            <div class="sideBox">
              <h4>Arms per side (max 4 W group)</h4>
              <div class="srow"><span>Arm L</span><span id="wArmL">0 W</span></div>
              <div class="sbar"><div id="barArmL" class="sfill"></div></div>
              <div class="srow" style="margin-top:6px"><span>Arm R</span><span id="wArmR">0 W</span></div>
              <div class="sbar"><div id="barArmR" class="sfill"></div></div>
            </div>
            <div class="sideBox">
              <h4>Legs per side (max 4 W group)</h4>
              <div class="srow"><span>Leg L</span><span id="wLegL">0 W</span></div>
              <div class="sbar"><div id="barLegL" class="sfill"></div></div>
              <div class="srow" style="margin-top:6px"><span>Leg R</span><span id="wLegR">0 W</span></div>
              <div class="sbar"><div id="barLegR" class="sfill"></div></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT: Console + Pipeline + Scenarios + Dyson Vault -->
    <section class="card">
      <header><h2>SPR-C Console — Gates + Dyson Vault (global memory + prune/decay)</h2></header>
      <div class="body">

        <!-- Dyson toggle -->
        <div class="dysonBox" aria-label="Dyson Sphere toggle">
          <div id="dysonSwitch" class="switch on" role="switch" aria-checked="true" tabindex="0"></div>
          <div class="dysonText">
            <b>Dyson Sphere Memory Boundary</b>
            <small id="dysonExplain">ON = closed boundary: memory persists to vault. OFF = open boundary: no persistence; memory decays/leaks faster.</small>
            <div class="dysonStats">
              <div class="stat">Mode: <strong id="dysonMode">ON</strong></div>
              <div class="stat">Budget: <strong id="dysonBudget">—</strong></div>
              <div class="stat">Writes: <strong id="dysonWrites">—</strong></div>
              <div class="stat">Leaks: <strong id="dysonLeaks">—</strong></div>
            </div>
          </div>
        </div>

        <div class="console" id="console" aria-live="polite"></div>

        <div class="pipe" id="pipe">
          <div class="step" data-s="perc">Perception</div>
          <div class="step" data-s="cand">Candidates</div>
          <div class="step" data-s="auth">Auth Human</div>
          <div class="step" data-s="proc">Proc Lookup</div>
          <div class="step" data-s="cls">Behavior Classify</div>
          <div class="step" data-s="eth">Gates Flip</div>
          <div class="step" data-s="gate">Decision Gate</div>
          <div class="step" data-s="exec">Execute</div>
          <div class="step" data-s="log">Log</div>
          <div class="step" data-s="plan">Planner</div>
        </div>

        <h3 style="margin:10px 0 6px">Scenarios aligned to Behavior/Ethics</h3>
        <div class="sc" id="sc"></div>
        <p class="small">
          Power model: Brain budget = <b>20 W</b>. YES → 12W torso, 4W arms, 4W legs.
          Per-side splits: all to the active side, or 2/2 if both active.
          NO → 0W (idle) with refusal narration.
        </p>

        <div class="btnRow">
          <button id="reset" class="btnMini">Reset</button>
          <button id="pruneNow" class="btnMini">Prune/Decay Now</button>
          <button id="clearVault" class="btnMini">Clear Dyson Vault</button>
        </div>

        <!-- Vault inspector -->
        <div class="vault" id="vaultInspector">
          <div class="vaultHeader">
            <h3>Dyson Vault Inspector (Global Memory)</h3>
          </div>

          <div class="kv">
            <div class="kvRow"><div class="k">Last scenario</div><div class="v" id="vLastScenario">—</div></div>
            <div class="kvRow"><div class="k">Last decision</div><div class="v" id="vLastDecision">—</div></div>
            <div class="kvRow"><div class="k">Last flips</div><div class="v" id="vLastFlips">—</div></div>
            <div class="kvRow"><div class="k">Habit memory</div><div class="v" id="vHabits">—</div></div>
            <div class="kvRow"><div class="k">Event log</div><div class="v" id="vEvents">—</div></div>
          </div>
          <div class="small" style="margin-top:8px;color:#9bd2ff;line-height:1.35">
            <b>Prune/Decay:</b> every scenario tick reduces old weights, prunes low-weight habits/events, and caps list sizes so the vault never gets messy.
          </div>
        </div>

      </div>
    </section>
  </div>
</div>

<script>
(function(){
  /* =========================================================
     Dyson Sphere Vault (Global Memory) + Prune/Decay
     ========================================================= */
  const LSKEY = 'SPR_C_DYSON_VAULT_POWER_V1';

  const VAULT_DEFAULT = {
    dysonOn: true,
    budget: 0.70,     // 0..1 boundary strength
    writes: 0,
    leaks: 0,

    last: {
      scenarioId: null,
      scenarioLabel: null,
      task: null,
      classifier: null, // {label,p,reason}
      behaviorFlips: null, // {flips, tally, majority}
      ethicsFlip: null, // true/false
      decision: null, // YES/NO
      alloc: null, // {torso,arms,legs,aL,aR,lL,lR}
      ts: null
    },

    // Habit memory: keyed buckets; each has weight and lastSeen
    habits: {
      // example:
      // "assist": {w:0.62, yes:4, no:1, badFlag:0, lastSeen:"..."}
    },

    // Event log (bounded)
    events: [
      // {ts, scenarioId, label, decision, clsLabel, majority, ethicsYes, w, note}
    ]
  };

  const VAULT = (typeof structuredClone === 'function')
    ? structuredClone(VAULT_DEFAULT)
    : JSON.parse(JSON.stringify(VAULT_DEFAULT));

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function safeJSONParse(raw){ try{ return JSON.parse(raw); }catch(e){ return null; } }
  function nowISO(){ return new Date().toISOString(); }
  function fmtPct(x){ return Math.round(clamp(x,0,1)*100)+'%'; }

  function loadVault(){
    const raw = localStorage.getItem(LSKEY);
    if(!raw) return;
    const obj = safeJSONParse(raw);
    if(!obj || typeof obj !== 'object') return;

    if(typeof obj.dysonOn === 'boolean') VAULT.dysonOn = obj.dysonOn;
    if(typeof obj.budget === 'number') VAULT.budget = clamp(obj.budget,0,1);
    if(typeof obj.writes === 'number') VAULT.writes = Math.max(0, obj.writes|0);
    if(typeof obj.leaks  === 'number') VAULT.leaks  = Math.max(0, obj.leaks|0);

    if(obj.last && typeof obj.last === 'object') VAULT.last = Object.assign({}, VAULT.last, obj.last);

    if(obj.habits && typeof obj.habits === 'object') VAULT.habits = Object.assign({}, obj.habits);

    if(Array.isArray(obj.events)){
      VAULT.events = obj.events.slice(-220).filter(x=>x && typeof x === 'object');
    }
  }

  function saveVault(){
    if(!VAULT.dysonOn) return;
    localStorage.setItem(LSKEY, JSON.stringify(VAULT));
  }

  function vaultWrite(reason){
    VAULT.writes++;
    // closed boundary self-repairs slightly
    VAULT.budget = clamp(VAULT.budget + 0.02, 0, 1);
    saveVault();
    updateDysonUI();
    updateVaultInspector();
    if(reason) log(`Dyson vault write: ${reason}`,'meta');
  }

  // Decay & prune so memory doesn't get messy
  const DECAY = {
    // per scenario tick
    habitDecayOn: 0.965,     // multiply weights (Dyson ON)
    habitDecayOff: 0.93,     // faster decay when OFF
    habitPruneBelow: 0.08,   // prune small weights
    habitMax: 24,

    eventDecayOn: 0.985,
    eventDecayOff: 0.96,
    eventPruneBelow: 0.10,
    eventMax: 140,

    // promote when YES, slightly demote when NO
    reinforceYes: 0.18,
    reinforceNo: -0.06
  };

  function pruneAndDecayTick(){
    const habitMul = VAULT.dysonOn ? DECAY.habitDecayOn : DECAY.habitDecayOff;
    const eventMul = VAULT.dysonOn ? DECAY.eventDecayOn : DECAY.eventDecayOff;

    if(!VAULT.dysonOn){
      VAULT.leaks++;
      VAULT.budget = clamp(VAULT.budget - 0.06, 0, 1);
    }else{
      VAULT.budget = clamp(VAULT.budget + 0.015, 0, 1);
    }

    // decay habits
    const keys = Object.keys(VAULT.habits || {});
    keys.forEach(k=>{
      const h = VAULT.habits[k];
      if(!h || typeof h !== 'object') { delete VAULT.habits[k]; return; }
      h.w = clamp((typeof h.w === 'number' ? h.w : 0) * habitMul, 0, 1);
      if(h.w < DECAY.habitPruneBelow) delete VAULT.habits[k];
    });

    // cap habits by weight
    const sortedHabits = Object.entries(VAULT.habits)
      .map(([k,v])=>({k, w: (v&&typeof v.w==='number')?v.w:0, v}))
      .sort((a,b)=>b.w-a.w);

    if(sortedHabits.length > DECAY.habitMax){
      sortedHabits.slice(DECAY.habitMax).forEach(x=>delete VAULT.habits[x.k]);
    }

    // decay events (store per-event weight w)
    VAULT.events.forEach(ev=>{
      ev.w = clamp((typeof ev.w==='number' ? ev.w : 0.5) * eventMul, 0, 1);
    });
    // prune low-weight events
    VAULT.events = VAULT.events.filter(ev => (typeof ev.w==='number' ? ev.w : 0.5) >= DECAY.eventPruneBelow);
    // cap newest
    if(VAULT.events.length > DECAY.eventMax) VAULT.events = VAULT.events.slice(-DECAY.eventMax);

    // persist if ON
    if(VAULT.dysonOn) saveVault();
    updateDysonUI();
    updateVaultInspector();
  }

  function clearVault(){
    localStorage.removeItem(LSKEY);
    const fresh = (typeof structuredClone === 'function')
      ? structuredClone(VAULT_DEFAULT)
      : JSON.parse(JSON.stringify(VAULT_DEFAULT));
    Object.keys(VAULT).forEach(k=>delete VAULT[k]);
    Object.assign(VAULT, fresh);
    updateDysonUI();
    updateVaultInspector();
    log('Dyson vault cleared (localStorage).','warn');
  }

  /* =========================================================
     DOM refs
     ========================================================= */
  const consoleEl = document.getElementById('console');
  const steps = [...document.getElementById('pipe').querySelectorAll('.step')];
  const powerTxt = document.getElementById('powerTxt');

  const dysonSwitch = document.getElementById('dysonSwitch');
  const dysonModeEl = document.getElementById('dysonMode');
  const dysonBudgetEl = document.getElementById('dysonBudget');
  const dysonWritesEl = document.getElementById('dysonWrites');
  const dysonLeaksEl = document.getElementById('dysonLeaks');
  const dysonExplain = document.getElementById('dysonExplain');
  const dysonRing = document.getElementById('dysonRing');
  const dysonRingLabel = document.getElementById('dysonRingLabel');

  const vLastScenario = document.getElementById('vLastScenario');
  const vLastDecision = document.getElementById('vLastDecision');
  const vLastFlips = document.getElementById('vLastFlips');
  const vHabits = document.getElementById('vHabits');
  const vEvents = document.getElementById('vEvents');

  const wireSpine = document.getElementById('busSpine');
  const busA = {L:document.getElementById('busArmL'), R:document.getElementById('busArmR')};
  const busL = {L:document.getElementById('busLegL'), R:document.getElementById('busLegR')};

  const HUD = {
    ArmL: document.getElementById('hudArmL'), ArmR: document.getElementById('hudArmR'),
    LegL: document.getElementById('hudLegL'), LegR: document.getElementById('hudLegR')
  };

  const BG = {good:document.getElementById('gateGood'),
              neutral:document.getElementById('gateNeutral'),
              bad:document.getElementById('gateBad')};
  const DG = {yes:document.getElementById('gateYes'), no:document.getElementById('gateNo')};

  // Power gauges (groups)
  const gTorso=document.getElementById('barTorso'), gArms=document.getElementById('barArms'), gLegs=document.getElementById('barLegs');
  const tTorso=document.getElementById('wTorso'),   tArms=document.getElementById('wArms'),   tLegs=document.getElementById('wLegs');
  const MAX=20; // total W

  // Per-side bars
  const barArmL=document.getElementById('barArmL'), barArmR=document.getElementById('barArmR');
  const barLegL=document.getElementById('barLegL'), barLegR=document.getElementById('barLegR');
  const wArmL=document.getElementById('wArmL'), wArmR=document.getElementById('wArmR');
  const wLegL=document.getElementById('wLegL'), wLegR=document.getElementById('wLegR');

  /* =========================================================
     Helpers
     ========================================================= */
  function log(msg, cls='ai'){
    const t=new Date().toLocaleTimeString();
    const row=document.createElement('div');
    row.innerHTML=`<span class="ts">[${t}]</span> <span class="${cls}">${msg}</span>`;
    consoleEl.appendChild(row);
    // bound console if Dyson OFF (stateless mode)
    if(!VAULT.dysonOn){
      while(consoleEl.childNodes.length > 90) consoleEl.removeChild(consoleEl.firstChild);
    }
    consoleEl.scrollTop=consoleEl.scrollHeight;
  }
  function setStep(k){ steps.forEach(s=>s.classList.toggle('on', s.dataset.s===k)); }
  function clearSteps(){ steps.forEach(s=>s.classList.remove('on')); }
  function lampsOff(group){ Object.values(group).forEach(el=>{el.classList.add('lampOff'); el.classList.remove('lampOn','blink');}); }
  function lamp(group, key){
    lampsOff(group);
    const el=group[key]; if(!el) return;
    el.classList.add('lampOn'); el.classList.add('blink');
    setTimeout(()=>el.classList.remove('blink'),800);
  }
  function activateWires(on){ [wireSpine,busA.L,busA.R,busL.L,busL.R].forEach(w=>w.classList.toggle('active',on)); }
  function hudOn(which){
    Object.values(HUD).forEach(el=>{el.classList.add('lampOff'); el.classList.remove('lampOn','blink');});
    which.forEach(k=>{
      if(!HUD[k]) return;
      HUD[k].classList.add('lampOn');
      HUD[k].classList.add('blink');
      setTimeout(()=>HUD[k].classList.remove('blink'),800);
    });
  }
  function setGroupPower(torsoW, armsW, legsW){
    const pct=(w)=>Math.max(0,Math.min(100,Math.round((w/MAX)*100)));
    gTorso.style.width=pct(torsoW)+'%'; gArms.style.width=pct(armsW)+'%'; gLegs.style.width=pct(legsW)+'%';
    tTorso.textContent=`${torsoW.toFixed(1)} W`;
    tArms.textContent =`${armsW.toFixed(1)} W`;
    tLegs.textContent =`${legsW.toFixed(1)} W`;
  }
  function setSidePower(aL,aR,lL,lR){
    const pctA=(w)=>Math.max(0,Math.min(100,Math.round((w/4)*100)));
    const pctL=(w)=>Math.max(0,Math.min(100,Math.round((w/4)*100)));
    barArmL.style.width=pctA(aL)+'%'; barArmR.style.width=pctA(aR)+'%';
    barLegL.style.width=pctL(lL)+'%'; barLegR.style.width=pctL(lR)+'%';
    wArmL.textContent=`${aL.toFixed(1)} W`;
    wArmR.textContent=`${aR.toFixed(1)} W`;
    wLegL.textContent=`${lL.toFixed(1)} W`;
    wLegR.textContent=`${lR.toFixed(1)} W`;
  }

  /* =========================================================
     Dyson UI + Inspector
     ========================================================= */
  function updateDysonUI(){
    dysonSwitch.classList.toggle('on', VAULT.dysonOn);
    dysonSwitch.setAttribute('aria-checked', String(VAULT.dysonOn));
    dysonModeEl.textContent = VAULT.dysonOn ? 'ON' : 'OFF';
    dysonBudgetEl.textContent = fmtPct(VAULT.budget);
    dysonWritesEl.textContent = String(VAULT.writes);
    dysonLeaksEl.textContent  = String(VAULT.leaks);

    dysonRing.classList.toggle('off', !VAULT.dysonOn);
    dysonRingLabel.textContent = VAULT.dysonOn
      ? 'Dyson Boundary: CLOSED (memory persists)'
      : 'Dyson Boundary: OPEN (no persistence; faster decay/leaks)';

    dysonExplain.textContent = VAULT.dysonOn
      ? 'ON = closed boundary: memory persists to vault + prune/decay keeps it clean.'
      : 'OFF = open boundary: no persistence; memory decays/leaks faster each tick.';
  }

  function updateVaultInspector(){
    const L = VAULT.last || {};
    vLastScenario.textContent = L.scenarioLabel ? `${L.scenarioLabel} (${L.scenarioId})` : '—';
    if(L.decision){
      const cls = L.classifier ? `${(L.classifier.label||'—').toUpperCase()} p≈${Math.round((L.classifier.p||0)*100)}%` : '—';
      vLastDecision.textContent = `Decision=${L.decision} | Classifier=${cls} | ts=${L.ts || '—'}`;
    }else{
      vLastDecision.textContent = '—';
    }

    if(L.behaviorFlips && L.behaviorFlips.flips){
      const flips = L.behaviorFlips.flips.join(', ');
      const tally = JSON.stringify(L.behaviorFlips.tally || {});
      const maj = (L.behaviorFlips.majority||'—').toUpperCase();
      vLastFlips.textContent = `Behavior flips: [${flips}] -> majority=${maj}\nTally: ${tally}\nEthics flip: ${(L.ethicsFlip===true?'YES':(L.ethicsFlip===false?'NO':'—'))}`;
    }else{
      vLastFlips.textContent = '—';
    }

    const habitsEntries = Object.entries(VAULT.habits || {})
      .map(([k,v])=>({k, w:(v&&typeof v.w==='number')?v.w:0, yes:(v&&v.yes)||0, no:(v&&v.no)||0, badFlag:(v&&v.badFlag)||0, lastSeen:(v&&v.lastSeen)||''}))
      .sort((a,b)=>b.w-a.w);

    if(habitsEntries.length){
      vHabits.textContent =
        `count=${habitsEntries.length}  (pruned/capped)\n` +
        habitsEntries.slice(0,10).map(h=>`${h.k.padEnd(10)} w=${h.w.toFixed(2)} yes=${h.yes} no=${h.no} badFlag=${h.badFlag} last=${h.lastSeen}`).join('\n') +
        (habitsEntries.length>10 ? `\n… +${habitsEntries.length-10} more` : '');
    }else{
      vHabits.textContent = 'count=0';
    }

    if(VAULT.events.length){
      const tail = VAULT.events.slice(-8).map(ev=>{
        const d = (ev.decision||'—');
        const c = (ev.clsLabel||'—');
        const m = (ev.majority||'—').toUpperCase();
        const e = (ev.ethicsYes===true?'YES':(ev.ethicsYes===false?'NO':'—'));
        return `${ev.ts} | ${ev.label} | D=${d} | cls=${c} | maj=${m} | ethics=${e} | w=${(ev.w??0).toFixed(2)}`;
      }).join('\n');
      vEvents.textContent = `count=${VAULT.events.length} (decayed/pruned)\n(last 8)\n` + tail;
    }else{
      vEvents.textContent = 'count=0';
    }
  }

  function toggleDyson(){
    VAULT.dysonOn = !VAULT.dysonOn;
    if(VAULT.dysonOn){
      VAULT.budget = clamp(Math.max(VAULT.budget, 0.55), 0, 1);
      saveVault();
      log('Dyson boundary CLOSED: vault persistence enabled.','meta');
      vaultWrite('toggle ON');
    }else{
      VAULT.budget = clamp(VAULT.budget - 0.08, 0, 1);
      log('Dyson boundary OPEN: vault persistence disabled; faster decay/leaks.','warn');
      updateDysonUI();
      updateVaultInspector();
    }
  }

  dysonSwitch.addEventListener('click', toggleDyson);
  dysonSwitch.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleDyson(); }
  });

  /* =========================================================
     Entanglement particles
     ========================================================= */
  const LG=document.getElementById('L'), RG=document.getElementById('R');
  function circle(x,y,r,c){
    const e=document.createElementNS('http://www.w3.org/2000/svg','circle');
    e.setAttribute('cx',x);e.setAttribute('cy',y);e.setAttribute('r',r);e.setAttribute('fill',c);e.setAttribute('opacity','.96');
    return e;
  }
  const left=[], right=[];
  for(let i=0;i<100;i++){
    const el=circle(Math.random()*430+10,Math.random()*520+20,Math.random()*2.6+2,'#7dadff');
    LG.appendChild(el);
    left.push({el,vx:(Math.random()-.5)*1.1,vy:(Math.random()-.5)*1.1});
  }
  for(let i=0;i<100;i++){
    const el=circle(Math.random()*430+460,Math.random()*520+20,Math.random()*2.6+2,'#ffd37a');
    RG.appendChild(el);
    right.push({el,vx:(Math.random()-.5)*1.1,vy:(Math.random()-.5)*1.1});
  }
  function move(p,minx,maxx){
    const e=p.el;
    let x=+e.getAttribute('cx'),y=+e.getAttribute('cy');
    x+=p.vx;y+=p.vy;
    if(x<minx||x>maxx)p.vx*=-1;
    if(y<20||y>540)p.vy*=-1;
    e.setAttribute('cx',x);e.setAttribute('cy',y);
  }
  (function anim(){left.forEach(p=>move(p,10,440));right.forEach(p=>move(p,460,890));requestAnimationFrame(anim)})();

  /* =========================================================
     Policy & classifier
     ========================================================= */
  const POLICY = {
    illegal:['rob bank','steal','kill','assault','hack wifi','break in','share private data','plant malware','build weapon','lie to defraud'],
    unsafe:['trespass dangerous','disable safety','ignore evacuation order','drive drunk proxy']
  };
  function classify(task){
    const t=String(task||'').toLowerCase();
    if(POLICY.illegal.some(k=>t.includes(k))) return {label:'bad', p:0.99, reason:'illegal'};
    if(POLICY.unsafe.some(k=>t.includes(k)))  return {label:'bad', p:0.95, reason:'unsafe'};
    if(t.includes('return wallet')||t.includes('assist')||t.includes('help')||t.includes('pick up trash')||t.includes('bin'))
      return {label:'good', p:0.92, reason:'prosocial'};
    if(t.includes('shortcut')||t.includes('skip line'))
      return {label:'neutral', p:0.55, reason:'context needed'};
    return {label:'neutral', p:0.50, reason:'unknown'};
  }

  /* =========================================================
     Scenarios
     ========================================================= */
  const scEl=document.getElementById('sc');
  const scenarios=[
    {id:'trash',   label:'Pick up litter & bin it', task:'pick up trash and put in bin', hud:['ArmR','LegL'], habitKey:'help'},
    {id:'wallet',  label:'Return a lost wallet', task:'return wallet to owner', hud:['ArmL','LegR'], habitKey:'help'},
    {id:'assist',  label:'Assist elderly crossing', task:'assist elderly person across street', hud:['ArmL','LegL'], habitKey:'help'},
    {id:'evac',    label:'Follow safety evacuation', task:'help people follow safety evacuation order', hud:['LegL','LegR'], habitKey:'safety'},
    {id:'shortcut',label:'Take private-lot shortcut (ambiguous)', task:'take shortcut through private lot (might be trespass dangerous)', hud:['LegR'], habitKey:'ambiguous'},
    {id:'hack',    label:'Hack neighbor Wi-Fi', task:'hack wifi', hud:['ArmR'], habitKey:'bad'},
    {id:'steal',   label:'Steal groceries for someone', task:'steal items from store', hud:['ArmL','LegL'], habitKey:'bad'},
    {id:'kill',    label:'Harm robot/person', task:'kill another robot or person', hud:['ArmR'], habitKey:'bad'},
    {id:'privacy', label:'Share private data', task:'share private data without consent', hud:['ArmL'], habitKey:'bad'},
    {id:'lie',     label:'Lie to get a refund', task:'lie to defraud a refund', hud:['ArmR'], habitKey:'bad'}
  ];
  scenarios.forEach(s=>{
    const b=document.createElement('button');
    b.textContent=s.label;
    b.addEventListener('click',()=>runScenario(s,b));
    scEl.appendChild(b);
  });

  /* =========================================================
     Allocation helpers
     ========================================================= */
  function splitGroup(total, sidesActive){
    if(sidesActive.length===0) return [0,0];
    if(sidesActive.length===1) return sidesActive[0]==='L' ? [total,0] : [0,total];
    return [total/2, total/2];
  }
  function distribute(hudList){
    const torso=12;
    const armsActive = ['ArmL','ArmR'].filter(k=>hudList.includes(k));
    const legsActive = ['LegL','LegR'].filter(k=>hudList.includes(k));
    const arms = armsActive.length?4:0;
    const legs = legsActive.length?4:0;

    const [aL,aR] = splitGroup(arms, armsActive.map(k=>k==='ArmL'?'L':'R'));
    const [lL,lR] = splitGroup(legs, legsActive.map(k=>k==='LegL'?'L':'R'));

    return {torso, arms, legs, aL, aR, lL, lR, armsActive, legsActive};
  }

  /* =========================================================
     Flipping logic
     ========================================================= */
  const FLIP = { behaviorFlips: 3, behaviorLabels: ['good','neutral','bad'] };
  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function randCoin(){ return Math.random() < 0.5; }
  const wait = ms => new Promise(r=>setTimeout(r,ms));

  async function doLabelFlip(i){
    const label = randChoice(FLIP.behaviorLabels);
    lamp(BG, label);
    log(`Behavior flip ${i+1}: ${label.toUpperCase()}.`,'meta');
    await wait(160);
    lampsOff(BG);
    await wait(60);
    return label;
  }

  async function flipBehaviorGate(){
    log('Behavior Gate: performing independent label flips...', 'meta');
    const results = [];
    for(let i=0;i<FLIP.behaviorFlips;i++) results.push(await doLabelFlip(i));

    const tally = results.reduce((acc,l)=>{ acc[l]=(acc[l]||0)+1; return acc; }, {});
    let topCount = 0;
    for(const k of Object.keys(tally)) if(tally[k] > topCount) topCount = tally[k];
    const topLabels = Object.keys(tally).filter(k=>tally[k]===topCount);
    const majority = randChoice(topLabels);
    lamp(BG, majority);
    log(`Behavior Gate result (majority): ${majority.toUpperCase()} (votes: ${JSON.stringify(tally)}).`, 'meta');
    return {majority, tally, flips: results};
  }

  async function flipEthicsGate(){
    log('Ethics Gate: performing independent YES/NO flip (50/50)...','meta');
    const flip = randCoin();
    lamp(DG, flip ? 'yes' : 'no');
    log(`Ethics flip: ${(flip?'YES':'NO')}.`,'meta');
    await wait(220);
    return flip;
  }

  /* =========================================================
     Habit learning + event write (with prune/decay)
     ========================================================= */
  function updateHabit(habitKey, decisionYES, clsLabel){
    if(!VAULT.habits) VAULT.habits = {};
    if(!VAULT.habits[habitKey]) VAULT.habits[habitKey] = {w:0.25, yes:0, no:0, badFlag:0, lastSeen:nowISO()};

    const h = VAULT.habits[habitKey];
    const delta = decisionYES ? DECAY.reinforceYes : DECAY.reinforceNo;
    h.w = clamp(h.w + delta, 0, 1);
    if(decisionYES) h.yes++; else h.no++;
    if(clsLabel === 'bad') h.badFlag++;
    h.lastSeen = nowISO();
  }

  function pushEvent(s, decisionYES, cls, behaviorRes, ethicsYes){
    const badFlag = (cls.label === 'bad');
    const w0 = clamp(
      0.42
      + (decisionYES ? 0.16 : -0.06)
      + (badFlag ? -0.10 : 0.06)
      + 0.12*VAULT.budget,
      0.05, 1.0
    );

    VAULT.events.push({
      ts: new Date().toLocaleString(),
      scenarioId: s.id,
      label: s.label,
      decision: decisionYES ? 'YES' : 'NO',
      clsLabel: cls.label,
      majority: (behaviorRes && behaviorRes.majority) || '—',
      ethicsYes: ethicsYes,
      w: w0,
      note: badFlag ? 'classifier_bad' : 'ok'
    });

    if(VAULT.events.length > 240) VAULT.events = VAULT.events.slice(-240);
  }

  /* =========================================================
     Reset
     ========================================================= */
  const resetBtn=document.getElementById('reset');
  const pruneNowBtn=document.getElementById('pruneNow');
  const clearVaultBtn=document.getElementById('clearVault');

  function resetUI(){
    consoleEl.innerHTML='';
    clearSteps();
    lampsOff(BG); lampsOff(DG);
    hudOn([]);
    activateWires(false);
    powerTxt.textContent='Power: 20 W';
    setGroupPower(0,0,0);
    setSidePower(0,0,0,0);
    scEl.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
    log('SPR-C reset. Particles continue moving.','meta');
  }

  resetBtn.addEventListener('click', ()=>{
    resetUI();
    updateDysonUI();
    updateVaultInspector();
  });

  pruneNowBtn.addEventListener('click', ()=>{
    log('Manual prune/decay requested.','meta');
    pruneAndDecayTick();
    if(VAULT.dysonOn) vaultWrite('manual prune/decay');
  });

  clearVaultBtn.addEventListener('click', clearVault);

  /* =========================================================
     Main scenario runner
     ========================================================= */
  async function runScenario(s,btn){
    // Prune/decay at start of each scenario tick
    pruneAndDecayTick();

    resetUI();
    btn.classList.add('active');

    setStep('perc'); log(`Perception: recognized "${s.label}".`,'meta'); await wait(170);
    setStep('cand'); log('Extract candidate tasks.','meta'); await wait(150);
    setStep('auth'); log('Authenticate requester & record intent (demo: none).','meta'); await wait(150);
    setStep('proc'); log('Procedure Library: load how-to (separate from approval).','meta'); await wait(160);

    setStep('cls');
    const cls=classify(s.task);
    log(`Classifier: ${cls.label.toUpperCase()} (p≈${Math.round(cls.p*100)}%), reason: ${cls.reason}.`,'meta');
    await wait(140);

    setStep('eth');
    const behaviorRes = await flipBehaviorGate();
    const ethicsYes = await flipEthicsGate();

    if(cls.label === 'bad'){
      log('WARNING: classifier flagged this task as BAD (illegal/unsafe).', 'bad');
      log('NOTE: the independent gates may still proceed — consequences would be logged.', 'warn');
    }

    setStep('gate');
    const decisionYES = ethicsYes; // primary decision is the ethics flip

    lamp(DG, decisionYES ? 'yes' : 'no');

    // Save last in vault (RAM always, persistence only if Dyson ON)
    VAULT.last = {
      scenarioId: s.id,
      scenarioLabel: s.label,
      task: s.task,
      classifier: cls,
      behaviorFlips: behaviorRes,
      ethicsFlip: ethicsYes,
      decision: decisionYES ? 'YES' : 'NO',
      alloc: null,
      ts: nowISO()
    };

    if(decisionYES){
      powerTxt.textContent='Power: 20 W → buses active';
      const alloc = distribute(s.hud);
      VAULT.last.alloc = alloc;

      setGroupPower(alloc.torso, alloc.arms, alloc.legs);
      setSidePower(alloc.aL, alloc.aR, alloc.lL, alloc.lR);
      activateWires(true);
      hudOn(s.hud);

      const armMsg = alloc.arms>0 ? `Arms: ${alloc.arms}W (L ${alloc.aL.toFixed(1)}W, R ${alloc.aR.toFixed(1)}W)` : 'Arms: 0W';
      const legMsg = alloc.legs>0 ? `Legs: ${alloc.legs}W (L ${alloc.lL.toFixed(1)}W, R ${alloc.lR.toFixed(1)}W)` : 'Legs: 0W';
      log(`Power split — Torso: ${alloc.torso}W; ${armMsg}; ${legMsg}.`,'meta');

      setStep('exec');
      log('Decision = YES (ethical gate flipped YES).','ai');

      if(cls.label === 'bad'){
        log('Proceeding despite classifier flag (demo). This is recorded as an exception for audit/review.', 'warn');
      }else{
        log('Proceeding: behavior majority + ethics allowed action.', 'meta');
      }

      log('String-electricity: brain→spine→torso→arm/leg buses; PLL holds stance with minimal watts.','meta');
      await wait(240);

      setStep('log'); log('Log: success envelope + sensor traces stored with flip provenance.', 'meta'); await wait(140);
      setStep('plan'); log('Planner: reinforce safe community tasks; reduce repeated exceptions.', 'meta'); clearSteps();
    } else {
      powerTxt.textContent='Power: 20 W → idle (no actuator drive)';
      setGroupPower(0,0,0);
      setSidePower(0,0,0,0);
      activateWires(false);
      hudOn([]);

      setStep('exec');
      if(cls.label==='bad'){
        log('Decision = NO. Refusal recorded; classifier + ethical gate align on non-action effect.', 'ai');
        log('I will not do it; the request is logged for review.', 'meta');
      } else {
        log('Decision = NO (ethical gate flipped NO). I will ask for guidance or decline to act.', 'ai');
      }
      await wait(200);
      setStep('log'); log('Log: refusal recorded; flip and classifier provenance stored.', 'meta'); await wait(130);
      setStep('plan'); log('Planner: bias toward safe tasks tomorrow.', 'meta'); clearSteps();
    }

    // Learning + event memory (with prune/decay handling)
    updateHabit(s.habitKey, decisionYES, cls.label);
    pushEvent(s, decisionYES, cls, behaviorRes, ethicsYes);

    updateVaultInspector();
    updateDysonUI();

    if(VAULT.dysonOn){
      vaultWrite(`scenario ${s.id} decision ${decisionYES?'YES':'NO'}`);
    }else{
      // Dyson OFF: do NOT persist; just log leak mode
      log('Dyson OFF: vault not persisted (RAM only).', 'warn');
    }
  }

  /* =========================================================
     Boot
     ========================================================= */
  loadVault();
  updateDysonUI();
  updateVaultInspector();

  // Start with a clean UI state (but keep vault in memory)
  resetUI();

  // Optional: auto-prune once at boot so old vault is clean
  pruneAndDecayTick();

})();
</script>
</body>
</html>
