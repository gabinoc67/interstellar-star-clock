<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Fix + Œ¶-HNS + Dyson + Prune/Decay + Vault Interval (Fixed Inspector + Live Stress)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --muted:#b6c2d2;
    --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e; --ok:#35d07f; --bad:#ff5a66;

    --dysonRing: rgba(255, 200, 60, 0.62);
    --dysonRing2: rgba(255, 200, 60, 0.18);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}

  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;align-items:start;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;min-height:calc(100vh - 24px);overflow:auto;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:10px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;align-items:center;}
  .row.tight{margin:6px 0}
  .group{border:1px solid rgba(45,71,100,.55);background:rgba(0,0,0,.14);border-radius:12px;padding:10px;margin-top:10px;}
  .group h3{margin:0 0 6px}

  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}

  label{display:block;font-size:12px;opacity:.92;margin-top:8px;}
  input[type="range"]{width:100%;}
  input[type="number"]{background:var(--panel2);border:1px solid var(--line);color:var(--ink);border-radius:10px;padding:6px 8px;}

  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;color:var(--muted);line-height:1.35;}

  .switch{
    display:flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:10px;
    border:1px solid var(--btnb);background:var(--panel2);
    font-size:12px;
    user-select:none;
    width:100%;
  }
  .switch input{transform:scale(1.05);}

  .log{
    height:170px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }

  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{height:100%;width:0%;background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);}

  .kv{display:grid;grid-template-columns:120px 1fr;gap:4px 10px;font-size:12px;opacity:.94;}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
  .inspector{
    border:1px solid rgba(45,71,100,.65);
    background:rgba(8,14,22,0.55);
    border-radius:12px;
    padding:10px;
  }

  .dyRead,.pdRead{font-size:12px;opacity:.95;line-height:1.35;}
  .statGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px;}
  .statBox{border:1px solid rgba(45,71,100,.55);background:rgba(0,0,0,.18);border-radius:10px;padding:8px;font-size:12px;line-height:1.35;}

  .logHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-top:8px;}
  .logHead h3{margin:0;}

  /* ‚úÖ decluttered Circle Panel Layers: split into 2 sub-panels */
  .layersGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;}
  .subpanel{
    border:1px solid rgba(45,71,100,.55);
    background:rgba(0,0,0,.10);
    border-radius:12px;
    padding:10px;
  }
  .subpanel h4{
    margin:0 0 8px;
    font-size:12px;
    opacity:.95;
    letter-spacing:.2px;
  }
  .subpanel .switch{margin:6px 0;}
</style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h2>Hexagon Fix + Œ¶-HNS + Dyson + Prune/Decay + Vault Interval</h2>

    <div class="row">
      <button id="step">+1 side</button>
      <button id="step5">+5 sides</button>
      <button id="reset">Reset (N=6)</button>
      <button id="auto">Auto ‚Üí circle mirror</button>
    </div>

    <div class="row tight">
      <span class="pill" id="nPill">N: 6</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
      <span class="pill" id="matchPill">Match: ‚Äî</span>
      <span class="pill" id="statusPill">Status: ‚Äî</span>
    </div>

    <!-- ‚úÖ decluttered / separated -->
    <div class="group">
      <h3>Circle Panel Layers (Separated)</h3>

      <div class="layersGrid">
        <div class="subpanel">
          <h4>Core Geometry</h4>
          <label class="switch" title="Shows the 6-node constraint ring and line labels (M‚ÄìE, E‚ÄìF, etc).">
            <input id="constraintView" type="checkbox" checked />
            Constraint Ring + Labels
          </label>
          <label class="switch" title="Shows nested hex frames.">
            <input id="nestedHex" type="checkbox" checked />
            Nested Hexagons
          </label>
        </div>

        <div class="subpanel">
          <h4>Lattice + Memory</h4>
          <label class="switch" title="Shows hex-lattice nodes and heat.">
            <input id="latticeView" type="checkbox" checked />
            Hex Lattice
          </label>
          <label class="switch" title="Clips lattice drawing inside the domain circle.">
            <input id="latticeClip" type="checkbox" checked />
            Clip to Circle
          </label>
          <label class="switch" title="Draws spiral trace snapped to lattice nodes.">
            <input id="spiralOn" type="checkbox" checked />
            Spiral Trace
          </label>
          <label class="switch" title="Draws glyphs for locked nodes.">
            <input id="glyphView" type="checkbox" checked />
            Glyphs
          </label>
        </div>
      </div>

      <div class="small" style="margin-top:8px;">
        <b>Legend:</b> Domain circle = container <b>R</b>. Inner mirror circle = regulated radius. Constraint ring nodes show live stress numbers.
      </div>
    </div>

    <div class="row">
      <label class="switch"><input id="inspectOn" type="checkbox" checked /> Click-to-Inspect</label>
      <label class="switch"><input id="pinSel" type="checkbox" /> Pin selection</label>
      <button id="unpin">Unpin</button>
    </div>

    <div class="row">
      <button id="stressBtn">Failure Inject</button>
      <button id="clearMem">Clear Glyph Memory</button>
    </div>

    <div class="group">
      <h3>Dyson Sphere + Vault</h3>
      <div class="row tight" style="flex-direction:column;">
        <label class="switch" title="Draw outer Dyson boundary ring. Also changes decay/prune behavior.">
          <input id="dysonOn" type="checkbox" />
          Dyson Sphere
        </label>
        <label class="switch" title="If ON and Dyson is ON, persists locks to localStorage (vault).">
          <input id="dysonPersist" type="checkbox" checked />
          Persist Memory
        </label>
      </div>

      <label>Vault save interval (frames): <span id="vaultEveryVal"></span></label>
      <input id="vaultEvery" type="range" min="1" max="120" step="1" value="20" />
      <div class="small">Higher interval = fewer writes. ‚Äú1‚Äù saves every frame (not recommended).</div>

      <label>Dyson radius scale: <span id="dysonScaleVal"></span></label>
      <input id="dysonScale" type="range" min="1.10" max="3.00" step="0.01" value="2.20" />

      <label>Capture fraction (%): <span id="dysonCapVal"></span></label>
      <input id="dysonCap" type="range" min="0" max="100" step="1" value="100" />

      <label>Star luminosity (W):</label>
      <input id="dysonLum" type="number" value="3.828e26" step="1e24" style="width:200px;" />

      <div class="dyRead" style="margin-top:6px;">
        <div><b>Captured power:</b> <span id="dysonPower">‚Äî</span></div>
        <div><b>Flux at shell:</b> <span id="dysonFlux">‚Äî</span></div>
        <div><b>Vault:</b> <span id="vaultRead">‚Äî</span></div>
      </div>
    </div>

    <div class="group">
      <h3>Prune + Decay (Memory Maintenance)</h3>
      <div class="row tight" style="flex-direction:column;">
        <label class="switch" title="Decay fades surplus + activation over time.">
          <input id="decayOn" type="checkbox" checked />
          Decay
        </label>
        <label class="switch" title="Prune unlocks weak nodes and caps locked count.">
          <input id="pruneOn" type="checkbox" checked />
          Prune
        </label>
      </div>

      <label>Decay rate (per tick): <span id="decayRateVal"></span></label>
      <input id="decayRate" type="range" min="0.000" max="0.060" step="0.001" value="0.018" />

      <label>Prune threshold (surplus): <span id="pruneThVal"></span></label>
      <input id="pruneTh" type="range" min="0.00" max="0.60" step="0.01" value="0.10" />

      <label>Max locked glyphs (cap): <span id="maxLockedVal"></span></label>
      <input id="maxLocked" type="range" min="50" max="700" step="10" value="320" />

      <div class="statGrid">
        <div class="statBox">
          <div><b>Effective decay:</b> <span id="pdDecayEff">‚Äî</span></div>
          <div><b>Effective prune:</b> <span id="pdPruneEff">‚Äî</span></div>
          <div class="small">Dyson ON ‚Üí gentler decay + slightly easier to keep locks.</div>
        </div>
        <div class="statBox">
          <div><b>Pruned this tick:</b> <span id="pdPrunedTick">0</span></div>
          <div><b>Locked kept:</b> <span id="pdKept">0</span></div>
          <div><b>Dropped by cap:</b> <span id="pdDropped">0</span></div>
        </div>
      </div>
    </div>

    <div class="group">
      <h3>Geometry + Regulation</h3>
      <label>Polygon sides N: <span id="nVal"></span></label>
      <input id="N" type="range" min="6" max="240" step="1" value="6" />

      <label>Intent radius a: <span id="aVal"></span></label>
      <input id="a" type="range" min="80" max="420" value="260" />

      <label>Container radius R: <span id="RVal"></span></label>
      <input id="R" type="range" min="160" max="520" value="300" />

      <label>Regulation strength k: <span id="kVal"></span></label>
      <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="1.10" />

      <div class="kbox">
        <div class="kTop">
          <div class="small"><b>Strength</b> (k)</div>
          <div class="kBig" id="kBig">1.10</div>
        </div>
        <div class="meter"><div class="meterFill" id="kFill"></div></div>
        <div class="small" id="kText" style="margin-top:6px;"></div>
      </div>

      <label style="margin-top:12px;">CST Phase Alignment œÜ‚Çõ‚Çú: <span id="phiBig">0.00</span></label>
      <input id="phi" type="range" min="0" max="1" step="0.01" value="0.00" />
      <div class="small" id="phiHint" style="margin-top:6px;"></div>
    </div>

    <div class="group">
      <h3>Œ¶-HNS Memory Controls</h3>
      <label>Collapse threshold Œ∏œï: <span id="thetaVal"></span></label>
      <input id="theta" type="range" min="0.20" max="1.00" step="0.01" value="0.62" />

      <label>Surplus gain: <span id="gainVal"></span></label>
      <input id="gain" type="range" min="0.20" max="2.00" step="0.01" value="1.00" />

      <label>Surplus leak: <span id="leakVal"></span></label>
      <input id="leak" type="range" min="0.00" max="0.12" step="0.001" value="0.028" />
    </div>

    <div class="group">
      <h3>Node Inspector (Live)</h3>
      <div class="inspector">
        <div class="kv">
          <div><b>Selected</b></div><div class="mono" id="selId">‚Äî</div>
          <div><b>q,r</b></div><div class="mono" id="selQR">‚Äî</div>
          <div><b>v</b></div><div class="mono" id="selV">‚Äî</div>
          <div><b>surplus</b></div><div class="mono" id="selS">‚Äî</div>
          <div><b>locked</b></div><div class="mono" id="selLock">‚Äî</div>
          <div><b>glyph</b></div><div class="mono" id="selGlyph">‚Äî</div>
          <div><b>dist‚Üícenter</b></div><div class="mono" id="selDist">‚Äî</div>
        </div>
        <div class="small" style="margin-top:8px;">
          Tip: click inside the domain circle. If Hex Lattice is OFF, Inspector won‚Äôt update.
        </div>
      </div>
    </div>

    <div class="logHead">
      <h3>Step log</h3>
      <div class="row" style="margin:0;">
        <button id="dlCSV" title="Download the step log as a CSV file">Download CSV</button>
      </div>
    </div>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const $ = (id)=>document.getElementById(id);

  // Inputs
  const NEl=$("N"), aEl=$("a"), REl=$("R"), kEl=$("k"), phiEl=$("phi");
  const thetaEl=$("theta"), gainEl=$("gain"), leakEl=$("leak");

  // Labels
  const nVal=$("nVal"), aVal=$("aVal"), RVal=$("RVal"), kVal=$("kVal");
  const thetaVal=$("thetaVal"), gainVal=$("gainVal"), leakVal=$("leakVal");
  const nPill=$("nPill"), modePill=$("modePill"), matchPill=$("matchPill"), statusPill=$("statusPill");
  const kBig=$("kBig"), kFill=$("kFill"), kText=$("kText");
  const phiBig=$("phiBig"), phiHint=$("phiHint");

  // Toggles
  const constraintViewEl=$("constraintView");
  const latticeViewEl=$("latticeView");
  const latticeClipEl=$("latticeClip");
  const glyphViewEl=$("glyphView");
  const nestedHexEl=$("nestedHex");
  const spiralOnEl=$("spiralOn");
  const inspectOnEl=$("inspectOn");
  const pinSelEl=$("pinSel");

  // Buttons
  const unpinBtn=$("unpin");
  const stressBtn=$("stressBtn");
  const clearMemBtn=$("clearMem");
  const dlCSVBtn=$("dlCSV");

  // Dyson + Vault
  const dysonOnEl=$("dysonOn");
  const dysonPersistEl=$("dysonPersist");
  const vaultEveryEl=$("vaultEvery");
  const vaultEveryValEl=$("vaultEveryVal");
  const vaultReadEl=$("vaultRead");

  const dysonScaleEl=$("dysonScale");
  const dysonScaleValEl=$("dysonScaleVal");
  const dysonCapEl=$("dysonCap");
  const dysonCapValEl=$("dysonCapVal");
  const dysonLumEl=$("dysonLum");
  const dysonPowerEl=$("dysonPower");
  const dysonFluxEl=$("dysonFlux");

  // Prune/Decay
  const decayOnEl=$("decayOn");
  const pruneOnEl=$("pruneOn");
  const decayRateEl=$("decayRate"), decayRateValEl=$("decayRateVal");
  const pruneThEl=$("pruneTh"), pruneThValEl=$("pruneThVal");
  const maxLockedEl=$("maxLocked"), maxLockedValEl=$("maxLockedVal");
  const pdDecayEffEl=$("pdDecayEff");
  const pdPruneEffEl=$("pdPruneEff");
  const pdPrunedTickEl=$("pdPrunedTick");
  const pdKeptEl=$("pdKept");
  const pdDroppedEl=$("pdDropped");

  // Inspector fields
  const selIdEl=$("selId"), selQREl=$("selQR"), selVEl=$("selV"), selSEl=$("selS"),
        selLockEl=$("selLock"), selGlyphEl=$("selGlyph"), selDistEl=$("selDist");

  // Log
  const logEl=$("log");
  const logEntries=[];
  const nowISO=()=>new Date().toISOString();
  const log=(t)=>{
    logEntries.push({time:nowISO(), msg:String(t)});
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  };

  // Helpers
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // ‚úÖ FIX: roundRect helper (your legend box was calling it but it didn‚Äôt exist)
  function roundRect(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // DPR safe
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function setDPR(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(DPR, DPR);
  }
  const cssW=()=>canvas.width/DPR;
  const cssH=()=>canvas.height/DPR;

  // Canvas HUD state
  const HUD = { decayAppliedPct:0, prunedThisTick:0, vaultEvent:"‚Äî", vaultCount:0, dysonOn:false };

  // --- Geometry ---
  function circleMatchPercent(N){
    const ratio=(N*Math.sin(Math.PI/N))/Math.PI;
    return 100*ratio;
  }
  function regulatedRadius(a,R,k){
    if(a<=R) return {rad:a, regulated:false, s:1};
    const s=Math.pow(R/a,k);
    return {rad:a*s, regulated:true, s};
  }
  function polygonVertices(cx,cy,rad,n,rot=0){
    const pts=[];
    const offset=-Math.PI/6 + rot;
    for(let i=0;i<n;i++){
      const ang=(Math.PI*2)*(i/n)+offset;
      pts.push([cx+rad*Math.cos(ang), cy+rad*Math.sin(ang)]);
    }
    return pts;
  }
  function drawPolygon(pts, fill=true){
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    if(fill) ctx.fill();
    ctx.stroke();
  }
  function strokeForK(regulated,k){
    const t=clamp((k-0.50)/2.00,0,1);
    const cool={r:69,g:103,b:132}, warm={r:182,g:139,b:46};
    const r=Math.round(cool.r*(1-t)+warm.r*t);
    const g=Math.round(cool.g*(1-t)+warm.g*t);
    const b=Math.round(cool.b*(1-t)+warm.b*t);
    const a=regulated?(0.75+0.20*t):(0.55+0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }
  function updateKUI(regulated){
    const k=+kEl.value;
    kVal.textContent=k.toFixed(2);
    kBig.textContent=k.toFixed(2);
    const pct=clamp(((k-0.50)/2.00)*100,0,100);
    kFill.style.width=pct.toFixed(1)+"%";
    let label="Soft clamp.";
    if(k>=1.00 && k<1.50) label="Balanced clamp.";
    if(k>=1.50 && k<2.10) label="Strong clamp.";
    if(k>=2.10) label="Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent=label;
  }
  function updatePills(regulated,N,matchPct){
    nPill.textContent=`N: ${N}`;
    modePill.textContent=`Mode: ${regulated?"Regulation":"Geometry"}`;
    modePill.style.borderColor=regulated?"#b68b2e":"#2d4764";
    modePill.style.background=regulated?"#221a0a":"#0c131d";
    matchPill.textContent=`Match: ${matchPct.toFixed(1)}%`;
  }

  // --- Dyson UI ---
  function fmtSI(x){
    if(!isFinite(x)) return "‚Äî";
    const ax=Math.abs(x);
    if(ax>=1e24) return (x/1e24).toFixed(3)+"e24";
    if(ax>=1e18) return (x/1e18).toFixed(3)+"e18";
    if(ax>=1e12) return (x/1e12).toFixed(3)+"e12";
    if(ax>=1e9)  return (x/1e9 ).toFixed(3)+"e9";
    if(ax>=1e6)  return (x/1e6 ).toFixed(3)+"e6";
    if(ax>=1e3)  return (x/1e3 ).toFixed(3)+"e3";
    return x.toFixed(3);
  }
  function updateDysonUI(){
    dysonScaleValEl.textContent=(+dysonScaleEl.value).toFixed(2)+"√óR";
    dysonCapValEl.textContent=(+dysonCapEl.value).toFixed(0);
    vaultEveryValEl.textContent=String(parseInt(vaultEveryEl.value,10));

    const cap=(+dysonCapEl.value)/100;
    const L=Number(dysonLumEl.value);
    const captured=L*cap;

    const rRel=+dysonScaleEl.value;
    const fluxRel=L/(4*Math.PI*rRel*rRel);

    dysonPowerEl.textContent=fmtSI(captured)+" W";
    dysonFluxEl.textContent=fmtSI(fluxRel)+" W / (4œÄ (R¬∑scale)^2)";
  }

  // --- Prune/Decay effective values ---
  function effectiveDecayRate(){
    const base=+decayRateEl.value;
    const mult = dysonOnEl.checked ? 0.70 : 1.35;
    return clamp(base*mult,0,0.20);
  }
  function effectivePruneThreshold(){
    const base=+pruneThEl.value;
    const adj = dysonOnEl.checked ? -0.02 : +0.03;
    return clamp(base+adj,0,0.95);
  }
  function updatePDUI(stats){
    decayRateValEl.textContent=(+decayRateEl.value).toFixed(3);
    pruneThValEl.textContent=(+pruneThEl.value).toFixed(2);
    maxLockedValEl.textContent=String(parseInt(maxLockedEl.value,10));

    pdDecayEffEl.textContent=effectiveDecayRate().toFixed(3)+" / tick";
    pdPruneEffEl.textContent=effectivePruneThreshold().toFixed(2)+" surplus";

    if(stats){
      pdPrunedTickEl.textContent=String(stats.prunedThisTick);
      pdKeptEl.textContent=String(stats.keptLocked);
      pdDroppedEl.textContent=String(stats.droppedLocked);
    }
  }

  // ---------------- Inspector ----------------
  function setInspector(idx){
    if(idx<0 || !lattice.nodes[idx]){
      selIdEl.textContent="‚Äî"; selQREl.textContent="‚Äî"; selVEl.textContent="‚Äî";
      selSEl.textContent="‚Äî"; selLockEl.textContent="‚Äî"; selGlyphEl.textContent="‚Äî"; selDistEl.textContent="‚Äî";
      return;
    }
    const n=lattice.nodes[idx];
    selIdEl.textContent=String(idx);
    selQREl.textContent=`${n.q}, ${n.r}`;
    selVEl.textContent=n.v.toFixed(3);
    selSEl.textContent=n.surplus.toFixed(3);
    selLockEl.textContent=n.locked?"true":"false";
    selGlyphEl.textContent=n.locked?(n.glyph||""):"‚Äî";
    const dx=n.x-lastCenter.cx, dy=n.y-lastCenter.cy;
    selDistEl.textContent=Math.hypot(dx,dy).toFixed(1);
  }

  // Selection state
  let selected={ idx:-1, pinned:false };
  let lastCenter={ cx:0, cy:0, R:0 };

  // Click-to-inspect
  canvas.addEventListener("click",(ev)=>{
    if(!inspectOnEl.checked) return;
    if(!latticeViewEl.checked) { log("Inspector: turn Hex Lattice ON to inspect nodes."); log("‚Äî"); return; }

    const rect=canvas.getBoundingClientRect();
    const px=ev.clientX-rect.left;
    const py=ev.clientY-rect.top;

    const cx=lastCenter.cx, cy=lastCenter.cy, R=lastCenter.R;
    if(Math.hypot(px-cx,py-cy) > R+6) return;

    let best=-1, bestD2=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-px, dy=n.y-py;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){bestD2=d2; best=i;}
    }
    if(best<0) return;

    selected.idx=best;
    selected.pinned=pinSelEl.checked;

    setInspector(best);
    const n=lattice.nodes[best];
    log(`INSPECT: idx=${best} q,r=(${n.q},${n.r}) v=${n.v.toFixed(3)} s=${n.surplus.toFixed(3)} locked=${n.locked}`);
    log("‚Äî");
    draw(false);
  });

  unpinBtn.addEventListener("click",()=>{
    selected.pinned=false;
    pinSelEl.checked=false;
    log("Inspector: unpinned.");
    log("‚Äî");
    draw(false);
  });

  // ---------------- Stress ring (live numbers) ----------------
  const pillars=[{key:"Maxwell",short:"M"},{key:"Einstein",short:"E"},{key:"Feynman",short:"F"},{key:"Turing",short:"T"},{key:"vonNeumann",short:"V"},{key:"Shannon",short:"S"}];
  const order=["Maxwell","Einstein","Feynman","Turing","vonNeumann","Shannon"];
  const edgeLabels=["M‚ÄìE","E‚ÄìF","F‚ÄìT","T‚ÄìV","V‚ÄìS","S‚ÄìM"];

  let stressInject=false;
  let t0=performance.now();

  function stressColor(s){
    if(s<0.5){
      const t=s/0.5;
      const r=Math.round(lerp(42,214,t));
      const g=Math.round(lerp(163,166,t));
      const b=Math.round(lerp(74,58,t));
      return `rgb(${r},${g},${b})`;
    }else{
      const t=(s-0.5)/0.5;
      const r=Math.round(lerp(214,208,t));
      const g=Math.round(lerp(166,74,t));
      const b=Math.round(lerp(58,74,t));
      return `rgb(${r},${g},${b})`;
    }
  }

  function computeStresses({N,a,R,k,phi,regulated}){
    const match = clamp(circleMatchPercent(N)/100,0,1);
    const coarseness = clamp(1-match,0,1);
    const overflow = clamp((a-R)/Math.max(1,R),0,1);
    const kPressure = clamp(Math.abs(k-1.0)/1.5,0,1);
    const clampActive = regulated ? 1 : 0;
    const deco = (1-phi);
    const damp = lerp(1.0,0.55,phi);

    let inj=0;
    if(stressInject){
      const tt=(performance.now()-t0)/1000;
      inj=0.5+0.5*Math.sin(tt*2.3);
    }

    const base={
      Maxwell:    0.12 + 0.55*overflow + 0.22*coarseness + 0.12*inj,
      Einstein:   0.14 + 0.60*overflow + 0.30*deco      + 0.06*clampActive + 0.10*inj,
      Shannon:    0.12 + 0.55*coarseness + 0.40*deco    + 0.08*overflow + 0.08*inj,
      vonNeumann: 0.14 + 0.55*kPressure + 0.20*deco     + 0.08*clampActive + 0.08*inj,
      Turing:     0.14 + 0.50*kPressure + 0.35*coarseness + 0.10*inj,
      Feynman:    0.14 + 0.45*coarseness + 0.55*deco    + 0.10*overflow + 0.10*inj,
    };

    let s=order.map(k=>base[k]);
    const c=lerp(0.22,0.12,phi);
    for(let it=0;it<2;it++){
      const next=s.slice();
      for(let i=0;i<s.length;i++){
        const L=s[(i-1+s.length)%s.length];
        const Rr=s[(i+1)%s.length];
        const coupled=(s[i]+c*(L+Rr))/(1+2*c);
        next[i]=clamp(coupled*damp,0,1);
      }
      s=next;
    }

    const out={};
    for(let i=0;i<order.length;i++) out[order[i]]=s[i];
    return {out,match};
  }

  function drawLegendBox(x,y){
    ctx.save();
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(10,16,24,0.68)";
    ctx.strokeStyle="rgba(45,71,100,0.78)";
    ctx.lineWidth=1;
    roundRect(x,y,270,106,10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.fillText("Constraint Ring (Live):", x+10, y+18);

    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText("Edges: M‚ÄìE, E‚ÄìF, F‚ÄìT, T‚ÄìV, V‚ÄìS, S‚ÄìM", x+10, y+36);
    ctx.fillText("Each corner shows live stress value (0..1).", x+10, y+52);

    ctx.fillStyle="rgba(232,238,246,0.86)";
    ctx.fillText("M Maxwell | E Einstein | F Feynman | T Turing | V vonN | S Shannon", x+10, y+74);
    ctx.restore();
  }

  function drawConstraintOverlay(cx,cy,R,rr,stressPack){
    const rad=Math.min(rr.rad,R*0.78);
    const pts=polygonVertices(cx,cy,rad,6);

    drawLegendBox(12, 112);

    // ring edges
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.strokeStyle="rgba(120,150,180,0.35)";
    ctx.lineWidth=1.4;
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    // edge labels
    ctx.save();
    ctx.globalAlpha=0.86;
    ctx.fillStyle="rgba(232,238,246,0.78)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    for(let i=0;i<6;i++){
      const a=pts[i], b=pts[(i+1)%6];
      const mx=(a[0]+b[0])*0.5, my=(a[1]+b[1])*0.5;
      const dx=mx-cx, dy=my-cy;
      const d=Math.max(1,Math.hypot(dx,dy));
      ctx.fillText(edgeLabels[i], mx+(dx/d)*16, my+(dy/d)*16);
    }
    ctx.restore();

    // nodes with live numbers
    for(let i=0;i<6;i++){
      const key=order[i];
      const s=stressPack.out[key];
      const [x,y]=pts[i];

      ctx.fillStyle=stressColor(s);
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(x,y,16,0,Math.PI*2); ctx.fill(); ctx.stroke();

      ctx.fillStyle="#071019";
      ctx.font="900 13px system-ui, Segoe UI, Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(pillars[i].short,x,y);

      const dx=x-cx, dy=y-cy;
      const d=Math.max(1,Math.hypot(dx,dy));
      const ox=x+(dx/d)*30;
      const oy=y+(dy/d)*30;

      ctx.fillStyle="rgba(232,238,246,0.92)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.textAlign=(dx>=0)?"left":"right";
      const name = key==="vonNeumann"?"vonN":key;
      ctx.fillText(`${name}: ${s.toFixed(2)}`, ox, oy);
    }
    ctx.textAlign="left"; ctx.textBaseline="alphabetic";
  }

  // ---------------- Dyson draw ----------------
  function drawDysonSphere(cx,cy,R){
    if(!dysonOnEl.checked) return;
    const scale=+dysonScaleEl.value;
    const dyR=R*scale;

    ctx.save();
    ctx.beginPath();
    ctx.arc(cx,cy,dyR,0,Math.PI*2);
    ctx.lineWidth=Math.max(2, R*0.022);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--dysonRing') || "rgba(255,200,60,.62)";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(cx,cy,dyR + ctx.lineWidth*2.1,0,Math.PI*2);
    ctx.lineWidth=ctx.lineWidth*2.2;
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--dysonRing2') || "rgba(255,200,60,.18)";
    ctx.stroke();
    ctx.restore();
  }

  // ---------------- Vault (interval) ----------------
  const VAULT_KEY="HEXARA_DYSON_VAULT_V3";
  let frameCount=0;

  function vaultEnabled(){
    return dysonOnEl.checked && dysonPersistEl.checked;
  }
  function saveVaultPayload(){
    const locked = lattice.nodes.filter(n=>n.locked).map(n=>({q:n.q,r:n.r,s:+n.surplus.toFixed(4),g:n.glyphIdx}));
    return {ts:Date.now(), locked};
  }
  function saveVaultMaybe(){
    if(!vaultEnabled()){ HUD.vaultEvent="off"; HUD.vaultCount=0; vaultReadEl.textContent="OFF"; return; }

    const every=parseInt(vaultEveryEl.value,10);
    if(every<=1 || (frameCount % every)===0){
      try{
        const payload=saveVaultPayload();
        localStorage.setItem(VAULT_KEY, JSON.stringify(payload));
        HUD.vaultEvent="saved";
        HUD.vaultCount=payload.locked.length;
        vaultReadEl.textContent=`saved (${HUD.vaultCount}) every ${every}`;
      }catch(e){
        HUD.vaultEvent="save fail";
        HUD.vaultCount=0;
        vaultReadEl.textContent="save fail";
      }
    }else{
      vaultReadEl.textContent=`idle every ${every}`;
      HUD.vaultEvent="idle";
      HUD.vaultCount=lattice.nodes.reduce((a,n)=>a+(n.locked?1:0),0);
    }
  }
  function restoreVaultIfEnabled(){
    if(!vaultEnabled()){ return 0; }
    try{
      const raw=localStorage.getItem(VAULT_KEY);
      if(!raw) return 0;
      const payload=JSON.parse(raw);
      if(!payload || !Array.isArray(payload.locked)) return 0;

      let applied=0;
      for(const it of payload.locked){
        const idx=lattice.map.get(it.q+","+it.r);
        if(idx===undefined) continue;
        const n=lattice.nodes[idx];
        n.locked=true;
        n.surplus=clamp(it.s ?? 0.2, 0, 1.25);
        n.glyphIdx=(it.g ?? 0);
        n.glyph=GLYPHS[n.glyphIdx] || "";
        applied++;
      }
      HUD.vaultEvent="restored";
      HUD.vaultCount=applied;
      vaultReadEl.textContent=`restored (${applied})`;
      return applied;
    }catch(e){
      return 0;
    }
  }

  // ---------------- Lattice ----------------
  const HEX={ size:14, dirs:[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]] };
  const GLYPHS=["ùíÆ","ùíû","‡∏Ä","ùí¶","œï","‚ü°","‚äï","‚àø","‚àû","‚óá","‚ñ£","‚ú∂"];

  let lattice={ nodes:[], map:new Map(), builtFor:{w:0,h:0,R:0,size:HEX.size} };

  function axialToPixel(q,r,size){
    const x=size*Math.sqrt(3)*(q+r/2);
    const y=size*1.5*r;
    return [x,y];
  }

  function buildHexLattice(cx,cy,R){
    const size=clamp(Math.round(R/22),10,16);
    HEX.size=size;
    lattice.nodes=[];
    lattice.map=new Map();
    lattice.builtFor={ w:cssW(), h:cssH(), R, size };

    const max=Math.ceil(R/(size*1.15));
    for(let r=-max;r<=max;r++){
      for(let q=-max;q<=max;q++){
        const [dx,dy]=axialToPixel(q,r,size);
        const d=Math.hypot(dx,dy);
        if(d<=R-size*0.3){
          const idx=lattice.nodes.length;
          lattice.map.set(q+","+r, idx);
          lattice.nodes.push({
            q,r, x:cx+dx, y:cy+dy,
            v:0,v2:0,
            surplus:0,s2:0,
            locked:false, glyph:"", glyphIdx:-1,
            nei:[]
          });
        }
      }
    }
    for(const n of lattice.nodes){
      n.nei.length=0;
      for(const [dq,dr] of HEX.dirs){
        const j=lattice.map.get((n.q+dq)+","+(n.r+dr));
        if(j!==undefined) n.nei.push(j);
      }
    }

    // Restore vault after build
    restoreVaultIfEnabled();

    log(`LATTICE: built ${lattice.nodes.length} nodes (hex size=${size}px).`);
    log("‚Äî");
  }

  function ensureLatticeBuilt(cx,cy,R,force=false){
    const bf=lattice.builtFor;
    const changed = force || !lattice.nodes.length ||
      Math.abs(bf.R-R)>0.5 ||
      Math.abs(bf.w-cssW())>0.5 ||
      Math.abs(bf.h-cssH())>0.5;
    if(changed) buildHexLattice(cx,cy,R);
  }

  function clearLatticeMemory(){
    for(const n of lattice.nodes){
      n.v=0;n.v2=0;n.surplus=0;n.s2=0;
      n.locked=false;n.glyph="";n.glyphIdx=-1;
    }
    try{ localStorage.removeItem(VAULT_KEY); }catch(e){}
    HUD.vaultEvent="cleared";
    HUD.vaultCount=0;
    vaultReadEl.textContent="cleared";
  }

  function injectSourcesToLattice(pillarPts, pillarStress, phi){
    const influence=clamp(lattice.builtFor.R*0.40,120,260);
    const inv2=1/(influence*influence);
    const injScale=lerp(1.00,0.70,phi);

    for(const node of lattice.nodes){
      let s=0,wsum=0;
      for(let i=0;i<pillarPts.length;i++){
        const [px,py]=pillarPts[i];
        const dx=node.x-px, dy=node.y-py;
        const w=Math.exp(-(dx*dx+dy*dy)*inv2);
        wsum+=w; s+=w*pillarStress[i];
      }
      const src=wsum>0?(s/wsum):0;
      const blend=node.locked?0.08:0.18;
      node.v=clamp(lerp(node.v, src*injScale, blend),0,1);
    }
  }

  function injectFailure(phi){
    if(!stressInject || !lattice.nodes.length) return;
    const R=lattice.builtFor.R;
    const cx=cssW()/2, cy=cssH()/2;
    const targetX=cx+R*0.35, targetY=cy-R*0.20;

    let best=-1, bestD=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-targetX, dy=n.y-targetY;
      const d2=dx*dx+dy*dy;
      if(d2<bestD){bestD=d2; best=i;}
    }
    if(best<0) return;

    const tt=(performance.now()-t0)/1000;
    const osc=0.5+0.5*Math.sin(tt*3.2);
    const amp=lerp(0.35,0.18,phi);
    lattice.nodes[best].v=clamp(lattice.nodes[best].v+osc*amp,0,1);
  }

  function propagateLatticeAndMemory(phi){
    const coupling=lerp(0.28,0.12,phi);
    const damping=lerp(0.985,0.92,phi);

    const thetaBase=+thetaEl.value;
    const gain=+gainEl.value;
    const leak=+leakEl.value;

    const thetaEff=clamp(thetaBase+0.08*phi,0.20,1.00);
    const gainEff=gain*lerp(1.0,0.78,phi);
    const leakEff=leak*lerp(1.0,0.75,phi);

    for(let step=0; step<2; step++){
      for(const n of lattice.nodes){
        let avg=0;
        const m=n.nei.length||1;
        for(const j of n.nei) avg+=lattice.nodes[j].v;
        avg/=m;
        const stiff=n.locked?0.65:1.0;
        const mixed=n.v+(coupling*stiff)*(avg-n.v);
        n.v2=clamp(mixed*damping,0,1);
      }
      for(const n of lattice.nodes) n.v=n.v2;

      for(const n of lattice.nodes){
        const lockFactor=n.locked?0.22:1.0;
        const add=n.v*0.030*gainEff*lockFactor;
        const dec=n.surplus*leakEff;
        n.s2=clamp(n.surplus+add-dec,0,1.25);
      }

      for(const n of lattice.nodes){
        n.surplus=n.s2;
        if(!n.locked && n.surplus>=thetaEff){
          n.locked=true;
          const idx=Math.abs((n.q*31+n.r*17)%GLYPHS.length);
          n.glyphIdx=idx;
          n.glyph=GLYPHS[idx]||"";
        }
      }
    }
    return {thetaEff, gainEff};
  }

  function applyDecayAndPrune(){
    const dOn=decayOnEl.checked;
    const pOn=pruneOnEl.checked;
    const dEff=effectiveDecayRate();
    const pruneTh=effectivePruneThreshold();
    const maxLocked=parseInt(maxLockedEl.value,10);

    const decayPct = dOn ? clamp(dEff*100,0,100) : 0;

    if(dOn){
      for(const n of lattice.nodes){
        const lockSlow = n.locked ? 0.55 : 1.0;
        n.surplus = clamp(n.surplus * (1 - dEff*lockSlow), 0, 1.25);
        n.v = clamp(n.v * (1 - (dEff*0.45)), 0, 1);
      }
    }

    let pruned=0;
    if(pOn){
      for(const n of lattice.nodes){
        if(n.locked && n.surplus < pruneTh){
          n.locked=false; n.glyph=""; n.glyphIdx=-1;
          pruned++;
        }
      }
    }

    let dropped=0;
    let lockedList = lattice.nodes.filter(n=>n.locked);
    if(pOn && lockedList.length>maxLocked){
      const idxs = lattice.nodes.map((n,i)=>({n,i})).filter(o=>o.n.locked);
      idxs.sort((a,b)=>a.n.surplus-b.n.surplus);
      const toDrop = idxs.length-maxLocked;
      for(let i=0;i<toDrop;i++){
        const nn=idxs[i].n;
        nn.locked=false; nn.glyph=""; nn.glyphIdx=-1;
        dropped++;
      }
    }

    const kept=lattice.nodes.reduce((acc,n)=>acc+(n.locked?1:0),0);
    return {prunedThisTick: pruned+dropped, keptLocked: kept, droppedLocked: dropped, decayPct};
  }

  function drawLattice(){
    if(latticeClipEl.checked){
      const {cx,cy,R}=lastCenter;
      ctx.save();
      ctx.beginPath(); ctx.arc(cx,cy,R-1,0,Math.PI*2); ctx.clip();
    } else ctx.save();

    for(const n of lattice.nodes){
      const hot=Math.max(n.v, clamp(n.surplus,0,1)*0.85);
      if(hot<0.02 && !n.locked) continue;
      ctx.fillStyle=stressColor(clamp(hot,0,1));
      const r=(n.locked?2.3:1.4)+2.0*hot;
      ctx.beginPath(); ctx.arc(n.x,n.y,r,0,Math.PI*2); ctx.fill();
      if(n.locked){
        ctx.strokeStyle="rgba(232,238,246,0.35)";
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(n.x,n.y,r+1.6,0,Math.PI*2); ctx.stroke();
      }
    }

    if(glyphViewEl.checked){
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.font="900 11px system-ui, Segoe UI, Arial";
      let drawn=0, MAX=320;
      for(const n of lattice.nodes){
        if(!n.locked) continue;
        if(drawn++>MAX) break;
        ctx.fillStyle="rgba(7,16,25,0.90)";
        ctx.fillText(n.glyph||"", n.x, n.y);
      }
    }

    // selection highlight
    if(selected.idx>=0 && lattice.nodes[selected.idx]){
      const n=lattice.nodes[selected.idx];
      ctx.strokeStyle="rgba(232,238,246,0.95)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(n.x,n.y,10,0,Math.PI*2); ctx.stroke();
    }

    ctx.restore();
  }

  function drawSpiral(cx,cy,R){
    if(!spiralOnEl.checked || !lattice.nodes.length) return;

    if(latticeClipEl.checked){
      ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,R-1,0,Math.PI*2); ctx.clip();
    } else ctx.save();

    const turns=3.2, samples=220, rMax=R*0.92;
    let path=[], last=-1;

    for(let i=0;i<samples;i++){
      const t=i/(samples-1);
      const ang=t*turns*2*Math.PI;
      const rad=t*rMax;
      const px=cx+rad*Math.cos(ang);
      const py=cy+rad*Math.sin(ang);

      let best=-1, bestD2=1e18;
      for(let j=0;j<lattice.nodes.length;j++){
        const n=lattice.nodes[j];
        const dx=n.x-px, dy=n.y-py;
        const d2=dx*dx+dy*dy;
        if(d2<bestD2){bestD2=d2; best=j;}
      }
      if(best>=0 && best!==last){
        path.push(best); last=best;
      }
    }

    ctx.globalAlpha=0.65;
    ctx.lineWidth=2.0;
    ctx.strokeStyle="rgba(182,139,46,0.75)";
    ctx.beginPath();
    for(let i=0;i<path.length;i++){
      const n=lattice.nodes[path[i]];
      if(i===0) ctx.moveTo(n.x,n.y); else ctx.lineTo(n.x,n.y);
    }
    ctx.stroke();

    ctx.restore();
  }

  function drawNestedHexes(cx,cy,R){
    if(!nestedHexEl.checked) return;
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.lineWidth=1.2;
    const rings=6;
    for(let i=1;i<=rings;i++){
      const t=i/(rings+1);
      const rad=R*(0.18 + 0.78*t);
      const rot=(i%2===0)?0:(Math.PI/12);
      const pts=polygonVertices(cx,cy,rad,6,rot);
      ctx.strokeStyle=(i===rings)?"rgba(232,238,246,0.28)":"rgba(120,150,180,0.22)";
      ctx.beginPath(); ctx.moveTo(pts[0][0],pts[0][1]);
      for(let k=1;k<pts.length;k++) ctx.lineTo(pts[k][0],pts[k][1]);
      ctx.closePath(); ctx.stroke();
    }
    ctx.restore();
  }

  // HUD box (always visible)
  function drawHUD(){
    const x=12,y=12,w=340,h=88;
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(10,16,24,0.68)";
    ctx.strokeStyle="rgba(45,71,100,0.80)";
    ctx.lineWidth=1;
    roundRect(x,y,w,h,12);
    ctx.fill(); ctx.stroke();

    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.fillText("Overlay (Decay / Prune / Vault):", x+12, y+20);
    ctx.fillText(`Decay applied: ${HUD.decayAppliedPct.toFixed(1)}%`, x+12, y+40);
    ctx.fillText(`Pruned this tick: ${HUD.prunedThisTick}`, x+12, y+58);
    const dy=HUD.dysonOn?"Dyson ON":"Dyson OFF";
    ctx.fillText(`${dy} ‚Ä¢ Vault: ${HUD.vaultEvent} (${HUD.vaultCount})`, x+12, y+76);
    ctx.restore();
  }

  // ---------------- Buttons wired ----------------
  function updateStressBtn(){ stressBtn.textContent = stressInject ? "Failure Inject: ON" : "Failure Inject"; }
  updateStressBtn();
  stressBtn.onclick=()=>{ stressInject=!stressInject; updateStressBtn(); log(`Failure Inject: ${stressInject?"ON":"OFF"}`); log("‚Äî"); draw(true); };

  clearMemBtn.onclick=()=>{
    if(!latticeViewEl.checked){ log("Clear: turn Hex Lattice ON first."); log("‚Äî"); return; }
    if(!lattice.nodes.length){ log("Clear: lattice not built yet."); log("‚Äî"); return; }
    clearLatticeMemory();
    if(!selected.pinned){ selected.idx=-1; setInspector(-1); }
    log("Memory cleared.");
    log("‚Äî");
    draw(false);
  };

  dlCSVBtn.onclick=()=>{
    const header=["time","message"];
    const rows=logEntries.map(e=>`"${e.time}","${String(e.msg).replaceAll('"','""')}"`);
    const csv=header.join(",")+"\n"+rows.join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download="hexara_step_log.csv";
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    log("CSV: downloaded hexara_step_log.csv");
    log("‚Äî");
  };

  // Step controls
  function setN(v){ NEl.value=String(clamp(v,6,240)); draw(false); }
  $("step").onclick=()=>{ const N=parseInt(NEl.value,10); setN(N+1); log(`STEP: N=${N+1}`); log("‚Äî"); };
  $("step5").onclick=()=>{ const N=parseInt(NEl.value,10); setN(N+5); log(`STEP: N=${N+5}`); log("‚Äî"); };
  $("auto").onclick=()=>{
    let N=parseInt(NEl.value,10);
    for(let it=0;it<400;it++){ if(circleMatchPercent(N)>=99.6) break; N++; if(N>=240) break; }
    setN(N);
    log(`AUTO: N‚Üí${N} match‚âà${circleMatchPercent(N).toFixed(2)}%`);
    log("‚Äî");
  };
  $("reset").onclick=()=>{
    NEl.value="6"; aEl.value="260"; REl.value="300"; kEl.value="1.10"; phiEl.value="0.00";
    thetaEl.value="0.62"; gainEl.value="1.00"; leakEl.value="0.028";
    dysonOnEl.checked=false;
    selected.idx=-1; selected.pinned=false; pinSelEl.checked=false; setInspector(-1);
    logEl.textContent=""; logEntries.length=0;
    log("RESET.");
    log("‚Äî");
    draw(true);
  };

  // ---------------- Main draw ----------------
  function draw(forceRebuild=false){
    frameCount++;

    const N=parseInt(NEl.value,10);
    const a=+aEl.value;
    const R=+REl.value;
    const k=+kEl.value;
    const phi=+phiEl.value;

    // live UI labels
    nVal.textContent=N;
    aVal.textContent=a.toFixed(0);
    RVal.textContent=R.toFixed(0);
    kVal.textContent=k.toFixed(2);
    phiBig.textContent=phi.toFixed(2);
    thetaVal.textContent=(+thetaEl.value).toFixed(2);
    gainVal.textContent=(+gainEl.value).toFixed(2);
    leakVal.textContent=(+leakEl.value).toFixed(3);

    if(phi<0.20) phiHint.textContent="œÜ‚Çõ‚Çú low: wider spread + more collapse.";
    else if(phi<0.60) phiHint.textContent="œÜ‚Çõ‚Çú moderate: reduced spread + collapse density.";
    else phiHint.textContent="œÜ‚Çõ‚Çú high: selective memory + stronger damping.";

    updateDysonUI();

    const w=cssW(), h=cssH();
    ctx.clearRect(0,0,w,h);

    const cx=w/2, cy=h/2;
    lastCenter={cx,cy,R};

    // Dyson
    drawDysonSphere(cx,cy,R);

    // domain circle R
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

    // nested hexes
    drawNestedHexes(cx,cy,R);

    const rr=regulatedRadius(a,R,k);
    updateKUI(rr.regulated);
    const matchPct=circleMatchPercent(N);
    updatePills(rr.regulated,N,matchPct);

    // main N-gon
    const poly=polygonVertices(cx,cy,rr.rad,N);
    ctx.fillStyle=rr.regulated?"#0f2236":"#0d1a2a";
    ctx.strokeStyle=strokeForK(rr.regulated,k);
    ctx.lineWidth=2;
    drawPolygon(poly,true);

    // mirror circle (regulated radius)
    ctx.globalAlpha=0.45;
    ctx.strokeStyle="rgba(232,238,246,0.35)";
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(cx,cy,rr.rad,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;

    // stress pack
    const needConstraint=constraintViewEl.checked;
    const needLattice=latticeViewEl.checked;
    const stressPack = (needConstraint || needLattice) ? computeStresses({N,a,R,k,phi,regulated:rr.regulated}) : null;

    // lattice
    if(needLattice && stressPack){
      ensureLatticeBuilt(cx,cy,R,forceRebuild);

      const rad=Math.min(rr.rad,R*0.78);
      const pillarPts=polygonVertices(cx,cy,rad,6);
      const pillarStress=order.map(key=>stressPack.out[key] ?? 0);

      injectSourcesToLattice(pillarPts,pillarStress,phi);
      injectFailure(phi);

      const eff=propagateLatticeAndMemory(phi);

      const pdStats=applyDecayAndPrune();
      updatePDUI(pdStats);

      HUD.dysonOn=dysonOnEl.checked;
      HUD.decayAppliedPct=pdStats.decayPct;
      HUD.prunedThisTick=pdStats.prunedThisTick;

      drawLattice();
      drawSpiral(cx,cy,R);

      const lockedCount=lattice.nodes.reduce((acc,n)=>acc+(n.locked?1:0),0);
      statusPill.textContent=`Status: nodes=${lattice.nodes.length} locked=${lockedCount}`;

      if(selected.idx>=0) setInspector(selected.idx);

      saveVaultMaybe();

      ctx.fillStyle="rgba(232,238,246,0.78)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.fillText(`Locked=${lockedCount}  Œ∏œï‚âà${eff.thetaEff.toFixed(2)}  gain‚âà${eff.gainEff.toFixed(2)}  leak=${(+leakEl.value).toFixed(3)}  œÜ‚Çõ‚Çú=${phi.toFixed(2)}`, 14, 92);
    } else {
      statusPill.textContent="Status: lattice OFF";
      updatePDUI({prunedThisTick:0, keptLocked:0, droppedLocked:0});
      HUD.dysonOn=dysonOnEl.checked;
      HUD.decayAppliedPct = decayOnEl.checked ? effectiveDecayRate()*100 : 0;
      HUD.prunedThisTick = 0;
      HUD.vaultEvent = vaultEnabled() ? "idle" : "off";
      HUD.vaultCount = 0;
      if(!selected.pinned){ selected.idx=-1; setInspector(-1); }
    }

    // constraint overlay with live numbers (always redraws)
    if(needConstraint && stressPack){
      drawConstraintOverlay(cx,cy,R,rr,stressPack);
    }

    // geometry text
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const geomMsg = rr.regulated
      ? `Clamp ACTIVE: a=${a.toFixed(0)} > R=${R.toFixed(0)} ‚Üí s=(R/a)^k=${rr.s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No clamp: a=${a.toFixed(0)} ‚â§ R=${R.toFixed(0)} (k=${k.toFixed(2)})`;
    ctx.fillText(geomMsg, 14, 18);
    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText(`Boundary refinement: N=${N}, circle-match ‚âà ${matchPct.toFixed(1)}%`, 14, 36);

    drawHUD();
  }

  // -------- Inputs/toggles redraw --------
  const inputsToRedraw=[NEl,aEl,REl,kEl,phiEl,thetaEl,gainEl,leakEl,dysonScaleEl,dysonCapEl,dysonLumEl,decayRateEl,pruneThEl,maxLockedEl,vaultEveryEl];
  inputsToRedraw.forEach(el=>el.addEventListener("input", ()=>draw(false)));

  const togglesToRedraw=[constraintViewEl,latticeViewEl,latticeClipEl,glyphViewEl,nestedHexEl,spiralOnEl,inspectOnEl,pinSelEl,dysonOnEl,dysonPersistEl,decayOnEl,pruneOnEl];
  togglesToRedraw.forEach(el=>el.addEventListener("change", ()=>draw(true)));

  // Resize
  function resize(){ setDPR(); draw(true); }
  window.addEventListener("resize", resize);

  // Animation
  function tick(){
    const animate = latticeViewEl.checked || stressInject;
    if(animate) draw(false);
    requestAnimationFrame(tick);
  }

  // Init
  log("FIX: roundRect() added (prevents script stop ‚Üí live numbers never freeze).");
  log("UI: Circle Panel Layers split into Core Geometry vs Lattice + Memory.");
  log("‚Äî");

  resize();
  draw(true);
  tick();
})();
</script>
</body>
</html>
