<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Fix + Î¦-HNS Hex Lattice + Nested Hexes + Spiral Trace + Inspector</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;

    /* Dyson Sphere ring colors */
    --dysonRing: rgba(255, 200, 60, 0.62);
    --dysonRing2: rgba(255, 200, 60, 0.18);
  }

  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;align-items:center;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:190px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }

  /* Canvas is plain; overlay HUD is drawn inside the canvas (no DOM overlap). */
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }

  .switch{
    display:flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:10px;
    border:1px solid var(--btnb);background:var(--panel2);
    font-size:12px;
    user-select:none;
  }
  .switch input{transform:scale(1.05);}

  .inspector{
    margin-top:10px;
    background:rgba(8,14,22,0.55);
    border:1px solid rgba(45,71,100,0.70);
    border-radius:12px;
    padding:10px;
  }
  .inspector .title{font-weight:800;font-size:13px;letter-spacing:.2px;margin-bottom:6px;}
  .kv{display:grid;grid-template-columns:120px 1fr;gap:4px 10px;font-size:12px;opacity:.92;}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}

  .dysonBox{
    margin-top:10px;
    border:1px solid var(--btnb);
    background:rgba(9,14,22,0.55);
    border-radius:12px;
    padding:10px;
  }
  .dyRead{margin-top:6px;font-size:12px;opacity:.92;line-height:1.35;}
  .dyRead b{opacity:1}

  .pdBox{
    margin-top:10px;
    border:1px solid var(--btnb);
    background:rgba(9,14,22,0.55);
    border-radius:12px;
    padding:10px;
  }
  .pdGrid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
    margin-top:8px;
  }
  .pdStat{
    border:1px solid rgba(45,71,100,.55);
    background:rgba(0,0,0,.18);
    border-radius:10px;
    padding:8px;
    font-size:12px;
    line-height:1.35;
    opacity:.95;
  }
  .pdStat b{opacity:1}

  .logHead{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    margin-top:8px;
  }
  .logHead h3{margin:0;}
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Hexagon Fix + Î¦-HNS: Hex Lattice + Nested Hexes + Spiral Trace + Inspector</h2>

    <div class="row">
      <button id="step">+1 side</button>
      <button id="step5">+5 sides</button>
      <button id="reset">Reset (N=6)</button>
      <button id="auto">Auto â†’ circle mirror</button>
    </div>

    <div class="row">
      <span class="pill" id="nPill">N: 6</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
      <span class="pill" id="matchPill">Match: â€”</span>
      <span class="pill" id="statusPill">Status: â€”</span>
    </div>

    <div class="row">
      <label class="switch"><input id="constraintView" type="checkbox" /> Constraint View</label>
      <label class="switch"><input id="latticeView" type="checkbox" checked /> Hex Lattice</label>
      <label class="switch" title="When ON, lattice drawing is clipped strictly inside the domain circle.">
        <input id="latticeClip" type="checkbox" checked />
        Lattice in Circle
      </label>
      <label class="switch"><input id="glyphView" type="checkbox" checked /> Glyph Memory</label>
    </div>

    <div class="row">
      <label class="switch" title="Draws multiple nested hexagon frames (paper-style).">
        <input id="nestedHex" type="checkbox" checked />
        Nested Hexagons
      </label>
      <label class="switch" title="Draws a spiral trace through the lattice (snapped to nodes).">
        <input id="spiralOn" type="checkbox" checked />
        Lattice Spiral Trace
      </label>
    </div>

    <div class="row">
      <label class="switch"><input id="inspectOn" type="checkbox" checked /> Click-to-Inspect</label>
      <label class="switch"><input id="pinSel" type="checkbox" /> Pin selection</label>
      <button id="unpin">Unpin</button>
    </div>

    <div class="row">
      <button id="stressBtn">Failure Inject</button>
      <button id="clearMem">Clear Glyph Memory</button>
    </div>

    <!-- Dyson Sphere controls -->
    <div class="dysonBox">
      <h3 style="margin:0 0 6px;">Dyson Sphere (Outer Boundary)</h3>
      <div class="row" style="margin:6px 0 0;">
        <label class="switch" title="Draw an outer boundary ring representing a Dyson sphere / capture shell.">
          <input id="dysonOn" type="checkbox" />
          Dyson Sphere
        </label>
        <label class="switch" title="If ON, Dyson also persists memory to localStorage (vault).">
          <input id="dysonPersist" type="checkbox" checked />
          Persist Memory (vault)
        </label>
      </div>

      <label>Dyson radius scale: <span id="dysonScaleVal"></span></label>
      <input id="dysonScale" type="range" min="1.10" max="3.00" step="0.01" value="2.20" />

      <label>Capture fraction (%): <span id="dysonCapVal"></span></label>
      <input id="dysonCap" type="range" min="0" max="100" step="1" value="100" />

      <label>Star luminosity (W):</label>
      <input id="dysonLum" type="number" value="3.828e26" step="1e24" style="width:180px;" />

      <div class="dyRead" id="dysonRead">
        <div><b>Captured power:</b> <span id="dysonPower">â€”</span></div>
        <div><b>Flux at shell:</b> <span id="dysonFlux">â€”</span></div>
      </div>
    </div>

    <!-- Prune + Decay controls -->
    <div class="pdBox">
      <h3 style="margin:0 0 6px;">Prune + Decay (Memory Maintenance)</h3>

      <div class="row" style="margin:6px 0 0;">
        <label class="switch" title="Decay slowly fades surplus and activation over time.">
          <input id="decayOn" type="checkbox" checked />
          Decay ON
        </label>
        <label class="switch" title="Prune removes weak memories (unlocks glyphs below threshold).">
          <input id="pruneOn" type="checkbox" checked />
          Prune ON
        </label>
      </div>

      <label>Decay rate (per tick): <span id="decayRateVal"></span></label>
      <input id="decayRate" type="range" min="0.000" max="0.060" step="0.001" value="0.018" />

      <label>Prune threshold (surplus): <span id="pruneThVal"></span></label>
      <input id="pruneTh" type="range" min="0.00" max="0.60" step="0.01" value="0.10" />

      <label>Max locked glyphs (cap): <span id="maxLockedVal"></span></label>
      <input id="maxLocked" type="range" min="50" max="700" step="10" value="320" />

      <div class="pdGrid">
        <div class="pdStat">
          <div><b>Decay mode:</b> <span id="pdDecayMode">â€”</span></div>
          <div><b>Effective decay:</b> <span id="pdDecayEff">â€”</span></div>
          <div><b>Effective prune:</b> <span id="pdPruneEff">â€”</span></div>
        </div>
        <div class="pdStat">
          <div><b>Pruned this tick:</b> <span id="pdPrunedTick">0</span></div>
          <div><b>Kept locked:</b> <span id="pdKept">0</span></div>
          <div><b>Dropped locked:</b> <span id="pdDropped">0</span></div>
        </div>
      </div>

      <div class="small" style="margin-top:8px;opacity:.88">
        <b>Meaning:</b> Dyson Sphere acts like a memory vault boundary. Decay fades memory; Prune removes weak locks.
        Dyson ON â†’ gentler decay + can persist. Dyson OFF â†’ harsher decay + no persistence.
      </div>
    </div>

    <label>Polygon sides N: <span id="nVal"></span></label>
    <input id="N" type="range" min="6" max="240" step="1" value="6" />

    <label>Intent radius a: <span id="aVal"></span></label>
    <input id="a" type="range" min="80" max="420" value="260" />

    <label>Container radius R: <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="520" value="300" />

    <label>Regulation strength k: <span id="kVal"></span></label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="1.10" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">1.10</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>
    <label style="margin-top:12px;">CST Phase Alignment Ï†â‚›â‚œ: <span id="phiBig">0.00</span></label>
    <input id="phi" type="range" min="0" max="1" step="0.01" value="0.00" />
    <div class="small" id="phiHint" style="margin-top:6px;"></div>

    <h3>Î¦-HNS Memory Controls</h3>

    <label>Collapse threshold Î¸Ï•: <span id="thetaVal"></span></label>
    <input id="theta" type="range" min="0.20" max="1.00" step="0.01" value="0.62" />

    <label>Surplus gain: <span id="gainVal"></span></label>
    <input id="gain" type="range" min="0.20" max="2.00" step="0.01" value="1.00" />

    <label>Surplus leak: <span id="leakVal"></span></label>
    <input id="leak" type="range" min="0.00" max="0.12" step="0.001" value="0.028" />

    <div class="inspector">
      <div class="title">Node Inspector</div>
      <div class="kv">
        <div><b>Selected</b></div><div class="mono" id="selId">â€”</div>
        <div><b>q,r</b></div><div class="mono" id="selQR">â€”</div>
        <div><b>v</b></div><div class="mono" id="selV">â€”</div>
        <div><b>surplus</b></div><div class="mono" id="selS">â€”</div>
        <div><b>locked</b></div><div class="mono" id="selLock">â€”</div>
        <div><b>glyph</b></div><div class="mono" id="selGlyph">â€”</div>
        <div><b>distâ†’center</b></div><div class="mono" id="selDist">â€”</div>
      </div>
      <div class="small" style="margin-top:6px;opacity:.85;">
        Tip: to create more locked glyphs faster â†’ Î¸Ï•â‰ˆ0.35, gainâ‰ˆ1.30, leakâ‰ˆ0.02. Raise Ï†â‚›â‚œ to make memory more selective.
      </div>
    </div>

    <div class="logHead">
      <h3>Step log</h3>
      <div class="row" style="margin:0;">
        <button id="dlCSV" title="Download the step log as a CSV file">Download CSV</button>
      </div>
    </div>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const $ = (id)=>document.getElementById(id);

  const NEl=$("N"), aEl=$("a"), REl=$("R"), kEl=$("k"), phiEl=$("phi");
  const thetaEl=$("theta"), gainEl=$("gain"), leakEl=$("leak");

  const nVal=$("nVal"), aVal=$("aVal"), RVal=$("RVal"), kVal=$("kVal");
  const thetaVal=$("thetaVal"), gainVal=$("gainVal"), leakVal=$("leakVal");

  const nPill=$("nPill"), modePill=$("modePill"), matchPill=$("matchPill"), statusPill=$("statusPill");
  const kBig=$("kBig"), kFill=$("kFill"), kText=$("kText");
  const phiBig=$("phiBig"), phiHint=$("phiHint");

  const constraintViewEl=$("constraintView");
  const latticeViewEl=$("latticeView");
  const latticeClipEl=$("latticeClip");
  const glyphViewEl=$("glyphView");
  const nestedHexEl=$("nestedHex");
  const spiralOnEl=$("spiralOn");

  const inspectOnEl=$("inspectOn");
  const pinSelEl=$("pinSel");
  const unpinBtn=$("unpin");

  const stressBtn=$("stressBtn");
  const clearMemBtn=$("clearMem");
  const dlCSVBtn=$("dlCSV");

  // Dyson UI
  const dysonOnEl=$("dysonOn");
  const dysonPersistEl=$("dysonPersist");
  const dysonScaleEl=$("dysonScale");
  const dysonScaleValEl=$("dysonScaleVal");
  const dysonCapEl=$("dysonCap");
  const dysonCapValEl=$("dysonCapVal");
  const dysonLumEl=$("dysonLum");
  const dysonPowerEl=$("dysonPower");
  const dysonFluxEl=$("dysonFlux");

  // Prune + Decay UI
  const decayOnEl=$("decayOn");
  const pruneOnEl=$("pruneOn");
  const decayRateEl=$("decayRate");
  const decayRateValEl=$("decayRateVal");
  const pruneThEl=$("pruneTh");
  const pruneThValEl=$("pruneThVal");
  const maxLockedEl=$("maxLocked");
  const maxLockedValEl=$("maxLockedVal");

  const pdDecayModeEl=$("pdDecayMode");
  const pdDecayEffEl=$("pdDecayEff");
  const pdPruneEffEl=$("pdPruneEff");
  const pdPrunedTickEl=$("pdPrunedTick");
  const pdKeptEl=$("pdKept");
  const pdDroppedEl=$("pdDropped");

  const selIdEl=$("selId"), selQREl=$("selQR"), selVEl=$("selV"), selSEl=$("selS"),
        selLockEl=$("selLock"), selGlyphEl=$("selGlyph"), selDistEl=$("selDist");

  const logEl=$("log");

  // ----------------- Log + CSV -----------------
  const logEntries = [];
  const nowISO = () => new Date().toISOString();
  const log=(t)=>{
    const entry = { time: nowISO(), msg: String(t) };
    logEntries.push(entry);
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  };

  // ----------------- Math helpers -----------------
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // DPR-safe canvas sizing
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function setDPR(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(DPR, DPR);
  }
  const cssW = () => canvas.width / DPR;
  const cssH = () => canvas.height / DPR;

  // ----------------- HUD (Canvas Overlay) state -----------------
  // Updated every draw() so it NEVER conflicts with other toggles.
  const HUD = {
    decayAppliedPct: 0,         // %
    prunedThisTick: 0,          // count
    vaultEvent: "â€”",            // "saved", "restored", "off", etc.
    vaultCount: 0,              // # locked saved/restored
    dysonOn: false
  };

  function drawHUDBox(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawHUD(){
    const x = 12, y = 12;
    const w = 320, h = 86;

    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(10,16,24,0.68)";
    ctx.strokeStyle = "rgba(45,71,100,0.80)";
    ctx.lineWidth = 1;
    drawHUDBox(x,y,w,h,12);
    ctx.fill(); ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(232,238,246,0.92)";
    ctx.font = "12px system-ui, Segoe UI, Arial";
    ctx.fillText("Overlay (Decay / Prune / Vault):", x+12, y+20);

    ctx.fillStyle = "rgba(232,238,246,0.85)";
    ctx.fillText(`Decay applied: ${HUD.decayAppliedPct.toFixed(1)}%`, x+12, y+40);
    ctx.fillText(`Pruned this tick: ${HUD.prunedThisTick}`, x+12, y+58);

    const dy = HUD.dysonOn ? "Dyson ON" : "Dyson OFF";
    ctx.fillText(`${dy} â€¢ Vault: ${HUD.vaultEvent} (${HUD.vaultCount})`, x+12, y+76);

    ctx.restore();
  }
  // ----------------- Geometry equations -----------------
  function circleMatchPercent(N){
    // perimeter ratio (inscribed polygon vs circle)
    const ratio = (N * Math.sin(Math.PI / N)) / Math.PI;
    return 100 * ratio;
  }

  function regulatedRadius(a,R,k){
    if(a<=R) return {rad:a, regulated:false, s:1};
    const s=Math.pow(R/a,k);
    return {rad:a*s, regulated:true, s};
  }

  function polygonVertices(cx,cy,rad,n,rot=0){
    const pts=[];
    const offset=-Math.PI/6 + rot;
    for(let i=0;i<n;i++){
      const ang=(Math.PI*2)*(i/n)+offset;
      pts.push([cx+rad*Math.cos(ang), cy+rad*Math.sin(ang)]);
    }
    return pts;
  }

  function drawPolygon(pts, fill=true){
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    if(fill) ctx.fill();
    ctx.stroke();
  }

  function strokeForK(regulated,k){
    const t=clamp((k-0.50)/2.00,0,1);
    const cool={r:69,g:103,b:132}, warm={r:182,g:139,b:46};
    const r=Math.round(cool.r*(1-t)+warm.r*t);
    const g=Math.round(cool.g*(1-t)+warm.g*t);
    const b=Math.round(cool.b*(1-t)+warm.b*t);
    const a=regulated?(0.75+0.20*t):(0.55+0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }

  function updateKUI(regulated){
    const k=+kEl.value;
    kVal.textContent = k.toFixed(2);
    kBig.textContent=k.toFixed(2);
    const pct=clamp(((k-0.50)/2.00)*100,0,100);
    kFill.style.width=pct.toFixed(1)+"%";
    let label="Soft clamp.";
    if(k>=1.00 && k<1.50) label="Balanced clamp.";
    if(k>=1.50 && k<2.10) label="Strong clamp.";
    if(k>=2.10) label="Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent=label;
  }

  function updatePills(regulated,N,matchPct){
    nPill.textContent=`N: ${N}`;
    modePill.textContent=`Mode: ${regulated?"Regulation":"Geometry"}`;
    modePill.style.borderColor=regulated?"#b68b2e":"#2d4764";
    modePill.style.background=regulated?"#221a0a":"#0c131d";
    matchPill.textContent=`Match: ${matchPct.toFixed(1)}%`;
  }

  // ----------------- Constraint View (labels lines on circle) -----------------
  // This draws a 6-node constraint ring *and labels each edge line*.
  const pillars=[
    { key:"Maxwell", short:"M" },
    { key:"Einstein", short:"E" },
    { key:"Feynman", short:"F" },
    { key:"Turing", short:"T" },
    { key:"vonNeumann", short:"V" },
    { key:"Shannon", short:"S" },
  ];
  const edgeLabels=["Mâ€“E","Eâ€“F","Fâ€“T","Tâ€“V","Vâ€“S","Sâ€“M"];
  const order=["Maxwell","Einstein","Feynman","Turing","vonNeumann","Shannon"];

  function roundRect(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawLegendBox(x,y){
    ctx.save();
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(10,16,24,0.68)";
    ctx.strokeStyle="rgba(45,71,100,0.70)";
    ctx.lineWidth=1;
    const w=260, h=112;
    roundRect(x,y,w,h,10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(232,238,246,0.90)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.fillText("Constraint Lines (labeled):", x+10, y+18);

    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText("Edges show coupling links:", x+10, y+36);
    ctx.fillText("Mâ€“Eâ€“Fâ€“Tâ€“Vâ€“Sâ€“M", x+10, y+52);

    ctx.fillStyle="rgba(232,238,246,0.86)";
    ctx.fillText("M Maxwell   E Einstein   F Feynman", x+10, y+72);
    ctx.fillText("T Turing     V vonN       S Shannon", x+10, y+90);

    ctx.restore();
  }

  function stressColor(s){
    if(s<0.5){
      const t=s/0.5;
      const r=Math.round(lerp(42,214,t));
      const g=Math.round(lerp(163,166,t));
      const b=Math.round(lerp(74,58,t));
      return `rgb(${r},${g},${b})`;
    }else{
      const t=(s-0.5)/0.5;
      const r=Math.round(lerp(214,208,t));
      const g=Math.round(lerp(166,74,t));
      const b=Math.round(lerp(58,74,t));
      return `rgb(${r},${g},${b})`;
    }
  }

  let stressInject=false;
  let t0=performance.now();

  function computeStresses({N,a,R,k,phi,regulated}){
    const match = clamp(circleMatchPercent(N)/100,0,1);
    const coarseness = clamp(1-match,0,1);

    const overflow = clamp((a-R)/Math.max(1,R),0,1);
    const kPressure = clamp(Math.abs(k-1.0)/1.5,0,1);
    const clampActive = regulated ? 1 : 0;

    const deco = (1-phi);
    const damp = lerp(1.0,0.55,phi);

    let inj=0;
    if(stressInject){
      const tt=(performance.now()-t0)/1000;
      inj=0.5+0.5*Math.sin(tt*2.3);
    }

    const base={
      Maxwell:    0.12 + 0.55*overflow + 0.22*coarseness + 0.12*inj,
      Einstein:   0.14 + 0.60*overflow + 0.30*deco      + 0.06*clampActive + 0.10*inj,
      Shannon:    0.12 + 0.55*coarseness + 0.40*deco    + 0.08*overflow + 0.08*inj,
      vonNeumann: 0.14 + 0.55*kPressure + 0.20*deco     + 0.08*clampActive + 0.08*inj,
      Turing:     0.14 + 0.50*kPressure + 0.35*coarseness + 0.10*inj,
      Feynman:    0.14 + 0.45*coarseness + 0.55*deco    + 0.10*overflow + 0.10*inj,
    };

    // small neighbor coupling around ring (no conflicts with toggles)
    let s=order.map(k=>base[k]);
    const c=lerp(0.22,0.12,phi);
    for(let it=0;it<2;it++){
      const next=s.slice();
      for(let i=0;i<s.length;i++){
        const L=s[(i-1+s.length)%s.length];
        const Rr=s[(i+1)%s.length];
        const coupled=(s[i]+c*(L+Rr))/(1+2*c);
        next[i]=clamp(coupled*damp,0,1);
      }
      s=next;
    }
    const out={};
    for(let i=0;i<order.length;i++) out[order[i]]=s[i];
    return {out,coarseness,overflow,deco,match};
  }

  function drawConstraintOverlay(cx,cy,R,rr,stressPack){
    const rad=Math.min(rr.rad,R*0.78);
    const pts=polygonVertices(cx,cy,rad,6);

    // Legend inside the canvas (also answers your â€œwhat are the lines?â€ request)
    drawLegendBox(12, 108);

    // Draw ring polygon edges
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.strokeStyle="rgba(120,150,180,0.35)";
    ctx.lineWidth=1.4;
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    // Label each EDGE midpoint (line labels)
    ctx.save();
    ctx.globalAlpha=0.86;
    ctx.fillStyle="rgba(232,238,246,0.76)";
    ctx.font="12px system-ui, Segoe UI, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    for(let i=0;i<6;i++){
      const a=pts[i];
      const b=pts[(i+1)%6];
      const mx=(a[0]+b[0])*0.5;
      const my=(a[1]+b[1])*0.5;
      const dx=mx-cx, dy=my-cy;
      const d=Math.max(1,Math.hypot(dx,dy));
      const ox=mx+(dx/d)*16;
      const oy=my+(dy/d)*16;
      ctx.fillText(edgeLabels[i], ox, oy);
    }
    ctx.restore();

    // Nodes with labels + live values
    for(let i=0;i<6;i++){
      const key=order[i];
      const s=stressPack.out[key];
      const [x,y]=pts[i];
      const col=stressColor(s);

      ctx.fillStyle=col;
      ctx.strokeStyle="rgba(255,255,255,0.22)";
      ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(x,y,16,0,Math.PI*2); ctx.fill(); ctx.stroke();

      ctx.fillStyle="#071019";
      ctx.font="900 13px system-ui, Segoe UI, Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(pillars[i].short,x,y);

      const dx = x - cx, dy = y - cy;
      const d = Math.max(1, Math.hypot(dx,dy));
      const ox = x + (dx/d)*30;
      const oy = y + (dy/d)*30;

      ctx.fillStyle="rgba(232,238,246,0.88)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.textAlign = (dx>=0) ? "left" : "right";
      const name = key === "vonNeumann" ? "vonN" : key;
      ctx.fillText(`${name}: ${s.toFixed(2)}`, ox, oy);
    }
    ctx.textAlign="left"; ctx.textBaseline="alphabetic";
  }

  // ----------------- Dyson helpers -----------------
  function fmtSI(x){
    if(!isFinite(x)) return "â€”";
    const ax=Math.abs(x);
    if(ax>=1e24) return (x/1e24).toFixed(3)+"e24";
    if(ax>=1e18) return (x/1e18).toFixed(3)+"e18";
    if(ax>=1e12) return (x/1e12).toFixed(3)+"e12";
    if(ax>=1e9)  return (x/1e9 ).toFixed(3)+"e9";
    if(ax>=1e6)  return (x/1e6 ).toFixed(3)+"e6";
    if(ax>=1e3)  return (x/1e3 ).toFixed(3)+"e3";
    return x.toFixed(3);
  }

  function updateDysonUI(){
    dysonScaleValEl.textContent = (+dysonScaleEl.value).toFixed(2) + "Ã—R";
    dysonCapValEl.textContent = (+dysonCapEl.value).toFixed(0);

    const cap = (+dysonCapEl.value)/100;
    const L = Number(dysonLumEl.value);
    const captured = L * cap;

    const rRel = +dysonScaleEl.value;
    const areaRel = 4*Math.PI*rRel*rRel;
    const fluxRel = L / areaRel;

    dysonPowerEl.textContent = fmtSI(captured) + " W";
    dysonFluxEl.textContent  = fmtSI(fluxRel) + " W / (4Ï€ (RÂ·scale)^2)";
  }

  function drawDysonSphere(cx,cy,R){
    if(!dysonOnEl.checked) return;

    const scale = +dysonScaleEl.value;
    const dyR = R * scale;

    ctx.save();
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(cx,cy,dyR,0,Math.PI*2);
    ctx.lineWidth = Math.max(2, R*0.022);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dysonRing') || "rgba(255,200,60,.62)";
    ctx.stroke();

    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(cx,cy,dyR + ctx.lineWidth*2.1,0,Math.PI*2);
    ctx.lineWidth = ctx.lineWidth*2.2;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dysonRing2') || "rgba(255,200,60,.18)";
    ctx.stroke();

    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 1.3;
    ctx.strokeStyle = "rgba(255,225,140,0.35)";
    const ticks=24;
    for(let i=0;i<ticks;i++){
      const a = (i/ticks)*Math.PI*2;
      const x1 = cx + (dyR-8)*Math.cos(a);
      const y1 = cy + (dyR-8)*Math.sin(a);
      const x2 = cx + (dyR+8)*Math.cos(a);
      const y2 = cy + (dyR+8)*Math.sin(a);
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ----------------- Prune + Decay (Dyson coupling) -----------------
  function effectiveDecayRate(){
    const base = +decayRateEl.value;
    const mult = dysonOnEl.checked ? 0.70 : 1.35;
    return clamp(base * mult, 0, 0.20);
  }
  function effectivePruneThreshold(){
    const base = +pruneThEl.value;
    const adj = dysonOnEl.checked ? -0.02 : +0.03;
    return clamp(base + adj, 0, 0.95);
  }

  function updatePruneDecayUI(stats){
    decayRateValEl.textContent = (+decayRateEl.value).toFixed(3);
    pruneThValEl.textContent = (+pruneThEl.value).toFixed(2);
    maxLockedValEl.textContent = String(parseInt(maxLockedEl.value,10));

    pdDecayModeEl.textContent = dysonOnEl.checked ? "Dyson ON (vault boundary)" : "Dyson OFF (leaky boundary)";
    pdDecayEffEl.textContent = effectiveDecayRate().toFixed(3) + " / tick";
    pdPruneEffEl.textContent = effectivePruneThreshold().toFixed(2) + " surplus";

    if(stats){
      pdPrunedTickEl.textContent = String(stats.prunedThisTick);
      pdKeptEl.textContent = String(stats.keptLocked);
      pdDroppedEl.textContent = String(stats.droppedLocked);
    }
  }
  // ----------------- Vault persistence -----------------
  const VAULT_KEY = "HEXARA_DYSON_VAULT_V2";

  function vaultEnabled(){
    return dysonOnEl.checked && dysonPersistEl.checked;
  }

  function saveVaultPayload(){
    const locked = lattice.nodes.filter(n=>n.locked).map(n=>({
      q:n.q, r:n.r,
      surplus:+n.surplus.toFixed(4),
      glyphIdx:n.glyphIdx
    }));
    return { ts: Date.now(), size: HEX.size, locked };
  }

  function saveVaultIfEnabled(){
    if(!vaultEnabled()) { HUD.vaultEvent="off"; HUD.vaultCount=0; return; }
    try{
      const payload = saveVaultPayload();
      localStorage.setItem(VAULT_KEY, JSON.stringify(payload));
      HUD.vaultEvent="saved";
      HUD.vaultCount = payload.locked.length;
    }catch(e){
      HUD.vaultEvent="save fail";
      HUD.vaultCount=0;
    }
  }

  function loadVaultIfEnabled(){
    if(!vaultEnabled()) { HUD.vaultEvent="off"; HUD.vaultCount=0; return 0; }
    try{
      const raw = localStorage.getItem(VAULT_KEY);
      if(!raw){ HUD.vaultEvent="empty"; HUD.vaultCount=0; return 0; }
      const payload = JSON.parse(raw);
      if(!payload || !Array.isArray(payload.locked)) { HUD.vaultEvent="bad"; HUD.vaultCount=0; return 0; }

      let applied=0;
      for(const item of payload.locked){
        const idx = lattice.map.get(item.q + "," + item.r);
        if(idx===undefined) continue;
        const n = lattice.nodes[idx];
        n.locked = true;
        n.surplus = clamp(item.surplus ?? 0.2, 0, 1.25);
        n.glyphIdx = (item.glyphIdx ?? 0);
        n.glyph = GLYPHS[n.glyphIdx] || "";
        applied++;
      }
      HUD.vaultEvent="restored";
      HUD.vaultCount=applied;
      if(applied>0){
        log(`DYSON VAULT: restored ${applied} locked glyphs.`);
        log("â€”");
      }
      return applied;
    }catch(e){
      HUD.vaultEvent="restore fail";
      HUD.vaultCount=0;
      return 0;
    }
  }

  // ----------------- Hex lattice + Î¦-HNS memory -----------------
  const HEX={ size:14, dirs:[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]] };
  const GLYPHS=["ð’®","ð’ž","à¸€","ð’¦","Ï•","âŸ¡","âŠ•","âˆ¿","âˆž","â—‡","â–£","âœ¶"];
  const FALLBACKS=["S","C","H","K","Ï†","*","+","~","âˆž","â—‡","â–£","*"];

  let lattice={ nodes:[], map:new Map(), builtFor:{w:0,h:0,R:0,size:HEX.size} };
  let selected={ idx:-1, pinned:false };
  let lastCenter={ cx:0, cy:0, R:0 };

  const keyQR=(q,r)=>q+","+r;
  function axialToPixel(q,r,size){
    const x=size*Math.sqrt(3)*(q+r/2);
    const y=size*1.5*r;
    return [x,y];
  }

  function buildHexLattice(cx,cy,R){
    const size=clamp(Math.round(R/22),10,16);
    HEX.size=size;
    lattice.nodes=[];
    lattice.map=new Map();
    lattice.builtFor={ w:cssW(), h:cssH(), R, size };

    const max=Math.ceil(R/(size*1.15));
    for(let r=-max;r<=max;r++){
      for(let q=-max;q<=max;q++){
        const [dx,dy]=axialToPixel(q,r,size);
        const d=Math.hypot(dx,dy);
        if(d<=R-size*0.3){
          const idx=lattice.nodes.length;
          lattice.map.set(keyQR(q,r),idx);
          lattice.nodes.push({
            q,r, x:cx+dx, y:cy+dy,
            v:0,v2:0,
            surplus:0,s2:0,
            locked:false, glyph:"", glyphIdx:-1,
            nei:[]
          });
        }
      }
    }
    for(const n of lattice.nodes){
      n.nei.length=0;
      for(const [dq,dr] of HEX.dirs){
        const j=lattice.map.get(keyQR(n.q+dq,n.r+dr));
        if(j!==undefined) n.nei.push(j);
      }
    }

    // Restore vault ONLY after building map/nodes
    loadVaultIfEnabled();

    log(`LATTICE: built ${lattice.nodes.length} nodes (hex size=${size}px).`);
    log("â€”");
  }

  function ensureLatticeBuilt(cx,cy,R,force=false){
    const bf=lattice.builtFor;
    const changed = force || !lattice.nodes.length ||
      Math.abs(bf.R-R)>0.5 ||
      Math.abs(bf.w-cssW())>0.5 ||
      Math.abs(bf.h-cssH())>0.5;
    if(changed) buildHexLattice(cx,cy,R);
  }

  function clearLatticeMemory(){
    for(const n of lattice.nodes){
      n.v = 0; n.v2 = 0;
      n.surplus=0; n.s2=0;
      n.locked=false; n.glyph=""; n.glyphIdx=-1;
    }
    try{ localStorage.removeItem(VAULT_KEY); }catch(e){}
    HUD.vaultEvent="cleared";
    HUD.vaultCount=0;
  }

  function injectSourcesToLattice(pillarPts, pillarStress, phi){
    const influence=clamp(lattice.builtFor.R*0.40,120,260);
    const inv2=1/(influence*influence);
    const injScale=lerp(1.00,0.70,phi);

    for(const node of lattice.nodes){
      let s=0,wsum=0;
      for(let i=0;i<pillarPts.length;i++){
        const [px,py]=pillarPts[i];
        const dx=node.x-px, dy=node.y-py;
        const w=Math.exp(-(dx*dx+dy*dy)*inv2);
        wsum+=w; s+=w*pillarStress[i];
      }
      const src=wsum>0?(s/wsum):0;
      const blend=node.locked?0.08:0.18;
      node.v=clamp(lerp(node.v, src*injScale, blend),0,1);
    }
  }

  function injectFailure(phi){
    if(!stressInject || !lattice.nodes.length) return;
    const R=lattice.builtFor.R;
    const cx=cssW()/2, cy=cssH()/2;
    const targetX=cx+R*0.35, targetY=cy-R*0.20;

    let best=-1, bestD=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-targetX, dy=n.y-targetY;
      const d2=dx*dx+dy*dy;
      if(d2<bestD){bestD=d2; best=i;}
    }
    if(best<0) return;

    const tt=(performance.now()-t0)/1000;
    const osc=0.5+0.5*Math.sin(tt*3.2);
    const amp=lerp(0.35,0.18,phi);
    lattice.nodes[best].v=clamp(lattice.nodes[best].v+osc*amp,0,1);
  }

  function propagateLatticeAndMemory(phi){
    const coupling=lerp(0.28,0.12,phi);
    const damping=lerp(0.985,0.92,phi);

    const thetaBase=+thetaEl.value;
    const gain=+gainEl.value;
    const leak=+leakEl.value;

    const thetaEff=clamp(thetaBase+0.08*phi,0.20,1.00);
    const gainEff=gain*lerp(1.0,0.78,phi);
    const leakEff=leak*lerp(1.0,0.75,phi);

    for(let step=0; step<2; step++){
      for(const n of lattice.nodes){
        let avg=0;
        const m=n.nei.length||1;
        for(const j of n.nei) avg+=lattice.nodes[j].v;
        avg/=m;
        const stiff=n.locked?0.65:1.0;
        const mixed=n.v+(coupling*stiff)*(avg-n.v);
        n.v2=clamp(mixed*damping,0,1);
      }
      for(const n of lattice.nodes) n.v=n.v2;

      for(const n of lattice.nodes){
        const lockFactor=n.locked?0.22:1.0;
        const add=n.v*0.030*gainEff*lockFactor;
        const dec=n.surplus*leakEff;
        n.s2=clamp(n.surplus+add-dec,0,1.25);
      }

      for(const n of lattice.nodes){
        n.surplus=n.s2;
        if(!n.locked && n.surplus>=thetaEff){
          n.locked=true;
          const idx=Math.abs((n.q*31+n.r*17)%GLYPHS.length);
          n.glyphIdx=idx;
          n.glyph=GLYPHS[idx]||"";
        }
      }
    }
    return {thetaEff, gainEff};
  }

  function applyDecayAndPrune(){
    if(!lattice.nodes.length) return {prunedThisTick:0, keptLocked:0, droppedLocked:0, decayPct:0};

    const dOn = decayOnEl.checked;
    const pOn = pruneOnEl.checked;
    const dEff = effectiveDecayRate();
    const pruneTh = effectivePruneThreshold();
    const maxLocked = parseInt(maxLockedEl.value,10);

    // decayPct in human-readable form (approx)
    const decayPct = dOn ? clamp(dEff*100, 0, 100) : 0;

    if(dOn){
      for(const n of lattice.nodes){
        const lockSlow = n.locked ? 0.55 : 1.0;
        n.surplus = clamp(n.surplus * (1 - dEff*lockSlow), 0, 1.25);
        n.v = clamp(n.v * (1 - (dEff*0.45)), 0, 1);
      }
    }

    let pruned=0;
    if(pOn){
      for(const n of lattice.nodes){
        if(n.locked && n.surplus < pruneTh){
          n.locked=false;
          n.glyph="";
          n.glyphIdx=-1;
          pruned++;
        }
      }
    }

    let dropped=0;
    let lockedList = lattice.nodes.map((n,i)=>({n,i})).filter(o=>o.n.locked);
    if(pOn && lockedList.length > maxLocked){
      lockedList.sort((a,b)=>a.n.surplus - b.n.surplus);
      const toDrop = lockedList.length - maxLocked;
      for(let i=0;i<toDrop;i++){
        const nn = lockedList[i].n;
        nn.locked=false; nn.glyph=""; nn.glyphIdx=-1;
        dropped++;
      }
    }

    const kept = lattice.nodes.reduce((acc,n)=>acc+(n.locked?1:0),0);
    return {prunedThisTick: pruned + dropped, keptLocked: kept, droppedLocked: dropped, decayPct};
  }

  function drawLattice(){
    const showGlyphs=glyphViewEl.checked;

    if(latticeClipEl.checked){
      const cx=lastCenter.cx, cy=lastCenter.cy, R=lastCenter.R;
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx,cy,R-1,0,Math.PI*2);
      ctx.clip();
    } else {
      ctx.save();
    }

    ctx.globalAlpha=0.95;

    for(const n of lattice.nodes){
      const s=n.v;
      const mem=clamp(n.surplus,0,1);
      const hot=Math.max(s, mem*0.85);
      if(hot<0.02 && !n.locked) continue;

      ctx.fillStyle=stressColor(clamp(hot,0,1));
      const r=(n.locked?2.3:1.4)+2.0*hot;
      ctx.beginPath();
      ctx.arc(n.x,n.y,r,0,Math.PI*2);
      ctx.fill();

      if(n.locked){
        ctx.strokeStyle="rgba(232,238,246,0.40)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.arc(n.x,n.y,r+1.6,0,Math.PI*2);
        ctx.stroke();
      }
    }

    if(showGlyphs){
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font="900 11px system-ui, Segoe UI, Arial";
      let drawn=0;
      const MAX=320;
      for(const n of lattice.nodes){
        if(!n.locked) continue;
        if(drawn++>MAX) break;
        const g=n.glyph || FALLBACKS[(n.glyphIdx>=0?n.glyphIdx:0)%FALLBACKS.length];
        ctx.fillStyle="rgba(7,16,25,0.90)";
        ctx.fillText(g,n.x,n.y);
      }
    }

    ctx.restore();
  }

  function drawNestedHexes(cx,cy,R){
    if(!nestedHexEl.checked) return;
    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.lineWidth=1.2;
    const rings=6;
    for(let i=1;i<=rings;i++){
      const t=i/(rings+1);
      const rad=R*(0.18 + 0.78*t);
      const rot = (i%2===0) ? 0 : (Math.PI/12);
      const pts=polygonVertices(cx,cy,rad,6,rot);
      ctx.strokeStyle = (i===rings) ? "rgba(232,238,246,0.28)" : "rgba(120,150,180,0.22)";
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let k=1;k<pts.length;k++) ctx.lineTo(pts[k][0],pts[k][1]);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }

  // Inspector
  function setInspector(idx){
    if(idx<0 || !lattice.nodes[idx]){
      selIdEl.textContent="â€”"; selQREl.textContent="â€”"; selVEl.textContent="â€”";
      selSEl.textContent="â€”"; selLockEl.textContent="â€”"; selGlyphEl.textContent="â€”"; selDistEl.textContent="â€”";
      return;
    }
    const n=lattice.nodes[idx];
    selIdEl.textContent=String(idx);
    selQREl.textContent=`${n.q}, ${n.r}`;
    selVEl.textContent=n.v.toFixed(3);
    selSEl.textContent=n.surplus.toFixed(3);
    selLockEl.textContent=n.locked?"true":"false";
    const g = n.glyph || (n.glyphIdx>=0 ? FALLBACKS[n.glyphIdx%FALLBACKS.length] : "");
    selGlyphEl.textContent=n.locked?g:"â€”";
    const dx=n.x-lastCenter.cx, dy=n.y-lastCenter.cy;
    selDistEl.textContent=Math.hypot(dx,dy).toFixed(1);
  }

  // Click-to-inspect (safe even if toggles change)
  canvas.addEventListener("click",(ev)=>{
    if(!inspectOnEl.checked) return;
    if(!latticeViewEl.checked) return;
    const rect=canvas.getBoundingClientRect();
    const px=ev.clientX-rect.left;
    const py=ev.clientY-rect.top;

    const cx=lastCenter.cx, cy=lastCenter.cy, R=lastCenter.R;
    const dc = Math.hypot(px-cx, py-cy);
    if(dc > R+6) return;

    // nearest node
    let best=-1, bestD2=1e18;
    for(let i=0;i<lattice.nodes.length;i++){
      const n=lattice.nodes[i];
      const dx=n.x-px, dy=n.y-py;
      const d2=dx*dx+dy*dy;
      if(d2<bestD2){bestD2=d2; best=i;}
    }
    if(best<0) return;

    selected.idx=best;
    selected.pinned = pinSelEl.checked;
    setInspector(best);

    const n=lattice.nodes[best];
    log(`INSPECT: idx=${best} q,r=(${n.q},${n.r}) v=${n.v.toFixed(3)} s=${n.surplus.toFixed(3)} locked=${n.locked} glyph=${n.glyph||""}`);
    log("â€”");
    draw(false);
  });

  unpinBtn.addEventListener("click",()=>{
    selected.pinned=false;
    pinSelEl.checked=false;
    log("Inspector: unpinned.");
    log("â€”");
    draw(false);
  });

  // Failure inject
  function updateStressBtn(){ stressBtn.textContent = stressInject ? "Failure Inject: ON" : "Failure Inject"; }
  updateStressBtn();
  stressBtn.onclick=()=>{
    stressInject=!stressInject;
    updateStressBtn();
    log(`Failure Inject: ${stressInject?"ON":"OFF"}`);
    log("â€”");
    draw(true);
  };

  // Clear memory
  clearMemBtn.onclick=()=>{
    if(!latticeViewEl.checked){
      log("Clear requested but lattice is OFF. Turn Hex Lattice ON.");
      log("â€”");
      return;
    }
    if(!lattice.nodes.length){
      log("Clear requested but lattice not built yet.");
      log("â€”");
      return;
    }
    clearLatticeMemory();
    if(!selected.pinned){
      selected.idx=-1;
      setInspector(-1);
    }
    log("Memory cleared (v + surplus + glyph locks reset).");
    log("â€”");
    draw(false);
  };

  // CSV
  dlCSVBtn.onclick=()=>{
    const header = ["time","message"];
    const rows = logEntries.map(e=>{
      const msg = String(e.msg).replaceAll('"','""');
      return `"${e.time}","${msg}"`;
    });
    const csv = header.join(",") + "\n" + rows.join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "hexara_step_log.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    log("CSV: downloaded hexara_step_log.csv");
    log("â€”");
  };

  // Step controls
  function setN(v){ NEl.value=String(clamp(v,6,240)); draw(false); }
  $("step").onclick=()=>{
    const N=parseInt(NEl.value,10);
    setN(N+1);
    log(`STEP: N=${N+1} matchâ‰ˆ${circleMatchPercent(N+1).toFixed(2)}%`);
    log("â€”");
  };
  $("step5").onclick=()=>{
    const N=parseInt(NEl.value,10);
    setN(N+5);
    log(`STEP: N=${N+5} matchâ‰ˆ${circleMatchPercent(N+5).toFixed(2)}%`);
    log("â€”");
  };
  $("reset").onclick=()=>{
    NEl.value="6";
    aEl.value="260";
    REl.value="300";
    kEl.value="1.10";
    phiEl.value="0.00";
    thetaEl.value="0.62";
    gainEl.value="1.00";
    leakEl.value="0.028";

    dysonOnEl.checked=false;

    selected.idx=-1;
    selected.pinned=false;
    pinSelEl.checked=false;
    setInspector(-1);

    logEl.textContent="";
    logEntries.length=0;

    log("RESET: N=6. (All toggles safe / redraw correctly.)");
    log("â€”");
    draw(true);
  };
  $("auto").onclick=()=>{
    let N=parseInt(NEl.value,10);
    for(let it=0;it<400;it++){
      if(circleMatchPercent(N)>=99.6) break;
      N++; if(N>=240) break;
    }
    setN(N);
    log(`AUTO: Nâ†’${N} matchâ‰ˆ${circleMatchPercent(N).toFixed(2)}%`);
    log("â€”");
  };

  // ----------------- Main draw -----------------
  function draw(forceRebuild=false){
    const N=parseInt(NEl.value,10);
    const a=+aEl.value;
    const R=+REl.value;
    const k=+kEl.value;
    const phi=+phiEl.value;

    nVal.textContent=N;
    aVal.textContent=a.toFixed(0);
    RVal.textContent=R.toFixed(0);
    kVal.textContent=k.toFixed(2);
    phiBig.textContent=phi.toFixed(2);

    thetaVal.textContent=(+thetaEl.value).toFixed(2);
    gainVal.textContent=(+gainEl.value).toFixed(2);
    leakVal.textContent=(+leakEl.value).toFixed(3);

    if(phi<0.20) phiHint.textContent="Ï†â‚›â‚œ low: strong coupling â†’ wider spread + more collapse.";
    else if(phi<0.60) phiHint.textContent="Ï†â‚›â‚œ moderate: partial phase-locking reduces spread + collapse density.";
    else phiHint.textContent="Ï†â‚›â‚œ high: strong damping â†’ more selective memory.";

    updateDysonUI();

    const w=cssW(), h=cssH();
    ctx.clearRect(0,0,w,h);

    const cx=w/2, cy=h/2;
    lastCenter={cx,cy,R};

    // Dyson
    drawDysonSphere(cx,cy,R);

    // Domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

    // nested frames
    drawNestedHexes(cx,cy,R);

    const rr=regulatedRadius(a,R,k);
    updateKUI(rr.regulated);

    const matchPct=circleMatchPercent(N);
    updatePills(rr.regulated,N,matchPct);

    // main N-gon
    const poly=polygonVertices(cx,cy,rr.rad,N);
    ctx.fillStyle=rr.regulated?"#0f2236":"#0d1a2a";
    ctx.strokeStyle=strokeForK(rr.regulated,k);
    ctx.lineWidth=2;
    drawPolygon(poly,true);

    // mirror circle
    ctx.globalAlpha=0.45;
    ctx.strokeStyle="rgba(232,238,246,0.35)";
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(cx,cy,rr.rad,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;

    // compute stress pack only if needed
    const needLattice = latticeViewEl.checked;
    const needConstraint = constraintViewEl.checked;
    let stressPack = null;
    if(needLattice || needConstraint){
      stressPack = computeStresses({N,a,R,k,phi,regulated:rr.regulated});
    }

    // lattice pipeline
    if(needLattice && stressPack){
      ensureLatticeBuilt(cx,cy,R,forceRebuild);

      // pillar sources
      const rad=Math.min(rr.rad,R*0.78);
      const pillarPts=polygonVertices(cx,cy,rad,6);
      const pillarStress=order.map(k=>stressPack.out[k]??0);

      injectSourcesToLattice(pillarPts,pillarStress,phi);
      injectFailure(phi);

      // core propagation
      const eff=propagateLatticeAndMemory(phi);

      // prune/decay after propagation
      const pdStats = applyDecayAndPrune();
      updatePruneDecayUI(pdStats);

      // update HUD values (no conflicts; read-only display)
      HUD.dysonOn = dysonOnEl.checked;
      HUD.decayAppliedPct = pdStats.decayPct;
      HUD.prunedThisTick = pdStats.prunedThisTick;

      drawLattice();

      const lockedCount=lattice.nodes.reduce((acc,n)=>acc+(n.locked?1:0),0);
      statusPill.textContent=`Status: nodes=${lattice.nodes.length} locked=${lockedCount}`;

      if(selected.idx>=0) setInspector(selected.idx);

      // persist (updates HUD vault fields)
      saveVaultIfEnabled();

      // info line
      ctx.fillStyle="rgba(232,238,246,0.78)";
      ctx.font="12px system-ui, Segoe UI, Arial";
      ctx.fillText(
        `Hex Lattice: locked=${lockedCount}  Î¸Ï•â‰ˆ${eff.thetaEff.toFixed(2)}  gainâ‰ˆ${eff.gainEff.toFixed(2)}  leak=${(+leakEl.value).toFixed(3)}  Ï†â‚›â‚œ=${phi.toFixed(2)}`,
        14, 92
      );
    } else {
      statusPill.textContent="Status: lattice OFF";
      updatePruneDecayUI({prunedThisTick:0, keptLocked:0, droppedLocked:0});
      HUD.dysonOn = dysonOnEl.checked;
      HUD.decayAppliedPct = decayOnEl.checked ? effectiveDecayRate()*100 : 0;
      HUD.prunedThisTick = 0;
      HUD.vaultEvent = vaultEnabled() ? "idle" : "off";
      HUD.vaultCount = 0;
      if(!selected.pinned){
        selected.idx=-1;
        setInspector(-1);
      }
    }

    // constraint overlay (labeled edge lines) â€” independent, no conflicts
    if(needConstraint && stressPack){
      drawConstraintOverlay(cx,cy,R,rr,stressPack);
    }

    // diagnostics
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const geomMsg = rr.regulated
      ? `Clamp ACTIVE: a=${a.toFixed(0)} > R=${R.toFixed(0)} â†’ s=(R/a)^k=${rr.s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No clamp: a=${a.toFixed(0)} â‰¤ R=${R.toFixed(0)} (k=${k.toFixed(2)})`;
    ctx.fillText(geomMsg, 14, 18);
    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText(`Boundary refinement: N=${N}, circle-match â‰ˆ ${matchPct.toFixed(1)}%`, 14, 36);

    // FINAL: draw HUD LAST so itâ€™s always visible
    drawHUD();
  }

  // ----------------- Ensure ALL toggles redraw correctly -----------------
  const inputsToRedraw = [
    NEl,aEl,REl,kEl,phiEl,thetaEl,gainEl,leakEl,
    dysonScaleEl,dysonCapEl,dysonLumEl,
    decayRateEl,pruneThEl,maxLockedEl
  ];
  inputsToRedraw.forEach(el => el.addEventListener("input", ()=>draw(false)));

  const togglesToRedraw = [
    constraintViewEl,latticeViewEl,latticeClipEl,glyphViewEl,
    nestedHexEl,spiralOnEl,inspectOnEl,pinSelEl,
    dysonOnEl,dysonPersistEl,decayOnEl,pruneOnEl
  ];
  togglesToRedraw.forEach(el => el.addEventListener("change", ()=>draw(true)));

  // Dyson toggle also updates HUD text immediately
  dysonOnEl.addEventListener("change", ()=>{ HUD.dysonOn = dysonOnEl.checked; draw(true); });
  dysonPersistEl.addEventListener("change", ()=>draw(true));

  // resize
  function resize(){ setDPR(); draw(true); }
  window.addEventListener("resize", resize);

  // animation loop
  function tick(){
    const animate = latticeViewEl.checked || stressInject;
    if(animate) draw(false);
    requestAnimationFrame(tick);
  }

  // init
  log("INIT: Added Canvas HUD overlay (Decay %, Pruned, Vault saved/restored).");
  log("CHECK: Constraint View labels edge-lines (Mâ€“E, Eâ€“F, ...).");
  log("CHECK: Toggles are independent and trigger redraw; no math equation conflicts.");
  log("â€”");

  resize();
  draw(true);
  tick();
})();
</script>
</body>
</html>
