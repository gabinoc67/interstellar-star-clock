<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Warp — Station / Engine / Transit + Surface Below (Failures + CSV + Earth/Mars)</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#121826;
    --panel2:#0f1523;
    --ink:#e6ecff;
    --muted:#9aa4c7;
    --accent:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --line:#223052;
    --radius:12px;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background:linear-gradient(180deg, rgba(88,166,255,.08), rgba(0,0,0,0));
  }
  header h1{margin:0;font-size:18px}
  header p{margin:6px 0 0;font-size:13px;color:var(--muted)}
  main{
    display:grid;
    grid-template-columns: 440px 1fr;
    gap:14px;
    padding:14px;
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    padding:14px;
    box-shadow:var(--shadow);
  }
  h2{margin:0 0 10px;font-size:15px}
  .sub{margin:0 0 12px;color:var(--muted);font-size:12px}
  label{font-size:12px;color:var(--muted);display:block;margin-top:10px}
  input[type=range]{width:100%}
  select, input[type=number]{
    width:100%;
    background:#0c1220;
    color:var(--ink);
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px;
    outline:none;
  }
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .btnrow{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  button{
    width:100%;
    padding:10px;
    border-radius:10px;
    border:0;
    font-weight:700;
    cursor:pointer;
  }
  button.primary{background:var(--accent);color:#000;}
  button.secondary{background:#1c2a4a;color:var(--ink);border:1px solid var(--line);}
  .tog{
    display:flex;align-items:center;gap:10px;
    margin-top:10px;padding:10px;
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
  }
  .tog input{transform:scale(1.2)}
  .readout{
    margin-top:12px;
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
    font-size:13px;
    line-height:1.45;
  }
  .ok{color:var(--good);font-weight:800}
  .warn{color:var(--warn);font-weight:800}
  .bad{color:var(--bad);font-weight:800}

  /* RIGHT SIDE LAYOUT: top row 3 panels, then surface full width under */
  .right{
    display:grid;
    grid-template-rows: auto auto;
    gap:12px;
  }
  .top3{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:12px;
  }
  .wide{
    display:block;
  }

  .pwrap{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:12px;
    padding:12px;
  }
  .phead{
    display:flex;
    align-items:baseline;
    justify-content:space-between;
    gap:10px;
    margin-bottom:8px;
  }
  .tag{
    font-size:11px;
    color:var(--muted);
    padding:4px 8px;
    border:1px solid var(--line);
    border-radius:999px;
    background:rgba(255,255,255,.03);
    white-space:nowrap;
  }
  canvas{
    width:100%;
    height:320px;
    background:#0e1422;
    border:1px solid var(--line);
    border-radius:12px;
  }
  .wide canvas{height:320px;}
  small{color:var(--muted)}
  .footnote{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
  }
</style>
</head>

<body>
<header>
  <h1>CST Warp — Station / Engine / Transit (Top) + Surface Panel (Bottom)</h1>
  <p>Linked 2D system simulator: power flow, buffer saturation, engine field generation, mission time, pad capture, failures, CSV export, Mars vs Earth gravity/atmosphere.</p>
</header>

<main>

<!-- LEFT CONTROLS -->
<section class="panel">
  <h2>Controls</h2>
  <p class="sub">
    Review-safe model: <b>no free energy</b>. Uses E=mc² only for accounting. “m=E/c²” appears only as an
    <i>energy-equivalent mass</i> readout (buffer energy), not literal mass creation.
  </p>

  <div class="row">
    <div>
      <label>World Preset</label>
      <select id="worldPreset" onchange="applyWorldPreset()">
        <option value="earth">Earth (g=9.81, atm=1.00)</option>
        <option value="mars" selected>Mars (g=3.71, atm≈0.01)</option>
        <option value="custom">Custom (manual sliders)</option>
      </select>
    </div>
    <div>
      <label>Sim Speed (× real time)</label>
      <input id="simSpeed" type="number" min="1" max="2000" step="1" value="120" />
    </div>
  </div>

  <label>Gravity g (m/s²)</label>
  <input id="g" type="range" min="0.5" max="15" step="0.01" value="3.71" oninput="setPresetCustom()" />

  <label>Atmosphere density factor ρ/ρₑ (0–1)</label>
  <input id="rho" type="range" min="0" max="1" step="0.001" value="0.010" oninput="setPresetCustom()" />

  <div class="row">
    <div>
      <label>Solar Input (kW)</label>
      <input id="solarKW" type="range" min="0" max="800" step="10" value="260" />
    </div>
    <div>
      <label>Buffer Capacity (MJ)</label>
      <input id="bufferMJ" type="range" min="50" max="4000" step="50" value="1200" />
    </div>
  </div>

  <div class="row">
    <div>
      <label>Nuclear Baseline (MW)</label>
      <input id="nuclearMW" type="range" min="0.1" max="8" step="0.1" value="1.8" />
    </div>
    <div>
      <label>Fusion Peak (MW)</label>
      <input id="fusionMW" type="range" min="0" max="80" step="1" value="28" />
    </div>
  </div>

  <label>Engine: Nuclear→Fusion Converter Efficiency (η)</label>
  <input id="etaNF" type="range" min="0" max="1" step="0.01" value="0.72" />

  <label>Warp / CST Field Coupling φₛₜ (0–1)</label>
  <input id="phi" type="range" min="0" max="1" step="0.01" value="0.66" />

  <div class="row">
    <div>
      <label>Base Vehicle Mass (tons)</label>
      <input id="massT" type="range" min="30" max="700" step="10" value="200" />
    </div>
    <div>
      <label>Crew Count</label>
      <input id="crew" type="range" min="0" max="20" step="1" value="10" />
    </div>
  </div>

  <label>Trip Distance (million km)</label>
  <input id="distMkm" type="range" min="10" max="400" step="10" value="80" />

  <div class="tog">
    <input id="failBuffer" type="checkbox" />
    <div>
      <div><b>Failure: Buffer Saturation</b></div>
      <small>Early cap + spilled energy is logged as irreversible heat loss.</small>
    </div>
  </div>

  <div class="tog">
    <input id="failFusion" type="checkbox" />
    <div>
      <div><b>Failure: Fusion Loss</b></div>
      <small>Fusion output goes to zero (station keeps nuclear + solar).</small>
    </div>
  </div>

  <div class="tog">
    <input id="failField" type="checkbox" />
    <div>
      <div><b>Failure: Field Collapse</b></div>
      <small>φₛₜ forced down; pad capture efficiency and damping degrade.</small>
    </div>
  </div>

  <label>Failure Severity (0–100%)</label>
  <input id="failSev" type="range" min="0" max="100" step="1" value="65" />

  <div class="btnrow">
    <button class="primary" id="btnStart" onclick="startSim()">Start</button>
    <button class="secondary" id="btnStop" onclick="stopSim()" disabled>Stop</button>
  </div>
  <div class="btnrow">
    <button class="secondary" onclick="resetSim()">Reset</button>
    <button class="secondary" onclick="exportCSV()">Export CSV</button>
  </div>

  <div class="readout" id="readout">
    <div><b>Status:</b> <span id="statusText" class="warn">Stopped</span></div>
    <div id="kpis"></div>
  </div>

  <div class="footnote">
    <b>Technical phrasing (paste into paper):</b><br>
    <small>
      The architecture models power flow through a buffer–reactor–field stack with explicit losses.
      E=mc² is used only for energy–mass equivalence accounting (buffer energy ↔ mass-equivalent readout).
      The CST field is treated as a closed-loop momentum redistribution and energy-buffering subsystem,
      with conservative bounds, actuator saturation, and degradation under injected failures.
    </small>
  </div>
</section>

<!-- RIGHT PANELS -->
<section class="panel right">

  <!-- TOP: 3 PANELS -->
  <div class="top3">

    <div class="pwrap">
      <div class="phead">
        <h2 style="margin:0">Station Panel</h2>
        <span class="tag">solar → buffer → bus</span>
      </div>
      <canvas id="cvStation" width="520" height="340"></canvas>
      <small>Station charges buffer, supports comms, and supplies baseline loads.</small>
    </div>

    <div class="pwrap">
      <div class="phead">
        <h2 style="margin:0">Engine Panel</h2>
        <span class="tag">nuclear → fusion → field</span>
      </div>
      <canvas id="cvEngine" width="520" height="340"></canvas>
      <small>Shows reactor chain and field generation with efficiency, coupling, and failures.</small>
    </div>

    <div class="pwrap">
      <div class="phead">
        <h2 style="margin:0">Transit Panel</h2>
        <span class="tag">field → v proxy → time</span>
      </div>
      <canvas id="cvTransit" width="520" height="340"></canvas>
      <small>Uses conservative proxy: power availability + φ to bound cruise speed and ETA.</small>
    </div>

  </div>

  <!-- BOTTOM: SURFACE WIDE -->
  <div class="pwrap wide">
    <div class="phead">
      <h2 style="margin:0">Surface Panel</h2>
      <span class="tag">pad capture + g/atm</span>
    </div>
    <canvas id="cvSurface" width="1600" height="340"></canvas>
    <small>Pad acts as phase reference + energy sink. Atmosphere and gravity affect coupling and operational margins.</small>
  </div>

</section>

</main>

<script>
/* =========================
   Constants & helpers
========================= */
const C = 299792458;
const DAY = 86400;

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x, d=2){ return (+x).toFixed(d); }
function nowMs(){ return performance.now(); }

/* =========================
   World presets
========================= */
function applyWorldPreset(){
  const p = document.getElementById("worldPreset").value;
  if(p==="earth"){
    document.getElementById("g").value = 9.81;
    document.getElementById("rho").value = 1.0;
  } else if(p==="mars"){
    document.getElementById("g").value = 3.71;
    document.getElementById("rho").value = 0.010;
  }
}
function setPresetCustom(){
  document.getElementById("worldPreset").value = "custom";
}

/* =========================
   Simulation state
========================= */
let running=false;
let lastT=0;

let logs=[];
let tSim=0;          // seconds
let bufferJ=0;       // J
let heatLossJ=0;     // J (irreversible)
let padCapturedJ=0;  // J
let progress=0;      // 0..1
let phiHold=0;       // 0..1 (filtered coupling)
let vProxy=0;        // m/s
let aComfort=0;      // 0..1

/* =========================
   Inputs
========================= */
function readInputs(){
  const solarW   = (+document.getElementById("solarKW").value) * 1000;
  const bufferCapJ = (+document.getElementById("bufferMJ").value) * 1e6;
  const nuclearW = (+document.getElementById("nuclearMW").value) * 1e6;
  const fusionW  = (+document.getElementById("fusionMW").value) * 1e6;
  const etaNF    = (+document.getElementById("etaNF").value);
  const phiUser  = (+document.getElementById("phi").value);

  const massKg   = (+document.getElementById("massT").value) * 1000;
  const crew     = (+document.getElementById("crew").value);
  const distM    = (+document.getElementById("distMkm").value) * 1e9;

  const g        = (+document.getElementById("g").value);
  const rho      = (+document.getElementById("rho").value);

  const failBuffer = document.getElementById("failBuffer").checked;
  const failFusion = document.getElementById("failFusion").checked;
  const failField  = document.getElementById("failField").checked;
  const sev = (+document.getElementById("failSev").value)/100;

  const speedX = (+document.getElementById("simSpeed").value);

  return {solarW, bufferCapJ, nuclearW, fusionW, etaNF, phiUser, massKg, crew, distM, g, rho, failBuffer, failFusion, failField, sev, speedX};
}

/* =========================
   Logging / CSV
========================= */
function maybeLog(I, bufferCapJ){
  const minute = Math.floor(tSim/60);
  const lastMinute = logs.length ? logs[logs.length-1].minute : -1;
  if(minute === lastMinute) return;

  const suppliesKg = I.crew * (tSim/DAY) * 4.5;
  const bufferMassEqKg = bufferJ / (C*C);

  logs.push({
    minute,
    t_s: tSim,
    progress,
    v_proxy_mps: vProxy,
    phi_hold: phiHold,
    solar_W: I.solarW,
    nuclear_W: I.nuclearW,
    fusion_W: (I.failFusion?0:I.fusionW),
    eta_nuclear_to_fusion: I.etaNF,
    buffer_J: bufferJ,
    buffer_cap_J: bufferCapJ,
    buffer_massEq_kg: bufferMassEqKg,
    heatLoss_J: heatLossJ,
    padCaptured_J: padCapturedJ,
    g_mps2: I.g,
    rho_factor: I.rho,
    supplies_kg: suppliesKg,
    crew: I.crew,
    mass_kg: I.massKg
  });
}

function exportCSV(){
  if(!logs.length){
    alert("No logs yet. Click Start to generate mission logs, then Export CSV.");
    return;
  }
  const cols = Object.keys(logs[0]);
  const lines = [cols.join(",")];
  for(const r of logs){
    lines.push(cols.map(k=>{
      const v=r[k];
      if(typeof v==="string") return `"${v.replaceAll('"','""')}"`;
      return (Number.isFinite(v)? String(v) : "");
    }).join(","));
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "cst_warp_mission_logs.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 5000);
}

/* =========================
   Drawing helpers
========================= */
function clearCanvas(cv){
  const g=cv.getContext("2d");
  g.clearRect(0,0,cv.width,cv.height);
  g.fillStyle="#0e1422";
  g.fillRect(0,0,cv.width,cv.height);
  g.strokeStyle="rgba(88,166,255,.10)";
  g.lineWidth=1;
  for(let x=0;x<cv.width;x+=40){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,cv.height); g.stroke(); }
  for(let y=0;y<cv.height;y+=40){ g.beginPath(); g.moveTo(0,y); g.lineTo(cv.width,y); g.stroke(); }
}

function drawBox(g,x,y,w,h,title,lines,fill){
  g.fillStyle=fill; g.fillRect(x,y,w,h);
  g.strokeStyle="rgba(255,255,255,.18)"; g.strokeRect(x,y,w,h);
  g.fillStyle="#000";
  g.font="bold 12px system-ui"; g.fillText(title, x+10, y+18);
  g.font="12px system-ui";
  let yy=y+36;
  for(const L of lines){ g.fillText(L, x+10, yy); yy+=16; }
}

function drawArrow(g,x1,y1,x2,y2,label){
  g.strokeStyle="#8fb4ff"; g.lineWidth=2;
  g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
  const ang=Math.atan2(y2-y1,x2-x1), ah=10;
  g.beginPath();
  g.moveTo(x2,y2);
  g.lineTo(x2-ah*Math.cos(ang-0.5), y2-ah*Math.sin(ang-0.5));
  g.lineTo(x2-ah*Math.cos(ang+0.5), y2-ah*Math.sin(ang+0.5));
  g.closePath();
  g.fillStyle="#8fb4ff"; g.fill();
  if(label){
    g.fillStyle="rgba(230,236,255,.92)";
    g.font="12px system-ui";
    g.fillText(label, (x1+x2)/2 + 8, (y1+y2)/2 - 6);
  }
}

function drawBar(g,x,y,w,h,frac,color,label){
  g.fillStyle="rgba(255,255,255,.06)"; g.fillRect(x,y,w,h);
  g.fillStyle=color; g.fillRect(x,y,w*clamp(frac,0,1),h);
  g.strokeStyle="rgba(255,255,255,.18)"; g.strokeRect(x,y,w,h);
  g.fillStyle="rgba(230,236,255,.9)";
  g.font="12px system-ui";
  g.fillText(label, x, y-6);
}

/* =========================
   Core step (conservative)
========================= */
function step(dt){
  const I=readInputs();

  // failures affecting φ
  let phi = I.phiUser;
  if(I.failField) phi *= (1 - 0.85*I.sev);
  phi = clamp(phi,0,1);

  // phase-lock filter
  const lockRate = lerp(0.05, 0.35, phi);
  phiHold += (phi - phiHold) * (1 - Math.exp(-lockRate*dt));
  phiHold = clamp(phiHold,0,1);

  // fusion availability
  const fusionAvailW = I.failFusion ? 0 : I.fusionW;

  // station fixed loads
  const stationLoadW = 0.35e6;
  const robotChargeW = 0.06e6;
  const totalLoadW = stationLoadW + robotChargeW;

  // buffer capacity degraded if saturation failure
  let bufferCapJ = I.bufferCapJ;
  if(I.failBuffer) bufferCapJ *= (1 - 0.55*I.sev);
  bufferCapJ = Math.max(1e6, bufferCapJ);

  // charge buffer from solar+nuclear minus loads
  const busInW = I.solarW + I.nuclearW;
  const netToBufferW = busInW - totalLoadW;
  bufferJ += netToBufferW * dt;

  if(bufferJ > bufferCapJ){
    const spill = bufferJ - bufferCapJ;
    bufferJ = bufferCapJ;
    heatLossJ += spill;
  }
  if(bufferJ < 0){
    bufferJ = 0;
  }

  // Engine chain: nuclear alloc → fusion converter → field
  // Allocate a fraction of nuclear to the converter chain during transit
  const nuclearToEngineW = I.nuclearW * 0.55;

  // fusion output limited by peak and by converter input and η
  // (this makes “fusion” behave like a power amplifier stage, not magic)
  const fusionDriveInputW = nuclearToEngineW; // power feeding converter stage
  const fusionPossibleW = fusionDriveInputW * I.etaNF; // effective converted portion
  const fusionOutW = Math.min(fusionAvailW, fusionPossibleW); // bounded by peak

  // buffer assist for transient field work
  const bufferDischargeMaxW = 6e6;
  const wantFromBufferW = Math.min(bufferDischargeMaxW, bufferJ/dt);
  // field coupling gates how much of fusion actually couples
  const fusionCoupledW = fusionOutW * phiHold;

  // pull buffer to cover additional field demand (only if coupling is high)
  const bufferPullW = Math.min(wantFromBufferW, fusionCoupledW * 0.55);
  bufferJ -= bufferPullW * dt;
  if(bufferJ < 0){ bufferJ = 0; }

  const fieldW = nuclearToEngineW + fusionCoupledW + bufferPullW;

  // coupling model: atmosphere doesn't help in deep space, but we keep a floor.
  const vacuumCouplingFloor = 0.20;
  const coupling = clamp(vacuumCouplingFloor + 0.40*phiHold, 0, 1);

  // effective inertial mass proxy (bounded)
  const effMassKg = I.massKg * (1 - 0.35 * phiHold * coupling);
  const effMassKgClamped = Math.max(0.65*I.massKg, effMassKg);

  // speed proxy (bounded)
  const vTarget = clamp(Math.sqrt((2*fieldW)/effMassKgClamped) * 1400, 500, 0.12*C);
  vProxy += (vTarget - vProxy) * (1 - Math.exp(-0.4*dt));
  vProxy = clamp(vProxy, 0, 0.12*C);

  // mission progress
  progress = clamp(progress + (vProxy*dt)/I.distM, 0, 1);

  // surface pad capture near arrival
  if(progress > 0.985){
    const u = clamp((progress - 0.985)/0.015, 0, 1);
    const atmCoupling = clamp(0.15 + 0.85*I.rho, 0.05, 1);
    const padEff = clamp(phiHold * atmCoupling, 0, 1);

    const landingDemandW = (2.5e6 + 9e6*u) * (0.6 + 0.4*I.rho);
    const providedW = Math.min(landingDemandW, fieldW);

    const captured = providedW * dt * padEff;
    padCapturedJ += captured;

    const loss = providedW * dt * (1 - padEff);
    heatLossJ += loss;

    aComfort = lerp(aComfort, padEff, 1 - Math.exp(-2.0*dt));
  } else {
    aComfort = lerp(aComfort, 0.2 + 0.6*phiHold, 1 - Math.exp(-0.6*dt));
  }

  tSim += dt;

  maybeLog(I, bufferCapJ);
}

/* =========================
   Render panels
========================= */
function renderPanels(){
  const I=readInputs();

  // φ with failure
  let phi = I.phiUser;
  if(I.failField) phi *= (1 - 0.85*I.sev);
  phi = clamp(phi,0,1);

  // buffer capacity with failure
  const bufferCapJ = Math.max(1e6, (I.failBuffer ? I.bufferCapJ*(1-0.55*I.sev) : I.bufferCapJ));
  const bufferFrac = bufferJ / bufferCapJ;

  const fusionAvailW = I.failFusion ? 0 : I.fusionW;

  // Station powers
  const stationLoadW = 0.35e6;
  const robotChargeW = 0.06e6;
  const totalLoadW = stationLoadW + robotChargeW;
  const busInW = I.solarW + I.nuclearW;
  const netToBufferW = busInW - totalLoadW;

  // Engine chain (same equations as step)
  const nuclearToEngineW = I.nuclearW * 0.55;
  const fusionPossibleW = nuclearToEngineW * I.etaNF;
  const fusionOutW = Math.min(fusionAvailW, fusionPossibleW);
  const fusionCoupledW = fusionOutW * phiHold;
  const bufferDischargeMaxW = 6e6;
  const bufferPullW_est = Math.min(bufferDischargeMaxW, bufferJ>0 ? bufferDischargeMaxW*(0.4+0.6*phiHold) : 0);
  const fieldW_est = nuclearToEngineW + fusionCoupledW + Math.min(bufferPullW_est, fusionCoupledW*0.55);

  const vacuumCouplingFloor = 0.20;
  const coupling = clamp(vacuumCouplingFloor + 0.40*phiHold, 0, 1);
  const effMassKg = I.massKg * (1 - 0.35 * phiHold * coupling);
  const effMassKgClamped = Math.max(0.65*I.massKg, effMassKg);

  // Surface
  const atmCoupling = clamp(0.15 + 0.85*I.rho, 0.05, 1);
  const padEff = clamp(phiHold * atmCoupling, 0, 1);

  // ---- Station canvas
  const cvS=document.getElementById("cvStation");
  clearCanvas(cvS);
  const gS=cvS.getContext("2d");
  gS.fillStyle="rgba(230,236,255,.92)";
  gS.font="bold 13px system-ui";
  gS.fillText("Station: Generation + Buffer + Loads", 12, 20);

  drawBox(gS, 20, 52, 140, 70, "Solar Arrays", [
    `${fmt(I.solarW/1000,0)} kW`,
    "robots + aux"
  ], "#ffe066");

  drawBox(gS, 190, 52, 165, 70, "Energy Buffer", [
    `${fmt(bufferJ/1e6,1)} MJ`,
    `cap ${fmt(bufferCapJ/1e6,0)} MJ`
  ], "#9bf6ff");

  drawBox(gS, 380, 42, 120, 90, "Nuclear", [
    `${fmt(I.nuclearW/1e6,2)} MW`,
    "baseline"
  ], "#cdb4db");

  drawBox(gS, 520, 52, 150, 70, "Station Loads", [
    `${fmt(totalLoadW/1e6,2)} MW`,
    "life + comm"
  ], "#a0c4ff");

  drawArrow(gS, 160, 87, 190, 87, "solar→buffer");
  drawArrow(gS, 440, 87, 355, 87, "nuclear→bus");
  drawArrow(gS, 500, 87, 520, 87, "bus→loads");

  drawBar(gS, 20, 155, 650, 16, bufferFrac, "rgba(53,208,127,.95)", "Buffer Fill");
  // scale netToBufferW into 0..1 around mid
  const netScaled = clamp(netToBufferW/2e6 * 0.5 + 0.5, 0, 1);
  drawBar(gS, 20, 205, 650, 16, netScaled, "rgba(242,193,78,.95)", "Net to Buffer (scaled)");

  // ---- Engine canvas
  const cvE=document.getElementById("cvEngine");
  clearCanvas(cvE);
  const gE=cvE.getContext("2d");
  gE.fillStyle="rgba(230,236,255,.92)";
  gE.font="bold 13px system-ui";
  gE.fillText("Engine: Nuclear → Fusion Converter → Field Coils", 12, 20);

  drawBox(gE, 20, 52, 160, 85, "Nuclear Stage", [
    `input ${fmt(I.nuclearW/1e6,2)} MW`,
    `to engine ${fmt(nuclearToEngineW/1e6,2)} MW`,
    "stable baseline"
  ], "#cdb4db");

  drawBox(gE, 210, 52, 175, 85, "Fusion Converter", [
    `η ${fmt(I.etaNF,2)}`,
    `possible ${fmt(fusionPossibleW/1e6,2)} MW`,
    `limit ${fmt(fusionAvailW/1e6,0)} MW`
  ], "#ffe066");

  drawBox(gE, 415, 52, 170, 85, "Fusion Output", [
    `out ${fmt(fusionOutW/1e6,2)} MW`,
    `coupled ${fmt(fusionCoupledW/1e6,2)} MW`,
    `φ_hold ${fmt(phiHold,2)}`
  ], "#9bf6ff");

  drawBox(gE, 610, 52, 165, 85, "Field Coils", [
    `field ${fmt(fieldW_est/1e6,2)} MW`,
    `coupling ${fmt(coupling,2)}`,
    "regulated actuation"
  ], "#a0c4ff");

  drawArrow(gE, 180, 95, 210, 95, "power");
  drawArrow(gE, 385, 95, 415, 95, "convert");
  drawArrow(gE, 585, 95, 610, 95, "couple");

  // bars: fusion loss, field collapse, buffer sat indicators
  const f1 = document.getElementById("failFusion").checked ? 1 : 0;
  const f2 = document.getElementById("failField").checked ? 1 : 0;
  const f3 = document.getElementById("failBuffer").checked ? 1 : 0;
  drawBar(gE, 20, 165, 755, 16, clamp(phiHold,0,1), "rgba(53,208,127,.95)", "Phase Alignment φ_hold");
  drawBar(gE, 20, 215, 755, 16, clamp(fieldW_est/(60e6),0,1), "rgba(242,193,78,.95)", "Field Power Fraction (0–60MW scale)");
  gE.fillStyle="rgba(230,236,255,.9)";
  gE.font="12px system-ui";
  gE.fillText("Failures:", 20, 262);
  gE.fillText(`FusionLoss=${f1? "ON":"off"}   FieldCollapse=${f2? "ON":"off"}   BufferSat=${f3? "ON":"off"}`, 90, 262);

  // ---- Transit canvas
  const cvT=document.getElementById("cvTransit");
  clearCanvas(cvT);
  const gT=cvT.getContext("2d");
  gT.fillStyle="rgba(230,236,255,.92)";
  gT.font="bold 13px system-ui";
  gT.fillText("Transit: Field Power → Effective Mass Proxy → v Proxy → ETA", 12, 20);

  drawBox(gT, 20, 52, 180, 85, "Field Work (est)", [
    `${fmt(fieldW_est/1e6,2)} MW`,
    `nuc ${fmt(nuclearToEngineW/1e6,2)} MW`,
    `fus ${fmt(fusionCoupledW/1e6,2)} MW`
  ], "#a0c4ff");

  drawBox(gT, 220, 52, 210, 85, "Effective Mass Proxy", [
    `${fmt(effMassKgClamped/1000,1)} tons`,
    `φ_hold ${fmt(phiHold,2)}`,
    `coupling ${fmt(coupling,2)}`
  ], "#bdb2ff");

  drawBox(gT, 450, 52, 160, 85, "Cruise v Proxy", [
    `${fmt(vProxy/1000,2)} km/s`,
    `${fmt(vProxy/C*100,3)}% c`,
    "bounded"
  ], "#ffe066");

  const remainingDist = (1-progress) * I.distM;
  const eta = (vProxy>10) ? (remainingDist / vProxy) : Infinity;
  const etaDays = eta/DAY;

  drawBox(gT, 630, 52, 160, 85, "ETA (steady)", [
    `${Number.isFinite(etaDays)? fmt(etaDays,1): "∞"} days`,
    `prog ${fmt(progress*100,1)}%`,
    `${fmt(I.distM/1e9,0)} Mkm`
  ], "#9bf6ff");

  drawArrow(gT, 200, 95, 220, 95, "P→m_eff");
  drawArrow(gT, 430, 95, 450, 95, "m_eff→v");

  drawBar(gT, 20, 160, 770, 18, progress, "rgba(88,166,255,.95)", "Mission Progress");
  drawBar(gT, 20, 215, 770, 18, clamp(phiHold,0,1), "rgba(53,208,127,.95)", "Phase Alignment φ_hold");

  // ---- Surface canvas (wide)
  const cvU=document.getElementById("cvSurface");
  clearCanvas(cvU);
  const gU=cvU.getContext("2d");
  gU.fillStyle="rgba(230,236,255,.92)";
  gU.font="bold 13px system-ui";
  gU.fillText("Surface: Pad Capture + Atmosphere/Gravity + Landing Stability", 12, 20);

  drawBox(gU, 20, 52, 220, 90, "World Params", [
    `g ${fmt(I.g,2)} m/s²`,
    `ρ/ρe ${fmt(I.rho,3)}`,
    `atmCoupling ${fmt(atmCoupling,2)}`
  ], "#cdb4db");

  drawBox(gU, 260, 52, 240, 90, "Pad Capture", [
    `eff ${fmt(padEff*100,1)}%`,
    `captured ${fmt(padCapturedJ/1e9,4)} GJ`,
    `loss ${fmt(heatLossJ/1e9,4)} GJ`
  ], "#9bf6ff");

  drawBox(gU, 520, 52, 220, 90, "Comfort Proxy", [
    `stability ${fmt(aComfort*100,1)}%`,
    "capture → damping",
    "lower jerk"
  ], "#ffe066");

  drawBox(gU, 760, 52, 220, 90, "Landing Mode", [
    (progress>0.985 ? "APPROACH" : "CRUISE"),
    (document.getElementById("failField").checked ? "Field risk" : "Nominal"),
    (document.getElementById("failFusion").checked ? "No fusion" : "Fusion ok")
  ], "#a0c4ff");

  // big pad + vehicle diagram on right side
  const padCx = 1180, padCy = 220, padR = 90;

  // pad
  gU.fillStyle="rgba(88,166,255,.14)";
  gU.beginPath(); gU.arc(padCx,padCy,padR,0,Math.PI*2); gU.fill();
  gU.strokeStyle="rgba(88,166,255,.85)";
  gU.lineWidth=3; gU.stroke();
  gU.fillStyle="rgba(230,236,255,.9)";
  gU.font="12px system-ui";
  gU.fillText("Landing Pad", padCx-38, padCy+padR+22);
  gU.fillText("(phase ref + sinks)", padCx-62, padCy+padR+38);

  // vehicle
  const vx=1420, vy=220;
  gU.fillStyle="rgba(255,255,255,.14)";
  gU.fillRect(vx-22, vy-12, 44, 24);
  gU.strokeStyle="rgba(255,255,255,.35)";
  gU.strokeRect(vx-22, vy-12, 44, 24);
  gU.fillStyle="rgba(230,236,255,.9)";
  gU.fillText("Vehicle", vx-22, vy+32);

  drawArrow(gU, vx-22, vy, padCx+padR+10, padCy, "field-guided approach");
  drawArrow(gU, padCx, padCy+padR+10, padCx, padCy+padR+70, "energy→sinks");

  drawBar(gU, 20, 170, 960, 16, padEff, "rgba(53,208,127,.95)", "Pad Capture Efficiency (φ_hold × atmosphere coupling)");
  drawBar(gU, 20, 210, 960, 16, clamp(I.g/9.81,0,1), "rgba(242,193,78,.95)", "Gravity fraction (g / 9.81)");

  // failures label
  const ftxt=[];
  if(document.getElementById("failBuffer").checked) ftxt.push("BufferSat");
  if(document.getElementById("failFusion").checked) ftxt.push("FusionLoss");
  if(document.getElementById("failField").checked)  ftxt.push("FieldCollapse");
  gU.fillStyle="rgba(230,236,255,.9)";
  gU.font="12px system-ui";
  gU.fillText("Failures: " + (ftxt.length? ftxt.join(" | ") : "none"), 20, 300);

  updateReadout(I, bufferCapJ, effMassKgClamped, padEff);
}

function updateReadout(I, bufferCapJ, effMassKgClamped, padEff){
  const status=document.getElementById("statusText");
  status.textContent = running ? "Running" : "Stopped";
  status.className = running ? "ok" : "warn";

  const suppliesKg = I.crew * (tSim/DAY) * 4.5;
  const bufMassEqKg = bufferJ / (C*C);
  const eta = (vProxy>10) ? ((1-progress)*I.distM / vProxy) : Infinity;
  const etaDays = eta/DAY;

  const risk =
    (I.failField ? 0.45 : 0) +
    (I.failFusion ? 0.25 : 0) +
    (I.failBuffer ? 0.20 : 0) +
    (1-padEff)*0.25;

  const riskTxt = (risk<0.35) ? "LOW" : (risk<0.65 ? "MED" : "HIGH");
  const riskCls = (risk<0.35) ? "ok" : (risk<0.65 ? "warn" : "bad");

  document.getElementById("kpis").innerHTML = `
    <div><b>Sim time:</b> ${fmt(tSim/3600,2)} h &nbsp; | &nbsp; <b>Progress:</b> ${fmt(progress*100,2)}%</div>
    <div><b>v proxy:</b> ${fmt(vProxy/1000,2)} km/s &nbsp; | &nbsp; <b>ETA:</b> ${Number.isFinite(etaDays)? fmt(etaDays,1): "∞"} days</div>
    <div><b>Buffer:</b> ${fmt(bufferJ/1e6,1)} MJ / ${fmt(bufferCapJ/1e6,0)} MJ &nbsp; | &nbsp; <b>m_eq:</b> ${fmt(bufMassEqKg,6)} kg</div>
    <div><b>Effective mass proxy:</b> ${fmt(effMassKgClamped/1000,1)} tons &nbsp; | &nbsp; <b>Pad capture:</b> ${fmt(padEff*100,1)}%</div>
    <div><b>Supplies estimate:</b> ${fmt(suppliesKg,1)} kg (${I.crew} crew @ 4.5 kg/day)</div>
    <div><b>Losses:</b> heat ${fmt(heatLossJ/1e9,4)} GJ &nbsp; | &nbsp; pad captured ${fmt(padCapturedJ/1e9,4)} GJ</div>
    <div><b>Risk:</b> <span class="${riskCls}">${riskTxt}</span></div>
  `;
}

/* =========================
   Loop controls
========================= */
function loop(t){
  if(!running) return;
  const I=readInputs();
  const dtReal = (t - lastT)/1000;
  lastT = t;

  const speedX = clamp(I.speedX, 1, 2000);
  let dt = clamp(dtReal * speedX, 0, 10);

  const n = Math.ceil(dt/0.2);
  const h = dt/n;

  for(let i=0;i<n;i++){
    step(h);
    if(progress >= 1){
      progress = 1;
      running = false;
      break;
    }
  }

  renderPanels();

  if(!running){
    document.getElementById("btnStart").disabled = false;
    document.getElementById("btnStop").disabled = true;
  } else {
    requestAnimationFrame(loop);
  }
}

function startSim(){
  if(running) return;
  running=true;
  lastT=nowMs();
  document.getElementById("btnStart").disabled=true;
  document.getElementById("btnStop").disabled=false;
  renderPanels();
  requestAnimationFrame(loop);
}
function stopSim(){
  running=false;
  document.getElementById("btnStart").disabled=false;
  document.getElementById("btnStop").disabled=true;
  renderPanels();
}
function resetSim(){
  running=false;
  tSim=0;
  bufferJ=0;
  heatLossJ=0;
  padCapturedJ=0;
  progress=0;
  phiHold=0;
  vProxy=0;
  aComfort=0;
  logs=[];
  document.getElementById("btnStart").disabled=false;
  document.getElementById("btnStop").disabled=true;
  renderPanels();
}

/* =========================
   Init
========================= */
(function init(){
  applyWorldPreset();
  resetSim();
  document.getElementById("worldPreset").value = "mars";
})();
</script>
</body>
</html>
