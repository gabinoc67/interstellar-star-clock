<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Warp — Figure 9 Heine Bottle Topology Panel (Dyson + Prune/Decay) + 5 FTL Planet Runs</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#121a33;
    --panel2:#0f1630;
    --ink:#e9f0ff;
    --muted:#a8b3d6;
    --line:#27325e;
    --accent:#6aa7ff;
    --good:#34e1a0;
    --warn:#ffd26a;
    --bad:#ff6b8b;
    --shadow: 0 14px 40px rgba(0,0,0,.35);
    --radius: 14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 700px at 20% -10%, #182455 0%, rgba(24,36,85,0) 60%),
                radial-gradient(900px 600px at 90% 10%, #14204b 0%, rgba(20,32,75,0) 55%),
                linear-gradient(180deg, #070b17 0%, #050815 60%, #040611 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.06);
    background: linear-gradient(90deg, rgba(106,167,255,.18), rgba(0,0,0,0));
  }
  header .row{
    display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
  }
  header h1{
    margin:0;
    font-size:16px;
    letter-spacing:.2px;
    font-weight:800;
  }
  header .sub{
    color:var(--muted);
    font-size:12px;
    max-width:900px;
  }

  .wrap{
    padding:14px;
    display:grid;
    grid-template-columns: 1.12fr .88fr;
    gap:14px;
    max-width:1400px;
    margin:0 auto;
  }
  @media (max-width: 1020px){
    .wrap{grid-template-columns:1fr}
  }
  .card{
    background: linear-gradient(180deg, rgba(18,26,51,.96), rgba(15,22,48,.92));
    border:1px solid rgba(255,255,255,.07);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .card h2{
    margin:0;
    padding:12px 12px 10px 12px;
    font-size:13px;
    color:#dfe8ff;
    border-bottom:1px solid rgba(255,255,255,.06);
    background: linear-gradient(90deg, rgba(106,167,255,.14), rgba(0,0,0,0));
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .badge{
    font-size:11px;
    color:#dce7ff;
    background:rgba(106,167,255,.12);
    border:1px solid rgba(106,167,255,.25);
    padding:4px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .content{padding:12px}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
  .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{
    cursor:pointer;
    border:none;
    border-radius:12px;
    padding:10px 12px;
    color:#071021;
    font-weight:800;
    background: linear-gradient(180deg, #8fc0ff, #5c9bff);
    box-shadow: 0 10px 18px rgba(0,0,0,.25);
  }
  .btn.secondary{
    color:var(--ink);
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    box-shadow:none;
    font-weight:700;
  }
  .btn.danger{
    color:#1a0810;
    background: linear-gradient(180deg, #ff9ab0, #ff6b8b);
  }
  .btn:active{transform: translateY(1px)}
  .small{font-size:12px; color:var(--muted); line-height:1.35}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  label{font-size:12px; color:var(--muted)}
  input[type="range"]{width:100%}
  .kv{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:6px;
    align-items:center;
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.14);
  }
  .kv b{font-size:12px}
  .kv span{font-size:12px; color:var(--muted)}
  .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0}
  canvas{
    width:100%;
    height:420px;
    display:block;
    background: radial-gradient(800px 420px at 50% 15%, rgba(106,167,255,.16), rgba(0,0,0,0) 60%),
                linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.08));
  }
  .mini{
    width:100%;
    height:140px;
    display:block;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.12);
  }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:7px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.14);
    font-size:12px;
    color:var(--muted);
  }
  .dot{width:9px;height:9px;border-radius:50%}
  .dot.good{background:var(--good)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--bad)}
  .legend{
    display:flex; gap:10px; flex-wrap:wrap;
    padding:10px 12px; border-top:1px solid rgba(255,255,255,.06);
    background: rgba(0,0,0,.10);
  }
  .scenarioGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  @media (max-width: 520px){
    .scenarioGrid{grid-template-columns: 1fr}
  }
  .scenario{
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.09);
    background: rgba(0,0,0,.12);
    cursor:pointer;
    transition: transform .08s ease, border-color .08s ease;
  }
  .scenario:hover{transform: translateY(-1px); border-color: rgba(106,167,255,.35)}
  .scenario h3{margin:0 0 4px 0; font-size:13px}
  .scenario p{margin:0; font-size:12px; color:var(--muted); line-height:1.3}
  .scenario .tag{
    display:inline-block;
    margin-top:8px;
    font-size:11px;
    padding:3px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(106,167,255,.10);
    color:#dce7ff;
  }
  .note{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.09);
    background: rgba(0,0,0,.14);
    color: var(--muted);
    font-size:12px;
    line-height:1.45;
  }
  .ok{color:var(--good)}
  .warn{color:var(--warn)}
  .bad{color:var(--bad)}
  .tight{line-height:1.25}
  .rightSticky{
    position:sticky;
    top:12px;
    align-self:start;
  }
  @media (max-width: 1020px){
    .rightSticky{position:static}
  }
</style>
</head>

<body>
<header>
  <div class="row">
    <div>
      <h1>Figure 9 — Heine Bottle (Figure-8/Klein-Type Immersion) • Live Topology + CST Navigation + Warp Engine</h1>
      <div class="sub">
        This simulator treats “Heine Bottle immersion” as a <b>control topology</b>: a coupled <b>two-loop flow</b> with a crossing node that performs
        <b>Dyson Sphere constraint capture</b> and <b>Prune + Decay</b> stabilization. Five clickable FTL runs show when the system remains stable.
      </div>
    </div>
    <div class="row">
      <button class="btn" id="btnStart">Start</button>
      <button class="btn secondary" id="btnStop">Stop</button>
      <button class="btn danger" id="btnReset">Reset</button>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- LEFT: Live topology -->
  <section class="card">
    <h2>
      <span>Live Heine Bottle Immersion Topology Panel</span>
      <span class="badge mono" id="statusBadge">IDLE</span>
    </h2>

    <canvas id="topology"></canvas>

    <div class="legend">
      <span class="pill"><span class="dot good"></span> Stable</span>
      <span class="pill"><span class="dot warn"></span> Marginal</span>
      <span class="pill"><span class="dot bad"></span> Unstable</span>
      <span class="pill mono">Crossing = Dyson Gate + Prune/Decay</span>
      <span class="pill mono">Outer Loop = Field / Dilation</span>
      <span class="pill mono">Inner Loop = CST / Navigation</span>
    </div>

    <div class="content">
      <div class="grid2">
        <div class="kv">
          <div>
            <b>Topology Coherence (κ)</b><br>
            <span class="mono" id="kappaTxt">0.000</span>
          </div>
          <div class="mono" id="kappaState">—</div>
        </div>

        <div class="kv">
          <div>
            <b>Dyson Constraint Capture (D)</b><br>
            <span class="mono" id="dysonTxt">0.000</span>
          </div>
          <div class="mono" id="dysonState">—</div>
        </div>

        <div class="kv">
          <div>
            <b>Prune Pressure (P)</b><br>
            <span class="mono" id="pruneTxt">0.000</span>
          </div>
          <div class="mono" id="pruneState">—</div>
        </div>

        <div class="kv">
          <div>
            <b>Decay Rate (δ)</b><br>
            <span class="mono" id="decayTxt">0.000</span>
          </div>
          <div class="mono" id="decayState">—</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="note">
        <b>What you are seeing (Figure 9):</b><br>
        • The two loops exchange “flow energy” at the crossing node. The crossing node applies:<br>
        <span class="mono">Dyson: D = clamp( captureGain · (1 − boundaryError) · coherence, 0..1 )</span><br>
        <span class="mono">Prune: P = σ( pruneGain · (stress − tolerance) )</span> (σ is a smooth logistic)<br>
        <span class="mono">Decay: δ = baseDecay + P · decayGain</span><br>
        • Bad / noisy trajectories lose weight over time (<span class="mono">w ← w · e^(−δ·dt)</span>), stable paths keep weight and lock phase.
      </div>
    </div>
  </section>

  <!-- RIGHT: Controls + scenarios + clocks -->
  <aside class="rightSticky">
    <section class="card">
      <h2>
        <span>Warp Engine + Navigation Controls</span>
        <span class="badge mono" id="runMode">No Scenario</span>
      </h2>
      <div class="content">
        <div class="grid3">
          <div class="kv">
            <div>
              <b>UTC</b><br>
              <span class="mono" id="utcClock">—</span>
            </div>
            <div class="mono">Z</div>
          </div>
          <div class="kv">
            <div>
              <b>CST (Local)</b><br>
              <span class="mono" id="cstClock">—</span>
            </div>
            <div class="mono">−06</div>
          </div>
          <div class="kv">
            <div>
              <b>Interstellar Time</b><br>
              <span class="mono" id="istClock">—</span>
            </div>
            <div class="mono">τ</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div>
            <label>Warp Factor (FTL scale)</label>
            <input id="warpFactor" type="range" min="1" max="10" step="0.01" value="4.2" />
            <div class="small mono">W = <span id="warpFactorTxt">4.20</span></div>
          </div>
          <div>
            <label>Field Energy (E)</label>
            <input id="fieldEnergy" type="range" min="0.2" max="3.0" step="0.01" value="1.20" />
            <div class="small mono">E = <span id="fieldEnergyTxt">1.20</span></div>
          </div>

          <div>
            <label>Bubble Shear Tolerance (T)</label>
            <input id="shearTol" type="range" min="0.20" max="1.50" step="0.01" value="0.78" />
            <div class="small mono">T = <span id="shearTolTxt">0.78</span></div>
          </div>
          <div>
            <label>CST Phase Lock Gain (Gφ)</label>
            <input id="phaseGain" type="range" min="0.20" max="2.50" step="0.01" value="1.15" />
            <div class="small mono">Gφ = <span id="phaseGainTxt">1.15</span></div>
          </div>

          <div>
            <label>Dyson Capture Gain (GD)</label>
            <input id="dysonGain" type="range" min="0.10" max="2.50" step="0.01" value="1.05" />
            <div class="small mono">GD = <span id="dysonGainTxt">1.05</span></div>
          </div>
          <div>
            <label>Prune Gain (GP)</label>
            <input id="pruneGain" type="range" min="0.10" max="3.50" step="0.01" value="1.65" />
            <div class="small mono">GP = <span id="pruneGainTxt">1.65</span></div>
          </div>

          <div>
            <label>Base Decay (δ₀)</label>
            <input id="baseDecay" type="range" min="0.00" max="0.40" step="0.001" value="0.075" />
            <div class="small mono">δ₀ = <span id="baseDecayTxt">0.075</span></div>
          </div>
          <div>
            <label>Decay Gain (Gδ)</label>
            <input id="decayGain" type="range" min="0.00" max="1.20" step="0.01" value="0.42" />
            <div class="small mono">Gδ = <span id="decayGainTxt">0.42</span></div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div class="kv">
            <div>
              <b>Outer Field Dilation (Δτ/Δt)</b><br>
              <span class="mono" id="dilationTxt">—</span>
            </div>
            <div class="mono" id="dilationState">—</div>
          </div>

          <div class="kv">
            <div>
              <b>Navigation Error (ε)</b><br>
              <span class="mono" id="navErrTxt">—</span>
            </div>
            <div class="mono" id="navErrState">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="note tight">
          <b>Equations used (sim-level, consistent + controllable):</b><br>
          <span class="mono">c = 299792458 m/s</span><br>
          <span class="mono">m = E / c²</span> (effective mass from energy)<br><br>
          <b>Warp / stress proxy:</b><br>
          <span class="mono">stress = (W^1.35 · E) · (1 + scenarioHazard)</span><br>
          <span class="mono">boundaryError = clamp( stress − T, 0..∞ ) normalized</span><br><br>
          <b>Dyson + Prune/Decay:</b><br>
          <span class="mono">D = clamp( GD · (1 − normErr) · κ, 0..1 )</span><br>
          <span class="mono">P = σ( GP · (stress − T) )</span><br>
          <span class="mono">δ = δ₀ + P · Gδ</span><br>
          <span class="mono">κ ← κ + dt·( +D·(Gφ·phaseMatch) − P·(1−D) )</span><br>
          <span class="mono">w ← w · exp(−δ·dt)</span> (unstable paths decay)
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>
        <span>5 Clickable FTL Planet Runs</span>
        <span class="badge mono" id="scenarioBadge">Select one</span>
      </h2>
      <div class="content">
        <div class="scenarioGrid" id="scenarioGrid"></div>

        <div class="hr"></div>

        <canvas class="mini" id="stripChart"></canvas>
        <div class="small" style="margin-top:8px">
          Mini chart shows <span class="mono">κ</span> (coherence) and <span class="mono">ε</span> (nav error) evolving in real time.
        </div>

        <div class="hr"></div>

        <div class="note">
          <b>Instructions</b><br>
          1) Click a planet run. 2) Press <b>Start</b>. 3) Adjust W/E/T/Gφ/GD/GP/δ controls.<br>
          • Stable runs show rising κ and shrinking ε.<br>
          • Unstable runs show κ collapsing while ε grows; Prune and Decay spike.<br>
          • Dyson capture should rise when boundary error is low.
        </div>
      </div>
    </section>
  </aside>
</div>

<script>
/* =========================
   CST Warp — Figure 9 Simulator
   Self-contained; no libraries.
   ========================= */

// ---- Constants
const C = 299792458;
const TAU0 = Date.now(); // for "Interstellar Time" epoch

// ---- DOM Helpers
const $ = (id)=>document.getElementById(id);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;

// Smooth logistic (avoid hard steps)
function sigma(x){ return 1/(1+Math.exp(-x)); }

// Nice fixed formatting
function f3(x){ return (Math.round(x*1000)/1000).toFixed(3); }
function f2(x){ return (Math.round(x*100)/100).toFixed(2); }

// ---- UI elements
const btnStart = $("btnStart");
const btnStop  = $("btnStop");
const btnReset = $("btnReset");

const warpFactor = $("warpFactor");
const fieldEnergy = $("fieldEnergy");
const shearTol = $("shearTol");
const phaseGain = $("phaseGain");
const dysonGain = $("dysonGain");
const pruneGain = $("pruneGain");
const baseDecay = $("baseDecay");
const decayGain = $("decayGain");

const warpFactorTxt = $("warpFactorTxt");
const fieldEnergyTxt = $("fieldEnergyTxt");
const shearTolTxt = $("shearTolTxt");
const phaseGainTxt = $("phaseGainTxt");
const dysonGainTxt = $("dysonGainTxt");
const pruneGainTxt = $("pruneGainTxt");
const baseDecayTxt = $("baseDecayTxt");
const decayGainTxt = $("decayGainTxt");

const utcClock = $("utcClock");
const cstClock = $("cstClock");
const istClock = $("istClock");

const statusBadge = $("statusBadge");
const runMode = $("runMode");
const scenarioBadge = $("scenarioBadge");

const kappaTxt = $("kappaTxt");
const dysonTxt = $("dysonTxt");
const pruneTxt = $("pruneTxt");
const decayTxt = $("decayTxt");
const kappaState = $("kappaState");
const dysonState = $("dysonState");
const pruneState = $("pruneState");
const decayState = $("decayState");

const dilationTxt = $("dilationTxt");
const dilationState = $("dilationState");
const navErrTxt = $("navErrTxt");
const navErrState = $("navErrState");

// ---- Canvases
const canvas = $("topology");
const ctx = canvas.getContext("2d");

const strip = $("stripChart");
const sctx = strip.getContext("2d");

// Handle high-DPI correctly
function fitCanvas(c){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const rect = c.getBoundingClientRect();
  c.width = Math.floor(rect.width * dpr);
  c.height = Math.floor(rect.height * dpr);
  const g = c.getContext("2d");
  g.setTransform(dpr,0,0,dpr,0,0);
  return g;
}
function refitAll(){
  fitCanvas(canvas);
  fitCanvas(strip);
}
window.addEventListener("resize", ()=>{ refitAll(); });
refitAll();

// =========================
// Scenarios (5 clickable)
// =========================
const scenarios = [
  {
    key:"mars",
    name:"Mars",
    desc:"Short FTL hop, moderate dust + comm jitter. Good for tuning lock gains.",
    hazard: 0.12,
    distanceAU: 0.52,
    recommended: { W:4.1, E:1.10, T:0.78, Gp:1.10, GD:1.05, GP:1.55, d0:0.070, Gd:0.40 }
  },
  {
    key:"europa",
    name:"Europa",
    desc:"Strong magnetic environment + radiation. Stress spikes at crossing node.",
    hazard: 0.28,
    distanceAU: 4.2,
    recommended: { W:5.3, E:1.35, T:0.92, Gp:1.25, GD:1.15, GP:1.85, d0:0.085, Gd:0.46 }
  },
  {
    key:"titan",
    name:"Titan",
    desc:"Dense atmosphere arrival + navigation drag model. Needs good Dyson capture.",
    hazard: 0.22,
    distanceAU: 8.6,
    recommended: { W:5.0, E:1.28, T:0.95, Gp:1.20, GD:1.25, GP:1.70, d0:0.080, Gd:0.44 }
  },
  {
    key:"proxima_b",
    name:"Proxima b",
    desc:"Interstellar jump. High dilation + long-run drift. Requires strong prune/decay.",
    hazard: 0.52,
    distanceAU: 268000, // symbolic
    recommended: { W:7.4, E:1.85, T:1.12, Gp:1.55, GD:1.35, GP:2.35, d0:0.110, Gd:0.62 }
  },
  {
    key:"trappist1e",
    name:"TRAPPIST-1e",
    desc:"Multi-well gravity environment. Worst-case stability test for topology.",
    hazard: 0.64,
    distanceAU: 2700000, // symbolic
    recommended: { W:8.2, E:2.05, T:1.22, Gp:1.70, GD:1.45, GP:2.60, d0:0.125, Gd:0.70 }
  }
];

let currentScenario = null;

// Render scenario buttons
const scenarioGrid = $("scenarioGrid");
function renderScenarios(){
  scenarioGrid.innerHTML = "";
  scenarios.forEach((s)=>{
    const el = document.createElement("div");
    el.className = "scenario";
    el.innerHTML = `
      <h3>${s.name}</h3>
      <p>${s.desc}</p>
      <span class="tag mono">hazard=${s.hazard.toFixed(2)} • AU≈${s.distanceAU >= 1000 ? "∞" : s.distanceAU}</span>
    `;
    el.addEventListener("click", ()=>selectScenario(s.key));
    scenarioGrid.appendChild(el);
  });
}
renderScenarios();

// =========================
// Simulation State
// =========================
let running = false;
let tPrev = performance.now();

let state = {
  // Topology / control state variables
  kappa: 0.55,       // coherence κ (0..1)
  dyson: 0.0,        // Dyson capture D (0..1)
  prune: 0.0,        // prune pressure P (0..1)
  decay: 0.0,        // decay rate δ (0..1+)
  weight: 1.0,       // path weight w (0..1)
  phase: 0.0,        // phase angle
  navErr: 0.25,      // navigation error ε (0..1+)
  dilation: 1.00,    // Δτ/Δt proxy
  // visual particle flow
  particles: [],
  // strip chart history
  histK: [],
  histE: []
};

function seedParticles(){
  state.particles = [];
  for(let i=0;i<150;i++){
    state.particles.push({
      u: Math.random(), // 0..1 along loop
      loop: Math.random()<0.5 ? 0 : 1, // 0 inner, 1 outer
      jitter: Math.random()*Math.PI*2
    });
  }
}
seedParticles();

function resetState(full=false){
  state.kappa = 0.55;
  state.dyson = 0.0;
  state.prune = 0.0;
  state.decay = 0.0;
  state.weight = 1.0;
  state.phase = 0.0;
  state.navErr = 0.25;
  state.dilation = 1.00;
  state.histK = [];
  state.histE = [];
  if(full){ seedParticles(); }
  updateUI();
  draw(); drawStrip();
}

function setStatus(txt){
  statusBadge.textContent = txt;
}

// =========================
// Scenario selection
// =========================
function selectScenario(key){
  currentScenario = scenarios.find(s=>s.key===key) || null;
  if(!currentScenario){
    runMode.textContent = "No Scenario";
    scenarioBadge.textContent = "Select one";
    return;
  }
  runMode.textContent = currentScenario.name;
  scenarioBadge.textContent = "Loaded: " + currentScenario.name;

  // Apply recommended knobs
  warpFactor.value = currentScenario.recommended.W;
  fieldEnergy.value = currentScenario.recommended.E;
  shearTol.value = currentScenario.recommended.T;
  phaseGain.value = currentScenario.recommended.Gp;
  dysonGain.value = currentScenario.recommended.GD;
  pruneGain.value = currentScenario.recommended.GP;
  baseDecay.value = currentScenario.recommended.d0;
  decayGain.value = currentScenario.recommended.Gd;

  updateKnobText();
  resetState(false);
}

// =========================
// Clocks (non-stop)
// =========================
function pad2(n){ return String(n).padStart(2,"0"); }
function fmtTime(d){
  return `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}:${pad2(d.getUTCSeconds())}.${String(d.getUTCMilliseconds()).padStart(3,"0")}`;
}
function tickClocks(){
  const now = new Date();

  // UTC clock
  utcClock.textContent = fmtTime(now);

  // CST (America/Monterrey typically UTC-6; we show a fixed -06 offset clock here for consistency)
  const cst = new Date(now.getTime() - 6*60*60*1000);
  cstClock.textContent = `${pad2(cst.getUTCHours())}:${pad2(cst.getUTCMinutes())}:${pad2(cst.getUTCSeconds())}.${String(cst.getUTCMilliseconds()).padStart(3,"0")}`;

  // Interstellar time τ: integrates dilation proxy when running; else ticks at 1x baseline
  // τ = ∫ dilation dt (proxy). We'll keep a running "tauSeconds" from epoch.
  if(!state.tauSeconds) state.tauSeconds = 0;
  const dt = 0.016;
  const rate = running ? state.dilation : 1.0;
  state.tauSeconds += dt * rate;
  const totalMs = Math.floor(state.tauSeconds*1000);
  const sec = Math.floor(totalMs/1000) % 60;
  const min = Math.floor(totalMs/60000) % 60;
  const hr  = Math.floor(totalMs/3600000) % 24;
  const ms  = totalMs % 1000;
  istClock.textContent = `${pad2(hr)}:${pad2(min)}:${pad2(sec)}.${String(ms).padStart(3,"0")}`;

  requestAnimationFrame(tickClocks);
}
tickClocks();

// =========================
// Knob text update
// =========================
function updateKnobText(){
  warpFactorTxt.textContent = (+warpFactor.value).toFixed(2);
  fieldEnergyTxt.textContent = (+fieldEnergy.value).toFixed(2);
  shearTolTxt.textContent = (+shearTol.value).toFixed(2);
  phaseGainTxt.textContent = (+phaseGain.value).toFixed(2);
  dysonGainTxt.textContent = (+dysonGain.value).toFixed(2);
  pruneGainTxt.textContent = (+pruneGain.value).toFixed(2);
  baseDecayTxt.textContent = (+baseDecay.value).toFixed(3);
  decayGainTxt.textContent = (+decayGain.value).toFixed(2);
}
["input","change"].forEach(ev=>{
  [warpFactor,fieldEnergy,shearTol,phaseGain,dysonGain,pruneGain,baseDecay,decayGain].forEach(el=>{
    el.addEventListener(ev, ()=>{ updateKnobText(); });
  });
});
updateKnobText();

// =========================
// Core simulation step
// =========================
function step(dt){
  // Inputs
  const W  = +warpFactor.value;
  const E  = +fieldEnergy.value;
  const T  = +shearTol.value;
  const Gφ = +phaseGain.value;
  const GD = +dysonGain.value;
  const GP = +pruneGain.value;
  const δ0 = +baseDecay.value;
  const Gδ = +decayGain.value;

  const hazard = currentScenario ? currentScenario.hazard : 0.18;

  // Derived proxy quantities
  // Stress: grows with warp factor and field energy and scenario hazard
  const stress = (Math.pow(W, 1.35) * E) * (1 + hazard);

  // Normalize boundary error to 0..1-ish band
  const rawErr = Math.max(0, stress - T);
  // Use a soft normalizer so it doesn't blow up:
  const normErr = clamp(rawErr / (rawErr + 1.0), 0, 1); // 0..1

  // Phase match proxy: if nav error small + kappa high, phase match improves
  const phaseMatch = clamp(1.0 - state.navErr, 0, 1) * clamp(state.kappa, 0, 1);

  // Dyson capture: high when boundary error is low and coherence exists
  const D = clamp(GD * (1 - normErr) * clamp(state.kappa, 0, 1), 0, 1);

  // Prune pressure: triggers when stress exceeds tolerance
  // Use logistic around the boundary (stress - T)
  const P = clamp(sigma(GP * (stress - T) * 0.65) - 0.5, 0, 1); // 0..1

  // Decay rate: increases with prune (more instability -> more decay)
  const δ = clamp(δ0 + P * Gδ, 0, 2.0);

  // Update coherence κ: grows with Dyson capture + phaseMatch; decreases with prune when Dyson is low
  // κ ← κ + dt*( +D*(Gφ*phaseMatch) − P*(1−D) )
  let kappaDot = (D * (Gφ * phaseMatch)) - (P * (1 - D));
  state.kappa = clamp(state.kappa + dt * (0.55 * kappaDot), 0, 1);

  // Navigation error ε: reduced by coherence + dyson capture; increased by stress and prune
  // ε ← ε + dt*( +a*normErr + b*P − c*(κ*D) )
  const a=0.38, b=0.22, c=0.55;
  state.navErr = Math.max(0, state.navErr + dt * ((a*normErr) + (b*P) - (c*(state.kappa*D))));

  // Path weight w decays when unstable
  state.weight *= Math.exp(-δ * dt);
  state.weight = clamp(state.weight, 0, 1);

  // Dilation proxy: increases with warp factor and field energy, reduced by coherence
  // Δτ/Δt ~ 1 + k*(W*E) - r*κ
  const k=0.06, r=0.05;
  state.dilation = Math.max(0.65, 1 + k*(W*E)*(1+hazard*0.6) - r*state.kappa);

  // Phase angle advances faster with warp factor but stabilized by coherence
  const phaseSpeed = 0.9 + 0.25*W;
  state.phase += dt * phaseSpeed * (0.9 + 0.25*(1 - state.kappa));
  if(state.phase > Math.PI*2) state.phase -= Math.PI*2;

  // Store outputs
  state.dyson = D;
  state.prune = P;
  state.decay = δ;

  // Update particles along loops; prune pushes more particles to "fade" (handled in draw)
  const flowSpeed = (0.15 + 0.10*W) * (0.65 + 0.35*state.kappa);
  for(const p of state.particles){
    // more prune => more jitter => visual turbulence
    const turb = (0.25 + 1.6*P) * 0.02;
    p.u = (p.u + dt*flowSpeed + (Math.sin(state.phase + p.jitter)*turb)) % 1;
    // when Dyson capture is high, particles tend to align (reduce random switching)
    const switchProb = (0.006 + 0.05*P) * (1 - D);
    if(Math.random() < switchProb * dt*60){
      p.loop = 1 - p.loop;
    }
  }

  // Strip chart history
  state.histK.push(state.kappa);
  state.histE.push(Math.min(1.2, state.navErr) / 1.2); // normalize navErr to 0..1
  const maxN = 220;
  if(state.histK.length > maxN){ state.histK.shift(); state.histE.shift(); }
}

// =========================
// UI updates
// =========================
function classify(x){
  if(x >= 0.72) return {label:"STABLE", cls:"ok"};
  if(x >= 0.48) return {label:"MARGINAL", cls:"warn"};
  return {label:"UNSTABLE", cls:"bad"};
}
function updateUI(){
  const kClass = classify(state.kappa);
  kappaTxt.textContent = f3(state.kappa);
  kappaState.textContent = kClass.label;
  kappaState.className = "mono " + kClass.cls;

  dysonTxt.textContent = f3(state.dyson);
  dysonState.textContent = state.dyson > 0.66 ? "HIGH" : (state.dyson>0.33 ? "MID" : "LOW");
  dysonState.className = "mono " + (state.dyson>0.66 ? "ok" : (state.dyson>0.33 ? "warn" : "bad"));

  pruneTxt.textContent = f3(state.prune);
  pruneState.textContent = state.prune > 0.66 ? "SPIKING" : (state.prune>0.33 ? "ACTIVE" : "QUIET");
  pruneState.className = "mono " + (state.prune>0.66 ? "bad" : (state.prune>0.33 ? "warn" : "ok"));

  decayTxt.textContent = f3(state.decay);
  decayState.textContent = state.decay > 0.55 ? "FAST" : (state.decay>0.25 ? "MED" : "SLOW");
  decayState.className = "mono " + (state.decay>0.55 ? "bad" : (state.decay>0.25 ? "warn" : "ok"));

  // Dilation / Nav error
  dilationTxt.textContent = f3(state.dilation);
  const dCls = state.dilation > 1.16 ? "warn" : (state.dilation < 0.92 ? "warn" : "ok");
  dilationState.textContent = (state.dilation > 1.22) ? "HIGH" : (state.dilation < 0.88 ? "LOW" : "NOMINAL");
  dilationState.className = "mono " + dCls;

  navErrTxt.textContent = f3(state.navErr);
  const ne = state.navErr;
  navErrState.textContent = (ne < 0.18) ? "LOCKED" : (ne < 0.45) ? "TRACKING" : "DRIFT";
  navErrState.className = "mono " + ((ne < 0.18) ? "ok" : (ne < 0.45) ? "warn" : "bad");
}

// =========================
// Drawing: Figure-9 Heine Bottle immersion
// Two loops + crossing node.
// =========================
function loopPoint(loop, u, time){
  // We draw an "∞" / lemniscate-like immersion as two loops with a shared crossing
  // inner loop is tighter; outer loop larger (field).
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;
  const cx = w/2, cy = h/2 + 4;

  const outerR = Math.min(w,h) * 0.34;
  const innerR = Math.min(w,h) * 0.24;

  // Lemniscate param (Bernoulli-ish), stabilized by kappa and phase
  // Use a smooth figure-8:
  const a = (loop === 1 ? outerR : innerR);
  const t = u * Math.PI*2;

  // Base figure-8:
  let x = a * Math.sin(t);
  let y = a * Math.sin(t) * Math.cos(t);

  // Separation: spread loops horizontally (outer more spread)
  const spread = (loop === 1 ? 1.35 : 1.10);
  x *= spread;

  // Add "immersion twist": a pseudo 3D tilt and a phase-dependent swirl
  const tilt = 0.22 + 0.14*Math.sin(time*0.7 + (loop?1.1:0.2));
  y *= (1.15 + tilt);

  // Add small breathing based on coherence
  const breath = 1 + 0.06*Math.sin(time*1.1) + 0.04*(state.kappa-0.5);
  x *= breath; y *= breath;

  // Translate
  return { x: cx + x, y: cy + y };
}

function draw(){
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;

  // Clear
  ctx.clearRect(0,0,w,h);

  // Back glow
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.beginPath();
  ctx.arc(w/2, h/2, Math.min(w,h)*0.42, 0, Math.PI*2);
  ctx.fillStyle = "rgba(106,167,255,0.18)";
  ctx.fill();
  ctx.restore();

  const time = performance.now()/1000;

  // Draw grid lines
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.lineWidth = 1;
  for(let i=1;i<=6;i++){
    const yy = (h/7)*i;
    ctx.beginPath();
    ctx.moveTo(0,yy);
    ctx.lineTo(w,yy);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.stroke();
  }
  ctx.restore();

  // Draw loops
  function drawLoop(loop, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = loop===1 ? 2.2 : 2.0;
    ctx.beginPath();
    const steps = 320;
    for(let i=0;i<=steps;i++){
      const u = i/steps;
      const p = loopPoint(loop, u, time);
      if(i===0) ctx.moveTo(p.x,p.y);
      else ctx.lineTo(p.x,p.y);
    }
    ctx.strokeStyle = loop===1 ? "rgba(106,167,255,0.95)" : "rgba(52,225,160,0.90)";
    ctx.stroke();
    ctx.restore();
  }

  // Outer loop (field) intensity depends on dilation and prune turbulence
  const outerAlpha = clamp(0.25 + 0.55*(state.dilation-0.85) - 0.30*state.prune, 0.18, 0.85);
  // Inner loop (CST) depends on coherence
  const innerAlpha = clamp(0.25 + 0.70*state.kappa, 0.18, 0.95);

  drawLoop(1, outerAlpha);
  drawLoop(0, innerAlpha);

  // Crossing node location (u=0.5 yields center crossing for this param)
  const cross = loopPoint(1, 0.0, time); // for our param, crossing is around center; use explicit:
  const crossPt = { x: w/2, y: h/2 + 4 };

  // Dyson "sphere" capture ring at crossing
  const dy = state.dyson;
  const pr = state.prune;
  const ringR = 20 + 26*dy;
  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(crossPt.x, crossPt.y, ringR, 0, Math.PI*2);
  ctx.strokeStyle = `rgba(255,210,106,${0.25 + 0.65*dy})`;
  ctx.stroke();

  // Prune/Decay turbulence halo
  ctx.globalAlpha = 0.25 + 0.55*pr;
  ctx.lineWidth = 1.5;
  for(let i=0;i<3;i++){
    const rr = ringR + 10 + i*8 + 7*Math.sin(time*2.2 + i);
    ctx.beginPath();
    ctx.arc(crossPt.x, crossPt.y, rr, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255,107,139,${0.10 + 0.20*pr})`;
    ctx.stroke();
  }

  // Cross label
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(233,240,255,0.92)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("CROSSING: DYSON + PRUNE/DECAY", crossPt.x - 130, crossPt.y - ringR - 16);
  ctx.restore();

  // Particles flow
  const fade = clamp(0.35 + 0.55*state.weight - 0.25*state.prune, 0.15, 0.95);
  for(const p of state.particles){
    const base = loopPoint(p.loop, p.u, time);
    const wob = 4.0 * state.prune * Math.sin(time*6 + p.jitter);
    const x = base.x + wob;
    const y = base.y + wob*0.6;

    // Particle alpha lower when decay is high
    const a = fade * (1 - 0.55*clamp(state.decay,0,1));
    ctx.save();
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(x,y, p.loop===1 ? 2.2 : 2.0, 0, Math.PI*2);
    ctx.fillStyle = (p.loop===1)
      ? `rgba(106,167,255,${0.85})`
      : `rgba(52,225,160,${0.85})`;
    ctx.fill();
    ctx.restore();
  }

  // Titles / axis labels
  ctx.save();
  ctx.globalAlpha = 0.88;
  ctx.fillStyle = "rgba(233,240,255,0.88)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  ctx.fillText("OUTER LOOP (FIELD / DILATION)", 12, 22);
  ctx.fillText("INNER LOOP (CST / NAVIGATION)", 12, 40);

  // Stability indicator
  const k = state.kappa;
  const st = classify(k);
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = st.cls==="ok" ? "rgba(52,225,160,0.95)" : st.cls==="warn" ? "rgba(255,210,106,0.95)" : "rgba(255,107,139,0.95)";
  ctx.fillText("STABILITY: " + st.label, 12, 62);
  ctx.restore();
}

// =========================
// Mini strip chart: κ and ε
// =========================
function drawStrip(){
  const w = strip.getBoundingClientRect().width;
  const h = strip.getBoundingClientRect().height;

  sctx.clearRect(0,0,w,h);

  // background grid
  sctx.save();
  sctx.globalAlpha = 0.15;
  sctx.lineWidth = 1;
  for(let i=1;i<=3;i++){
    const yy = (h/4)*i;
    sctx.beginPath();
    sctx.moveTo(0,yy);
    sctx.lineTo(w,yy);
    sctx.strokeStyle = "rgba(255,255,255,0.12)";
    sctx.stroke();
  }
  sctx.restore();

  const K = state.histK;
  const E = state.histE;
  if(K.length < 2) return;

  // κ line (green-ish via alpha; we don't hard-set colors elsewhere but canvas needs something)
  sctx.save();
  sctx.lineWidth = 2;
  sctx.globalAlpha = 0.95;
  sctx.beginPath();
  for(let i=0;i<K.length;i++){
    const x = (i/(K.length-1))*w;
    const y = (1 - clamp(K[i],0,1))*h;
    if(i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
  }
  sctx.strokeStyle = "rgba(52,225,160,0.95)";
  sctx.stroke();
  sctx.restore();

  // ε line (pink-ish)
  sctx.save();
  sctx.lineWidth = 2;
  sctx.globalAlpha = 0.85;
  sctx.beginPath();
  for(let i=0;i<E.length;i++){
    const x = (i/(E.length-1))*w;
    const y = (clamp(E[i],0,1))*h;
    if(i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
  }
  sctx.strokeStyle = "rgba(255,107,139,0.85)";
  sctx.stroke();
  sctx.restore();

  // Labels
  sctx.save();
  sctx.globalAlpha = 0.8;
  sctx.fillStyle = "rgba(233,240,255,0.85)";
  sctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  sctx.fillText("κ (coherence)", 10, 16);
  sctx.fillText("ε (nav error)", 10, 32);
  sctx.restore();
}

// =========================
// Main loop
// =========================
function frame(now){
  const dt = Math.min(0.05, Math.max(0.001, (now - tPrev)/1000));
  tPrev = now;

  if(running){
    // If no scenario selected, assume a default hazard
    if(!currentScenario){
      // create a fallback scenario quietly
      currentScenario = { hazard: 0.18, name: "Default", key:"default" };
      runMode.textContent = "Default";
      scenarioBadge.textContent = "Default";
    }
    step(dt);
  }

  updateUI();
  draw();
  drawStrip();

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// =========================
// Buttons
// =========================
btnStart.addEventListener("click", ()=>{
  running = true;
  setStatus("RUNNING");
});
btnStop.addEventListener("click", ()=>{
  running = false;
  setStatus("PAUSED");
});
btnReset.addEventListener("click", ()=>{
  running = false;
  setStatus("IDLE");
  // reset tau too
  state.tauSeconds = 0;
  resetState(true);
});

// Default text
setStatus("IDLE");
resetState(false);
</script>
</body>
</html>
