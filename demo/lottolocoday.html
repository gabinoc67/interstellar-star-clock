<!-- ======================= PART 1 / 2 ======================= -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>20-Ticket Tight Coach — Recency (Day-Decay) + Dyson + Prune/Decay + Stokes Pair-Circulation</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    font-size:18px;
  }
  .wrap{max-width:1320px;margin:0 auto;padding:24px 16px 40px}
  h1{margin:4px 0 10px;font-size:2rem}
  h2{margin:16px 0 8px;font-size:1.4rem}
  p{margin:4px 0 10px;color:var(--muted)}
  .grid{
    display:grid;
    grid-template-columns:minmax(0,1.15fr) minmax(0,1fr);
    gap:18px;
    align-items:flex-start;
  }
  .card{
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 0 0 1px rgba(0,0,0,0.4),0 10px 25px rgba(0,0,0,0.55);
  }
  textarea{
    width:100%;
    min-height:190px;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    resize:vertical;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.9rem;
    line-height:1.3;
  }
  label{display:block;font-weight:700;margin:8px 0 4px;color:var(--ink)}
  .controls-row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center}
  button{
    border:none;border-radius:999px;padding:10px 18px;font-size:1rem;font-weight:700;
    cursor:pointer;background:linear-gradient(135deg,var(--accent),#b4d0ff);
    color:#020415;box-shadow:0 4px 12px rgba(0,0,0,0.45);
    display:inline-flex;align-items:center;gap:6px;
  }
  button:active{transform:translateY(1px);box-shadow:0 2px 6px rgba(0,0,0,0.6)}
  .btn-secondary{background:#222a4a;color:var(--ink)}
  .badge{
    display:inline-block;padding:2px 8px;border-radius:999px;font-size:0.78rem;
    font-weight:700;background:#182044;color:var(--muted);border:1px solid var(--grid);
    margin-left:6px;
  }
  .stats{margin-top:8px;font-size:0.95rem}
  .stats-row{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0}
  .pill{padding:3px 9px;border-radius:999px;font-size:0.85rem;border:1px solid var(--grid);background:#050816}
  .pill-hot{ border-color:var(--good); color:var(--good); }
  .pill-warm{ border-color:var(--accent); color:var(--accent); }
  .pill-cold{ border-color:var(--muted); color:var(--muted); }
  .output-box{
    margin-top:10px;background:#050816;border-radius:10px;padding:10px 12px;border:1px solid var(--grid);
    font-family:ui-monospace,Consolas,monospace;font-size:1.05rem;line-height:1.45;
    max-height:520px;overflow:auto;
  }
  .ticket-line{display:flex;justify-content:space-between;align-items:center;padding:3px 0}
  .ticket-label{color:var(--muted);font-size:0.9rem;margin-right:10px}
  .ticket-numbers{letter-spacing:1px}
  .legend{margin-top:6px;font-size:0.9rem;color:var(--muted)}
  .small-note{font-size:0.82rem;color:var(--muted);margin-top:6px}
  .mini-note{font-size:0.84rem;color:var(--muted);margin-top:8px}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .controlbox{background:#0a0f25;border:1px solid var(--grid);border-radius:12px;padding:12px}
  .kv{display:grid;grid-template-columns:190px 1fr;gap:8px;align-items:center}
  input[type="number"], input[type="text"], select{
    width:100%;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    font-size:0.95rem;
  }
  input[type="range"]{width:100%}
  .rangeRow{display:grid;grid-template-columns:1fr 64px;gap:10px;align-items:center}
  .rangeVal{
    text-align:center;
    background:#050816;border:1px solid var(--grid);border-radius:10px;padding:8px 6px;
    font-weight:800;color:var(--ink);
  }
  .checkrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .checkrow label{margin:0;display:flex;gap:8px;align-items:center;color:var(--muted);font-weight:800}
  input[type="checkbox"]{transform:scale(1.15)}
  .hr{height:1px;background:var(--grid);margin:12px 0}
  .mono{font-family:ui-monospace,Consolas,monospace}
  .ok{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
  .tiny{font-size:0.78rem;color:var(--muted);margin-top:6px}
  .kpiGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .kpi{background:#050816;border:1px solid var(--grid);border-radius:10px;padding:10px}
  .kpi b{display:block;margin-bottom:4px}

  @media print {
    body{background:#ffffff;color:#000000;}
    body *{visibility:hidden;}
    #ticketsBox, #ticketsBox *{visibility:visible;}
    #ticketsBox{
      position:absolute;left:0;top:0;width:100%;
      border:none;background:#ffffff;box-shadow:none;font-size:1.1rem;
      max-height:none;overflow:visible;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>20-Ticket Tight Coach</h1>
  <p>
    <strong>Day-decay recency weighting</strong> (τ half-life) + prize-winner anchor + Dyson z-score phases + prune/decay +
    <strong>Stokes-style pair-circulation control</strong> to generate <strong>20 tight lines</strong> (6/54).
  </p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <h2>1. Official Draw History (with dates)</h2>
      <p>
        Paste recent official draws here (e.g., last ~300 draws). Prefer one line per draw using a date:
        <span class="mono">YYYY-MM-DD: n n n n n n</span>
        <span class="badge">best</span>
        <br/>
        Accepted formats: <span class="mono">YYYY-MM-DD</span>, <span class="mono">YYYY/MM/DD</span>, <span class="mono">MM/DD/YYYY</span>.
        If you omit dates, the system uses “Days per draw” as an estimate.
      </p>
      <textarea id="historyInput" placeholder="Example:
2026-01-12: 3 26 11 14 41 35
2026-01-09: 52 39 10 7 19 29
2026-01-06: 18 6 53 42 44 26
..."></textarea>

      <div class="controlbox" style="margin-top:12px;">
        <div style="font-weight:900;margin-bottom:6px;">Recency Day-Decay (Exponential)</div>
        <div class="kv">
          <div>Half-life τ (days)</div>
          <input id="tauDays" type="number" step="1" min="3" max="120" value="21" />
          <div>Days per draw (if no dates)</div>
          <input id="daysPerDraw" type="number" step="0.5" min="1" max="14" value="3.5" />
          <div>Recency strength</div>
          <input id="recencyStrength" type="number" step="0.1" min="0" max="3" value="1.2" />
        </div>
        <div class="mini-note">
          Recency score per number uses: <span class="mono">Σ exp( -age_days / τ )</span>.
          Larger τ = longer memory. Smaller τ = only recent hits matter.
          “Recency strength” multiplies the recency score before mixing into weights.
        </div>
      </div>

      <h2 style="margin-top:18px;">2. Prize / Jackpot Winners (pre-loaded)</h2>
      <p>These prize-winning lines are used as an anchor weight. Exact repeats are blocked.</p>
      <textarea id="winnersInput">
1 2 4 27 40 42
1 3 11 15 16 50
1 3 13 14 22 52
1 4 10 14 15 26
1 6 8 11 15 25
1 6 31 43 44 53
1 7 15 35 43 53
1 9 14 23 29 41
1 10 11 31 38 49
1 12 25 36 39 45
1 16 19 39 42 46
1 25 35 42 48 51
2 3 8 12 25 27
2 3 17 35 41 44
2 5 13 16 23 38
2 6 14 26 36 50
2 6 18 39 40 48
2 6 28 29 46 53
2 7 21 35 43 50
2 8 22 29 35 38
2 9 34 38 43 51
2 11 22 27 33 40
2 14 16 19 25 28
2 19 25 28 30 51
2 23 31 37 41 50
3 4 6 23 34 54
3 4 29 31 33 50
3 5 9 32 36 37
3 5 18 29 30 52
3 6 14 43 44 50
3 6 24 36 38 49
3 8 13 25 33 44
3 9 13 25 30 51
3 11 23 35 41 54
3 13 14 17 31 33
3 16 18 23 40 44
4 5 14 16 18 19
4 10 35 38 41 49
4 11 16 19 27 30
4 12 13 26 39 54
4 13 14 18 26 38
4 14 21 29 34 43
4 14 37 39 51 52
4 19 34 35 40 52
4 21 24 40 43 48
5 6 9 14 27 51
5 6 14 25 36 44
5 7 10 28 31 44
5 8 15 25 40 53
5 9 18 22 35 48
5 9 26 38 41 44
5 10 16 22 26 46
5 10 23 35 41 48
5 11 20 24 27 46
5 13 22 29 37 48
5 14 16 17 39 46
6 7 23 34 37 50
6 11 13 18 26 49
6 11 16 21 25 32
6 14 30 45 49 50
6 20 23 24 31 54
7 9 11 30 33 53
7 10 23 34 46 47
7 14 16 35 48 52
7 15 26 31 51 54
8 10 15 18 26 44
8 11 22 24 30 49
8 13 15 32 37 47
8 14 27 30 47 51
8 16 31 36 38 51
8 19 22 31 41 43
8 19 29 44 46 48
8 21 32 35 45 52
8 25 42 45 47 53
8 34 37 44 46 54
9 10 12 17 37 51
9 13 17 20 26 28
9 15 20 28 39 43
9 19 28 41 45 51
9 20 27 42 51 53
9 28 36 38 41 42
10 14 17 31 38 48
10 14 22 28 40 44
10 16 23 24 48 50
10 27 42 43 47 52
11 21 25 30 32 50
11 28 32 49 51 53
12 15 17 31 38 47
13 24 26 30 36 52
13 36 38 45 46 49
15 17 43 45 47 50
16 17 18 19 21 47
16 17 21 28 41 52
16 34 38 40 49 54
16 36 37 45 49 52
17 23 26 32 38 45
18 19 26 29 32 42
19 21 25 45 47 52
20 24 27 37 39 41
21 23 29 44 47 53
21 25 27 30 36 48
22 33 44 45 47 54
25 26 40 43 46 51
26 27 34 37 48 53
31 35 42 44 51 53
7 17 23 28 39 48
      </textarea>

      <h2 style="margin-top:18px;">3. Tightness Controls</h2>
      <div class="controlbox">
        <div style="font-weight:900;margin-bottom:6px;">Top Pool Slider (18–24)</div>
        <div class="rangeRow">
          <input id="topPool" type="range" min="18" max="24" step="1" value="18" />
          <div class="rangeVal" id="topPoolVal">18</div>
        </div>
        <div class="mini-note">
          Lower = tighter/narrower. For larger buying (80+ tickets), use 22–24 to increase coverage.
        </div>
      </div>

      <div class="subgrid" style="margin-top:12px;">
        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Dyson Sphere Bias</div>
          <div class="kv">
            <div>Capture (0–1)</div>
            <input id="dysonCapture" type="number" step="0.05" min="0" max="1" value="0.55" />
            <div>Field Amp (0–3)</div>
            <input id="dysonAmp" type="number" step="0.1" min="0" max="3" value="1.6" />
            <div>Cooling Suppress (0–2)</div>
            <input id="coolSuppress" type="number" step="0.1" min="0" max="2" value="1.0" />
          </div>
          <div class="mini-note">
            Higher Dyson can tighten again. For “many tickets” mode, keep capture ~0.35–0.55.
          </div>
        </div>

        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Prune & Decay (between tickets)</div>
          <div class="kv">
            <div>Decay Rate</div>
            <input id="decayRate" type="number" step="0.01" min="0" max="0.35" value="0.12" />
            <div>Decay Mode</div>
            <select id="decayMode">
              <option value="row">Decay numbers used per ticket</option>
              <option value="coverage">Extra decay for over-used numbers</option>
              <option value="both" selected>Both</option>
            </select>
            <div>Prune</div>
            <select id="pruneOn">
              <option value="off">Off</option>
              <option value="on" selected>On</option>
            </select>
            <div>Prune Threshold</div>
            <input id="pruneThreshold" type="number" step="0.01" min="0" max="0.25" value="0.12" />
          </div>
          <div class="checkrow">
            <label><input id="decayTargetsOnly" type="checkbox" checked />Decay top-pool only</label>
            <label><input id="microReheat" type="checkbox" checked />Micro re-heat unused</label>
          </div>
          <div class="mini-note">
            Tight default: prune 0.12, decay 0.12. For broader coverage: decay 0.16, top pool 22–24.
          </div>
        </div>
      </div>

      <h2 style="margin-top:18px;">4. Stokes Pair-Circulation Controls</h2>
      <div class="controlbox">
        <div style="font-weight:900;margin-bottom:6px;">Pair Penalty Strength (λ)</div>
        <div class="rangeRow">
          <input id="pairLambda" type="range" min="0" max="0.35" step="0.01" value="0.18" />
          <div class="rangeVal" id="pairLambdaVal">0.18</div>
        </div>
        <div class="checkrow">
          <label><input id="sessionMemoryOn" type="checkbox" checked />Carry memory across batches (20→20→20…)</label>
        </div>
        <div class="tiny">
          Idea: repeated pair reuse = repeated boundary “flow” (circulation). λ penalizes over-used edges to reduce looping and expand coverage.
        </div>
      </div>

      <div class="controls-row" style="margin-top:14px;">
        <button id="analyzeBtn" type="button">Analyze History</button>
        <button id="generateBtn" type="button" class="btn-secondary">Generate 20 Tickets</button>
        <button id="printBtn" type="button" class="btn-secondary">Print 20 Tickets</button>
        <button id="resetSessionBtn" type="button" class="btn-secondary">Reset Session Memory</button>
      </div>

      <div class="small-note">
        Rules: 6 numbers from 1–54. Exact prize lines blocked. Any run of 3+ consecutive numbers blocked.
        Near-duplicates sharing 5/6 numbers are blocked to keep variety.
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2>5. Bands & Dyson Phase Summary</h2>
      <div id="summaryBox" class="stats">Paste history and click <b>Analyze History</b>.</div>

      <div class="legend">
        <span class="pill pill-hot">Hot</span> top weight &nbsp;
        <span class="pill pill-warm">Warm</span> mid &nbsp;
        <span class="pill pill-cold">Cold</span> low weight
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Dyson z-score phases</strong> (computed from your recency-weighted hits)</div>
        <div class="stats-row" id="phaseRow">Analyze history first.</div>
        <div class="mini-note" id="dysonExplain"></div>
      </div>

      <div class="hr"></div>

      <h2>6. Generated 20-Ticket Set</h2>
      <div id="ticketsBox" class="output-box">Click “Generate 20 Tickets” after analyzing.</div>

      <div class="kpiGrid">
        <div class="kpi"><b>Coverage</b><div id="coverageBox" class="mini-note">—</div></div>
        <div class="kpi"><b>Circulation / Pairs</b><div id="pairsBox" class="mini-note">—</div></div>
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Effective pool after prune</strong></div>
        <div id="effectivePool" class="mono">—</div>
        <div class="mini-note">Shows how many Top Pool numbers still carry meaningful weight after prune.</div>
      </div>

      <div class="hr"></div>
      <div class="stats">
        <div><strong>Session Memory</strong> (optional)</div>
        <div id="sessionBox" class="mini-note">No session stats yet.</div>
      </div>

      <div class="hr"></div>
      <div class="stats">
        <div><strong>Recency model check</strong></div>
        <div id="recencyBox" class="mini-note">—</div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const N_MIN = 1;
  const N_MAX = 54;
  const TICKET_SIZE = 6;
  const NUM_TICKETS = 20;

  const historyInput = document.getElementById('historyInput');
  const winnersInput = document.getElementById('winnersInput');

  const tauDaysInput = document.getElementById('tauDays');
  const daysPerDrawInput = document.getElementById('daysPerDraw');
  const recencyStrengthInput = document.getElementById('recencyStrength');

  const summaryBox   = document.getElementById('summaryBox');
  const ticketsBox   = document.getElementById('ticketsBox');
  const analyzeBtn   = document.getElementById('analyzeBtn');
  const generateBtn  = document.getElementById('generateBtn');
  const printBtn     = document.getElementById('printBtn');
  const resetSessionBtn = document.getElementById('resetSessionBtn');

  const topPoolSlider = document.getElementById('topPool');
  const topPoolVal = document.getElementById('topPoolVal');

  const pairLambda = document.getElementById('pairLambda');
  const pairLambdaVal = document.getElementById('pairLambdaVal');
  const sessionMemoryOn = document.getElementById('sessionMemoryOn');

  const dysonCaptureInput = document.getElementById('dysonCapture');
  const dysonAmpInput = document.getElementById('dysonAmp');
  const coolSuppressInput = document.getElementById('coolSuppress');

  const decayRateInput = document.getElementById('decayRate');
  const decayModeInput = document.getElementById('decayMode');
  const pruneOnInput = document.getElementById('pruneOn');
  const pruneThresholdInput = document.getElementById('pruneThreshold');
  const decayTargetsOnlyInput = document.getElementById('decayTargetsOnly');
  const microReheatInput = document.getElementById('microReheat');

  const phaseRowEl = document.getElementById('phaseRow');
  const dysonExplainEl = document.getElementById('dysonExplain');
  const coverageBoxEl = document.getElementById('coverageBox');
  const pairsBoxEl = document.getElementById('pairsBox');
  const effectivePoolEl = document.getElementById('effectivePool');
  const sessionBoxEl = document.getElementById('sessionBox');
  const recencyBoxEl = document.getElementById('recencyBox');

  let lastStats = null;
  let forbiddenSet = new Set();

  // Session memory across batches (optional)
  let sessionUsageCounts = new Array(N_MAX+1).fill(0);
  let sessionPairCounts = new Map(); // key "a-b" -> count
  let sessionTicketsGenerated = 0;

  // ---- helpers ----
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function clamp01(x){ return clamp(x,0,1); }

  function keyForCombo(combo) { return combo.join('-'); }
  function pairKey(a,b){ return (a<b) ? (a+"-"+b) : (b+"-"+a); }

  function parseDateFlexible(s){
    // Accept: YYYY-MM-DD, YYYY/MM/DD, MM/DD/YYYY
    const t = (s||'').trim();
    if (!t) return null;

    let m = t.match(/^(\d{4})[-\/](\d{2})[-\/](\d{2})$/);
    if (m){
      const y = +m[1], mo = +m[2], d = +m[3];
      const dt = new Date(Date.UTC(y, mo-1, d));
      return isNaN(dt.getTime()) ? null : dt;
    }
    m = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (m){
      const mo = +m[1], d = +m[2], y = +m[3];
      const dt = new Date(Date.UTC(y, mo-1, d));
      return isNaN(dt.getTime()) ? null : dt;
    }
    return null;
  }

  function parseHistoryWithDates(text){
    // Lines:
    // 2026-01-12: 3 26 11 14 41 35
    // OR without date: 3 26 11 14 41 35
    const rows = [];
    if (!text) return rows;
    const lines = text.trim().split(/\n+/);

    for (let line of lines){
      line = line.trim();
      if (!line) continue;

      let datePart = null;
      let numsPart = line;

      const colonIdx = line.indexOf(':');
      if (colonIdx >= 0){
        datePart = line.slice(0, colonIdx).trim();
        numsPart = line.slice(colonIdx+1).trim();
      }

      const nums = numsPart.split(/[\s,]+/).map(x => parseInt(x,10)).filter(n => !isNaN(n));
      if (nums.length < TICKET_SIZE) continue;
      const combo = nums.slice(0, TICKET_SIZE).sort((a,b)=>a-b);
      if (!combo.every(n => n>=N_MIN && n<=N_MAX)) continue;

      const dt = datePart ? parseDateFlexible(datePart) : null;
      rows.push({date: dt, combo});
    }
    return rows;
  }

  function parseCombos(text) {
    // winners list (no dates)
    const combos = [];
    if (!text) return combos;
    const lines = text.trim().split(/\n+/);
    for (let line of lines) {
      const nums = line.trim().split(/[\s,]+/).map(x => parseInt(x,10)).filter(n => !isNaN(n));
      if (nums.length >= TICKET_SIZE) {
        const combo = nums.slice(0, TICKET_SIZE).sort((a,b)=>a-b);
        if (combo.every(n => n >= N_MIN && n <= N_MAX)) combos.push(combo);
      }
    }
    return combos;
  }

  function meanStd(values){
    const n = values.length || 1;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  function hasSequenceRun(combo, minLen) {
    let run = 1;
    for (let i = 1; i < combo.length; i++) {
      if (combo[i] === combo[i-1] + 1) { run++; if (run >= minLen) return true; }
      else run = 1;
    }
    return false;
  }

  function median(values){
    const a = values.slice().sort((x,y)=>x-y);
    const n = a.length;
    if(!n) return 0;
    return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
  }

  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // ------------------ Recency Day-Decay core ------------------
  function dayDecayWeight(ageDays, tauDays){
    // exp(-age/tau)
    const tau = Math.max(1e-6, tauDays);
    return Math.exp(-Math.max(0, ageDays) / tau);
  }

  function buildRecencyScores(historyRows){
    const tau = clamp(+tauDaysInput.value || 21, 3, 120);
    const daysPerDraw = clamp(+daysPerDrawInput.value || 3.5, 1, 14);
    const strength = clamp(+recencyStrengthInput.value || 1.2, 0, 3);

    // Determine a reference "latest date" if dates exist
    let maxT = null;
    for (const r of historyRows){
      if (r.date){
        const t = r.date.getTime();
        if (maxT === null || t > maxT) maxT = t;
      }
    }
    // If dates exist, ageDays = (maxDate - date)/86400000
    // If no dates, treat index 0 as newest? We’ll assume input is newest→oldest if no dates.
    // AgeDays = i * daysPerDraw
    const rec = new Array(N_MAX+1).fill(0);

    for (let i=0;i<historyRows.length;i++){
      const row = historyRows[i];
      let ageDays = 0;
      if (row.date && maxT !== null){
        ageDays = (maxT - row.date.getTime()) / 86400000;
      } else {
        ageDays = i * daysPerDraw;
      }
      const w = dayDecayWeight(ageDays, tau);
      for (const n of row.combo){
        rec[n] += w;
      }
    }

    // Scale by strength (so it has controllable influence)
    for (let n=N_MIN; n<=N_MAX; n++){
      rec[n] = rec[n] * strength;
    }

    // Summaries
    const totalRec = rec.reduce((a,b)=>a+b,0);
    const maxRec = Math.max(...rec.slice(N_MIN));
    const minRec = Math.min(...rec.slice(N_MIN));

    return {rec, tau, daysPerDraw, strength, totalRec, maxRec, minRec, hasDates:(maxT!==null)};
  }

  // ------------------ Dyson phases from z-score ------------------
  function computeZPhases(valuesArr){
    const vals = [];
    for (let n=N_MIN; n<=N_MAX; n++) vals.push(valuesArr[n] || 0);
    const {mu, sigma} = meanStd(vals);

    const z = new Array(N_MAX+1).fill(0);
    const phases = {rising:[], neutral:[], cooling:[]};
    for (let n=N_MIN; n<=N_MAX; n++){
      const zz = (sigma>0) ? ((valuesArr[n]-mu)/sigma) : 0;
      z[n] = zz;
      if (zz <= -0.5) phases.rising.push(n);
      else if (Math.abs(zz) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    }
    return {z, phases, mu, sigma};
  }

  function dysonFieldFactor(z, capture, amp, coolSuppress){
    const strength = capture * amp;
    if (strength <= 0) return 1;

    if (z <= -0.5){
      const t = Math.min(1, (-z - 0.5) / 1.5);
      return 1 + (0.8*strength) * (0.6 + 0.4*t);
    }
    if (z >= 0.5){
      const t = Math.min(1, (z - 0.5) / 1.5);
      const sup = (coolSuppress * strength) * (0.6 + 0.4*t);
      return 1 / (1 + sup);
    }
    return 1 + 0.10*strength*(0.5 - Math.abs(z));
  }

  function applyDysonToWeights(baseWeights, zArr){
    const cap = clamp01(+dysonCaptureInput.value || 0);
    const amp = clamp(+dysonAmpInput.value || 0, 0, 3);
    const sup = clamp(+coolSuppressInput.value || 0, 0, 2);
    const out = baseWeights.slice();
    for (let n=N_MIN; n<=N_MAX; n++){
      const factor = dysonFieldFactor(zArr[n] || 0, cap, amp, sup);
      out[n] = Math.max(1e-6, out[n] * factor);
    }
    return out;
  }

  function makeTopPool(weights, k){
    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push([n, weights[n]]);
    arr.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    return new Set(arr.slice(0,k).map(x=>x[0]));
  }

  function pruneWeights(weights, topPoolSet){
    const pruneOn = (pruneOnInput.value === 'on');
    if(!pruneOn) return weights;

    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    const cut = med * threshFrac;
    if (cut <= 0) return weights;

    const out = weights.slice();
    for (let n of topPoolSet){
      if (out[n] < cut) out[n] = 1e-6;
    }
    return out;
  }

  function effectivePoolCount(weights, topPoolSet){
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    if (med <= 0) return {count: topPoolSet.size, cut: 0};
    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const cut = med * threshFrac;
    let c = 0;
    for (let n of topPoolSet) if (weights[n] >= cut) c++;
    return {count:c, cut};
  }

  // ---- Pair-circulation (Stokes-style) picking ----
  function pairPenalty(candidate, chosen, pairCounts){
    let p = 0;
    for (const x of chosen){
      const k = pairKey(candidate, x);
      p += (pairCounts.get(k) || 0);
    }
    return p;
  }

  function weightedPickWithPenalty(available, weights, rng, chosen, pairCounts, lambda){
    const lam = clamp(+lambda || 0, 0, 0.35);
    if (lam <= 0) {
      let total = 0;
      for (const n of available) total += weights[n];
      if (total <= 0) return available[Math.floor(rng()*available.length)];
      let r = rng() * total;
      for (const n of available) { r -= weights[n]; if (r <= 0) return n; }
      return available[available.length-1];
    }

    let total = 0;
    const eff = [];
    for (const n of available){
      const pen = pairPenalty(n, chosen, pairCounts);
      const factor = 1 / (1 + lam * pen);
      const w = Math.max(1e-9, weights[n] * factor);
      eff.push([n, w]);
      total += w;
    }
    if (total <= 0) return available[Math.floor(rng()*available.length)];
    let r = rng() * total;
    for (const [n,w] of eff){ r -= w; if (r <= 0) return n; }
    return eff[eff.length-1][0];
  }

  function generateTicketFromWeights(weights, rng, pairCounts, lambda) {
    const available = [];
    for (let n=N_MIN; n<=N_MAX; n++) available.push(n);

    const combo = [];
    for (let i=0; i<TICKET_SIZE; i++){
      const pick = weightedPickWithPenalty(available, weights, rng, combo, pairCounts, lambda);
      combo.push(pick);
      const idx = available.indexOf(pick);
      if (idx >= 0) available.splice(idx,1);
    }
    combo.sort((a,b)=>a-b);
    return combo;
  }

  function applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet){
    const rate = clamp(+decayRateInput.value || 0, 0, 0.35);
    const mode = decayModeInput.value || 'both';
    const decayTargetsOnly = !!decayTargetsOnlyInput.checked;
    const microReheat = !!microReheatInput.checked;

    const out = weights.slice();

    if (mode === 'row' || mode === 'both'){
      for (const n of ticket){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = Math.max(1e-6, out[n] * (1 - rate));
      }
    }

    if (mode === 'coverage' || mode === 'both'){
      for (let n=N_MIN; n<=N_MAX; n++){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        const c = usageCounts[n] || 0;
        if (c >= 4){
          const extra = Math.min(0.22, rate * 0.75);
          out[n] = Math.max(1e-6, out[n] * (1 - extra));
        }
      }
    }

    if (microReheat){
      const lift = rate * 0.10;
      for (let n=N_MIN; n<=N_MAX; n++){
        if (ticket.includes(n)) continue;
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = out[n] * (1 + lift);
      }
    }

    return out;
  }

  function circulationIndex(pairCounts){
    let s = 0;
    pairCounts.forEach(c => { s += c*c; });
    return s;
  }
  function pairDiversity(pairCounts){
    let c2 = 0;
    pairCounts.forEach(c => { if (c >= 2) c2++; });
    return c2;
  }

  function renderSessionStats(){
    const totalUsed = sessionUsageCounts.reduce((a,b)=>a+b,0);
    const usedNums = sessionUsageCounts.filter(x=>x>0).length;
    const ci = circulationIndex(sessionPairCounts);
    const pd = pairDiversity(sessionPairCounts);
    sessionBoxEl.innerHTML =
      `<div><b>Tickets generated:</b> ${sessionTicketsGenerated}</div>` +
      `<div><b>Unique numbers touched:</b> ${usedNums} / 54</div>` +
      `<div><b>Total picks:</b> ${totalUsed}</div>` +
      `<div><b>Session pair diversity (pairs ≥2):</b> ${pd}</div>` +
      `<div><b>Session circulation index (Σpair²):</b> ${ci}</div>`;
  }

  function syncTopPoolUI(){ topPoolVal.textContent = String(topPoolSlider.value); }
  function syncLambdaUI(){ pairLambdaVal.textContent = (+pairLambda.value).toFixed(2); }
  syncTopPoolUI(); syncLambdaUI();

  topPoolSlider.addEventListener('input', ()=>{ syncTopPoolUI(); maybeRefresh(); });
  pairLambda.addEventListener('input', ()=>{ syncLambdaUI(); maybeRefresh(); });

  resetSessionBtn.addEventListener('click', ()=>{
    sessionUsageCounts = new Array(N_MAX+1).fill(0);
    sessionPairCounts = new Map();
    sessionTicketsGenerated = 0;
    sessionBoxEl.textContent = 'Session memory reset.';
  });

  function renderPhases(stats){
    const r = stats.phases.rising.length;
    const n = stats.phases.neutral.length;
    const c = stats.phases.cooling.length;
    phaseRowEl.innerHTML = `
      <span class="pill pill-hot">Rising (z≤-0.5): <b>${r}</b></span>
      <span class="pill pill-warm">Neutral (|z|&lt;0.5): <b>${n}</b></span>
      <span class="pill pill-cold">Cooling (z≥0.5): <b>${c}</b></span>
    `;
    dysonExplainEl.textContent =
      `Dyson bias uses your recency-weighted z-scores: Rising numbers get boosted, Cooling get suppressed.`;
  }

  function renderStats(stats){
    function fmtList(list){ return list.length ? list.join(' ') : '(none)'; }
    summaryBox.innerHTML = `
      <div><strong>Draws analyzed:</strong> ${stats.drawsCount}</div>
      <div><strong>Recency model:</strong> τ=${stats.recency.tau} days • strength=${stats.recency.strength.toFixed(2)}
        <span class="badge">${stats.recency.hasDates ? 'using dates' : 'no dates → days/draw'}</span>
      </div>
      <div><strong>Avg recency per number:</strong> ${(stats.mu).toFixed(3)}
        <span class="badge">σ ≈ ${(stats.sigma).toFixed(3)}</span>
      </div>
      <div class="stats-row" style="margin-top:8px;">
        <span class="pill pill-hot"><strong>Hot</strong> ${fmtList(stats.hot)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-warm"><strong>Warm</strong> ${fmtList(stats.warm)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-cold"><strong>Cold</strong> ${fmtList(stats.cold)}</span>
      </div>
    `;

    // show top recency numbers quick
    const topRec = stats.rank.slice(0,12).map(o=>`${o.n}(${o.rec.toFixed(2)})`).join('  ');
    recencyBoxEl.innerHTML =
      `<div class="mono"><b>Top recency:</b> ${topRec || '—'}</div>` +
      `<div class="tiny">Each value is Σ exp(-age_days/τ) (scaled by strength). Higher = more recent hits.</div>`;
  }

  function computeStats(historyRows, winnerCombos){
    // Build recency scores (day-decay) from history
    const recency = buildRecencyScores(historyRows);

    // prize boost
    const prizeBoost = new Array(N_MAX + 1).fill(0);
    winnerCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) prizeBoost[n]++; }));

    // Base weights = 1 + recency + (0.6 * prizeBoost)
    const weights = new Array(N_MAX+1).fill(1);
    for (let n=N_MIN; n<=N_MAX; n++){
      const prizeExtra = 0.6 * prizeBoost[n];
      weights[n] = Math.max(1e-6, 1 + recency.rec[n] + prizeExtra);
    }

    // z-score phases computed from recency (NOT raw count)
    const {z, phases, mu, sigma} = computeZPhases(recency.rec);

    // hot/warm/cold bands based on weights (after prize+recency, before Dyson)
    const rank = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      rank.push({n, w:weights[n], rec:recency.rec[n], boost:prizeBoost[n]});
    }
    rank.sort((a,b)=>b.w-a.w || b.rec-a.rec || b.boost-a.boost || a.n-b.n);

    const hotCount=10, warmCount=15;
    const hot  = rank.slice(0, hotCount).map(o=>o.n);
    const warm = rank.slice(hotCount, hotCount+warmCount).map(o=>o.n);
    const cold = rank.slice(hotCount+warmCount).map(o=>o.n);

    return {weights, prizeBoost, z, phases, mu, sigma, hot, warm, cold, drawsCount:historyRows.length, recency, rank};
  }

  analyzeBtn.addEventListener('click', ()=>{
    const historyRows = parseHistoryWithDates(historyInput.value);
    const winnerCombos = parseCombos(winnersInput.value);

    forbiddenSet = new Set();
    winnerCombos.forEach(c => forbiddenSet.add(keyForCombo(c)));

    if (!historyRows.length){
      summaryBox.innerHTML = '<span class="bad"><b>No valid history draws detected.</b> Paste some lines first.</span>';
      phaseRowEl.textContent = 'Analyze history first.';
      dysonExplainEl.textContent = '';
      recencyBoxEl.textContent = '—';
      effectivePoolEl.textContent = '—';
      ticketsBox.textContent = '—';
      coverageBoxEl.textContent = '—';
      pairsBoxEl.textContent = '—';
      return;
    }

    lastStats = computeStats(historyRows, winnerCombos);
    renderStats(lastStats);
    renderPhases(lastStats);

    ticketsBox.textContent = 'History analyzed. Now click “Generate 20 Tickets”.';
    coverageBoxEl.textContent = '—';
    pairsBoxEl.textContent = '—';
    effectivePoolEl.textContent = '—';
  });

  generateBtn.addEventListener('click', ()=> generateTickets(lastStats));

  printBtn.addEventListener('click', ()=>{
    const txt = ticketsBox.textContent.trim();
    if (!txt || txt.includes('Generate 20') || txt.includes('History analyzed') || txt === '—') {
      alert('Generate your 20 tickets first before printing.');
      return;
    }
    window.print();
  });

  function maybeRefresh(){
    if (!lastStats) return;
    const txt = (ticketsBox.textContent || '').trim();
    if (!txt || txt.includes('History analyzed') || txt.includes('Analyze') || txt.includes('Generate')) return;
    generateTickets(lastStats);
  }

  [
    tauDaysInput, daysPerDrawInput, recencyStrengthInput,
    dysonCaptureInput, dysonAmpInput, coolSuppressInput,
    decayRateInput, decayModeInput, pruneOnInput, pruneThresholdInput,
    decayTargetsOnlyInput, microReheatInput, sessionMemoryOn
  ].forEach(el=>{
    el.addEventListener('input', maybeRefresh);
    el.addEventListener('change', maybeRefresh);
  });

  function generateTickets(stats){
    if (!stats){
      ticketsBox.textContent = 'Please analyze history first.';
      return;
    }

    // Step 1: base (recency+prize) -> Dyson
    let weights = applyDysonToWeights(stats.weights, stats.z);

    // Step 2: Top pool
    const TOP_POOL_K = clamp(parseInt(topPoolSlider.value,10) || 18, 18, 24);
    const topPoolSet = makeTopPool(weights, TOP_POOL_K);

    // Step 3: prune in pool
    weights = pruneWeights(weights, topPoolSet);

    // Step 4: downweight outside pool (tightness)
    for (let n=N_MIN; n<=N_MAX; n++){
      if (!topPoolSet.has(n)) weights[n] *= 0.30;
    }

    // Effective pool after prune
    const ep = effectivePoolCount(weights, topPoolSet);
    effectivePoolEl.textContent = `TopPool=${TOP_POOL_K} • pruneCut≈${ep.cut.toFixed(4)} • effective≈${ep.count}/${TOP_POOL_K}`;

    // Batch state
    const tickets = [];
    const seen = new Set(forbiddenSet);
    const usageCounts = new Array(N_MAX+1).fill(0);

    // Pair counts for this batch (optionally seeded from session)
    const batchPairCounts = new Map();
    const useSession = !!sessionMemoryOn.checked;
    if (useSession){
      sessionPairCounts.forEach((c,k)=> batchPairCounts.set(k, Math.round(c * 0.35)));
    }

    const rng = mulberry32((Date.now() ^ (Math.random()*1e9)) >>> 0);
    const lambda = clamp(+pairLambda.value || 0, 0, 0.35);

    let attempts = 0;
    while (tickets.length < NUM_TICKETS && attempts < 14000){
      attempts++;

      const ticket = generateTicketFromWeights(weights, rng, batchPairCounts, lambda);
      const key = keyForCombo(ticket);

      if (seen.has(key)) continue;
      if (hasSequenceRun(ticket, 3)) continue;

      // near-duplicate filter (5/6 overlap)
      let tooSimilar = false;
      for (const t of tickets){
        let common = 0;
        for (const n of ticket) if (t.includes(n)) common++;
        if (common >= 5){ tooSimilar = true; break; }
      }
      if (tooSimilar) continue;

      seen.add(key);
      tickets.push(ticket);

      // update counts
      for (const n of ticket) usageCounts[n]++;

      // update pair counts (Stokes-style “boundary circulation” memory)
      for (let i=0;i<ticket.length;i++){
        for (let j=i+1;j<ticket.length;j++){
          const k = pairKey(ticket[i], ticket[j]);
          batchPairCounts.set(k, (batchPairCounts.get(k)||0) + 1);
        }
      }

      // decay between tickets
      weights = applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet);
      weights = pruneWeights(weights, topPoolSet);
    }

    if (!tickets.length){
      ticketsBox.textContent = 'No tickets generated (constraints too tight). Raise Top Pool or lower prune/decay.';
      coverageBoxEl.textContent = '—';
      pairsBoxEl.textContent = '—';
      return;
    }

    ticketsBox.innerHTML = tickets.map((t,i)=>`
      <div class="ticket-line">
        <span class="ticket-label">#${(i+1).toString().padStart(2,'0')}</span>
        <span class="ticket-numbers">${t.join('  ')}</span>
      </div>
    `).join('');

    // Coverage stats
    const used = new Set();
    tickets.forEach(t=>t.forEach(n=>used.add(n)));
    let inPool = 0;
    used.forEach(n=>{ if (topPoolSet.has(n)) inPool++; });

    const freqList = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      if (usageCounts[n]>0) freqList.push([n, usageCounts[n]]);
    }
    freqList.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const topUsed = freqList.slice(0,12).map(([n,c])=>`${n}(${c})`).join('  ');

    coverageBoxEl.innerHTML =
      `<div><b>Unique numbers used:</b> <b>${used.size}</b> / 54</div>` +
      `<div><b>Inside Top Pool:</b> <b>${inPool}</b> / ${TOP_POOL_K}</div>` +
      `<div class="mono"><b>Most repeated:</b> ${topUsed || '—'}</div>`;

    // Pair diversity + circulation
    const batchPairs2 = pairDiversity(batchPairCounts);
    const batchCI = circulationIndex(batchPairCounts);
    pairsBoxEl.innerHTML =
      `<div><b>Pair diversity (pairs ≥2):</b> <b>${batchPairs2}</b></div>` +
      `<div><b>Circulation index (Σpair²):</b> <b>${batchCI}</b></div>` +
      `<div class="tiny">Lower circulation usually means less “looping” (less repeated pair reuse).</div>`;

    // Update session memory
    if (useSession){
      tickets.forEach(t=>{
        for (const n of t) sessionUsageCounts[n]++;
        for (let i=0;i<t.length;i++){
          for (let j=i+1;j<t.length;j++){
            const k = pairKey(t[i], t[j]);
            sessionPairCounts.set(k, (sessionPairCounts.get(k)||0) + 1);
          }
        }
      });
      sessionTicketsGenerated += tickets.length;
      renderSessionStats();
    } else {
      sessionBoxEl.textContent = 'Session memory is OFF (no cross-batch carry).';
    }
  }
})();
</script>
<!-- ======================= PART 2 / 2 ======================= -->
</body>
</html>
