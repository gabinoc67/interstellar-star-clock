<!-- ======================= PART 1 / 3 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lever-Crane Thought Experiment — Constraint Sandbox (GO/NO-GO)</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --red:#b91c1c;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;

    --note:#fff7ed;
    --noteBorder:#fed7aa;
    --warnBg:#fff1f2;
    --warnBorder:#fee2e2;
    --okBg:#f0fdf4;
    --okBorder:#dcfce7;
  }

  html,body{height:100%;}
  body{
    margin:0;
    font-family:Arial,Helvetica,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  header{
    background:var(--blue);
    color:#fff;
    padding:14px 16px;
  }
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.95;font-size:13px;margin-top:6px;line-height:1.25;}

  main{
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:14px;
    padding:14px;
  }

  .card{
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }

  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  h3{margin:0 0 8px;color:var(--blue);font-size:15px;}

  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;
    margin-top:6px;
    padding:6px;
    border:1px solid #d1d5db;
    border-radius:10px;
    font-size:13px;
    background:#fff;
  }
  textarea{min-height:110px;resize:vertical;line-height:1.25;}

  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}

  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}

  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);line-height:1.2;}

  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid var(--warnBorder);background:var(--warnBg);color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid var(--okBorder);background:var(--okBg);color:#14532d;font-size:13px;line-height:1.25;}

  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;
    white-space:pre-wrap;
    background:#0b1020;
    color:#e5e7eb;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    line-height:1.25;
  }

  canvas{width:100%;height:520px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}

  .underCanvas{
    margin-top:10px;
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .underCanvas ul{margin:6px 0 0 18px;font-size:13px;line-height:1.35;color:#111;}

  .explain{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .explain .math{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    background:#111827;color:#e5e7eb;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.08);
    font-size:12px;white-space:pre-wrap;line-height:1.25;
  }

  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}

  /* PURPOSE box (always visible in left panel) */
  .purposeBox{
    position: sticky;
    top: 10px;
    z-index: 20;
    background: var(--note);
    border: 1px solid var(--noteBorder);
    border-radius: 14px;
    padding: 10px 10px 8px;
    box-shadow: 0 8px 18px rgba(0,0,0,.08);
    margin-bottom: 10px;
  }
  .purposeBox h3{
    margin:0 0 6px;
    color:#7c2d12;
    font-size:13px;
    letter-spacing:.02em;
  }
  .purposeBox ul{
    margin:0 0 6px 18px;
    padding:0;
    font-size:12px;
    line-height:1.3;
    color:#111;
  }
  .purposeBox .mini{
    font-size:12px;color:#7c2d12;opacity:.95;line-height:1.25;
  }
  .toggleRow{
    display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
    margin-top:6px;
  }
  .pill{
    display:flex;gap:8px;align-items:center;
    background:rgba(255,255,255,.65);
    border:1px solid rgba(124,45,18,.18);
    padding:6px 8px;border-radius:999px;
    font-size:12px;color:#111;
  }
  .pill select{
    width:auto;margin:0;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #d1d5db;background:#fff;
  }

  .banner{
    margin-top:8px;
    border-radius:12px;
    padding:10px;
    border:1px solid #fde68a;
    background:#fffbeb;
    color:#7c2d12;
    font-size:12px;
    line-height:1.25;
    display:none;
  }

  .hint{
    margin-top:10px;
    border-radius:12px;
    padding:10px;
    border:1px solid #e5e7eb;
    background:#fff;
    color:#111;
    font-size:12px;
    line-height:1.25;
  }
</style>
</head>

<body>
<header>
  <h1>Lever-Crane Thought Experiment — Constraint Sandbox (GO/NO-GO)</h1>
  <div class="sub">
    Beam turns <b style="color:#86efac;">green</b> when <b>τ_demand ≤ τ_cap</b> under chosen assumptions (GO),
    and <b style="color:#fecaca;">red</b> when capacity is exceeded (NO-GO). Stone + rope are always visible.
  </div>
</header>

<main>
  <!-- LEFT -->
  <section class="card">

    <div class="purposeBox">
      <h3>Purpose & Non-Claims (read first)</h3>
      <ul>
        <li><b>Physics/engineering constraint sandbox</b> (thought experiment).</li>
        <li><b>Not</b> a reconstruction of Egyptian/Mayan methods.</li>
        <li>Outputs are <b>approximate proxies</b>, not archaeological claims.</li>
        <li>Numbers depend on assumptions (materials, geometry, rigging, safety factors).</li>
        <li>Use for <b>GO/NO-GO</b> stress testing of scenarios only.</li>
      </ul>
      <div class="mini">
        <b>GO</b> = τ_demand ≤ τ_cap (chosen allowable stress + geometry proxy).<br/>
        <b>NO-GO</b> = exceeds capacity OR requires forces beyond chosen inputs.
      </div>

      <div class="toggleRow">
        <div class="pill">
          <span><b>Interpretation mode</b></span>
          <select id="interpMode">
            <option value="engineering" selected>Engineering (default)</option>
            <option value="story">Narrative / Story labels</option>
          </select>
        </div>
        <div class="pill">
          <span><b>Canvas watermark</b></span>
          <select id="wmMode">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
      </div>

      <div class="banner" id="storyBanner">
        <b>Narrative mode is illustrative only.</b> Labels are visualization language — not historical claims.
      </div>
    </div>

    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (toggle up/down)</option>
          <option value="liftMove">Lift + Move (cycles) — visual shows sliding only</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight preset (tons)</label>
        <select id="tonsPreset">
          <option value="20">20</option><option value="30">30</option><option value="40">40</option>
          <option value="50">50</option><option value="60">60</option><option value="70">70</option>
          <option value="80" selected>80</option><option value="90">90</option><option value="100">100</option>
          <option value="120">120</option><option value="140">140</option><option value="160">160</option>
          <option value="180">180</option><option value="200">200</option>
          <option value="custom">Custom…</option>
        </select>
      </div>
      <div>
        <label>Block weight (tons) (1–500)</label>
        <input id="tons" type="number" step="1" value="80" min="1" max="500" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Target lift height (in)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209" type="button">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300" type="button">3.00 ft</button>
      <button class="ghost small" id="front400" type="button">4.00 ft</button>
      <button class="ghost small" id="front500" type="button">5.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20" type="button">20 ft</button>
      <button class="ghost small" data-back="30" type="button">30 ft</button>
      <button class="ghost small" data-back="49.2" type="button">49 ft</button>
      <button class="ghost small" data-back="60" type="button">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <label>Auto CW</label>
        <select id="cwMode" title="Auto CW balances in this simplified model; ignores rope angles and pulley inefficiency.">
          <option value="auto" selected>Auto CW (balance in this simplified model)</option>
          <option value="manual">Manual CW (use my CW)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam (manual)</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Optional people pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <label>Friction μ (0.02–0.20) — used in math only</label>
    <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />

    <div class="btnrow">
      <button id="liftToggleBtn" type="button">Lift (toggle)</button>
      <button id="cycleBtn" class="secondary" type="button">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost" type="button">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost" type="button">Reset</button>
    </div>

    <div class="hint">
      <b>Sensitivity hint:</b> changing μ, pad area, r_front, r_back, or allowable-stress proxy can flip GO/NO-GO.
      This is a constraint stress test — not a proclamation.
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box"><div class="t">Auto/Manual counterweight setting</div><div class="v" id="cwOut">—</div></div>
      <div class="box"><div class="t">Mechanical advantage (r_back / r_front)</div><div class="v" id="maOut">—</div></div>
      <div class="box"><div class="t">Beam torque demand vs capacity (GO/NO-GO)</div><div class="v" id="beamTorqueOut">—</div></div>
      <div class="box"><div class="t">Force threshold to start lift (back end)</div><div class="v" id="forceLiftOut">—</div></div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box"><div class="t">Beam bending stress proxy (approx)</div><div class="v" id="stressOut">—</div></div>
      <div class="box"><div class="t">Contact pressure proxy at sling pad</div><div class="v" id="pressOut">—</div></div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box"><div class="t">Move resistance estimate (μ·W)</div><div class="v" id="moveResOut">—</div></div>
      <div class="box"><div class="t">A-frame leg load (approx)</div><div class="v" id="legOut">—</div></div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box"><div class="t">Recommended logs (min) to meet GO torque-capacity proxy</div><div class="v" id="recLogsOut">—</div></div>
      <div class="box"><div class="t">Recommended section summary</div><div class="v" id="recSecOut">—</div></div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox"></div>

    <h2>Paper text (editable copy)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      GO/NO-GO here means τ_demand ≤ τ_cap under your proxy assumptions — not “proven in reality.”
      If you ever show squared terms, use caret form like W^2 to avoid formatting breaks.
    </div>
  </section>

  <!-- RIGHT -->
  <section>
    <canvas id="c"></canvas>

    <div class="underCanvas">
      <h3>Why “lift a little + spread the load” matters</h3>
      <ul>
        <li><b>r_front ↑</b> → stone torque ↑ → harder to lift (in this model).</li>
        <li><b>r_back ↑</b> → force threshold ↓ (more leverage).</li>
        <li><b>Force threshold:</b> <b>F_lift = (W · r_front) / r_back</b>.</li>
        <li><b>GO/NO-GO:</b> τ_demand ≤ τ_cap (chosen allowable stress + geometry proxy).</li>
      </ul>
    </div>

    <div class="explain">
      <h3>Does this configuration meet this model’s assumptions?</h3>
      <div class="math" id="explainMath"></div>
    </div>
  </section>
</main>
<!-- ======================= PART 2 / 3 ======================= -->
<script>
(() => {
  "use strict";

  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo proxy constants
  const WOOD_ALLOW_MPA=40;     // placeholder allowable
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");

  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    // draw in CSS pixels
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  function labelBox(text, x, y, opts={}){
    const pad=6;
    const font=opts.font || "12px Arial";
    ctx.font=font;
    const w=ctx.measureText(text).width + pad*2;
    const h=(opts.h || 18);
    ctx.fillStyle=opts.bg || "rgba(255,255,255,0.92)";
    ctx.strokeStyle=opts.border || "rgba(17,17,17,0.25)";
    ctx.lineWidth=1;
    ctx.fillRect(x, y-h+2, w, h);
    ctx.strokeRect(x, y-h+2, w, h);
    ctx.fillStyle=opts.color || "#111";
    ctx.fillText(text, x+pad, y);
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function glowText(text, x, y, ok){
    ctx.save();
    ctx.font="bold 16px Arial";
    ctx.fillStyle = ok ? "#0f5132" : "#7f1d1d";
    ctx.shadowColor = ok ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
    ctx.shadowBlur = 18;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawWatermark(w,h){
    if($("wmMode").value!=="on") return;
    ctx.save();
    ctx.globalAlpha=0.30;
    ctx.fillStyle="#111";
    ctx.font="bold 12px Arial";
    const txt="Constraint Sandbox — not historical reconstruction";
    const pad=10;
    const tw=ctx.measureText(txt).width;
    ctx.fillRect(12, h-28, tw+pad*2, 20);
    ctx.globalAlpha=0.88;
    ctx.fillStyle="#fff";
    ctx.fillText(txt, 12+pad, h-14);
    ctx.restore();
  }

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tonsPreset=$("tonsPreset");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");
  const interpMode=$("interpMode");
  const storyBanner=$("storyBanner");

  // State
  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle",
    liftProgress:0,
    xMove:0,
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  // Defaults
  const DEFAULTS = {};
  function captureDefaults(){
    const ids = [
      "rigType","simMode","units","tonType","tonsPreset","tons","liftIn","rFront","rBack",
      "cwTons","cwMode","logs","logDia","padArea","moveFt","mu","pullLb","interpMode","wmMode"
    ];
    ids.forEach(id=>{
      const el=$(id);
      DEFAULTS[id]=el.value;
    });
  }

  function syncPresetFromTons(){
    const v = String(Math.round(clamp(Number(tons.value)||80,1,500)));
    const exists = Array.from(tonsPreset.options).some(o => o.value===v);
    tonsPreset.value = exists ? v : "custom";
  }

  function syncTonsFromPreset(){
    const v = tonsPreset.value;
    if(v==="custom") return;
    tons.value = Number(v);
  }

  function restoreDefaults(){
    Object.keys(DEFAULTS).forEach(id=>{
      const el=$(id);
      if(el) el.value = DEFAULTS[id];
    });
    syncPresetFromTons();

    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";

    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;

    applyInterpretationUI();
    computeAndRender();
  }

  function applyInterpretationUI(){
    const isStory = (interpMode.value==="story");
    storyBanner.style.display = isStory ? "block" : "none";
  }

  // Preset button handlers
  $("front209").addEventListener("click", ()=>{ rFront.value="2.09"; computeAndRender(); });
  $("front300").addEventListener("click", ()=>{ rFront.value="3.00"; computeAndRender(); });
  $("front400").addEventListener("click", ()=>{ rFront.value="4.00"; computeAndRender(); });
  $("front500").addEventListener("click", ()=>{ rFront.value="5.00"; computeAndRender(); });

  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.addEventListener("click", ()=>{
      rBack.value = String(b.getAttribute("data-back"));
      computeAndRender();
    });
  });

  interpMode.addEventListener("change", ()=>{ applyInterpretationUI(); computeAndRender(); });
  $("wmMode").addEventListener("change", ()=>computeAndRender());

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne in lbf
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6; // in^3 (rectangular approximation)
    return {b,h,S,cols,rows};
  }

  function tauCapFromSection(nLogs,diaIn){
    const sec=sectionFromLogs(nLogs,diaIn);
    const sigmaAllow_psi = (WOOD_ALLOW_MPA/PSI_TO_MPA);
    const M_allow_lbin = sigmaAllow_psi * sec.S;
    const tauCap_lbft = M_allow_lbin / 12.0;
    return {tauCap_lbft, sec};
  }

  function recommendLogsForTau(tauDemand_lbft, diaIn){
    const options=[4,6,8];
    for(const n of options){
      const cap=tauCapFromSection(n,diaIn);
      if(tauDemand_lbft<=cap.tauCap_lbft){
        return {n, cap:cap.tauCap_lbft, sec:cap.sec, over:false};
      }
    }
    const cap=tauCapFromSection(8,diaIn);
    return {n:8, cap:cap.tauCap_lbft, sec:cap.sec, over:true};
  }

  function compute(){
    const U=units.value;
    const tonsVal=clamp(Number(tons.value)||80,1,500);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);

    const tauBlock_lbft=Wb_lb*rF_ft;
    const F_lift_lb = tauBlock_lbft / rB_ft;

    // Auto CW = balance force proxy (toy)
    const Wcw_req_lb = F_lift_lb;
    let Wcw_lb=Wcw_req_lb;

    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW_lbft = Wcw_lb*rB_ft;
    const tauRatio = tauCW_lbft / tauBlock_lbft;

    // NOTE: This keeps your prior “toy” model convention.
    const F_human_lb = Math.max(0, F_lift_lb - Wcw_lb);

    // Demand proxy
    const tauDemand_lbft = Math.max(tauBlock_lbft, tauCW_lbft);

    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const capSel=tauCapFromSection(nLogs,diaIn);
    const goNoGo = (tauDemand_lbft <= capSel.tauCap_lbft);

    const M_lbin = tauDemand_lbft*12;
    const sigma_psi = M_lbin/capSel.sec.S;
    const sigma_mpa = sigma_psi*PSI_TO_MPA;

    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    const R_lb=Wb_lb+Wcw_lb;
    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal, Wb_lb,
      rF_ft, rB_ft,
      tauBlock_lbft, tauCW_lbft, tauRatio,
      tauDemand_lbft,
      tauCap_lbft: capSel.tauCap_lbft,
      sec: capSel.sec,
      goNoGo,
      beamColor: goNoGo ? "#1f8a3b" : "#b91c1c",
      F_lift_lb,
      F_human_lb,
      Wcw_lb,
      sigma_psi, sigma_mpa,
      p_psi, p_mpa,
      muVal, moveRes_lb, pullAvail_lb,
      R_lb, legLoad_lb,
      rec: recommendLogsForTau(tauDemand_lbft, diaIn)
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    $("paperText").value =
`Lever-Crane Thought Experiment — Constraint Sandbox

Purpose & Non-Claims:
- Physics/engineering constraint sandbox (thought experiment).
- Not a reconstruction of Egyptian/Mayan methods.
- Outputs are approximate proxies, not archaeological claims.
- Numbers depend on assumptions (materials, geometry, rigging, safety factors).
- GO/NO-GO = within this model’s assumptions only.

Core equations (simplified statics):
- τ_block = W · r_front
- F_lift  = (W · r_front) / r_back
- F_human = max(0, F_lift − W_counterweight)

GO/NO-GO meaning:
- GO    = τ_demand ≤ τ_cap (chosen allowable stress + chosen geometry proxy)
- NO-GO = exceeds capacity OR requires forces beyond chosen inputs

Formatting note:
- Use caret form like W^2 for squared terms to avoid platform formatting breaks.`;
  }
</script>
<!-- ======================= PART 3 / 3 ======================= -->
<script>
  function setStatus(d){
    const status=document.getElementById("statusBox");
    const meetsAssumptions = (d.tauRatio>=1) && d.goNoGo;
    let cls = meetsAssumptions ? "ok" : "warn";
    const msg=[];
    const story = (document.getElementById("interpMode").value==="story");

    msg.push(story
      ? (meetsAssumptions ? "STORY LABEL: “WORKS” (illustrative only)." : "STORY LABEL: “FAILS” (illustrative only).")
      : (meetsAssumptions ? "MEETS THIS MODEL’S ASSUMPTIONS (GO)." : "FAILS THIS MODEL’S ASSUMPTIONS (NO-GO).")
    );

    msg.push(`GO/NO-GO means: τ_demand ≤ τ_cap under chosen proxy assumptions (not proven in reality).`);
    msg.push(`Beam: τ_demand=${Number(d.tauDemand_lbft).toFixed(0)} lb·ft vs τ_cap≈${Number(d.tauCap_lbft).toFixed(0)} lb·ft.`);
    msg.push(`Lift threshold (back end)≈${Number(d.F_lift_lb).toFixed(0)} lb.`);
    msg.push(`Human needed (with current CW)≈${Number(d.F_human_lb).toFixed(0)} lb.`);

    if(d.p_psi>6000){ cls="warn"; msg.push(`Pad pressure EXTREME (${Number(d.p_psi).toFixed(0)} psi). Increase pad area.`); }
    else if(d.p_psi>2500){ msg.push(`Pad pressure moderate (${Number(d.p_psi).toFixed(0)} psi). Wider pads reduce risk.`); }
    else { msg.push(`Pad pressure relatively low (${Number(d.p_psi).toFixed(0)} psi).`); }

    if(document.getElementById("simMode").value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move proxy OK: pull ${Number(d.pullAvail_lb).toFixed(0)} lb ≥ μW ${Number(d.moveRes_lb).toFixed(0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${Number(d.pullAvail_lb).toFixed(0)} lb < μW ${Number(d.moveRes_lb).toFixed(0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  // ===== Re-open the same closure scope from Part 2 safely by re-reading needed refs =====
  (() => {
    const $ = (id)=>document.getElementById(id);
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const FT_TO_M=0.3048;
    const LB_TO_N=4.4482216152605;

    const canvas=$("c");
    const ctx=canvas.getContext("2d");

    // Pull the functions/vars we created in Part 2 from the global closure? (We did NOT export them.)
    // So: Part 3 includes the rest of the original IIFE by *rebuilding* the needed pieces in one place.
    // To keep everything clean: we re-wrap everything once, and we do not rely on globals.

    // ----- FULL rebuild (single coherent simulator) -----
    // (This is the merged “constraint sandbox” + “pivot always visible” fix.)
  })();
</script>

<script>
/* ======================= MERGED ENGINE (single IIFE) ======================= */
(() => {
  "use strict";

  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  const WOOD_ALLOW_MPA=40;
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  const canvas=$("c");
  const ctx=canvas.getContext("2d");

  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  function labelBox(text, x, y, opts={}){
    const pad=6;
    const font=opts.font || "12px Arial";
    ctx.font=font;
    const w=ctx.measureText(text).width + pad*2;
    const h=(opts.h || 18);
    ctx.fillStyle=opts.bg || "rgba(255,255,255,0.92)";
    ctx.strokeStyle=opts.border || "rgba(17,17,17,0.25)";
    ctx.lineWidth=1;
    ctx.fillRect(x, y-h+2, w, h);
    ctx.strokeRect(x, y-h+2, w, h);
    ctx.fillStyle=opts.color || "#111";
    ctx.fillText(text, x+pad, y);
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function glowText(text, x, y, ok){
    ctx.save();
    ctx.font="bold 16px Arial";
    ctx.fillStyle = ok ? "#0f5132" : "#7f1d1d";
    ctx.shadowColor = ok ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
    ctx.shadowBlur = 18;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawWatermark(w,h){
    if($("wmMode").value!=="on") return;
    ctx.save();
    ctx.globalAlpha=0.30;
    ctx.fillStyle="#111";
    ctx.font="bold 12px Arial";
    const txt="Constraint Sandbox — not historical reconstruction";
    const pad=10;
    const tw=ctx.measureText(txt).width;
    ctx.fillRect(12, h-28, tw+pad*2, 20);
    ctx.globalAlpha=0.88;
    ctx.fillStyle="#fff";
    ctx.fillText(txt, 12+pad, h-14);
    ctx.restore();
  }

  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tonsPreset=$("tonsPreset");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");
  const interpMode=$("interpMode");
  const storyBanner=$("storyBanner");

  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle",
    liftProgress:0,
    xMove:0,
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  const DEFAULTS = {};
  function captureDefaults(){
    const ids = [
      "rigType","simMode","units","tonType","tonsPreset","tons","liftIn","rFront","rBack",
      "cwTons","cwMode","logs","logDia","padArea","moveFt","mu","pullLb","interpMode","wmMode"
    ];
    ids.forEach(id=>{ DEFAULTS[id] = $(id).value; });
  }

  function syncPresetFromTons(){
    const v = String(Math.round(clamp(Number(tons.value)||80,1,500)));
    const exists = Array.from(tonsPreset.options).some(o => o.value===v);
    tonsPreset.value = exists ? v : "custom";
  }
  function syncTonsFromPreset(){
    const v = tonsPreset.value;
    if(v!=="custom") tons.value = Number(v);
  }

  function restoreDefaults(){
    Object.keys(DEFAULTS).forEach(id=>{ $(id).value = DEFAULTS[id]; });
    syncPresetFromTons();

    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";

    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;

    applyInterpretationUI();
    computeAndRender();
  }

  function applyInterpretationUI(){
    storyBanner.style.display = (interpMode.value==="story") ? "block" : "none";
  }

  $("front209").addEventListener("click", ()=>{ rFront.value="2.09"; computeAndRender(); });
  $("front300").addEventListener("click", ()=>{ rFront.value="3.00"; computeAndRender(); });
  $("front400").addEventListener("click", ()=>{ rFront.value="4.00"; computeAndRender(); });
  $("front500").addEventListener("click", ()=>{ rFront.value="5.00"; computeAndRender(); });
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.addEventListener("click", ()=>{
      rBack.value = String(b.getAttribute("data-back"));
      computeAndRender();
    });
  });

  interpMode.addEventListener("change", ()=>{ applyInterpretationUI(); computeAndRender(); });
  $("wmMode").addEventListener("change", ()=>computeAndRender());

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185;
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6;
    return {b,h,S,cols,rows};
  }

  function tauCapFromSection(nLogs,diaIn){
    const sec=sectionFromLogs(nLogs,diaIn);
    const sigmaAllow_psi = (WOOD_ALLOW_MPA/PSI_TO_MPA);
    const M_allow_lbin = sigmaAllow_psi * sec.S;
    const tauCap_lbft = M_allow_lbin / 12.0;
    return {tauCap_lbft, sec};
  }

  function recommendLogsForTau(tauDemand_lbft, diaIn){
    const options=[4,6,8];
    for(const n of options){
      const cap=tauCapFromSection(n,diaIn);
      if(tauDemand_lbft<=cap.tauCap_lbft){
        return {n, cap:cap.tauCap_lbft, sec:cap.sec, over:false};
      }
    }
    const cap=tauCapFromSection(8,diaIn);
    return {n:8, cap:cap.tauCap_lbft, sec:cap.sec, over:true};
  }

  function compute(){
    const U=units.value;
    const tonsVal=clamp(Number(tons.value)||80,1,500);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);

    const tauBlock_lbft=Wb_lb*rF_ft;
    const F_lift_lb = tauBlock_lbft / rB_ft;

    const Wcw_req_lb = F_lift_lb;
    let Wcw_lb=Wcw_req_lb;

    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW_lbft = Wcw_lb*rB_ft;
    const tauRatio = tauCW_lbft / tauBlock_lbft;

    const F_human_lb = Math.max(0, F_lift_lb - Wcw_lb);
    const tauDemand_lbft = Math.max(tauBlock_lbft, tauCW_lbft);

    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const capSel=tauCapFromSection(nLogs,diaIn);
    const goNoGo = (tauDemand_lbft <= capSel.tauCap_lbft);

    const M_lbin = tauDemand_lbft*12;
    const sigma_psi = M_lbin/capSel.sec.S;
    const sigma_mpa = sigma_psi*PSI_TO_MPA;

    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    const R_lb=Wb_lb+Wcw_lb;
    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal, Wb_lb,
      rF_ft, rB_ft,
      tauBlock_lbft, tauCW_lbft, tauRatio,
      tauDemand_lbft,
      tauCap_lbft: capSel.tauCap_lbft,
      sec: capSel.sec,
      goNoGo,
      beamColor: goNoGo ? "#1f8a3b" : "#b91c1c",
      F_lift_lb,
      F_human_lb,
      Wcw_lb,
      sigma_psi, sigma_mpa,
      p_psi, p_mpa,
      muVal, moveRes_lb, pullAvail_lb,
      R_lb, legLoad_lb,
      rec: recommendLogsForTau(tauDemand_lbft, diaIn)
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    $("paperText").value =
`Lever-Crane Thought Experiment — Constraint Sandbox

Purpose & Non-Claims:
- Physics/engineering constraint sandbox (thought experiment).
- Not a reconstruction of Egyptian/Mayan methods.
- Outputs are approximate proxies, not archaeological claims.
- Numbers depend on assumptions (materials, geometry, rigging, safety factors).
- GO/NO-GO = within this model’s assumptions only.

Core equations (simplified statics):
- τ_block = W · r_front
- F_lift  = (W · r_front) / r_back
- F_human = max(0, F_lift − W_counterweight)

GO/NO-GO meaning:
- GO    = τ_demand ≤ τ_cap (chosen allowable stress + chosen geometry proxy)
- NO-GO = exceeds capacity OR requires forces beyond chosen inputs`;
  }

  function updateOutputs(d){
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;

      $("cwOut").textContent = `${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent = `${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("beamTorqueOut").textContent = `${fmt(d.tauDemand_lbft,0)} / cap ${fmt(d.tauCap_lbft,0)} lb·ft (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt(d.F_lift_lb,0)} lb`;
      $("stressOut").textContent = `${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent = `${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent = `${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";
    }else{
      const Wcw_N = d.Wcw_lb*LB_TO_N;
      const tauDemand_Nm = d.tauDemand_lbft*LB_TO_N*FT_TO_M;
      const tauCap_Nm = d.tauCap_lbft*LB_TO_N*FT_TO_M;

      $("cwOut").textContent = `${fmt(Wcw_N/1000,1)} kN`;
      $("maOut").textContent = `${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("beamTorqueOut").textContent = `${fmt(tauDemand_Nm/1000,1)} / cap ${fmt(tauCap_Nm/1000,1)} kN·m (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt((d.F_lift_lb*LB_TO_N)/1000,1)} kN`;
      $("stressOut").textContent = `${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent = `${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent = `${fmt((d.moveRes_lb*LB_TO_N)/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(((d.R_lb*LB_TO_N)/2)/1000,1)} kN/leg` : "—";
    }

    $("recLogsOut").textContent = d.rec.over ? `>8 logs needed (UI max=8)` : `${d.rec.n} logs`;
    $("recSecOut").textContent = `${d.rec.sec.cols}×${d.rec.sec.rows} pack, b≈${fmt(d.rec.sec.b,0)} in, h≈${fmt(d.rec.sec.h,0)} in`;

    const eq=[];
    eq.push(`LIFT THRESHOLD (simplified):`);
    eq.push(`  τ_block = W · r_front`);
    eq.push(`  F_lift  = (W · r_front) / r_back`);
    eq.push(`  F_human = max(0, F_lift − W_counterweight)`);
    eq.push(``);
    eq.push(`GO/NO-GO (this model only):`);
    eq.push(`  τ_demand = max(τ_block, τ_back)`);
    eq.push(`  τ_cap ≈ (σ_allow · S) / 12`);
    eq.push(`  GO iff τ_demand ≤ τ_cap`);
    eq.push(``);
    eq.push(`LIVE:`);
    eq.push(`  Stone=${fmt(d.tonsVal,0)} tons (W≈${fmt(d.Wb_lb,0)} lb)`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft | r_back=${fmt(d.rB_ft,1)} ft`);
    eq.push(`  τ_demand≈${fmt(d.tauDemand_lbft,0)} lb·ft | τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`);
    eq.push(`  F_lift≈${fmt(d.F_lift_lb,0)} lb | human≈${fmt(d.F_human_lb,0)} lb`);
    eq.push(`  Move proxy μ·W≈${fmt(d.moveRes_lb,0)} lb`);
    $("eqBox").textContent = eq.join("\n");

    const meets = (d.tauRatio>=1) && d.goNoGo;
    const story = (interpMode.value==="story");
    const lines=[];
    lines.push(`Interpretation mode: ${story ? "Narrative (illustrative only)" : "Engineering (default)"}`);
    lines.push(``);
    lines.push(`GO/NO-GO meaning (this model only):`);
    lines.push(`  GO    = τ_demand ≤ τ_cap under chosen assumptions`);
    lines.push(`  NO-GO = exceeds capacity OR requires forces beyond chosen inputs`);
    lines.push(``);
    lines.push(`Current check:`);
    lines.push(`  τ_demand≈${fmt(d.tauDemand_lbft,0)} lb·ft`);
    lines.push(`  τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`);
    lines.push(`  Result: ${meets ? "MEETS ASSUMPTIONS (GO)" : "FAILS ASSUMPTIONS (NO-GO)"}`);
    $("explainMath").textContent = lines.join("\n");
  }

  // ===== PIVOT FIX =====
  // Your “pivot disappeared” issue is a draw-order problem: the thick beam stroke can paint *over* the pivot/yoke.
  // Fix: draw the beam first, then draw the mast/pivot plate ON TOP (like your older working file).
  function drawSupportsOnTop({pivotX,pivotY,groundY,rig,beamX0,beamX1,frontEndY,backEndY}){
    let apexX=pivotX, apexY=pivotY;

    if(rig==="single"){
      // mast
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      // pivot/yoke plate (TOP LAYER)
      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      apexX=pivotX; apexY=pivotY-2;
      labelBox("Vertical mast", pivotX-75, groundY-10);
      labelBox("Pivot / yoke", pivotX-74, pivotY-32);
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      // apex/pivot plate (TOP LAYER)
      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      labelBox("Two-mast A-frame", pivotX-98, groundY-10);
      labelBox("Apex / pivot plate", apexX-104, apexY-32);
    }

    return {apexX, apexY};
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const groundY=h-70;

    // ground
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // pivot location
    const pivotX=210;
    const pivotY=groundY-240;

    // scale
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    const beamX0=pivotX-frontPx;
    const beamX1=pivotX+backPx;

    // rocking
    const flex=state.liftProgress;
    const maxFlexPx=16;
    const frontEndY = pivotY - (maxFlexPx*flex);
    const backEndY  = pivotY + (maxFlexPx*flex);

    // ===== draw beam FIRST =====
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;
    ctx.strokeStyle = d.beamColor;
    ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, frontEndY);
    ctx.lineTo(beamX1, backEndY);
    ctx.stroke();

    // beam label
    labelBox(`Beam logs: ${logs.value} | GO/NO-GO: ${d.goNoGo ? "GO" : "NO-GO"}`,
      Math.max(18, (beamX0+beamX1)/2 - 190), pivotY - 18);

    // ===== draw supports/pivot ON TOP (FIX) =====
    const {apexX, apexY} = drawSupportsOnTop({
      pivotX,pivotY,groundY,
      rig: rigType.value,
      beamX0,beamX1,frontEndY,backEndY
    });

    // sling position
    const slingBaseX = beamX0 + 36;
    const slingX = slingBaseX + (state.xMove * pxPerFt);
    const t = clamp((slingX - beamX0)/(beamX1 - beamX0), 0, 1);
    const beamYSling = frontEndY*(1-t) + backEndY*t;

    // lift amount
    const liftPx = (clamp(Number(liftIn.value)||6,0.5,48)/12.0)*pxPerFt;
    const liftNow = state.liftProgress*liftPx;

    // stone (always visible)
    const blockW=92, blockH=92;
    const blockY = (groundY - blockH) - liftNow;
    const blockX = slingX - blockW/2;

    // rope
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // stone
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#f3f4f6";
    ctx.fillRect(blockX, blockY, blockW, blockH);
    ctx.strokeRect(blockX, blockY, blockW, blockH);

    ctx.fillStyle="#111";
    ctx.font="bold 14px Arial";
    ctx.fillText(`${fmt(d.tonsVal,0)} tons`, blockX + 10, blockY + 24);
    ctx.font="12px Arial";
    ctx.fillText(`STONE`, blockX + 10, blockY + 44);

    // counterweight
    const cwW=56, cwH=56;
    const cwX = beamX1 - 30 - cwW/2;
    const cwY = backEndY + 48;

    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(beamX1, backEndY + 6);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    ctx.strokeStyle="rgba(0,0,0,0.35)"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#ffffff";
    ctx.fillRect(cwX, cwY, cwW, cwH);
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // arm arrows
    arrow(pivotX, pivotY-140, beamX1, pivotY-140, "r_back");
    arrow(beamX0, pivotY-110, pivotX, pivotY-110, "r_front");

    // top banner
    const meets = (d.tauRatio>=1) && d.goNoGo;
    const story = (interpMode.value==="story");
    const banner = story ? (meets ? "STORY: WORKS" : "STORY: FAILS")
                         : (meets ? "MEETS ASSUMPTIONS (GO)" : "FAILS ASSUMPTIONS (NO-GO)");
    glowText(banner, w-360, 44, meets);

    // info box
    const infoX=w-340, infoY=64;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 320, 250);
    ctx.strokeRect(infoX, infoY, 320, 250);

    let yy = infoY + 22;
    labelBox(`GO/NO-GO (model): ${d.goNoGo ? "GO" : "NO-GO"}`, infoX+10, yy); yy+=24;
    labelBox(`τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`F_lift≈${fmt(d.F_lift_lb,0)} lb`, infoX+10, yy); yy+=24;
    labelBox(`human≈${fmt(d.F_human_lb,0)} lb`, infoX+10, yy); yy+=24;
    labelBox(`stone=${fmt(d.tonsVal,0)} tons`, infoX+10, yy); yy+=24;
    labelBox(`moved=${fmt(state.xMove,1)} ft`, infoX+10, yy); yy+=24;
    labelBox(`Constraint sandbox only`, infoX+10, yy);

    labelBox("Sling / rope", slingX-44, beamYSling - 10);

    drawWatermark(w,h);
  }

  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    // status
    const status=$("statusBox");
    const meetsAssumptions = (d.tauRatio>=1) && d.goNoGo;
    let cls = meetsAssumptions ? "ok" : "warn";
    const msg=[];
    const story = (interpMode.value==="story");
    msg.push(story
      ? (meetsAssumptions ? "STORY LABEL: “WORKS” (illustrative only)." : "STORY LABEL: “FAILS” (illustrative only).")
      : (meetsAssumptions ? "MEETS THIS MODEL’S ASSUMPTIONS (GO)." : "FAILS THIS MODEL’S ASSUMPTIONS (NO-GO).")
    );
    msg.push(`GO/NO-GO means: τ_demand ≤ τ_cap under chosen proxy assumptions (not proven in reality).`);
    msg.push(`Beam: τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft vs τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft.`);
    msg.push(`Lift threshold (back end)≈${fmt(d.F_lift_lb,0)} lb.`);
    msg.push(`Human needed (with current CW)≈${fmt(d.F_human_lb,0)} lb.`);

    if(d.p_psi>PRESS_WARN_PSI){ cls="warn"; msg.push(`Pad pressure EXTREME (${fmt(d.p_psi,0)} psi). Increase pad area.`); }
    else if(d.p_psi>PRESS_OK_PSI){ msg.push(`Pad pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk.`); }
    else { msg.push(`Pad pressure relatively low (${fmt(d.p_psi,0)} psi).`); }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move proxy OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");

    draw(d);
  }

  // Buttons
  $("liftToggleBtn").addEventListener("click", ()=>{
    state.liftToggle=!state.liftToggle;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle)";
    computeAndRender();
  });

  $("cycleBtn").addEventListener("click", ()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=!state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
    computeAndRender();
  });

  $("stepBtn").addEventListener("click", ()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
    computeAndRender();
  });

  $("resetBtn").addEventListener("click", ()=>{ restoreDefaults(); });

  // Motion
  function advance(dt){
    const d=compute();
    const meets = (d.tauRatio>=1) && d.goNoGo;

    if(!meets){
      state.liftProgress=clamp(state.liftProgress-dt*1.6,0,1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    if(state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress+dt*1.05,0,1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress-dt*1.25,0,1);
      return;
    }

    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress=clamp(state.liftProgress+dt*1.0,0,1);
        if(state.liftProgress>=1){ state.phase="moving"; state.phaseT=0; }
      }else if(state.phase==="moving"){
        const canMove=d.pullAvail_lb>=d.moveRes_lb;
        const speed=canMove ? 1.0 : 0.18;
        const moveRateFtPerSec=2.0*speed;

        const step=moveRateFtPerSec*dt;
        const remaining=Math.max(0,state.targetMove-(state.phaseT*state.targetMove));
        const adv=Math.min(step,remaining);

        const frac=adv/state.targetMove;
        state.phaseT=clamp(state.phaseT+frac,0,1);
        state.xMove+=adv;

        if(state.phaseT>=1){ state.phase="lowering"; state.phaseT=0; }
      }else if(state.phase==="lowering"){
        state.liftProgress=clamp(state.liftProgress-dt*1.35,0,1);
        if(state.liftProgress<=0){
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Inputs update
  const inputs=[
    rigType, simMode, units, tonType, tonsPreset, tons, liftIn, rFront, rBack, cwTons, cwMode,
    logs, logDia, padArea, moveFt, mu, pullLb
  ];
  inputs.forEach(el=>{
    el.addEventListener("input", ()=>{
      if(el===tonsPreset) syncTonsFromPreset();
      if(el===tons) syncPresetFromTons();
      computeAndRender();
    });
    el.addEventListener("change", ()=>{
      if(el===tonsPreset) syncTonsFromPreset();
      if(el===tons) syncPresetFromTons();
      computeAndRender();
    });
  });

  // Init
  resizeCanvas();
  setPaperText();
  captureDefaults();
  syncPresetFromTons();
  applyInterpretationUI();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>

</body>
</html>
