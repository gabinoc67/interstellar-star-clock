<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Forgotten Lever-Crane Simulator — Go/No-Go Beam Torque + Force Needed (Stone Visible)</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --red:#b91c1c;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;
  }
  html,body{height:100%;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);}
  header{background:var(--blue);color:#fff;padding:14px 16px;}
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.92;font-size:13px;margin-top:5px;line-height:1.25;}
  main{display:grid;grid-template-columns:460px 1fr;gap:14px;padding:14px;}
  .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;margin-top:6px;padding:6px;border:1px solid #d1d5db;border-radius:10px;font-size:13px;background:#fff;
  }
  textarea{min-height:110px;resize:vertical;line-height:1.25;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}
  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);}
  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #fee2e2;background:#fff1f2;color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #dcfce7;background:#f0fdf4;color:#14532d;font-size:13px;line-height:1.25;}
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;white-space:pre-wrap;background:#0b1020;color:#e5e7eb;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.08);line-height:1.25;
  }
  canvas{width:100%;height:520px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}
  .underCanvas{
    margin-top:10px;
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .underCanvas h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .underCanvas p{margin:6px 0;color:#111;font-size:13px;line-height:1.35;}
  .underCanvas ul{margin:6px 0 0 18px;font-size:13px;line-height:1.35;color:#111;}
  .explain{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .explain h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .explain p{margin:6px 0;font-size:13px;line-height:1.35;color:#111;}
  .explain .math{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    background:#111827;color:#e5e7eb;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.08);
    font-size:12px;white-space:pre-wrap;line-height:1.25;
  }
  .diagramWrap{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .diagramWrap h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .diagramImg{
    width:100%;
    height:auto;
    border-radius:12px;
    border:1px solid #e5e7eb;
    display:block;
    background:#fff;
  }
  .diagramNote{
    margin:8px 0 0;
    color:var(--muted);
    font-size:12px;
    line-height:1.25;
  }
  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}
</style>
</head>
<body>
<header>
  <h1>Forgotten Lever-Crane Simulator — Go/No-Go Beam Torque + Force Needed</h1>
  <div class="sub">
    Beam turns <b style="color:#86efac;">green</b> when torque is safe (GO) and <b style="color:#fecaca;">red</b> when torque is too high (NO-GO).
    The stone always stays visible with a rope line connecting the beam to the selected stone.
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="card">
    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (toggle up/down)</option>
          <option value="liftMove">Lift + Move (cycles) — visual shows sliding only</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight preset (tons)</label>
        <select id="tonsPreset">
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="50">50</option>
          <option value="60">60</option>
          <option value="70">70</option>
          <option value="80" selected>80</option>
          <option value="90">90</option>
          <option value="100">100</option>
          <option value="120">120</option>
          <option value="140">140</option>
          <option value="160">160</option>
          <option value="180">180</option>
          <option value="200">200</option>
          <option value="custom">Custom…</option>
        </select>
      </div>
      <div>
        <label>Block weight (tons)</label>
        <input id="tons" type="number" step="1" value="80" min="1" max="500" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Target lift height (in)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300">3.00 ft</button>
      <button class="ghost small" id="front400">4.00 ft</button>
      <button class="ghost small" id="front500">5.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20">20 ft</button>
      <button class="ghost small" data-back="30">30 ft</button>
      <button class="ghost small" data-back="49.2">49 ft</button>
      <button class="ghost small" data-back="60">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <label>CW mode</label>
        <select id="cwMode">
          <option value="auto" selected>Auto: set CW to balance</option>
          <option value="manual">Manual: use my CW</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Optional people pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <label>Friction μ (0.02–0.20) — used in math only</label>
    <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />

    <div class="btnrow">
      <button id="liftToggleBtn">Lift (toggle)</button>
      <button id="cycleBtn" class="secondary">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost">Reset</button>
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box">
        <div class="t">Required counterweight</div>
        <div class="v" id="cwOut">—</div>
      </div>
      <div class="box">
        <div class="t">Mechanical advantage (r_back / r_front)</div>
        <div class="v" id="maOut">—</div>
      </div>
      <div class="box">
        <div class="t">Beam torque tension (Go/No-Go)</div>
        <div class="v" id="beamTorqueOut">—</div>
      </div>
      <div class="box">
        <div class="t">Force needed to lift at back end</div>
        <div class="v" id="forceLiftOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Beam bending stress (approx)</div>
        <div class="v" id="stressOut">—</div>
      </div>
      <div class="box">
        <div class="t">Contact pressure at sling pad</div>
        <div class="v" id="pressOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Move resistance (μ·W) estimate</div>
        <div class="v" id="moveResOut">—</div>
      </div>
      <div class="box">
        <div class="t">A-frame leg load (approx)</div>
        <div class="v" id="legOut">—</div>
      </div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox">Loading…</div>

    <h2>Paper text (editable copy)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      Beam color is a Go/No-Go check on <b>beam torque demand</b> vs estimated <b>beam torque capacity</b>.
    </div>
  </section>

  <!-- RIGHT: CANVAS + UNDER PANEL -->
  <section>
    <canvas id="c"></canvas>

    <div class="underCanvas">
      <h3>Why “lift a little + spread the load” matters</h3>
      <ul>
        <li><b>r_front up</b> → stone torque up → harder to lift.</li>
        <li><b>r_back up</b> → force needed down (more leverage).</li>
        <li><b>Force to lift</b>: <b>F_lift = (W · r_front) / r_back</b>.</li>
        <li><b>Go/No-Go</b>: if beam torque demand exceeds capacity, beam turns red.</li>
      </ul>
    </div>

    <div class="explain">
      <h3>Can this method lift the selected stone?</h3>
      <div class="math" id="explainMath">Loading…</div>
    </div>

    <div class="diagramWrap">
      <h3>Swivel / torque-point concept diagram</h3>
      <img
        class="diagramImg"
        alt="Swivel torque-point diagram"
        src="https://raw.githubusercontent.com/gabinoc67/interstellar-star-clock/main/demo/swiffel.png"
      />
      <p class="diagramNote">Shown under the panel as requested.</p>
    </div>

  </section>
</main>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo thresholds (rough)
  const WOOD_ALLOW_MPA=40; // stress "allowable" demo
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Text drawing helper (prevents overlapping labels by drawing on white box)
  function labelBox(text, x, y, opts={}){
    const pad=6;
    const font=opts.font || "12px Arial";
    ctx.font=font;
    const w=ctx.measureText(text).width + pad*2;
    const h=(opts.h || 18);
    ctx.fillStyle=opts.bg || "rgba(255,255,255,0.92)";
    ctx.strokeStyle=opts.border || "rgba(17,17,17,0.25)";
    ctx.lineWidth=1;
    ctx.fillRect(x, y-h+2, w, h);
    ctx.strokeRect(x, y-h+2, w, h);
    ctx.fillStyle=opts.color || "#111";
    ctx.fillText(text, x+pad, y);
  }

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");
  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*devicePixelRatio);
    canvas.height=Math.floor(r.height*devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tonsPreset=$("tonsPreset");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");

  // Presets
  $("front209").onclick=()=>{ rFront.value=2.09; computeAndRender(); };
  $("front300").onclick=()=>{ rFront.value=3.00; computeAndRender(); };
  $("front400").onclick=()=>{ rFront.value=4.00; computeAndRender(); };
  $("front500").onclick=()=>{ rFront.value=5.00; computeAndRender(); };
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.onclick=()=>{ rBack.value=b.getAttribute("data-back"); computeAndRender(); };
  });

  // State
  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle", // idle, lifting, moving, lowering
    liftProgress:0, // 0..1
    xMove:0, // ft
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne in lbf
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6; // in^3
    return {b,h,S,cols,rows};
  }

  function compute(){
    const U=units.value;
    const tonsVal=Math.max(1,Number(tons.value)||80);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);

    // Stone torque
    const tauBlock_lbft=Wb_lb*rF_ft;

    // Force needed at back end to just start lifting
    const F_lift_lb = tauBlock_lbft / rB_ft;

    // Auto CW uses that balancing force as CW "weight"
    const Wcw_req_lb = F_lift_lb;

    let Wcw_lb=Wcw_req_lb;
    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW_lbft = Wcw_lb*rB_ft;
    const tauRatio = tauCW_lbft / tauBlock_lbft;

    // Beam torque demand
    const tauDemand_lbft = Math.max(tauBlock_lbft, tauCW_lbft);

    // Capacity from allowable stress
    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const sec=sectionFromLogs(nLogs,diaIn);

    const sigmaAllow_psi = (WOOD_ALLOW_MPA/PSI_TO_MPA);
    const M_allow_lbin = sigmaAllow_psi * sec.S;
    const tauCap_lbft = M_allow_lbin / 12.0;

    const goNoGo = (tauDemand_lbft <= tauCap_lbft);

    // Stress estimate
    const M_lbin = tauDemand_lbft*12;
    const sigma_psi = M_lbin/sec.S;
    const sigma_mpa = sigma_psi*PSI_TO_MPA;

    // Contact pressure
    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    // Move resistance
    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    // Reactions
    const R_lb=Wb_lb+Wcw_lb;
    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal,
      Wb_lb, Wb_N:Wb_lb*LB_TO_N,
      rF_ft, rB_ft,
      tauBlock_lbft, tauCW_lbft, tauRatio,
      tauDemand_lbft,
      tauCap_lbft,
      goNoGo,
      beamColor: goNoGo ? "#1f8a3b" : "#b91c1c",
      F_lift_lb, F_lift_N:F_lift_lb*LB_TO_N,
      Wcw_req_lb, Wcw_lb, Wcw_N:Wcw_lb*LB_TO_N,
      sec, sigma_psi, sigma_mpa,
      A_in2, p_psi, p_mpa,
      muVal, moveRes_lb, pullAvail_lb,
      R_lb, legLoad_lb,
      tauDemand_Nm:tauDemand_lbft*LB_TO_N*FT_TO_M,
      tauCap_Nm:tauCap_lbft*LB_TO_N*FT_TO_M
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    const t =
`Go/No-Go beam torque + force-needed model

Core lift physics:
  τ_block = W_block · r_front
  τ_back  = F_back · r_back

Force needed to just start lifting (balance):
  F_lift = (W_block · r_front) / r_back

Go/No-Go beam check:
  τ_demand = max(τ_block, τ_back)
  τ_cap ≈ (σ_allow · S)/12
If τ_demand ≤ τ_cap → GO (beam green), else NO-GO (beam red).`;
    $("paperText").value=t;
  }

  function setStatus(d){
    const status=$("statusBox");
    const liftPossible = (d.tauRatio>=1) && d.goNoGo;

    let cls = liftPossible ? "ok" : "warn";
    const msg=[];
    msg.push(liftPossible ? "LIFT POSSIBLE (GO)." : "NO LIFT (NO-GO).");

    msg.push(`Beam: τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft vs τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft.`);
    msg.push(`Force needed to lift (back end)≈${fmt(d.F_lift_lb,0)} lb.`);

    if(d.p_psi>PRESS_WARN_PSI){
      cls="warn";
      msg.push(`Contact pressure EXTREME (${fmt(d.p_psi,0)} psi). Use wider pads.`);
    }else if(d.p_psi>PRESS_OK_PSI){
      msg.push(`Contact pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk.`);
    }else{
      msg.push(`Contact pressure relatively low (${fmt(d.p_psi,0)} psi).`);
    }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  function updateOutputs(d){
    // Required CW
    let cwDisplay;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwDisplay=`${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent=`${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent=`${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";

      $("beamTorqueOut").textContent = `${fmt(d.tauDemand_lbft,0)} / cap ${fmt(d.tauCap_lbft,0)} lb·ft (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt(d.F_lift_lb,0)} lb`;
    }else{
      cwDisplay=`${fmt(d.Wcw_N/1000,1)} kN`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent=`${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent=`${fmt((d.moveRes_lb*LB_TO_N)/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(((d.R_lb*LB_TO_N)/2)/1000,1)} kN/leg` : "—";

      $("beamTorqueOut").textContent = `${fmt(d.tauDemand_Nm/1000,1)} / cap ${fmt(d.tauCap_Nm/1000,1)} kN·m (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt(d.F_lift_N/1000,1)} kN`;
    }
    $("cwOut").textContent=cwDisplay;

    // Live equations
    const eq=[];
    eq.push(`LIFT FORCE NEEDED:`);
    eq.push(`  τ_block = W · r_front`);
    eq.push(`  F_lift  = (W · r_front) / r_back`);
    eq.push(``);
    eq.push(`BEAM GO/NO-GO:`);
    eq.push(`  τ_demand = max(τ_block, τ_back)`);
    eq.push(`  τ_cap ≈ (σ_allow · S)/12`);
    eq.push(``);
    eq.push(`LIVE:`);
    eq.push(`  Stone=${fmt(d.tonsVal,0)} tons, W=${fmt(d.Wb_lb,0)} lb`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft, r_back=${fmt(d.rB_ft,1)} ft`);
    eq.push(`  τ_block=${fmt(d.tauBlock_lbft,0)} lb·ft`);
    eq.push(`  F_lift≈${fmt(d.F_lift_lb,0)} lb (back end)`);
    eq.push(`  τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`);
    eq.push(`  τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft => ${d.goNoGo ? "GO" : "NO-GO"}`);
    eq.push(`  Beam stress≈${fmt(d.sigma_psi,0)} psi`);
    eq.push(`  Pad pressure≈${fmt(d.p_psi,0)} psi`);
    eq.push(`  Block moved=${fmt(state.xMove,1)} ft`);
    $("eqBox").textContent=eq.join("\n");

    // Explain panel with highlighted lift possible
    const liftPossible = (d.tauRatio>=1) && d.goNoGo;
    const lines=[];
    lines.push(`Lift condition:`);
    lines.push(`  F_lift = (W · r_front) / r_back`);
    lines.push(``);
    lines.push(`Current:`);
    lines.push(`  W_block=${fmt(d.tonsVal,0)} tons`);
    lines.push(`  r_front=${fmt(d.rF_ft,2)} ft`);
    lines.push(`  r_back =${fmt(d.rB_ft,1)} ft`);
    lines.push(`  Force needed ≈ ${d.U==="imperial" ? fmt(d.F_lift_lb,0)+" lb" : fmt(d.F_lift_N/1000,1)+" kN"}`);
    lines.push(`  Beam GO/NO-GO: ${d.goNoGo ? "GO" : "NO-GO"}`);
    lines.push(``);
    lines.push(liftPossible ? "LIFT POSSIBLE (GREEN)" : "NO LIFT (RED)");
    $("explainMath").textContent = lines.join("\n");
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function glowText(text, x, y, ok){
    // Bright highlight: green glow if lift possible, red glow otherwise
    ctx.save();
    ctx.font="bold 16px Arial";
    ctx.fillStyle = ok ? "#0f5132" : "#7f1d1d";
    ctx.shadowColor = ok ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
    ctx.shadowBlur = 18;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const groundY=h-70;

    // ground
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // pivot
    const pivotX=210;
    const pivotY=groundY-240;

    // scale
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    const beamX0=pivotX-frontPx;
    const beamX1=pivotX+backPx;

    // rocking
    const flex=state.liftProgress;
    const maxFlexPx=16;
    const frontEndY = pivotY - (maxFlexPx*flex);
    const backEndY  = pivotY + (maxFlexPx*flex);

    // supports
    let apexX=pivotX, apexY=pivotY;
    if(rigType.value==="single"){
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      apexX=pivotX; apexY=pivotY-2;

      labelBox("Vertical mast", pivotX-75, groundY-10);
      labelBox("Pivot / yoke", pivotX-74, pivotY-32);
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      labelBox("Two-mast A-frame", pivotX-98, groundY-10);
      labelBox("Apex / pivot plate", apexX-104, apexY-32);
    }

    // Beam
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;

    ctx.strokeStyle = d.beamColor;
    ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, frontEndY);
    ctx.lineTo(beamX1, backEndY);
    ctx.stroke();

    // beam label (boxed so it doesn't overlap)
    labelBox(`Beam logs: ${logs.value}  |  GO/NO-GO: ${d.goNoGo ? "GO" : "NO-GO"}`, Math.max(18, (beamX0+beamX1)/2 - 170), pivotY - 18);

    // sling point position (always visible)
    const slingBaseX = beamX0 + 36;
    const moveNowPx = state.xMove * pxPerFt;
    const slingX = slingBaseX + moveNowPx;
    const t = clamp((slingX - beamX0)/(beamX1 - beamX0), 0, 1);
    const beamYSling = frontEndY*(1-t) + backEndY*t;

    // lift amount
    const liftPx = (clamp(Number(liftIn.value)||6,0.5,48)/12.0)*pxPerFt;
    const liftNow = state.liftProgress*liftPx;

    // STONE (always visible)
    const blockW=92, blockH=92;
    const blockBottomY=groundY;
    const blockY = (blockBottomY - blockH) - liftNow;
    const blockX = slingX - blockW/2;

    // rope line from beam to stone (always)
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // stone block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#f3f4f6";
    ctx.fillRect(blockX, blockY, blockW, blockH);
    ctx.strokeRect(blockX, blockY, blockW, blockH);

    // label ON the stone with selected tons
    ctx.fillStyle="#111";
    ctx.font="bold 14px Arial";
    ctx.fillText(`${fmt(d.tonsVal,0)} tons`, blockX + 10, blockY + 24);
    ctx.font="12px Arial";
    ctx.fillText(`STONE`, blockX + 10, blockY + 44);

    // Counterweight follows beam end
    const cwW=56, cwH=56;
    const beamEndX = beamX1;
    const beamEndY = backEndY;

    const cwX = beamEndX - 30 - cwW/2;
    const cwY = beamEndY + 48;

    // rope to CW
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(beamEndX, beamEndY + 6);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // guide line from apex
    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // CW block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#ffffff";
    ctx.fillRect(cwX, cwY, cwW, cwH);
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // CW label box
    let cwText;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwText=`CW: ${fmt(cw_ton,2)} tons`;
    }else{
      cwText=`CW: ${fmt(d.Wcw_N/1000,1)} kN`;
    }
    labelBox("Counterweight", cwX-22, cwY+cwH+18);
    labelBox(cwText, cwX-10, cwY+cwH+38);

    // arm arrows
    arrow(pivotX, pivotY-140, beamX1, pivotY-140, "r_back");
    arrow(beamX0, pivotY-110, pivotX, pivotY-110, "r_front");

    // LIFT POSSIBLE highlight (bright)
    const liftPossible = (d.tauRatio>=1) && d.goNoGo;
    glowText(liftPossible ? "LIFT POSSIBLE" : "NO LIFT", w-260, 44, liftPossible);

    // info panel (boxed + spaced so no overlaps)
    const infoX=w-330, infoY=64;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 300, 206);
    ctx.strokeRect(infoX, infoY, 300, 206);

    // rows of boxed labels inside
    let yy = infoY + 22;
    labelBox(`GO/NO-GO: ${d.goNoGo ? "GO (green)" : "NO-GO (red)"}`, infoX+10, yy); yy+=24;
    labelBox(`τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`Force needed to lift≈${fmt(d.F_lift_lb,0)} lb`, infoX+10, yy); yy+=24;
    labelBox(`r_front=${fmt(d.rF_ft,2)} ft  |  r_back=${fmt(d.rB_ft,1)} ft`, infoX+10, yy); yy+=24;
    labelBox(`Stone=${fmt(d.tonsVal,0)} tons`, infoX+10, yy); yy+=24;
    labelBox(`Lift progress=${fmt(state.liftProgress,2)}  |  moved=${fmt(state.xMove,1)} ft`, infoX+10, yy);

    // small labels near sling / stone to show connection
    labelBox("Sling / rope", slingX-44, beamYSling - 10);
  }

  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    setStatus(d);
    draw(d);
  }

  // Tons preset sync
  function syncPresetFromTons(){
    const val = String(Math.round(Number(tons.value)||80));
    const exists = Array.from(tonsPreset.options).some(o => o.value===val);
    tonsPreset.value = exists ? val : "custom";
  }
  function syncTonsFromPreset(){
    const v = tonsPreset.value;
    if(v==="custom") return;
    tons.value = Number(v);
  }

  // Buttons
  $("liftToggleBtn").onclick=()=>{
    state.liftToggle=!state.liftToggle;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle)";
  };

  $("cycleBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=!state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
  };

  $("stepBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
  };

  $("resetBtn").onclick=()=>{
    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;
    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    computeAndRender();
  };

  // Motion
  function advance(dt){
    const d=compute();
    const liftPossible = (d.tauRatio>=1) && d.goNoGo;

    // If not possible, don't lift; settle down
    if(!liftPossible){
      state.liftProgress=clamp(state.liftProgress-dt*1.6,0,1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    // Lift-only toggle
    if(state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress+dt*1.05,0,1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress-dt*1.25,0,1);
      return;
    }

    // Cycle mode
    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress=clamp(state.liftProgress+dt*1.0,0,1);
        if(state.liftProgress>=1){
          state.phase="moving";
          state.phaseT=0;
        }
      }else if(state.phase==="moving"){
        const canMove=d.pullAvail_lb>=d.moveRes_lb;
        const speed=canMove ? 1.0 : 0.18;
        const moveRateFtPerSec=2.0*speed;

        const step=moveRateFtPerSec*dt;
        const remaining=Math.max(0,state.targetMove-(state.phaseT*state.targetMove));
        const adv=Math.min(step,remaining);

        const frac=adv/state.targetMove;
        state.phaseT=clamp(state.phaseT+frac,0,1);
        state.xMove+=adv;

        if(state.phaseT>=1){
          state.phase="lowering";
          state.phaseT=0;
        }
      }else if(state.phase==="lowering"){
        state.liftProgress=clamp(state.liftProgress-dt*1.35,0,1);
        if(state.liftProgress<=0){
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Inputs
  [
    rigType, simMode, units, tonType, tonsPreset, tons, liftIn,
    rFront, rBack, cwTons, cwMode, logs, logDia, padArea, moveFt, mu, pullLb
  ].forEach(el=>{
    el.addEventListener("input", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
    el.addEventListener("change", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
  });

  // Init
  resizeCanvas();
  setPaperText();
  syncPresetFromTons();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
