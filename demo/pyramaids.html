<!-- ======================= PART 1 / 4 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lever-Crane Thought Experiment — Constraint Sandbox (GO/NO-GO Torque + Force)</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --red:#b91c1c;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;

    --note:#fff7ed;
    --noteBorder:#fed7aa;
    --warnBg:#fff1f2;
    --warnBorder:#fee2e2;
    --okBg:#f0fdf4;
    --okBorder:#dcfce7;
  }

  html,body{height:100%;}
  body{
    margin:0;
    font-family:Arial,Helvetica,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  header{
    background:var(--blue);
    color:#fff;
    padding:14px 16px;
  }
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.95;font-size:13px;margin-top:6px;line-height:1.25;}

  main{
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:14px;
    padding:14px;
  }

  .card{
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }

  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  h3{margin:0 0 8px;color:var(--blue);font-size:15px;}

  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;
    margin-top:6px;
    padding:6px;
    border:1px solid #d1d5db;
    border-radius:10px;
    font-size:13px;
    background:#fff;
  }
  textarea{min-height:110px;resize:vertical;line-height:1.25;}

  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}

  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}

  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);line-height:1.2;}

  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid var(--warnBorder);background:var(--warnBg);color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid var(--okBorder);background:var(--okBg);color:#14532d;font-size:13px;line-height:1.25;}

  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;
    white-space:pre-wrap;
    background:#0b1020;
    color:#e5e7eb;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    line-height:1.25;
  }

  canvas{width:100%;height:520px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}

  .underCanvas{
    margin-top:10px;
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .underCanvas ul{margin:6px 0 0 18px;font-size:13px;line-height:1.35;color:#111;}

  .explain{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .explain .math{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    background:#111827;color:#e5e7eb;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.08);
    font-size:12px;white-space:pre-wrap;line-height:1.25;
  }

  .diagramWrap{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .diagramImg{
    width:100%;
    height:auto;
    border-radius:12px;
    border:1px solid #e5e7eb;
    display:block;
    background:#fff;
  }
  .diagramNote{margin:8px 0 0;color:var(--muted);font-size:12px;line-height:1.25;}

  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}

  /* ---------- PURPOSE BOX (sticky, top-left, always visible) ---------- */
  .purposeBox{
    position: sticky;
    top: 10px;
    z-index: 20;
    background: var(--note);
    border: 1px solid var(--noteBorder);
    border-radius: 14px;
    padding: 10px 10px 8px;
    box-shadow: 0 8px 18px rgba(0,0,0,.08);
    margin-bottom: 10px;
  }
  .purposeBox h3{
    margin:0 0 6px;
    color:#7c2d12;
    font-size:13px;
    letter-spacing:.02em;
  }
  .purposeBox ul{
    margin:0 0 6px 18px;
    padding:0;
    font-size:12px;
    line-height:1.3;
    color:#111;
  }
  .purposeBox .mini{
    font-size:12px;color:#7c2d12;opacity:.95;line-height:1.25;
  }
  .toggleRow{
    display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
    margin-top:6px;
  }
  .pill{
    display:flex;gap:8px;align-items:center;
    background:rgba(255,255,255,.65);
    border:1px solid rgba(124,45,18,.18);
    padding:6px 8px;border-radius:999px;
    font-size:12px;color:#111;
  }
  .pill select{
    width:auto;margin:0;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #d1d5db;background:#fff;
  }
  details{margin-top:8px;}
  details summary{
    cursor:pointer;
    font-weight:900;
    color:#7c2d12;
    font-size:12px;
    user-select:none;
  }
  details .detailBody{
    margin-top:6px;
    font-size:12px;
    color:#111;
    line-height:1.3;
  }

  /* Narrative banner */
  .banner{
    margin-top:8px;
    border-radius:12px;
    padding:10px;
    border:1px solid #fde68a;
    background:#fffbeb;
    color:#7c2d12;
    font-size:12px;
    line-height:1.25;
    display:none;
  }

  /* Sensitivity hint panel */
  .hint{
    margin-top:10px;
    border-radius:12px;
    padding:10px;
    border:1px solid #e5e7eb;
    background:#fff;
    color:#111;
    font-size:12px;
    line-height:1.25;
  }
</style>
</head>
<body>
<header>
  <h1>Lever-Crane Thought Experiment — Constraint Sandbox (GO/NO-GO Torque + Force)</h1>
  <div class="sub">
    Beam turns <b style="color:#86efac;">green</b> when <b>torque demand ≤ torque capacity under selected assumptions</b> (GO),
    and <b style="color:#fecaca;">red</b> when <b>capacity is exceeded or inputs imply infeasible forces</b> (NO-GO).
    The stone is always visible with a rope line to the sling point.
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="card">

    <!-- 1) PURPOSE + NON-CLAIMS (always on screen) -->
    <div class="purposeBox">
      <h3>Purpose & Non-Claims (read first)</h3>
      <ul>
        <li><b>Physics/engineering constraint sandbox</b> (thought experiment).</li>
        <li><b>Not</b> a reconstruction of Egyptian/Mayan methods.</li>
        <li>Outputs are <b>approximate proxies</b>, not archaeological claims.</li>
        <li>Numbers depend on assumptions (materials, geometry, rigging, safety factors).</li>
        <li>Use for <b>GO/NO-GO</b> stress testing of scenarios only.</li>
      </ul>

      <div class="mini" id="goMeaning">
        <b>GO</b> = torque demand ≤ torque capacity (chosen allowable stress + geometry).<br/>
        <b>NO-GO</b> = exceeds capacity OR requires forces beyond your chosen inputs.
      </div>

      <!-- 5) Interpretation Mode + 10) Watermark -->
      <div class="toggleRow">
        <div class="pill">
          <span><b>Interpretation mode</b></span>
          <select id="interpMode" title="Changes wording only (does not change the math).">
            <option value="engineering" selected>Engineering (default)</option>
            <option value="story">Narrative / Story labels</option>
          </select>
        </div>
        <div class="pill">
          <span><b>Canvas watermark</b></span>
          <select id="wmMode" title="Adds the disclaimer onto screenshots.">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
      </div>

      <div class="banner" id="storyBanner">
        <b>Narrative mode is illustrative only.</b> Labels are visualization language — not historical claims, not proof, not reconstruction.
      </div>

      <!-- 6) Assumptions dropdown + 7) Pop-culture quarantined -->
      <details>
        <summary>Assumptions (compact)</summary>
        <div class="detailBody">
          <ul style="margin:6px 0 0 18px;padding:0;">
            <li>Simplified lever statics.</li>
            <li>Simplified bending stress proxy (built-up rectangular section).</li>
            <li>No dynamic shock loading.</li>
            <li>No rope stretch / knot loss / imperfect bearings.</li>
            <li>Material allowable is a demo placeholder (not “wood truth”).</li>
          </ul>
        </div>
      </details>

      <details>
        <summary>Pop-culture analogy (analogy only; not evidence)</summary>
        <div class="detailBody">
          If you keep a “visual analogy” reference, keep it here.
          <b>Analogy only</b> — not offered as historical evidence.
        </div>
      </details>
    </div>

    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (toggle up/down)</option>
          <option value="liftMove">Lift + Move (cycles) — visual shows sliding only</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight preset (tons)</label>
        <select id="tonsPreset">
          <option value="20">20</option><option value="30">30</option><option value="40">40</option>
          <option value="50">50</option><option value="60">60</option><option value="70">70</option>
          <option value="80" selected>80</option><option value="90">90</option><option value="100">100</option>
          <option value="120">120</option><option value="140">140</option><option value="160">160</option>
          <option value="180">180</option><option value="200">200</option>
          <option value="custom">Custom…</option>
        </select>
      </div>
      <div>
        <label>Block weight (tons) (1–500)</label>
        <input id="tons" type="number" step="1" value="80" min="1" max="500" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Target lift height (in)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300">3.00 ft</button>
      <button class="ghost small" id="front400">4.00 ft</button>
      <button class="ghost small" id="front500">5.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20">20 ft</button>
      <button class="ghost small" data-back="30">30 ft</button>
      <button class="ghost small" data-back="49.2">49 ft</button>
      <button class="ghost small" data-back="60">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <!-- 8) stronger label -->
        <label>Auto CW</label>
        <select id="cwMode" title="Auto CW balances in this simplified model; ignores pulley inefficiency and rope angles.">
          <option value="auto" selected>Auto CW (balance in this simplified model)</option>
          <option value="manual">Manual CW (use my CW)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam (manual)</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Optional people pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <label>Friction μ (0.02–0.20) — used in math only</label>
    <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />

    <div class="btnrow">
      <button id="liftToggleBtn">Lift (toggle)</button>
      <button id="cycleBtn" class="secondary">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost">Reset</button>
    </div>

    <!-- 9) Sensitivity hint -->
    <div class="hint">
      <b>Sensitivity hint:</b> if you change μ, pad area, allowable stress proxy, r_front, or r_back, GO/NO-GO can flip.
      This is a constraint stress test — not a proclamation.
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box">
        <div class="t">Auto/Manual counterweight setting</div>
        <div class="v" id="cwOut">—</div>
      </div>
      <div class="box">
        <div class="t">Mechanical advantage (r_back / r_front)</div>
        <div class="v" id="maOut">—</div>
      </div>
      <div class="box">
        <!-- 2) rename definitive -->
        <div class="t">Beam torque demand vs capacity (GO/NO-GO)</div>
        <div class="v" id="beamTorqueOut">—</div>
      </div>
      <div class="box">
        <div class="t">Force threshold to start lift (back end)</div>
        <div class="v" id="forceLiftOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Beam bending stress proxy (approx)</div>
        <div class="v" id="stressOut">—</div>
      </div>
      <div class="box">
        <div class="t">Contact pressure proxy at sling pad</div>
        <div class="v" id="pressOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Move resistance estimate (μ·W)</div>
        <div class="v" id="moveResOut">—</div>
      </div>
      <div class="box">
        <div class="t">A-frame leg load (approx)</div>
        <div class="v" id="legOut">—</div>
      </div>
    </div>

    <!-- NEW: recommended logs needed for 1–500 tons -->
    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Recommended logs (min) to meet GO torque-capacity proxy</div>
        <div class="v" id="recLogsOut">—</div>
      </div>
      <div class="box">
        <div class="t">Recommended section summary</div>
        <div class="v" id="recSecOut">—</div>
      </div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox">Loading…</div>

    <h2>Paper text (editable copy)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      GO/NO-GO here means: <b>τ_demand ≤ τ_cap</b> under your chosen proxy assumptions — not “proven in reality.”
      Also, if you ever show W^2, write it as <b>W^2</b> (caret form) to avoid platform formatting breaks.
    </div>
  </section>

  <!-- RIGHT: CANVAS + UNDER PANEL -->
  <section>
    <canvas id="c"></canvas>

    <div class="underCanvas">
      <h3>Why “lift a little + spread the load” matters</h3>
      <ul>
        <li><b>r_front ↑</b> → stone torque ↑ → harder to lift (in this model).</li>
        <li><b>r_back ↑</b> → force threshold ↓ (more leverage).</li>
        <li><b>Force threshold:</b> <b>F_lift = (W · r_front) / r_back</b>.</li>
        <li><b>GO/NO-GO:</b> τ_demand ≤ τ_cap (chosen allowable stress + geometry proxy).</li>
      </ul>
    </div>

    <div class="explain">
      <h3>Does this configuration meet this model’s assumptions?</h3>
      <div class="math" id="explainMath">Loading…</div>
    </div>

    <div class="diagramWrap">
      <h3>Swivel / torque-point concept diagram</h3>
      <img class="diagramImg" alt="Swivel torque-point diagram"
           src="https://raw.githubusercontent.com/gabinoc67/interstellar-star-clock/main/demo/swiffel.png" />
      <p class="diagramNote">Shown under the panel as requested.</p>
    </div>
  </section>
</main>
<!-- ======================= PART 2 / 4 ======================= -->
<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo thresholds (rough proxies)
  const WOOD_ALLOW_MPA=40;     // demo placeholder allowable
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");
  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*devicePixelRatio);
    canvas.height=Math.floor(r.height*devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  // Text drawing helper
  function labelBox(text, x, y, opts={}){
    const pad=6;
    const font=opts.font || "12px Arial";
    ctx.font=font;
    const w=ctx.measureText(text).width + pad*2;
    const h=(opts.h || 18);
    ctx.fillStyle=opts.bg || "rgba(255,255,255,0.92)";
    ctx.strokeStyle=opts.border || "rgba(17,17,17,0.25)";
    ctx.lineWidth=1;
    ctx.fillRect(x, y-h+2, w, h);
    ctx.strokeRect(x, y-h+2, w, h);
    ctx.fillStyle=opts.color || "#111";
    ctx.fillText(text, x+pad, y);
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function glowText(text, x, y, ok){
    ctx.save();
    ctx.font="bold 16px Arial";
    ctx.fillStyle = ok ? "#0f5132" : "#7f1d1d";
    ctx.shadowColor = ok ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
    ctx.shadowBlur = 18;
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawWatermark(w,h){
    if($("wmMode").value!=="on") return;
    ctx.save();
    ctx.globalAlpha=0.30;
    ctx.fillStyle="#111";
    ctx.font="bold 12px Arial";
    const txt="Constraint Sandbox — not historical reconstruction";
    const pad=10;
    const tw=ctx.measureText(txt).width;
    ctx.fillRect(12, h-28, tw+pad*2, 20);
    ctx.globalAlpha=0.88;
    ctx.fillStyle="#fff";
    ctx.fillText(txt, 12+pad, h-14);
    ctx.restore();
  }

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tonsPreset=$("tonsPreset");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");
  const interpMode=$("interpMode");
  const storyBanner=$("storyBanner");

  // Defaults (so Reset truly restores)
  const DEFAULTS = {};
  function captureDefaults(){
    const ids = [
      "rigType","simMode","units","tonType","tonsPreset","tons","liftIn","rFront","rBack",
      "cwTons","cwMode","logs","logDia","padArea","moveFt","mu","pullLb","interpMode","wmMode"
    ];
    ids.forEach(id=>{
      const el=$(id);
      DEFAULTS[id]=el.value;
    });
  }
  function restoreDefaults(){
    Object.keys(DEFAULTS).forEach(id=>{
      const el=$(id);
      if(!el) return;
      el.value = DEFAULTS[id];
    });
    syncPresetFromTons();

    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";

    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;

    applyInterpretationUI();
    computeAndRender();
  }

  // Preset buttons
  $("front209").onclick=()=>{ rFront.value=2.09; computeAndRender(); };
  $("front300").onclick=()=>{ rFront.value=3.00; computeAndRender(); };
  $("front400").onclick=()=>{ rFront.value=4.00; computeAndRender(); };
  $("front500").onclick=()=>{ rFront.value=5.00; computeAndRender(); };
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.onclick=()=>{ rBack.value=b.getAttribute("data-back"); computeAndRender(); };
  });

  // State
  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle",     // idle, lifting, moving, lowering
    liftProgress:0,   // 0..1
    xMove:0,          // ft
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne in lbf
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6; // in^3 (rectangular approximation)
    return {b,h,S,cols,rows};
  }

  function tauCapFromSection(nLogs,diaIn){
    const sec=sectionFromLogs(nLogs,diaIn);
    const sigmaAllow_psi = (WOOD_ALLOW_MPA/PSI_TO_MPA);
    const M_allow_lbin = sigmaAllow_psi * sec.S;
    const tauCap_lbft = M_allow_lbin / 12.0;
    return {tauCap_lbft, sec};
  }

  function compute(){
    const U=units.value;
    const tonsVal=clamp(Number(tons.value)||80,1,500);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);

    // Stone torque
    const tauBlock_lbft=Wb_lb*rF_ft;

    // Force needed at back end to just start lifting
    const F_lift_lb = tauBlock_lbft / rB_ft;

    // Auto CW uses that balancing force as CW "weight" (toy model)
    const Wcw_req_lb = F_lift_lb;

    let Wcw_lb=Wcw_req_lb;
    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW_lbft = Wcw_lb*rB_ft;
    const tauRatio = tauCW_lbft / tauBlock_lbft;

    // Human force needed (additional to CW, toy model)
    const F_human_lb = Math.max(0, F_lift_lb - Wcw_lb);

    // Beam torque demand
    const tauDemand_lbft = Math.max(tauBlock_lbft, tauCW_lbft);

    // Capacity from selected logs (manual)
    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const capSel=tauCapFromSection(nLogs,diaIn);

    const goNoGo = (tauDemand_lbft <= capSel.tauCap_lbft);

    // Stress estimate
    const M_lbin = tauDemand_lbft*12;
    const sigma_psi = M_lbin/capSel.sec.S;
    const sigma_mpa = sigma_psi*PSI_TO_MPA;

    // Contact pressure
    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    // Move resistance
    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    // Reactions
    const R_lb=Wb_lb+Wcw_lb;
    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal,
      Wb_lb,
      rF_ft, rB_ft,
      tauBlock_lbft, tauCW_lbft, tauRatio,
      tauDemand_lbft,
      tauCap_lbft: capSel.tauCap_lbft,
      sec: capSel.sec,
      goNoGo,
      beamColor: goNoGo ? "#1f8a3b" : "#b91c1c",
      F_lift_lb,
      F_human_lb,
      Wcw_lb,
      sigma_psi, sigma_mpa,
      A_in2, p_psi, p_mpa,
      muVal, moveRes_lb, pullAvail_lb,
      R_lb, legLoad_lb
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  // 5) interpretation UI
  function applyInterpretationUI(){
    const isStory = (interpMode.value==="story");
    storyBanner.style.display = isStory ? "block" : "none";
  }
  interpMode.addEventListener("change", ()=>{ applyInterpretationUI(); computeAndRender(); });
  $("wmMode").addEventListener("change", ()=>computeAndRender());

  function setPaperText(){
    const t =
`Lever-Crane Thought Experiment — Constraint Sandbox

Purpose:
  A physics/engineering constraint sandbox (thought experiment).
  Not a reconstruction of Egyptian/Mayan methods.
  Outputs are approximate proxies, not archaeological claims.

Core lift statics (simplified):
  τ_block = W · r_front
  F_lift  = (W · r_front) / r_back
  F_human = max(0, F_lift − W_counterweight)

GO/NO-GO meaning (within this model’s assumptions):
  GO    = τ_demand ≤ τ_cap (chosen allowable stress + chosen geometry proxy)
  NO-GO = exceeds capacity OR requires forces beyond chosen inputs

Notes:
  Use W^2 caret form if you ever show squared terms to avoid platform formatting issues.`;
    $("paperText").value=t;
  }
<!-- ======================= PART 3 / 4 ======================= -->
<script>
  // Recommended logs calculator (4 / 6 / 8, using current diaIn)
  function recommendLogsForTau(tauDemand_lbft, diaIn){
    const options=[4,6,8];
    for(const n of options){
      const cap=tauCapFromSection(n,diaIn);
      if(tauDemand_lbft<=cap.tauCap_lbft){
        return {n, cap:cap.tauCap_lbft, sec:cap.sec};
      }
    }
    // if none satisfy, return 8 as max in this UI
    const cap=tauCapFromSection(8,diaIn);
    return {n:8, cap:cap.tauCap_lbft, sec:cap.sec, over:true};
  }

  function setStatus(d){
    const status=$("statusBox");
    const meetsAssumptions = (d.tauRatio>=1) && d.goNoGo; // torque balance + beam capacity proxy
    let cls = meetsAssumptions ? "ok" : "warn";
    const msg=[];
    const story = ($("interpMode").value==="story");

    // 2) rename definitive labels
    msg.push(story
      ? (meetsAssumptions ? "STORY LABEL: “WORKS” (illustrative only)." : "STORY LABEL: “FAILS” (illustrative only).")
      : (meetsAssumptions ? "MEETS THIS MODEL’S ASSUMPTIONS (GO)." : "FAILS THIS MODEL’S ASSUMPTIONS (NO-GO).")
    );

    // 3) clarify GO/NO-GO meaning (explicit)
    msg.push(`GO/NO-GO here means: τ_demand ≤ τ_cap under the chosen allowable-stress + geometry proxy.`);

    msg.push(`Beam: τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft vs τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft.`);
    msg.push(`Lift threshold (back end)≈${fmt(d.F_lift_lb,0)} lb.`);
    msg.push(`Human needed (with current CW)≈${fmt(d.F_human_lb,0)} lb.`);

    if(d.p_psi>PRESS_WARN_PSI){
      cls="warn";
      msg.push(`Pad pressure EXTREME (${fmt(d.p_psi,0)} psi). Use wider pads.`);
    }else if(d.p_psi>PRESS_OK_PSI){
      msg.push(`Pad pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk.`);
    }else{
      msg.push(`Pad pressure relatively low (${fmt(d.p_psi,0)} psi).`);
    }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move proxy OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    msg.push("Reminder: this is a constraint sandbox; not a historical reconstruction.");

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  function updateOutputs(d){
    // Counterweight display
    let cwDisplay;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwDisplay=`${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent=`${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent=`${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";
      $("beamTorqueOut").textContent = `${fmt(d.tauDemand_lbft,0)} / cap ${fmt(d.tauCap_lbft,0)} lb·ft (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt(d.F_lift_lb,0)} lb`;
    }else{
      // Metric readouts (still ok, math is same; labels convert)
      const Wcw_N = d.Wcw_lb*LB_TO_N;
      const tauDemand_Nm = d.tauDemand_lbft*LB_TO_N*FT_TO_M;
      const tauCap_Nm = d.tauCap_lbft*LB_TO_N*FT_TO_M;
      cwDisplay=`${fmt(Wcw_N/1000,1)} kN`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent=`${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent=`${fmt((d.moveRes_lb*LB_TO_N)/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(((d.R_lb*LB_TO_N)/2)/1000,1)} kN/leg` : "—";
      $("beamTorqueOut").textContent = `${fmt(tauDemand_Nm/1000,1)} / cap ${fmt(tauCap_Nm/1000,1)} kN·m (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("forceLiftOut").textContent = `${fmt((d.F_lift_lb*LB_TO_N)/1000,1)} kN`;
    }
    $("cwOut").textContent=cwDisplay;

    // Recommended logs needed
    const diaIn = Math.max(6,Number(logDia.value)||12);
    const rec = recommendLogsForTau(d.tauDemand_lbft, diaIn);
    const recTxt = rec.over
      ? `>8 logs needed (UI max=8)`
      : `${rec.n} logs`;
    $("recLogsOut").textContent = recTxt;
    $("recSecOut").textContent = `${rec.sec.cols}×${rec.sec.rows} pack, b≈${fmt(rec.sec.b,0)} in, h≈${fmt(rec.sec.h,0)} in`;

    // 4) formula presentation: keep plain text with caret form where needed
    const eq=[];
    eq.push(`LIFT THRESHOLD (simplified statics):`);
    eq.push(`  τ_block = W · r_front`);
    eq.push(`  F_lift  = (W · r_front) / r_back`);
    eq.push(`  F_human = max(0, F_lift − W_counterweight)`);
    eq.push(``);
    eq.push(`GO/NO-GO MEANING (this model only):`);
    eq.push(`  τ_demand = max(τ_block, τ_back)`);
    eq.push(`  τ_cap ≈ (σ_allow · S)/12  (demo proxy; not “wood truth”)`);
    eq.push(`  GO iff τ_demand ≤ τ_cap`);
    eq.push(``);
    eq.push(`LIVE:`);
    eq.push(`  Stone=${fmt(d.tonsVal,0)} tons, W=${fmt(d.Wb_lb,0)} lb`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft, r_back=${fmt(d.rB_ft,1)} ft`);
    eq.push(`  τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft | τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`);
    eq.push(`  F_lift≈${fmt(d.F_lift_lb,0)} lb | human needed≈${fmt(d.F_human_lb,0)} lb`);
    eq.push(`  Move resistance μ·W≈${fmt(d.moveRes_lb,0)} lb`);
    eq.push(`  Recommended logs (min to meet τ_cap): ${$("recLogsOut").textContent}`);
    $("eqBox").textContent=eq.join("\n");

    // Explain panel
    const meets = (d.tauRatio>=1) && d.goNoGo;
    const story = ($("interpMode").value==="story");
    const lines=[];
    lines.push(`Interpretation mode: ${story ? "Narrative (illustrative only)" : "Engineering (default)"}`);
    lines.push(``);
    lines.push(`GO/NO-GO meaning (this model only):`);
    lines.push(`  GO    = τ_demand ≤ τ_cap under chosen assumptions`);
    lines.push(`  NO-GO = exceeds capacity OR requires forces beyond chosen inputs`);
    lines.push(``);
    lines.push(`Current:`);
    lines.push(`  F_lift = (W · r_front) / r_back`);
    lines.push(`  F_lift≈${fmt(d.F_lift_lb,0)} lb`);
    lines.push(`  Human needed≈${fmt(d.F_human_lb,0)} lb (with current CW)`);
    lines.push(`  τ_demand≈${fmt(d.tauDemand_lbft,0)} lb·ft`);
    lines.push(`  τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`);
    lines.push(``);
    lines.push(story
      ? (meets ? "STORY LABEL: “WORKS” (illustrative only)" : "STORY LABEL: “FAILS” (illustrative only)")
      : (meets ? "MEETS THIS MODEL’S ASSUMPTIONS (GO)" : "FAILS THIS MODEL’S ASSUMPTIONS (NO-GO)")
    );
    $("explainMath").textContent = lines.join("\n");
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const groundY=h-70;

    // ground
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // pivot (kept from your working version)
    const pivotX=210;
    const pivotY=groundY-240;

    // scale
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    const beamX0=pivotX-frontPx;
    const beamX1=pivotX+backPx;

    // rocking
    const flex=state.liftProgress;
    const maxFlexPx=16;
    const frontEndY = pivotY - (maxFlexPx*flex);
    const backEndY  = pivotY + (maxFlexPx*flex);

    // supports
    let apexX=pivotX, apexY=pivotY;
    if(rigType.value==="single"){
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      apexX=pivotX; apexY=pivotY-2;

      labelBox("Vertical mast", pivotX-75, groundY-10);
      labelBox("Pivot / yoke", pivotX-74, pivotY-32);
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      labelBox("Two-mast A-frame", pivotX-98, groundY-10);
      labelBox("Apex / pivot plate", apexX-104, apexY-32);
    }

    // Beam (always visible)
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;
    ctx.strokeStyle = d.beamColor;
    ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, frontEndY);
    ctx.lineTo(beamX1, backEndY);
    ctx.stroke();

    labelBox(`Beam logs: ${logs.value} | GO/NO-GO: ${d.goNoGo ? "GO" : "NO-GO"}`, Math.max(18, (beamX0+beamX1)/2 - 190), pivotY - 18);

    // sling point (always visible)
    const slingBaseX = beamX0 + 36;
    const moveNowPx = state.xMove * pxPerFt;
    const slingX = slingBaseX + moveNowPx;
    const t = clamp((slingX - beamX0)/(beamX1 - beamX0), 0, 1);
    const beamYSling = frontEndY*(1-t) + backEndY*t;

    // lift amount
    const liftPx = (clamp(Number(liftIn.value)||6,0.5,48)/12.0)*pxPerFt;
    const liftNow = state.liftProgress*liftPx;

    // STONE (always visible)
    const blockW=92, blockH=92;
    const blockBottomY=groundY;
    const blockY = (blockBottomY - blockH) - liftNow;
    const blockX = slingX - blockW/2;

    // rope line (always)
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // stone block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#f3f4f6";
    ctx.fillRect(blockX, blockY, blockW, blockH);
    ctx.strokeRect(blockX, blockY, blockW, blockH);

    // label on stone
    ctx.fillStyle="#111";
    ctx.font="bold 14px Arial";
    ctx.fillText(`${fmt(d.tonsVal,0)} tons`, blockX + 10, blockY + 24);
    ctx.font="12px Arial";
    ctx.fillText(`STONE`, blockX + 10, blockY + 44);

    // Counterweight
    const cwW=56, cwH=56;
    const beamEndX = beamX1;
    const beamEndY = backEndY;

    const cwX = beamEndX - 30 - cwW/2;
    const cwY = beamEndY + 48;

    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(beamEndX, beamEndY + 6);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.fillStyle="#ffffff";
    ctx.fillRect(cwX, cwY, cwW, cwH);
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // CW label
    let cwText;
    if(units.value==="imperial"){
      let cw_ton;
      const Wcw_lb=d.Wcw_lb;
      if(tonType.value==="short") cw_ton=Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_lb/2240;
      else cw_ton=Wcw_lb/2204.62262185;
      cwText=`CW: ${fmt(cw_ton,2)} tons`;
    }else{
      cwText=`CW: ${fmt((d.Wcw_lb*LB_TO_N)/1000,1)} kN`;
    }
    labelBox("Counterweight", cwX-22, cwY+cwH+18);
    labelBox(cwText, cwX-10, cwY+cwH+38);

    // arms
    arrow(pivotX, pivotY-140, beamX1, pivotY-140, "r_back");
    arrow(beamX0, pivotY-110, pivotX, pivotY-110, "r_front");

    // 2) rename definitive labels (canvas)
    const meets = (d.tauRatio>=1) && d.goNoGo;
    const story = ($("interpMode").value==="story");
    const banner = story ? (meets ? "STORY: WORKS" : "STORY: FAILS")
                         : (meets ? "MEETS ASSUMPTIONS (GO)" : "FAILS ASSUMPTIONS (NO-GO)");
    glowText(banner, w-360, 44, meets);

    // info panel
    const infoX=w-340, infoY=64;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 320, 250);
    ctx.strokeRect(infoX, infoY, 320, 250);

    let yy = infoY + 22;
    labelBox(`GO/NO-GO (model): ${d.goNoGo ? "GO" : "NO-GO"}`, infoX+10, yy); yy+=24;
    labelBox(`τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`, infoX+10, yy); yy+=24;
    labelBox(`F_lift≈${fmt(d.F_lift_lb,0)} lb`, infoX+10, yy); yy+=24;
    labelBox(`Human needed≈${fmt(d.F_human_lb,0)} lb`, infoX+10, yy); yy+=24;
    labelBox(`r_front=${fmt(d.rF_ft,2)} ft | r_back=${fmt(d.rB_ft,1)} ft`, infoX+10, yy); yy+=24;
    labelBox(`Stone=${fmt(d.tonsVal,0)} tons`, infoX+10, yy); yy+=24;
    labelBox(`Moved=${fmt(state.xMove,1)} ft`, infoX+10, yy); yy+=24;
    labelBox(`Not historical reconstruction`, infoX+10, yy);

    labelBox("Sling / rope", slingX-44, beamYSling - 10);

    // 10) watermark for screenshots
    drawWatermark(w,h);
  }

  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    setStatus(d);
    draw(d);
  }

  // Preset sync
  function syncPresetFromTons(){
    const v = String(Math.round(clamp(Number(tons.value)||80,1,500)));
    const exists = Array.from(tonsPreset.options).some(o => o.value===v);
    tonsPreset.value = exists ? v : "custom";
  }
  function syncTonsFromPreset(){
    const v = tonsPreset.value;
    if(v==="custom") return;
    tons.value = Number(v);
  }

  // Buttons
  $("liftToggleBtn").onclick=()=>{
    state.liftToggle=!state.liftToggle;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle)";
  };

  $("cycleBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=!state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
  };

  $("stepBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
  };

  $("resetBtn").onclick=()=>{ restoreDefaults(); };

  // Motion
  function advance(dt){
    const d=compute();
    const meets = (d.tauRatio>=1) && d.goNoGo;

    // If not meeting assumptions, don't lift; settle down
    if(!meets){
      state.liftProgress=clamp(state.liftProgress-dt*1.6,0,1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    // Lift-only toggle
    if(state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress+dt*1.05,0,1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress-dt*1.25,0,1);
      return;
    }

    // Cycle mode
    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress=clamp(state.liftProgress+dt*1.0,0,1);
        if(state.liftProgress>=1){
          state.phase="moving";
          state.phaseT=0;
        }
      }else if(state.phase==="moving"){
        const canMove=d.pullAvail_lb>=d.moveRes_lb;
        const speed=canMove ? 1.0 : 0.18;
        const moveRateFtPerSec=2.0*speed;

        const step=moveRateFtPerSec*dt;
        const remaining=Math.max(0,state.targetMove-(state.phaseT*state.targetMove));
        const adv=Math.min(step,remaining);

        const frac=adv/state.targetMove;
        state.phaseT=clamp(state.phaseT+frac,0,1);
        state.xMove+=adv;

        if(state.phaseT>=1){
          state.phase="lowering";
          state.phaseT=0;
        }
      }else if(state.phase==="lowering"){
        state.liftProgress=clamp(state.liftProgress-dt*1.35,0,1);
        if(state.liftProgress<=0){
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Input listeners (fix: all selectors work)
  [
    rigType, simMode, units, tonType, tonsPreset, tons, liftIn,
    rFront, rBack, cwTons, cwMode, logs, logDia, padArea, moveFt, mu, pullLb,
    $("wmMode")
  ].forEach(el=>{
    el.addEventListener("input", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
    el.addEventListener("change", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
  });

  // Init
  resizeCanvas();
  setPaperText();
  captureDefaults();
  syncPresetFromTons();
  applyInterpretationUI();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>
<!-- ======================= PART 4 / 4 ======================= -->
</body>
</html>
