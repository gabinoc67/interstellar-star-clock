<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Forgotten Lever-Crane Simulator — 80-Ton Lift + Move (Ropes Follow Beam Ends + A-Frame)</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;
  }
  html,body{height:100%;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);}
  header{background:var(--blue);color:#fff;padding:14px 16px;}
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.92;font-size:13px;margin-top:5px;line-height:1.25;}
  main{display:grid;grid-template-columns:460px 1fr;gap:14px;padding:14px;}
  .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;margin-top:6px;padding:6px;border:1px solid #d1d5db;border-radius:10px;font-size:13px;background:#fff;
  }
  textarea{min-height:110px;resize:vertical;line-height:1.25;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}
  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);}
  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #fee2e2;background:#fff1f2;color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #dcfce7;background:#f0fdf4;color:#14532d;font-size:13px;line-height:1.25;}
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;white-space:pre-wrap;background:#0b1020;color:#e5e7eb;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.08);line-height:1.25;
  }
  .underCanvas{
    margin-top:10px;
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .underCanvas h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .underCanvas p{margin:6px 0;color:#111;font-size:13px;line-height:1.35;}
  .underCanvas ul{margin:6px 0 0 18px;font-size:13px;line-height:1.35;color:#111;}
  canvas{width:100%;height:520px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}
  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}
</style>
</head>
<body>
<header>
  <h1>Forgotten Lever-Crane Simulator — 80-Ton Lift + Move (Rope Ends Follow Beam Ends)</h1>
  <div class="sub">
    Updates: counterweight rope attaches to the <b>beam end</b> (not floating), and it <b>moves down when lifting</b> and <b>moves up when lowering</b> because it follows the rocking beam.
    The math panel shows torque balance and why long back-arm distance reduces required counterweight.
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="card">
    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (toggle up/down)</option>
          <option value="liftMove">Lift + Move (rollers) (cycles)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight (tons)</label>
        <input id="tons" type="number" step="1" value="80" min="1" />
      </div>
      <div>
        <label>Target lift height (in)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300">3.00 ft</button>
      <button class="ghost small" id="front400">4.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20">20 ft</button>
      <button class="ghost small" data-back="30">30 ft</button>
      <button class="ghost small" data-back="49.2">49 ft</button>
      <button class="ghost small" data-back="60">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <label>CW mode</label>
        <select id="cwMode">
          <option value="auto" selected>Auto: set CW to balance</option>
          <option value="manual">Manual: use my CW</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Roller/skid friction μ (0.02–0.20)</label>
        <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />
      </div>
      <div>
        <label>Optional pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <div class="btnrow">
      <button id="liftToggleBtn">Lift (toggle)</button>
      <button id="cycleBtn" class="secondary">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost">Reset</button>
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box">
        <div class="t">Required counterweight</div>
        <div class="v" id="cwOut">—</div>
      </div>
      <div class="box">
        <div class="t">Mechanical advantage (r_back / r_front)</div>
        <div class="v" id="maOut">—</div>
      </div>
      <div class="box">
        <div class="t">Beam bending stress (approx)</div>
        <div class="v" id="stressOut">—</div>
      </div>
      <div class="box">
        <div class="t">Contact pressure at sling pad</div>
        <div class="v" id="pressOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Move resistance (μ·W) estimate</div>
        <div class="v" id="moveResOut">—</div>
      </div>
      <div class="box">
        <div class="t">A-frame leg load (approx)</div>
        <div class="v" id="legOut">—</div>
      </div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox">Loading…</div>

    <h2>Paper text (editable copy)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      Requested fixes included: counterweight rope drops when block rises (beam rocks), rope attaches at beam end, block returns to ground when lowered,
      and the explanation panel below the image addresses why dragging/pulling would scrape surfaces and why direct logs-on-stone would leave cracks.
    </div>
  </section>

  <!-- RIGHT: CANVAS + UNDER PANEL -->
  <section>
    <canvas id="c"></canvas>

    <div class="underCanvas">
      <h3>Why “lift a little + spread the load” matters (no cracks / ship loading / Stonehenge-style logic)</h3>
      <p>
        If you pull a multi-ton block by dragging it, the friction force is enormous and the block would tend to <b>scrape, chip, and gouge</b> surfaces.
        Likewise, if you place bare logs directly under sharp contact points, the pressure concentrates and can leave <b>crush marks, spalls, or cracks</b>.
        That’s why a practical ancient method would favor a cycle of <b>small controlled lift</b> plus <b>rollers/skids</b> and <b>wide pads</b>:
      </p>
      <ul>
        <li><b>Lift only a few inches</b> (enough to insert rollers/skids), not “super high.”</li>
        <li><b>Spread contact pressure</b> using wide sling pads and built-up beams (multiple lashed logs) to reduce local crushing.</li>
        <li><b>Move on rollers</b> so the effective friction coefficient μ is small (the required pull ≈ μ·W drops dramatically).</li>
        <li><b>A-frame support</b> reduces sideways stress on the mast and spreads the reaction into two legs—useful on uneven ground or on a ship deck.</li>
        <li><b>Ship loading idea</b>: a counterbalanced rig can load/unload heavy stones with lower peak forces into the structure because the lift is controlled and the beam shares stress.</li>
      </ul>
      <p>
        You said you couldn’t find this technique written clearly. It’s plausible that a real method like this could be transmitted
        <b>word-by-word through stories and apprenticeship</b> (showing and doing), not preserved as a formal engineering manual.
        A famous example you referenced—builders using a tripod to move heavy stones—fits the same family of ideas:
        <b>mechanical advantage + controlled lift + load spreading</b>, which could also be relevant to Stonehenge-type stone placement.
      </p>
    </div>
  </section>
</main>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo thresholds (rough)
  const WOOD_ALLOW_MPA=40;
  const WOOD_WARN_MPA=60;
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");
  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*devicePixelRatio);
    canvas.height=Math.floor(r.height*devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");

  // Presets
  $("front209").onclick=()=>{ rFront.value=2.09; computeAndRender(); };
  $("front300").onclick=()=>{ rFront.value=3.00; computeAndRender(); };
  $("front400").onclick=()=>{ rFront.value=4.00; computeAndRender(); };
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.onclick=()=>{ rBack.value=b.getAttribute("data-back"); computeAndRender(); };
  });

  // State
  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle", // idle, lifting, moving, lowering
    liftProgress:0, // 0..1
    xMove:0, // ft
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne (weight in lbf)
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6;
    return {b,h,S,cols,rows};
  }

  function compute(){
    const U=units.value;
    const tonsVal=Math.max(1,Number(tons.value)||80);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);
    const tauBlock=Wb_lb*rF_ft;

    const Wcw_req_lb=tauBlock/rB_ft;
    let Wcw_lb=Wcw_req_lb;

    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW=Wcw_lb*rB_ft;
    const tauRatio=tauCW/tauBlock;

    const R_lb=Wb_lb+Wcw_lb;
    const M_lbft=Math.max(tauBlock,tauCW);

    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const sec=sectionFromLogs(nLogs,diaIn);

    const M_lbin=M_lbft*12;
    const sigma_psi=M_lbin/sec.S;
    const sigma_mpa=sigma_psi*PSI_TO_MPA;

    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    const MA=rB_ft/rF_ft;
    const liftTargetIn=clamp(Number(liftIn.value)||6,0.5,48);

    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal, Wb_lb,
      rF_ft,rB_ft,
      Wcw_req_lb,Wcw_lb,
      tauBlock,tauCW,tauRatio,
      R_lb,M_lbft,
      sec,sigma_psi,sigma_mpa,
      A_in2,p_psi,p_mpa,
      MA,liftTargetIn,
      muVal,moveRes_lb,pullAvail_lb,
      legLoad_lb,
      // metric extras
      Wb_N:Wb_lb*LB_TO_N,
      Wcw_N:Wcw_lb*LB_TO_N,
      R_N:R_lb*LB_TO_N,
      rF_m:rF_ft*FT_TO_M,
      rB_m:rB_ft*FT_TO_M,
      M_Nm:M_lbft*LB_TO_N*FT_TO_M,
      moveRes_N:moveRes_lb*LB_TO_N
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    const t =
`Forgotten counterbalanced lever-crane concept (plausible ancient workflow)

This simulation models a practical method for handling very heavy stone blocks using materials available in antiquity: timber (multiple logs lashed as a beam), rope, a pivot seat/yoke, stone counterweights, and simple rollers/skids. The goal is not to lift a block high, but to lift it “just enough” (a few inches) to insert rollers and reposition it with far less friction.

Physics basis (torque balance):
  τ_block = W_block · r_front
  τ_cw    = W_cw · r_back
Lift begins when τ_cw ≥ τ_block, giving the required counterweight:
  W_cw = W_block · (r_front / r_back)

A long back arm r_back reduces the needed counterweight dramatically while preserving torque balance. To avoid cracking and visible damage, the load must be spread: a built-up beam (4, 6, or 8 logs lashed) increases section modulus S and reduces bending stress (σ ≈ M/S), while wide sling pads reduce local contact pressure (p = W/A). After a small lift, the block is moved on rollers/skids; required pull is approximated by F ≈ μ·W.

Documentation note:
I could not find this exact technique clearly written in surviving sources; it is plausible that methods like this were transmitted by apprenticeship and oral tradition—word-by-word and demonstration—rather than formal manuals. Modern examples of heavy-stone movement using tripods/cranes suggest the same underlying principle: mechanical advantage + controlled lift + load spreading, which could apply to large stone construction and even Stonehenge-style placement, as well as controlled loading/unloading onto ships with lower peak stress.`;
    $("paperText").value=t;
  }

  function setStatus(d){
    const status=$("statusBox");
    let cls="ok";
    const msg=[];
    const liftable=d.tauRatio>=1;

    if(d.sigma_mpa>WOOD_WARN_MPA){
      cls="warn";
      msg.push(`Beam stress VERY HIGH (${fmt(d.sigma_mpa,1)} MPa). Add logs/diameter or increase r_back / reduce r_front.`);
    }else if(d.sigma_mpa>WOOD_ALLOW_MPA){
      cls="warn";
      msg.push(`Beam stress high (${fmt(d.sigma_mpa,1)} MPa). More logs/diameter lowers stress (matches your “no cracks” load-spreading argument).`);
    }else{
      msg.push(`Beam stress in safer demo range (${fmt(d.sigma_mpa,1)} MPa).`);
    }

    if(d.p_psi>PRESS_WARN_PSI){
      cls="warn";
      msg.push(`Contact pressure EXTREME (${fmt(d.p_psi,0)} psi). Use wide pads/rollers to prevent point damage.`);
    }else if(d.p_psi>PRESS_OK_PSI){
      msg.push(`Contact pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk further.`);
    }else{
      msg.push(`Contact pressure relatively low (${fmt(d.p_psi,0)} psi) with current pad area.`);
    }

    if(liftable) msg.push(`Lift condition met (τ_ratio=${fmt(d.tauRatio,2)}).`);
    else { cls="warn"; msg.push(`Not enough torque (τ_ratio=${fmt(d.tauRatio,2)}). Increase CW or r_back.`); }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  function updateOutputs(d){
    // CW display
    let cwDisplay;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;

      cwDisplay=`${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent=`${fmt(d.MA,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent=`${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent=`${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";
    }else{
      cwDisplay=`${fmt(d.Wcw_N/1000,1)} kN`;
      $("maOut").textContent=`${fmt(d.MA,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent=`${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent=`${fmt(d.moveRes_N/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt((d.R_N/2)/1000,1)} kN/leg` : "—";
    }
    $("cwOut").textContent=cwDisplay;

    // Live equations
    const eq=[];
    eq.push(`TORQUE / LIFT:`);
    eq.push(`  τ_block = W_b · r_front`);
    eq.push(`  τ_cw    = W_cw · r_back`);
    eq.push(`  Lift when τ_cw ≥ τ_block`);
    eq.push(`  Required CW (balance): W_cw = W_b · (r_front / r_back)`);
    eq.push(``);
    eq.push(`MECHANICAL ADVANTAGE: MA = r_back / r_front`);
    eq.push(``);
    eq.push(`REACTION (approx): R ≈ W_b + W_cw`);
    eq.push(``);
    eq.push(`BEAM: M ≈ max(τ_block, τ_cw),  σ ≈ M/S,  S≈(b·h²)/6`);
    eq.push(`CONTACT: p = W_b / A_pad`);
    eq.push(`MOVE: F_resist ≈ μ · W_b`);
    eq.push(``);
    eq.push(`LIVE:`);
    eq.push(`  W_b=${fmt(d.Wb_lb,0)} lb (${fmt(d.Wb_N/1000,1)} kN)`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft (${fmt(d.rF_m,3)} m)`);
    eq.push(`  r_back =${fmt(d.rB_ft,1)} ft (${fmt(d.rB_m,3)} m)`);
    eq.push(`  τ_block=${fmt(d.tauBlock,0)} lb·ft`);
    eq.push(`  τ_cw   =${fmt(d.tauCW,0)} lb·ft`);
    eq.push(`  τ_ratio=${fmt(d.tauRatio,3)}`);
    eq.push(`  W_cw=${fmt(d.Wcw_lb,0)} lb (${fmt(d.Wcw_N/1000,1)} kN)`);
    eq.push(`  MA=${fmt(d.MA,2)}`);
    eq.push(`  R≈${fmt(d.R_lb,0)} lb (${fmt(d.R_N/1000,1)} kN)`);
    eq.push(`  M≈${fmt(d.M_lbft,0)} lb·ft (${fmt(d.M_Nm,0)} N·m)`);
    eq.push(`  Logs: ${d.sec.cols}×${d.sec.rows}, d=${fmt(Number(logDia.value),1)} in`);
    eq.push(`  b=${fmt(d.sec.b,1)} in, h=${fmt(d.sec.h,1)} in, S=${fmt(d.sec.S,0)} in³`);
    eq.push(`  σ≈${fmt(d.sigma_psi,0)} psi (${fmt(d.sigma_mpa,1)} MPa)`);
    eq.push(`  A_pad=${fmt(d.A_in2,0)} in² → p≈${fmt(d.p_psi,0)} psi`);
    eq.push(`  μ=${fmt(d.muVal,3)} → F_resist≈${fmt(d.moveRes_lb,0)} lb, pull=${fmt(d.pullAvail_lb,0)} lb`);
    eq.push(`  Block moved=${fmt(state.xMove,1)} ft`);
    $("eqBox").textContent=eq.join("\n");
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const groundY=h-70;

    // ground line
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // geometry placement
    const pivotX=210;
    const pivotY=groundY-240;

    // scale
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    const beamX0=pivotX-frontPx;
    const beamX1=pivotX+backPx;

    // Visual rocking/flex: pivot fixed, endpoints shift in Y with liftProgress
    const flex=state.liftProgress;      // 0..1
    const maxFlexPx=16;
    const frontEndY = pivotY - (maxFlexPx*flex); // front goes up when lifting
    const backEndY  = pivotY + (maxFlexPx*flex); // back goes down when lifting

    // Supports and apex
    let apexX=pivotX, apexY=pivotY;
    if(rigType.value==="single"){
      // mast
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      // yoke
      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Vertical mast", pivotX-55, groundY-10);
      ctx.fillText("Pivot / yoke", pivotX-52, pivotY-35);

      apexX=pivotX; apexY=pivotY-2;
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Two-mast A-frame", pivotX-72, groundY-10);
      ctx.fillText("Apex / pivot plate", apexX-82, apexY-35);
    }

    // Beam
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;
    ctx.strokeStyle="#0b3d91"; ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, frontEndY);
    ctx.lineTo(beamX1, backEndY);
    ctx.stroke();

    ctx.lineWidth=1;
    ctx.fillStyle="#0b3d91"; ctx.font="15px Arial";
    ctx.fillText(`Built-up beam (${logs.value} logs lashed)`, (beamX0+beamX1)/2 - 160, pivotY - 26);

    // arm labels
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`Front arm r_front = ${fmt(d.rF_ft,2)} ft`, beamX0 + 10, pivotY - 92);
    ctx.fillText(`Back arm r_back = ${fmt(d.rB_ft,1)} ft`, pivotX + 10, pivotY - 116);

    // sling point (near front)
    const slingBaseX = beamX0 + 36;
    const moveNowPx = state.xMove * pxPerFt;
    const slingX = slingBaseX + moveNowPx;

    // interpolate beam Y at slingX between ends
    const t = clamp((slingX - beamX0)/(beamX1 - beamX0), 0, 1);
    const beamYSling = frontEndY*(1-t) + backEndY*t;

    // lift amount
    const liftPx = (d.liftTargetIn/12.0)*pxPerFt;
    const liftNow = state.liftProgress*liftPx;

    // block sits on ground when liftProgress=0
    const blockW=78, blockH=78;
    const blockBottomY=groundY;
    const blockY = (blockBottomY - blockH) - liftNow;
    const blockX = slingX - blockW/2;

    // sling line
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(blockX, blockY, blockW, blockH);
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`${tons.value}-ton block`, blockX-8, blockY+blockH+18);

    // rollers/skids
    if(simMode.value==="liftMove"){
      const skidY=groundY-14;
      const underX0=blockX-10;
      const underX1=blockX+blockW+10;

      ctx.strokeStyle="#6b7280"; ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(underX0, skidY); ctx.lineTo(underX1, skidY); ctx.stroke();

      for(let x=underX0+18; x<underX1-12; x+=26){
        ctx.beginPath();
        ctx.arc(x, skidY+10, 8, 0, Math.PI*2);
        ctx.strokeStyle="#111"; ctx.lineWidth=2;
        ctx.stroke();
      }
      ctx.fillStyle="#111"; ctx.font="12px Arial";
      ctx.fillText("Rollers / skids (lift → slide → set down)", 36, groundY-44);
    }

    // Counterweight ATTACHMENT: rope from beam END (black line) and CW follows beam end Y.
    // This is the fix you requested: rope originates at the beam end and goes down to the CW.
    const cwW=56, cwH=56;

    // Beam end point (back end)
    const beamEndX = beamX1;
    const beamEndY = backEndY;

    // Counterweight hangs under beam end (so it moves down when lifting, up when lowering)
    const cwX = beamEndX - 30 - cwW/2;
    const cwY = beamEndY + 48;

    // Rope: beam end -> CW top center
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(beamEndX, beamEndY + 6);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // OPTIONAL stabilizing line from mast/apex to CW (a tie/guide line)
    // (kept subtle; helps show “attached to pole” idea without changing main rope.)
    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // counterweight block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // CW label
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    let cwText;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwText=`${fmt(cw_ton,2)} tons`;
    }else{
      cwText=`${fmt(d.Wcw_N/1000,1)} kN`;
    }
    ctx.fillText("Counterweight", cwX-14, cwY+cwH+18);
    ctx.fillText(cwText, cwX+4, cwY+cwH+34);

    // Arm arrows
    arrow(pivotX, pivotY-140, beamX1, pivotY-140, "r_back");
    arrow(beamX0, pivotY-110, pivotX, pivotY-110, "r_front");

    // Info box
    const infoX=w-330, infoY=24;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 300, 160);
    ctx.strokeRect(infoX, infoY, 300, 160);
    ctx.fillStyle="#111"; ctx.font="12px Arial";
    ctx.fillText(`Mode: ${simMode.value==="liftMove" ? "Lift+Move" : "Lift only"}`, infoX+10, infoY+22);
    ctx.fillText(`Rig: ${rigType.value==="aframe" ? "A-frame" : "Single mast"}`, infoX+10, infoY+40);
    ctx.fillText(`τ_ratio=${fmt(d.tauRatio,2)} (≥1 lifts)`, infoX+10, infoY+58);
    ctx.fillText(`Beam stress≈${fmt(d.sigma_psi/1000,2)} ksi`, infoX+10, infoY+76);
    ctx.fillText(`Pad pressure≈${fmt(d.p_psi,0)} psi`, infoX+10, infoY+94);
    ctx.fillText(`Lift target=${fmt(d.liftTargetIn,1)} in, progress=${fmt(state.liftProgress,2)}`, infoX+10, infoY+112);
    ctx.fillText(`Moved=${fmt(state.xMove,1)} ft`, infoX+10, infoY+130);
    if(simMode.value==="liftMove"){
      ctx.fillText(`μW≈${fmt(d.moveRes_lb,0)} lb, pull=${fmt(d.pullAvail_lb,0)} lb`, infoX+10, infoY+148);
    }

    ctx.fillStyle=(d.tauRatio>=1) ? "#14532d" : "#7f1d1d";
    ctx.font="13px Arial";
    ctx.fillText((d.tauRatio>=1) ? "LIFT POSSIBLE" : "NOT ENOUGH TORQUE", infoX+170, infoY+22);
  }

  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    setStatus(d);
    draw(d);
  }

  // Buttons
  $("liftToggleBtn").onclick=()=>{
    // manual lift toggle overrides cycling
    state.liftToggle=!state.liftToggle;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle)";
  };

  $("cycleBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=!state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
  };

  $("stepBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
  };

  $("resetBtn").onclick=()=>{
    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;
    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    computeAndRender();
  };

  // Motion
  function advance(dt){
    const d=compute();
    const liftable=d.tauRatio>=1;

    // if not liftable, force down
    if(!liftable){
      state.liftProgress=clamp(state.liftProgress-dt*1.6,0,1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    // manual lift toggle (when not cycling)
    if(state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress+dt*1.05,0,1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress-dt*1.25,0,1);
      return;
    }

    // cycling (liftMove)
    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress=clamp(state.liftProgress+dt*1.0,0,1);
        if(state.liftProgress>=1){
          state.phase="moving";
          state.phaseT=0;
        }
      }else if(state.phase==="moving"){
        const canMove=d.pullAvail_lb>=d.moveRes_lb;
        const speed=canMove ? 1.0 : 0.18;
        const moveRateFtPerSec=2.0*speed;

        const step=moveRateFtPerSec*dt;
        const remaining=Math.max(0,state.targetMove-(state.phaseT*state.targetMove));
        const adv=Math.min(step,remaining);

        const frac=adv/state.targetMove;
        state.phaseT=clamp(state.phaseT+frac,0,1);
        state.xMove+=adv;

        if(state.phaseT>=1){
          state.phase="lowering";
          state.phaseT=0;
        }
      }else if(state.phase==="lowering"){
        state.liftProgress=clamp(state.liftProgress-dt*1.35,0,1);
        if(state.liftProgress<=0){
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Input listeners
  [
    rigType, simMode, units, tonType, tons, liftIn, rFront, rBack, cwTons, cwMode,
    logs, logDia, padArea, moveFt, mu, pullLb
  ].forEach(el=>{
    el.addEventListener("input", computeAndRender);
    el.addEventListener("change", computeAndRender);
  });

  // Init
  resizeCanvas();
  setPaperText();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
