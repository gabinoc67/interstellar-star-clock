<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Forgotten Lever-Crane Simulator — Go/No-Go Beam Torque + Force Needed</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --red:#b91c1c;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;
  }
  html,body{height:100%;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);}
  header{background:var(--blue);color:#fff;padding:14px 16px;}
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.92;font-size:13px;margin-top:5px;line-height:1.25;}
  main{display:grid;grid-template-columns:460px 1fr;gap:14px;padding:14px;}
  .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;margin-top:6px;padding:6px;border:1px solid #d1d5db;border-radius:10px;font-size:13px;background:#fff;
  }
  textarea{min-height:110px;resize:vertical;line-height:1.25;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}
  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);}
  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #fee2e2;background:#fff1f2;color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #dcfce7;background:#f0fdf4;color:#14532d;font-size:13px;line-height:1.25;}
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;white-space:pre-wrap;background:#0b1020;color:#e5e7eb;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.08);line-height:1.25;
  }
  .underCanvas{
    margin-top:10px;
    background:var(--panel);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .underCanvas h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .underCanvas p{margin:6px 0;color:#111;font-size:13px;line-height:1.35;}
  .underCanvas ul{margin:6px 0 0 18px;font-size:13px;line-height:1.35;color:#111;}
  .explain{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .explain h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .explain p{margin:6px 0;font-size:13px;line-height:1.35;color:#111;}
  .explain .math{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    background:#111827;color:#e5e7eb;border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,.08);
    font-size:12px;white-space:pre-wrap;line-height:1.25;
  }
  .diagramWrap{
    margin-top:10px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e5e7eb;
    padding:12px;
  }
  .diagramWrap h3{margin:0 0 8px;color:var(--blue);font-size:15px;}
  .diagramImg{
    width:100%;
    height:auto;
    border-radius:12px;
    border:1px solid #e5e7eb;
    display:block;
    background:#fff;
  }
  .diagramNote{
    margin:8px 0 0;
    color:var(--muted);
    font-size:12px;
    line-height:1.25;
  }
  canvas{width:100%;height:520px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}
  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}
</style>
</head>
<body>
<header>
  <h1>Forgotten Lever-Crane Simulator — Go/No-Go Beam Torque + Force Needed</h1>
  <div class="sub">
    Go/No-Go beam coloring: <b style="color:#a7f3d0;">green</b> when torque is OK to lift; <b style="color:#fecaca;">red</b> when beam torque is too high (compromised).
    Moving r_front and r_back shows torque increase/decrease and the force needed to lift.
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="card">
    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (toggle up/down)</option>
          <option value="liftMove">Lift + Move (cycles) — visual shows sliding only</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight preset (tons)</label>
        <select id="tonsPreset">
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="50">50</option>
          <option value="60">60</option>
          <option value="70">70</option>
          <option value="80" selected>80</option>
          <option value="90">90</option>
          <option value="100">100</option>
          <option value="120">120</option>
          <option value="140">140</option>
          <option value="160">160</option>
          <option value="180">180</option>
          <option value="200">200</option>
          <option value="custom">Custom…</option>
        </select>
      </div>
      <div>
        <label>Block weight (tons)</label>
        <input id="tons" type="number" step="1" value="80" min="1" max="500" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Target lift height (in)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300">3.00 ft</button>
      <button class="ghost small" id="front400">4.00 ft</button>
      <button class="ghost small" id="front500">5.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20">20 ft</button>
      <button class="ghost small" data-back="30">30 ft</button>
      <button class="ghost small" data-back="49.2">49 ft</button>
      <button class="ghost small" data-back="60">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <label>CW mode</label>
        <select id="cwMode">
          <option value="auto" selected>Auto: set CW to balance</option>
          <option value="manual">Manual: use my CW</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Optional people pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <label>Friction μ (0.02–0.20) — used in math only</label>
    <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />

    <div class="btnrow">
      <button id="liftToggleBtn">Lift (toggle)</button>
      <button id="cycleBtn" class="secondary">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost">Reset</button>
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box">
        <div class="t">Required counterweight</div>
        <div class="v" id="cwOut">—</div>
      </div>
      <div class="box">
        <div class="t">Mechanical advantage (r_back / r_front)</div>
        <div class="v" id="maOut">—</div>
      </div>
      <div class="box">
        <div class="t">Beam torque tension (Go/No-Go)</div>
        <div class="v" id="beamTorqueOut">—</div>
      </div>
      <div class="box">
        <div class="t">Force needed to lift at back end</div>
        <div class="v" id="forceLiftOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Beam bending stress (approx)</div>
        <div class="v" id="stressOut">—</div>
      </div>
      <div class="box">
        <div class="t">Contact pressure at sling pad</div>
        <div class="v" id="pressOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Move resistance (μ·W) estimate</div>
        <div class="v" id="moveResOut">—</div>
      </div>
      <div class="box">
        <div class="t">A-frame leg load (approx)</div>
        <div class="v" id="legOut">—</div>
      </div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox">Loading…</div>

    <h2>Paper text (editable copy)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      Beam color is a simple Go/No-Go check on beam torque capacity vs applied torque:
      if applied torque exceeds capacity, beam turns red; otherwise green.
    </div>
  </section>

  <!-- RIGHT: CANVAS + UNDER PANEL -->
  <section>
    <canvas id="c"></canvas>

    <div class="underCanvas">
      <h3>Why “lift a little + spread the load” matters (no cracks / ship loading / Stonehenge-style logic)</h3>
      <p>
        If you pull a multi-ton block by dragging it, the friction force is enormous and the block would tend to <b>scrape, chip, and gouge</b> surfaces.
        Likewise, if you place bare logs directly under sharp contact points, the pressure concentrates and can leave <b>crush marks, spalls, or cracks</b>.
        That’s why a practical ancient method would favor a cycle of <b>small controlled lift</b> plus <b>wide pads</b> and <b>controlled sliding/rolling</b>.
      </p>
      <ul>
        <li><b>Front arm longer</b> → more stone torque → harder to lift.</li>
        <li><b>Back arm longer</b> → less force/counterweight needed.</li>
        <li><b>Force needed to lift</b> at the back end: <b>F_lift = (W_block · r_front) / r_back</b>.</li>
        <li><b>Go/No-Go</b> uses a beam torque capacity estimate (from beam stress limit × section modulus).</li>
      </ul>
    </div>

    <div class="explain">
      <h3>Can this method lift the selected stone?</h3>
      <p>
        <b>Yes — in principle</b>, if the counterweight/people force can supply enough torque, and if the beam torque is within safe capacity.
      </p>
      <div class="math" id="explainMath">Loading…</div>
      <p>
        <b>Bottom line:</b> torque balance decides “can it lift.” Beam torque capacity decides “go/no-go.”
      </p>
    </div>

    <div class="diagramWrap">
      <h3>Swivel / torque-point concept diagram</h3>
      <img
        class="diagramImg"
        alt="Swivel torque-point diagram"
        src="https://raw.githubusercontent.com/gabinoc67/interstellar-star-clock/main/demo/swiffel.png"
      />
      <p class="diagramNote">Shown under the panel as requested.</p>
    </div>

  </section>
</main>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo thresholds (rough)
  const WOOD_ALLOW_MPA=40; // stress "allowable" demo
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");
  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*devicePixelRatio);
    canvas.height=Math.floor(r.height*devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tonsPreset=$("tonsPreset");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");

  // Presets
  $("front209").onclick=()=>{ rFront.value=2.09; computeAndRender(); };
  $("front300").onclick=()=>{ rFront.value=3.00; computeAndRender(); };
  $("front400").onclick=()=>{ rFront.value=4.00; computeAndRender(); };
  $("front500").onclick=()=>{ rFront.value=5.00; computeAndRender(); };
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.onclick=()=>{ rBack.value=b.getAttribute("data-back"); computeAndRender(); };
  });

  // State
  const state={
    liftToggle:false,
    cycling:false,
    oneStep:false,
    phase:"idle", // idle, lifting, moving, lowering
    liftProgress:0, // 0..1
    xMove:0, // ft
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne (weight in lbf)
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6; // in^3
    return {b,h,S,cols,rows};
  }

  function compute(){
    const U=units.value;
    const tonsVal=Math.max(1,Number(tons.value)||80);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    // weights
    const Wb_lb=blockWeightLb(tonsVal,tonType.value);

    // Stone torque about pivot
    const tauBlock_lbft=Wb_lb*rF_ft;

    // Force needed at back end to just balance (people pull or CW rope tension at end)
    // F_lift = (W_block * r_front) / r_back
    const F_lift_lb = tauBlock_lbft / rB_ft;

    // Auto CW uses exactly that balancing force as counterweight "weight"
    const Wcw_req_lb = F_lift_lb;

    let Wcw_lb=Wcw_req_lb;
    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    // Counterweight torque
    const tauCW_lbft = Wcw_lb*rB_ft;
    const tauRatio = tauCW_lbft / tauBlock_lbft; // ≥1 lift

    // Beam torque "demand" = max end torque being carried (same as max of the two torques)
    const tauDemand_lbft = Math.max(tauBlock_lbft, tauCW_lbft);

    // Beam section + bending capacity estimate
    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const sec=sectionFromLogs(nLogs,diaIn);

    // capacity based on allowable stress:
    // M_allow = sigma_allow * S  (units: (psi)*(in^3)=lb*in)
    // convert to lb*ft
    const M_allow_lbin = (WOOD_ALLOW_MPA/PSI_TO_MPA) * sec.S; // psi = MPa / PSI_TO_MPA
    const tauCap_lbft = M_allow_lbin / 12.0;

    const goNoGo = (tauDemand_lbft <= tauCap_lbft);

    // Report stress too (still shown)
    const M_lbin = tauDemand_lbft*12;
    const sigma_psi = M_lbin/sec.S;
    const sigma_mpa = sigma_psi*PSI_TO_MPA;

    // contact pressure
    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    // move resistance
    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    // reactions
    const R_lb=Wb_lb+Wcw_lb;
    const legLoad_lb=R_lb/2;

    return {
      U,
      tonsVal,
      Wb_lb,
      rF_ft,
      rB_ft,

      tauBlock_lbft,
      tauCW_lbft,
      tauRatio,

      // NEW outputs
      tauDemand_lbft,
      tauCap_lbft,
      goNoGo,
      beamColor: goNoGo ? "green" : "red",

      // force needed to lift (at back end)
      F_lift_lb,

      // CW
      Wcw_req_lb,
      Wcw_lb,

      // stress
      sec,
      sigma_psi,
      sigma_mpa,

      // contact
      A_in2,
      p_psi,
      p_mpa,

      // move
      muVal,
      moveRes_lb,
      pullAvail_lb,

      // other
      R_lb,
      legLoad_lb,

      // conversions
      Wb_N:Wb_lb*LB_TO_N,
      Wcw_N:Wcw_lb*LB_TO_N,
      F_lift_N:F_lift_lb*LB_TO_N,
      tauDemand_Nm:tauDemand_lbft*LB_TO_N*FT_TO_M,
      tauCap_Nm:tauCap_lbft*LB_TO_N*FT_TO_M
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    const t =
`Go/No-Go beam torque + force-needed model

Core lift physics:
  τ_block = W_block · r_front
  Lift requires an opposing torque from counterweight or people force at the back end:
  τ_back = F_back · r_back

Force needed to just start lifting (balance point):
  F_lift = (W_block · r_front) / r_back

Go/No-Go beam check (torque capacity):
  Beam "demand torque" is the maximum torque it must carry:
    τ_demand = max(τ_block, τ_back)
  Beam torque capacity is estimated from allowable bending stress:
    M_allow = σ_allow · S
    τ_cap   = M_allow / 12  (convert lb·in to lb·ft)
  If τ_demand ≤ τ_cap → GO (beam green)
  Else → NO-GO (beam red)

Changing r_front and r_back:
  r_front up  → τ_block up  → harder lift (more force needed)
  r_back  up  → needed force down (more mechanical advantage)
`;
    $("paperText").value=t;
  }

  function setStatus(d){
    const status=$("statusBox");
    let cls="ok";
    const msg=[];

    if(d.goNoGo){
      msg.push(`GO: Beam torque OK (τ_demand ≤ τ_cap).`);
    }else{
      cls="warn";
      msg.push(`NO-GO: Beam torque TOO HIGH (τ_demand > τ_cap). Increase logs/diameter, reduce r_front, or reduce load.`);
    }

    if(d.p_psi>PRESS_WARN_PSI){
      cls="warn";
      msg.push(`Contact pressure EXTREME (${fmt(d.p_psi,0)} psi). Use wider pads to prevent damage.`);
    }else if(d.p_psi>PRESS_OK_PSI){
      msg.push(`Contact pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk.`);
    }else{
      msg.push(`Contact pressure relatively low (${fmt(d.p_psi,0)} psi).`);
    }

    // Torque ratio display still useful
    if(d.tauRatio>=1) msg.push(`Lift condition met (τ_ratio=${fmt(d.tauRatio,2)}).`);
    else { cls="warn"; msg.push(`Not enough torque (τ_ratio=${fmt(d.tauRatio,2)}). Increase CW or r_back.`); }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  function updateOutputs(d){
    // required CW display
    let cwDisplay;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwDisplay=`${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent=`${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent=`${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";

      // NEW: beam torque tension + lift force
      const beamTxt = `${fmt(d.tauDemand_lbft,0)} lb·ft / cap ${fmt(d.tauCap_lbft,0)} lb·ft (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("beamTorqueOut").textContent = beamTxt;

      $("forceLiftOut").textContent = `${fmt(d.F_lift_lb,0)} lb (at back end)`;
    }else{
      cwDisplay=`${fmt(d.Wcw_N/1000,1)} kN`;
      $("maOut").textContent=`${fmt(d.rB_ft/d.rF_ft,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent=`${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent=`${fmt((d.moveRes_lb*LB_TO_N)/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(((d.R_lb*LB_TO_N)/2)/1000,1)} kN/leg` : "—";

      const beamTxt = `${fmt(d.tauDemand_Nm/1000,1)} kN·m / cap ${fmt(d.tauCap_Nm/1000,1)} kN·m (${d.goNoGo ? "GO" : "NO-GO"})`;
      $("beamTorqueOut").textContent = beamTxt;

      $("forceLiftOut").textContent = `${fmt(d.F_lift_N/1000,1)} kN (at back end)`;
    }
    $("cwOut").textContent=cwDisplay;

    // Equations live
    const eq=[];
    eq.push(`LIFT FORCE NEEDED (back end):`);
    eq.push(`  τ_block = W_block · r_front`);
    eq.push(`  τ_back  = F_back · r_back`);
    eq.push(`  Balance point: F_lift = (W_block · r_front) / r_back`);
    eq.push(``);
    eq.push(`BEAM GO/NO-GO TORQUE CHECK:`);
    eq.push(`  τ_demand = max(τ_block, τ_back)`);
    eq.push(`  τ_cap ≈ (σ_allow · S)/12`);
    eq.push(`  GO if τ_demand ≤ τ_cap; else NO-GO`);
    eq.push(``);
    eq.push(`LIVE:`);
    eq.push(`  W_block=${fmt(d.Wb_lb,0)} lb (${fmt(d.Wb_N/1000,1)} kN)`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft`);
    eq.push(`  r_back =${fmt(d.rB_ft,1)} ft`);
    eq.push(`  τ_block=${fmt(d.tauBlock_lbft,0)} lb·ft`);
    eq.push(`  F_lift=${fmt(d.F_lift_lb,0)} lb (back end force for lift)`);
    eq.push(`  τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`);
    eq.push(`  τ_cap=${fmt(d.tauCap_lbft,0)} lb·ft  => ${d.goNoGo ? "GO" : "NO-GO"}`);
    eq.push(`  Beam stress≈${fmt(d.sigma_psi,0)} psi (${fmt(d.sigma_mpa,1)} MPa)`);
    eq.push(`  Pad pressure≈${fmt(d.p_psi,0)} psi`);
    eq.push(`  μ=${fmt(d.muVal,3)} → μW≈${fmt(d.moveRes_lb,0)} lb, pull=${fmt(d.pullAvail_lb,0)} lb`);
    eq.push(`  Block moved=${fmt(state.xMove,1)} ft`);
    $("eqBox").textContent=eq.join("\n");

    // Explain panel
    const example=[];
    example.push(`Lift condition (force form):`);
    example.push(`  F_lift = (W_block · r_front) / r_back`);
    example.push(``);
    example.push(`Go/No-Go (beam torque):`);
    example.push(`  τ_demand = max(W_block·r_front, F_back·r_back)`);
    example.push(`  τ_cap ≈ (σ_allow·S)/12`);
    example.push(``);
    example.push(`Current:`);
    example.push(`  W_block=${fmt(d.tonsVal,0)} tons`);
    example.push(`  r_front=${fmt(d.rF_ft,2)} ft, r_back=${fmt(d.rB_ft,1)} ft`);
    example.push(`  Force needed to lift ≈ ${d.U==="imperial" ? fmt(d.F_lift_lb,0)+" lb" : fmt(d.F_lift_N/1000,1)+" kN"} (at back end)`);
    example.push(`  Beam: ${d.goNoGo ? "GO (green)" : "NO-GO (red)"} — τ_demand vs τ_cap`);
    $("explainMath").textContent=example.join("\n");
  }

  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const groundY=h-70;

    // ground
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // pivot
    const pivotX=210;
    const pivotY=groundY-240;

    // scale
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    const beamX0=pivotX-frontPx;
    const beamX1=pivotX+backPx;

    // rocking
    const flex=state.liftProgress;
    const maxFlexPx=16;
    const frontEndY = pivotY - (maxFlexPx*flex);
    const backEndY  = pivotY + (maxFlexPx*flex);

    // supports
    let apexX=pivotX, apexY=pivotY;
    if(rigType.value==="single"){
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Vertical mast", pivotX-55, groundY-10);
      ctx.fillText("Pivot / yoke", pivotX-52, pivotY-35);

      apexX=pivotX; apexY=pivotY-2;
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Two-mast A-frame", pivotX-72, groundY-10);
      ctx.fillText("Apex / pivot plate", apexX-82, apexY-35);
    }

    // Beam (GO/NO-GO color)
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;

    ctx.strokeStyle = (d.beamColor==="green") ? "#1f8a3b" : "#b91c1c";
    ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, frontEndY);
    ctx.lineTo(beamX1, backEndY);
    ctx.stroke();

    ctx.lineWidth=1;
    ctx.fillStyle="#111"; ctx.font="15px Arial";
    ctx.fillText(`Built-up beam (${logs.value} logs) — ${d.goNoGo ? "GO (green)" : "NO-GO (red)"}`, (beamX0+beamX1)/2 - 200, pivotY - 26);

    // labels
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`r_front=${fmt(d.rF_ft,2)} ft`, beamX0 + 10, pivotY - 92);
    ctx.fillText(`r_back=${fmt(d.rB_ft,1)} ft`, pivotX + 10, pivotY - 116);

    // sling point
    const slingBaseX = beamX0 + 36;
    const moveNowPx = state.xMove * pxPerFt;
    const slingX = slingBaseX + moveNowPx;

    const t = clamp((slingX - beamX0)/(beamX1 - beamX0), 0, 1);
    const beamYSling = frontEndY*(1-t) + backEndY*t;

    // lift amount
    const liftPx = (d.liftTargetIn/12.0)*pxPerFt;
    const liftNow = state.liftProgress*liftPx;

    // block
    const blockW=78, blockH=78;
    const blockBottomY=groundY;
    const blockY = (blockBottomY - blockH) - liftNow;
    const blockX = slingX - blockW/2;

    // sling line
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // stone block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(blockX, blockY, blockW, blockH);
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`${tons.value}-ton block`, blockX-8, blockY+blockH+18);

    // Counterweight follows beam end
    const cwW=56, cwH=56;
    const beamEndX = beamX1;
    const beamEndY = backEndY;

    const cwX = beamEndX - 30 - cwW/2;
    const cwY = beamEndY + 48;

    // rope to CW
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(beamEndX, beamEndY + 6);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // guide line
    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);
    ctx.lineTo(cwX + cwW/2, cwY);
    ctx.stroke();

    // CW block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // CW label
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    let cwText;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwText=`${fmt(cw_ton,2)} tons`;
    }else{
      cwText=`${fmt(d.Wcw_N/1000,1)} kN`;
    }
    ctx.fillText("Counterweight", cwX-14, cwY+cwH+18);
    ctx.fillText(cwText, cwX+4, cwY+cwH+34);

    // arrows
    arrow(pivotX, pivotY-140, beamX1, pivotY-140, "r_back");
    arrow(beamX0, pivotY-110, pivotX, pivotY-110, "r_front");

    // info box
    const infoX=w-330, infoY=24;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 300, 186);
    ctx.strokeRect(infoX, infoY, 300, 186);
    ctx.fillStyle="#111"; ctx.font="12px Arial";
    ctx.fillText(`Beam: ${d.goNoGo ? "GO (green)" : "NO-GO (red)"}`, infoX+10, infoY+22);
    ctx.fillText(`τ_demand=${fmt(d.tauDemand_lbft,0)} lb·ft`, infoX+10, infoY+40);
    ctx.fillText(`τ_cap≈${fmt(d.tauCap_lbft,0)} lb·ft`, infoX+10, infoY+58);
    ctx.fillText(`Force needed to lift: ${fmt(d.F_lift_lb,0)} lb`, infoX+10, infoY+76);
    ctx.fillText(`Mode: ${simMode.value==="liftMove" ? "Lift+Move (slide)" : "Lift only"}`, infoX+10, infoY+94);
    ctx.fillText(`Lift target=${fmt(d.liftTargetIn,1)} in, progress=${fmt(state.liftProgress,2)}`, infoX+10, infoY+112);
    ctx.fillText(`Moved=${fmt(state.xMove,1)} ft`, infoX+10, infoY+130);
    if(simMode.value==="liftMove"){
      ctx.fillText(`μW≈${fmt(d.moveRes_lb,0)} lb, pull=${fmt(d.pullAvail_lb,0)} lb`, infoX+10, infoY+148);
    }
    ctx.fillText(`r_front=${fmt(d.rF_ft,2)} ft, r_back=${fmt(d.rB_ft,1)} ft`, infoX+10, infoY+166);

    ctx.fillStyle=(d.tauRatio>=1) ? "#14532d" : "#7f1d1d";
    ctx.font="13px Arial";
    ctx.fillText((d.tauRatio>=1) ? "LIFT POSSIBLE" : "NOT ENOUGH TORQUE", infoX+165, infoY+22);
  }

  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    setStatus(d);
    draw(d);
  }

  // Tons preset sync
  function syncPresetFromTons(){
    const val = String(Math.round(Number(tons.value)||80));
    const exists = Array.from(tonsPreset.options).some(o => o.value===val);
    tonsPreset.value = exists ? val : "custom";
  }
  function syncTonsFromPreset(){
    const v = tonsPreset.value;
    if(v==="custom") return;
    tons.value = Number(v);
  }

  // Buttons
  $("liftToggleBtn").onclick=()=>{
    state.liftToggle=!state.liftToggle;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle)";
  };

  $("cycleBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=!state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
  };

  $("stepBtn").onclick=()=>{
    if(simMode.value!=="liftMove") simMode.value="liftMove";
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle)";

    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
  };

  $("resetBtn").onclick=()=>{
    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;
    $("liftToggleBtn").textContent="Lift (toggle)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    computeAndRender();
  };

  // Motion
  function advance(dt){
    const d=compute();
    const liftable=(d.tauRatio>=1) && d.goNoGo; // require both lift torque and beam GO

    if(!liftable){
      state.liftProgress=clamp(state.liftProgress-dt*1.6,0,1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    if(state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress+dt*1.05,0,1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      state.liftProgress=clamp(state.liftProgress-dt*1.25,0,1);
      return;
    }

    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress=clamp(state.liftProgress+dt*1.0,0,1);
        if(state.liftProgress>=1){
          state.phase="moving";
          state.phaseT=0;
        }
      }else if(state.phase==="moving"){
        const canMove=d.pullAvail_lb>=d.moveRes_lb;
        const speed=canMove ? 1.0 : 0.18;
        const moveRateFtPerSec=2.0*speed;

        const step=moveRateFtPerSec*dt;
        const remaining=Math.max(0,state.targetMove-(state.phaseT*state.targetMove));
        const adv=Math.min(step,remaining);

        const frac=adv/state.targetMove;
        state.phaseT=clamp(state.phaseT+frac,0,1);
        state.xMove+=adv;

        if(state.phaseT>=1){
          state.phase="lowering";
          state.phaseT=0;
        }
      }else if(state.phase==="lowering"){
        state.liftProgress=clamp(state.liftProgress-dt*1.35,0,1);
        if(state.liftProgress<=0){
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Inputs
  [
    rigType, simMode, units, tonType, tonsPreset, tons, liftIn,
    rFront, rBack, cwTons, cwMode, logs, logDia, padArea, moveFt, mu, pullLb
  ].forEach(el=>{
    el.addEventListener("input", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
    el.addEventListener("change", ()=>{
      if(el===tonsPreset){ syncTonsFromPreset(); }
      if(el===tons){ syncPresetFromTons(); }
      computeAndRender();
    });
  });

  // Init
  resizeCanvas();
  setPaperText();
  syncPresetFromTons();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
