<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ancient Lever-Crane Simulator — 80-Ton Lift + Move (Logs Flex + Ropes + A-Frame)</title>
<style>
  :root{
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#111;
    --muted:#4b5563;
    --blue:#0b3d91;
    --green:#1f8a3b;
    --shadow: 0 6px 18px rgba(0,0,0,.10);
    --radius: 12px;
  }
  html,body{height:100%;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);}
  header{background:var(--blue);color:#fff;padding:14px 16px;}
  header h1{margin:0;font-size:18px;}
  header .sub{opacity:.92;font-size:13px;margin-top:5px;line-height:1.25;}
  main{display:grid;grid-template-columns:460px 1fr;gap:14px;padding:14px;}
  .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
  h2{margin:6px 0 10px;font-size:15px;color:var(--blue);}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px;}
  input[type="range"], input[type="number"], select, textarea{
    width:100%;margin-top:6px;padding:6px;border:1px solid #d1d5db;border-radius:10px;font-size:13px;background:#fff;
  }
  textarea{min-height:88px;resize:vertical;line-height:1.25;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  button{
    border:0;border-radius:10px;padding:9px 10px;font-weight:900;cursor:pointer;background:var(--blue);color:#fff;
    box-shadow: 0 6px 14px rgba(11,61,145,.20);
  }
  button.secondary{background:#111827;}
  button.ghost{background:#e5e7eb;color:#111;box-shadow:none;font-weight:900;}
  button.small{padding:6px 8px;font-size:12px;}
  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
  .kpi .box{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:10px;}
  .kpi .box .v{font-size:16px;font-weight:900;margin-top:4px;}
  .kpi .box .t{font-size:12px;color:var(--muted);}
  .warn{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #fee2e2;background:#fff1f2;color:#7f1d1d;font-size:13px;line-height:1.25;}
  .ok{margin-top:10px;padding:10px;border-radius:12px;border:1px solid #dcfce7;background:#f0fdf4;color:#14532d;font-size:13px;line-height:1.25;}
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size:12px;white-space:pre-wrap;background:#0b1020;color:#e5e7eb;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.08);line-height:1.25;
  }
  canvas{width:100%;height:600px;border-radius:var(--radius);background:#fff;box-shadow:var(--shadow);}
  .foot{margin-top:8px;font-size:12px;color:var(--muted);line-height:1.25;}
</style>
</head>
<body>
<header>
  <h1>Ancient Lever-Crane Simulator — Lift “Just Enough” + Move (Rollers) + A-Frame Option</h1>
  <div class="sub">
    This sim models a plausible <b>forgotten/under-documented crane workflow</b> using <b>timbers (lashed logs), rope, a pivot seat/yoke, counterweights, and simple rollers/skids</b>.
    The key idea is not “floating stones,” but <b>torque balance + load spreading</b>: a long back arm lets a smaller counterweight lift a massive block slightly, then the block is repositioned on rollers.
    Many practical engineering tricks were historically transmitted by apprenticeship and story rather than formal writing — so a technique can be real and effective yet lightly recorded.
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="card">
    <h2>Controls</h2>

    <div class="row">
      <div>
        <label>Rig type</label>
        <select id="rigType">
          <option value="single" selected>Single mast (post + yoke)</option>
          <option value="aframe">Two-mast A-frame (reduced side load)</option>
        </select>
      </div>
      <div>
        <label>Simulation mode</label>
        <select id="simMode">
          <option value="liftOnly" selected>Lift only (button up/down)</option>
          <option value="liftMove">Lift + Move (rollers) (cycles)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Units</label>
        <select id="units">
          <option value="imperial" selected>Imperial (ft, lb, psi)</option>
          <option value="metric">Metric (m, N, MPa)</option>
        </select>
      </div>
      <div>
        <label>Ton type</label>
        <select id="tonType">
          <option value="short" selected>Short ton (US) 2000 lb</option>
          <option value="metric">Metric tonne 1000 kg</option>
          <option value="long">Long ton 2240 lb</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Block weight (tons)</label>
        <input id="tons" type="number" step="1" value="80" min="1" />
      </div>
      <div>
        <label>Target lift height (in) (“just enough”)</label>
        <input id="liftIn" type="number" step="0.5" value="6" min="0.5" max="24" />
      </div>
    </div>

    <label>Front arm length r_front (ft) — fulcrum → sling</label>
    <input id="rFront" type="range" min="1.0" max="6.0" step="0.01" value="2.09" />
    <div class="btnrow">
      <button class="ghost small" id="front209">2.09 ft (≈0.64 m)</button>
      <button class="ghost small" id="front300">3.00 ft</button>
      <button class="ghost small" id="front400">4.00 ft</button>
    </div>

    <label>Back arm length r_back (ft) — fulcrum → counterweight</label>
    <input id="rBack" type="range" min="10" max="70" step="0.1" value="49.2" />
    <div class="btnrow">
      <button class="ghost small" data-back="20">20 ft</button>
      <button class="ghost small" data-back="30">30 ft</button>
      <button class="ghost small" data-back="49.2">49 ft</button>
      <button class="ghost small" data-back="60">60 ft</button>
    </div>

    <div class="row">
      <div>
        <label>Counterweight (tons) (override)</label>
        <input id="cwTons" type="number" step="0.1" value="0" min="0" />
      </div>
      <div>
        <label>Mode</label>
        <select id="cwMode">
          <option value="auto" selected>Auto: set CW to balance</option>
          <option value="manual">Manual: use my CW</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Built-up logs in beam</label>
        <select id="logs">
          <option value="4" selected>4 logs (2×2 lash)</option>
          <option value="6">6 logs (3×2 lash)</option>
          <option value="8">8 logs (4×2 lash)</option>
        </select>
      </div>
      <div>
        <label>Log diameter (in)</label>
        <input id="logDia" type="number" step="0.5" value="12" min="6" max="24" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Contact pad area under sling (in²)</label>
        <input id="padArea" type="number" step="10" value="300" min="20" />
      </div>
      <div>
        <label>Move distance per cycle (ft) (Lift+Move)</label>
        <input id="moveFt" type="number" step="0.5" value="3" min="0.5" max="20" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Roller/skid friction μ (0.02–0.20)</label>
        <input id="mu" type="range" min="0.02" max="0.20" step="0.005" value="0.06" />
      </div>
      <div>
        <label>Optional pull force (lb) (for sliding)</label>
        <input id="pullLb" type="number" step="100" value="2000" min="0" />
      </div>
    </div>

    <div class="btnrow">
      <button id="liftToggleBtn">Lift (toggle up/down)</button>
      <button id="cycleBtn" class="secondary">Run cycles (Lift+Move)</button>
      <button id="stepBtn" class="ghost">Step (1 cycle)</button>
      <button id="resetBtn" class="ghost">Reset</button>
    </div>

    <h2 style="margin-top:14px;">Live Results</h2>
    <div class="kpi">
      <div class="box">
        <div class="t">Required counterweight</div>
        <div class="v" id="cwOut">—</div>
      </div>
      <div class="box">
        <div class="t">Mechanical advantage (r_back / r_front)</div>
        <div class="v" id="maOut">—</div>
      </div>
      <div class="box">
        <div class="t">Beam bending stress (approx)</div>
        <div class="v" id="stressOut">—</div>
      </div>
      <div class="box">
        <div class="t">Contact pressure at sling pad</div>
        <div class="v" id="pressOut">—</div>
      </div>
    </div>

    <div class="kpi" style="margin-top:10px;">
      <div class="box">
        <div class="t">Move resistance (μ·W) estimate</div>
        <div class="v" id="moveResOut">—</div>
      </div>
      <div class="box">
        <div class="t">A-frame load split (per leg)</div>
        <div class="v" id="legOut">—</div>
      </div>
    </div>

    <div id="statusBox" class="ok" style="display:none;"></div>

    <h2>Equations (live)</h2>
    <div class="mono" id="eqBox">Loading…</div>

    <h2>Short explanation text (for your paper)</h2>
    <textarea id="paperText" readonly></textarea>

    <div class="foot">
      Fixes you asked for:
      <b>(1)</b> beam “logs” flex visually up/down during lift and return to default on lower,
      <b>(2)</b> block returns to the ground line when lowered,
      <b>(3)</b> rope line drawn from mast/A-frame apex to counterweight.
    </div>
  </section>

  <!-- CANVAS -->
  <section>
    <canvas id="c"></canvas>
  </section>
</main>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const FT_TO_M=0.3048;
  const LB_TO_N=4.4482216152605;
  const PSI_TO_MPA=0.006894757293168;

  // Demo thresholds (rough)
  const WOOD_ALLOW_MPA=40;
  const WOOD_WARN_MPA=60;
  const PRESS_WARN_PSI=6000;
  const PRESS_OK_PSI=2500;

  // Canvas
  const canvas=$("c");
  const ctx=canvas.getContext("2d");
  function resizeCanvas(){
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*devicePixelRatio);
    canvas.height=Math.floor(r.height*devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  // Inputs
  const rigType=$("rigType");
  const simMode=$("simMode");
  const units=$("units");
  const tonType=$("tonType");
  const tons=$("tons");
  const liftIn=$("liftIn");
  const rFront=$("rFront");
  const rBack=$("rBack");
  const cwTons=$("cwTons");
  const cwMode=$("cwMode");
  const logs=$("logs");
  const logDia=$("logDia");
  const padArea=$("padArea");
  const moveFt=$("moveFt");
  const mu=$("mu");
  const pullLb=$("pullLb");

  // Presets
  $("front209").onclick=()=>{ rFront.value=2.09; computeAndRender(); };
  $("front300").onclick=()=>{ rFront.value=3.00; computeAndRender(); };
  $("front400").onclick=()=>{ rFront.value=4.00; computeAndRender(); };
  document.querySelectorAll('button[data-back]').forEach(b=>{
    b.onclick=()=>{ rBack.value=b.getAttribute("data-back"); computeAndRender(); };
  });

  // State
  const state={
    // Lift toggle mode
    liftToggle:false,
    // Cycle mode
    cycling:false,
    oneStep:false,
    phase:"idle", // idle, lifting, moving, lowering
    liftProgress:0, // 0..1
    xMove:0, // ft
    phaseT:0,
    targetMove:0,
    lastT:performance.now()
  };

  function blockWeightLb(tonsVal,type){
    if(type==="short") return tonsVal*2000;
    if(type==="long") return tonsVal*2240;
    return tonsVal*2204.62262185; // metric tonne (weight in lbf)
  }

  function sectionFromLogs(nLogs,diaIn){
    const d=diaIn;
    let cols=2,rows=2;
    if(nLogs===6){cols=3;rows=2;}
    if(nLogs===8){cols=4;rows=2;}
    const b=cols*d;
    const h=rows*d;
    const S=b*h*h/6;
    return {b,h,S,cols,rows};
  }

  function compute(){
    const U=units.value;
    const tonsVal=Math.max(1,Number(tons.value)||80);
    const rF_ft=clamp(Number(rFront.value)||2.09,0.2,1000);
    const rB_ft=clamp(Number(rBack.value)||49.2,0.2,10000);

    const Wb_lb=blockWeightLb(tonsVal,tonType.value);
    const tauBlock=Wb_lb*rF_ft;

    const Wcw_req_lb=tauBlock/rB_ft;
    let Wcw_lb=Wcw_req_lb;

    if(cwMode.value==="manual"){
      const cw_user=Math.max(0,Number(cwTons.value)||0);
      Wcw_lb=blockWeightLb(cw_user,tonType.value);
    }else{
      let cw_ton;
      if(tonType.value==="short") cw_ton=Wcw_req_lb/2000;
      else if(tonType.value==="long") cw_ton=Wcw_req_lb/2240;
      else cw_ton=Wcw_req_lb/2204.62262185;
      cwTons.value=cw_ton.toFixed(2);
    }

    const tauCW=Wcw_lb*rB_ft;
    const tauRatio=tauCW/tauBlock;

    const R_lb=Wb_lb+Wcw_lb;
    const M_lbft=Math.max(tauBlock,tauCW);

    const nLogs=Number(logs.value)||4;
    const diaIn=Math.max(6,Number(logDia.value)||12);
    const sec=sectionFromLogs(nLogs,diaIn);

    const M_lbin=M_lbft*12;
    const sigma_psi=M_lbin/sec.S;
    const sigma_mpa=sigma_psi*PSI_TO_MPA;

    const A_in2=Math.max(1,Number(padArea.value)||300);
    const p_psi=Wb_lb/A_in2;
    const p_mpa=p_psi*PSI_TO_MPA;

    const MA=rB_ft/rF_ft;
    const liftTargetIn=clamp(Number(liftIn.value)||6,0.5,48);

    const muVal=Number(mu.value)||0.06;
    const moveRes_lb=muVal*Wb_lb;
    const pullAvail_lb=Math.max(0,Number(pullLb.value)||0);

    const legLoad_lb=R_lb/2;

    return {
      U, tonsVal, Wb_lb,
      rF_ft,rB_ft,
      Wcw_req_lb,Wcw_lb,
      tauBlock,tauCW,tauRatio,
      R_lb,M_lbft,
      sec,sigma_psi,sigma_mpa,
      A_in2,p_psi,p_mpa,
      MA,liftTargetIn,
      muVal,moveRes_lb,pullAvail_lb,
      legLoad_lb,
      // metric extras
      Wb_N:Wb_lb*LB_TO_N,
      Wcw_N:Wcw_lb*LB_TO_N,
      R_N:R_lb*LB_TO_N,
      rF_m:rF_ft*0.3048,
      rB_m:rB_ft*0.3048,
      M_Nm:M_lbft*LB_TO_N*0.3048,
      moveRes_N:moveRes_lb*LB_TO_N
    };
  }

  function fmt(n,d=2){ return Number(n).toFixed(d); }

  function setPaperText(){
    const text =
`Ancient counterbalanced lever-crane concept (plausible construction workflow)

A practical way to reposition multi-ton stone blocks is to lift them only a small amount—just enough to reduce ground friction and insert rollers/skids—rather than lifting them high. A long lever beam lashed from multiple logs can pivot on a seat/yoke mounted to a mast (or two-mast A-frame). The block hangs from the short front arm, while a counterweight hangs from the long back arm.

The governing physics is torque balance about the fulcrum:
  τ_block = W_block · r_front
  τ_cw    = W_cw · r_back
Lift begins when τ_cw ≥ τ_block, so the required counterweight is:
  W_cw = W_block · (r_front / r_back)

This means a very long back arm can reduce the needed counterweight substantially, while still enabling a controlled lift. To avoid cracking and visible damage, the load must be spread: a built-up beam (4, 6, or 8 logs lashed) increases the section modulus S and reduces bending stress (σ ≈ M/S), while wide sling pads reduce local contact pressure (p = W/A). Once the stone is raised a few inches, it can be slid forward on rollers; the required pull is roughly F ≈ μ·W, where μ is small for rollers.

Much ancient engineering was transmitted by apprenticeship, demonstration, and oral tradition rather than detailed technical writing. As a result, effective “everyday” lifting rigs could be widely used yet lightly recorded—surviving mainly as fragments, stories, or simplified depictions—while still being completely achievable with the materials available at the time (timber, rope, stone weights, and simple joinery).`;
    $("paperText").value = text;
  }

  function setStatus(d){
    const status=$("statusBox");
    let cls="ok";
    const msg=[];
    const liftable=d.tauRatio>=1;

    if(d.sigma_mpa>WOOD_WARN_MPA){
      cls="warn";
      msg.push(`Beam stress VERY HIGH (${fmt(d.sigma_mpa,1)} MPa). Add logs/diameter or increase r_back / reduce r_front.`);
    }else if(d.sigma_mpa>WOOD_ALLOW_MPA){
      cls="warn";
      msg.push(`Beam stress high (${fmt(d.sigma_mpa,1)} MPa). More logs/diameter lowers stress.`);
    }else{
      msg.push(`Beam stress in safer demo range (${fmt(d.sigma_mpa,1)} MPa).`);
    }

    if(d.p_psi>PRESS_WARN_PSI){
      cls="warn";
      msg.push(`Contact pressure EXTREME (${fmt(d.p_psi,0)} psi). Wider pads/rollers reduce point loading.`);
    }else if(d.p_psi>PRESS_OK_PSI){
      msg.push(`Contact pressure moderate (${fmt(d.p_psi,0)} psi). Wider pads reduce risk of cracking.`);
    }else{
      msg.push(`Contact pressure relatively low (${fmt(d.p_psi,0)} psi) with current pad area.`);
    }

    if(liftable) msg.push(`Lift condition met (τ_ratio=${fmt(d.tauRatio,2)}).`);
    else { cls="warn"; msg.push(`Not enough torque (τ_ratio=${fmt(d.tauRatio,2)}). Increase CW or r_back.`); }

    if(simMode.value==="liftMove"){
      const canMove=d.pullAvail_lb>=d.moveRes_lb;
      if(canMove) msg.push(`Move OK: pull ${fmt(d.pullAvail_lb,0)} lb ≥ μW ${fmt(d.moveRes_lb,0)} lb.`);
      else { cls="warn"; msg.push(`Move may stall: pull ${fmt(d.pullAvail_lb,0)} lb < μW ${fmt(d.moveRes_lb,0)} lb.`); }
    }

    status.className=cls;
    status.style.display="block";
    status.textContent=msg.join(" ");
  }

  function updateOutputs(d){
    // CW
    let cwDisplay;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwDisplay=`${fmt(cw_ton,2)} tons (${fmt(d.Wcw_lb,0)} lb)`;
      $("maOut").textContent=`${fmt(d.MA,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_psi/1000,2)} ksi`;
      $("pressOut").textContent=`${fmt(d.p_psi,0)} psi`;
      $("moveResOut").textContent=`${fmt(d.moveRes_lb,0)} lb`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt(d.legLoad_lb,0)} lb/leg` : "—";
    }else{
      cwDisplay=`${fmt(d.Wcw_N/1000,1)} kN`;
      $("maOut").textContent=`${fmt(d.MA,2)} ×`;
      $("stressOut").textContent=`${fmt(d.sigma_mpa,1)} MPa`;
      $("pressOut").textContent=`${fmt(d.p_mpa,2)} MPa`;
      $("moveResOut").textContent=`${fmt(d.moveRes_N/1000,1)} kN`;
      $("legOut").textContent = rigType.value==="aframe" ? `${fmt((d.R_N/2)/1000,1)} kN/leg` : "—";
    }
    $("cwOut").textContent=cwDisplay;

    // Equations panel
    const eq=[];
    eq.push(`TORQUE / LIFT:`);
    eq.push(`  τ_block = W_b · r_front`);
    eq.push(`  τ_cw    = W_cw · r_back`);
    eq.push(`  Lift when τ_cw ≥ τ_block`);
    eq.push(`  Balance CW: W_cw = W_b · (r_front / r_back)`);
    eq.push(``);
    eq.push(`MECHANICAL ADVANTAGE: MA = r_back / r_front`);
    eq.push(``);
    eq.push(`FULCRUM REACTION (approx): R ≈ W_b + W_cw`);
    eq.push(``);
    eq.push(`BEAM BENDING: M ≈ max(τ_block, τ_cw),   σ ≈ M / S`);
    eq.push(`  S ≈ (b · h²)/6 (built-up logs as a block)`);
    eq.push(``);
    eq.push(`CONTACT PRESSURE: p = W_b / A_pad`);
    eq.push(``);
    eq.push(`MOVE (rollers/skids): F_resist ≈ μ · W_b`);
    eq.push(``);
    eq.push(`LIVE VALUES:`);
    eq.push(`  W_b=${fmt(d.Wb_lb,0)} lb (${fmt(d.Wb_N/1000,1)} kN)`);
    eq.push(`  r_front=${fmt(d.rF_ft,2)} ft (${fmt(d.rF_m,3)} m)`);
    eq.push(`  r_back =${fmt(d.rB_ft,1)} ft (${fmt(d.rB_m,3)} m)`);
    eq.push(`  τ_block=${fmt(d.tauBlock,0)} lb·ft`);
    eq.push(`  τ_cw   =${fmt(d.tauCW,0)} lb·ft`);
    eq.push(`  τ_ratio=${fmt(d.tauRatio,3)}`);
    eq.push(`  W_cw   =${fmt(d.Wcw_lb,0)} lb (${fmt(d.Wcw_N/1000,1)} kN)`);
    eq.push(`  R≈${fmt(d.R_lb,0)} lb (${fmt(d.R_N/1000,1)} kN)`);
    eq.push(`  M≈${fmt(d.M_lbft,0)} lb·ft (${fmt(d.M_Nm,0)} N·m)`);
    eq.push(`  Logs: ${d.sec.cols}×${d.sec.rows}, d=${fmt(Number(logDia.value),1)} in`);
    eq.push(`  b=${fmt(d.sec.b,1)} in, h=${fmt(d.sec.h,1)} in, S=${fmt(d.sec.S,0)} in³`);
    eq.push(`  σ≈${fmt(d.sigma_psi,0)} psi (${fmt(d.sigma_mpa,1)} MPa)`);
    eq.push(`  A_pad=${fmt(d.A_in2,0)} in² → p≈${fmt(d.p_psi,0)} psi (${fmt(d.p_mpa,2)} MPa)`);
    eq.push(`  μ=${fmt(d.muVal,3)} → F_resist≈${fmt(d.moveRes_lb,0)} lb`);
    eq.push(`  Pull=${fmt(d.pullAvail_lb,0)} lb`);
    eq.push(`  Moved=${fmt(state.xMove,1)} ft`);
    $("eqBox").textContent=eq.join("\n");
  }

  // Drawing helpers
  function arrow(x0,y0,x1,y1,text){
    ctx.strokeStyle="#111"; ctx.fillStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    const ang=Math.atan2(y1-y0,x1-x0), a=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1-a*Math.cos(ang-0.5), y1-a*Math.sin(ang-0.5));
    ctx.lineTo(x1-a*Math.cos(ang+0.5), y1-a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+a*Math.cos(ang-0.5), y0+a*Math.sin(ang-0.5));
    ctx.lineTo(x0+a*Math.cos(ang+0.5), y0+a*Math.sin(ang+0.5));
    ctx.closePath(); ctx.fill();
    ctx.font="12px Arial";
    ctx.fillText(text, (x0+x1)/2 - 30, y0 - 6);
  }

  function draw(d){
    resizeCanvas();
    const w=canvas.getBoundingClientRect().width;
    const h=canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    // ground
    const groundY=h-70;
    ctx.beginPath(); ctx.moveTo(30,groundY); ctx.lineTo(w-30,groundY);
    ctx.lineWidth=4; ctx.strokeStyle="#1f8a3b"; ctx.stroke();

    // pivot placement
    const pivotX=210;
    const pivotY=groundY-250;

    // scale lever arms to pixels
    const avail=(w-270)-60;
    const totalFt=d.rF_ft+d.rB_ft;
    const pxPerFt=clamp(avail/totalFt,3,20);

    const frontPx=d.rF_ft*pxPerFt;
    const backPx =d.rB_ft*pxPerFt;

    // Base beam Y position with "visual flex":
    // As lift increases, beam shows slight rotation/deflection: front end goes up, back end goes down (or vice versa).
    // We keep pivot fixed and shift endpoints to show flex/rocking, then return when lowered.
    const flex = state.liftProgress; // 0..1
    const maxFlexPx = 14;           // visual only
    const frontFlexY = -maxFlexPx * flex; // front rises
    const backFlexY  = +maxFlexPx * flex; // back dips

    const beamY = pivotY;
    const beamX0 = pivotX - frontPx;
    const beamX1 = pivotX + backPx;

    // supports + apex point for ropes
    let apexX=pivotX, apexY=pivotY;
    if(rigType.value==="single"){
      // mast
      ctx.fillStyle="#111";
      ctx.fillRect(pivotX-10, pivotY, 20, groundY-pivotY);

      // yoke
      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(pivotX-22, pivotY-22, 44, 44);
      ctx.strokeRect(pivotX-22, pivotY-22, 44, 44);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Vertical mast", pivotX-55, groundY-10);
      ctx.fillText("Pivot / yoke", pivotX-50, pivotY-35);

      apexX=pivotX; apexY=pivotY-2; // rope attachment near yoke
    }else{
      const baseLeftX=pivotX-95, baseRightX=pivotX+95, baseY=groundY;
      apexX=pivotX; apexY=pivotY+10;

      ctx.strokeStyle="#111"; ctx.lineWidth=10;
      ctx.beginPath();
      ctx.moveTo(baseLeftX, baseY); ctx.lineTo(apexX, apexY);
      ctx.moveTo(baseRightX, baseY); ctx.lineTo(apexX, apexY);
      ctx.stroke();

      ctx.fillStyle="#e5e7eb"; ctx.strokeStyle="#111"; ctx.lineWidth=2;
      ctx.fillRect(apexX-26, apexY-26, 52, 52);
      ctx.strokeRect(apexX-26, apexY-26, 52, 52);

      ctx.fillStyle="#111"; ctx.font="13px Arial";
      ctx.fillText("Two-mast A-frame", pivotX-70, groundY-10);
      ctx.fillText("Apex / pivot plate", apexX-75, apexY-35);
    }

    // beam thickness by logs
    const nL=Number(logs.value)||4;
    const thick=(nL===4)?16:(nL===6)?20:24;

    // draw beam as a line from front to back with flex
    ctx.strokeStyle="#0b3d91"; ctx.lineWidth=thick;
    ctx.beginPath();
    ctx.moveTo(beamX0, beamY + frontFlexY);
    ctx.lineTo(beamX1, beamY + backFlexY);
    ctx.stroke();

    ctx.lineWidth=1;
    ctx.fillStyle="#0b3d91"; ctx.font="15px Arial";
    ctx.fillText(`Built-up beam (${logs.value} logs lashed)`, (beamX0+beamX1)/2 - 150, beamY - 22);

    // arm labels
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`Front arm r_front = ${fmt(d.rF_ft,2)} ft`, beamX0 + 10, beamY - 80);
    ctx.fillText(`Back arm r_back = ${fmt(d.rB_ft,1)} ft`, pivotX + 10, beamY - 105);

    // sling point follows beam front with flex + move
    const slingBaseX = beamX0 + 36;
    const moveNowPx = state.xMove * pxPerFt;
    const slingX = slingBaseX + moveNowPx;

    // linear interpolate beam Y at slingX position for rope attach (so rope follows the flexed beam)
    // param t from beamX0..beamX1
    const t = clamp((slingX - beamX0) / (beamX1 - beamX0), 0, 1);
    const beamYSling = (beamY + frontFlexY) * (1-t) + (beamY + backFlexY) * t;

    // block lift progress moves it upward; when lowered, it returns to the ground line
    const liftPx = (d.liftTargetIn/12.0) * pxPerFt;
    const liftNow = state.liftProgress * liftPx;

    // place block bottom exactly on ground when liftProgress=0
    const blockW=78, blockH=78;
    const blockBottomY = groundY; // bottom touches ground line
    const blockTopY_atGround = blockBottomY - blockH;
    const blockY = blockTopY_atGround - liftNow; // lift moves block up from ground
    const blockX = slingX - blockW/2;

    // sling rope to block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(slingX, beamYSling + 8);
    ctx.lineTo(slingX, blockY);
    ctx.stroke();

    // block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(blockX, blockY, blockW, blockH);
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    ctx.fillText(`${tons.value}-ton block`, blockX - 8, blockY + blockH + 18);
    ctx.fillText("Sling", slingX - 16, (beamYSling + blockY)/2);

    // rollers/skids drawn near ground when Lift+Move mode
    if(simMode.value==="liftMove"){
      const skidY = groundY - 14;
      const underX0 = blockX - 10;
      const underX1 = blockX + blockW + 10;

      ctx.strokeStyle="#6b7280"; ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(underX0, skidY); ctx.lineTo(underX1, skidY); ctx.stroke();

      for(let x=underX0+18; x<underX1-12; x+=26){
        ctx.beginPath();
        ctx.arc(x, skidY+10, 8, 0, Math.PI*2);
        ctx.strokeStyle="#111"; ctx.lineWidth=2;
        ctx.stroke();
      }
      ctx.fillStyle="#111"; ctx.font="12px Arial";
      ctx.fillText("Rollers / skids (lift → slide → set down)", 36, groundY-44);
    }

    // counterweight position follows beam end with flex
    const cwW=56, cwH=56;
    const cwX = beamX1 - 30 - cwW/2;
    const beamYCW = beamY + backFlexY;
    const cwY = beamYCW + 48;

    // draw counterweight rope from apex/pole to counterweight (your requested line)
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(apexX, apexY);        // from mast yoke / A-frame apex
    ctx.lineTo(cwX + cwW/2, cwY);    // to top center of counterweight
    ctx.stroke();

    // counterweight block
    ctx.strokeStyle="#111"; ctx.lineWidth=2;
    ctx.strokeRect(cwX, cwY, cwW, cwH);

    // label cw
    ctx.fillStyle="#111"; ctx.font="13px Arial";
    let cwText;
    if(d.U==="imperial"){
      let cw_ton;
      if(tonType.value==="short") cw_ton=d.Wcw_lb/2000;
      else if(tonType.value==="long") cw_ton=d.Wcw_lb/2240;
      else cw_ton=d.Wcw_lb/2204.62262185;
      cwText = `${fmt(cw_ton,2)} tons`;
    }else{
      cwText = `${fmt(d.Wcw_N/1000,1)} kN`;
    }
    ctx.fillText("Counterweight", cwX - 14, cwY + cwH + 18);
    ctx.fillText(cwText, cwX + 4, cwY + cwH + 34);

    // arrows for arms (draw from pivot to ends)
    arrow(pivotX, beamY-135, beamX1, beamY-135, "r_back");
    arrow(beamX0, beamY-105, pivotX, beamY-105, "r_front");

    // info box
    const infoX=w-330, infoY=24;
    ctx.fillStyle="#f9fafb"; ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
    ctx.fillRect(infoX, infoY, 300, 155);
    ctx.strokeRect(infoX, infoY, 300, 155);

    ctx.fillStyle="#111"; ctx.font="12px Arial";
    ctx.fillText(`Mode: ${simMode.value==="liftMove" ? "Lift+Move" : "Lift only"}`, infoX+10, infoY+22);
    ctx.fillText(`Rig: ${rigType.value==="aframe" ? "A-frame" : "Single mast"}`, infoX+10, infoY+40);
    ctx.fillText(`τ_ratio = ${fmt(d.tauRatio,2)} (≥1 lifts)`, infoX+10, infoY+58);
    ctx.fillText(`Beam stress ≈ ${fmt(d.sigma_psi/1000,2)} ksi`, infoX+10, infoY+76);
    ctx.fillText(`Pad pressure ≈ ${fmt(d.p_psi,0)} psi`, infoX+10, infoY+94);
    ctx.fillText(`Lift = ${fmt(d.liftTargetIn,1)} in, progress=${fmt(state.liftProgress,2)}`, infoX+10, infoY+112);
    ctx.fillText(`Moved = ${fmt(state.xMove,1)} ft`, infoX+10, infoY+130);
    if(simMode.value==="liftMove"){
      ctx.fillText(`μW ≈ ${fmt(d.moveRes_lb,0)} lb, pull=${fmt(d.pullAvail_lb,0)} lb`, infoX+10, infoY+148);
    }

    ctx.fillStyle = (d.tauRatio>=1) ? "#14532d" : "#7f1d1d";
    ctx.font="13px Arial";
    ctx.fillText((d.tauRatio>=1) ? "LIFT POSSIBLE" : "NOT ENOUGH TORQUE", infoX+170, infoY+22);
  }

  // Behavior
  function computeAndRender(){
    const d=compute();
    updateOutputs(d);
    setStatus(d);
    draw(d);
  }

  // Lift toggle button: up/down + logs flex + return to default + block returns to ground.
  $("liftToggleBtn").onclick=()=>{
    // liftOnly: toggle up/down
    // liftMove: we still allow manual lift toggle too (but cycles button is the main)
    state.liftToggle = !state.liftToggle;
    // stop cycling if user takes manual control
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    $("liftToggleBtn").textContent = state.liftToggle ? "Lower (toggle)" : "Lift (toggle up/down)";
  };

  // Cycle controls
  $("cycleBtn").onclick=()=>{
    if(simMode.value!=="liftMove"){
      // If not in liftMove, switch it
      simMode.value="liftMove";
    }
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle up/down)";

    state.cycling = !state.cycling;
    state.oneStep=false;

    if(state.cycling){
      state.phase="lifting";
      state.phaseT=0;
      state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
      $("cycleBtn").textContent="Stop cycles";
    }else{
      state.phase="idle";
      state.phaseT=0;
      $("cycleBtn").textContent="Run cycles (Lift+Move)";
    }
  };

  $("stepBtn").onclick=()=>{
    if(simMode.value!=="liftMove"){
      simMode.value="liftMove";
    }
    state.liftToggle=false;
    $("liftToggleBtn").textContent="Lift (toggle up/down)";
    state.cycling=true;
    state.oneStep=true;
    state.phase="lifting";
    state.phaseT=0;
    state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
    $("cycleBtn").textContent="Stop cycles";
  };

  $("resetBtn").onclick=()=>{
    state.liftToggle=false;
    state.cycling=false;
    state.oneStep=false;
    state.phase="idle";
    state.phaseT=0;
    state.liftProgress=0;
    state.xMove=0;
    state.targetMove=0;
    $("liftToggleBtn").textContent="Lift (toggle up/down)";
    $("cycleBtn").textContent="Run cycles (Lift+Move)";
    computeAndRender();
  };

  // Animation loop
  function advance(dt){
    const d=compute();
    const liftable = d.tauRatio>=1;

    // If lift not possible, force lift down (safety)
    if(!liftable){
      state.liftProgress = clamp(state.liftProgress - dt*1.6, 0, 1);
      state.liftToggle=false;
      if(state.cycling){
        state.cycling=false;
        state.oneStep=false;
        state.phase="idle";
        $("cycleBtn").textContent="Run cycles (Lift+Move)";
      }
      return;
    }

    // Manual lift toggle (dominates if not cycling)
    if(state.liftToggle && !state.cycling){
      state.liftProgress = clamp(state.liftProgress + dt*1.0, 0, 1);
      return;
    }
    if(!state.liftToggle && !state.cycling){
      // return to ground (block bottom on ground line) + beam returns to neutral
      state.liftProgress = clamp(state.liftProgress - dt*1.2, 0, 1);
      return;
    }

    // Cycling mode (liftMove)
    if(state.cycling){
      if(state.phase==="lifting"){
        state.liftProgress = clamp(state.liftProgress + dt*1.0, 0, 1);
        if(state.liftProgress>=1){
          state.phase="moving";
          state.phaseT=0;
        }
      }
      else if(state.phase==="moving"){
        const canMove = d.pullAvail_lb >= d.moveRes_lb;
        const speed = canMove ? 1.0 : 0.18;
        const moveRateFtPerSec = 2.0 * speed;

        const step = moveRateFtPerSec * dt;
        const remaining = Math.max(0, state.targetMove - (state.phaseT * state.targetMove));
        const adv = Math.min(step, remaining);

        const fracStep = adv / state.targetMove;
        state.phaseT = clamp(state.phaseT + fracStep, 0, 1);
        state.xMove += adv;

        if(state.phaseT>=1){
          state.phase="lowering";
          state.phaseT=0;
        }
      }
      else if(state.phase==="lowering"){
        state.liftProgress = clamp(state.liftProgress - dt*1.3, 0, 1);
        if(state.liftProgress<=0){
          // cycle complete
          if(state.oneStep){
            state.cycling=false;
            state.oneStep=false;
            state.phase="idle";
            $("cycleBtn").textContent="Run cycles (Lift+Move)";
          }else{
            state.phase="lifting";
            state.phaseT=0;
            state.targetMove=Math.max(0.1,Number(moveFt.value)||3);
          }
        }
      }
    }
  }

  function tick(t){
    const dt=Math.min(0.05,(t-state.lastT)/1000);
    state.lastT=t;
    advance(dt);
    computeAndRender();
    requestAnimationFrame(tick);
  }

  // Hook inputs
  [
    rigType, simMode, units, tonType, tons, liftIn, rFront, rBack, cwTons, cwMode,
    logs, logDia, padArea, moveFt, mu, pullLb
  ].forEach(el=>{
    el.addEventListener("input", computeAndRender);
    el.addEventListener("change", computeAndRender);
  });

  // Init
  resizeCanvas();
  setPaperText();
  computeAndRender();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
