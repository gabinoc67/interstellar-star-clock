<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Saturation → Regulation Simulator</title>

<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --muted:rgba(232,238,246,.82);
    --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:410px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  .pill{
    display:inline-block;padding:2px 8px;border-radius:999px;
    border:1px solid var(--btnb);background:var(--panel2);font-size:12px;
  }
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:240px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}
  .eq{
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    background:var(--panel2);border:1px solid var(--line);border-radius:10px;padding:8px;
  }

  /* Highlighted k meter */
  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg, #142235, #251c0b, #2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:800;
    letter-spacing:.5px;
    font-size:22px;
    padding:4px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;
    height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{height:100%;width:0%;}
  .meterFill{
    background:linear-gradient(90deg, #3a5678, #b68b2e, #ff7a18);
  }

  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
</style>
</head>

<body>
<div class="wrap">

  <!-- LEFT PANEL -->
  <div class="panel">
    <h2>Hexagon Saturation → Regulation</h2>

    <div class="row">
      <button data-add="1">+ Add 1</button>
      <button data-add="2">+ Add 2</button>
      <button data-add="3">+ Add 3</button>
      <button data-add="4">+ Add 4</button>
      <button data-add="5">+ Add 5</button>
      <button data-add="6">+ Add 6</button>
      <button data-add="7">+ Add 7</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Hexes: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Hex size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="32" value="18" />

    <label>Container radius R (global limit): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240" />

    <label>Regulation strength k (how hard compression applies):</label>
    <!-- IMPORTANT: step lets you land on 0.93 exactly -->
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.93" />

    <!-- BIG highlighted strength display -->
    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">0.93</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <h3>Regulation equation</h3>
    <div class="eq" id="eqBox"></div>

    <h3>Why 6 → 7 won’t work locally</h3>
    <div class="warn small">
      A regular hex grid has a <b>hard local rule</b>: each interior cell has <b>6 equal neighbors</b>.
      Trying to “make a 7th” forces distortion (angles/edges) or requires new independent directions.
      <br><br>
      So the system does not become a 7-point hexagon. Instead, growth triggers <b>global regulation</b>:
      the whole patch is compressed to fit inside R while the 6-neighbor lattice stays intact.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <!-- CANVAS -->
  <canvas id="c"></canvas>

</div>

<script>
(() => {
  // ===== Hex math (axial coords) =====
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key = (q,r)=> q + "," + r;

  function hexRing(radius){
    if(radius === 0) return [[0,0]];
    let q = dirs[4][0] * radius;
    let r = dirs[4][1] * radius;
    const out = [];
    for(let side=0; side<6; side++){
      const [dq, dr] = dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q += dq; r += dr;
      }
    }
    return out;
  }

  function axialToPixel(q, r, size){
    // pointy-top
    const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
    const y = size * (3/2 * r);
    return [x,y];
  }

  function polygonHex(x,y,size){
    const pts=[];
    for(let i=0;i<6;i++){
      const ang = (Math.PI/180) * (60*i - 30);
      pts.push([x + size*Math.cos(ang), y + size*Math.sin(ang)]);
    }
    return pts;
  }

  // ===== State =====
  let rings = 0;
  const cells = new Map();
  cells.set(key(0,0), {q:0,r:0});

  // ===== UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const ringsPill = document.getElementById("ringsPill");
  const cellsPill = document.getElementById("cellsPill");
  const modePill  = document.getElementById("modePill");
  const logEl = document.getElementById("log");

  const sizeEl = document.getElementById("size");
  const REl = document.getElementById("R");
  const kEl = document.getElementById("k");

  const sizeVal = document.getElementById("sizeVal");
  const RVal = document.getElementById("RVal");
  const kBig = document.getElementById("kBig");
  const kFill = document.getElementById("kFill");
  const kText = document.getElementById("kText");
  const eqBox = document.getElementById("eqBox");

  function log(line){
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function updateStats(){
    ringsPill.textContent = "Rings: " + rings;
    cellsPill.textContent = "Hexes: " + cells.size;
  }

  function updateKUI(){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    // Fill meter: map [0.50..2.50] -> [0..100]
    const pct = Math.max(0, Math.min(100, ((k - 0.50) / 2.00) * 100));
    kFill.style.width = pct.toFixed(1) + "%";

    // Strength label
    let label = "Soft compression (gentle regulation).";
    if(k >= 1.00 && k < 1.50) label = "Balanced regulation (noticeable compression).";
    if(k >= 1.50 && k < 2.10) label = "Strong regulation (tight containment).";
    if(k >= 2.10) label = "Very strong regulation (hard clamp).";
    kText.textContent = label;
  }

  function updateEq(){
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    eqBox.textContent =
`Let r_max = max distance of any hex center from origin.

If r_max <= R : (Geometry mode)
    positions remain unchanged.

If r_max > R : (Regulation mode)
    scale factor s = (R / r_max)^k
    x' = s x
    y' = s y

k controls "how hard" the clamp is.
Higher k => stronger compression when saturation occurs.`;
  }

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(canvas.clientWidth  * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  // ===== Growth =====
  function addOneRing(){
    rings += 1;
    const ringCells = hexRing(rings);
    let added = 0;
    for(const [q,r] of ringCells){
      const K = key(q,r);
      if(!cells.has(K)){
        cells.set(K, {q,r});
        added++;
      }
    }
    return added;
  }

  function computeMaxRadius(size){
    let maxD = 0;
    for(const {q,r} of cells.values()){
      const [x,y] = axialToPixel(q,r,size);
      const d = Math.hypot(x,y);
      if(d > maxD) maxD = d;
    }
    return maxD;
  }

  function computeScale(size, R, k){
    const rMax = computeMaxRadius(size);
    if(rMax <= R) return { s: 1, rMax };
    const s = Math.pow(R / rMax, k);
    return { s, rMax };
  }

  // ===== Draw =====
  function draw(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);

    sizeVal.textContent = size;
    RVal.textContent = R;
    updateKUI();
    updateEq();
    updateStats();

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx = w/2, cy = h/2;

    // container circle
    ctx.strokeStyle = "#3a5678";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI*2);
    ctx.stroke();

    // regulation
    const { s, rMax } = computeScale(size, R, k);
    const regulated = (s < 0.999999);

    modePill.textContent = "Mode: " + (regulated ? "Regulation" : "Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";

    // draw cells
    for(const {q,r} of cells.values()){
      const [x0,y0] = axialToPixel(q,r,size);
      const x = cx + s*x0;
      const y = cy + s*y0;

      const pts = polygonHex(x,y, s*size*0.98);

      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<6;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();

      // boundary estimate by axial distance
      const dist = (Math.abs(q) + Math.abs(r) + Math.abs(-q-r)) / 2;
      const isBoundary = (dist === rings);

      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.fill();

      ctx.strokeStyle = isBoundary ? "#8aa7c8" : "#456784";
      ctx.lineWidth = isBoundary ? 1.6 : 1;
      ctx.stroke();
    }

    // diagnostic label
    ctx.fillStyle = "#e8eef6";
    ctx.font = "12px system-ui, Segoe UI, Arial";
    const msg = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R}. Regulation: s=${s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R}. Pure geometry (k=${k.toFixed(2)})`;
    ctx.fillText(msg, 14, 18);
  }

  // ===== Step / Add-N logic =====
  function doStep(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);

    const added = addOneRing();
    log(`STEP: Added ring ${rings}. New cells: ${added}. Total hexes: ${cells.size}.`);

    const rMax = computeMaxRadius(size);
    if(rMax <= R){
      log(`CHECK: r_max=${rMax.toFixed(2)} <= R=${R}. Geometry is sufficient. 6-neighbor rule stays exact.`);
      log(`RESULT: Growth continues normally. No contradiction — boundary just expands.`);
    } else {
      const s = Math.pow(R / rMax, k);
      log(`CHECK: r_max=${rMax.toFixed(2)} > R=${R}. Expansion saturates (does not fail).`);
      log(`TAKEOVER: Regulation engages: s=(R/r_max)^k = (${R}/${rMax.toFixed(2)})^${k.toFixed(2)} = ${s.toFixed(4)}.`);
      log(`EFFECT: Global compression fits the patch inside R while local hex structure remains readable.`);
      log(`NOTE: You cannot create a true “7-point hexagon” locally; the extra capacity is handled globally.`);
    }
    log("—");
    draw();
  }

  function addN(n){
    log(`ADD ${n}: will add ${n} rings (1…${n}) step-by-step.`);
    for(let i=0;i<n;i++) doStep();
  }

  // Buttons: + Add 1..7
  document.querySelectorAll("button[data-add]").forEach(btn=>{
    btn.addEventListener("click", ()=> addN(parseInt(btn.dataset.add,10)));
  });

  document.getElementById("step").addEventListener("click", doStep);

  document.getElementById("reset").addEventListener("click", () => {
    rings = 0;
    cells.clear();
    cells.set(key(0,0), {q:0,r:0});
    logEl.textContent = "";
    log("RESET: Back to 1 hex (ring 0). Geometry mode.");
    log("Use +Add 1..7 to grow multiple rings.");
    log("—");
    draw();
  });

  [sizeEl, REl, kEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: Back to 1 hex (ring 0). Geometry mode.");
  log("Use +Add 1..7 to add rings step-by-step (you’ll see when regulation activates).");
  log("—");
  resize();
})();
</script>
</body>
</html>
