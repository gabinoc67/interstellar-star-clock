<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hex Coherence: Add Boundary Lines (Segments) + Regulation (k)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:230px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  /* Highlighted k panel */
  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }

  .box{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
  }
  .bigNum{
    font-weight:900;font-size:20px;
    padding:2px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    display:inline-block;
  }
  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Hex Coherence: Add Boundary Lines (Segments) → Regulation (k)</h2>

    <div class="row">
      <button id="addRing1">+ Add 1 ring</button>
      <button id="addRing3">+ Add 3 rings</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Hexes: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Hex size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="34" value="18" />

    <label>Container radius R (domain): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240" />

    <label>Regulation strength k (compression strength):</label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.94" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">0.94</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <h3>Add “more lines” to the same hexagon boundary</h3>
    <div class="box">
      <div class="row" style="align-items:center;justify-content:space-between;">
        <div class="small">
          Corners stay <b>6</b> (still a hexagon).<br>
          “Lines” = how many <b>edge segments</b> the boundary is split into (6,7,8,9…).
        </div>
        <div class="bigNum" id="segBig">6</div>
      </div>

      <div class="row">
        <button id="segMinus">-1</button>
        <button id="segPlus">+1</button>
        <button id="segPlus5">+5</button>
        <button id="segSet6">6</button>
        <button id="segAuto">Auto ↑ to circle</button>
      </div>

      <label>Boundary segments (lines): <span id="segVal"></span></label>
      <input id="segments" type="range" min="6" max="120" step="1" value="6" />

      <div class="small" style="margin-top:6px;">
        This does <b>not</b> create a 7-corner polygon. It keeps the hex and just adds more boundary line pieces.
        Coherence is enforced by the circle domain; regulation compresses only when growth would exceed R.
      </div>
    </div>

    <div class="warn small" style="margin-top:10px;">
      In your framing: “identity” (6 corners) stays fixed; added segments are supplementation (more articulation).
      The remainder is global saturation; regulation (k) translates it into a scale factor s so coherence stays in-domain.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // ===== Hex grid (axial coords) =====
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key  = (q,r)=> `${q},${r}`;

  function hexRing(radius){
    if(radius===0) return [[0,0]];
    let q = dirs[4][0]*radius;
    let r = dirs[4][1]*radius;
    const out=[];
    for(let side=0; side<6; side++){
      const [dq,dr]=dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q += dq; r += dr;
      }
    }
    return out;
  }

  function axialToPixel(q,r,size){
    // pointy-top layout
    return [
      size*(Math.sqrt(3)*q + Math.sqrt(3)/2*r),
      size*(3/2*r)
    ];
  }

  // 6-corner hex vertices (always)
  function hexVertices(cx,cy,rad){
    const pts=[];
    for(let i=0;i<6;i++){
      const ang = (Math.PI/180) * (60*i - 30);
      pts.push([cx + rad*Math.cos(ang), cy + rad*Math.sin(ang)]);
    }
    return pts;
  }

  // Distribute totalSegments across 6 sides as evenly as possible.
  // Example: totalSegments=7 => [2,1,1,1,1,1] (still a hex, one side is split into 2 segments)
  function segmentsPerSide(totalSegments){
    const base = Math.floor(totalSegments / 6);
    let rem = totalSegments % 6;
    const arr = new Array(6).fill(base);
    // give the remainder to first sides
    for(let i=0;i<6 && rem>0;i++,rem--) arr[i] += 1;
    // ensure at least 1 segment per side (we clamp slider min to 6 anyway)
    for(let i=0;i<6;i++) if(arr[i] < 1) arr[i] = 1;
    return arr;
  }

  // Draw hex boundary using totalSegments segments while keeping the same 6 corners.
  function strokeHexWithSegments(pts, totalSegments){
    const perSide = segmentsPerSide(totalSegments);
    ctx.beginPath();
    for(let s=0;s<6;s++){
      const a = pts[s];
      const b = pts[(s+1)%6];
      const n = perSide[s];
      // split side into n subsegments
      for(let i=0;i<n;i++){
        const t0 = i / n;
        const t1 = (i+1) / n;
        const x0 = a[0] + (b[0]-a[0]) * t0;
        const y0 = a[1] + (b[1]-a[1]) * t0;
        const x1 = a[0] + (b[0]-a[0]) * t1;
        const y1 = a[1] + (b[1]-a[1]) * t1;
        ctx.moveTo(x0,y0);
        ctx.lineTo(x1,y1);
      }
    }
    ctx.stroke();
  }

  // ===== State =====
  let rings = 0;
  const cells = new Map();
  cells.set(key(0,0), {q:0,r:0});

  // ===== UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const sizeEl = document.getElementById("size");
  const REl    = document.getElementById("R");
  const kEl    = document.getElementById("k");
  const segEl  = document.getElementById("segments");

  const sizeVal= document.getElementById("sizeVal");
  const RVal   = document.getElementById("RVal");
  const ringsPill=document.getElementById("ringsPill");
  const cellsPill=document.getElementById("cellsPill");
  const modePill =document.getElementById("modePill");

  const kBig  = document.getElementById("kBig");
  const kFill = document.getElementById("kFill");
  const kText = document.getElementById("kText");

  const segBig = document.getElementById("segBig");
  const segVal = document.getElementById("segVal");

  const logEl = document.getElementById("log");
  const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  function updatePills(regulated){
    ringsPill.textContent = "Rings: " + rings;
    cellsPill.textContent = "Hexes: " + cells.size;
    modePill.textContent = "Mode: " + (regulated ? "Regulation" : "Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
  }

  function updateKUI(regulated){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    const pct = Math.max(0, Math.min(100, ((k - 0.50) / 2.00) * 100));
    kFill.style.width = pct.toFixed(1) + "%";

    let label = "Soft compression.";
    if(k >= 1.00 && k < 1.50) label = "Balanced regulation.";
    if(k >= 1.50 && k < 2.10) label = "Strong regulation.";
    if(k >= 2.10) label = "Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent = label;
  }

  function updateSegUI(){
    const S = parseInt(segEl.value,10);
    segBig.textContent = String(S);
    segVal.textContent = String(S);
  }

  // ===== Growth + Regulation =====
  function addRing(){
    rings++;
    let added=0;
    for(const [q,r] of hexRing(rings)){
      const K=key(q,r);
      if(!cells.has(K)){ cells.set(K,{q,r}); added++; }
    }
    return added;
  }

  function maxRadius(size){
    let m=0;
    for(const {q,r} of cells.values()){
      const [x,y]=axialToPixel(q,r,size);
      m = Math.max(m, Math.hypot(x,y));
    }
    return m;
  }

  function computeScale(size,R,k){
    const rMax = maxRadius(size);
    if(rMax <= R) return {s:1, rMax};
    return {s: Math.pow(R/rMax, k), rMax};
  }

  function strokeForK(regulated, k){
    const t = Math.max(0, Math.min(1, (k - 0.50)/2.00));
    const cool = {r:69,g:103,b:132};
    const warm = {r:182,g:139,b:46};
    const r = Math.round(cool.r*(1-t) + warm.r*t);
    const g = Math.round(cool.g*(1-t) + warm.g*t);
    const b = Math.round(cool.b*(1-t) + warm.b*t);
    const a = regulated ? (0.70 + 0.20*t) : (0.55 + 0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }

  // ===== Render =====
  function resize(){
    const dpr=Math.max(1, window.devicePixelRatio || 1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function draw(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const S = parseInt(segEl.value,10);

    sizeVal.textContent = size;
    RVal.textContent = R;
    updateSegUI();

    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx0=w/2, cy0=h/2;

    // domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(cx0,cy0,R,0,Math.PI*2);
    ctx.stroke();

    // regulation
    const {s, rMax} = computeScale(size,R,k);
    const regulated = s < 0.999999;
    updatePills(regulated);
    updateKUI(regulated);

    // draw all cells: fill + segmented boundary
    for(const {q,r} of cells.values()){
      const [x0,y0]=axialToPixel(q,r,size);
      const cx = cx0 + s*x0;
      const cy = cy0 + s*y0;

      const dist=(Math.abs(q)+Math.abs(r)+Math.abs(-q-r))/2;
      const isBoundary = dist === rings;

      const rad = s*size*0.98;
      const pts = hexVertices(cx,cy,rad);

      // fill polygon (true hex)
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<6;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();
      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.fill();

      // segmented boundary shows “more lines”
      ctx.strokeStyle = strokeForK(regulated, k);
      ctx.lineWidth = isBoundary ? 1.8 : 1.05;
      strokeHexWithSegments(pts, S);
    }

    // overlay diagnostics
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const msg = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R} → Regulation ON (s=${s.toFixed(3)}, k=${k.toFixed(2)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R} → Geometry ON (s=1.000, k=${k.toFixed(2)})`;
    ctx.fillText(msg, 14, 18);

    ctx.fillStyle = regulated ? "rgba(182,139,46,0.95)" : "rgba(138,167,200,0.95)";
    ctx.fillText(`Hex corners=6 always | boundary line segments S=${S} (6→7→8→…)`, 14, 36);

    // show on the center cell too
    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="bold 13px system-ui, Segoe UI, Arial";
    ctx.fillText(`k=${k.toFixed(2)}`, cx0-28, cy0+4);
    ctx.font="bold 12px system-ui, Segoe UI, Arial";
    ctx.fillText(`S=${S}`, cx0-16, cy0+20);
  }

  // ===== Step logic =====
  function doStep(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const S = parseInt(segEl.value,10);

    const added = addRing();
    log(`STEP: Added ring ${rings}. +${added} hexes. Total: ${cells.size}.`);

    const rMax = maxRadius(size);
    if(rMax <= R){
      log(`CHECK: r_max=${rMax.toFixed(2)} <= R=${R}. In-domain coherence holds.`);
      log(`NOTE: Added boundary segments S=${S}. Hex is still 6-corner (same identity), just more line pieces.`);
    } else {
      const s = Math.pow(R/rMax, k);
      log(`CHECK: r_max=${rMax.toFixed(2)} > R=${R}. Would exceed domain → regulation clamps.`);
      log(`TAKEOVER: k=${k.toFixed(2)} → s=${s.toFixed(4)}. Coherence preserved inside circle.`);
    }
    log("—");
    draw();
  }

  // ===== Controls =====
  document.getElementById("step").onclick = doStep;
  document.getElementById("addRing1").onclick = doStep;
  document.getElementById("addRing3").onclick = () => { doStep(); doStep(); doStep(); };

  document.getElementById("reset").onclick = () => {
    rings=0;
    cells.clear();
    cells.set(key(0,0), {q:0,r:0});
    logEl.textContent="";
    log("RESET: 1 hex (ring 0). Corners=6 always. Add boundary segments S=6→7→8…");
    log("—");
    draw();
  };

  function setSeg(v){
    v = Math.max(6, Math.min(120, v));
    segEl.value = String(v);
    draw();
  }

  document.getElementById("segMinus").onclick = ()=>setSeg(parseInt(segEl.value,10)-1);
  document.getElementById("segPlus").onclick  = ()=>setSeg(parseInt(segEl.value,10)+1);
  document.getElementById("segPlus5").onclick = ()=>setSeg(parseInt(segEl.value,10)+5);
  document.getElementById("segSet6").onclick  = ()=>setSeg(6);

  // Auto: increase segments until near circle fill (visual density), but never affects geometry.
  document.getElementById("segAuto").onclick = () => {
    // push S upward in steps until either S hits max or saturation is visually near (r_max close to R)
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);

    let S = parseInt(segEl.value,10);
    // we don't want infinite loops; cap iterations
    for(let it=0; it<60; it++){
      const {rMax} = computeScale(size,R,k);
      // if patch is close to domain edge, stop
      if(rMax >= 0.98*R) break;
      S += 1;
      if(S >= 120) break;
      segEl.value = String(S);
    }
    draw();
  };

  [sizeEl, REl, kEl, segEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: 1 hex (ring 0). Corners=6 always. Add boundary segments S=6→7→8…");
  log("More boundary line pieces do not break coherence; only leaving the circle would, so regulation clamps.");
  log("—");
  resize();
})();
</script>
</body>
</html>
