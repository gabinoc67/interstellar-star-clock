<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hex → Heptagon Attempt (Why 7 Points Won’t Tile)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e; --bad:#ff4d4d;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:10px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);
    background:var(--panel2);font-size:12px;}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:220px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}
  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
  .bad{
    border-left:4px solid var(--bad);
    background:rgba(255,77,77,.08);
    padding:10px;border-radius:10px;
  }
  .toggle{
    display:flex;gap:10px;align-items:center;justify-content:space-between;
    background:var(--panel2);border:1px solid var(--line);border-radius:10px;padding:10px;margin-top:10px;
  }
  .big{
    font-weight:800;font-size:20px;padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>“Add 7th point” test</h2>

    <div class="row">
      <button id="add1">+ Add 1 ring</button>
      <button id="add3">+ Add 3 rings</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Cells: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Hex size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="30" value="18">

    <label>Container radius R: <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240">

    <label>Regulation strength k: <span id="kVal"></span></label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.93">

    <div class="toggle">
      <div class="small"><b>Cell sides</b><br>6 = real hex tiling<br>7 = “add a line” attempt</div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="set6">Use 6</button>
        <button id="set7">Use 7</button>
        <div class="big" id="sidesBig">6</div>
      </div>
    </div>

    <h3>What you’ll see</h3>
    <div class="warn small">
      Switching to <b>7 sides</b> does not change the underlying lattice (still hex centers).
      It only changes the drawn polygon. That’s intentional: it reveals the truth.
      <br><br>
      A regular heptagon cannot meet neighbors edge-to-edge all around without leaving
      <b>gaps/overlaps</b>. The mismatch will be highlighted in red.
    </div>

    <h3>Why it “won’t work” as a rule</h3>
    <div class="bad small" id="whyBox">
      In 6-mode, neighbor edges align (tiling works).
      In 7-mode, edges cannot align with all neighbors at once → tiling breaks.
      That means “7 points” is not an extension of the hex rule — it’s a different geometry.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>

</div>

<script>
(() => {
  // --- axial hex grid (centers) ---
  const dirs=[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key=(q,r)=>q+","+r;

  function hexRing(radius){
    if(radius===0) return [[0,0]];
    let q=dirs[4][0]*radius, r=dirs[4][1]*radius;
    const out=[];
    for(let side=0; side<6; side++){
      const [dq,dr]=dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q+=dq; r+=dr;
      }
    }
    return out;
  }

  function axialToPixel(q,r,size){
    // pointy-top layout
    return [
      size*(Math.sqrt(3)*q + Math.sqrt(3)/2*r),
      size*(3/2*r)
    ];
  }

  // polygon with N sides around (x,y)
  function polygonN(x,y,radius,sides){
    const pts=[];
    // keep visual alignment similar to hex orientation
    const rot = -Math.PI/6; // -30°
    for(let i=0;i<sides;i++){
      const a = rot + i*(2*Math.PI/sides);
      pts.push([x + radius*Math.cos(a), y + radius*Math.sin(a)]);
    }
    return pts;
  }

  // --- state ---
  let rings=0;
  const cells=new Map();
  cells.set(key(0,0),{q:0,r:0});
  let sides=6; // 6 or 7

  // --- UI ---
  const canvas=document.getElementById("c");
  const ctx=canvas.getContext("2d");
  const sizeEl=document.getElementById("size");
  const REl=document.getElementById("R");
  const kEl=document.getElementById("k");
  const logEl=document.getElementById("log");

  const ringsPill=document.getElementById("ringsPill");
  const cellsPill=document.getElementById("cellsPill");
  const modePill=document.getElementById("modePill");

  const sizeVal=document.getElementById("sizeVal");
  const RVal=document.getElementById("RVal");
  const kVal=document.getElementById("kVal");
  const sidesBig=document.getElementById("sidesBig");
  const whyBox=document.getElementById("whyBox");

  function log(t){ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; }

  function addOneRing(){
    rings++;
    let added=0;
    for(const [q,r] of hexRing(rings)){
      const K=key(q,r);
      if(!cells.has(K)){ cells.set(K,{q,r}); added++; }
    }
    return added;
  }

  function maxRadius(size){
    let m=0;
    for(const {q,r} of cells.values()){
      const [x,y]=axialToPixel(q,r,size);
      m=Math.max(m,Math.hypot(x,y));
    }
    return m;
  }

  function computeScale(size,R,k){
    const rMax=maxRadius(size);
    if(rMax<=R) return {s:1,rMax};
    return {s:Math.pow(R/rMax,k), rMax};
  }

  function resize(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function updatePills(regulated){
    ringsPill.textContent="Rings: "+rings;
    cellsPill.textContent="Cells: "+cells.size;
    sidesBig.textContent=String(sides);
    modePill.textContent="Mode: "+(regulated?"Regulation":"Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
  }

  // core: show mismatch when sides=7 by “gap score”
  // we estimate mismatch as: in a true tiling, polygons should share edges.
  // With hex centers fixed, a 7-gon edge will rarely line up with neighbor direction.
  function edgeMismatchScore(){
    if(sides===6) return 0; // by design, hex orientation fits this lattice visually
    // simple heuristic: 7-gon has edge directions at multiples of 360/7,
    // but neighbor directions are multiples of 60°.
    // Compute nearest angle distance between 60° and 360/7 grid.
    const neighborAngles=[0,60,120,180,240,300];
    const edgeStep=360/sides; // ~51.428...
    let best=999;
    for(const a of neighborAngles){
      // closest multiple of edgeStep
      const m=Math.round(a/edgeStep)*edgeStep;
      const d=Math.abs(a-m);
      best=Math.min(best, Math.min(d, 360-d));
    }
    // normalize 0..1 where 0 means “aligns”
    return Math.min(1, best / 30); // 30° scale
  }

  function draw(){
    const size=+sizeEl.value;
    const R=+REl.value;
    const k=parseFloat(kEl.value);

    sizeVal.textContent=size;
    RVal.textContent=R;
    kVal.textContent=k.toFixed(2);

    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha=.35;
    ctx.strokeStyle="#1f2c3c";
    ctx.lineWidth=1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha=1;

    const cx=w/2, cy=h/2;

    // container
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(cx,cy,R,0,Math.PI*2);
    ctx.stroke();

    const {s,rMax}=computeScale(size,R,k);
    const regulated=(s<0.999999);
    updatePills(regulated);

    const mismatch=edgeMismatchScore();
    if(sides===6){
      whyBox.textContent =
        "6 sides works because the hex lattice is a true 6-neighbor tiling. Edges can align around the plane.";
    } else {
      whyBox.textContent =
        "7 sides cannot tile on this lattice. The heptagon’s edge directions cannot align with all 6 neighbor directions. Gaps/overlaps are unavoidable — that’s why a true 7-point upgrade won’t work as a local rule.";
    }

    // draw cells
    for(const {q,r} of cells.values()){
      const [x0,y0]=axialToPixel(q,r,size);
      const x=cx+s*x0, y=cy+s*y0;

      const dist=(Math.abs(q)+Math.abs(r)+Math.abs(-q-r))/2;
      const isBoundary=(dist===rings);

      // polygon radius:
      // use a slightly smaller radius so shapes show separation cleanly
      const rad = s*size*0.98;
      const pts = polygonN(x,y,rad,sides);

      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();

      // fill base
      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.fill();

      // stroke: in 7-mode, highlight mismatch with red intensity
      if(sides===7){
        // stronger red when mismatch is higher
        const alpha = 0.25 + 0.65*mismatch;
        ctx.strokeStyle = `rgba(255,77,77,${alpha})`;
        ctx.lineWidth = isBoundary ? 2.2 : 1.6;
      } else {
        ctx.strokeStyle = isBoundary ? "#8aa7c8" : "#456784";
        ctx.lineWidth = isBoundary ? 1.6 : 1.0;
      }
      ctx.stroke();
    }

    // diagnostic text
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const msg = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R}. Regulation: s=${s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R}. Pure geometry (k=${k.toFixed(2)})`;
    ctx.fillText(msg, 14, 18);

    if(sides===7){
      ctx.fillStyle="rgba(255,77,77,.95)";
      ctx.fillText(`7-point attempt → tiling mismatch (heuristic): ${mismatch.toFixed(2)}  (red = cannot align)`, 14, 36);
    } else {
      ctx.fillStyle="rgba(138,167,200,.95)";
      ctx.fillText(`6-point hex → valid local tiling`, 14, 36);
    }
  }

  function stepOnce(){
    const added=addOneRing();
    log(`STEP: Added ring ${rings}. +${added} cells. Total ${cells.size}.`);

    if(sides===7){
      log(`7-POINT MODE: You are drawing heptagons on hex centers.`);
      log(`Result: gaps/overlaps are unavoidable (heptagons don't tile this plane).`);
      log(`So it cannot become a consistent “7-neighbor local rule.”`);
    } else {
      log(`6-POINT MODE: True hex tiling; interior cells keep 6 neighbors cleanly.`);
    }
    log("—");
    draw();
  }

  // controls
  document.getElementById("add1").onclick=()=>stepOnce();
  document.getElementById("add3").onclick=()=>{ stepOnce(); stepOnce(); stepOnce(); };
  document.getElementById("reset").onclick=()=>{
    rings=0; cells.clear(); cells.set(key(0,0),{q:0,r:0});
    logEl.textContent="";
    log("RESET: ring 0 (one cell).");
    log("Use 6 to see valid tiling. Use 7 to see why it cannot work as a local rule.");
    log("—");
    draw();
  };

  document.getElementById("set6").onclick=()=>{
    sides=6;
    log("SET: Cell sides = 6 (valid tiling).");
    log("—");
    draw();
  };
  document.getElementById("set7").onclick=()=>{
    sides=7;
    log("SET: Cell sides = 7 (heptagon attempt).");
    log("This will highlight mismatch because 7-gons cannot tile the hex lattice.");
    log("—");
    draw();
  };

  [sizeEl,REl,kEl].forEach(el=>el.addEventListener("input", draw));

  // init
  log("RESET: ring 0 (one cell).");
  log("Use 6 to see valid tiling. Use 7 to see why it cannot work as a local rule.");
  log("—");
  resize();
})();
</script>
</body>
</html>
