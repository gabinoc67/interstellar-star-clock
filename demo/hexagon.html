<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Polygon Coherence: N-Side Boundary + Regulation (k)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:230px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }

  .box{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
  }
  .bigNum{
    font-weight:900;font-size:20px;
    padding:2px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    display:inline-block;
  }
  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Polygon Coherence: N-Side Boundary → Regulation (k)</h2>

    <div class="row">
      <button id="addRing1">+ Add 1 ring</button>
      <button id="addRing3">+ Add 3 rings</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Cells: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Cell size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="34" value="18" />

    <label>Container radius R (domain): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240" />

    <label>Regulation strength k (compression strength):</label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.94" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">0.94</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <h3>Boundary “lines” now change the shape (6 → 7 → 8 → …)</h3>
    <div class="box">
      <div class="row" style="align-items:center;justify-content:space-between;">
        <div class="small">
          Sides = corners = <b>N</b> (polygon).<br>
          Set N=6 for a hexagon, N=7 for a 7-gon, etc.
        </div>
        <div class="bigNum" id="nBig">6</div>
      </div>

      <div class="row">
        <button id="nMinus">-1</button>
        <button id="nPlus">+1</button>
        <button id="nPlus5">+5</button>
        <button id="nSet6">6</button>
        <button id="nAuto">Auto ↑ toward circle</button>
      </div>

      <label>Polygon sides N: <span id="nVal"></span></label>
      <input id="N" type="range" min="3" max="120" step="1" value="6" />

      <div class="small" style="margin-top:6px;">
        Coherence is still enforced by the circle domain; regulation compresses only when growth would exceed R.
      </div>
    </div>

    <div class="warn small" style="margin-top:10px;">
      Interpretation: you can increase boundary complexity (N) while keeping the whole patch coherent in the same domain.
      If the patch would exceed the circle, regulation (k) applies a global scale factor s.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // ===== Hex grid (axial coords) =====
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key  = (q,r)=> `${q},${r}`;

  function hexRing(radius){
    if(radius===0) return [[0,0]];
    let q = dirs[4][0]*radius;
    let r = dirs[4][1]*radius;
    const out=[];
    for(let side=0; side<6; side++){
      const [dq,dr]=dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q += dq; r += dr;
      }
    }
    return out;
  }

  function axialToPixel(q,r,size){
    // pointy-top layout
    return [
      size*(Math.sqrt(3)*q + Math.sqrt(3)/2*r),
      size*(3/2*r)
    ];
  }

  // ===== N-gon vertices (N sides => N corners) =====
  function polygonVertices(cx, cy, rad, n){
    const pts=[];
    // keep the same "pointy-top" feel as your original (-30° offset)
    const offset = -Math.PI/6;
    for(let i=0;i<n;i++){
      const ang = (Math.PI*2)*(i/n) + offset;
      pts.push([cx + rad*Math.cos(ang), cy + rad*Math.sin(ang)]);
    }
    return pts;
  }

  function fillAndStrokePolygon(pts){
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // ===== State =====
  let rings = 0;
  const cells = new Map();
  cells.set(key(0,0), {q:0,r:0});

  // ===== UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const sizeEl = document.getElementById("size");
  const REl    = document.getElementById("R");
  const kEl    = document.getElementById("k");
  const nEl    = document.getElementById("N");

  const sizeVal= document.getElementById("sizeVal");
  const RVal   = document.getElementById("RVal");
  const ringsPill=document.getElementById("ringsPill");
  const cellsPill=document.getElementById("cellsPill");
  const modePill =document.getElementById("modePill");

  const kBig  = document.getElementById("kBig");
  const kFill = document.getElementById("kFill");
  const kText = document.getElementById("kText");

  const nBig = document.getElementById("nBig");
  const nVal = document.getElementById("nVal");

  const logEl = document.getElementById("log");
  const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  function updatePills(regulated){
    ringsPill.textContent = "Rings: " + rings;
    cellsPill.textContent = "Cells: " + cells.size;
    modePill.textContent = "Mode: " + (regulated ? "Regulation" : "Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
  }

  function updateKUI(regulated){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    const pct = Math.max(0, Math.min(100, ((k - 0.50) / 2.00) * 100));
    kFill.style.width = pct.toFixed(1) + "%";

    let label = "Soft compression.";
    if(k >= 1.00 && k < 1.50) label = "Balanced regulation.";
    if(k >= 1.50 && k < 2.10) label = "Strong regulation.";
    if(k >= 2.10) label = "Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent = label;
  }

  function updateNUI(){
    const N = parseInt(nEl.value,10);
    nBig.textContent = String(N);
    nVal.textContent = String(N);
  }

  // ===== Growth + Regulation =====
  function addRing(){
    rings++;
    let added=0;
    for(const [q,r] of hexRing(rings)){
      const K=key(q,r);
      if(!cells.has(K)){ cells.set(K,{q,r}); added++; }
    }
    return added;
  }

  function maxRadius(size){
    let m=0;
    for(const {q,r} of cells.values()){
      const [x,y]=axialToPixel(q,r,size);
      m = Math.max(m, Math.hypot(x,y));
    }
    return m;
  }

  function computeScale(size,R,k){
    const rMax = maxRadius(size);
    if(rMax <= R) return {s:1, rMax};
    return {s: Math.pow(R/rMax, k), rMax};
  }

  function strokeForK(regulated, k){
    const t = Math.max(0, Math.min(1, (k - 0.50)/2.00));
    const cool = {r:69,g:103,b:132};
    const warm = {r:182,g:139,b:46};
    const r = Math.round(cool.r*(1-t) + warm.r*t);
    const g = Math.round(cool.g*(1-t) + warm.g*t);
    const b = Math.round(cool.b*(1-t) + warm.b*t);
    const a = regulated ? (0.70 + 0.20*t) : (0.55 + 0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }

  // ===== Render =====
  function resize(){
    const dpr=Math.max(1, window.devicePixelRatio || 1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function draw(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const N = parseInt(nEl.value,10);

    sizeVal.textContent = size;
    RVal.textContent = R;
    updateNUI();

    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx0=w/2, cy0=h/2;

    // domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(cx0,cy0,R,0,Math.PI*2);
    ctx.stroke();

    // regulation
    const {s, rMax} = computeScale(size,R,k);
    const regulated = s < 0.999999;
    updatePills(regulated);
    updateKUI(regulated);

    // draw all cells: fill + N-gon boundary
    for(const {q,r} of cells.values()){
      const [x0,y0]=axialToPixel(q,r,size);
      const cx = cx0 + s*x0;
      const cy = cy0 + s*y0;

      const dist=(Math.abs(q)+Math.abs(r)+Math.abs(-q-r))/2;
      const isBoundary = dist === rings;

      const rad = s*size*0.98;
      const pts = polygonVertices(cx,cy,rad,N);

      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.strokeStyle = strokeForK(regulated, k);
      ctx.lineWidth = isBoundary ? 1.8 : 1.05;

      fillAndStrokePolygon(pts);
    }

    // overlay diagnostics
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const msg = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R} → Regulation ON (s=${s.toFixed(3)}, k=${k.toFixed(2)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R} → Geometry ON (s=1.000, k=${k.toFixed(2)})`;
    ctx.fillText(msg, 14, 18);

    ctx.fillStyle = regulated ? "rgba(182,139,46,0.95)" : "rgba(138,167,200,0.95)";
    ctx.fillText(`Polygon sides/corners N=${N} (6=hex, 7=heptagon, 8=octagon, ...)`, 14, 36);

    // show on the center cell too
    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="bold 13px system-ui, Segoe UI, Arial";
    ctx.fillText(`k=${k.toFixed(2)}`, cx0-28, cy0+4);
    ctx.font="bold 12px system-ui, Segoe UI, Arial";
    ctx.fillText(`N=${N}`, cx0-16, cy0+20);
  }

  // ===== Step logic =====
  function doStep(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const N = parseInt(nEl.value,10);

    const added = addRing();
    log(`STEP: Added ring ${rings}. +${added} cells. Total: ${cells.size}.`);

    const rMax = maxRadius(size);
    if(rMax <= R){
      log(`CHECK: r_max=${rMax.toFixed(2)} <= R=${R}. In-domain coherence holds.`);
      log(`NOTE: Boundary sides/corners N=${N}.`);
    } else {
      const s = Math.pow(R/rMax, k);
      log(`CHECK: r_max=${rMax.toFixed(2)} > R=${R}. Would exceed domain → regulation clamps.`);
      log(`TAKEOVER: k=${k.toFixed(2)} → s=${s.toFixed(4)}. Coherence preserved inside circle.`);
    }
    log("—");
    draw();
  }

  // ===== Controls =====
  document.getElementById("step").onclick = doStep;
  document.getElementById("addRing1").onclick = doStep;
  document.getElementById("addRing3").onclick = () => { doStep(); doStep(); doStep(); };

  document.getElementById("reset").onclick = () => {
    rings=0;
    cells.clear();
    cells.set(key(0,0), {q:0,r:0});
    logEl.textContent="";
    log("RESET: 1 cell (ring 0). N controls polygon sides: 6→7→8…");
    log("—");
    draw();
  };

  function setN(v){
    v = Math.max(3, Math.min(120, v));
    nEl.value = String(v);
    draw();
  }

  document.getElementById("nMinus").onclick = ()=>setN(parseInt(nEl.value,10)-1);
  document.getElementById("nPlus").onclick  = ()=>setN(parseInt(nEl.value,10)+1);
  document.getElementById("nPlus5").onclick = ()=>setN(parseInt(nEl.value,10)+5);
  document.getElementById("nSet6").onclick  = ()=>setN(6);

  // Auto: increase N toward “circle-like” (more sides), but doesn't change regulation math.
  document.getElementById("nAuto").onclick = () => {
    let N = parseInt(nEl.value,10);
    for(let it=0; it<60; it++){
      N += 1;
      if(N >= 120) break;
      nEl.value = String(N);
    }
    draw();
  };

  [sizeEl, REl, kEl, nEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: 1 cell (ring 0). N controls polygon sides: 6→7→8…");
  log("If the patch would exceed the circle, regulation clamps with s=(R/r_max)^k.");
  log("—");
  resize();
})();
</script>
</body>
</html>
