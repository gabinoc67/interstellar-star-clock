<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Fix: Boundary Refinement (6→7→…→Circle) + Regulation (k)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:230px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }
  .box{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
  }
  .bigNum{
    font-weight:900;font-size:20px;
    padding:2px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    display:inline-block;
  }
  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Hexagon Fix: one shape, refine boundary (6→7→8→…→circle-like)</h2>

    <div class="row">
      <button id="step">+1 side</button>
      <button id="step5">+5 sides</button>
      <button id="reset">Reset (N=6)</button>
      <button id="auto">Auto → circle mirror</button>
    </div>

    <div class="row">
      <span class="pill" id="nPill">N: 6</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
      <span class="pill" id="matchPill">Match: —</span>
    </div>

    <label>Polygon sides N (6=hexagon, 7=heptagon, …): <span id="nVal"></span></label>
    <input id="N" type="range" min="6" max="240" step="1" value="6" />

    <label>Polygon “intent radius” a (tries to be this big): <span id="aVal"></span></label>
    <input id="a" type="range" min="80" max="420" value="260" />

    <label>Container radius R (domain circle): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="520" value="300" />

    <label>Regulation strength k (compression strength):</label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="1.10" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">1.10</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <div class="warn small" style="margin-top:10px;">
      <b>Hexagon Fix mapping:</b> N=6 is the closed planar frame. Increasing N is not a “7th axis” inside the plane — it’s
      boundary refinement that converges to a circular constraint (new embedding behavior). Regulation (k) clamps only when
      the boundary would exceed the domain R.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const NEl = document.getElementById("N");
  const aEl = document.getElementById("a");
  const REl = document.getElementById("R");
  const kEl = document.getElementById("k");

  const nVal = document.getElementById("nVal");
  const aVal = document.getElementById("aVal");
  const RVal = document.getElementById("RVal");

  const nPill = document.getElementById("nPill");
  const modePill = document.getElementById("modePill");
  const matchPill = document.getElementById("matchPill");

  const kBig  = document.getElementById("kBig");
  const kFill = document.getElementById("kFill");
  const kText = document.getElementById("kText");

  const logEl = document.getElementById("log");
  const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // Regular N-gon vertices on circumradius rad
  function polygonVertices(cx, cy, rad, n){
    const pts=[];
    const offset = -Math.PI/6; // keeps a “pointy” feel near N=6
    for(let i=0;i<n;i++){
      const ang = (Math.PI*2)*(i/n) + offset;
      pts.push([cx + rad*Math.cos(ang), cy + rad*Math.sin(ang)]);
    }
    return pts;
  }

  function drawPolygon(pts){
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function updateKUI(regulated){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    const pct = clamp(((k - 0.50) / 2.00) * 100, 0, 100);
    kFill.style.width = pct.toFixed(1) + "%";

    let label = "Soft clamp (gentle regulation).";
    if(k >= 1.00 && k < 1.50) label = "Balanced clamp.";
    if(k >= 1.50 && k < 2.10) label = "Strong clamp.";
    if(k >= 2.10) label = "Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent = label;
  }

  function updatePills(regulated, N, matchPct){
    nPill.textContent = `N: ${N}`;
    modePill.textContent = `Mode: ${regulated ? "Regulation" : "Geometry"}`;
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
    matchPill.textContent = `Match: ${matchPct.toFixed(1)}%`;
  }

  // How “circle-like” is a regular N-gon vs its circumcircle?
  // Using area ratio: A_ngon / A_circle = (N sin(2π/N)) / (2π)
  function circleMatchPercent(N){
    const ratio = (N * Math.sin((2*Math.PI)/N)) / (2*Math.PI);
    return 100 * ratio; // 100% => perfect circle (limit)
  }

  // Regulation: polygon "wants" circumradius = a, but must stay <= R.
  // If a > R, clamp by scale s = (R/a)^k, final radius = a*s.
  function regulatedRadius(a, R, k){
    if(a <= R) return { rad: a, regulated:false, s:1.0 };
    const s = Math.pow(R / a, k);
    return { rad: a * s, regulated:true, s };
  }

  function strokeForK(regulated, k){
    const t = clamp((k - 0.50)/2.00, 0, 1);
    const cool = {r:69,g:103,b:132};
    const warm = {r:182,g:139,b:46};
    const r = Math.round(cool.r*(1-t) + warm.r*t);
    const g = Math.round(cool.g*(1-t) + warm.g*t);
    const b = Math.round(cool.b*(1-t) + warm.b*t);
    const a = regulated ? (0.75 + 0.20*t) : (0.55 + 0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }

  function resize(){
    const dpr=Math.max(1, window.devicePixelRatio || 1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function draw(){
    const N = parseInt(NEl.value,10);
    const a = +aEl.value;     // intended radius
    const R = +REl.value;     // domain radius
    const k = parseFloat(kEl.value);

    nVal.textContent = N;
    aVal.textContent = a;
    RVal.textContent = R;

    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.30;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx=w/2, cy=h/2;

    // domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(cx,cy,R,0,Math.PI*2);
    ctx.stroke();

    // regulation clamp
    const rr = regulatedRadius(a, R, k);
    updateKUI(rr.regulated);

    const matchPct = circleMatchPercent(N);
    updatePills(rr.regulated, N, matchPct);

    // polygon
    const pts = polygonVertices(cx, cy, rr.rad, N);

    ctx.fillStyle = rr.regulated ? "#0f2236" : "#0d1a2a";
    ctx.strokeStyle = strokeForK(rr.regulated, k);
    ctx.lineWidth = 2;
    drawPolygon(pts);

    // “mirror” overlay: show a faint circle at polygon radius so you can see convergence
    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = "rgba(232,238,246,0.35)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(cx,cy,rr.rad,0,Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // diagnostics text
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";

    const geomMsg = rr.regulated
      ? `Clamp: a=${a.toFixed(0)} > R=${R.toFixed(0)} → s=(R/a)^k = ${rr.s.toFixed(3)} (k=${k.toFixed(2)})`
      : `No clamp: a=${a.toFixed(0)} <= R=${R.toFixed(0)} → s=1.000 (k=${k.toFixed(2)})`;

    ctx.fillText(geomMsg, 14, 18);
    ctx.fillStyle="rgba(138,167,200,0.95)";
    ctx.fillText(`Boundary refinement: N=${N} sides. Circle-likeness (area match) ≈ ${matchPct.toFixed(1)}%`, 14, 36);

    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="bold 13px system-ui, Segoe UI, Arial";
    ctx.fillText(`N=${N}`, cx-20, cy+4);
  }

  // ===== Controls =====
  function setN(v){
    v = clamp(v, 6, 240);
    NEl.value = String(v);
    draw();
  }

  document.getElementById("step").onclick = () => {
    const N = parseInt(NEl.value,10);
    setN(N+1);
    log(`STEP: N=${N+1}. (One shape only) Boundary refined: 6→7→8→…  Circle-match ≈ ${circleMatchPercent(N+1).toFixed(2)}%`);
    log("—");
  };

  document.getElementById("step5").onclick = () => {
    const N = parseInt(NEl.value,10);
    setN(N+5);
    log(`STEP: N=${N+5}. Boundary refined +5. Circle-match ≈ ${circleMatchPercent(N+5).toFixed(2)}%`);
    log("—");
  };

  document.getElementById("reset").onclick = () => {
    setN(6);
    logEl.textContent="";
    log("RESET: N=6 (hexagon). This is the planar closed frame.");
    log("Add one 'line' => N=7 (not a new axis, but boundary refinement).");
    log("As N grows large, polygon becomes circle-like (embedding to domain constraint).");
    log("—");
    draw();
  };

  document.getElementById("auto").onclick = () => {
    // Increase N until circle-match is very high (mirror convergence)
    let N = parseInt(NEl.value,10);
    for(let it=0; it<400; it++){
      const m = circleMatchPercent(N);
      if(m >= 99.6) break; // very circle-like
      N += 1;
      if(N >= 240) break;
    }
    setN(N);
    log(`AUTO: N→${N}. Circle-match ≈ ${circleMatchPercent(N).toFixed(2)}% (mirror-like).`);
    log("—");
  };

  [NEl, aEl, REl, kEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: One shape centered in the circle.");
  log("N=6 starts as hexagon. Each +1 makes a 7-gon, 8-gon, ... approaching circle.");
  log("Regulation (k) clamps size only if the polygon would exceed R.");
  log("—");
  resize();
})();
</script>
</body>
</html>
