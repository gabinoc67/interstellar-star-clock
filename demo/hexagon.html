<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexagon Saturation → Regulation + Extra Lines (Coherence)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{
    display:inline-block;padding:2px 8px;border-radius:999px;
    border:1px solid var(--btnb);background:var(--panel2);font-size:12px;
  }
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:220px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  .eq{
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    background:var(--panel2);border:1px solid var(--line);border-radius:10px;padding:8px;
  }

  /* Highlighted k meter */
  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg, #142235, #221a0a, #2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;
    letter-spacing:.5px;
    font-size:22px;
    padding:4px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;
    height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;
    width:0%;
    background:linear-gradient(90deg, #3a5678, #b68b2e, #ff7a18);
  }

  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }

  .box{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
  }
  .bigNum{
    font-weight:900;
    font-size:20px;
    padding:2px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    display:inline-block;
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h2>Hexagon Saturation → Regulation (Coherence)</h2>

    <div class="row">
      <button id="add1">+ Add 1 ring</button>
      <button id="add3">+ Add 3 rings</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Hexes: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Hex size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="34" value="18" />

    <label>Container radius R (global limit): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240" />

    <label>Regulation strength k (how hard compression applies):</label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.94" />

    <!-- HIGHLIGHTED k PANEL (back) -->
    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">0.94</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <!-- EXTRA LINES CONTROL (instead of 6/7 sides) -->
    <h3>Extra lines added inside each hex</h3>
    <div class="box">
      <div class="row" style="align-items:center;justify-content:space-between;">
        <div class="small">
          Hex stays <b>6-sided</b> (tiling stays valid).<br>
          “Extra lines” represent added relational capacity (spokes/diagonals).
        </div>
        <div class="bigNum" id="linesBig">0</div>
      </div>
      <div class="row">
        <button id="linesMinus">-</button>
        <button id="linesPlus">+</button>
        <button id="linesPlus5">+5</button>
        <button id="linesClear">Clear</button>
      </div>
      <label>Extra lines (0…30):</label>
      <input id="lines" type="range" min="0" max="30" step="1" value="0" />
      <div class="small" style="margin-top:6px;">
        Claim modeled here: <b>adding more lines does not break coherence</b> as long as the patch
        stays inside the circle. If it would exceed R, <b>regulation compresses</b> to maintain coherence.
      </div>
    </div>

    <h3>Regulation equation</h3>
    <div class="eq" id="eqBox"></div>

    <h3>Meaning (your rule)</h3>
    <div class="warn small">
      Local geometry stays hex (6 neighbors). Extra lines add <b>structure</b>, not new directions.
      Global limit is handled by regulation (compression), so the system can keep growing while
      maintaining coherence inside the circle.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // ===== Hex math (axial coords) =====
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key = (q,r) => q + "," + r;

  function hexRing(radius){
    if(radius === 0) return [[0,0]];
    let q = dirs[4][0] * radius;
    let r = dirs[4][1] * radius;
    const out = [];
    for(let side=0; side<6; side++){
      const [dq, dr] = dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q += dq; r += dr;
      }
    }
    return out;
  }

  function axialToPixel(q, r, size){
    // pointy-top
    const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
    const y = size * (3/2 * r);
    return [x,y];
  }

  function hexPoints(x,y,r){
    const pts=[];
    for(let i=0;i<6;i++){
      const ang = (Math.PI/180) * (60*i - 30);
      pts.push([x + r*Math.cos(ang), y + r*Math.sin(ang)]);
    }
    return pts;
  }

  // ===== State =====
  let rings = 0;
  const cells = new Map();
  cells.set(key(0,0), {q:0,r:0});

  // ===== UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const logEl = document.getElementById("log");

  const ringsPill = document.getElementById("ringsPill");
  const cellsPill = document.getElementById("cellsPill");
  const modePill  = document.getElementById("modePill");

  const sizeEl = document.getElementById("size");
  const REl    = document.getElementById("R");
  const kEl    = document.getElementById("k");

  const sizeVal = document.getElementById("sizeVal");
  const RVal    = document.getElementById("RVal");

  const kBig = document.getElementById("kBig");
  const kFill= document.getElementById("kFill");
  const kText= document.getElementById("kText");
  const eqBox= document.getElementById("eqBox");

  const linesEl   = document.getElementById("lines");
  const linesBig  = document.getElementById("linesBig");
  const linesMinus= document.getElementById("linesMinus");
  const linesPlus = document.getElementById("linesPlus");
  const linesPlus5= document.getElementById("linesPlus5");
  const linesClear= document.getElementById("linesClear");

  function log(line){
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function updateStats(regulated){
    ringsPill.textContent = "Rings: " + rings;
    cellsPill.textContent = "Hexes: " + cells.size;
    modePill.textContent  = "Mode: " + (regulated ? "Regulation" : "Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
  }

  function updateKUI(){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    const pct = Math.max(0, Math.min(100, ((k - 0.50) / 2.00) * 100));
    kFill.style.width = pct.toFixed(1) + "%";

    let label = "Soft compression (gentle regulation).";
    if(k >= 1.00 && k < 1.50) label = "Balanced regulation (noticeable compression).";
    if(k >= 1.50 && k < 2.10) label = "Strong regulation (tight containment).";
    if(k >= 2.10) label = "Very strong regulation (hard clamp).";
    kText.textContent = label;
  }

  function updateLinesUI(){
    const L = parseInt(linesEl.value,10);
    linesBig.textContent = String(L);
  }

  function updateEq(){
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    eqBox.textContent =
`Let r_max = max distance of any hex center from origin.

If r_max <= R : (Geometry mode)
    positions stay unscaled.

If r_max > R : (Regulation mode)
    scale factor s = (R / r_max)^k
    x' = s x
    y' = s y

k sets how hard the clamp is when saturation occurs.`;
  }

  // ===== Geometry + Regulation =====
  function addRing(){
    rings += 1;
    const ringCells = hexRing(rings);
    let added = 0;
    for(const [q,r] of ringCells){
      const K = key(q,r);
      if(!cells.has(K)){
        cells.set(K, {q,r});
        added++;
      }
    }
    return added;
  }

  function computeMaxRadius(size){
    let maxD = 0;
    for(const {q,r} of cells.values()){
      const [x,y] = axialToPixel(q,r,size);
      maxD = Math.max(maxD, Math.hypot(x,y));
    }
    return maxD;
  }

  function computeScale(size, R, k){
    const rMax = computeMaxRadius(size);
    if(rMax <= R) return {s:1, rMax};
    return {s: Math.pow(R / rMax, k), rMax};
  }

  // ===== Drawing helpers =====
  function strokeForK(baseHex, regulated, k){
    // Visualize k: higher k => warmer + stronger
    // (We avoid fancy color libs; simple blending.)
    // We choose between cool blue and warm orange based on normalized k.
    const t = Math.max(0, Math.min(1, (k - 0.50) / 2.00)); // 0..1
    const cool = {r:69,g:103,b:132};     // #456784-ish
    const warm = {r:182,g:139,b:46};     // #b68b2e-ish
    const r = Math.round(cool.r*(1-t) + warm.r*t);
    const g = Math.round(cool.g*(1-t) + warm.g*t);
    const b = Math.round(cool.b*(1-t) + warm.b*t);
    const alpha = regulated ? (0.55 + 0.35*t) : (0.50 + 0.25*t);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function drawExtraLines(pts, cx, cy, lineCount, strokeStyle, lw){
    // We add "lineCount" internal lines without changing the hex boundary.
    // Pattern:
    //  - First 6 lines: center -> each vertex (spokes)
    //  - Next 6 lines: vertex i -> vertex i+2 (short diagonals)
    //  - Next 6 lines: vertex i -> vertex i+3 (long diagonals)
    //  - Then repeat (still fine visually)
    if(lineCount <= 0) return;

    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lw;
    ctx.beginPath();

    let remaining = lineCount;
    const cycle = (n) => ((n % 6) + 6) % 6;

    // Spokes
    for(let i=0;i<6 && remaining>0;i++){
      ctx.moveTo(cx,cy);
      ctx.lineTo(pts[i][0], pts[i][1]);
      remaining--;
    }
    // Short diagonals (i -> i+2)
    for(let i=0;i<6 && remaining>0;i++){
      const j = cycle(i+2);
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      remaining--;
    }
    // Long diagonals (i -> i+3)
    for(let i=0;i<6 && remaining>0;i++){
      const j = cycle(i+3);
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      remaining--;
    }
    // If still remaining, repeat pattern by wrapping
    let idx = 0;
    while(remaining > 0){
      const i = cycle(idx);
      const j = cycle(idx+2);
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      remaining--;
      idx++;
    }

    ctx.stroke();
  }

  // ===== Draw =====
  function draw(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const L = parseInt(linesEl.value,10);

    sizeVal.textContent = size;
    RVal.textContent = R;
    updateKUI();
    updateLinesUI();
    updateEq();

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx0 = w/2;
    const cy0 = h/2;

    // container circle
    ctx.strokeStyle = "#3a5678";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx0, cy0, R, 0, Math.PI*2);
    ctx.stroke();

    // compute regulation
    const {s, rMax} = computeScale(size, R, k);
    const regulated = (s < 0.999999);
    updateStats(regulated);

    // draw cells
    for(const {q,r} of cells.values()){
      const [x0,y0] = axialToPixel(q,r,size);
      const cx = cx0 + s*x0;
      const cy = cy0 + s*y0;

      const dist = (Math.abs(q) + Math.abs(r) + Math.abs(-q-r)) / 2;
      const isBoundary = (dist === rings);

      const rad = s*size*0.98;
      const pts = hexPoints(cx,cy,rad);

      // fill hex
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<6;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();
      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.fill();

      // boundary stroke reflects k + regulation
      ctx.strokeStyle = strokeForK("#456784", regulated, k);
      ctx.lineWidth = isBoundary ? 1.8 : 1.1;
      ctx.stroke();

      // extra internal lines (do NOT affect tiling)
      if(L > 0){
        const innerStroke = regulated
          ? "rgba(182,139,46,0.30)"
          : "rgba(138,167,200,0.22)";
        const lw = isBoundary ? 1.0 : 0.8;
        drawExtraLines(pts, cx, cy, L, innerStroke, lw);
      }
    }

    // top diagnostics on canvas
    ctx.fillStyle = "#e8eef6";
    ctx.font = "12px system-ui, Segoe UI, Arial";
    const msg1 = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R}  → Regulation ON  (s=${s.toFixed(3)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R}  → Geometry ON  (s=1.000)`;
    ctx.fillText(msg1, 14, 18);

    // show k strongly on the canvas too
    ctx.fillStyle = regulated ? "rgba(182,139,46,0.95)" : "rgba(138,167,200,0.95)";
    ctx.fillText(`k (strength) = ${k.toFixed(2)}   |   extra lines per hex = ${L}`, 14, 36);

    // show k inside the center hex (visual “on the hexagon”)
    ctx.fillStyle = "rgba(232,238,246,0.92)";
    ctx.font = "bold 13px system-ui, Segoe UI, Arial";
    ctx.fillText(`k=${k.toFixed(2)}`, cx0-22, cy0+5);
  }

  // ===== Canvas resize =====
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  // ===== Step logic =====
  function doStep(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);

    const added = addRing();
    log(`STEP: Added ring ${rings}. New hexes: ${added}. Total: ${cells.size}.`);

    const rMax = computeMaxRadius(size);
    if(rMax <= R){
      log(`CHECK: r_max=${rMax.toFixed(2)} <= R=${R}. Coherence maintained by geometry alone.`);
      log(`NOTE: Extra internal lines do not change tiling; they add structure only.`);
    } else {
      const s = Math.pow(R / rMax, k);
      log(`CHECK: r_max=${rMax.toFixed(2)} > R=${R}. Growth saturates (not failure).`);
      log(`TAKEOVER: Regulation engages with k=${k.toFixed(2)} → s=${s.toFixed(4)}.`);
      log(`RESULT: Patch stays inside circle, coherence maintained.`);
    }
    log("—");
    draw();
  }

  // ===== Controls =====
  document.getElementById("step").addEventListener("click", doStep);
  document.getElementById("add1").addEventListener("click", doStep);
  document.getElementById("add3").addEventListener("click", () => { doStep(); doStep(); doStep(); });

  document.getElementById("reset").addEventListener("click", () => {
    rings = 0;
    cells.clear();
    cells.set(key(0,0), {q:0,r:0});
    logEl.textContent = "";
    log("RESET: Back to 1 hex (ring 0).");
    log("Rule: add lines inside hex = more structure; coherence maintained if patch stays inside circle.");
    log("—");
    draw();
  });

  // Extra lines buttons
  function clampLines(v){
    v = Math.max(0, Math.min(30, v));
    linesEl.value = String(v);
    draw();
  }
  linesMinus.addEventListener("click", ()=> clampLines(parseInt(linesEl.value,10)-1));
  linesPlus.addEventListener("click",  ()=> clampLines(parseInt(linesEl.value,10)+1));
  linesPlus5.addEventListener("click", ()=> clampLines(parseInt(linesEl.value,10)+5));
  linesClear.addEventListener("click", ()=> clampLines(0));

  // Sliders
  [sizeEl, REl, kEl, linesEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: Back to 1 hex (ring 0).");
  log("Extra lines add structure (not new geometry). Regulation keeps coherence inside the circle.");
  log("—");
  resize();
})();
</script>
</body>
</html>
