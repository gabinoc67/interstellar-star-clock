<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hex Coherence: Add Lines (Not Points) + Regulation (k)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#101823; --panel2:#0c131d; --line:#1f2c3c;
    --ink:#e8eef6; --btn:#1a2a3d; --btnb:#2d4764; --btnh:#233a55;
    --warn:#b68b2e;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--ink);}
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px;}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;}
  h2{margin:0 0 10px;font-size:16px;}
  h3{margin:12px 0 6px;font-size:13px;opacity:.95}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;}
  button{
    background:var(--btn);color:var(--ink);border:1px solid var(--btnb);
    border-radius:10px;padding:8px 10px;cursor:pointer;
  }
  button:hover{background:var(--btnh);}
  label{display:block;font-size:12px;opacity:.9;margin-top:10px;}
  input[type="range"]{width:100%;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--btnb);background:var(--panel2);font-size:12px;}
  .small{font-size:12px;opacity:.9;line-height:1.4;}
  .log{
    height:230px;overflow:auto;padding:10px;background:var(--panel2);
    border:1px solid var(--line);border-radius:10px;font-size:12px;line-height:1.35;
    white-space:pre-wrap;
  }
  canvas{width:100%;height:calc(100vh - 24px);background:#070a0f;border-radius:12px;border:1px solid var(--line);}

  /* Highlighted k panel */
  .kbox{
    margin-top:8px;
    background:linear-gradient(90deg,#142235,#221a0a,#2b1506);
    border:1px solid var(--btnb);
    border-radius:12px;
    padding:10px;
  }
  .kTop{display:flex;align-items:baseline;justify-content:space-between;gap:10px;}
  .kBig{
    font-weight:900;letter-spacing:.5px;font-size:22px;
    padding:4px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
  }
  .kHint{font-size:12px;opacity:.9;}
  .meter{
    margin-top:8px;height:10px;border-radius:999px;overflow:hidden;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.10);
  }
  .meterFill{
    height:100%;width:0%;
    background:linear-gradient(90deg,#3a5678,#b68b2e,#ff7a18);
  }

  .box{
    background:var(--panel2);
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
  }
  .bigNum{
    font-weight:900;font-size:20px;
    padding:2px 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    display:inline-block;
  }
  .warn{
    border-left:4px solid var(--warn);
    background:#191203;
    padding:10px;border-radius:10px;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h2>Hex Coherence: Add Lines (Not Points) → Regulation (k)</h2>

    <div class="row">
      <button id="add1">+ Add 1 ring</button>
      <button id="add3">+ Add 3 rings</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <span class="pill" id="ringsPill">Rings: 0</span>
      <span class="pill" id="cellsPill">Hexes: 1</span>
      <span class="pill" id="modePill">Mode: Geometry</span>
    </div>

    <label>Hex size: <span id="sizeVal"></span></label>
    <input id="size" type="range" min="12" max="34" value="18" />

    <label>Container radius R (domain): <span id="RVal"></span></label>
    <input id="R" type="range" min="160" max="460" value="240" />

    <label>Regulation strength k (compression strength):</label>
    <input id="k" type="range" min="0.50" max="2.50" step="0.01" value="0.94" />

    <div class="kbox">
      <div class="kTop">
        <div class="kHint"><b>Strength</b> (k)</div>
        <div class="kBig" id="kBig">0.94</div>
      </div>
      <div class="meter"><div class="meterFill" id="kFill"></div></div>
      <div class="kHint" id="kText" style="margin-top:6px;"></div>
    </div>

    <h3>How many internal lines to add (hex stays 6-sided)</h3>
    <div class="box">
      <div class="row" style="align-items:center;justify-content:space-between;">
        <div class="small">
          The boundary is always a <b>6-point hexagon</b>.<br>
          Extra “lines” are internal structure only (do NOT add vertices).
        </div>
        <div class="bigNum" id="linesBig">6</div>
      </div>

      <div class="row">
        <button id="L6">6</button>
        <button id="L12">12</button>
        <button id="L24">24</button>
        <button id="L48">48</button>
        <button id="L96">96</button>
      </div>

      <label>Extra internal lines (0…200):</label>
      <input id="lines" type="range" min="0" max="200" step="1" value="6" />
      <div class="small" style="margin-top:6px;">
        Rule you stated: <b>More lines do not break the hex rules</b> as long as the patch stays inside the circle.
        If growth would exceed R, <b>regulation compresses</b> to keep coherence.
      </div>
    </div>

    <h3>Rule statement (locked)</h3>
    <div class="warn small">
      A hexagon is defined by its <b>6 vertices</b>. We never change that.  
      Adding more lines means adding <b>internal connections</b> (capacity/structure),
      not adding points/sides. Coherence is maintained by staying inside the domain (circle),
      and regulation activates only to keep the whole system inside that domain.
    </div>

    <h3>Step log</h3>
    <div class="log" id="log"></div>
  </div>

  <canvas id="c"></canvas>

</div>

<script>
(() => {
  // ===== Hex grid (axial coords) =====
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  const key  = (q,r)=> `${q},${r}`;

  function hexRing(radius){
    if(radius===0) return [[0,0]];
    let q = dirs[4][0]*radius;
    let r = dirs[4][1]*radius;
    const out=[];
    for(let side=0; side<6; side++){
      const [dq,dr]=dirs[side];
      for(let step=0; step<radius; step++){
        out.push([q,r]);
        q += dq; r += dr;
      }
    }
    return out;
  }

  function axialToPixel(q,r,size){
    // pointy-top layout
    return [
      size*(Math.sqrt(3)*q + Math.sqrt(3)/2*r),
      size*(3/2*r)
    ];
  }

  // ALWAYS a 6-vertex hex boundary
  function hexVertices(cx,cy,rad){
    const pts=[];
    for(let i=0;i<6;i++){
      const ang = (Math.PI/180) * (60*i - 30);
      pts.push([cx + rad*Math.cos(ang), cy + rad*Math.sin(ang)]);
    }
    return pts;
  }

  // ===== State =====
  let rings = 0;
  const cells = new Map();
  cells.set(key(0,0), {q:0,r:0});

  // ===== UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const sizeEl = document.getElementById("size");
  const REl    = document.getElementById("R");
  const kEl    = document.getElementById("k");
  const linesEl= document.getElementById("lines");

  const sizeVal= document.getElementById("sizeVal");
  const RVal   = document.getElementById("RVal");
  const ringsPill=document.getElementById("ringsPill");
  const cellsPill=document.getElementById("cellsPill");
  const modePill =document.getElementById("modePill");

  const logEl = document.getElementById("log");

  const kBig  = document.getElementById("kBig");
  const kFill = document.getElementById("kFill");
  const kText = document.getElementById("kText");

  const linesBig = document.getElementById("linesBig");

  function log(t){ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; }

  function updateKUI(regulated){
    const k = parseFloat(kEl.value);
    kBig.textContent = k.toFixed(2);

    const pct = Math.max(0, Math.min(100, ((k - 0.50) / 2.00) * 100));
    kFill.style.width = pct.toFixed(1) + "%";

    let label = "Soft compression.";
    if(k >= 1.00 && k < 1.50) label = "Balanced regulation.";
    if(k >= 1.50 && k < 2.10) label = "Strong regulation.";
    if(k >= 2.10) label = "Very strong clamp.";
    if(regulated) label += " (ACTIVE)";
    kText.textContent = label;
  }

  function updateLinesUI(){
    const L = parseInt(linesEl.value,10);
    linesBig.textContent = String(L);
  }

  function updatePills(regulated){
    ringsPill.textContent = "Rings: " + rings;
    cellsPill.textContent = "Hexes: " + cells.size;
    modePill.textContent = "Mode: " + (regulated ? "Regulation" : "Geometry");
    modePill.style.borderColor = regulated ? "#b68b2e" : "#2d4764";
    modePill.style.background  = regulated ? "#221a0a" : "#0c131d";
  }

  // ===== Growth =====
  function addRing(){
    rings++;
    let added=0;
    for(const [q,r] of hexRing(rings)){
      const K=key(q,r);
      if(!cells.has(K)){ cells.set(K,{q,r}); added++; }
    }
    return added;
  }

  function maxRadius(size){
    let m=0;
    for(const {q,r} of cells.values()){
      const [x,y]=axialToPixel(q,r,size);
      m = Math.max(m, Math.hypot(x,y));
    }
    return m;
  }

  function computeScale(size,R,k){
    const rMax = maxRadius(size);
    if(rMax <= R) return {s:1, rMax};
    return {s: Math.pow(R/rMax, k), rMax};
  }

  // ===== Internal-line drawing (adds structure, never adds vertices) =====
  function drawInternalLines(pts, cx, cy, lineCount, strokeStyle, lw){
    if(lineCount <= 0) return;

    // We only ever use the 6 vertices + the center.
    // We can draw any number of internal lines by repeating patterns.
    // This guarantees: hex stays 6-point. Lines are just extra structure.

    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lw;
    ctx.beginPath();

    let n = lineCount;

    // 1) spokes (center -> vertex) : up to 6
    for(let i=0;i<6 && n>0;i++){
      ctx.moveTo(cx,cy);
      ctx.lineTo(pts[i][0], pts[i][1]);
      n--;
    }

    // 2) short diagonals (i -> i+2) : up to 6
    for(let i=0;i<6 && n>0;i++){
      const j=(i+2)%6;
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      n--;
    }

    // 3) long diagonals (i -> i+3) : up to 6
    for(let i=0;i<6 && n>0;i++){
      const j=(i+3)%6;
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      n--;
    }

    // 4) if still more, repeat diagonals (structure density increases)
    let t=0;
    while(n>0){
      const i=t%6;
      const j=(i+2)%6;
      ctx.moveTo(pts[i][0], pts[i][1]);
      ctx.lineTo(pts[j][0], pts[j][1]);
      n--; t++;
    }

    ctx.stroke();
  }

  // color for boundary strokes that “shows k”
  function strokeForK(regulated, k){
    const t = Math.max(0, Math.min(1, (k - 0.50)/2.00));
    const cool = {r:69,g:103,b:132};
    const warm = {r:182,g:139,b:46};
    const r = Math.round(cool.r*(1-t) + warm.r*t);
    const g = Math.round(cool.g*(1-t) + warm.g*t);
    const b = Math.round(cool.b*(1-t) + warm.b*t);
    const a = regulated ? (0.65 + 0.25*t) : (0.55 + 0.20*t);
    return `rgba(${r},${g},${b},${a})`;
  }

  // ===== Render =====
  function resize(){
    const dpr=Math.max(1, window.devicePixelRatio || 1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  function draw(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const L = parseInt(linesEl.value,10);

    sizeVal.textContent = size;
    RVal.textContent = R;
    updateLinesUI();

    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // faint grid
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#1f2c3c";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let gx=0; gx<w; gx+=40){ ctx.moveTo(gx,0); ctx.lineTo(gx,h); }
    for(let gy=0; gy<h; gy+=40){ ctx.moveTo(0,gy); ctx.lineTo(w,gy); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    const cx0=w/2, cy0=h/2;

    // domain circle
    ctx.strokeStyle="#3a5678";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(cx0,cy0,R,0,Math.PI*2);
    ctx.stroke();

    // regulation
    const {s, rMax} = computeScale(size,R,k);
    const regulated = s < 0.999999;

    updatePills(regulated);
    updateKUI(regulated);

    // draw all hexes (always 6 points)
    for(const {q,r} of cells.values()){
      const [x0,y0]=axialToPixel(q,r,size);
      const cx = cx0 + s*x0;
      const cy = cy0 + s*y0;

      const dist=(Math.abs(q)+Math.abs(r)+Math.abs(-q-r))/2;
      const isBoundary = dist === rings;

      const rad = s*size*0.98;
      const pts = hexVertices(cx,cy,rad);

      // fill
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<6;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();
      ctx.fillStyle = isBoundary ? "#0f2236" : "#0d1a2a";
      ctx.fill();

      // boundary stroke shows k/regulation
      ctx.strokeStyle = strokeForK(regulated, k);
      ctx.lineWidth = isBoundary ? 1.8 : 1.05;
      ctx.stroke();

      // internal lines (structure only)
      if(L > 0){
        const inner = regulated ? "rgba(182,139,46,0.28)" : "rgba(138,167,200,0.22)";
        drawInternalLines(pts, cx, cy, L, inner, isBoundary ? 1.0 : 0.75);
      }
    }

    // overlay diagnostics
    ctx.fillStyle="#e8eef6";
    ctx.font="12px system-ui, Segoe UI, Arial";
    const msg = regulated
      ? `Saturation: r_max=${rMax.toFixed(1)} > R=${R} → Regulation ON (s=${s.toFixed(3)}, k=${k.toFixed(2)})`
      : `No saturation: r_max=${rMax.toFixed(1)} <= R=${R} → Geometry ON (s=1.000, k=${k.toFixed(2)})`;
    ctx.fillText(msg, 14, 18);
    ctx.fillStyle = regulated ? "rgba(182,139,46,0.95)" : "rgba(138,167,200,0.95)";
    ctx.fillText(`Internal lines per hex = ${L} (hex remains 6-point)`, 14, 36);

    // show on the center hex (k + L “on the hexagon”)
    ctx.fillStyle="rgba(232,238,246,0.92)";
    ctx.font="bold 13px system-ui, Segoe UI, Arial";
    ctx.fillText(`k=${k.toFixed(2)}`, cx0-28, cy0+4);
    ctx.font="bold 12px system-ui, Segoe UI, Arial";
    ctx.fillText(`L=${L}`, cx0-16, cy0+20);
  }

  // ===== Step logic =====
  function doStep(){
    const size = +sizeEl.value;
    const R = +REl.value;
    const k = parseFloat(kEl.value);
    const L = parseInt(linesEl.value,10);

    const added = addRing();
    log(`STEP: Added ring ${rings}. +${added} hexes. Total: ${cells.size}.`);

    const rMax = maxRadius(size);
    if(rMax <= R){
      log(`CHECK: r_max=${rMax.toFixed(2)} <= R=${R}. Coherence maintained in-domain.`);
      log(`NOTE: Lines L=${L} add structure only (hex stays 6-point).`);
    } else {
      const s = Math.pow(R/rMax, k);
      log(`CHECK: r_max=${rMax.toFixed(2)} > R=${R}. Saturation occurs (not failure).`);
      log(`TAKEOVER: Regulation compresses with k=${k.toFixed(2)} → s=${s.toFixed(4)}.`);
      log(`RESULT: Patch stays inside domain; coherence maintained.`);
    }
    log("—");
    draw();
  }

  // ===== Controls =====
  document.getElementById("step").onclick = doStep;
  document.getElementById("add1").onclick = doStep;
  document.getElementById("add3").onclick = () => { doStep(); doStep(); doStep(); };

  document.getElementById("reset").onclick = () => {
    rings=0;
    cells.clear();
    cells.set(key(0,0), {q:0,r:0});
    logEl.textContent="";
    log("RESET: 1 hex (ring 0). Hex stays 6-point forever.");
    log("Add any number of internal lines. Regulation keeps the patch inside the circle.");
    log("—");
    draw();
  };

  // line preset buttons
  const setL = (v) => { linesEl.value = String(v); draw(); };
  document.getElementById("L6").onclick  = ()=>setL(6);
  document.getElementById("L12").onclick = ()=>setL(12);
  document.getElementById("L24").onclick = ()=>setL(24);
  document.getElementById("L48").onclick = ()=>setL(48);
  document.getElementById("L96").onclick = ()=>setL(96);

  [sizeEl, REl, kEl, linesEl].forEach(el => el.addEventListener("input", draw));

  // init
  log("RESET: 1 hex (ring 0). Hex stays 6-point forever.");
  log("More lines = more structure, not more points. Coherence is preserved inside the circle.");
  log("—");
  resize();
})();
</script>
</body>
</html>
