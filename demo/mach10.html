<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Global Mach-10 Route Simulator — City-to-City + Auto-Stability + Live Gauges + Clocks</title>

<!-- MathJax for equations -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
  :root{
    --bg:#070a12;
    --panel:#10172a;
    --panel2:#0d1324;
    --ink:#e9eeff;
    --muted:#a9b3d6;
    --line:#223055;
    --accent:#86a9ff;
    --ok:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --radius:14px;
    --shadow:0 18px 50px rgba(0,0,0,.40);
    color-scheme: dark;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 600px at 50% 0%, #0b1230 0%, #070a12 55%, #05060b 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: linear-gradient(180deg, rgba(16,23,42,.85), rgba(7,10,18,.2));
  }
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  header p{margin:6px 0 0;color:var(--muted);font-size:12px;line-height:1.35}

  .wrap{
    max-width:1320px;
    margin:0 auto;
    padding:16px;
    display:grid;
    grid-template-columns: 1.18fr .82fr;
    gap:14px;
  }
  .card{
    background: linear-gradient(180deg, rgba(16,23,42,.95), rgba(13,19,36,.92));
    border:1px solid rgba(255,255,255,.08);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .title{
    padding:12px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: rgba(255,255,255,.03);
    gap:10px;
    flex-wrap:wrap;
  }
  .title b{font-size:13px}
  .body{padding:12px 14px}
  .foot{
    padding:10px 14px;
    border-top:1px solid rgba(255,255,255,.08);
    color:var(--muted);
    font-size:11px;
    background: rgba(255,255,255,.03);
  }

  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .grid4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}

  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  select, input[type="range"]{
    width:100%;
  }
  select{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--ink);
    border-radius:12px;
    padding:10px;
    font-weight:700;
    font-size:12px;
    outline:none;
  }
  input[type="range"]{accent-color: var(--accent)}
  .btn{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--ink);
    padding:8px 10px;
    border-radius:10px;
    cursor:pointer;
    font-weight:800;
    font-size:12px;
  }
  .btn:hover{background:rgba(255,255,255,.09)}
  .btn.primary{border-color:rgba(134,169,255,.55);background:rgba(134,169,255,.14)}
  .btn.danger{border-color:rgba(255,90,102,.55);background:rgba(255,90,102,.12)}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .pill{
    font-size:11px;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    color:var(--muted);
  }
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}

  .kpi{
    display:flex;align-items:baseline;justify-content:space-between;
    padding:8px 10px;
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(0,0,0,.18);
    gap:8px;
  }
  .kpi .v{font-weight:900;font-size:14px}
  .kpi .k{font-size:11px;color:var(--muted)}

  .status{
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;
  }
  .dot{
    width:10px;height:10px;border-radius:50%;
    background:var(--ok);
    box-shadow:0 0 14px rgba(53,208,127,.55);
  }
  .dot.warn{background:var(--warn);box-shadow:0 0 14px rgba(242,193,78,.55)}
  .dot.bad{background:var(--bad);box-shadow:0 0 14px rgba(255,90,102,.60)}

  .beacon{
    display:flex;align-items:center;gap:10px;
    padding:10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.22);
    min-width: 360px;
  }
  .beaconLight{
    width:18px;height:18px;border-radius:50%;
    background: var(--ok);
    box-shadow: 0 0 22px rgba(53,208,127,.9), 0 0 60px rgba(53,208,127,.35);
    animation: pulse 1.1s infinite;
  }
  .beaconLight.warn{
    background: var(--warn);
    box-shadow: 0 0 22px rgba(242,193,78,.9), 0 0 60px rgba(242,193,78,.35);
  }
  .beaconLight.bad{
    background: var(--bad);
    box-shadow: 0 0 22px rgba(255,90,102,.95), 0 0 70px rgba(255,90,102,.4);
  }
  @keyframes pulse{
    0%{transform:scale(0.92); filter:brightness(1.0)}
    50%{transform:scale(1.15); filter:brightness(1.35)}
    100%{transform:scale(0.92); filter:brightness(1.0)}
  }

  /* Jet canvas + flash */
  .jetWrap{position:relative}
  canvas{width:100%;height:auto;display:block}
  #flashOverlay{
    pointer-events:none;
    position:absolute;
    inset:0;
    opacity:0;
    background: radial-gradient(circle at 52% 50%, rgba(255,255,255,.25), rgba(255,255,255,0) 60%);
    mix-blend-mode: screen;
    transition: opacity .12s linear;
  }

  /* Gauges */
  .gwrap{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    gap:10px;
    margin-top:12px;
  }
  .gauge{
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(0,0,0,.20);
    padding:10px;
    position:relative;
    overflow:hidden;
  }
  .gauge .gt{font-size:11px;color:var(--muted);margin-bottom:8px}
  .gauge canvas{width:100%;height:auto;display:block}
  .gauge .gv{
    position:absolute; bottom:10px; left:10px;
    font-size:12px; font-weight:900;
  }
  .gauge .gs{
    position:absolute; bottom:10px; right:10px;
    font-size:11px;color:var(--muted);
  }

  /* Log */
  .log{
    max-height:210px;
    overflow:auto;
    padding:10px;
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(0,0,0,.22);
    font-size:12px;
    line-height:1.35;
  }
  .log .t{color:var(--muted);font-size:11px}

  .small{font-size:12px;color:var(--muted);line-height:1.45}
  .eq{font-size:12px;color:var(--muted);line-height:1.45}
  .eq b{color:var(--ink)}
</style>
</head>

<body>
<header>
  <h1>Global Route Simulator — Depart → Accelerate → Mach 10 Cruise → Decelerate → Land (Auto-Stability)</h1>
  <p>
    Picks a real city-to-city route (great-circle distance), simulates phases (takeoff/accel/cruise/decel/landing),
    runs live gauges for heat/cooling/momentum/Π/thrust margin, and automatically slows back to the last stable Mach if constraints tighten.
  </p>
</header>

<div class="wrap">
  <!-- LEFT: VIS + CONTROLS -->
  <section class="card">
    <div class="title">
      <b>Jet + Stability Field (blue=cold → green=stable → red=hot) | Route A→B</b>
      <span class="status">
        <span id="dot" class="dot"></span>
        <span id="statusText" class="pill">READY</span>
        <span class="pill mono" id="simTime">t=0.0s</span>
      </span>

      <div class="beacon">
        <div id="beaconLight" class="beaconLight"></div>
        <div>
          <div class="mono" style="font-weight:900" id="apText">AUTOPILOT: STABILITY HOLD</div>
          <div class="small" id="apDetail">Will aim for Mach 10 in cruise; if unstable, reduces to last stable Mach.</div>
        </div>
      </div>
    </div>

    <div class="body">
      <div class="grid2">
        <div>
          <label>Route (choose one of 5)</label>
          <select id="routeSelect"></select>
          <div class="row" style="margin-top:8px">
            <span class="pill mono" id="distRead">Distance: — km</span>
            <span class="pill mono" id="bearingRead">Initial bearing: —°</span>
            <span class="pill mono" id="progressRead">Progress: 0%</span>
          </div>
        </div>

        <div>
          <label>Run Controls</label>
          <div class="row" style="margin-top:4px">
            <button id="startBtn" class="btn primary">Start</button>
            <button id="stopBtn" class="btn" disabled>Stop</button>
            <button id="resetBtn" class="btn danger">Reset</button>
          </div>
          <div class="row" style="margin-top:8px">
            <span class="pill mono" id="phaseRead">Phase: READY</span>
            <span class="pill mono" id="holdRead">Last Stable Mach: —</span>
          </div>
        </div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div>
          <label>Cruise Target Mach</label>
          <input id="targetMach" type="range" min="5" max="10" step="0.1" value="10.0"/>
          <div class="row">
            <span class="pill mono" id="targetMachRead">Target: M=10.0</span>
            <span class="pill mono" id="machRead">M=1.00</span>
            <span class="pill mono" id="velRead">V=0 m/s</span>
          </div>
        </div>

        <div>
          <label>Altitude Corridor (km)</label>
          <input id="altSlider" type="range" min="10" max="35" step="0.1" value="26.0"/>
          <div class="row">
            <span class="pill mono" id="altRead">h=26.0 km</span>
            <span class="pill mono" id="rhoRead">ρ=0.0000 kg/m³</span>
            <span class="pill mono" id="aRead">a=0 m/s</span>
          </div>
        </div>

        <div>
          <label>Skin Target Temperature Window</label>
          <input id="tStarSlider" type="range" min="140" max="320" step="1" value="205"/>
          <div class="row">
            <span class="pill mono" id="tStarRead">T*=205°C</span>
            <span class="pill mono" id="dTRead">ΔT=5°C</span>
            <span class="pill mono" id="tBandRead">[200,210]°C</span>
          </div>
        </div>
      </div>

      <div class="jetWrap" style="margin-top:12px">
        <canvas id="jetCanvas" width="980" height="380"></canvas>
        <div id="flashOverlay"></div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div class="kpi">
          <div><div class="k">Wall Temp</div><div class="v mono" id="twKpi">200.0 °C</div></div>
          <div class="pill mono" id="twWindow">Target: 205±5 °C</div>
        </div>
        <div class="kpi">
          <div><div class="k">Coolant Flow</div><div class="v mono" id="mdotKpi">0.80 kg/s</div></div>
          <div class="pill mono" id="coolantMode">PI + Feedforward</div>
        </div>
        <div class="kpi">
          <div><div class="k">Stability Health</div><div class="v mono" id="healthKpi">0.95</div></div>
          <div class="pill mono" id="msKpi">Ms=0.50</div>
        </div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div class="kpi">
          <div><div class="k">Thrust Available</div><div class="v mono" id="thrustKpi">0 kN</div></div>
          <div class="pill mono" id="marginVal">T>D: +0 kN</div>
        </div>
        <div class="kpi">
          <div><div class="k">Drag</div><div class="v mono" id="dragKpi">0 kN</div></div>
          <div class="pill mono" id="qKpi">q∞=0 kPa</div>
        </div>
        <div class="kpi">
          <div><div class="k">Inlet Proxy</div><div class="v mono" id="piKpi">Π=0.60</div></div>
          <div class="pill mono" id="t0Read">T0=0 K</div>
        </div>
      </div>

      <!-- Live gauges -->
      <div class="gwrap">
        <div class="gauge">
          <div class="gt">Mach</div>
          <canvas id="gMach" width="220" height="150"></canvas>
          <div class="gv mono" id="gMachV">1.00</div>
          <div class="gs mono">1–10</div>
        </div>
        <div class="gauge">
          <div class="gt">Wall Temp (°C)</div>
          <canvas id="gTw" width="220" height="150"></canvas>
          <div class="gv mono" id="gTwV">200.0</div>
          <div class="gs mono" id="gTwBand">[200–210]</div>
        </div>
        <div class="gauge">
          <div class="gt">Coolant Flow (kg/s)</div>
          <canvas id="gMdot" width="220" height="150"></canvas>
          <div class="gv mono" id="gMdotV">0.80</div>
          <div class="gs mono">0.2–3.5</div>
        </div>
        <div class="gauge">
          <div class="gt">Thrust Margin</div>
          <canvas id="gMargin" width="220" height="150"></canvas>
          <div class="gv mono" id="gMarginV">+0</div>
          <div class="gs mono">kN</div>
        </div>
      </div>
    </div>

    <div class="foot">
      Autopilot logic: during cruise it tries to hold Target Mach. If stability health drops or constraints near limits, it slows to “Last Stable Mach” and holds there until recovered.
    </div>
  </section>

  <!-- RIGHT: CLOCKS + EXPLANATIONS + LOG -->
  <aside class="card">
    <div class="title">
      <b>Departure/Arrival Clocks + Trip Math + Live Log</b>
      <span class="pill mono" id="clocks">UTC — | CST — | Dep — | Arr —</span>
    </div>
    <div class="body">

      <div class="grid2">
        <div class="kpi">
          <div><div class="k">Departure Local Time</div><div class="v mono" id="depClock">—</div></div>
          <div class="pill mono" id="depTZ">—</div>
        </div>
        <div class="kpi">
          <div><div class="k">Arrival Local Time</div><div class="v mono" id="arrClock">—</div></div>
          <div class="pill mono" id="arrTZ">—</div>
        </div>
      </div>

      <div class="grid3" style="margin-top:10px">
        <div class="kpi">
          <div><div class="k">Distance Remaining</div><div class="v mono" id="remainRead">— km</div></div>
          <div class="pill mono" id="etaRead">ETA: —</div>
        </div>
        <div class="kpi">
          <div><div class="k">Phase Time</div><div class="v mono" id="phaseTimeRead">—</div></div>
          <div class="pill mono" id="timeScaleRead">Time Scale: 120×</div>
        </div>
        <div class="kpi">
          <div><div class="k">Stability Action</div><div class="v mono" id="actionRead">—</div></div>
          <div class="pill mono" id="reasonRead">—</div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0">

      <div class="small">
        <b>Route distance math:</b> great-circle (Haversine) distance and initial bearing. Distance is integrated from speed:
        $s(t)=\\int_0^t V(\\tau)d\\tau$, with $V=M\\,a$ and $a=\\sqrt{\\gamma R T_\\infty}$.<br><br>
        <b>Stability constraints:</b>
        $T_{min}\\le T_w\\le T_{max}$, $\\Pi\\le \\Pi_{max}$, and $T_{net}(M,h)&gt;D(M,h)$.<br>
        If constraints approach limits, autopilot reduces Mach to last stable value.
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0">

      <div class="eq">
        <b>Core equations used</b><br>
        • $M=\\dfrac{V}{a}$, $a=\\sqrt{\\gamma R T_\\infty}$<br>
        • $T_0=T_\\infty\\left(1+\\dfrac{\\gamma-1}{2}M^2\\right)$<br>
        • $q_\\infty=\\dfrac12\\rho_\\infty V^2$<br>
        • Wall: $C_w\\dfrac{dT_w}{dt}=q_{in}-q_{out}$<br>
        • Cooling: $q_{out}\\approx \\eta\\dot m_{cool}c_p(T_w-T_{cool})$<br>
        • Control: $\\dot m_{cool}=\\text{clamp}(\\dot m_0(M)+K_p(T_w-T^*)+K_i\\int(T_w-T^*)dt)$<br>
        • Propulsion check: $T_{net}(M,h)&gt;D(M,h)$ (conceptual thrust/drag models)
      </div>

      <div style="margin-top:12px">
        <label>Live Event Log</label>
        <div id="log" class="log"></div>
      </div>

    </div>
    <div class="foot">
      Note: This sim uses simplified atmosphere + thrust/drag models for a safe conceptual dashboard. Real hypersonic design needs CFD, propulsion testing, and material validation.
    </div>
  </aside>
</div>

<script>
/* ==========================================================
   GLOBAL ROUTE MACH-10 SIM (CONCEPTUAL)
   - 5 real city pairs (fixed coordinates + time zones)
   - Great-circle distance (Haversine) + bearing
   - Flight phases: takeoff/accel → climb/accel → cruise → decel → land
   - Autopilot: try to reach target Mach in cruise; if unstable, back off
   - Live gauges + clocks
   ========================================================== */

const $ = (id)=>document.getElementById(id);

/* ---------- UI refs ---------- */
const ui = {
  routeSelect: $("routeSelect"),
  startBtn: $("startBtn"),
  stopBtn: $("stopBtn"),
  resetBtn: $("resetBtn"),

  targetMach: $("targetMach"),
  targetMachRead: $("targetMachRead"),
  altSlider: $("altSlider"),

  tStarSlider: $("tStarSlider"),
  tStarRead: $("tStarRead"),
  dTRead: $("dTRead"),
  tBandRead: $("tBandRead"),

  distRead: $("distRead"),
  bearingRead: $("bearingRead"),
  progressRead: $("progressRead"),

  simTime: $("simTime"),
  phaseRead: $("phaseRead"),
  holdRead: $("holdRead"),

  machRead: $("machRead"),
  velRead: $("velRead"),
  altRead: $("altRead"),
  rhoRead: $("rhoRead"),
  aRead: $("aRead"),

  twKpi: $("twKpi"),
  mdotKpi: $("mdotKpi"),
  healthKpi: $("healthKpi"),
  msKpi: $("msKpi"),

  thrustKpi: $("thrustKpi"),
  dragKpi: $("dragKpi"),
  marginVal: $("marginVal"),
  qKpi: $("qKpi"),
  piKpi: $("piKpi"),
  t0Read: $("t0Read"),

  dot: $("dot"),
  statusText: $("statusText"),
  beaconLight: $("beaconLight"),

  depClock: $("depClock"),
  arrClock: $("arrClock"),
  depTZ: $("depTZ"),
  arrTZ: $("arrTZ"),
  clocks: $("clocks"),

  remainRead: $("remainRead"),
  etaRead: $("etaRead"),
  phaseTimeRead: $("phaseTimeRead"),
  timeScaleRead: $("timeScaleRead"),
  actionRead: $("actionRead"),
  reasonRead: $("reasonRead"),

  log: $("log"),

  // Canvases
  jetCanvas: $("jetCanvas"),
  flashOverlay: $("flashOverlay"),
  gMach: $("gMach"),
  gTw: $("gTw"),
  gMdot: $("gMdot"),
  gMargin: $("gMargin"),
  gMachV: $("gMachV"),
  gTwV: $("gTwV"),
  gMdotV: $("gMdotV"),
  gMarginV: $("gMarginV"),
  gTwBand: $("gTwBand"),
};

const jetCtx = ui.jetCanvas.getContext("2d");
const gMachCtx = ui.gMach.getContext("2d");
const gTwCtx = ui.gTw.getContext("2d");
const gMdotCtx = ui.gMdot.getContext("2d");
const gMarginCtx = ui.gMargin.getContext("2d");

/* ---------- constants ---------- */
const gamma = 1.4;
const R = 287.05;
const g0 = 9.80665;

// Conceptual vehicle + environment scaling
const Aref = 1.8;
const Cd0  = 0.16;
const CdM  = 0.020;

// Make it generally capable of reaching/holding high Mach in this sim
const thrustBase = 340e3;
const Hscale = 7200;

// Thermal
let Cw = 5.0e5;
const cpCool = 1100;
const etaCool = 0.90;
const Tcool = 120 + 273.15;
const epsRad = 0.20;
const sigmaSB = 5.670374e-8;

const heatGain = 0.0092;
const radGain  = 0.0000008;

const PiMax = 1.00;

// Controller
let Kp = 0.060;
let Ki = 0.010;
const mdotMin = 0.20;
const mdotMax = 3.50;

// Time scaling (so world trips finish quickly)
const TIME_SCALE = 120; // 120× faster than real time (sim time = dt_real * 120)
ui.timeScaleRead.textContent = `Time Scale: ${TIME_SCALE}×`;

/* ---------- routes (5 examples) ---------- */
const routes = [
  {
    name: "Dallas, TX (USA) → Tokyo (Japan)",
    from:{ city:"Dallas, TX", lat:32.7767, lon:-96.7970, tz:"America/Chicago" },
    to:{ city:"Tokyo", lat:35.6762, lon:139.6503, tz:"Asia/Tokyo" }
  },
  {
    name: "Los Angeles, CA (USA) → Sydney (Australia)",
    from:{ city:"Los Angeles", lat:34.0522, lon:-118.2437, tz:"America/Los_Angeles" },
    to:{ city:"Sydney", lat:-33.8688, lon:151.2093, tz:"Australia/Sydney" }
  },
  {
    name: "London (UK) → Singapore",
    from:{ city:"London", lat:51.5074, lon:-0.1278, tz:"Europe/London" },
    to:{ city:"Singapore", lat:1.3521, lon:103.8198, tz:"Asia/Singapore" }
  },
  {
    name: "New York, NY (USA) → Dubai (UAE)",
    from:{ city:"New York", lat:40.7128, lon:-74.0060, tz:"America/New_York" },
    to:{ city:"Dubai", lat:25.2048, lon:55.2708, tz:"Asia/Dubai" }
  },
  {
    name: "Mexico City (Mexico) → Paris (France)",
    from:{ city:"Mexico City", lat:19.4326, lon:-99.1332, tz:"America/Mexico_City" },
    to:{ city:"Paris", lat:48.8566, lon:2.3522, tz:"Europe/Paris" }
  }
];

/* ---------- math helpers ---------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x,d=2){ return Number(x).toFixed(d); }
function rad(deg){ return deg*Math.PI/180; }
function deg(rad){ return rad*180/Math.PI; }
function nowISO(){ return new Date().toLocaleTimeString([], {hour12:false}); }

// Haversine distance (km)
function haversineKm(lat1, lon1, lat2, lon2){
  const Rk = 6371.0;
  const dLat = rad(lat2-lat1);
  const dLon = rad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(rad(lat1))*Math.cos(rad(lat2))*Math.sin(dLon/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return Rk*c;
}
// Initial bearing (deg)
function bearingDeg(lat1, lon1, lat2, lon2){
  const φ1=rad(lat1), φ2=rad(lat2), Δλ=rad(lon2-lon1);
  const y = Math.sin(Δλ)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  return (deg(Math.atan2(y,x)) + 360) % 360;
}

// Simple atmosphere model
function atmosphere(h_m){
  let T, p, rho;
  if(h_m < 11000){
    const T0 = 288.15;
    const L = -0.0065;
    T = T0 + L*h_m;
    p = 101325 * Math.pow(T/T0, -g0/(L*R));
    rho = p/(R*T);
  } else if(h_m < 20000){
    const T11 = 216.65;
    const p11 = 22632.06;
    T = T11;
    p = p11 * Math.exp(-g0*(h_m-11000)/(R*T));
    rho = p/(R*T);
  } else {
    T = 216.65 + 0.001*(h_m-20000);
    const p20 = 5474.89;
    rho = (p20/(R*216.65)) * Math.exp(-(h_m-20000)/6500);
    p = rho*R*T;
  }
  const a = Math.sqrt(gamma*R*T);
  return {T,p,rho,a};
}

// Conceptual thrust available
function thrustAvailable(M, h_m){
  // strong scram hump around 7–9; small baseline
  const eff =
    0.16*Math.exp(-Math.pow((M-2.4)/1.2,2)) +
    1.02*Math.exp(-Math.pow((M-7.8)/2.4,2)) +
    0.10;
  const altFactor = Math.exp(-h_m/Hscale);
  return thrustBase * eff * (0.52 + 0.48*altFactor);
}

// Conceptual drag
function dragForce(M, qInf){
  const Cd = Cd0 + CdM*(M-1) + 0.0022*Math.pow(M-1,2);
  return Cd * Aref * qInf;
}

// Backpressure proxy Π (reduced by more conditioning/coolant)
function backpressureProxy(M, mdot){
  let Pi = 0.62 + 0.028*Math.max(0, M-3) + 0.018*Math.max(0, M-6);
  Pi -= 0.055*(mdot-0.8);
  return clamp(Pi, 0.40, 1.65);
}

// Heating input (kW/m^2)
function heatingIn(qInf, M, T0K, TwK){
  const conv = heatGain * (qInf/1000) * (1 + 0.05*M*M);
  const rad  = radGain * epsRad * sigmaSB * (Math.pow(T0K,4) - Math.pow(TwK,4)) / 1000;
  return Math.max(0, conv + rad);
}

// Cooling output (kW/m^2)
function coolingOut_kWm2(mdot, TwK){
  const qW = etaCool * mdot * cpCool * Math.max(0, (TwK - Tcool));
  return qW/1000;
}

// Medium stability index Ms (dimensionless, target about 0.50)
function mediumStabilityIndex(TwC, TstarC, dTC, Pi, thrustN, dragN){
  const eT = (TwC - TstarC)/dTC;
  const rPi = Pi / PiMax;
  const rMD = (thrustN>1 ? Math.max(0, dragN/thrustN - 1) : 1);
  const wT=0.60, wP=0.25, wM=0.15;
  return clamp(0.50 + wT*eT + wP*(rPi-0.60) + wM*rMD*2.2, 0, 2);
}

/* ---------- gauges ---------- */
function drawArcGauge(ctx, value, vmin, vmax, zones){
  const W = ctx.canvas.width, H = ctx.canvas.height;
  ctx.clearRect(0,0,W,H);

  const cx = W/2, cy = H*0.92;
  const Rg = Math.min(W*0.42, H*0.85);
  const start = Math.PI*1.05;
  const end   = Math.PI* -0.05;
  const sweep = end - start;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,.18)";
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  ctx.lineWidth = 14;
  ctx.lineCap = "round";
  zones.forEach(z=>{
    ctx.beginPath();
    const a0 = start + sweep*z.t0;
    const a1 = start + sweep*z.t1;
    ctx.strokeStyle = z.color;
    ctx.globalAlpha = 0.85;
    ctx.arc(cx, cy, Rg, a0, a1, false);
    ctx.stroke();
  });
  ctx.globalAlpha = 1;

  // ticks
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  ctx.lineWidth = 2;
  for(let i=0;i<=10;i++){
    const tt = i/10;
    const a = start + sweep*tt;
    const x1 = cx + Math.cos(a)*(Rg-18);
    const y1 = cy + Math.sin(a)*(Rg-18);
    const x2 = cx + Math.cos(a)*(Rg-2);
    const y2 = cy + Math.sin(a)*(Rg-2);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();

  const n = clamp((value - vmin)/(vmax - vmin), 0, 1);
  const ang = start + sweep*n;

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.55)";
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(ang)*(Rg-26), cy + Math.sin(ang)*(Rg-26));
  ctx.stroke();

  ctx.strokeStyle = "rgba(134,169,255,.95)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(ang)*(Rg-26), cy + Math.sin(ang)*(Rg-26));
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.85)";
  ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(16,23,42,.95)";
  ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}
function zonesDefault(){
  return [
    {t0:0.00, t1:0.33, color:"rgba(120,160,255,.95)"},
    {t0:0.33, t1:0.75, color:"rgba(53,208,127,.95)"},
    {t0:0.75, t1:1.00, color:"rgba(255,90,102,.95)"},
  ];
}

/* ---------- jet drawing ---------- */
function stabilityColor(score01){
  const s = clamp(score01, 0, 1);
  if(s < 0.5){
    const t = s/0.5;
    return { r: Math.round(lerp(70, 53, t)), g: Math.round(lerp(140, 208, t)), b: Math.round(lerp(255, 127, t)) };
  } else {
    const t = (s-0.5)/0.5;
    return { r: Math.round(lerp(53, 255, t)), g: Math.round(lerp(208, 90, t)), b: Math.round(lerp(127, 90, t)) };
  }
}
function drawJet(col, glowScore, health){
  const W = ui.jetCanvas.width, H = ui.jetCanvas.height;
  jetCtx.clearRect(0,0,W,H);

  // grid
  jetCtx.save();
  jetCtx.globalAlpha = 0.20;
  jetCtx.strokeStyle = "#3a4a86";
  for(let x=0;x<=W;x+=40){ jetCtx.beginPath(); jetCtx.moveTo(x,0); jetCtx.lineTo(x,H); jetCtx.stroke(); }
  for(let y=0;y<=H;y+=40){ jetCtx.beginPath(); jetCtx.moveTo(0,y); jetCtx.lineTo(W,y); jetCtx.stroke(); }
  jetCtx.restore();

  const pulse = 0.55 + 0.45*Math.sin(sim.t*5.0);
  const g = clamp(glowScore,0,1)*pulse;
  const cx = W*0.52, cy = H*0.52;

  const grad1 = jetCtx.createRadialGradient(cx, cy, 80, cx, cy, 340);
  grad1.addColorStop(0, `rgba(${col.r},${col.g},${col.b},${0.70*g})`);
  grad1.addColorStop(0.45, `rgba(${col.r},${col.g},${col.b},${0.20*g})`);
  grad1.addColorStop(1, `rgba(${col.r},${col.g},${col.b},0)`);
  jetCtx.fillStyle = grad1;
  jetCtx.fillRect(0,0,W,H);

  const grad2 = jetCtx.createRadialGradient(cx, cy, 10, cx, cy, 160);
  grad2.addColorStop(0, `rgba(255,255,255,${0.30*g})`);
  grad2.addColorStop(0.20, `rgba(${col.r},${col.g},${col.b},${0.55*g})`);
  grad2.addColorStop(1, `rgba(${col.r},${col.g},${col.b},0)`);
  jetCtx.fillStyle = grad2;
  jetCtx.fillRect(0,0,W,H);

  // jet
  jetCtx.save();
  jetCtx.translate(W*0.12, H*0.52);

  jetCtx.fillStyle = "rgba(233,238,255,0.94)";
  jetCtx.strokeStyle = "rgba(130,150,220,0.60)";
  jetCtx.lineWidth = 2;

  jetCtx.beginPath();
  jetCtx.moveTo(0, -18);
  jetCtx.lineTo(310, -18);
  jetCtx.quadraticCurveTo(340, -16, 360, -6);
  jetCtx.quadraticCurveTo(385, 0, 360, 6);
  jetCtx.quadraticCurveTo(340, 16, 310, 18);
  jetCtx.lineTo(0, 18);
  jetCtx.quadraticCurveTo(-18, 0, 0, -18);
  jetCtx.closePath();
  jetCtx.fill();
  jetCtx.stroke();

  jetCtx.fillStyle = "rgba(130,169,255,0.42)";
  jetCtx.beginPath();
  jetCtx.ellipse(120, -8, 42, 18, 0, 0, Math.PI*2);
  jetCtx.fill();

  jetCtx.fillStyle = "rgba(233,238,255,0.90)";
  jetCtx.beginPath();
  jetCtx.moveTo(120, 10);
  jetCtx.lineTo(170, 50);
  jetCtx.lineTo(230, 52);
  jetCtx.lineTo(175, 12);
  jetCtx.closePath();
  jetCtx.fill();
  jetCtx.stroke();

  jetCtx.beginPath();
  jetCtx.moveTo(130, -10);
  jetCtx.lineTo(175, -52);
  jetCtx.lineTo(240, -50);
  jetCtx.lineTo(185, -12);
  jetCtx.closePath();
  jetCtx.fill();
  jetCtx.stroke();

  jetCtx.fillStyle = "rgba(0,0,0,0.30)";
  jetCtx.beginPath();
  jetCtx.moveTo(-3, -12);
  jetCtx.lineTo(30, -12);
  jetCtx.quadraticCurveTo(40, 0, 30, 12);
  jetCtx.lineTo(-3, 12);
  jetCtx.closePath();
  jetCtx.fill();

  jetCtx.fillStyle = "rgba(0,0,0,0.18)";
  jetCtx.beginPath();
  jetCtx.moveTo(310, -10);
  jetCtx.lineTo(350, -3);
  jetCtx.lineTo(350, 3);
  jetCtx.lineTo(310, 10);
  jetCtx.closePath();
  jetCtx.fill();

  jetCtx.strokeStyle = `rgba(${col.r},${col.g},${col.b},${0.55 + 0.35*g})`;
  jetCtx.lineWidth = 3.2;
  jetCtx.beginPath();
  jetCtx.moveTo(-30, 0);
  jetCtx.bezierCurveTo(20, -70, 95, -80, 185, -45);
  jetCtx.stroke();
  jetCtx.beginPath();
  jetCtx.moveTo(-30, 0);
  jetCtx.bezierCurveTo(20, 70, 95, 80, 185, 45);
  jetCtx.stroke();

  jetCtx.restore();

  // flash overlay visible when stressed
  const flash = clamp((1-health)*1.4 + glowScore*0.25, 0, 1);
  ui.flashOverlay.style.opacity = String(0.12 + 0.62*flash*(0.60 + 0.40*Math.sin(sim.t*10.0)));
}

/* ---------- logging + status ---------- */
let logLines = [];
let lastLog = {key:"", t:-999};
function logThrottled(key, msg, cooldown=1.0){
  if(lastLog.key === key && (sim.t - lastLog.t) < cooldown) return;
  lastLog = {key, t: sim.t};
  const line = `<div><span class="t">${nowISO()}</span> — ${msg}</div>`;
  logLines.unshift(line);
  if(logLines.length>140) logLines.pop();
  ui.log.innerHTML = logLines.join("");
}
function setStatus(level, text){
  ui.statusText.textContent = text;
  ui.dot.className = "dot" + (level==="warn" ? " warn" : level==="bad" ? " bad" : "");
  ui.beaconLight.className = "beaconLight" + (level==="warn" ? " warn" : level==="bad" ? " bad" : "");
}

/* ==========================================================
   SIM STATE + PHASES
   We simulate distance traveled along route using s += V*dt.
   Phases:
     0 READY
     1 TAKEOFF+ACCEL (M 0.3->2, low altitude ramp)
     2 CLIMB+ACCEL   (M 2->target, climb to corridor)
     3 CRUISE        (hold near target Mach)
     4 DESCENT+DECEL (reduce Mach as distance remaining short)
     5 LANDING       (M -> 0.3)
     6 ARRIVED
   ========================================================== */
const sim = {
  running:false,
  t:0,
  lastTs:null,
  phase:0,
  phaseT:0,

  // route
  routeIdx:0,
  distKm:0,
  bearing0:0,
  sKm:0,

  // flight state
  Mach:0.3,
  h_km:2.0,

  // thermal + control
  TwK: (200 + 273.15),
  mdot: 0.80,
  iErr: 0,

  // stability memory
  lastStableMach: 0.3,
  action: "—",
  reason: "—",
};

function phaseName(p){
  return ["READY","TAKEOFF+ACCEL","CLIMB+ACCEL","CRUISE","DESCENT+DECEL","LANDING","ARRIVED"][p] || "—";
}

/* ---------- autopilot phase targets ---------- */
function targetForPhase(){
  const cruiseTarget = parseFloat(ui.targetMach.value);
  const corridorAlt = parseFloat(ui.altSlider.value);

  // plan decel start: start slowing when remaining distance is small
  const remainKm = Math.max(0, sim.distKm - sim.sKm);

  // Decide decel onset (simple): begin descent/decel at last 900 km (scaled by cruise target)
  const decelStartKm = 900 + 120*(cruiseTarget-8);

  let M_target, h_target;

  if(sim.phase === 1){
    M_target = 2.0; h_target = 8.0;
  } else if(sim.phase === 2){
    M_target = cruiseTarget; h_target = corridorAlt;
  } else if(sim.phase === 3){
    M_target = cruiseTarget; h_target = corridorAlt;
    if(remainKm < decelStartKm) {
      sim.phase = 4; sim.phaseT = 0;
      logThrottled("Phase4", `Entering DESCENT+DECEL with ${fmt(remainKm,0)} km remaining.`, 0.5);
    }
  } else if(sim.phase === 4){
    // linearly reduce Mach toward 1.5 as we approach destination
    const frac = clamp(remainKm / decelStartKm, 0, 1); // 1 far, 0 near
    M_target = 1.5 + frac*(cruiseTarget - 1.5);
    h_target = 10.0 + frac*(corridorAlt - 10.0);
    if(remainKm < 120){
      sim.phase = 5; sim.phaseT = 0;
      logThrottled("Phase5", `Entering LANDING with ${fmt(remainKm,0)} km remaining.`, 0.5);
    }
  } else if(sim.phase === 5){
    M_target = 0.35; h_target = 1.0;
  } else {
    M_target = cruiseTarget; h_target = corridorAlt;
  }
  return {M_target, h_target, remainKm};
}

/* ---------- stability checks + “slow back to last stable” ---------- */
function computeHealthAndActions(snap){
  // penalties
  const TwC = snap.TwC;
  const tempErr = Math.abs(TwC - TstarC)/dTC;
  const tempPenalty = clamp((tempErr-1)/1.7, 0, 1);
  const piPenalty = clamp((snap.Pi/PiMax - 1), 0, 1);
  const marginPenalty = clamp((-snap.marginN)/(0.8*snap.thrust + 1), 0, 1);

  const health = 1 - clamp(0.58*tempPenalty + 0.30*piPenalty + 0.12*marginPenalty, 0, 1);

  // Determine “stable”
  const stable = (tempErr <= 1.0) && (snap.Pi <= PiMax) && (snap.marginN > 0);

  // Update last stable memory
  if(stable && snap.M > sim.lastStableMach){
    sim.lastStableMach = snap.M;
  }

  // Autopilot action:
  // If health is dropping or constraints are near limits, pull Mach back toward last stable.
  // We do this *before* letting it go unstable.
  const nearTempEdge = (tempErr > 0.92);
  const nearPiEdge = (snap.Pi/PiMax > 0.98);
  const nearMargin = (snap.marginN < 0.06*snap.thrust);

  if(nearTempEdge || nearPiEdge || nearMargin || health < 0.70){
    sim.action = "SLOW BACK";
    if(nearTempEdge) sim.reason = "Approaching temperature window edge";
    else if(nearPiEdge) sim.reason = "Approaching Π limit (inlet stability)";
    else if(nearMargin) sim.reason = "Thrust margin getting small";
    else sim.reason = "Health threshold";
  } else {
    sim.action = "HOLD / ACCEL";
    sim.reason = "Within constraint envelope";
  }

  return {health, tempErr, piPenalty, stable};
}

/* ---------- clocks (UTC + CST + departure + arrival) ---------- */
function fmtTimeInTZ(date, tz){
  return new Date(date.toLocaleString("en-US", { timeZone: tz }))
    .toLocaleTimeString([], {hour12:false});
}
function updateClocks(){
  const now = new Date();
  const utc = fmtTimeInTZ(now, "UTC");
  const cst = fmtTimeInTZ(now, "America/Monterrey");

  const r = routes[sim.routeIdx];
  const dep = fmtTimeInTZ(now, r.from.tz);
  const arr = fmtTimeInTZ(now, r.to.tz);

  ui.clocks.textContent = `UTC ${utc} | CST ${cst} | Dep ${dep} | Arr ${arr}`;
  ui.depClock.textContent = dep;
  ui.arrClock.textContent = arr;
  ui.depTZ.textContent = r.from.tz;
  ui.arrTZ.textContent = r.to.tz;
}

/* ---------- controller + dynamics step ---------- */
let TstarC = 205;
let dTC = 5;
function step(dtReal){
  // scale time
  const dt = dtReal * TIME_SCALE;

  sim.t += dt;
  sim.phaseT += dt;

  // read UI
  const cruiseTarget = parseFloat(ui.targetMach.value);
  ui.targetMachRead.textContent = `Target: M=${fmt(cruiseTarget,1)}`;

  // skin window
  TstarC = parseFloat(ui.tStarSlider.value);
  dTC = 5; // keep fixed as requested; easy to add slider later
  const TminC = TstarC - dTC;
  const TmaxC = TstarC + dTC;

  ui.tStarRead.textContent = `T*=${fmt(TstarC,0)}°C`;
  ui.dTRead.textContent = `ΔT=${fmt(dTC,0)}°C`;
  ui.tBandRead.textContent = `[${fmt(TminC,0)},${fmt(TmaxC,0)}]°C`;
  ui.gTwBand.textContent = `[${fmt(TminC,0)}–${fmt(TmaxC,0)}]`;

  // phase transitions
  if(sim.phase === 0){
    sim.phase = 1; sim.phaseT = 0;
    logThrottled("Phase1", "Entering TAKEOFF+ACCEL.", 0.1);
  }

  // compute desired targets
  const targets = targetForPhase();
  const M_target = targets.M_target;
  const h_target = targets.h_target;
  const remainKm = targets.remainKm;

  // autopilot: adjust altitude toward target smoothly
  const hRate = (sim.phase<=2 ? 0.06 : sim.phase===4 ? 0.08 : 0.05); // km/s (sim-time)
  sim.h_km += clamp(h_target - sim.h_km, -hRate*dt, hRate*dt);

  // atmosphere
  const h_m = sim.h_km * 1000;
  const at = atmosphere(h_m);
  const a = at.a;

  // autopilot: choose Mach command
  let MachCmd = sim.Mach;

  // base accel/decel rates (Mach per sim-second)
  const accel = (sim.phase<=2 ? 0.020 : sim.phase===3 ? 0.012 : 0.020);
  const decel = (sim.phase>=4 ? 0.030 : 0.020);

  // try to move Mach toward M_target
  if(sim.Mach < M_target){
    MachCmd = sim.Mach + accel*dt;
  } else if(sim.Mach > M_target){
    MachCmd = sim.Mach - decel*dt;
  }

  // compute speed and forces at commanded Mach (preview)
  MachCmd = clamp(MachCmd, 0.30, 10.0);

  const Vcmd = MachCmd * a;
  const qInfCmd = 0.5 * at.rho * Vcmd * Vcmd;

  const thrustCmd = thrustAvailable(MachCmd, h_m);
  const dragCmd = dragForce(MachCmd, qInfCmd);
  const marginCmd = thrustCmd - dragCmd;

  // thermal preview
  const T0cmd = at.T*(1 + (gamma-1)/2 * MachCmd*MachCmd);
  const qInCmd = heatingIn(qInfCmd, MachCmd, T0cmd, sim.TwK);
  const TwC_now = sim.TwK - 273.15;

  // coolant PI controller (feedforward + PI)
  const e = (TwC_now - TstarC);
  sim.iErr += e * dt;
  sim.iErr = clamp(sim.iErr, -220, 220);

  const mdot0 = 0.60 + 0.085*(MachCmd-1); // feedforward
  sim.mdot = clamp(mdot0 + Kp*e + Ki*sim.iErr, mdotMin, mdotMax);

  // backpressure with conditioning
  const PiCmd = backpressureProxy(MachCmd, sim.mdot);

  // Now compute actual wall update using cmd
  const qOut = coolingOut_kWm2(sim.mdot, sim.TwK);
  const dTw = ((qInCmd - qOut)*1000) / Cw;
  sim.TwK += dTw * dt;

  // compute actual state snapshot for health/stability
  const V = MachCmd * a;
  const qInf = 0.5 * at.rho * V*V;
  const thrust = thrustCmd;
  const drag = dragCmd;
  const marginN = thrust - drag;

  const T0 = T0cmd;
  const TwC = sim.TwK - 273.15;
  const Pi = PiCmd;

  const Ms = mediumStabilityIndex(TwC, TstarC, dTC, Pi, thrust, drag);

  const snap = {
    M: MachCmd, V, a, rho: at.rho, Tinf: at.T, T0, qInf,
    thrust, drag, marginN,
    TwC, mdot: sim.mdot, qIn: qInCmd, qOut, Pi, Ms,
    TminC, TmaxC, remainKm
  };

  // evaluate stability and decide if we must slow back
  const meta = computeHealthAndActions(snap);

  // if autopilot says slow back, override Mach toward last stable (preemptively)
  if(sim.action === "SLOW BACK"){
    const targetBack = Math.max(0.35, Math.min(sim.lastStableMach, M_target));
    // move down faster to avoid crossing limits
    MachCmd = Math.min(MachCmd, targetBack);
    // additional immediate nudge if already near edge
    MachCmd = Math.min(MachCmd, sim.Mach - 0.010*dt);
    MachCmd = clamp(MachCmd, 0.30, 10.0);

    // update key log
    logThrottled("SlowBack", `Stability tightening → slowing to last stable Mach ${fmt(sim.lastStableMach,2)} (${sim.reason}).`, 1.6);
  } else {
    // if we're stable and in cruise, let last stable drift upward
    if(sim.phase === 3 && meta.health > 0.80){
      logThrottled("CruiseStable", `Cruise stable at Mach ${fmt(snap.M,2)} (health ${fmt(meta.health,2)}).`, 3.0);
    }
  }

  // Commit Mach (after autopilot corrections)
  sim.Mach = MachCmd;

  // advance distance
  const ds_m = V * dt; // meters traveled this sim-step
  sim.sKm += ds_m/1000;

  // phase switching based on progress
  if(sim.phase === 1 && sim.phaseT > 240){ // ~4 sim-min at 120×
    sim.phase = 2; sim.phaseT = 0;
    logThrottled("Phase2", "Entering CLIMB+ACCEL toward cruise corridor.", 0.5);
  }
  if(sim.phase === 2 && sim.Mach >= (cruiseTarget - 0.2)){
    sim.phase = 3; sim.phaseT = 0;
    logThrottled("Phase3", "Entering CRUISE (aim Mach target).", 0.5);
  }
  if(sim.phase === 5 && sim.phaseT > 240){
    sim.phase = 6; sim.phaseT = 0;
    sim.Mach = 0.30;
    logThrottled("Arrived", "ARRIVED. Route complete.", 0.5);
  }

  // clamp progress at end
  if(sim.sKm >= sim.distKm && sim.phase < 6){
    sim.sKm = sim.distKm;
    sim.phase = 6; sim.phaseT = 0;
    sim.Mach = 0.30;
    logThrottled("Arrived2", "ARRIVED. Route complete.", 0.5);
  }

  return {snap, meta};
}

/* ---------- UI render ---------- */
function updateUI(snap, meta){
  // status + beacon
  if(meta.health > 0.82){
    setStatus("ok","STABLE");
  } else if(meta.health > 0.60){
    setStatus("warn","WATCH");
  } else {
    setStatus("bad","LIMIT");
  }

  // reads
  ui.simTime.textContent = `t=${fmt(sim.t,1)}s`;
  ui.phaseRead.textContent = `Phase: ${phaseName(sim.phase)}`;

  ui.holdRead.textContent = `Last Stable Mach: ${fmt(sim.lastStableMach,2)}`;

  ui.machRead.textContent = `M=${fmt(snap.M,2)}`;
  ui.velRead.textContent = `V=${fmt(snap.V,0)} m/s`;

  ui.altRead.textContent = `h=${fmt(sim.h_km,1)} km`;
  ui.rhoRead.textContent = `ρ=${fmt(snap.rho,5)} kg/m³`;
  ui.aRead.textContent = `a=${fmt(snap.a,0)} m/s`;

  ui.twKpi.textContent = `${fmt(snap.TwC,1)} °C`;
  ui.mdotKpi.textContent = `${fmt(snap.mdot,2)} kg/s`;
  ui.healthKpi.textContent = fmt(meta.health,2);
  ui.msKpi.textContent = `Ms=${fmt(snap.Ms,2)}`;

  ui.thrustKpi.textContent = `${fmt(snap.thrust/1000,0)} kN`;
  ui.dragKpi.textContent = `${fmt(snap.drag/1000,0)} kN`;
  ui.marginVal.textContent = `T>D: ${snap.marginN>=0?"+":""}${fmt(snap.marginN/1000,0)} kN`;
  ui.qKpi.textContent = `q∞=${fmt(snap.qInf/1000,1)} kPa`;
  ui.piKpi.textContent = `Π=${fmt(snap.Pi,2)}`;
  ui.t0Read.textContent = `T0=${fmt(snap.T0,0)} K`;

  // progress
  const prog = clamp(sim.sKm / sim.distKm, 0, 1);
  ui.progressRead.textContent = `Progress: ${fmt(prog*100,1)}%`;
  ui.remainRead.textContent = `${fmt(Math.max(0, sim.distKm - sim.sKm),0)} km`;

  // ETA (rough): remaining / current speed
  const v_km_s = snap.V / 1000;
  const eta_s = v_km_s > 0.05 ? (Math.max(0, sim.distKm - sim.sKm) / v_km_s) : Infinity;
  ui.etaRead.textContent = (isFinite(eta_s) ? `ETA: ${fmt(eta_s/60,1)} min (sim)` : "ETA: —");

  ui.phaseTimeRead.textContent = `${fmt(sim.phaseT/60,1)} min (sim)`;

  ui.actionRead.textContent = sim.action;
  ui.reasonRead.textContent = sim.reason;

  // gauges
  drawArcGauge(gMachCtx, snap.M, 0.3, 10, zonesDefault());
  drawArcGauge(gTwCtx, snap.TwC, snap.TminC-20, snap.TmaxC+20, [
    {t0:0.00, t1:0.40, color:"rgba(120,160,255,.95)"},
    {t0:0.40, t1:0.70, color:"rgba(53,208,127,.95)"},
    {t0:0.70, t1:1.00, color:"rgba(255,90,102,.95)"},
  ]);
  drawArcGauge(gMdotCtx, snap.mdot, mdotMin, mdotMax, zonesDefault());
  // margin gauge: map -200..+200 kN (conceptual)
  const margin_kN = snap.marginN/1000;
  drawArcGauge(gMarginCtx, margin_kN, -200, 200, [
    {t0:0.00, t1:0.45, color:"rgba(255,90,102,.95)"},
    {t0:0.45, t1:0.55, color:"rgba(242,193,78,.95)"},
    {t0:0.55, t1:1.00, color:"rgba(53,208,127,.95)"},
  ]);

  ui.gMachV.textContent = fmt(snap.M,2);
  ui.gTwV.textContent = fmt(snap.TwC,1);
  ui.gMdotV.textContent = fmt(snap.mdot,2);
  ui.gMarginV.textContent = `${margin_kN>=0?"+":""}${fmt(margin_kN,0)}`;

  // jet glow from temp + pi + margin penalties
  const glowScore = clamp(0.72*clamp(meta.tempErr/1.35,0,1) + 0.18*meta.piPenalty + 0.10*clamp((-snap.marginN)/(0.8*snap.thrust+1),0,1), 0, 1);
  drawJet(stabilityColor(glowScore), glowScore, meta.health);

  // route info display
  ui.distRead.textContent = `Distance: ${fmt(sim.distKm,0)} km`;
  ui.bearingRead.textContent = `Initial bearing: ${fmt(sim.bearing0,0)}°`;

  // log small event when we reach cruise hold
  if(sim.phase === 3 && meta.health > 0.80){
    // (throttled by logThrottled in step)
  }
}

/* ---------- route setup ---------- */
function setRoute(idx){
  sim.routeIdx = idx;
  const r = routes[idx];
  sim.distKm = haversineKm(r.from.lat, r.from.lon, r.to.lat, r.to.lon);
  sim.bearing0 = bearingDeg(r.from.lat, r.from.lon, r.to.lat, r.to.lon);
  ui.depTZ.textContent = r.from.tz;
  ui.arrTZ.textContent = r.to.tz;
  logThrottled("Route", `Route set: ${r.from.city} → ${r.to.city} (${fmt(sim.distKm,0)} km).`, 0.2);
}

/* ---------- animation loop ---------- */
function tick(ts){
  if(!sim.running){ sim.lastTs=null; return; }
  if(sim.lastTs===null) sim.lastTs = ts;
  let dtReal = (ts - sim.lastTs)/1000;
  sim.lastTs = ts;
  dtReal = clamp(dtReal, 0.001, 0.05);

  updateClocks();

  const {snap, meta} = step(dtReal);
  updateUI(snap, meta);

  requestAnimationFrame(tick);
}

/* ---------- reset ---------- */
function reset(){
  sim.running = false;
  sim.t = 0;
  sim.lastTs = null;
  sim.phase = 0;
  sim.phaseT = 0;

  sim.sKm = 0;

  sim.Mach = 0.30;
  sim.h_km = 2.0;

  sim.TwK = 200 + 273.15;
  sim.mdot = 0.80;
  sim.iErr = 0;

  sim.lastStableMach = 0.30;
  sim.action = "—";
  sim.reason = "—";

  logLines = [];
  ui.log.innerHTML = "";
  setStatus("ok","READY");

  ui.startBtn.disabled = false;
  ui.stopBtn.disabled = true;

  // render initial
  updateClocks();
  const at = atmosphere(sim.h_km*1000);
  const a = at.a;
  const V = sim.Mach*a;
  const qInf = 0.5*at.rho*V*V;
  const thrust = thrustAvailable(sim.Mach, sim.h_km*1000);
  const drag = dragForce(sim.Mach, qInf);
  const marginN = thrust - drag;
  const T0 = at.T*(1 + (gamma-1)/2 * sim.Mach*sim.Mach);
  const qIn = heatingIn(qInf, sim.Mach, T0, sim.TwK);
  const qOut = coolingOut_kWm2(sim.mdot, sim.TwK);
  const Pi = backpressureProxy(sim.Mach, sim.mdot);
  const TwC = sim.TwK - 273.15;
  TstarC = parseFloat(ui.tStarSlider.value);
  const TminC = TstarC - dTC, TmaxC = TstarC + dTC;
  const Ms = mediumStabilityIndex(TwC, TstarC, dTC, Pi, thrust, drag);
  const snap = {M:sim.Mach, V, a, rho:at.rho, Tinf:at.T, T0, qInf, thrust, drag, marginN, TwC, mdot:sim.mdot, qIn, qOut, Pi, Ms, TminC, TmaxC, remainKm: sim.distKm};
  const meta = computeHealthAndActions(snap);
  updateUI(snap, meta);
  drawJet(stabilityColor(0.30), 0.25, meta.health);
}

/* ---------- init UI ---------- */
function init(){
  // populate routes
  ui.routeSelect.innerHTML = routes.map((r,i)=>`<option value="${i}">${r.name}</option>`).join("");
  ui.routeSelect.addEventListener("change", ()=>{
    setRoute(parseInt(ui.routeSelect.value,10));
    reset();
  });

  ui.targetMach.addEventListener("input", ()=>{
    ui.targetMachRead.textContent = `Target: M=${fmt(parseFloat(ui.targetMach.value),1)}`;
  });

  ui.altSlider.addEventListener("input", ()=>{
    // corridor used in phases 2-4; show live
    // (actual alt is autopilot-controlled)
  });

  ui.tStarSlider.addEventListener("input", ()=>{
    // updates happen in step()
  });

  ui.startBtn.addEventListener("click", ()=>{
    if(sim.running) return;
    sim.running = true;
    ui.startBtn.disabled = true;
    ui.stopBtn.disabled = false;
    setStatus("ok","RUNNING");
    logThrottled("Start", "Simulation started: takeoff → climb/accel → Mach cruise → decel → landing.", 0.2);
    requestAnimationFrame(tick);
  });

  ui.stopBtn.addEventListener("click", ()=>{
    sim.running = false;
    ui.startBtn.disabled = false;
    ui.stopBtn.disabled = true;
    setStatus("warn","PAUSED");
    logThrottled("Stop", "Simulation paused.", 0.4);
  });

  ui.resetBtn.addEventListener("click", reset);

  // default route
  setRoute(0);
  reset();
  setInterval(updateClocks, 250);
}

init();
</script>
</body>
</html>
