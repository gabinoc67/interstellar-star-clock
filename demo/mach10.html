<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mach 1 → 10 Stability Simulator — Heat + Coolant + Momentum + Thrust vs Drag (Closed-Loop)</title>

<!-- MathJax (equations) -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
  :root{
    --bg:#070a12;
    --panel:#10172a;
    --panel2:#0d1324;
    --ink:#e9eeff;
    --muted:#a9b3d6;
    --line:#223055;
    --accent:#86a9ff;
    --ok:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --radius:14px;
    --shadow:0 18px 50px rgba(0,0,0,.40);
    color-scheme: dark;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 600px at 50% 0%, #0b1230 0%, #070a12 55%, #05060b 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: linear-gradient(180deg, rgba(16,23,42,.85), rgba(7,10,18,.2));
  }
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  header p{margin:6px 0 0;color:var(--muted);font-size:12px;line-height:1.35}
  .wrap{
    max-width:1200px;
    margin:0 auto;
    padding:16px;
    display:grid;
    grid-template-columns: 1.1fr .9fr;
    gap:14px;
  }
  .card{
    background: linear-gradient(180deg, rgba(16,23,42,.95), rgba(13,19,36,.92));
    border:1px solid rgba(255,255,255,.08);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .title{
    padding:12px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: rgba(255,255,255,.03);
  }
  .card .title b{font-size:13px}
  .card .title span{color:var(--muted);font-size:12px}
  .card .body{padding:12px 14px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--ink);
    padding:8px 10px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    font-size:12px;
  }
  .btn:hover{background:rgba(255,255,255,.09)}
  .btn.primary{border-color:rgba(134,169,255,.5);background:rgba(134,169,255,.12)}
  .btn.danger{border-color:rgba(255,90,102,.45);background:rgba(255,90,102,.10)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input[type="range"]{width:100%}
  .pill{
    font-size:11px;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    color:var(--muted);
  }
  .kpi{
    display:flex;align-items:baseline;justify-content:space-between;
    padding:8px 10px;
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(0,0,0,.18);
  }
  .kpi .v{font-weight:800;font-size:14px}
  .kpi .k{font-size:11px;color:var(--muted)}
  .bar{
    height:8px;border-radius:999px;background:rgba(255,255,255,.08);
    overflow:hidden;margin-top:8px
  }
  .bar > i{
    display:block;height:100%;width:50%;
    background:linear-gradient(90deg, rgba(53,208,127,.95), rgba(242,193,78,.95), rgba(255,90,102,.95));
  }
  canvas{width:100%;height:auto;display:block}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
  .small{font-size:12px;color:var(--muted);line-height:1.45}
  .eq{
    font-size:12px; color:var(--muted); line-height:1.45;
  }
  .eq b{color:var(--ink)}
  .log{
    max-height:180px;
    overflow:auto;
    padding:10px;
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(0,0,0,.22);
    font-size:12px;
    line-height:1.35;
  }
  .log .t{color:var(--muted);font-size:11px}
  .status{
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;
  }
  .dot{
    width:10px;height:10px;border-radius:50%;
    background:var(--ok);
    box-shadow:0 0 12px rgba(53,208,127,.35);
  }
  .dot.warn{background:var(--warn);box-shadow:0 0 12px rgba(242,193,78,.35)}
  .dot.bad{background:var(--bad);box-shadow:0 0 12px rgba(255,90,102,.35)}
  .foot{
    padding:10px 14px;
    border-top:1px solid rgba(255,255,255,.08);
    color:var(--muted);
    font-size:11px;
    background: rgba(255,255,255,.03);
  }
</style>
</head>

<body>
<header>
  <h1>Mach 1 → 10 Stability Simulator — Closed-Loop Heat + Coolant + Momentum + Thrust-vs-Drag</h1>
  <p>
    Educational closed-loop model: ramps Mach 1→10, computes heating trend, wall temperature dynamics, coolant control, medium stability index, and net thrust margin.
    This is a conceptual control simulator (not a design tool for real vehicles).
  </p>
</header>

<div class="wrap">
  <!-- LEFT: Jet + Live -->
  <section class="card">
    <div class="title">
      <b>Jet Model + Field Glow (blue=cold → green=stable → red=hot)</b>
      <span class="status">
        <span id="dot" class="dot"></span>
        <span id="statusText" class="pill">READY</span>
        <span class="pill mono" id="simTime">t=0.0s</span>
      </span>
    </div>
    <div class="body">
      <canvas id="jetCanvas" width="980" height="380" aria-label="jet visualization"></canvas>

      <div class="grid3" style="margin-top:12px">
        <div>
          <label>Mach Command (manual)</label>
          <input id="machSlider" type="range" min="1" max="10" step="0.01" value="1.00" />
          <div class="row">
            <span class="pill mono" id="machRead">M=1.00</span>
            <span class="pill mono" id="velRead">V=0 m/s</span>
            <span class="pill mono" id="aRead">a=0 m/s</span>
          </div>
        </div>

        <div>
          <label>Altitude (km)</label>
          <input id="altSlider" type="range" min="0" max="35" step="0.1" value="20.0" />
          <div class="row">
            <span class="pill mono" id="altRead">h=20.0 km</span>
            <span class="pill mono" id="rhoRead">ρ=0.000 kg/m³</span>
            <span class="pill mono" id="tInfRead">T∞=0 K</span>
          </div>
        </div>

        <div>
          <label>Auto Ramp Mach 1→10</label>
          <input id="rampToggle" type="range" min="0" max="1" step="1" value="1" />
          <div class="row">
            <button id="startBtn" class="btn primary">Start</button>
            <button id="stopBtn" class="btn" disabled>Stop</button>
            <button id="resetBtn" class="btn danger">Reset</button>
            <span class="pill mono" id="rampRead">AUTO: ON</span>
          </div>
        </div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div class="kpi">
          <div>
            <div class="k">Wall Temp</div>
            <div class="v mono" id="twKpi">200.0 °C</div>
          </div>
          <div class="pill mono" id="twWindow">Target: 205±5 °C</div>
        </div>
        <div class="kpi">
          <div>
            <div class="k">Coolant Flow</div>
            <div class="v mono" id="mdotKpi">0.80 kg/s</div>
          </div>
          <div class="pill mono" id="coolantMode">PI Control</div>
        </div>
        <div class="kpi">
          <div>
            <div class="k">Medium Stability Index</div>
            <div class="v mono" id="msKpi">0.50</div>
          </div>
          <div class="pill mono" id="msBand">Target: 0.50</div>
        </div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div class="kpi">
          <div>
            <div class="k">Thrust Available</div>
            <div class="v mono" id="thrustKpi">0 kN</div>
          </div>
          <div class="pill mono" id="thrustType">Cycle: Scram-mode</div>
        </div>
        <div class="kpi">
          <div>
            <div class="k">Drag</div>
            <div class="v mono" id="dragKpi">0 kN</div>
          </div>
          <div class="pill mono" id="qKpi">q∞=0 kPa</div>
        </div>
        <div class="kpi">
          <div>
            <div class="k">Margin</div>
            <div class="v mono" id="marginKpi">OK</div>
          </div>
          <div class="pill mono" id="marginVal">T>D: +0 kN</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <label>Overall Constraint Health (Dyson-style: stable if all constraints stay inside bounds)</label>
        <div class="bar"><i id="healthBar" style="width: 70%"></i></div>
        <div class="row" style="margin-top:8px">
          <span class="pill mono" id="piRead">Π=0.60 / Πmax=1.00</span>
          <span class="pill mono" id="t0Read">T0=0 K</span>
          <span class="pill mono" id="qinRead">q_in≈0 kW/m²</span>
          <span class="pill mono" id="qoutRead">q_out≈0 kW/m²</span>
        </div>
      </div>
    </div>

    <div class="foot">
      Tip: Keep the jet “green” by choosing a higher altitude (lower density), and let the controller raise coolant flow as Mach increases.
    </div>
  </section>

  <!-- RIGHT: Equations + Instructions + Logs -->
  <aside class="card">
    <div class="title">
      <b>Equations, What the Simulation Does, and Live Logs</b>
      <span class="pill mono" id="clocks">UTC — | CST — | IST —</span>
    </div>
    <div class="body">

      <div class="small">
        <b>What this simulation is:</b> a closed-loop “heat + coolant + momentum” model that ramps Mach and continuously adjusts coolant flow to keep a
        <b>skin temperature window</b> ($T^*\\pm\\Delta T$) and a <b>medium stability index</b> near target while also checking <b>propulsion margin</b> ($T_{net}(M,h)&gt;D(M,h)$).<br><br>
        <b>What it’s not:</b> a real CFD solver or a real scramjet performance predictor. It’s a safe, conceptual stability dashboard.
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0">

      <div class="eq">
        <b>Core definitions (computed live)</b><br>
        1) Mach definition: $M=\\dfrac{V}{a}$, with $a=\\sqrt{\\gamma R T_\\infty}$.<br>
        2) Stagnation temperature trend: $T_0=T_\\infty\\left(1+\\dfrac{\\gamma-1}{2}M^2\\right)$.<br>
        3) Dynamic pressure: $q_\\infty=\\dfrac12\\rho_\\infty V^2$.<br><br>

        <b>Propulsion requirement</b><br>
        $T_{net}(M,h)&gt;D(M,h)$ (in the sim: thrust-available must exceed drag).<br><br>

        <b>Stability requirement (your contribution)</b><br>
        $T_{min}\\le T_w\\le T_{max}$, $\\Pi\\le\\Pi_{max}$, and $M_s\\approx\\text{stable}$.<br><br>

        <b>Wall energy balance (closed-loop)</b><br>
        $C_w\\,\\dfrac{dT_w}{dt}=q_{in}(M,h,\\dots)-q_{out}(\\dot m_{cool})$<br>
        with $C_w=\\rho_s c_s d_s$ (effective thermal capacitance).<br><br>

        <b>Cooling removal (simplified)</b><br>
        $q_{out}\\approx \\eta\\,\\dot m_{cool}\\,c_p\\,(T_w-T_{cool})$<br><br>

        <b>Controller (PI, clamped)</b><br>
        $\\dot m_{cool}=\\text{clamp}(\\dot m_0+K_p(T_w-T^*)+K_i\\int(T_w-T^*)dt)$<br><br>

        <b>Medium Stability Index (dimensionless)</b><br>
        $M_s=w_T\\,\\frac{T_w-T^*}{\\Delta T}+w_\\Pi\\,\\frac{\\Pi}{\\Pi_{max}}+w_M\\,\\frac{\\max(0,D/T-1)}{1}$<br>
        (weights $w_*$ keep the index interpretable; target is near 0.50 in this sim).
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:12px 0">

      <div class="grid2">
        <div>
          <label>Skin Target Window</label>
          <div class="row">
            <span class="pill mono" id="tStarRead">T*=205 °C</span>
            <span class="pill mono" id="dTRead">ΔT=5 °C</span>
            <span class="pill mono" id="tMinMaxRead">[200, 210] °C</span>
          </div>
        </div>
        <div>
          <label>Controller Gains</label>
          <div class="row">
            <span class="pill mono" id="kpRead">Kp=0.060</span>
            <span class="pill mono" id="kiRead">Ki=0.010</span>
            <span class="pill mono" id="mdotLimRead">ṁ∈[0.20, 3.50]</span>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <label>Live Event Log (constraint warnings, margin changes)</label>
        <div id="log" class="log"></div>
      </div>

    </div>
    <div class="foot">
      Controls: Start begins time integration; Stop pauses; Reset restores initial state. Auto Ramp (ON) sweeps Mach 1→10; you can override with the Mach slider.
    </div>
  </aside>
</div>

<script>
/* ==========================
   MACH 1→10 STABILITY SIM
   Conceptual closed-loop model
   ========================== */

const $ = (id)=>document.getElementById(id);

const ui = {
  jetCanvas: $("jetCanvas"),
  machSlider: $("machSlider"),
  altSlider: $("altSlider"),
  rampToggle: $("rampToggle"),
  startBtn: $("startBtn"),
  stopBtn: $("stopBtn"),
  resetBtn: $("resetBtn"),

  machRead: $("machRead"),
  velRead: $("velRead"),
  aRead: $("aRead"),

  altRead: $("altRead"),
  rhoRead: $("rhoRead"),
  tInfRead: $("tInfRead"),

  rampRead: $("rampRead"),
  simTime: $("simTime"),

  twKpi: $("twKpi"),
  twWindow: $("twWindow"),
  mdotKpi: $("mdotKpi"),
  msKpi: $("msKpi"),

  thrustKpi: $("thrustKpi"),
  dragKpi: $("dragKpi"),
  marginKpi: $("marginKpi"),
  marginVal: $("marginVal"),
  qKpi: $("qKpi"),

  piRead: $("piRead"),
  t0Read: $("t0Read"),
  qinRead: $("qinRead"),
  qoutRead: $("qoutRead"),

  dot: $("dot"),
  statusText: $("statusText"),
  healthBar: $("healthBar"),

  clocks: $("clocks"),
  log: $("log"),

  tStarRead: $("tStarRead"),
  dTRead: $("dTRead"),
  tMinMaxRead: $("tMinMaxRead"),
  kpRead: $("kpRead"),
  kiRead: $("kiRead"),
  mdotLimRead: $("mdotLimRead"),
  thrustType: $("thrustType"),
  coolantMode: $("coolantMode"),
  msBand: $("msBand"),
};

const ctx = ui.jetCanvas.getContext("2d");

// Physical-ish constants (conceptual)
const gamma = 1.4;
const R = 287.05;          // J/(kg*K) air
const g0 = 9.80665;

// Vehicle / model parameters (conceptual)
const Aref = 1.8;          // m^2 reference area
const Cd0  = 0.16;         // baseline drag coefficient
const CdM  = 0.020;        // drag growth with Mach (conceptual)
const thrustBase = 280e3;  // N baseline available thrust scaling (conceptual)
const Hscale = 7200;       // m density scale height-ish for thrust availability (conceptual)

// Wall thermal parameters (conceptual)
const Cw = 4.2e5;          // J/(m^2*K) effective wall capacitance (lumped)
const cpCool = 1100;       // J/(kg*K) coolant cp (conceptual)
const etaCool = 0.85;      // effectiveness
const Tcool = 120 + 273.15;// K coolant temp (conceptual cold loop ~120K)
const epsRad = 0.20;       // emissivity-ish (conceptual)
const sigmaSB = 5.670374e-8;

// Heating model scale
const heatGain = 0.010;    // scales q∞ into kW/m^2 (conceptual mapping)
const radGain  = 0.0000008;// scales radiation effect (kept small, conceptual)

// Control targets
let TstarC = 205;          // °C target
let dTC = 5;               // °C half-window
let TminC = TstarC - dTC;
let TmaxC = TstarC + dTC;

const PiMax = 1.00;        // max backpressure ratio proxy
const MsTarget = 0.50;

// Controller gains & limits
let Kp = 0.060;
let Ki = 0.010;
const mdotMin = 0.20;
const mdotMax = 3.50;

// State
let running = false;
let t = 0;
let lastTs = null;

// Dynamic state vars
let MachCmd = 1.00;
let Mach = 1.00;
let h_km = 20.0;

let TwK = (200 + 273.15);     // wall temperature
let mdot = 0.80;              // coolant mass flow kg/s (control output)
let iErr = 0;                 // integral error
let logLines = [];
let lastLogKey = "";

// AUTO ramp
let autoRamp = true;
let rampDir = 1;
let rampRate = 0.18;          // Mach per second

// Small helper
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x, d=2){ return Number(x).toFixed(d); }
function nowISO(){ return new Date().toLocaleTimeString([], {hour12:false}); }

// ISA-like atmosphere (simple, enough for sim)
function atmosphere(h_m){
  // Piecewise: troposphere (0-11km), lower stratosphere (11-20km), above 20km simple exponential
  let T, p, rho;
  if(h_m < 11000){
    const T0 = 288.15;
    const L = -0.0065; // K/m
    T = T0 + L*h_m;
    p = 101325 * Math.pow(T/T0, -g0/(L*R));
    rho = p/(R*T);
  } else if(h_m < 20000){
    const T11 = 216.65;
    const p11 = 22632.06;
    T = T11;
    p = p11 * Math.exp(-g0*(h_m-11000)/(R*T));
    rho = p/(R*T);
  } else {
    // crude continuation: T slowly rises, rho exponential
    T = 216.65 + 0.001*(h_m-20000);
    const rho20 = (5474.89)/(R*(216.65)); // approximate from p at 20km (~5475 Pa)
    rho = rho20 * Math.exp(-(h_m-20000)/6500);
    p = rho*R*T;
  }
  const a = Math.sqrt(gamma*R*T);
  return {T, p, rho, a};
}

// Conceptual thrust availability vs Mach (cycle ladder)
function thrustAvailable(M, h_m){
  // Efficiency hump: strongest in scram-like region (5-9), weaker near 1-3, decays after ~10
  const eff =
    0.25*Math.exp(-Math.pow((M-2.2)/1.2,2)) +  // turbo/ram-ish hump
    0.85*Math.exp(-Math.pow((M-7.0)/2.0,2)) +  // scram-ish hump
    0.12;                                      // baseline
  const altFactor = Math.exp(-h_m/Hscale);     // less air, less thrust
  // cap and scale
  return thrustBase * eff * (0.55 + 0.45*altFactor);
}

// Conceptual drag
function dragForce(M, qInf){
  const Cd = Cd0 + CdM*(M-1) + 0.0025*Math.pow(M-1,2); // mild growth
  return Cd * Aref * qInf;
}

// Backpressure proxy Π (unstart risk), influenced by Mach and “thermal/conditioning”
function backpressureProxy(M, mdot){
  // Base rises in scram region, reduced by more conditioning (mdot)
  let Pi = 0.62
    + 0.03*Math.max(0, M-3)
    + 0.02*Math.max(0, M-6);
  // Conditioning effect (more coolant/film reduces effective Π)
  Pi -= 0.05*(mdot-0.8);
  return clamp(Pi, 0.40, 1.60);
}

// Heating input (conceptual): q_in scales with dynamic pressure and Mach trend
function heatingIn(qInf, M, T0K, TwK){
  // convective trend: scales with q∞ and rises with M^2 mildly
  const conv_kWm2 = heatGain * (qInf/1000) * (1 + 0.06*M*M); // kW/m^2
  // radiative-ish term: small (kept conceptual)
  const rad_kWm2 = radGain * epsRad * sigmaSB * (Math.pow(T0K,4) - Math.pow(TwK,4)) / 1000;
  return Math.max(0, conv_kWm2 + rad_kWm2);
}

// Cooling removal (conceptual): q_out = η ṁ cp (Tw - Tcool)
function coolingOut_kWm2(mdot, TwK){
  // convert to kW/m^2 (assume unit effective area for lump model)
  const qW = etaCool * mdot * cpCool * Math.max(0, (TwK - Tcool));
  return qW/1000;
}

// Stability index Ms (dimensionless)
function mediumStabilityIndex(TwK, Pi, thrustN, dragN){
  const TwC = TwK - 273.15;
  const eT = (TwC - TstarC)/dTC;             // normalized temperature error (±1 ~ window edges)
  const rPi = Pi / PiMax;                    // >1 means unstart-ish risk
  const rMD = (thrustN>1 ? Math.max(0, dragN/thrustN - 1) : 1); // >0 if drag exceeds thrust
  // weights
  const wT=0.62, wP=0.25, wM=0.13;
  return clamp(0.50 + wT*eT + wP*(rPi-0.60) + wM*rMD*2.0, 0, 2);
}

function logOnce(key, msg){
  if(key === lastLogKey) return;
  lastLogKey = key;
  const line = `<div><span class="t">${nowISO()}</span> — ${msg}</div>`;
  logLines.unshift(line);
  if(logLines.length>80) logLines.pop();
  ui.log.innerHTML = logLines.join("");
}

function setStatus(level, text){
  ui.statusText.textContent = text;
  ui.dot.className = "dot" + (level==="warn" ? " warn" : level==="bad" ? " bad" : "");
}

function updateClocks(){
  const now = new Date();
  // UTC
  const utc = new Date(now.toLocaleString("en-US", {timeZone:"UTC"}));
  // CST (America/Monterrey)
  const cst = new Date(now.toLocaleString("en-US", {timeZone:"America/Monterrey"}));
  // "Interstellar Time" (IST) — define as CST + mission elapsed offset (conceptual)
  const ist = new Date(cst.getTime() + (t*1000)); // IST = CST + sim time
  ui.clocks.textContent =
    `UTC ${utc.toLocaleTimeString([], {hour12:false})} | CST ${cst.toLocaleTimeString([], {hour12:false})} | IST ${ist.toLocaleTimeString([], {hour12:false})}`;
}

function drawJet(glowColor, glowStrength){
  const W = ui.jetCanvas.width, H = ui.jetCanvas.height;
  ctx.clearRect(0,0,W,H);

  // Background grid
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "#3a4a86";
  for(let x=0;x<=W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<=H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();

  // Pulse glow around craft
  const pulse = 0.65 + 0.35*Math.sin(t*4.0);
  const g = clamp(glowStrength, 0, 1) * pulse;

  // Glow gradient
  const cx = W*0.52, cy = H*0.52;
  const r1 = 85 + 40*g;
  const r2 = 190 + 90*g;
  const grad = ctx.createRadialGradient(cx, cy, r1, cx, cy, r2);
  grad.addColorStop(0, `rgba(${glowColor.r},${glowColor.g},${glowColor.b},${0.35*g})`);
  grad.addColorStop(1, `rgba(${glowColor.r},${glowColor.g},${glowColor.b},0)`);

  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // Jet silhouette
  ctx.save();
  ctx.translate(W*0.12, H*0.52);
  ctx.scale(1.0, 1.0);

  // body
  ctx.fillStyle = "rgba(233,238,255,0.92)";
  ctx.strokeStyle = "rgba(130,150,220,0.55)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(0, -18);
  ctx.lineTo(310, -18);
  ctx.quadraticCurveTo(340, -16, 360, -6);
  ctx.quadraticCurveTo(385, 0, 360, 6);
  ctx.quadraticCurveTo(340, 16, 310, 18);
  ctx.lineTo(0, 18);
  ctx.quadraticCurveTo(-18, 0, 0, -18);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // canopy
  ctx.fillStyle = "rgba(130,169,255,0.35)";
  ctx.beginPath();
  ctx.ellipse(120, -8, 42, 18, 0, 0, Math.PI*2);
  ctx.fill();

  // wings
  ctx.fillStyle = "rgba(233,238,255,0.88)";
  ctx.beginPath();
  ctx.moveTo(120, 10);
  ctx.lineTo(170, 50);
  ctx.lineTo(230, 52);
  ctx.lineTo(175, 12);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(130, -10);
  ctx.lineTo(175, -52);
  ctx.lineTo(240, -50);
  ctx.lineTo(185, -12);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // inlet highlight (front)
  ctx.fillStyle = "rgba(0,0,0,0.28)";
  ctx.beginPath();
  ctx.moveTo(-3, -12);
  ctx.lineTo(30, -12);
  ctx.quadraticCurveTo(40, 0, 30, 12);
  ctx.lineTo(-3, 12);
  ctx.closePath();
  ctx.fill();

  // nozzle highlight (back)
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.beginPath();
  ctx.moveTo(310, -10);
  ctx.lineTo(350, -3);
  ctx.lineTo(350, 3);
  ctx.lineTo(310, 10);
  ctx.closePath();
  ctx.fill();

  // shock “bow” curve (wind bending visual)
  ctx.strokeStyle = `rgba(${glowColor.r},${glowColor.g},${glowColor.b},${0.35 + 0.25*g})`;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.bezierCurveTo(20, -60, 90, -70, 170, -40);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.bezierCurveTo(20, 60, 90, 70, 170, 40);
  ctx.stroke();

  ctx.restore();

  // Legend
  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(16,23,42,0.75)";
  ctx.fillRect(12, 12, 300, 86);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.strokeRect(12, 12, 300, 86);
  ctx.fillStyle = "rgba(233,238,255,0.95)";
  ctx.font = "12px system-ui,Segoe UI,Roboto,Arial";
  ctx.fillText("Glow represents surface stability state:", 22, 34);
  ctx.fillStyle = "rgba(120,160,255,0.95)";
  ctx.fillText("Blue = cold / under-target", 22, 52);
  ctx.fillStyle = "rgba(53,208,127,0.95)";
  ctx.fillText("Green = within window (stable)", 22, 68);
  ctx.fillStyle = "rgba(255,90,102,0.95)";
  ctx.fillText("Red = hot / over-target", 22, 84);
  ctx.restore();
}

// Color mapping: blue -> green -> red
function stabilityColor(score01){
  const s = clamp(score01, 0, 1);
  if(s < 0.5){
    const t = s/0.5;
    return {
      r: Math.round(lerp(90, 53, t)),
      g: Math.round(lerp(160, 208, t)),
      b: Math.round(lerp(255, 127, t))
    };
  } else {
    const t = (s-0.5)/0.5;
    return {
      r: Math.round(lerp(53, 255, t)),
      g: Math.round(lerp(208, 90, t)),
      b: Math.round(lerp(127, 102, t))
    };
  }
}

function updateUI(snapshot){
  ui.simTime.textContent = `t=${fmt(snapshot.t,1)}s`;

  ui.machRead.textContent = `M=${fmt(snapshot.M,2)}`;
  ui.velRead.textContent = `V=${fmt(snapshot.V,0)} m/s`;
  ui.aRead.textContent = `a=${fmt(snapshot.a,0)} m/s`;

  ui.altRead.textContent = `h=${fmt(snapshot.h_km,1)} km`;
  ui.rhoRead.textContent = `ρ=${fmt(snapshot.rho,4)} kg/m³`;
  ui.tInfRead.textContent = `T∞=${fmt(snapshot.Tinf,0)} K`;

  ui.twKpi.textContent = `${fmt(snapshot.TwC,1)} °C`;
  ui.twWindow.textContent = `Target: ${fmt(TstarC,0)}±${fmt(dTC,0)} °C`;
  ui.mdotKpi.textContent = `${fmt(snapshot.mdot,2)} kg/s`;
  ui.msKpi.textContent = fmt(snapshot.Ms,2);

  ui.thrustKpi.textContent = `${fmt(snapshot.thrust/1000,0)} kN`;
  ui.dragKpi.textContent = `${fmt(snapshot.drag/1000,0)} kN`;
  ui.qKpi.textContent = `q∞=${fmt(snapshot.qInf/1000,1)} kPa`;

  ui.t0Read.textContent = `T0=${fmt(snapshot.T0,0)} K`;
  ui.piRead.textContent = `Π=${fmt(snapshot.Pi,2)} / Πmax=${fmt(PiMax,2)}`;
  ui.qinRead.textContent = `q_in≈${fmt(snapshot.qIn,1)} kW/m²`;
  ui.qoutRead.textContent = `q_out≈${fmt(snapshot.qOut,1)} kW/m²`;

  // margin
  const marginN = snapshot.thrust - snapshot.drag;
  const ok = marginN > 0;
  ui.marginKpi.textContent = ok ? "OK" : "FAIL";
  ui.marginVal.textContent = `T>D: ${ok?"+":""}${fmt(marginN/1000,0)} kN`;
  ui.marginKpi.style.color = ok ? "var(--ok)" : "var(--bad)";

  // health score: penalize temp out of window, Pi out of bound, thrust margin negative
  const tempErr = Math.abs(snapshot.TwC - TstarC)/dTC; // 0..∞
  const tempPenalty = clamp((tempErr-1)/2, 0, 1);      // 0 inside window, grows outside
  const piPenalty = clamp((snapshot.Pi/PiMax - 1), 0, 1);
  const marginPenalty = clamp((-marginN)/(0.8*snapshot.thrust + 1), 0, 1);

  const health = 1 - clamp(0.55*tempPenalty + 0.30*piPenalty + 0.15*marginPenalty, 0, 1);
  ui.healthBar.style.width = `${fmt(health*100,1)}%`;

  // status dot
  if(health > 0.80){
    setStatus("ok", "STABLE");
  } else if(health > 0.55){
    setStatus("warn", "WATCH");
  } else {
    setStatus("bad", "UNSTABLE");
  }

  // glow score uses temperature dominance (what you asked for)
  const glowScore = clamp(0.7*clamp(tempErr/1.4,0,1) + 0.2*piPenalty + 0.1*marginPenalty, 0, 1);
  const col = stabilityColor(glowScore);

  // draw
  drawJet(col, glowScore);

  // log important events
  const TwOut = (snapshot.TwC < TminC) || (snapshot.TwC > TmaxC);
  if(TwOut){
    logOnce("TwOut", `Wall temperature out of window: Tw=${fmt(snapshot.TwC,1)}°C (target ${TstarC}±${dTC}). Controller increasing coolant.`);
  } else if(snapshot.M > 1.05){
    logOnce("TwOk", `Temperature within window. Closed-loop maintaining Tw≈${fmt(snapshot.TwC,1)}°C as Mach changes.`);
  }

  if(snapshot.Pi > PiMax){
    logOnce("PiHigh", `Backpressure proxy Π exceeded Πmax (risk of inlet instability/unstart). Increasing conditioning via coolant/injection proxy.`);
  }

  if(!ok && snapshot.M > 2){
    logOnce("MarginFail", `Propulsion margin failed (T≤D). Increase altitude (lower density), improve thrust model, or reduce Mach ramp rate.`);
  }

  // equation inputs readouts
  ui.tStarRead.textContent = `T*=${fmt(TstarC,0)} °C`;
  ui.dTRead.textContent = `ΔT=${fmt(dTC,0)} °C`;
  ui.tMinMaxRead.textContent = `[${fmt(TminC,0)}, ${fmt(TmaxC,0)}] °C`;
  ui.kpRead.textContent = `Kp=${fmt(Kp,3)}`;
  ui.kiRead.textContent = `Ki=${fmt(Ki,3)}`;
  ui.mdotLimRead.textContent = `ṁ∈[${fmt(mdotMin,2)}, ${fmt(mdotMax,2)}]`;
}

function step(dt){
  // read UI commands
  h_km = parseFloat(ui.altSlider.value);
  MachCmd = parseFloat(ui.machSlider.value);
  autoRamp = (parseInt(ui.rampToggle.value,10) === 1);
  ui.rampRead.textContent = `AUTO: ${autoRamp ? "ON" : "OFF"}`;

  // auto ramp logic
  if(autoRamp){
    Mach += rampDir * rampRate * dt;
    if(Mach >= 10){ Mach = 10; rampDir = -1; }
    if(Mach <= 1){ Mach = 1; rampDir =  1; }
    // sync slider so user sees it
    ui.machSlider.value = Mach.toFixed(2);
  } else {
    Mach = MachCmd;
  }

  // atmosphere
  const h_m = h_km*1000;
  const at = atmosphere(h_m);
  const a = at.a;
  const V = Mach * a;
  const rho = at.rho;
  const Tinf = at.T;

  // stagnation temp trend
  const T0 = Tinf*(1 + (gamma-1)/2 * Mach*Mach);

  // dynamic pressure & forces
  const qInf = 0.5 * rho * V*V;
  const thrust = thrustAvailable(Mach, h_m);
  const drag = dragForce(Mach, qInf);

  // backpressure proxy Π
  let Pi = backpressureProxy(Mach, mdot);

  // heating/cooling
  const qIn = heatingIn(qInf, Mach, T0, TwK);    // kW/m^2
  // PI controller to hold Tw near target
  const TwC = TwK - 273.15;
  const e = (TwC - TstarC);
  iErr += e * dt;
  iErr = clamp(iErr, -150, 150);

  // baseline flow rises with Mach (conceptual: you “open the valve” as speed rises)
  const mdot0 = 0.55 + 0.06*(Mach-1);

  mdot = clamp(mdot0 + Kp*e + Ki*iErr, mdotMin, mdotMax);

  // more coolant slightly reduces effective Π (conditioning)
  Pi = backpressureProxy(Mach, mdot);

  const qOut = coolingOut_kWm2(mdot, TwK);       // kW/m^2

  // wall temperature ODE
  // convert kW/m^2 -> W/m^2
  const dTw = ((qIn - qOut)*1000) / Cw;
  TwK += dTw * dt;

  // medium stability index
  const Ms = mediumStabilityIndex(TwK, Pi, thrust, drag);

  // snapshot
  return {
    t, M:Mach, V, a, h_km, rho, Tinf, T0, qInf,
    TwC: (TwK - 273.15),
    mdot, qIn, qOut,
    thrust, drag, Pi, Ms
  };
}

function tick(ts){
  if(!running){ lastTs=null; return; }
  if(lastTs===null) lastTs = ts;
  let dt = (ts-lastTs)/1000;
  lastTs = ts;
  dt = clamp(dt, 0.001, 0.05); // stable integration

  t += dt;

  // update clocks
  updateClocks();

  // compute and render
  const snap = step(dt);
  updateUI(snap);

  requestAnimationFrame(tick);
}

function reset(){
  running = false;
  t = 0;
  lastTs = null;
  rampDir = 1;

  // defaults
  ui.altSlider.value = "20.0";
  ui.machSlider.value = "1.00";
  ui.rampToggle.value = "1";

  Mach = 1.00;
  MachCmd = 1.00;
  h_km = 20.0;

  TwK = 200 + 273.15;
  mdot = 0.80;
  iErr = 0;

  logLines = [];
  ui.log.innerHTML = "";
  lastLogKey = "";

  setStatus("ok", "READY");
  ui.simTime.textContent = "t=0.0s";

  ui.startBtn.disabled = false;
  ui.stopBtn.disabled = true;

  // render one frame
  updateClocks();
  const at = atmosphere(h_km*1000);
  const a = at.a;
  const V = Mach*a;
  const T0 = at.T*(1 + (gamma-1)/2 * Mach*Mach);
  const qInf = 0.5*at.rho*V*V;
  const thrust = thrustAvailable(Mach, h_km*1000);
  const drag = dragForce(Mach, qInf);
  const Pi = backpressureProxy(Mach, mdot);
  const qIn = heatingIn(qInf, Mach, T0, TwK);
  const qOut = coolingOut_kWm2(mdot, TwK);
  const Ms = mediumStabilityIndex(TwK, Pi, thrust, drag);

  updateUI({
    t, M:Mach, V, a, h_km, rho:at.rho, Tinf:at.T, T0, qInf,
    TwC: (TwK-273.15), mdot, qIn, qOut, thrust, drag, Pi, Ms
  });

  // initial draw
  drawJet(stabilityColor(0.35), 0.25);
  logOnce("Reset", "Reset complete. Start to ramp Mach 1→10 with closed-loop cooling.");
}

ui.startBtn.addEventListener("click", ()=>{
  if(running) return;
  running = true;
  ui.startBtn.disabled = true;
  ui.stopBtn.disabled = false;
  setStatus("ok","RUNNING");
  logOnce("Start", "Simulation started. Controller regulating Tw within target window as Mach ramps.");
  requestAnimationFrame(tick);
});

ui.stopBtn.addEventListener("click", ()=>{
  running = false;
  ui.startBtn.disabled = false;
  ui.stopBtn.disabled = true;
  setStatus("warn","PAUSED");
  logOnce("Stop", "Simulation paused.");
});

ui.resetBtn.addEventListener("click", reset);

ui.rampToggle.addEventListener("input", ()=>{
  const on = (parseInt(ui.rampToggle.value,10) === 1);
  ui.rampRead.textContent = `AUTO: ${on ? "ON" : "OFF"}`;
  logOnce("RampToggle", `Auto ramp set to ${on ? "ON" : "OFF"}.`);
});

ui.machSlider.addEventListener("input", ()=>{
  if(parseInt(ui.rampToggle.value,10)===1) return; // auto updates slider
  logOnce("MachManual", `Manual Mach command set to M=${fmt(parseFloat(ui.machSlider.value),2)}.`);
});

ui.altSlider.addEventListener("input", ()=>{
  logOnce("AltChange", `Altitude set to h=${fmt(parseFloat(ui.altSlider.value),1)} km.`);
});

// Initialize
reset();
setInterval(updateClocks, 250);
</script>
</body>
</html>
