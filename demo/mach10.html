<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mach-10 Route Simulator — Autopilot Stability Hold + Live Gauges</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0f14;
    --panel:#111827;
    --panel2:#0f172a;
    --ink:#e5e7eb;
    --muted:#9aa4c7;
    --line:#223052;
    --accent:#60a5fa;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --shadow: 0 14px 38px rgba(0,0,0,.45);
    --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: radial-gradient(1200px 700px at 50% -10%, #0b2040 0%, #070a10 55%, #05070b 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background: linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.70));
    position: sticky; top:0; z-index:5;
    backdrop-filter: blur(8px);
  }
  header .row{
    display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    max-width:1280px; margin:0 auto;
  }
  .title{
    display:flex; flex-direction:column; gap:2px;
    min-width: 290px;
  }
  .title h1{margin:0;font-size:16px;letter-spacing:.3px}
  .title .sub{color:var(--muted);font-size:12px}
  .controls{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    margin-left:auto;
  }
  select, button, input[type="checkbox"]{
    font:inherit;
  }
  select{
    padding:9px 10px;
    border-radius:10px;
    border:1px solid var(--line);
    background: rgba(2,6,23,.55);
    color:var(--ink);
    min-width: 320px;
  }
  button{
    padding:9px 12px;
    border-radius:10px;
    border:1px solid var(--line);
    background: rgba(96,165,250,.15);
    color:var(--ink);
    cursor:pointer;
    transition: transform .06s ease, background .15s ease;
  }
  button:hover{background: rgba(96,165,250,.22)}
  button:active{transform: translateY(1px)}
  button.primary{background: rgba(52,211,153,.18)}
  button.primary:hover{background: rgba(52,211,153,.24)}
  button.danger{background: rgba(251,113,133,.14)}
  button.danger:hover{background: rgba(251,113,133,.20)}
  .toggle{
    display:flex; align-items:center; gap:8px;
    padding:8px 10px;
    border:1px solid var(--line);
    border-radius:10px;
    background: rgba(2,6,23,.35);
    color:var(--muted);
    user-select:none;
  }
  .toggle strong{color:var(--ink); font-weight:600}
  main{
    max-width:1280px;
    margin:0 auto;
    padding:14px 16px 22px;
  }
  .grid{
    display:grid;
    grid-template-columns: 1.05fr .95fr;
    gap:14px;
  }
  @media (max-width: 980px){
    .grid{grid-template-columns: 1fr}
    select{min-width: 100%}
    .title{min-width: 0}
  }
  .card{
    background: linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.74));
    border:1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    display:flex;
    align-items:baseline;
    justify-content:space-between;
    gap:10px;
    padding:12px 12px 10px;
    border-bottom:1px solid var(--line);
  }
  .card .hd h2{margin:0;font-size:13px;letter-spacing:.35px}
  .chip{
    font-size:12px;
    padding:4px 9px;
    border:1px solid var(--line);
    border-radius:999px;
    color:var(--muted);
    background: rgba(2,6,23,.35);
    white-space:nowrap;
  }
  .chip.good{border-color: rgba(52,211,153,.35); color: var(--good)}
  .chip.bad{border-color: rgba(251,113,133,.35); color: var(--bad)}
  .body{padding:12px}
  .two{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  @media (max-width: 700px){
    .two{grid-template-columns: 1fr}
  }
  .kv{
    display:flex;
    align-items:baseline;
    justify-content:space-between;
    gap:10px;
    padding:10px 10px;
    border:1px solid var(--line);
    border-radius:12px;
    background: rgba(2,6,23,.30);
  }
  .kv .k{
    color:var(--muted);
    font-size:12px;
    display:flex; flex-direction:column; gap:3px;
  }
  .kv .k small{color:rgba(154,164,199,.8)}
  .kv .v{
    text-align:right;
    font-variant-numeric: tabular-nums;
  }
  .kv .v .big{font-size:18px; font-weight:750; letter-spacing:.2px}
  .kv .v .sm{font-size:12px; color:var(--muted)}
  .barwrap{
    margin-top:10px;
    border:1px solid var(--line);
    border-radius:12px;
    padding:10px;
    background: rgba(2,6,23,.28);
  }
  .barrow{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px}
  .barrow .lbl{font-size:12px; color:var(--muted)}
  .barrow .val{font-size:12px; color:var(--ink); font-variant-numeric: tabular-nums}
  .bar{
    height:12px; border-radius:999px; overflow:hidden;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.08);
  }
  .fill{
    height:100%;
    width:0%;
    background: var(--accent);
    transition: width .08s linear, background .12s linear;
  }
  .fill.good{background: var(--good)}
  .fill.warn{background: var(--warn)}
  .fill.bad{background: var(--bad)}
  .hint{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .log{
    max-height: 320px;
    overflow:auto;
    border:1px solid var(--line);
    border-radius:12px;
    background: rgba(2,6,23,.30);
    padding:10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size:12px;
    line-height:1.35;
  }
  .log .line{white-space:pre-wrap}
  .log .t{color:#a7f3d0}
  .log .w{color:#fde68a}
  .log .e{color:#fda4af}
  .footerNote{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
  }
</style>
</head>
<body>
<header>
  <div class="row">
    <div class="title">
      <h1>Mach-10 Route Simulator — AUTOPILOT: STABILITY HOLD</h1>
      <div class="sub">Cruise aims for Mach 10; if unstable, it automatically drops to the last stable Mach. Gauges are fully physics-driven (drag, q∞, thrust margin, inlet proxy).</div>
    </div>
    <div class="controls">
      <select id="routeSel" title="Choose one of 5 routes"></select>
      <button class="primary" id="btnStart">Start</button>
      <button id="btnStop">Stop</button>
      <button class="danger" id="btnReset">Reset</button>
      <label class="toggle" title="If ON: autopilot manages Mach targets and stability fallback">
        <input type="checkbox" id="autoHold" checked />
        <span><strong>AUTOPILOT</strong> Stability Hold</span>
      </label>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <!-- LEFT: Flight + Propulsion -->
    <section class="card">
      <div class="hd">
        <h2>Flight / Propulsion</h2>
        <div id="chipStable" class="chip">Status: —</div>
      </div>
      <div class="body">
        <div class="two">
          <div class="kv">
            <div class="k">Phase <small>Takeoff → Cruise → Landing</small></div>
            <div class="v"><div class="big" id="phaseTxt">READY</div><div class="sm" id="routeTxt">—</div></div>
          </div>
          <div class="kv">
            <div class="k">Mach / Speed <small>Autopilot target + actual</small></div>
            <div class="v">
              <div class="big"><span id="machNow">0.00</span> M</div>
              <div class="sm">Target <span id="machTgt">—</span> · V <span id="vNow">0</span> m/s</div>
            </div>
          </div>

          <div class="kv">
            <div class="k">Altitude <small>ISA density model</small></div>
            <div class="v"><div class="big"><span id="altNow">0.0</span> km</div><div class="sm">ρ <span id="rhoNow">1.225</span> kg/m³</div></div>
          </div>
          <div class="kv">
            <div class="k">Dynamic Pressure q∞ <small>q = ½ρV²</small></div>
            <div class="v"><div class="big"><span id="qNow">0.0</span> kPa</div><div class="sm">Constraint band shown below</div></div>
          </div>

          <div class="kv">
            <div class="k">Thrust Available <small>Engine proxy</small></div>
            <div class="v"><div class="big"><span id="thrustNow">0</span> kN</div><div class="sm">Inlet Π <span id="piNow">0.65</span></div></div>
          </div>
          <div class="kv">
            <div class="k">Drag <small>D = ½ρV²·CdA</small></div>
            <div class="v"><div class="big"><span id="dragNow">0</span> kN</div><div class="sm">CdA <span id="cdaNow">0.85</span> m²</div></div>
          </div>

          <div class="kv">
            <div class="k">Thrust Margin <small>T − D</small></div>
            <div class="v"><div class="big"><span id="marginNow">+0</span> kN</div><div class="sm">T&gt;D: <span id="tdNow">—</span></div></div>
          </div>
          <div class="kv">
            <div class="k">Stability Health <small>0…1 (green stable / red unstable)</small></div>
            <div class="v"><div class="big"><span id="healthNow">0.00</span></div><div class="sm">Ms <span id="msNow">0.00</span></div></div>
          </div>
        </div>

        <div class="barwrap">
          <div class="barrow">
            <div class="lbl">Autopilot Stability Hold</div>
            <div class="val">Last stable Mach: <span id="lastStableMach">0.00</span></div>
          </div>
          <div class="bar"><div id="barHealth" class="fill"></div></div>
          <div class="hint">
            Stability health is computed from thrust margin, q∞ overload risk, inlet Π, and thermal deviation.
            If health drops below 0.70 during cruise, autopilot immediately reduces to the last stable Mach and logs the event.
          </div>
        </div>

        <div class="barwrap">
          <div class="barrow">
            <div class="lbl">q∞ (Dynamic Pressure) Constraint</div>
            <div class="val">Recommended: 0.5–6.0 kPa (hypersonic cruise proxy)</div>
          </div>
          <div class="bar"><div id="barQ" class="fill"></div></div>
          <div class="hint">Too low → control authority weak; too high → aero heating & structure risk (stability drops).</div>
        </div>

      </div>
    </section>

    <!-- RIGHT: Thermal + Log -->
    <section class="card">
      <div class="hd">
        <h2>Thermal Control + Live Event Log</h2>
        <div class="chip">PI + Feedforward</div>
      </div>
      <div class="body">
        <div class="two">
          <div class="kv">
            <div class="k">Skin Temp <small>Heating − Cooling</small></div>
            <div class="v"><div class="big"><span id="tempNow">124.6</span> °C</div><div class="sm">Target 205±5 °C</div></div>
          </div>
          <div class="kv">
            <div class="k">Coolant Flow <small>Controller output</small></div>
            <div class="v"><div class="big"><span id="flowNow">0.20</span> kg/s</div><div class="sm">Limits 0.20–1.20</div></div>
          </div>
        </div>

        <div class="barwrap">
          <div class="barrow">
            <div class="lbl">Thermal Deviation</div>
            <div class="val">|T − 205| mapped to bar</div>
          </div>
          <div class="bar"><div id="barTherm" class="fill"></div></div>
          <div class="hint">Thermal deviation directly reduces stability health when outside the 205±5 °C window.</div>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button id="btnInject" title="Adds a short disturbance that may trigger instability">Inject Disturbance</button>
          <button id="btnClearLog" title="Clears the event log (does not reset the sim)">Clear Log</button>
        </div>

        <div class="footerNote">Live Event Log (includes takeoff speed, cruise speed, landing speed from 0 → Mach 10 → 0)</div>
        <div id="log" class="log" aria-live="polite"></div>
      </div>
    </section>
  </div>
</main>

<script>
(() => {
  // ---------------------------
  // ROUTES (choose 1 of 5)
  // ---------------------------
  const ROUTES = [
    { name: "Dallas, TX (USA) → Tokyo (Japan)",   a:{lat:32.7767, lon:-96.7970}, b:{lat:35.6762, lon:139.6503} },
    { name: "Los Angeles, CA (USA) → Sydney (Australia)", a:{lat:34.0522, lon:-118.2437}, b:{lat:-33.8688, lon:151.2093} },
    { name: "New York, NY (USA) → London (UK)",  a:{lat:40.7128, lon:-74.0060}, b:{lat:51.5074, lon:-0.1278} },
    { name: "Mexico City (MX) → Paris (France)", a:{lat:19.4326, lon:-99.1332}, b:{lat:48.8566, lon:2.3522} },
    { name: "Dubai (UAE) → Singapore",           a:{lat:25.2048, lon:55.2708},  b:{lat:1.3521,  lon:103.8198} }
  ];

  // ---------------------------
  // UI refs
  // ---------------------------
  const $ = (id) => document.getElementById(id);

  const routeSel = $("routeSel");
  const btnStart = $("btnStart");
  const btnStop  = $("btnStop");
  const btnReset = $("btnReset");
  const autoHold = $("autoHold");
  const chipStable = $("chipStable");

  const phaseTxt = $("phaseTxt");
  const routeTxt = $("routeTxt");

  const machNow = $("machNow");
  const machTgt = $("machTgt");
  const vNow = $("vNow");

  const altNow = $("altNow");
  const rhoNow = $("rhoNow");

  const qNow = $("qNow");
  const thrustNow = $("thrustNow");
  const dragNow = $("dragNow");
  const marginNow = $("marginNow");
  const tdNow = $("tdNow");

  const piNow = $("piNow");
  const cdaNow = $("cdaNow");

  const healthNow = $("healthNow");
  const msNow = $("msNow");
  const lastStableMachEl = $("lastStableMach");

  const tempNow = $("tempNow");
  const flowNow = $("flowNow");

  const barHealth = $("barHealth");
  const barQ = $("barQ");
  const barTherm = $("barTherm");

  const logEl = $("log");
  const btnInject = $("btnInject");
  const btnClearLog = $("btnClearLog");

  // ---------------------------
  // helpers / math
  // ---------------------------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const lerp  = (a, b, t) => a + (b - a) * t;

  function haversineKm(lat1, lon1, lat2, lon2){
    const R = 6371;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
    const a = s1*s1 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*s2*s2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }

  // ISA-like density proxy (simple & stable):
  function densityAtAlt(alt_m){
    // smooth exponential fits: sea level 1.225, ~30km ~0.018
    const rho0 = 1.225;
    const H = 7800; // scale height (m)
    return rho0 * Math.exp(-alt_m / H);
  }

  // speed of sound proxy vs altitude (m/s): ~340 at sea level, ~295 at 30km
  function aSoundAtAlt(alt_m){
    const a0 = 340;
    const a30 = 295;
    const t = clamp(alt_m / 30000, 0, 1);
    return lerp(a0, a30, t);
  }

  // inlet proxy Π (0..1): worse at very high Mach & high q, better in cruise band
  function inletProxy(mach, q_kpa){
    // base falls with Mach beyond 6, and with q beyond 6 kPa
    const machPenalty = clamp((mach - 6) / 6, 0, 1); // 0 at <=6, 1 at 12
    const qPenalty = clamp((q_kpa - 6) / 8, 0, 1);   // 0 at <=6kPa
    const goodBand = 1 - 0.55*machPenalty - 0.35*qPenalty;
    // keep it realistic-ish and never exactly 0
    return clamp(goodBand, 0.20, 0.95);
  }

  // ---------------------------
  // route selector init
  // ---------------------------
  ROUTES.forEach((r, i) => {
    const opt = document.createElement("option");
    opt.value = String(i);
    const dist = haversineKm(r.a.lat, r.a.lon, r.b.lat, r.b.lon);
    opt.textContent = `${r.name}  •  ${dist.toFixed(0)} km`;
    routeSel.appendChild(opt);
  });

  // ---------------------------
  // SIM state
  // ---------------------------
  const state = {
    running: false,
    t: 0,                // sim time (s)
    dt: 1/30,            // step (s)
    routeIdx: 0,

    // kinematics
    phase: "READY",      // READY, TAKEOFF, CLIMB, CRUISE, DESCENT, LANDING, DONE
    distKm: 0,
    distTotalKm: haversineKm(ROUTES[0].a.lat, ROUTES[0].a.lon, ROUTES[0].b.lat, ROUTES[0].b.lon),

    alt_m: 0,
    mach: 0,
    machTarget: 0,

    // propulsion/aero
    CdA: 0.85,           // m^2 (proxy)
    thrustBase_kN: 20.0, // kN (your number)
    thrust_kN: 0,
    drag_kN: 0,
    q_kpa: 0.1,
    pi: 0.65,

    // stability
    health: 0.42,
    lastStableMach: 0.00,
    disturbance: 0,      // injected transient

    // thermal
    tempC: 124.6,
    tempTarget: 205,
    tempBand: 5,
    flow: 0.20,          // kg/s (your minimum)
    flowMin: 0.20,
    flowMax: 1.20,

    // PI controller
    Kp: 0.060,
    Ki: 0.010,
    integ: 0,

    // event flags
    loggedTakeoff: false,
    loggedCruise: false,
    loggedLanding: false,
    lastPhase: "READY",
    lastStableLoggedAt: -999,
    lastAutoDropAt: -999,
  };

  function setRoute(idx){
    state.routeIdx = idx;
    const r = ROUTES[idx];
    state.distTotalKm = haversineKm(r.a.lat, r.a.lon, r.b.lat, r.b.lon);
    routeTxt.textContent = `${r.name} • ${state.distTotalKm.toFixed(0)} km`;
    logLine("t", `ROUTE selected: ${r.name} (${state.distTotalKm.toFixed(0)} km)`);
  }

  routeSel.addEventListener("change", () => {
    setRoute(Number(routeSel.value));
    // keep sim consistent: reset distance and phase if not running
    if(!state.running){
      state.distKm = 0;
      state.phase = "READY";
      state.lastPhase = "READY";
      draw();
    }
  });

  // ---------------------------
  // logging
  // ---------------------------
  function ts(){
    const m = Math.floor(state.t/60);
    const s = Math.floor(state.t%60);
    return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }
  function logLine(kind, msg){
    const div = document.createElement("div");
    div.className = "line " + (kind || "");
    div.textContent = `[${ts()}] ${msg}`;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ---------------------------
  // Phase schedule (simple but complete)
  // ---------------------------
  function phaseTargets(){
    // returns {altTarget_m, machTarget, accelLimit, climbRate}
    // accelLimit affects how quickly Mach follows target
    switch(state.phase){
      case "TAKEOFF":
        return { altTarget_m: 2000,  machTarget: 0.85, accelLimit: 0.20, climbRate: 35 };
      case "CLIMB":
        return { altTarget_m: 30000, machTarget: 3.00, accelLimit: 0.18, climbRate: 120 };
      case "CRUISE":
        return { altTarget_m: 30000, machTarget: 10.0, accelLimit: 0.12, climbRate: 10 };
      case "DESCENT":
        return { altTarget_m: 3000,  machTarget: 1.20, accelLimit: 0.16, climbRate: -140 };
      case "LANDING":
        return { altTarget_m: 0,     machTarget: 0.00, accelLimit: 0.20, climbRate: -40 };
      default:
        return { altTarget_m: 0,     machTarget: 0.00, accelLimit: 0.20, climbRate: 0 };
    }
  }

  function updatePhase(){
    // compute completion vs distance to move through phases.
    const frac = state.distKm / Math.max(1, state.distTotalKm);
    // keep it stable and predictable:
    if(state.phase === "READY") return;
    if(frac < 0.03) state.phase = "TAKEOFF";
    else if(frac < 0.12) state.phase = "CLIMB";
    else if(frac < 0.88) state.phase = "CRUISE";
    else if(frac < 0.96) state.phase = "DESCENT";
    else if(frac < 1.00) state.phase = "LANDING";
    else state.phase = "DONE";
  }

  // ---------------------------
  // Physics + Controllers
  // ---------------------------
  function step(){
    const dt = state.dt;
    state.t += dt;

    // decay disturbance
    state.disturbance = lerp(state.disturbance, 0, clamp(dt*0.9, 0, 1));

    // phase progression
    updatePhase();

    // phase change log
    if(state.phase !== state.lastPhase){
      logLine("t", `PHASE → ${state.phase}`);
      state.lastPhase = state.phase;

      // reset phase speed logs at appropriate times
      if(state.phase === "TAKEOFF"){ state.loggedTakeoff = false; }
      if(state.phase === "CRUISE"){ state.loggedCruise = false; }
      if(state.phase === "LANDING"){ state.loggedLanding = false; }
    }

    const tgt = phaseTargets();

    // altitude dynamics
    // move toward altitude target with a bounded climb rate.
    const altErr = tgt.altTarget_m - state.alt_m;
    const climb = clamp(altErr, -800, 800); // limit per tick before rate
    state.alt_m += clamp(climb, -Math.abs(tgt.climbRate)*dt*20, Math.abs(tgt.climbRate)*dt*20);
    state.alt_m = clamp(state.alt_m, 0, 35000);

    // atmosphere
    const rho = densityAtAlt(state.alt_m);
    const a = aSoundAtAlt(state.alt_m);
    const V = state.mach * a;

    // distance traveled (km)
    const groundSpeed = V; // proxy
    state.distKm += (groundSpeed * dt) / 1000;
    state.distKm = clamp(state.distKm, 0, state.distTotalKm);

    // compute dynamic pressure & inlet proxy
    const q_pa = 0.5 * rho * V * V;
    state.q_kpa = clamp(q_pa / 1000, 0, 999);
    state.pi = inletProxy(state.mach, state.q_kpa);

    // Drag (kN)
    // add mild Mach wave drag rise after Mach 2
    const waveRise = 1 + 0.12 * clamp(state.mach - 2, 0, 12);
    const D_N = 0.5 * rho * V*V * state.CdA * waveRise;
    state.drag_kN = clamp(D_N / 1000, 0, 9999);

    // Thrust Available (kN)
    // base thrust scaled by inlet Π, throttle proxy, and density (less oxygen at altitude)
    const densityScale = clamp(0.65 + 0.35 * (rho / 1.225), 0.55, 1.00);
    const throttle = 0.55 + 0.45 * clamp(state.machTarget / 10, 0, 1);
    const thrust = state.thrustBase_kN * state.pi * densityScale * throttle;

    // small random-ish ripple + disturbance
    const ripple = 0.4 * Math.sin(state.t*1.3) + 0.25 * Math.sin(state.t*0.37);
    state.thrust_kN = clamp(thrust + ripple + state.disturbance, 0, 999);

    // Thermal model
    // heating grows with q and Mach; cooling with flow and error sign
    const heat = (0.06 * state.q_kpa) * (1 + 0.22*state.mach*state.mach); // °C/s proxy
    const cool = 0.85 * state.flow * (state.tempC - state.tempTarget) / 60; // °C/s proxy
    state.tempC += (heat - cool) * dt;

    // PI + feedforward for coolant flow
    const e = (state.tempTarget - state.tempC); // positive when too cold
    state.integ += e * dt;
    // feedforward: more heat -> more flow
    const ff = clamp(0.20 + 0.06 * state.q_kpa + 0.02 * state.mach, 0.20, 1.20);
    const u = ff + state.Kp * (-e) + state.Ki * (-state.integ); // drive flow up when temp > target
    state.flow = clamp(u, state.flowMin, state.flowMax);

    // Stability Health (0..1)
    // components:
    const margin = state.thrust_kN - state.drag_kN; // kN
    const marginGood = clamp((margin + 2) / 10, 0, 1); // good when margin is comfortably positive
    const qBandGood = (() => {
      // best between 0.5 and 6 kPa; penalize outside
      const q = state.q_kpa;
      if(q < 0.5) return clamp(q/0.5, 0, 1);
      if(q <= 6.0) return 1;
      return clamp(1 - (q - 6.0)/8.0, 0, 1);
    })();
    const inletGood = clamp((state.pi - 0.20) / 0.75, 0, 1);
    const thermDev = Math.abs(state.tempC - state.tempTarget);
    const thermGood = clamp(1 - Math.max(0, (thermDev - state.tempBand) / 40), 0, 1);

    // mild Mach penalty outside target regimes (especially low altitude)
    const altFactor = clamp(state.alt_m / 30000, 0, 1);
    const machPenalty = clamp((state.mach - 10) / 6, 0, 1) * 0.2 + clamp((10 - state.mach)/10,0,1) * 0.05;
    const disturbancePenalty = clamp(Math.abs(state.disturbance)/3, 0, 0.35);

    // weighted health
    let health = 0.36*marginGood + 0.28*qBandGood + 0.22*inletGood + 0.14*thermGood;
    health *= (1 - 0.10*machPenalty*(1-altFactor));
    health -= disturbancePenalty;

    // soften oscillations
    state.health = clamp(lerp(state.health, health, clamp(dt*3.5, 0, 1)), 0, 1);

    // Ms shown as centered margin metric (-1..+1)
    const Ms = clamp((state.health - 0.5) * 2, -1, 1);

    // AUTOPILOT target Mach:
    // - phase target sets baseline
    // - in CRUISE: aims 10
    // - if unstable: drop to last stable Mach
    const wantsAuto = autoHold.checked;

    if(state.phase !== "DONE" && state.phase !== "READY"){
      if(wantsAuto){
        state.machTarget = tgt.machTarget;
      }else{
        // if autopilot disabled, still follow phase schedule gently
        state.machTarget = tgt.machTarget;
      }

      // last stable Mach tracking (only meaningful in CRUISE)
      const stable = state.health >= 0.70;
      if(state.phase === "CRUISE" && stable){
        // update last stable mach but not too frequently
        if(state.t - state.lastStableLoggedAt > 2.0){
          state.lastStableMach = Math.max(state.lastStableMach, state.mach);
          state.lastStableLoggedAt = state.t;
        }
      }

      // Stability hold fallback
      if(wantsAuto && state.phase === "CRUISE" && !stable){
        const fallback = clamp(Math.max(0.8, state.lastStableMach || 0.8), 0.8, 10.0);
        // if already failing often, step down a bit more
        const stepped = clamp(fallback - 0.35, 0.8, 10.0);
        if(state.t - state.lastAutoDropAt > 1.25){
          state.machTarget = Math.min(state.machTarget, stepped);
          logLine("e", `UNSTABLE → reducing to last stable Mach (target now ${state.machTarget.toFixed(2)} M)`);
          state.lastAutoDropAt = state.t;
        } else {
          state.machTarget = Math.min(state.machTarget, stepped);
        }
      }

      // Mach dynamics toward target
      const dM = state.machTarget - state.mach;
      const maxStep = tgt.accelLimit * dt; // Mach per tick
      state.mach += clamp(dM, -maxStep, +maxStep);
      state.mach = clamp(state.mach, 0, 12.0);
    }

    // event log requirements: takeoff speed, cruise speed, landing speed
    if(state.phase === "TAKEOFF" && !state.loggedTakeoff && state.mach >= 0.30){
      state.loggedTakeoff = true;
      logLine("t", `TAKEOFF speed reached: ${state.mach.toFixed(2)} M (${Math.round(V)} m/s)`);
    }
    if(state.phase === "CRUISE" && !state.loggedCruise && state.mach >= 9.75){
      state.loggedCruise = true;
      logLine("t", `CRUISE speed achieved: ${state.mach.toFixed(2)} M (${Math.round(V)} m/s)`);
    }
    if(state.phase === "LANDING" && !state.loggedLanding && state.mach <= 0.20){
      state.loggedLanding = true;
      logLine("t", `LANDING rollout: ${state.mach.toFixed(2)} M (${Math.round(V)} m/s)`);
    }

    // DONE log
    if(state.phase === "DONE"){
      state.machTarget = 0;
      state.mach = lerp(state.mach, 0, clamp(dt*3, 0, 1));
      if(state.mach < 0.01){
        state.mach = 0;
        state.running = false;
        logLine("t", "TRIP complete (0 → Mach 10 → 0).");
      }
    }

    // store computed Ms for display
    state._Ms = Ms;
    state._rho = rho;
    state._a = a;
    state._V = V;
    state._margin = (state.thrust_kN - state.drag_kN);
  }

  // ---------------------------
  // UI draw
  // ---------------------------
  function setFill(el, pct, kind){
    el.style.width = `${clamp(pct,0,100).toFixed(1)}%`;
    el.classList.remove("good","warn","bad");
    if(kind) el.classList.add(kind);
  }

  function draw(){
    // phase + route
    phaseTxt.textContent = state.phase;
    const r = ROUTES[state.routeIdx];
    routeTxt.textContent = `${r.name} • ${state.distKm.toFixed(0)} / ${state.distTotalKm.toFixed(0)} km`;

    // speed
    machNow.textContent = state.mach.toFixed(2);
    machTgt.textContent = state.machTarget.toFixed(2);
    vNow.textContent = Math.round(state._V || 0).toString();

    // altitude + rho
    altNow.textContent = (state.alt_m/1000).toFixed(1);
    rhoNow.textContent = (state._rho ?? 1.225).toFixed(3);

    // q, thrust, drag, margin
    qNow.textContent = (state.q_kpa).toFixed(1);
    thrustNow.textContent = (state.thrust_kN).toFixed(1);
    dragNow.textContent = (state.drag_kN).toFixed(1);

    const margin = state._margin || 0;
    marginNow.textContent = `${margin >= 0 ? "+" : ""}${margin.toFixed(1)}`;
    tdNow.textContent = `${margin >= 0 ? "+" : ""}${margin.toFixed(1)} kN`;

    // inlet + CdA
    piNow.textContent = state.pi.toFixed(2);
    cdaNow.textContent = state.CdA.toFixed(2);

    // stability
    healthNow.textContent = state.health.toFixed(2);
    msNow.textContent = (state._Ms ?? 0).toFixed(2);
    lastStableMachEl.textContent = state.lastStableMach.toFixed(2);

    const stable = state.health >= 0.70;
    chipStable.textContent = `Status: ${stable ? "STABLE" : "UNSTABLE"}`;
    chipStable.classList.remove("good","bad");
    chipStable.classList.add(stable ? "good" : "bad");

    // health bar
    const hPct = state.health * 100;
    setFill(barHealth, hPct, stable ? "good" : (state.health >= 0.55 ? "warn" : "bad"));

    // q bar: map 0..10 kPa to 0..100
    const qPct = clamp((state.q_kpa/10)*100, 0, 100);
    let qKind = "good";
    if(state.q_kpa < 0.5) qKind = "warn";
    if(state.q_kpa > 6.0) qKind = "bad";
    setFill(barQ, qPct, qKind);

    // thermal
    tempNow.textContent = state.tempC.toFixed(1);
    flowNow.textContent = state.flow.toFixed(2);

    const dev = Math.abs(state.tempC - state.tempTarget);
    const devPct = clamp((dev/50)*100, 0, 100);
    let tKind = "good";
    if(dev > state.tempBand) tKind = "warn";
    if(dev > (state.tempBand + 15)) tKind = "bad";
    setFill(barTherm, devPct, tKind);
  }

  // ---------------------------
  // loop
  // ---------------------------
  let raf = null;
  function tick(){
    if(!state.running){ raf = null; return; }
    // run multiple substeps for stability if needed
    for(let i=0;i<1;i++) step();
    draw();
    raf = requestAnimationFrame(tick);
  }

  // ---------------------------
  // controls
  // ---------------------------
  function hardReset(){
    const keepRoute = state.routeIdx;

    state.running = false;
    state.t = 0;
    state.phase = "READY";
    state.lastPhase = "READY";
    state.distKm = 0;

    state.alt_m = 0;
    state.mach = 0;
    state.machTarget = 0;

    state.CdA = 0.85;
    state.thrustBase_kN = 20.0;
    state.thrust_kN = 0;
    state.drag_kN = 0;
    state.q_kpa = 0.1;
    state.pi = 0.65;

    state.health = 0.42;
    state.lastStableMach = 0.00;
    state.disturbance = 0;

    state.tempC = 124.6;
    state.flow = 0.20;
    state.integ = 0;

    state.loggedTakeoff = false;
    state.loggedCruise = false;
    state.loggedLanding = false;
    state.lastStableLoggedAt = -999;
    state.lastAutoDropAt = -999;

    // derived
    state._rho = 1.225;
    state._a = 340;
    state._V = 0;
    state._margin = 0;
    state._Ms = 0;

    // restore route (and recalc distance)
    setRoute(keepRoute);

    // clear log and add a header
    logEl.innerHTML = "";
    logLine("t", "RESET complete. Ready for 0 → Mach 10 → 0.");
    draw();
  }

  btnStart.addEventListener("click", () => {
    if(state.running) return;

    if(state.phase === "READY"){
      state.phase = "TAKEOFF";
      state.lastPhase = "READY";
      // on start, set initial targets
      state.machTarget = 0.85;
      logLine("t", "START: Beginning takeoff roll (0 → Mach 10 → 0).");
    } else if(state.phase === "DONE"){
      hardReset();
      state.phase = "TAKEOFF";
      logLine("t", "START: Restarting trip.");
    } else {
      logLine("t", "START: Resuming.");
    }

    state.running = true;
    if(!raf) raf = requestAnimationFrame(tick);
  });

  btnStop.addEventListener("click", () => {
    if(!state.running) return;
    state.running = false;
    logLine("w", "STOP: Simulation paused.");
  });

  btnReset.addEventListener("click", () => hardReset());

  btnInject.addEventListener("click", () => {
    // disturbance in kN equivalent affecting thrust
    state.disturbance += (Math.random() < 0.5 ? -1 : 1) * (1.8 + 1.7*Math.random());
    logLine("w", `Disturbance injected (engine/flow transient).`);
  });

  btnClearLog.addEventListener("click", () => {
    logEl.innerHTML = "";
    logLine("t", "Log cleared.");
  });

  // ---------------------------
  // initial boot
  // ---------------------------
  setRoute(0);
  hardReset(); // sets initial log + draw
  routeSel.value = "0";
})();
</script>
</body>
</html>
