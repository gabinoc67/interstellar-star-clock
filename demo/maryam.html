<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mirzakhani Geometry Lab v2 — Drawings • Animation • CST vs Local Clocks • Einstein Tension Panel</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1a30;
    --panel2:#0c1528;
    --line:#213659;
    --ink:#eaf0ff;
    --muted:#a9b6df;
    --brand:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --shadow: 0 14px 40px rgba(0,0,0,.35);
    --radius: 14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui, Segoe UI, Arial, sans-serif;
    background: radial-gradient(circle at 15% 0%, #13224a 0, var(--bg) 55%, #070b14 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: linear-gradient(90deg, rgba(88,166,255,.10), rgba(53,208,127,.06));
  }
  header h1{margin:0;font-size:18px;letter-spacing:.2px}
  header .sub{margin-top:6px;color:var(--muted);font-size:13px;line-height:1.35}
  .wrap{
    height:calc(100% - 74px);
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:12px;
    padding:12px;
  }
  .panel{
    background: linear-gradient(180deg, rgba(15,26,48,.95), rgba(10,18,35,.95));
    border:1px solid rgba(255,255,255,.08);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .panel .inner{padding:12px}
  .panel h2{
    margin:0 0 10px;
    font-size:14px;
    color:#dbe7ff;
    letter-spacing:.2px;
  }
  .row{display:flex;gap:10px;align-items:center}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px}
  select,input[type="range"],button{
    width:100%;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(8,14,28,.65);
    color: var(--ink);
    outline:none;
  }
  input[type="range"]{padding:0;height:32px}
  button{
    cursor:pointer;
    background: linear-gradient(180deg, rgba(88,166,255,.20), rgba(88,166,255,.10));
    transition: transform .06s ease;
  }
  button:hover{transform: translateY(-1px)}
  .btnRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px}
  .btnRow2{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .pill{
    display:inline-flex;gap:8px;align-items:center;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    color: var(--muted);
    font-size:12px;
  }
  .kpi{
    display:grid;grid-template-columns:1fr 1fr;gap:10px;
    margin-top:10px;
  }
  .kpi .card{
    padding:10px;border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
  }
  .kpi .card .t{font-size:11px;color:var(--muted)}
  .kpi .card .v{margin-top:6px;font-family:var(--mono);font-size:12px;color:#eaf0ff}
  .note{
    margin-top:10px;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    color: var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .eq{
    font-family:var(--mono);
    font-size:12px;
    background: rgba(0,0,0,.22);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    overflow:auto;
  }
  .right{
    display:grid;
    grid-template-rows: 1fr 330px;
    gap:12px;
  }
  .topGrid{
    height:100%;
    display:grid;
    grid-template-columns: 1.25fr 0.75fr;
    gap:12px;
    padding:12px;
  }
  .canvasPanel{padding:0}
  canvas{
    width:100%;height:100%;
    display:block;
    background: radial-gradient(circle at 30% 10%, rgba(88,166,255,.12), rgba(0,0,0,.18) 55%, rgba(0,0,0,.28) 100%);
    border-radius: var(--radius);
  }
  .canvasWrap{position:relative;padding:12px}
  .overlay{
    position:absolute;left:24px;top:22px;right:24px;
    display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;
    pointer-events:none;
  }
  .badge{
    pointer-events:none;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.35);
    color:#dbe7ff;
    font-size:12px;
  }
  .legend{
    display:flex;gap:8px;flex-wrap:wrap;
  }
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.blue{background:var(--brand)}
  .dot.green{background:var(--good)}
  .dot.yellow{background:var(--warn)}
  .dot.red{background:var(--bad)}
  .infoGrid{
    height:100%;
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    padding:12px;
  }
  .infoBox{
    border-radius: var(--radius);
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    padding:10px;
    overflow:auto;
  }
  .infoBox h3{margin:0 0 8px;font-size:13px;color:#dbe7ff}
  .infoBox p{margin:0 0 8px;color:var(--muted);font-size:12px;line-height:1.35}
  .small{font-size:11px;color:var(--muted)}
  .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0}
  .toggle{
    display:flex;gap:10px;align-items:center;margin-top:8px;
    padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
  }
  .toggle input{width:auto;height:auto;margin:0;transform:scale(1.15)}
  .mini{
    display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;
  }
  .mini .box{
    border-radius:12px;border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    padding:10px;
  }
  .mini .box .h{font-size:12px;color:#dbe7ff;margin-bottom:6px}
  .mini .box .m{font-family:var(--mono);font-size:12px;color:#eaf0ff}
  .bar{
    height:10px;border-radius:999px;overflow:hidden;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.10);
    margin-top:8px;
  }
  .bar > div{height:100%}
</style>

<!-- Optional MathJax for equations; simulation works without it -->
<script>
  window.MathJax = {tex:{inlineMath:[['\\(','\\)'],['$','$']]}, svg:{fontCache:'global'}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
<header>
  <h1>Mirzakhani Geometry Lab v2 — Select Drawings • Animate • Print Report • CST vs Local Clocks • Einstein Tension</h1>
  <div class="sub">
    We are building a <b>visual learning simulator</b> of Mirzakhani’s main method:
    <span class="pill">encode deformation by parameters (lengths + twists)</span> →
    <span class="pill">use a global measure/“volume” over all shapes</span> →
    <span class="pill">get predictable statistics (counts/distributions) even if local paths look chaotic</span>.
  </div>
</header>

<div class="wrap">
  <!-- LEFT CONTROL PANEL -->
  <div class="panel">
    <div class="inner">
      <h2>1) Select a Mirzakhani-style drawing / concept</h2>
      <label>Drawing / Concept Selector</label>
      <select id="mode">
        <option value="disk">Hyperbolic Disk + Geodesics (chaos → countable order)</option>
        <option value="pants">Pair-of-Pants Decomposition (cut/glue, encode by lengths & twists)</option>
        <option value="sixholo">6-Parameter “Hexagon in Circle” (your hologram control intuition)</option>
        <option value="moduli">Moduli “Volume” Sampling (global measure over all shapes)</option>
        <option value="count">Counting Law Demo (N(L) growth intuition)</option>
        <option value="einstein">Einstein Tension Panel (local metric vs global invariant measure)</option>
      </select>

      <div class="kpi">
        <div class="card">
          <div class="t">Current parameter state</div>
          <div class="v" id="kParam">—</div>
        </div>
        <div class="card">
          <div class="t">Order-from-chaos signals</div>
          <div class="v" id="kSignal">—</div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>2) Animation controls</h2>
      <div class="btnRow">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnStep">Step</button>
      </div>
      <div class="btnRow2">
        <button id="btnRandom">Randomize shape (sample “moduli”)</button>
        <button id="btnReset">Reset</button>
      </div>

      <label>Animation speed</label>
      <input id="speed" type="range" min="0" max="2.5" step="0.01" value="1.0">

      <div class="hr"></div>

      <h2>3) Fenchel–Nielsen style knobs (lengths + twists)</h2>
      <label>Length L₁</label>
      <input id="L1" type="range" min="0.2" max="3.0" step="0.01" value="1.20">
      <label>Length L₂</label>
      <input id="L2" type="range" min="0.2" max="3.0" step="0.01" value="1.60">
      <label>Length L₃</label>
      <input id="L3" type="range" min="0.2" max="3.0" step="0.01" value="1.00">

      <label>Twist τ₁</label>
      <input id="T1" type="range" min="-3.14" max="3.14" step="0.01" value="0.60">
      <label>Twist τ₂</label>
      <input id="T2" type="range" min="-3.14" max="3.14" step="0.01" value="-0.80">
      <label>Twist τ₃</label>
      <input id="T3" type="range" min="-3.14" max="3.14" step="0.01" value="1.20">

      <label>Geodesic cutoff length L (for counting demo)</label>
      <input id="Lc" type="range" min="1" max="25" step="1" value="12">

      <div class="toggle">
        <input id="cstToggle" type="checkbox" />
        <div>
          <div style="color:#dbe7ff;font-size:12px;margin-bottom:3px"><b>CST toggle</b> (show Local Clocks vs Global Invariant Measure)</div>
          <div class="small">When ON, the bottom panel shows <i>side-by-side</i> “local clock drift” vs “global measure stability”.</div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>4) Print / Save report</h2>
      <button id="btnReport">Print / Save Report (opens print dialog)</button>

      <div class="note" id="quickExplain">
        <b>Mirzakhani “permission rule” (the point of this simulator):</b><br>
        If a system’s deformations can be <b>parameterized coherently</b>, then <b>order exists at the statistical/volumetric level</b>,
        even when local behavior looks chaotic. That’s the math intuition behind robust navigation through distortion.
      </div>

      <div class="hr"></div>

      <h2>5) Equations (conceptual)</h2>
      <div class="eq" id="eqBox">Loading…</div>
    </div>
  </div>

  <!-- RIGHT SIDE -->
  <div class="right">
    <!-- TOP: Canvas + Quick legend panel -->
    <div class="panel">
      <div class="topGrid">
        <div class="canvasWrap">
          <canvas id="cv"></canvas>
          <div class="overlay">
            <div class="badge" id="titleBadge">—</div>
            <div class="legend badge">
              <span class="row" style="gap:6px"><span class="dot blue"></span><span>frame / boundary</span></span>
              <span class="row" style="gap:6px"><span class="dot green"></span><span>geodesics / seams</span></span>
              <span class="row" style="gap:6px"><span class="dot yellow"></span><span>twist signal</span></span>
              <span class="row" style="gap:6px"><span class="dot red"></span><span>pinch / degeneration</span></span>
            </div>
          </div>
        </div>

        <div class="panel inner" style="margin:12px">
          <h2>What we’re doing (fast)</h2>
          <div class="note" id="fastPanel" style="margin-top:0">
            <b>Step 1:</b> Pick a drawing (disk, pants, hexagon-in-circle, moduli sampling, counting, Einstein tension).<br>
            <b>Step 2:</b> Change lengths/twists (the deformation “knobs”).<br>
            <b>Step 3:</b> Watch how local complexity changes, but global “measure/volume” and statistics remain stable/meaningful.<br><br>
            <b>Why this matters to CST navigation:</b> you don’t navigate by fighting local distortions; you navigate using a stable global measure that remains meaningful under deformation.
          </div>

          <div class="mini" id="cstMini" style="display:none">
            <div class="box">
              <div class="h">Local clocks (Einstein/GR side)</div>
              <div class="m" id="localClock">—</div>
              <div class="bar"><div id="localBar" style="width:0%; background: rgba(255,90,102,.85)"></div></div>
              <div class="small" style="margin-top:8px">Shows drift/instability when distortion is high (pinch + twist turbulence).</div>
            </div>
            <div class="box">
              <div class="h">Global invariant measure (Mirzakhani side)</div>
              <div class="m" id="globalMeasure">—</div>
              <div class="bar"><div id="globalBar" style="width:0%; background: rgba(53,208,127,.85)"></div></div>
              <div class="small" style="margin-top:8px">Shows stable “navigation handle” via parameter-space measure/volume.</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- BOTTOM: Info panels -->
    <div class="panel">
      <div class="infoGrid">
        <div class="infoBox">
          <h3>Drawing meaning</h3>
          <div id="infoMeaning"></div>
        </div>
        <div class="infoBox">
          <h3>What Mirzakhani figured out (and why it matters)</h3>
          <div id="infoFindings"></div>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* =========================================================
   Mirzakhani Geometry Lab v2 (Concept Simulator)
   Added:
   - Start/Pause/Step animation loop
   - Print/Save report
   - CST toggle: Local clocks vs Global measure side-by-side
   - Einstein Tension drawing mode
========================================================= */

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const ui = {
  mode: document.getElementById('mode'),
  L1: document.getElementById('L1'),
  L2: document.getElementById('L2'),
  L3: document.getElementById('L3'),
  T1: document.getElementById('T1'),
  T2: document.getElementById('T2'),
  T3: document.getElementById('T3'),
  Lc: document.getElementById('Lc'),
  speed: document.getElementById('speed'),
  cstToggle: document.getElementById('cstToggle'),

  btnStart: document.getElementById('btnStart'),
  btnPause: document.getElementById('btnPause'),
  btnStep: document.getElementById('btnStep'),
  btnRandom: document.getElementById('btnRandom'),
  btnReset: document.getElementById('btnReset'),
  btnReport: document.getElementById('btnReport'),

  eqBox: document.getElementById('eqBox'),
  titleBadge: document.getElementById('titleBadge'),
  infoMeaning: document.getElementById('infoMeaning'),
  infoFindings: document.getElementById('infoFindings'),
  kParam: document.getElementById('kParam'),
  kSignal: document.getElementById('kSignal'),

  cstMini: document.getElementById('cstMini'),
  localClock: document.getElementById('localClock'),
  globalMeasure: document.getElementById('globalMeasure'),
  localBar: document.getElementById('localBar'),
  globalBar: document.getElementById('globalBar')
};

function resize(){
  const r = cv.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width = Math.floor(r.width * dpr);
  cv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function readParams(){
  const L1 = +ui.L1.value, L2 = +ui.L2.value, L3 = +ui.L3.value;
  const T1 = +ui.T1.value, T2 = +ui.T2.value, T3 = +ui.T3.value;
  const Lc = +ui.Lc.value;
  const spd = +ui.speed.value;
  return {L1,L2,L3,T1,T2,T3,Lc, spd};
}

// Degeneration/pinch heuristic: very small lengths imply near-degenerate seams
function degenerationScore(p){
  const m = Math.min(p.L1, p.L2, p.L3);
  return clamp((0.6 - m)/0.6, 0, 1);
}

// Toy “global measure weight” heuristic (stand-in for a true moduli measure)
function pseudoMeasureWeight(p){
  const len = (p.L1+p.L2+p.L3)/3;
  const twist = (Math.cos(p.T1)+Math.cos(p.T2)+Math.cos(p.T3))/3;
  return clamp( (0.9*Math.exp(-Math.abs(len-1.5)) + 0.1*(twist+1)/2 ), 0, 1);
}

// Counting law demo: toy growth ~ exp(L/6)/L
function N_of_L(L){ return Math.exp(L/6) / Math.max(1, L/2); }
function N_modulated(p){
  const base = N_of_L(p.Lc);
  const mod = 0.65 + 0.18*(p.L1+p.L2+p.L3)/3 + 0.06*(Math.sin(p.T1)+Math.sin(p.T2)+Math.sin(p.T3));
  return Math.max(0, base*mod);
}

/* ---------------- Drawing helpers ---------------- */
function clear(){
  const w = cv.getBoundingClientRect().width;
  const h = cv.getBoundingClientRect().height;
  ctx.clearRect(0,0,w,h);
}

function setStroke(color, width=2, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}

function setFill(color, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
}

function drawCircle(x,y,r,stroke='rgba(88,166,255,.9)', width=2, alpha=1){
  setStroke(stroke, width, alpha);
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
}

function drawText(txt, x,y, color='rgba(234,240,255,.9)', size=12, align='left'){
  ctx.globalAlpha = 1;
  ctx.fillStyle = color;
  ctx.font = `${size}px ${getComputedStyle(document.body).fontFamily}`;
  ctx.textAlign = align;
  ctx.fillText(txt, x,y);
}

// Geodesic-like curve in disk model (visual approximation)
function drawDiskGeodesic(cx,cy,R, a1, a2, wobble=0, phase=0){
  const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
  const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);

  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  const nx = (midx - cx), ny = (midy - cy);
  const nlen = Math.hypot(nx,ny) || 1;

  const k = 0.45 + 0.20*wobble + 0.08*Math.sin(phase + a1*1.7);
  const cx1 = midx + k*(nx/nlen)*R*0.35;
  const cy1 = midy + k*(ny/nlen)*R*0.35;

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.quadraticCurveTo(cx1,cy1,x2,y2);
  ctx.stroke();
}

// Pants decomposition: three boundaries, seams, twist arrows
function drawPants(x,y,scale,p,phase=0){
  const R = 0.18*scale;
  const b1 = {x:x - 0.22*scale, y:y + 0.12*scale, r:R*(0.75+0.25*p.L1)};
  const b2 = {x:x + 0.22*scale, y:y + 0.12*scale, r:R*(0.75+0.25*p.L2)};
  const b3 = {x:x,             y:y - 0.22*scale, r:R*(0.75+0.25*p.L3)};

  drawCircle(b1.x,b1.y,b1.r,'rgba(88,166,255,.9)',2,0.9);
  drawCircle(b2.x,b2.y,b2.r,'rgba(88,166,255,.9)',2,0.9);
  drawCircle(b3.x,b3.y,b3.r,'rgba(88,166,255,.9)',2,0.9);

  // seams
  setStroke('rgba(53,208,127,.9)',2.2,0.9);
  ctx.beginPath(); ctx.moveTo(b1.x,b1.y); ctx.lineTo(b3.x,b3.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(b2.x,b2.y); ctx.lineTo(b3.x,b3.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(b1.x,b1.y); ctx.lineTo(b2.x,b2.y); ctx.stroke();

  // twist arrows (animated)
  function twistArrow(b, t, wob){
    const ang = t + 0.25*Math.sin(phase + wob);
    const ax = b.x + b.r*Math.cos(ang), ay = b.y + b.r*Math.sin(ang);
    const bx = b.x + b.r*Math.cos(ang+0.5), by = b.y + b.r*Math.sin(ang+0.5);
    setStroke('rgba(242,193,78,.9)',2,0.9);
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    const hx=bx, hy=by;
    const a = Math.atan2(by-ay, bx-ax);
    ctx.beginPath();
    ctx.moveTo(hx,hy);
    ctx.lineTo(hx - 10*Math.cos(a-0.5), hy - 10*Math.sin(a-0.5));
    ctx.lineTo(hx - 10*Math.cos(a+0.5), hy - 10*Math.sin(a+0.5));
    ctx.closePath();
    setFill('rgba(242,193,78,.9)',0.9);
    ctx.fill();
  }
  twistArrow(b1, p.T1, 0.0);
  twistArrow(b2, p.T2, 2.0);
  twistArrow(b3, p.T3, 4.0);

  // pinch marker
  const d = degenerationScore(p);
  if (d>0){
    setStroke('rgba(255,90,102,.9)',3,0.85);
    ctx.beginPath();
    ctx.arc(x,y, 0.14*scale*(1+0.8*d), 0, Math.PI*2);
    ctx.stroke();
  }
}

// 6 hologram: hexagon-in-circle with pinch bar
function drawSixHolo(cx,cy,R,p,phase=0){
  drawCircle(cx,cy,R,'rgba(88,166,255,.9)',2.2,0.95);

  const angles = [];
  for(let k=0;k<6;k++) angles.push(-Math.PI/2 + k*(Math.PI/3));

  const controls = [p.L1, p.T1, p.L2, p.T2, p.L3, p.T3];

  const rScales = controls.map((v,i)=>{
    if (i%2===0){
      return clamp(0.55 + 0.20*(v/3.0) + 0.05*Math.sin(phase + i), 0.55, 0.92);
    } else {
      return clamp(0.70 + 0.18*(Math.sin(v + 0.35*Math.sin(phase))*0.5+0.5), 0.55, 0.92);
    }
  });

  // “empty space” wash
  setFill('rgba(88,166,255,.08)',1);
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.fill();

  const pts = angles.map((a,i)=>{
    const rr = R * rScales[i];
    return {x: cx + rr*Math.cos(a), y: cy + rr*Math.sin(a)};
  });

  setStroke('rgba(53,208,127,.95)',2.4,0.95);
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  for(let i=1;i<6;i++) ctx.lineTo(pts[i].x,pts[i].y);
  ctx.closePath();
  ctx.stroke();

  for(let i=0;i<6;i++){
    setFill('rgba(53,208,127,.95)',0.95);
    ctx.beginPath(); ctx.arc(pts[i].x,pts[i].y,5,0,Math.PI*2); ctx.fill();
  }

  const labels = ["L₁","τ₁","L₂","τ₂","L₃","τ₃"];
  for(let i=0;i<6;i++){
    drawText(labels[i], pts[i].x + 10, pts[i].y + 4, 'rgba(234,240,255,.85)', 12, 'left');
  }

  const d = degenerationScore(p);
  const barW = R*1.3, barH = 10;
  const bx = cx - barW/2, by = cy + R + 18;
  setFill('rgba(255,255,255,.10)',1); ctx.fillRect(bx,by,barW,barH);
  setFill('rgba(255,90,102,.85)',1); ctx.fillRect(bx,by,barW*d,barH);
  drawText(`pinch / degeneration risk ≈ ${Math.round(d*100)}%`, cx, by+26, 'rgba(169,182,223,.9)', 12, 'center');
}

// Moduli sampling: 2D projection cloud + current point
function drawModuli(cx,cy,w,h,p,phase=0){
  function proj(pp){
    const x = (pp.L1+pp.L2+pp.L3)/3;
    const y = (Math.sin(pp.T1)+Math.sin(pp.T2)+Math.sin(pp.T3))/3;
    return {x, y};
  }

  const pad=40;
  const X0=cx-w/2+pad, Y0=cy-h/2+pad, X1=cx+w/2-pad, Y1=cy+h/2-pad;

  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(X0,Y0, X1-X0, Y1-Y0);
  drawText("projection: x = mean length, y = mean sin(twist)", X0, Y0-10, 'rgba(169,182,223,.9)', 12, 'left');

  function mapToScreen(q){
    const sx = lerp(X0, X1, (q.x-0.2)/(3.0-0.2));
    const sy = lerp(Y1, Y0, (q.y+1)/2);
    return {sx, sy};
  }

  const N=260;
  for(let i=0;i<N;i++){
    const sp = {
      L1: 0.2 + Math.random()*2.8,
      L2: 0.2 + Math.random()*2.8,
      L3: 0.2 + Math.random()*2.8,
      T1: -Math.PI + Math.random()*2*Math.PI,
      T2: -Math.PI + Math.random()*2*Math.PI,
      T3: -Math.PI + Math.random()*2*Math.PI,
      Lc: p.Lc
    };
    const wt = pseudoMeasureWeight(sp);
    const q = proj(sp);
    const s = mapToScreen(q);
    const pulse = 0.8 + 0.2*Math.sin(phase + i*0.2);
    setFill(`rgba(53,208,127,${(0.05 + 0.18*wt)*pulse})`,1);
    ctx.beginPath();
    ctx.arc(s.sx, s.sy, (2 + 2.2*wt)*pulse, 0, Math.PI*2);
    ctx.fill();
  }

  const q0=proj(p);
  const s0=mapToScreen(q0);
  setFill('rgba(242,193,78,.95)',1);
  ctx.beginPath(); ctx.arc(s0.sx,s0.sy,6,0,Math.PI*2); ctx.fill();
  setStroke('rgba(242,193,78,.95)',2,1);
  ctx.beginPath(); ctx.arc(s0.sx,s0.sy,10,0,Math.PI*2); ctx.stroke();

  drawText("shorter ⟵ mean length ⟶ longer", (X0+X1)/2, Y1+24, 'rgba(169,182,223,.9)', 12, 'center');
  drawText("twist blend", X0-10, (Y0+Y1)/2, 'rgba(169,182,223,.9)', 12, 'right');
}

// Counting plot: baseline + modulated
function drawCount(cx,cy,w,h,p,phase=0){
  const pad=40;
  const X0=cx-w/2+pad, Y0=cy-h/2+pad, X1=cx+w/2-pad, Y1=cy+h/2-pad;

  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(X0,Y0, X1-X0, Y1-Y0);

  const Lmax=25;
  const Ns=[];
  let Nmax=0;
  for(let L=1;L<=Lmax;L++){
    const val = N_of_L(L);
    Ns.push(val);
    Nmax = Math.max(Nmax,val);
  }

  setStroke('rgba(53,208,127,.95)',2.3,1);
  ctx.beginPath();
  for(let i=0;i<Ns.length;i++){
    const L=i+1;
    const x=lerp(X0,X1, (L-1)/(Lmax-1));
    const y=lerp(Y1,Y0, Ns[i]/Nmax);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  setStroke('rgba(242,193,78,.95)',2.0,0.95);
  ctx.beginPath();
  for(let L=1;L<=Lmax;L++){
    const pp={...p, Lc:L};
    const val = N_modulated(pp);
    const yn = clamp(val/(Nmax*1.4),0,1);
    const x=lerp(X0,X1, (L-1)/(Lmax-1));
    const y=lerp(Y1,Y0, yn*(0.92 + 0.06*Math.sin(phase)));
    if(L===1) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  const Lc=p.Lc;
  const xLc=lerp(X0,X1, (Lc-1)/(Lmax-1));
  setStroke('rgba(242,193,78,.8)',2,1);
  ctx.beginPath(); ctx.moveTo(xLc,Y0); ctx.lineTo(xLc,Y1); ctx.stroke();

  drawText("green: baseline growth   yellow: shape-modulated growth", X0, Y0-10, 'rgba(169,182,223,.9)', 12, 'left');
  const Nv = N_modulated(p);
  drawText(`N(L) @ L=${Lc} ≈ ${Nv.toFixed(2)}`, X1, Y0-10, 'rgba(234,240,255,.9)', 12, 'right');
}

// Einstein tension: show two layers—local metric stress vs global measure
function drawEinsteinTension(cx,cy,W,H,p,phase=0){
  // left: "local metric distortion map"
  const pad=36;
  const mid = cx;
  const left = {x: pad, y: pad, w: mid-pad*1.5, h: H-pad*2};
  const right = {x: mid+pad*0.5, y: pad, w: W-(mid+pad*1.5), h: H-pad*2};

  // frames
  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(left.x,left.y,left.w,left.h);
  ctx.strokeRect(right.x,right.y,right.w,right.h);

  // Local stress field (red heat)
  const d = degenerationScore(p);
  const twistTurb = (Math.abs(Math.sin(p.T1))+Math.abs(Math.sin(p.T2))+Math.abs(Math.sin(p.T3)))/3;
  const stress = clamp(0.35*d + 0.45*twistTurb + 0.15*Math.abs(Math.sin(phase)), 0, 1);

  // draw a wavy grid with stress intensity
  const gx=16, gy=14;
  for(let i=0;i<=gx;i++){
    const x = left.x + (i/gx)*left.w;
    setStroke(`rgba(255,90,102,${0.10 + 0.40*stress})`, 1.2, 1);
    ctx.beginPath();
    for(let j=0;j<=gy;j++){
      const y = left.y + (j/gy)*left.h;
      const wob = 10*stress*Math.sin(phase + i*0.35 + j*0.22);
      const px = x + wob*(j/gy-0.5);
      const py = y + wob*(i/gx-0.5);
      if(j===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  // draw a clock icon-ish circle with drift needle
  const c1x = left.x + left.w*0.75, c1y = left.y + left.h*0.25;
  const r1 = Math.min(left.w,left.h)*0.12;
  drawCircle(c1x,c1y,r1,'rgba(255,90,102,.85)',2.2,1);
  setStroke('rgba(255,90,102,.85)',2.4,1);
  const needle = phase*(0.7+1.2*stress);
  ctx.beginPath();
  ctx.moveTo(c1x,c1y);
  ctx.lineTo(c1x + r1*0.85*Math.cos(needle), c1y + r1*0.85*Math.sin(needle));
  ctx.stroke();

  drawText("Einstein / GR side: LOCAL metric tension", left.x+10, left.y+18, 'rgba(234,240,255,.92)', 13, 'left');
  drawText("clock drift rises with local distortion", left.x+10, left.y+38, 'rgba(169,182,223,.9)', 12, 'left');

  // Right: global measure/invariant navigation handle (green)
  const wgt = pseudoMeasureWeight(p);
  // draw smooth “state-space ring” and stable pointer
  const c2x = right.x + right.w*0.55, c2y = right.y + right.h*0.52;
  const r2 = Math.min(right.w,right.h)*0.28;
  drawCircle(c2x,c2y,r2,'rgba(53,208,127,.85)',2.2,1);

  // stable pointer: depends on parameters but less on stress
  const ang = 0.8*(p.T1+p.T2+p.T3)/3 + 0.4*Math.sin(phase*0.3);
  setStroke('rgba(53,208,127,.9)',3.0,1);
  ctx.beginPath();
  ctx.moveTo(c2x,c2y);
  ctx.lineTo(c2x + r2*(0.65+0.25*wgt)*Math.cos(ang), c2y + r2*(0.65+0.25*wgt)*Math.sin(ang));
  ctx.stroke();

  // show “volume stability” as thickness ring
  setStroke(`rgba(53,208,127,${0.25 + 0.45*wgt})`, 10, 0.55);
  ctx.beginPath(); ctx.arc(c2x,c2y,r2,0,Math.PI*2); ctx.stroke();

  drawText("Mirzakhani side: GLOBAL measure / volume handle", right.x+10, right.y+18, 'rgba(234,240,255,.92)', 13, 'left');
  drawText("stable navigation handle across deformation", right.x+10, right.y+38, 'rgba(169,182,223,.9)', 12, 'left');

  drawText(`local stress ≈ ${(stress*100).toFixed(0)}%`, left.x+10, left.y+left.h-16, 'rgba(255,90,102,.9)', 12, 'left');
  drawText(`global measure weight ≈ ${(wgt*100).toFixed(0)}%`, right.x+10, right.y+right.h-16, 'rgba(53,208,127,.9)', 12, 'left');
}

/* ---------------- Content blocks ---------------- */
const content = {
  disk: {
    title: "Hyperbolic Disk + Geodesics",
    meaning: `
      <p><b>Drawing:</b> A disk model (negative curvature intuition) with many “geodesic-like” paths.</p>
      <p><b>What you learn:</b> Paths can look chaotic locally, but we can organize them by <i>length cutoffs</i> and by <i>shape parameters</i>.</p>
      <p><b>Mirzakhani angle:</b> Don’t chase every path. Build a system that counts/averages them across the space of shapes.</p>
    `,
    findings: `
      <p><b>Her breakthrough theme:</b> Geodesics on hyperbolic surfaces obey deep statistical laws when you view them through moduli space.</p>
      <p><b>Why it matters:</b> It links geometry (surfaces), topology (holes), and dynamics (flows) into one computable framework.</p>
      <p class="small"><b>Animation:</b> paths gently “breathe” to show how geodesic families respond to deformation.</p>
    `,
    eq: `
      \\[
      \\textbf{Geodesics: } \\text{straightest paths on curved surfaces.}
      \\]
      \\[
      \\textbf{Counting idea: } N(L)=\\#\\{\\gamma\\;\\text{closed geodesic}:\\;\\ell(\\gamma)\\le L\\}.
      \\]
      \\[
      \\textbf{Main idea: } \\text{local complexity} \\Rightarrow \\text{global statistical order (after parameterization).}
      \\]
    `
  },
  pants: {
    title: "Pair-of-Pants Decomposition",
    meaning: `
      <p><b>Drawing:</b> A “pair of pants” has 3 boundary loops. Complex surfaces can be cut into pants pieces.</p>
      <p><b>Encoding:</b> Seams have <b>lengths</b> \\(\\ell_i\\) and <b>twists</b> \\(\\tau_i\\) when gluing back.</p>
      <p><b>Your 6-hologram link:</b> genus-2 can be understood via <b>3 seams × (length + twist) = 6 knobs</b>.</p>
    `,
    findings: `
      <p><b>Mirzakhani’s computation style:</b> cut → compute on simpler pieces → glue via recursion/summation/integration.</p>
      <p><b>Result:</b> enables exact volume calculations (in her setting) and controls geodesic counting statistics.</p>
      <p class="small"><b>Animation:</b> twist arrows oscillate to show the “gluing phase” changing.</p>
    `,
    eq: `
      \\[
      \\textbf{Fenchel–Nielsen coordinates (intuition):}\\quad
      (\\ell_1,\\ell_2,\\ell_3;\\, \\tau_1,\\tau_2,\\tau_3)
      \\]
      \\[
      \\ell_i = \\text{seam length},\\quad \\tau_i = \\text{twist amount when gluing.}
      \\]
      \\[
      \\textbf{Recursive philosophy: } \\text{cut} \\to \\text{compute} \\to \\text{glue back.}
      \\]
    `
  },
  sixholo: {
    title: "6-Parameter Hexagon in Circle (Your Hologram)",
    meaning: `
      <p><b>Drawing:</b> Outer circle = total configuration space. Inner hexagon = the 6 degrees of freedom \\((L_1,\\tau_1,L_2,\\tau_2,L_3,\\tau_3)\\).</p>
      <p><b>Empty space:</b> not “nothing” — it’s the region of configurations that appear when geometry warps/pinches or when linear control is insufficient.</p>
      <p><b>Interpretation:</b> A small parameter set can still encode huge deformation freedom if the coordinates are coherent.</p>
    `,
    findings: `
      <p><b>What she showed (intuitively):</b> coherent parameterization lets you put a global measure on “all shapes,” so you can still count/average even under extreme twisting/stretching.</p>
      <p><b>CST navigation analogy:</b> track the global invariant measure across distortion rather than relying on unstable local readings.</p>
      <p class="small"><b>Animation:</b> the hexagon pulses to show continuous deformation inside a fixed “allowed space.”</p>
    `,
    eq: `
      \\[
      \\textbf{Permission rule (intuition):}\\;
      \\text{Coherent parameterization} \\Rightarrow \\text{global measurability} \\Rightarrow \\text{predictable statistics.}
      \\]
      \\[
      \\textbf{State vector: } \\mathbf{x}=(\\ell_1,\\ell_2,\\ell_3,\\tau_1,\\tau_2,\\tau_3)
      \\]
    `
  },
  moduli: {
    title: "Moduli Volume Sampling (Global Measure)",
    meaning: `
      <p><b>Drawing:</b> a 2D projection of the (much higher-dimensional) space of shapes.</p>
      <p><b>Dots:</b> each dot is a shape. “Weight” brightness is a toy stand-in for a real geometric measure.</p>
      <p><b>Key:</b> with a true measure, you can compute averages like “typical behavior” across all shapes.</p>
    `,
    findings: `
      <p><b>Mirzakhani’s impact:</b> made certain moduli-space volume calculations accessible via recursion and geometry.</p>
      <p><b>Why it matters:</b> global averages turn chaos into predictable laws (for geodesics, dynamics, etc.).</p>
      <p class="small"><b>Animation:</b> dot cloud pulses; your current state stays highlighted.</p>
    `,
    eq: `
      \\[
      \\textbf{Moduli space } \\mathcal{M}:\\;\\text{all shapes (up to equivalence).}
      \\]
      \\[
      \\textbf{Volume / measure:}\\quad \\mathrm{Vol}(\\mathcal{M})=\\int_{\\mathcal{M}} d\\mu
      \\]
      \\[
      \\mathbb{E}[f]=\\frac{1}{\\mathrm{Vol}(\\mathcal{M})}\\int_{\\mathcal{M}} f\\, d\\mu
      \\]
    `
  },
  count: {
    title: "Counting Law Demo (Geodesics Under Cutoff L)",
    meaning: `
      <p><b>Drawing:</b> plots a toy growth curve for the count of closed geodesics shorter than \\(L\\).</p>
      <p><b>Green:</b> baseline growth. <b>Yellow:</b> shape-modulated growth (lengths/twists change statistics).</p>
      <p><b>Message:</b> even if individual paths are messy, the overall count obeys structured behavior.</p>
    `,
    findings: `
      <p><b>Mirzakhani’s connection:</b> geodesic counting links to global geometry through integration/volume on moduli space.</p>
      <p><b>Navigation idea:</b> you route by stable statistics/invariants, not by chasing every local fluctuation.</p>
      <p class="small"><b>Animation:</b> slight wave to show evolving environment while counts remain structured.</p>
    `,
    eq: `
      \\[
      N(L)=\\#\\{\\gamma:\\;\\text{closed geodesic},\\;\\ell(\\gamma)\\le L\\}
      \\]
      \\[
      \\text{Toy growth here: } N(L)\\approx \\frac{e^{\\alpha L}}{L}
      \\]
    `
  },
  einstein: {
    title: "Einstein Tension Panel (Local Metric vs Global Measure)",
    meaning: `
      <p><b>Drawing:</b> left side is a “local metric tension” field (GR intuition: clocks/geometry distort locally). Right side is a “global measure handle” (Mirzakhani intuition: parameter-space measure stays meaningful).</p>
      <p><b>Tension:</b> Einstein focuses on the local metric and time dilation; Mirzakhani shows how global structure can stay computable across huge deformation families.</p>
      <p><b>Why you care:</b> this is the exact logic behind your CST navigation: don’t trust only local clocks—use a global invariant handle.</p>
    `,
    findings: `
      <p><b>Takeaway:</b> local readings can drift under distortion (left), but a coherent parameterization plus global measure preserves navigability (right).</p>
      <p><b>What this justifies:</b> navigation through distorted spacetime, warp-like coordination, higher-dimensional control systems—because you keep a stable “state-space map.”</p>
      <p class="small"><b>Animation:</b> local grid warps with stress; global pointer stays stable.</p>
    `,
    eq: `
      \\[
      \\textbf{Local view (Einstein): } \\text{metric changes} \\Rightarrow \\text{local clock drift}.
      \\]
      \\[
      \\textbf{Global view (Mirzakhani): } \\text{parameterize shapes} \\Rightarrow \\text{define measure} \\Rightarrow \\text{stable statistics}.
      \\]
    `
  }
};

function setContent(mode){
  const c = content[mode];
  ui.titleBadge.textContent = c.title;
  ui.infoMeaning.innerHTML = c.meaning;
  ui.infoFindings.innerHTML = c.findings;

  ui.eqBox.innerHTML = c.eq;
  if (window.MathJax && window.MathJax.typesetPromise){
    MathJax.typesetPromise([ui.eqBox]).catch(()=>{});
  }
}

function updateKPIs(p, t){
  const d = degenerationScore(p);
  const w = pseudoMeasureWeight(p);
  const Nv = N_modulated(p);
  const twistMag = (Math.abs(Math.sin(p.T1))+Math.abs(Math.sin(p.T2))+Math.abs(Math.sin(p.T3)))/3;

  ui.kParam.textContent =
    `(L₁,L₂,L₃; τ₁,τ₂,τ₃) = (${p.L1.toFixed(2)},${p.L2.toFixed(2)},${p.L3.toFixed(2)}; ${p.T1.toFixed(2)},${p.T2.toFixed(2)},${p.T3.toFixed(2)})`;

  ui.kSignal.textContent =
    `measure≈${w.toFixed(2)} • pinch≈${Math.round(d*100)}% • twist≈${twistMag.toFixed(2)} • N(L)≈${Nv.toFixed(2)} • t=${t.toFixed(2)}`;

  // CST side-by-side (when enabled)
  if (ui.cstToggle.checked){
    ui.cstMini.style.display = "grid";

    // “Local drift” is worse when pinch and twist turbulence are high
    const localDrift = clamp(0.15 + 0.55*d + 0.35*twistMag, 0, 1);
    // “Global stability” tracks measure weight (more stable when weight is higher)
    const globalStab = clamp(0.20 + 0.80*w, 0, 1);

    ui.localClock.textContent = `local drift index ≈ ${(localDrift*100).toFixed(1)}%`;
    ui.globalMeasure.textContent = `global stability index ≈ ${(globalStab*100).toFixed(1)}%`;

    ui.localBar.style.width = `${(localDrift*100).toFixed(1)}%`;
    ui.globalBar.style.width = `${(globalStab*100).toFixed(1)}%`;
  } else {
    ui.cstMini.style.display = "none";
  }
}

/* ---------------- Main render ---------------- */
function drawScene(t, forcedMode=null){
  resize();
  clear();

  const mode = forcedMode || ui.mode.value;
  const p = readParams();
  const rect = cv.getBoundingClientRect();
  const W = rect.width, H = rect.height;
  const cx = W/2, cy = H/2;

  // faint grid
  ctx.globalAlpha = 0.25;
  setStroke('rgba(255,255,255,.10)',1,0.25);
  for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.globalAlpha = 1;

  const phase = t;

  if(mode === 'disk'){
    const R = Math.min(W,H)*0.38;
    drawCircle(cx,cy,R,'rgba(88,166,255,.95)',2.4,0.95);

    const wobble = 0.25*(Math.sin(p.T1)+Math.sin(p.T2)+Math.sin(p.T3))/3;
    const spread = 0.75 + 0.20*((p.L1+p.L2+p.L3)/3 - 1.5);

    const n = 22;
    for(let i=0;i<n;i++){
      const a1 = (i/n)*Math.PI*2 + 0.15*Math.sin(phase*0.6 + i);
      const a2 = a1 + Math.PI*(0.35 + 0.35*(i%2)) * spread;
      const colA = 0.35 + 0.55*(i/n);
      setStroke(`rgba(53,208,127,${colA})`, 2.1, 0.9);
      drawDiskGeodesic(cx,cy,R, a1, a2, wobble, phase);
    }

    const d = degenerationScore(p);
    if(d>0){
      setStroke('rgba(255,90,102,.9)',3.0,0.85);
      ctx.beginPath(); ctx.arc(cx,cy,R*(0.20+0.15*d),0,Math.PI*2); ctx.stroke();
      drawText("pinch / degeneration boundary", cx, cy+R*(0.20+0.15*d)+18, 'rgba(255,90,102,.85)', 12, 'center');
    }

    drawText("Disk model: geodesic-like families (concept)", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  if(mode === 'pants'){
    const sc = Math.min(W,H)*0.95;
    drawPants(cx,cy,sc,p,phase);
    drawText("Cut into pants → encode by seam lengths + twists", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  if(mode === 'sixholo'){
    const R = Math.min(W,H)*0.36;
    drawSixHolo(cx,cy,R,p,phase);
    drawText("Hexagon (6 knobs) inside circle (allowed configuration space)", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  if(mode === 'moduli'){
    drawModuli(cx,cy, Math.min(W, H)*0.92, Math.min(W,H)*0.72, p, phase);
    drawText("Cloud = sampled shapes; brightness = (toy) measure weight", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  if(mode === 'count'){
    drawCount(cx,cy, Math.min(W,H)*0.92, Math.min(W,H)*0.72, p, phase);
    drawText("Counting: growth of #closed geodesics under cutoff L", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  if(mode === 'einstein'){
    drawEinsteinTension(cx,cy,W,H,p,phase);
    drawText("Einstein tension: local drift vs global measure handle", 16, H-18, 'rgba(169,182,223,.9)', 12, 'left');
  }

  setContent(mode);
  updateKPIs(p, t);
}

/* ---------------- Animation loop ---------------- */
let running = false;
let lastTs = 0;
let simT = 0;

function tick(ts){
  if(!running){ lastTs = ts; return; }
  const p = readParams();
  const dt = Math.min(0.05, Math.max(0, (ts - lastTs)/1000));
  lastTs = ts;
  simT += dt * (0.2 + 1.8*p.spd);
  drawScene(simT);
  requestAnimationFrame(tick);
}

/* ---------------- Events ---------------- */
function redraw(){ drawScene(simT); }

['change','input'].forEach(ev=>{
  ui.mode.addEventListener(ev, redraw);
  ui.L1.addEventListener(ev, redraw);
  ui.L2.addEventListener(ev, redraw);
  ui.L3.addEventListener(ev, redraw);
  ui.T1.addEventListener(ev, redraw);
  ui.T2.addEventListener(ev, redraw);
  ui.T3.addEventListener(ev, redraw);
  ui.Lc.addEventListener(ev, redraw);
  ui.speed.addEventListener(ev, redraw);
  ui.cstToggle.addEventListener(ev, redraw);
});

ui.btnStart.addEventListener('click', ()=>{
  if(!running){
    running = true;
    requestAnimationFrame((ts)=>{ lastTs = ts; requestAnimationFrame(tick); });
  }
});
ui.btnPause.addEventListener('click', ()=>{ running = false; });
ui.btnStep.addEventListener('click', ()=>{
  running = false;
  const p = readParams();
  simT += 0.18 * (0.2 + 1.8*p.spd);
  drawScene(simT);
});

ui.btnRandom.addEventListener('click', ()=>{
  ui.L1.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.L2.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.L3.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.T1.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.T2.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.T3.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.Lc.value = Math.floor(6 + Math.random()*18);
  redraw();
});

ui.btnReset.addEventListener('click', ()=>{
  running = false;
  simT = 0;
  ui.mode.value = 'disk';
  ui.L1.value = 1.20;
  ui.L2.value = 1.60;
  ui.L3.value = 1.00;
  ui.T1.value = 0.60;
  ui.T2.value = -0.80;
  ui.T3.value = 1.20;
  ui.Lc.value = 12;
  ui.speed.value = 1.0;
  ui.cstToggle.checked = false;
  redraw();
});

/* ---------------- Print / Save Report ---------------- */
function htmlEscape(s){
  return (s+"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

ui.btnReport.addEventListener('click', ()=>{
  const p = readParams();
  const mode = ui.mode.value;
  const d = degenerationScore(p);
  const w = pseudoMeasureWeight(p);
  const Nv = N_modulated(p);

  // Capture a snapshot image of the canvas
  const snap = cv.toDataURL("image/png");

  const reportHtml = `
<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Mirzakhani Geometry Lab — Report</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:24px;color:#111;}
  h1{margin:0 0 10px}
  .meta{margin:0 0 16px;color:#333}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:16px}
  .box{border:1px solid #ddd;border-radius:10px;padding:12px}
  .k{font-family:ui-monospace,Consolas,monospace;font-size:12px;background:#f6f7fb;border:1px solid #e5e7eb;border-radius:8px;padding:10px}
  img{max-width:100%;border:1px solid #ddd;border-radius:12px}
  .small{font-size:12px;color:#444;line-height:1.35}
</style>
</head>
<body>
  <h1>Mirzakhani Geometry Lab — Report</h1>
  <div class="meta">
    Generated: ${new Date().toLocaleString()}<br>
    Selected drawing: <b>${htmlEscape(content[mode].title)}</b>
  </div>

  <img src="${snap}" alt="Canvas snapshot" />

  <div class="grid">
    <div class="box">
      <h3>Parameters</h3>
      <div class="k">(L1,L2,L3; T1,T2,T3) = (${p.L1.toFixed(2)}, ${p.L2.toFixed(2)}, ${p.L3.toFixed(2)}; ${p.T1.toFixed(2)}, ${p.T2.toFixed(2)}, ${p.T3.toFixed(2)})</div>
      <div class="k">Cutoff L = ${p.Lc}</div>
      <div class="k">pinch/degeneration ≈ ${(d*100).toFixed(1)}%</div>
      <div class="k">global measure weight (toy) ≈ ${(w*100).toFixed(1)}%</div>
      <div class="k">N(L) (toy) ≈ ${Nv.toFixed(2)}</div>
    </div>

    <div class="box">
      <h3>Meaning</h3>
      <div class="small">${content[mode].meaning}</div>
      <h3 style="margin-top:12px">What Mirzakhani figured out</h3>
      <div class="small">${content[mode].findings}</div>
    </div>
  </div>

  <div class="box" style="margin-top:14px">
    <h3>Core message (permission rule)</h3>
    <div class="small">
      If a system’s deformations can be parameterized coherently, then order exists at the statistical and volumetric level
      even when local behavior looks chaotic. This supports robust navigation through distortion by tracking a global invariant handle.
    </div>
  </div>

  <script>
    window.onload = () => { window.print(); };
  </script>
</body>
</html>
  `;

  const wwin = window.open("", "_blank", "noopener,noreferrer,width=1000,height=800");
  if(!wwin){ alert("Pop-up blocked. Allow pop-ups to print/save the report."); return; }
  wwin.document.open();
  wwin.document.write(reportHtml);
  wwin.document.close();
});

/* ---------------- init ---------------- */
resize();
drawScene(simT);
</script>
</body>
</html>
