<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mirzakhani Geometry Lab v2.2 — Einstein Panel FIXED + Equations Checked</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1a30;
    --line:#213659;
    --ink:#eaf0ff;
    --muted:#a9b6df;
    --brand:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --shadow: 0 14px 40px rgba(0,0,0,.35);
    --radius: 14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui, Segoe UI, Arial, sans-serif;
    background: radial-gradient(circle at 15% 0%, #13224a 0, var(--bg) 55%, #070b14 100%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: linear-gradient(90deg, rgba(88,166,255,.10), rgba(53,208,127,.06));
  }
  header h1{margin:0;font-size:18px;letter-spacing:.2px}
  header .sub{margin-top:6px;color:var(--muted);font-size:13px;line-height:1.35}

  .wrap{
    height:calc(100% - 74px);
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:12px;
    padding:12px;
  }
  .panel{
    background: linear-gradient(180deg, rgba(15,26,48,.95), rgba(10,18,35,.95));
    border:1px solid rgba(255,255,255,.08);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .panel .inner{padding:12px}
  .panel h2{
    margin:0 0 10px;
    font-size:14px;
    color:#dbe7ff;
    letter-spacing:.2px;
  }
  .row{display:flex;gap:10px;align-items:center}
  label{display:block;font-size:12px;color:var(--muted);margin-top:10px}
  select,input[type="range"],button{
    width:100%;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(8,14,28,.65);
    color: var(--ink);
    outline:none;
  }
  input[type="range"]{padding:0;height:32px}
  button{
    cursor:pointer;
    background: linear-gradient(180deg, rgba(88,166,255,.20), rgba(88,166,255,.10));
    transition: transform .06s ease;
  }
  button:hover{transform: translateY(-1px)}
  .btnRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px}
  .btnRow2{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}

  .kpi{
    display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;
  }
  .kpi .card{
    padding:10px;border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
  }
  .kpi .card .t{font-size:11px;color:var(--muted)}
  .kpi .card .v{margin-top:6px;font-family:var(--mono);font-size:12px;color:#eaf0ff}

  .note{
    margin-top:10px;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    color: var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .eq{
    font-family:var(--mono);
    font-size:12px;
    background: rgba(0,0,0,.22);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    overflow:auto;
  }
  .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0}

  .toggle{
    display:flex;gap:10px;align-items:center;margin-top:8px;
    padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
  }
  .toggle input{width:auto;height:auto;margin:0;transform:scale(1.15)}

  .right{
    display:grid;
    grid-template-rows: 1fr 330px;
    gap:12px;
  }
  .topGrid{
    height:100%;
    display:grid;
    grid-template-columns: 1.25fr 0.75fr;
    gap:12px;
    padding:12px;
  }

  canvas{
    width:100%;height:100%;
    display:block;
    background: radial-gradient(circle at 30% 10%, rgba(88,166,255,.12), rgba(0,0,0,.18) 55%, rgba(0,0,0,.28) 100%);
    border-radius: var(--radius);
  }
  .canvasWrap{position:relative;padding:12px}
  .overlay{
    position:absolute;left:24px;top:22px;right:24px;
    display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;
    pointer-events:none;
  }
  .badge{
    pointer-events:none;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.35);
    color:#dbe7ff;
    font-size:12px;
  }
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.blue{background:var(--brand)}
  .dot.green{background:var(--good)}
  .dot.yellow{background:var(--warn)}
  .dot.red{background:var(--bad)}

  .mini{
    display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;
  }
  .mini .box{
    border-radius:12px;border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    padding:10px;
  }
  .mini .box .h{font-size:12px;color:#dbe7ff;margin-bottom:6px}
  .mini .box .m{font-family:var(--mono);font-size:12px;color:#eaf0ff}
  .bar{
    height:10px;border-radius:999px;overflow:hidden;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.10);
    margin-top:8px;
  }
  .bar > div{height:100%}

  .infoGrid{
    height:100%;
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    padding:12px;
  }
  .infoBox{
    border-radius: var(--radius);
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    padding:10px;
    overflow:auto;
  }
  .infoBox h3{margin:0 0 8px;font-size:13px;color:#dbe7ff}
  .infoBox p{margin:0 0 8px;color:var(--muted);font-size:12px;line-height:1.35}
  .small{font-size:11px;color:var(--muted)}
</style>

<!-- MathJax (optional) -->
<script>
  window.MathJax = {tex:{inlineMath:[['\\(','\\)'],['$','$']]}, svg:{fontCache:'global'}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
<header>
  <h1>Mirzakhani Geometry Lab v2.2 — Einstein Panel FIXED (Local Drift vs Global Measure)</h1>
  <div class="sub">Select a drawing, change (lengths + twists), animate, and compare <b>local clock drift</b> vs a <b>global invariant measure handle</b>.</div>
</header>

<div class="wrap">
  <!-- LEFT -->
  <div class="panel">
    <div class="inner">
      <h2>1) Select drawing / concept</h2>
      <label>Drawing / Concept Selector</label>
      <select id="mode">
        <option value="disk">Hyperbolic Disk + Geodesics (chaos → order)</option>
        <option value="pants">Pair-of-Pants Decomposition (lengths & twists)</option>
        <option value="sixholo">6-Parameter Hexagon in Circle (your hologram)</option>
        <option value="moduli">Moduli Sampling (global measure)</option>
        <option value="count">Counting Law Demo N(L)</option>
        <option value="einstein">Einstein Tension (LOCAL drift vs GLOBAL invariant)</option>
      </select>

      <div class="kpi">
        <div class="card">
          <div class="t">Current parameter state</div>
          <div class="v" id="kParam">—</div>
        </div>
        <div class="card">
          <div class="t">Signals</div>
          <div class="v" id="kSignal">—</div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>2) Animation controls</h2>
      <div class="btnRow">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnStep">Step</button>
      </div>
      <div class="btnRow2">
        <button id="btnRandom">Randomize shape</button>
        <button id="btnReset">Reset</button>
      </div>

      <label>Animation speed</label>
      <input id="speed" type="range" min="0" max="2.5" step="0.01" value="1.0">

      <div class="hr"></div>

      <h2>3) Deformation knobs (lengths + twists)</h2>
      <label>Length L₁</label>
      <input id="L1" type="range" min="0.2" max="3.0" step="0.01" value="1.20">
      <label>Length L₂</label>
      <input id="L2" type="range" min="0.2" max="3.0" step="0.01" value="1.60">
      <label>Length L₃</label>
      <input id="L3" type="range" min="0.2" max="3.0" step="0.01" value="1.00">

      <label>Twist τ₁</label>
      <input id="T1" type="range" min="-3.14" max="3.14" step="0.01" value="0.60">
      <label>Twist τ₂</label>
      <input id="T2" type="range" min="-3.14" max="3.14" step="0.01" value="-0.80">
      <label>Twist τ₃</label>
      <input id="T3" type="range" min="-3.14" max="3.14" step="0.01" value="1.20">

      <label>Geodesic cutoff length L (counting demo)</label>
      <input id="Lc" type="range" min="1" max="25" step="1" value="12">

      <div class="toggle">
        <input id="cstToggle" type="checkbox" />
        <div>
          <div style="color:#dbe7ff;font-size:12px;margin-bottom:3px"><b>CST toggle</b> (Local Clocks vs Global Measure)</div>
          <div class="small">When ON, you see side-by-side “local drift” vs “global stability”.</div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>4) Print / Save report</h2>
      <button id="btnReport">Print / Save Report</button>

      <div class="note">
        <b>Mirzakhani permission rule:</b><br>
        If deformation can be parameterized coherently, then <b>global order exists</b> (measure/volume/statistics),
        even when local behavior looks chaotic.
      </div>

      <div class="hr"></div>

      <h2>5) Equations (conceptual)</h2>
      <div class="eq" id="eqBox">Ready.</div>
    </div>
  </div>

  <!-- RIGHT -->
  <div class="right">
    <div class="panel">
      <div class="topGrid">
        <div class="canvasWrap">
          <canvas id="cv"></canvas>
          <div class="overlay">
            <div class="badge" id="titleBadge">—</div>
            <div class="legend badge">
              <span class="row" style="gap:6px"><span class="dot blue"></span><span>frame</span></span>
              <span class="row" style="gap:6px"><span class="dot green"></span><span>paths</span></span>
              <span class="row" style="gap:6px"><span class="dot yellow"></span><span>twist</span></span>
              <span class="row" style="gap:6px"><span class="dot red"></span><span>pinch</span></span>
            </div>
          </div>
        </div>

        <div class="panel inner" style="margin:12px">
          <h2>What we’re doing (fast)</h2>
          <div class="note" style="margin-top:0">
            <b>Step 1:</b> Select a drawing.<br>
            <b>Step 2:</b> Change lengths/twists.<br>
            <b>Step 3:</b> Watch how <i>local</i> behavior changes, while <i>global</i> invariants remain usable.<br><br>
            <b>Einstein vs Mirzakhani:</b> local metric drift can be high while a global parameter-space handle stays stable.
          </div>

          <div class="mini" id="cstMini" style="display:none">
            <div class="box">
              <div class="h">Local clocks (Einstein/GR)</div>
              <div class="m" id="localClock">—</div>
              <div class="bar"><div id="localBar" style="width:0%; background: rgba(255,90,102,.85)"></div></div>
              <div class="small" style="margin-top:8px">Higher = more drift risk.</div>
            </div>
            <div class="box">
              <div class="h">Global measure (Mirzakhani)</div>
              <div class="m" id="globalMeasure">—</div>
              <div class="bar"><div id="globalBar" style="width:0%; background: rgba(53,208,127,.85)"></div></div>
              <div class="small" style="margin-top:8px">Higher = more stable navigation handle.</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <div class="panel">
      <div class="infoGrid">
        <div class="infoBox">
          <h3>Drawing meaning</h3>
          <div id="infoMeaning"></div>
        </div>
        <div class="infoBox">
          <h3>What Mirzakhani figured out</h3>
          <div id="infoFindings"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ==================== v2.2 FIXES ====================
1) Einstein mode now draws a REAL "local clock drift" dial + numbers (not just a grid).
2) Panels update reliably on mode change via updatePanels().
3) Equations are wrapped with \\[ \\] in every mode and typeset safely.
4) Einstein content + equation now correctly show "local metric" vs "global invariant measure" (conceptual).
====================================================== */

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const ui = {
  mode: document.getElementById('mode'),
  L1: document.getElementById('L1'),
  L2: document.getElementById('L2'),
  L3: document.getElementById('L3'),
  T1: document.getElementById('T1'),
  T2: document.getElementById('T2'),
  T3: document.getElementById('T3'),
  Lc: document.getElementById('Lc'),
  speed: document.getElementById('speed'),
  cstToggle: document.getElementById('cstToggle'),

  btnStart: document.getElementById('btnStart'),
  btnPause: document.getElementById('btnPause'),
  btnStep: document.getElementById('btnStep'),
  btnRandom: document.getElementById('btnRandom'),
  btnReset: document.getElementById('btnReset'),
  btnReport: document.getElementById('btnReport'),

  eqBox: document.getElementById('eqBox'),
  titleBadge: document.getElementById('titleBadge'),
  infoMeaning: document.getElementById('infoMeaning'),
  infoFindings: document.getElementById('infoFindings'),
  kParam: document.getElementById('kParam'),
  kSignal: document.getElementById('kSignal'),

  cstMini: document.getElementById('cstMini'),
  localClock: document.getElementById('localClock'),
  globalMeasure: document.getElementById('globalMeasure'),
  localBar: document.getElementById('localBar'),
  globalBar: document.getElementById('globalBar')
};

function resize(){
  const r = cv.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width = Math.floor(r.width * dpr);
  cv.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function readParams(){
  return {
    L1:+ui.L1.value, L2:+ui.L2.value, L3:+ui.L3.value,
    T1:+ui.T1.value, T2:+ui.T2.value, T3:+ui.T3.value,
    Lc:+ui.Lc.value, spd:+ui.speed.value
  };
}

function degenerationScore(p){
  const m = Math.min(p.L1, p.L2, p.L3);
  return clamp((0.6 - m)/0.6, 0, 1);
}
function pseudoMeasureWeight(p){
  const len = (p.L1+p.L2+p.L3)/3;
  const twist = (Math.cos(p.T1)+Math.cos(p.T2)+Math.cos(p.T3))/3;
  return clamp((0.9*Math.exp(-Math.abs(len-1.5)) + 0.1*(twist+1)/2), 0, 1);
}
function N_of_L(L){ return Math.exp(L/6) / Math.max(1, L/2); }
function N_modulated(p){
  const base = N_of_L(p.Lc);
  const mod = 0.65 + 0.18*(p.L1+p.L2+p.L3)/3 + 0.06*(Math.sin(p.T1)+Math.sin(p.T2)+Math.sin(p.T3));
  return Math.max(0, base*mod);
}

/* Drawing helpers */
function clear(){
  const w = cv.getBoundingClientRect().width;
  const h = cv.getBoundingClientRect().height;
  ctx.clearRect(0,0,w,h);
}
function setStroke(color, width=2, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}
function setFill(color, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
}
function drawCircle(x,y,r,stroke='rgba(88,166,255,.9)', width=2, alpha=1){
  setStroke(stroke, width, alpha);
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
}
function drawText(txt, x,y, color='rgba(234,240,255,.9)', size=12, align='left'){
  ctx.globalAlpha = 1;
  ctx.fillStyle = color;
  ctx.font = `${size}px ${getComputedStyle(document.body).fontFamily}`;
  ctx.textAlign = align;
  ctx.fillText(txt, x,y);
}

/* Modes */
function drawDiskGeodesic(cx,cy,R, a1, a2, wobble=0, phase=0){
  const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
  const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  const nx = (midx - cx), ny = (midy - cy);
  const nlen = Math.hypot(nx,ny) || 1;
  const k = 0.45 + 0.20*wobble + 0.08*Math.sin(phase + a1*1.7);
  const cx1 = midx + k*(nx/nlen)*R*0.35;
  const cy1 = midy + k*(ny/nlen)*R*0.35;
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.quadraticCurveTo(cx1,cy1,x2,y2);
  ctx.stroke();
}

function drawPants(x,y,scale,p,phase=0){
  const R = 0.18*scale;
  const b1 = {x:x - 0.22*scale, y:y + 0.12*scale, r:R*(0.75+0.25*p.L1)};
  const b2 = {x:x + 0.22*scale, y:y + 0.12*scale, r:R*(0.75+0.25*p.L2)};
  const b3 = {x:x,             y:y - 0.22*scale, r:R*(0.75+0.25*p.L3)};
  drawCircle(b1.x,b1.y,b1.r,'rgba(88,166,255,.9)',2,0.9);
  drawCircle(b2.x,b2.y,b2.r,'rgba(88,166,255,.9)',2,0.9);
  drawCircle(b3.x,b3.y,b3.r,'rgba(88,166,255,.9)',2,0.9);

  setStroke('rgba(53,208,127,.9)',2.2,0.9);
  ctx.beginPath(); ctx.moveTo(b1.x,b1.y); ctx.lineTo(b3.x,b3.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(b2.x,b2.y); ctx.lineTo(b3.x,b3.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(b1.x,b1.y); ctx.lineTo(b2.x,b2.y); ctx.stroke();

  function twistArrow(b, t, wob){
    const ang = t + 0.25*Math.sin(phase + wob);
    const ax = b.x + b.r*Math.cos(ang), ay = b.y + b.r*Math.sin(ang);
    const bx = b.x + b.r*Math.cos(ang+0.5), by = b.y + b.r*Math.sin(ang+0.5);
    setStroke('rgba(242,193,78,.9)',2,0.9);
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    const a = Math.atan2(by-ay, bx-ax);
    ctx.beginPath();
    ctx.moveTo(bx,by);
    ctx.lineTo(bx - 10*Math.cos(a-0.5), by - 10*Math.sin(a-0.5));
    ctx.lineTo(bx - 10*Math.cos(a+0.5), by - 10*Math.sin(a+0.5));
    ctx.closePath();
    setFill('rgba(242,193,78,.9)',0.9);
    ctx.fill();
  }
  twistArrow(b1, p.T1, 0.0);
  twistArrow(b2, p.T2, 2.0);
  twistArrow(b3, p.T3, 4.0);

  const d = degenerationScore(p);
  if (d>0){
    setStroke('rgba(255,90,102,.9)',3,0.85);
    ctx.beginPath(); ctx.arc(x,y, 0.14*scale*(1+0.8*d), 0, Math.PI*2); ctx.stroke();
  }
}

function drawSixHolo(cx,cy,R,p,phase=0){
  drawCircle(cx,cy,R,'rgba(88,166,255,.9)',2.2,0.95);
  const angles = [];
  for(let k=0;k<6;k++) angles.push(-Math.PI/2 + k*(Math.PI/3));
  const controls = [p.L1, p.T1, p.L2, p.T2, p.L3, p.T3];
  const rScales = controls.map((v,i)=>{
    if (i%2===0){
      return clamp(0.55 + 0.20*(v/3.0) + 0.05*Math.sin(phase + i), 0.55, 0.92);
    } else {
      return clamp(0.70 + 0.18*(Math.sin(v + 0.35*Math.sin(phase))*0.5+0.5), 0.55, 0.92);
    }
  });

  setFill('rgba(88,166,255,.08)',1);
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.fill();

  const pts = angles.map((a,i)=>{
    const rr = R * rScales[i];
    return {x: cx + rr*Math.cos(a), y: cy + rr*Math.sin(a)};
  });

  setStroke('rgba(53,208,127,.95)',2.4,0.95);
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  for(let i=1;i<6;i++) ctx.lineTo(pts[i].x,pts[i].y);
  ctx.closePath();
  ctx.stroke();

  const labels = ["L₁","τ₁","L₂","τ₂","L₃","τ₃"];
  for(let i=0;i<6;i++){
    setFill('rgba(53,208,127,.95)',0.95);
    ctx.beginPath(); ctx.arc(pts[i].x,pts[i].y,5,0,Math.PI*2); ctx.fill();
    drawText(labels[i], pts[i].x + 10, pts[i].y + 4, 'rgba(234,240,255,.85)', 12, 'left');
  }

  const d = degenerationScore(p);
  const barW = R*1.3, barH = 10;
  const bx = cx - barW/2, by = cy + R + 18;
  setFill('rgba(255,255,255,.10)',1); ctx.fillRect(bx,by,barW,barH);
  setFill('rgba(255,90,102,.85)',1); ctx.fillRect(bx,by,barW*d,barH);
  drawText(`pinch risk ≈ ${Math.round(d*100)}%`, cx, by+26, 'rgba(169,182,223,.9)', 12, 'center');
}

function drawModuli(cx,cy,w,h,p,phase=0){
  function proj(pp){
    const x = (pp.L1+pp.L2+pp.L3)/3;
    const y = (Math.sin(pp.T1)+Math.sin(pp.T2)+Math.sin(pp.T3))/3;
    return {x, y};
  }
  const pad=40;
  const X0=cx-w/2+pad, Y0=cy-h/2+pad, X1=cx+w/2-pad, Y1=cy+h/2-pad;

  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(X0,Y0, X1-X0, Y1-Y0);
  drawText("projection: x=mean length, y=mean sin(twist)", X0, Y0-10, 'rgba(169,182,223,.9)', 12, 'left');

  function mapToScreen(q){
    const sx = lerp(X0, X1, (q.x-0.2)/(3.0-0.2));
    const sy = lerp(Y1, Y0, (q.y+1)/2);
    return {sx, sy};
  }

  const N=260;
  for(let i=0;i<N;i++){
    const sp = {
      L1: 0.2 + Math.random()*2.8,
      L2: 0.2 + Math.random()*2.8,
      L3: 0.2 + Math.random()*2.8,
      T1: -Math.PI + Math.random()*2*Math.PI,
      T2: -Math.PI + Math.random()*2*Math.PI,
      T3: -Math.PI + Math.random()*2*Math.PI,
      Lc: p.Lc
    };
    const wt = pseudoMeasureWeight(sp);
    const q = proj(sp);
    const s = mapToScreen(q);
    const pulse = 0.8 + 0.2*Math.sin(phase + i*0.2);
    setFill(`rgba(53,208,127,${(0.05 + 0.18*wt)*pulse})`,1);
    ctx.beginPath(); ctx.arc(s.sx, s.sy, (2 + 2.2*wt)*pulse, 0, Math.PI*2); ctx.fill();
  }

  const q0=proj(p);
  const s0=mapToScreen(q0);
  setFill('rgba(242,193,78,.95)',1);
  ctx.beginPath(); ctx.arc(s0.sx,s0.sy,6,0,Math.PI*2); ctx.fill();
  setStroke('rgba(242,193,78,.95)',2,1);
  ctx.beginPath(); ctx.arc(s0.sx,s0.sy,10,0,Math.PI*2); ctx.stroke();
}

function drawCount(cx,cy,w,h,p,phase=0){
  const pad=40;
  const X0=cx-w/2+pad, Y0=cy-h/2+pad, X1=cx+w/2-pad, Y1=cy+h/2-pad;
  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(X0,Y0, X1-X0, Y1-Y0);

  const Lmax=25;
  const Ns=[]; let Nmax=0;
  for(let L=1;L<=Lmax;L++){ const v=N_of_L(L); Ns.push(v); Nmax=Math.max(Nmax,v); }

  setStroke('rgba(53,208,127,.95)',2.3,1);
  ctx.beginPath();
  for(let i=0;i<Ns.length;i++){
    const L=i+1;
    const x=lerp(X0,X1,(L-1)/(Lmax-1));
    const y=lerp(Y1,Y0,Ns[i]/Nmax);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  setStroke('rgba(242,193,78,.95)',2.0,0.95);
  ctx.beginPath();
  for(let L=1;L<=Lmax;L++){
    const pp={...p,Lc:L};
    const val=N_modulated(pp);
    const yn=clamp(val/(Nmax*1.4),0,1);
    const x=lerp(X0,X1,(L-1)/(Lmax-1));
    const y=lerp(Y1,Y0,yn*(0.92+0.06*Math.sin(phase)));
    if(L===1) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  const xLc=lerp(X0,X1,(p.Lc-1)/(Lmax-1));
  setStroke('rgba(242,193,78,.8)',2,1);
  ctx.beginPath(); ctx.moveTo(xLc,Y0); ctx.lineTo(xLc,Y1); ctx.stroke();
}

/* --------- EINSTEIN PANEL (FIXED) ----------
Left: warped grid + "clock drift dial" that changes with stress
Right: stable ring + pointer (global invariant handle), changes slowly and remains stable
-------------------------------------------- */
function drawEinsteinTension(W,H,p,phase=0){
  const pad=34;
  const mid=W/2;
  const left = {x: pad, y: pad, w: mid-pad*1.5, h: H-pad*2};
  const right = {x: mid+pad*0.5, y: pad, w: W-(mid+pad*1.5), h: H-pad*2};

  // frames
  setStroke('rgba(88,166,255,.55)',1.6,1);
  ctx.strokeRect(left.x,left.y,left.w,left.h);
  ctx.strokeRect(right.x,right.y,right.w,right.h);

  const d = degenerationScore(p);
  const twistMag = (Math.abs(Math.sin(p.T1))+Math.abs(Math.sin(p.T2))+Math.abs(Math.sin(p.T3)))/3;
  const localDrift = clamp(0.10 + 0.60*d + 0.45*twistMag, 0, 1);
  const globalStab = clamp(0.25 + 0.75*pseudoMeasureWeight(p), 0, 1);

  // LEFT warped grid
  const gx=16, gy=14;
  for(let i=0;i<=gx;i++){
    const x0 = left.x + (i/gx)*left.w;
    setStroke(`rgba(255,90,102,${0.08 + 0.45*localDrift})`, 1.2, 1);
    ctx.beginPath();
    for(let j=0;j<=gy;j++){
      const y0 = left.y + (j/gy)*left.h;
      const wob = 14*localDrift*Math.sin(phase*1.2 + i*0.35 + j*0.22);
      const px = x0 + wob*(j/gy-0.5);
      const py = y0 + wob*(i/gx-0.5);
      if(j===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  // LEFT: clock dial
  const dialR = Math.min(left.w,left.h)*0.18;
  const dialX = left.x + left.w*0.75;
  const dialY = left.y + left.h*0.25;

  drawCircle(dialX,dialY,dialR,'rgba(255,90,102,.90)',2.2,1);

  // dial ticks
  setStroke('rgba(255,90,102,.55)',1.4,1);
  for(let k=0;k<12;k++){
    const a = -Math.PI/2 + k*(Math.PI*2/12);
    const r1 = dialR*0.82, r2 = dialR*0.95;
    ctx.beginPath();
    ctx.moveTo(dialX + r1*Math.cos(a), dialY + r1*Math.sin(a));
    ctx.lineTo(dialX + r2*Math.cos(a), dialY + r2*Math.sin(a));
    ctx.stroke();
  }

  // needle: gets "noisier" with drift
  const needleA = -Math.PI/2 + (phase*1.3)*(0.4+1.8*localDrift) + 1.2*Math.sin(phase*2.4)*localDrift;
  setStroke('rgba(255,90,102,.95)',3.0,1);
  ctx.beginPath();
  ctx.moveTo(dialX,dialY);
  ctx.lineTo(dialX + dialR*0.82*Math.cos(needleA), dialY + dialR*0.82*Math.sin(needleA));
  ctx.stroke();

  setFill('rgba(255,90,102,.95)',1);
  ctx.beginPath(); ctx.arc(dialX,dialY,4,0,Math.PI*2); ctx.fill();

  drawText("Einstein / GR: LOCAL metric drift", left.x+10, left.y+18, 'rgba(234,240,255,.92)', 13, 'left');
  drawText(`local drift index ≈ ${(localDrift*100).toFixed(0)}%`, left.x+10, left.y+38, 'rgba(255,90,102,.92)', 12, 'left');

  // RIGHT: global measure ring + stable pointer
  const ringX = right.x + right.w*0.55;
  const ringY = right.y + right.h*0.52;
  const ringR = Math.min(right.w,right.h)*0.30;

  // ring thickness shows stability
  setStroke(`rgba(53,208,127,${0.30 + 0.55*globalStab})`, 12, 0.65);
  ctx.beginPath(); ctx.arc(ringX,ringY,ringR,0,Math.PI*2); ctx.stroke();

  drawCircle(ringX,ringY,ringR,'rgba(53,208,127,.90)',2.2,1);

  // stable pointer moves slowly (less dependent on drift)
  const baseAng = (p.T1+p.T2+p.T3)/3;
  const pointerA = -Math.PI/2 + 0.55*baseAng + 0.30*Math.sin(phase*0.35);
  setStroke('rgba(53,208,127,.95)',3.2,1);
  ctx.beginPath();
  ctx.moveTo(ringX,ringY);
  ctx.lineTo(ringX + ringR*(0.70+0.15*globalStab)*Math.cos(pointerA),
             ringY + ringR*(0.70+0.15*globalStab)*Math.sin(pointerA));
  ctx.stroke();

  drawText("Mirzakhani: GLOBAL invariant handle", right.x+10, right.y+18, 'rgba(234,240,255,.92)', 13, 'left');
  drawText(`global stability ≈ ${(globalStab*100).toFixed(0)}%`, right.x+10, right.y+38, 'rgba(53,208,127,.92)', 12, 'left');

  // label line between them
  setStroke('rgba(88,166,255,.20)',2,1);
  ctx.beginPath();
  ctx.moveTo(mid, pad);
  ctx.lineTo(mid, H-pad);
  ctx.stroke();

  // footer hints inside boxes
  drawText("warped grid = curvature/tension", left.x+10, left.y+left.h-16, 'rgba(169,182,223,.85)', 12, 'left');
  drawText("ring + pointer = parameter-space handle", right.x+10, right.y+right.h-16, 'rgba(169,182,223,.85)', 12, 'left');
}

/* Content (panels + equations) */
const content = {
  disk:{
    title:"Hyperbolic Disk + Geodesics",
    meaning:`<p><b>Disk:</b> families of “geodesic-like” paths on a negatively-curved surface.</p>
             <p><b>Point:</b> local paths look complex, but become organized by a length cutoff and global statistics.</p>`,
    findings:`<p><b>Mirzakhani theme:</b> geodesic statistics become predictable once shapes are organized by parameters and integrated using a global measure.</p>`,
    eq:`\\[
      N(L)=\\#\\{\\gamma\\;\\text{closed geodesic}:\\;\\ell(\\gamma)\\le L\\}
    \\]`
  },
  pants:{
    title:"Pair-of-Pants Decomposition",
    meaning:`<p><b>Cut → glue:</b> encode a surface by seam <b>lengths</b> and <b>twists</b>.</p>
             <p><b>6 knobs:</b> three seams × (length + twist) = 6 parameters (your control intuition).</p>`,
    findings:`<p><b>Compute globally:</b> complex surfaces become computable by cutting into simple pieces and summing/integrating over parameters.</p>`,
    eq:`\\[
      (\\ell_1,\\ell_2,\\ell_3;\\,\\tau_1,\\tau_2,\\tau_3)
    \\]`
  },
  sixholo:{
    title:"6-Parameter Hexagon in Circle",
    meaning:`<p><b>Your hologram:</b> inner hexagon = 6 degrees of freedom \\((L_1,\\tau_1,L_2,\\tau_2,L_3,\\tau_3)\\) within an allowed configuration region (circle).</p>
             <p><b>Empty space:</b> latent configurations that appear under deformation and constraints.</p>`,
    findings:`<p><b>Key:</b> coherent parameterization lets you define a global measure and keep navigability even when local geometry looks chaotic.</p>`,
    eq:`\\[
      \\mathbf{x}=(\\ell_1,\\ell_2,\\ell_3,\\tau_1,\\tau_2,\\tau_3)
    \\]`
  },
  moduli:{
    title:"Moduli Sampling (Global Measure)",
    meaning:`<p><b>Cloud:</b> each dot is a different “shape.” Brightness is a toy weight standing in for a real invariant measure.</p>`,
    findings:`<p><b>Mirzakhani style:</b> global averages across moduli space turn chaos into predictable laws (counts/distributions).</p>`,
    eq:`\\[
      \\mathrm{Vol}(\\mathcal{M})=\\int_{\\mathcal{M}} d\\mu,\\quad
      \\mathbb{E}[f]=\\frac{1}{\\mathrm{Vol}(\\mathcal{M})}\\int_{\\mathcal{M}} f\\, d\\mu
    \\]`
  },
  count:{
    title:"Counting Law Demo N(L)",
    meaning:`<p><b>Green:</b> baseline growth; <b>yellow:</b> shape-modulated growth (lengths/twists affect statistics).</p>`,
    findings:`<p><b>Message:</b> individual paths can be messy, but global counting behavior remains structured and informative.</p>`,
    eq:`\\[
      \\text{Toy: } N(L)\\approx \\frac{e^{\\alpha L}}{L}
    \\]`
  },
  einstein:{
    title:"Einstein Tension: Local Drift vs Global Invariant",
    meaning:`<p><b>Left:</b> LOCAL metric distortion (warped grid) + a clock dial showing drift.</p>
             <p><b>Right:</b> GLOBAL invariant handle (ring + pointer) representing stable measure/parameter-space control.</p>`,
    findings:`<p><b>What this illustrates:</b> local time/metric readings can drift heavily under distortion, while a global measure built from coherent parameters stays usable for navigation/control (Mirzakhani-style viewpoint).</p>`,
    eq:`\\[
      \\textbf{Local (Einstein/GR):}\\; g_{\\mu\\nu}(x)\\;\\Rightarrow\\;\\text{local clock rates vary.}
      \\qquad
      \\textbf{Global (Mirzakhani):}\\; (\\ell,\\tau)\\;\\Rightarrow\\; d\\mu\\;\\Rightarrow\\;\\text{stable statistics/measure.}
    \\]`
  }
};

function typesetEq(){
  if (window.MathJax && window.MathJax.typesetPromise){
    MathJax.typesetPromise([ui.eqBox]).catch(()=>{});
  }
}

function updatePanels(){
  const mode = ui.mode.value;
  const c = content[mode];
  ui.titleBadge.textContent = c.title;
  ui.infoMeaning.innerHTML = c.meaning;
  ui.infoFindings.innerHTML = c.findings;
  ui.eqBox.innerHTML = c.eq;
  typesetEq();
}

function updateKPIs(p,t){
  const d = degenerationScore(p);
  const w = pseudoMeasureWeight(p);
  const Nv = N_modulated(p);
  const twistMag = (Math.abs(Math.sin(p.T1))+Math.abs(Math.sin(p.T2))+Math.abs(Math.sin(p.T3)))/3;

  ui.kParam.textContent =
    `(L₁,L₂,L₃; τ₁,τ₂,τ₃)=(${p.L1.toFixed(2)},${p.L2.toFixed(2)},${p.L3.toFixed(2)}; ${p.T1.toFixed(2)},${p.T2.toFixed(2)},${p.T3.toFixed(2)})`;

  ui.kSignal.textContent =
    `measure=${w.toFixed(2)} • pinch=${Math.round(d*100)}% • twist=${twistMag.toFixed(2)} • N(L)=${Nv.toFixed(2)} • t=${t.toFixed(2)}`;

  if (ui.cstToggle.checked){
    ui.cstMini.style.display = "grid";
    const localDrift = clamp(0.10 + 0.60*d + 0.45*twistMag, 0, 1);
    const globalStab = clamp(0.25 + 0.75*w, 0, 1);
    ui.localClock.textContent = `local drift ≈ ${(localDrift*100).toFixed(1)}%`;
    ui.globalMeasure.textContent = `global stability ≈ ${(globalStab*100).toFixed(1)}%`;
    ui.localBar.style.width = `${(localDrift*100).toFixed(1)}%`;
    ui.globalBar.style.width = `${(globalStab*100).toFixed(1)}%`;
  } else {
    ui.cstMini.style.display = "none";
  }
}

function drawScene(t){
  resize();
  clear();

  const mode = ui.mode.value;
  const p = readParams();
  const rect = cv.getBoundingClientRect();
  const W = rect.width, H = rect.height;
  const cx = W/2, cy = H/2;
  const phase = t;

  // faint background grid
  ctx.globalAlpha = 0.25;
  setStroke('rgba(255,255,255,.10)',1,0.25);
  for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.globalAlpha = 1;

  if(mode === "disk"){
    const R = Math.min(W,H)*0.38;
    drawCircle(cx,cy,R,'rgba(88,166,255,.95)',2.4,0.95);
    const wobble = 0.25*(Math.sin(p.T1)+Math.sin(p.T2)+Math.sin(p.T3))/3;
    const spread = 0.75 + 0.20*((p.L1+p.L2+p.L3)/3 - 1.5);
    const n = 22;
    for(let i=0;i<n;i++){
      const a1 = (i/n)*Math.PI*2 + 0.15*Math.sin(phase*0.6 + i);
      const a2 = a1 + Math.PI*(0.35 + 0.35*(i%2)) * spread;
      const colA = 0.35 + 0.55*(i/n);
      setStroke(`rgba(53,208,127,${colA})`, 2.1, 0.9);
      drawDiskGeodesic(cx,cy,R,a1,a2,wobble,phase);
    }
    const d = degenerationScore(p);
    if(d>0){
      setStroke('rgba(255,90,102,.9)',3.0,0.85);
      ctx.beginPath(); ctx.arc(cx,cy,R*(0.20+0.15*d),0,Math.PI*2); ctx.stroke();
    }
  }

  if(mode === "pants"){
    const sc = Math.min(W,H)*0.95;
    drawPants(cx,cy,sc,p,phase);
  }

  if(mode === "sixholo"){
    const R = Math.min(W,H)*0.36;
    drawSixHolo(cx,cy,R,p,phase);
  }

  if(mode === "moduli"){
    drawModuli(cx,cy, Math.min(W,H)*0.92, Math.min(W,H)*0.72, p, phase);
  }

  if(mode === "count"){
    drawCount(cx,cy, Math.min(W,H)*0.92, Math.min(W,H)*0.72, p, phase);
  }

  if(mode === "einstein"){
    drawEinsteinTension(W,H,p,phase);
  }

  updatePanels();
  updateKPIs(p,t);
}

/* Animation */
let running = false;
let lastTs = 0;
let simT = 0;

function tick(ts){
  if(!running){ lastTs = ts; return; }
  const p = readParams();
  const dt = Math.min(0.05, Math.max(0, (ts - lastTs)/1000));
  lastTs = ts;
  simT += dt * (0.2 + 1.8*p.spd);
  drawScene(simT);
  requestAnimationFrame(tick);
}

/* Events */
function redraw(){ drawScene(simT); }

["change","input"].forEach(ev=>{
  ui.mode.addEventListener(ev, redraw);
  ui.L1.addEventListener(ev, redraw);
  ui.L2.addEventListener(ev, redraw);
  ui.L3.addEventListener(ev, redraw);
  ui.T1.addEventListener(ev, redraw);
  ui.T2.addEventListener(ev, redraw);
  ui.T3.addEventListener(ev, redraw);
  ui.Lc.addEventListener(ev, redraw);
  ui.speed.addEventListener(ev, redraw);
  ui.cstToggle.addEventListener(ev, redraw);
});

ui.btnStart.addEventListener("click", ()=>{
  if(!running){
    running = true;
    requestAnimationFrame((ts)=>{ lastTs = ts; requestAnimationFrame(tick); });
  }
});
ui.btnPause.addEventListener("click", ()=>{ running = false; });
ui.btnStep.addEventListener("click", ()=>{
  running = false;
  const p = readParams();
  simT += 0.18 * (0.2 + 1.8*p.spd);
  drawScene(simT);
});

ui.btnRandom.addEventListener("click", ()=>{
  ui.L1.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.L2.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.L3.value = (0.2 + Math.random()*2.8).toFixed(2);
  ui.T1.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.T2.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.T3.value = (-Math.PI + Math.random()*2*Math.PI).toFixed(2);
  ui.Lc.value = Math.floor(6 + Math.random()*18);
  redraw();
});

ui.btnReset.addEventListener("click", ()=>{
  running = false;
  simT = 0;
  ui.mode.value = "disk";
  ui.L1.value = 1.20;
  ui.L2.value = 1.60;
  ui.L3.value = 1.00;
  ui.T1.value = 0.60;
  ui.T2.value = -0.80;
  ui.T3.value = 1.20;
  ui.Lc.value = 12;
  ui.speed.value = 1.0;
  ui.cstToggle.checked = false;
  redraw();
});

/* Report (stable) */
function stripTags(html){
  const div = document.createElement("div");
  div.innerHTML = html;
  return div.textContent || div.innerText || "";
}
ui.btnReport.addEventListener("click", ()=>{
  const p = readParams();
  const mode = ui.mode.value;
  const d = degenerationScore(p);
  const wgt = pseudoMeasureWeight(p);
  const Nv = N_modulated(p);
  const snap = cv.toDataURL("image/png");

  const meaningText = stripTags(content[mode].meaning);
  const findingsText = stripTags(content[mode].findings);
  const eqText = stripTags(ui.eqBox.innerHTML);

  const report = [
'<!doctype html>',
'<html><head><meta charset="utf-8" />',
'<title>Mirzakhani Geometry Lab — Report</title>',
'<style>',
'body{font-family:Arial,Helvetica,sans-serif;margin:24px;color:#111;}',
'h1{margin:0 0 10px}',
'.meta{margin:0 0 16px;color:#333}',
'.grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:16px}',
'.box{border:1px solid #ddd;border-radius:10px;padding:12px}',
'.k{font-family:ui-monospace,Consolas,monospace;font-size:12px;background:#f6f7fb;border:1px solid #e5e7eb;border-radius:8px;padding:10px}',
'img{max-width:100%;border:1px solid #ddd;border-radius:12px}',
'.small{font-size:12px;color:#444;line-height:1.35;white-space:pre-wrap}',
'</style></head><body>',
'<h1>Mirzakhani Geometry Lab — Report</h1>',
`<div class="meta">Generated: ${new Date().toLocaleString()}<br>Selected drawing: <b>${stripTags(content[mode].title)}</b></div>`,
`<img src="${snap}" alt="Canvas snapshot" />`,
'<div class="grid">',
'<div class="box"><h3>Parameters</h3>',
`<div class="k">(L1,L2,L3; T1,T2,T3)=(${p.L1.toFixed(2)}, ${p.L2.toFixed(2)}, ${p.L3.toFixed(2)}; ${p.T1.toFixed(2)}, ${p.T2.toFixed(2)}, ${p.T3.toFixed(2)})</div>`,
`<div class="k">Cutoff L = ${p.Lc}</div>`,
`<div class="k">pinch/degeneration ≈ ${(d*100).toFixed(1)}%</div>`,
`<div class="k">global measure weight (toy) ≈ ${(wgt*100).toFixed(1)}%</div>`,
`<div class="k">N(L) (toy) ≈ ${Nv.toFixed(2)}</div>`,
'</div>',
'<div class="box"><h3>Meaning</h3>',
`<div class="small">${meaningText}</div>`,
'<h3 style="margin-top:12px">What Mirzakhani figured out</h3>',
`<div class="small">${findingsText}</div>`,
'<h3 style="margin-top:12px">Equations (text)</h3>',
`<div class="small">${eqText}</div>`,
'</div>',
'</div>',
'<div class="box" style="margin-top:14px">',
'<h3>Core message (permission rule)</h3>',
'<div class="small">',
'If a system’s deformations can be parameterized coherently, then order exists at the statistical and volumetric level ',
'even when local behavior looks chaotic. This supports navigation through distortion by tracking a global invariant handle.',
'</div></div>',
'<script>window.onload=()=>{window.print();};<\/script>',
'</body></html>'
  ].join("");

  const wwin = window.open("", "_blank", "noopener,noreferrer,width=1000,height=800");
  if(!wwin){ alert("Pop-up blocked. Allow pop-ups to print/save the report."); return; }
  wwin.document.open();
  wwin.document.write(report);
  wwin.document.close();
});

/* init */
resize();
drawScene(simT);
</script>
</body>
</html>
