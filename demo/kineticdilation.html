<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Strong-Field Timing Frontier — Transport vs GR vs Torsion-Softened + CST (Fixed & Fast)</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#101a2f;
    --panel2:#0c1426;
    --line:#203156;
    --ink:#eaf0ff;
    --muted:#a8b3d6;
    --brand:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 14px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:radial-gradient(circle at 20% 0%, #101b35 0, var(--bg) 55%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background:rgba(8,14,28,.85);
    position:sticky; top:0; z-index:2;
    backdrop-filter: blur(8px);
  }
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  header .sub{margin-top:4px;color:var(--muted);font-size:12.5px;line-height:1.35}

  /* ✅ NEW: Regime / Non-Claims banner (early + visible) */
  .notice{
    margin-top:10px;
    padding:10px 12px;
    border:1px solid rgba(148,163,184,.25);
    border-radius:12px;
    background:rgba(15,23,42,.55);
    color:rgba(234,240,255,.92);
    font-size:12.2px;
    line-height:1.35;
  }
  .notice b{color:#dbe6ff}
  .notice ul{margin:8px 0 0 18px; padding:0}
  .notice li{margin:6px 0; color:rgba(229,231,235,.88)}

  main{
    display:grid;
    grid-template-columns:430px 1fr;
    gap:12px;
    padding:12px;
    max-width:1320px;
    margin:0 auto;
  }
  @media (max-width: 980px){
    main{grid-template-columns:1fr}
  }
  .panel{
    background:linear-gradient(180deg, rgba(16,26,47,.96), rgba(12,20,38,.92));
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .panel h2{margin:0 0 10px;font-size:14px;color:#dbe6ff}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  .hr{height:1px;background:var(--line);margin:10px 0}

  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="range"]{width:100%}
  input[type="number"], select, button, textarea{
    width:100%;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:#0a1222;
    color:var(--ink);
    outline:none;
  }
  button{
    cursor:pointer;
    background:linear-gradient(180deg, #112349, #0a1730);
    font-weight:700;
  }
  button:hover{border-color:#32529a}
  textarea{
    min-height:130px; resize:vertical;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px
  }

  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background:rgba(0,0,0,.18);
    font-size:12px;
    color:var(--muted);
    font-variant-numeric:tabular-nums;
  }

  .sw{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14);
    margin-top:10px;
  }
  .sw b{color:#dbe6ff;font-size:12.5px}
  .toggle{
    width:50px;height:28px;border-radius:999px;border:1px solid var(--line);
    background:#0a1222;position:relative;cursor:pointer;flex:0 0 auto;
  }
  .knob{position:absolute;top:3px;left:3px;width:22px;height:22px;border-radius:50%;background:#6076b9;transition:.18s}
  .toggle.on{background:#0b1f16;border-color:#1f5c3e}
  .toggle.on .knob{left:25px;background:var(--good)}

  .callout{
    border-left:4px solid var(--brand);
    padding:10px 12px;
    background:rgba(88,166,255,.10);
    border-radius:12px;
    margin-top:10px;
  }

  .kv{
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    margin-top:8px;
    padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14)
  }
  .kv div:nth-child(2n){
    text-align:right;
    color:#dbe6ff;
    font-variant-numeric:tabular-nums;
    white-space:nowrap;
  }

  .tabs{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
  .tab{
    padding:8px 10px;border:1px solid var(--line);border-radius:999px;
    background:rgba(0,0,0,.18);color:var(--muted);cursor:pointer;font-size:12px;
  }
  .tab.on{border-color:#32529a;color:#dbe6ff;background:rgba(88,166,255,.10)}

  canvas{
    width:100%;
    border:1px solid var(--line);
    border-radius:14px;
    background:linear-gradient(180deg, #070c18, #050a14);
  }

  .legend{
    display:flex;gap:10px;flex-wrap:wrap;margin-top:8px
  }
  .leg{
    display:inline-flex;align-items:center;gap:8px;
    border:1px solid var(--line);border-radius:999px;padding:6px 10px;
    background:rgba(0,0,0,.16);color:var(--muted);font-size:12px
  }
  .swatch{width:12px;height:12px;border-radius:3px;display:inline-block}
  .note{font-size:12px;color:var(--muted);line-height:1.4}
</style>
</head>

<body>
<header>
  <h1>Strong-Field Timing Frontier — Transport-First (Exponential) vs GR vs Torsion-Softened + CST</h1>
  <div class="sub">
    Reader teaching simulator: compare three time-rate laws near a compact object (toy models). Focus is <b>timing signatures</b> (pulsar clocks), not EHT ray-tracing images.
    Tip: switch to <b>Tab B</b> and press <b>Start</b> to see the residual history trace animate.
  </div>

  <!-- ✅ NEW: regime bound early -->
  <div class="notice">
    <b>Regime / Non-Claims (read first):</b>
    <ul>
      <li><b>Toy functional forms</b> for comparative timing signatures under stated assumptions (protocol discipline).</li>
      <li><b>Not</b> a self-consistent Einstein–Cartan solver; torsion here is parameterized as a response family.</li>
      <li><b>Not</b> EHT ray-tracing / plasma emission / image formation.</li>
      <li>Goal: <b>discriminate timing behaviors</b> (admissibility under constraints), not claim a final gravity theory.</li>
    </ul>
  </div>
</header>

<main>
  <!-- LEFT: Controls -->
  <section class="panel">
    <h2>1) Geometry: compact object + orbit (toy)</h2>
    <div class="small">
      Dimensionless radius <b>R = r/r<sub>s</sub></b>. GR horizon is at R=1. The mock pulsar orbit uses R(t)=R<sub>orb</sub>(1−e cos(2πt/P)) (clamped above 1).
    </div>

    <div class="grid2">
      <div>
        <label>Probe radius R (for curves)</label>
        <input id="R" type="range" min="1.001" max="30" step="0.001" />
        <div class="row"><span class="pill">R = <span id="ROut"></span></span></div>
      </div>
      <div>
        <label>Orbit radius R<sub>orb</sub> (mock pulsar)</label>
        <input id="Rorb" type="range" min="1.05" max="30" step="0.01" />
        <div class="row"><span class="pill">R<sub>orb</sub> = <span id="RorbOut"></span></span></div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Orbit period P (seconds, simulation time)</label>
        <input id="P" type="range" min="1" max="120" step="1" />
        <div class="row"><span class="pill">P = <span id="POut"></span> s</span></div>
      </div>
      <div>
        <label>Number of orbits to accumulate (target)</label>
        <input id="Norbits" type="range" min="1" max="60" step="1" />
        <div class="row"><span class="pill">N = <span id="NorbitsOut"></span></span></div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Orbit eccentricity e (demo)</label>
        <input id="ecc" type="range" min="0" max="0.6" step="0.01" />
        <div class="row"><span class="pill">e = <span id="eccOut"></span></span></div>
      </div>
      <div>
        <label>History trace length (points)</label>
        <input id="histLen" type="range" min="200" max="1500" step="10" />
        <div class="row"><span class="pill">H = <span id="histLenOut"></span></span></div>
      </div>
    </div>

    <div class="hr"></div>

    <h2>2) Model knobs: Transport vs Torsion</h2>
    <div class="small">
      Transport-first: exponential saturation from causal-flux attenuation. Geometry-first: torsion-softened toy response (parameterized).
    </div>

    <div class="grid2">
      <div>
        <label>Transport attenuation κ (dimensionless)</label>
        <input id="kappa" type="range" min="0" max="12" step="0.001" />
        <div class="row"><span class="pill">κ = <span id="kappaOut"></span></span></div>
      </div>
      <div>
        <label>Flux profile power p (Φ ∝ 1/R<sup>p</sup>)</label>
        <input id="pPow" type="range" min="0" max="6" step="0.01" />
        <div class="row"><span class="pill">p = <span id="pPowOut"></span></span></div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Torsion softening α (dimensionless)</label>
        <input id="alpha" type="range" min="0" max="20" step="0.001" />
        <div class="row"><span class="pill">α = <span id="alphaOut"></span></span></div>
      </div>
      <div>
        <label>Torsion exponent n (power)</label>
        <input id="nPow" type="range" min="0.1" max="8" step="0.01" />
        <div class="row"><span class="pill">n = <span id="nPowOut"></span></span></div>
      </div>
    </div>

    <div class="callout">
      <div class="small">
        <b>Equations (left-to-right):</b><br/>
        GR: dτ/dt = √(1 − 1/R).<br/>
        Transport: dτ/dt = exp(−κ Φ(R)), Φ(R)=1/R<sup>p</sup>.<br/>
        Torsion-soft (toy): dτ/dt = (1 + α T(R))<sup>−n</sup>, T(R)=1/R<sup>3</sup>.
      </div>
    </div>

    <div class="sw">
      <div>
        <b>CST synchronization overlay</b>
        <div class="small">Display clock is phase-locked to reference time (a shared standard), while residuals remain physics-based.</div>
      </div>
      <div class="toggle on" id="togCST" role="switch" aria-checked="true"><div class="knob"></div></div>
    </div>

    <div class="sw">
      <div>
        <b>Mapping label (Φ ↔ |Ψ|²)</b>
        <div class="small">Interpretive relabel only (no math change).</div>
      </div>
      <div class="toggle" id="togMap" role="switch" aria-checked="false"><div class="knob"></div></div>
    </div>

    <div class="hr"></div>

    <h2>Run</h2>
    <div class="grid3">
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnStep">Step +1s</button>
    </div>
    <div class="grid3" style="margin-top:10px">
      <button id="btnReset">Reset</button>
      <button id="btnCopy">Copy Summary</button>
      <button id="btnPrint">Print / Save Data</button>
    </div>

    <div class="callout">
      <div class="small">
        <b>Reader path:</b><br/>
        (1) Go to <b>Tab A</b> and slide R → 1 to see the strong-field approach.<br/>
        (2) Increase κ (transport) vs α,n (torsion) and compare the approach to “freeze.”<br/>
        (3) Go to <b>Tab B</b> and press <b>Start</b>: the residual trace updates continuously over time and as orbits advance.
      </div>
    </div>
  </section>
  <!-- RIGHT: Visualization -->
  <section class="panel">
    <h2>Visualization</h2>

    <div class="tabs">
      <div class="tab on" id="tabA">Time-rate laws vs R</div>
      <div class="tab" id="tabB">Residual history (animate)</div>
      <div class="tab" id="tabC">Flux / torsion profiles</div>
    </div>

    <canvas id="cv" width="1200" height="420" style="height:340px"></canvas>
    <canvas id="cv2" width="1200" height="300" style="height:260px;margin-top:12px"></canvas>

    <div class="legend">
      <div class="leg"><span class="swatch" style="background:rgba(242,193,78,.95)"></span>GR: √(1−1/R)</div>
      <div class="leg"><span class="swatch" style="background:rgba(88,166,255,.95)"></span>Transport: exp(−κΦ)</div>
      <div class="leg"><span class="swatch" style="background:rgba(53,208,127,.95)"></span>Torsion-soft: (1+αT)<sup>−n</sup></div>
      <div class="leg"><span class="swatch" style="background:rgba(255,90,102,.95)"></span>Probe / orbit markers</div>
    </div>

    <div class="hr"></div>

    <h2>Live Readout</h2>
    <div class="kv">
      <div>Reference time t (s)</div><div><span id="tOut">0.0</span></div>
      <div>Orbits completed (integer)</div><div><span id="orbitsDoneOut">0</span></div>
      <div>Orbit phase (0→1)</div><div><span id="phaseOut">0.00</span></div>

      <div>Probe radius R</div><div><span id="ROut2">—</span></div>
      <div>Orbit radius R<sub>orb</sub></div><div><span id="RorbOut2">—</span></div>
      <div>Instantaneous R(t) along orbit</div><div><span id="RinstOut">—</span></div>

      <div>Φ(R) (or |Ψ|² label)</div><div><span id="phiOut">—</span></div>
      <div>T(R) torsion profile</div><div><span id="torsOut">—</span></div>

      <div>GR rate at R(t)</div><div><span id="grInstOut">—</span></div>
      <div>Transport rate at R(t)</div><div><span id="trInstOut">—</span></div>
      <div>Torsion-soft rate at R(t)</div><div><span id="tsInstOut">—</span></div>

      <div>Accumulated Δτ (GR − Transport)</div><div><span id="resGT">—</span></div>
      <div>Accumulated Δτ (GR − Torsion)</div><div><span id="resGS">—</span></div>

      <div>CST display clock (s)</div><div><span id="cstOut">—</span></div>
      <div>CST correction applied (s)</div><div><span id="cstCorrOut">—</span></div>
    </div>

    <div class="hr"></div>

    <h2>Explanation Panel</h2>
    <textarea id="explain" readonly></textarea>

    <div class="hr"></div>
    <div class="note">
      <b>Limitations:</b> Toy functional forms only. No self-consistent Einstein–Cartan solver, and no EHT ray-tracing/plasma emission.
      This targets timing behavior (proper-time transport) and model discrimination.
    </div>
  </section>
</main>

<script>
(() => {
  // ✅ Safer numeric policy for the whole demo
  const EPS = 1e-15;
  const EPS_R = 1e-6;        // clamp margin above horizon
  const R_HORIZON = 1.0;

  const el = id => document.getElementById(id);

  // Inputs
  const inR = el("R");
  const inRorb = el("Rorb");
  const inP = el("P");
  const inNorbits = el("Norbits");
  const inEcc = el("ecc");
  const inHistLen = el("histLen");
  const inK = el("kappa");
  const inPpow = el("pPow");
  const inAlpha = el("alpha");
  const inNpow = el("nPow");

  // Toggles
  const togCST = el("togCST");
  const togMap = el("togMap");

  // Outputs (left)
  const ROut = el("ROut");
  const RorbOut = el("RorbOut");
  const POut = el("POut");
  const NorbitsOut = el("NorbitsOut");
  const eccOut = el("eccOut");
  const histLenOut = el("histLenOut");
  const kappaOut = el("kappaOut");
  const pPowOut = el("pPowOut");
  const alphaOut = el("alphaOut");
  const nPowOut = el("nPowOut");

  // Outputs (right)
  const tOut = el("tOut");
  const orbitsDoneOut = el("orbitsDoneOut");
  const phaseOut = el("phaseOut");
  const ROut2 = el("ROut2");
  const RorbOut2 = el("RorbOut2");
  const RinstOut = el("RinstOut");
  const phiOut = el("phiOut");
  const torsOut = el("torsOut");
  const grInstOut = el("grInstOut");
  const trInstOut = el("trInstOut");
  const tsInstOut = el("tsInstOut");
  const resGT = el("resGT");
  const resGS = el("resGS");
  const cstOut = el("cstOut");
  const cstCorrOut = el("cstCorrOut");
  const explain = el("explain");

  // Buttons
  const btnStart = el("btnStart");
  const btnPause = el("btnPause");
  const btnStep = el("btnStep");
  const btnReset = el("btnReset");
  const btnCopy = el("btnCopy");
  const btnPrint = el("btnPrint");

  // Tabs
  const tabA = el("tabA"), tabB = el("tabB"), tabC = el("tabC");

  // Canvases
  const cv = el("cv");
  const cv2 = el("cv2");
  const ctx = cv.getContext("2d");
  const ctx2 = cv2.getContext("2d");

  // ---------- State ----------
  let running = false;
  let lastTs = 0;

  // simulation time
  let t = 0;

  // accumulators over time (these build the moving trace in Tab B)
  let tauGR = 0;
  let tauTR = 0;
  let tauTS = 0;

  let orbitsDone = 0;   // integer completed orbits
  let phasePrev = 0;    // last phase in [0,1)

  // CST display (phase-locked)
  let tauLocalDisplay = 0;
  let cstCorr = 0;

  // rolling history for Tab B animated traces
  let HIST_MAX = 700;
  const hist = { t:[], resGT:[], resGS:[] };

  // ---------- Formatting ----------
  function fmt(x, n=6){
    if (!isFinite(x)) return "—";
    const a = Math.abs(x);
    if (a !== 0 && (a < 1e-6 || a > 1e9)) return x.toExponential(Math.max(1,n-1));
    return x.toFixed(n);
  }

  function toggleUI(node, on){
    node.classList.toggle("on", !!on);
    node.setAttribute("aria-checked", on ? "true" : "false");
  }
  function isOn(node){ return node.classList.contains("on"); }

  // ✅ Central clamp: prevents accidental R <= 1 in any formula
  function clampR(R){
    if (!isFinite(R)) return R_HORIZON + EPS_R;
    return Math.max(R_HORIZON + EPS_R, R);
  }

  // ---------- Toy functions (now clamp-protected) ----------
  function Phi(R, p){
    const Rc = clampR(R);
    return 1 / Math.pow(Math.max(EPS, Rc), p);
  }
  function TorsionProfile(R){
    const Rc = clampR(R);
    return 1 / Math.pow(Math.max(EPS, Rc), 3);
  }

  function rateGR(R){
    // Schwarzschild: sqrt(1 - 1/R) with clamp for safety
    const Rc = clampR(R);
    return Math.sqrt(Math.max(0, 1 - 1/Rc));
  }
  function rateTransport(R, kappa, p){
    const Rc = clampR(R);
    return Math.exp(-kappa * Phi(Rc, p));
  }
  function rateTorsionSoft(R, alpha, n){
    const Rc = clampR(R);
    return Math.pow(1 + alpha*TorsionProfile(Rc), -n);
  }

  function orbitRadiusInstant(Rorb, e, phase01){
    // R(t)=Rorb*(1 - e cos(2πphase)), then clamp above 1+eps
    const Rraw = Rorb * (1 - e*Math.cos(2*Math.PI*phase01));
    return clampR(Math.max(1.001, Rraw));
  }

  // ---------- Parameters ----------
  function getParams(){
    const R = clampR(Number(inR.value));
    const Rorb = clampR(Number(inRorb.value));
    const P = Math.max(0.01, Number(inP.value));
    const Norbits = Math.max(1, Number(inNorbits.value));
    const e = Math.max(0, Math.min(0.95, Number(inEcc.value)));
    const kappa = Number(inK.value);
    const pPow = Number(inPpow.value);
    const alpha = Number(inAlpha.value);
    const nPow = Number(inNpow.value);
    const cst = isOn(togCST);
    const map = isOn(togMap);
    HIST_MAX = Math.max(200, Math.min(2000, Number(inHistLen.value)));
    return { R, Rorb, P, Norbits, e, kappa, pPow, alpha, nPow, cst, map };
  }

  // ---------- Explain ----------
  function updateExplain(p){
    const phiName = p.map ? "|Ψ|² (label)" : "Φ";
    const lines = [];
    lines.push("What to look for:");
    lines.push("• Tab A: compare the functional forms near R→1 (strong field).");
    lines.push("• Tab B: press Start — the residual traces animate as time advances and as orbits complete.");
    lines.push("• Tab C: see the underlying profiles " + phiName + "(R)=1/R^p and T(R)=1/R^3 (normalized).");
    lines.push("");
    lines.push("Equations:");
    lines.push("• GR: dτ/dt = √(1 − 1/R).");
    lines.push("• Transport: dτ/dt = exp(−κ " + phiName + "(R)), with " + phiName + "(R)=1/R^p.");
    lines.push("• Torsion-soft: dτ/dt = (1 + α T(R))^(−n), with T(R)=1/R^3.");
    lines.push("");
    lines.push("Protocol discipline (necessity framing):");
    lines.push("• Radii are clamped to R>1 to avoid horizon singular behavior in these toy laws.");
    lines.push("• Changing parameters resets accumulators to avoid mixing regimes.");
    lines.push("");
    lines.push("Limitations (regime-bound):");
    lines.push("• Toy comparative timing laws only (signatures/admissibility), not a complete gravity theory.");
    lines.push("• No self-consistent Einstein–Cartan solver; torsion is parameterized.");
    lines.push("• No EHT imaging (no ray-tracing/plasma emission).");
    explain.value = lines.join("\n");
  }

  // ---------- Drawing helpers ----------
  function clear(g,w,h){ g.clearRect(0,0,w,h); }
  function axes(g,w,h,pad=50){
    g.strokeStyle="rgba(255,255,255,.18)";
    g.lineWidth=1;
    g.beginPath();
    g.moveTo(pad, 14);
    g.lineTo(pad, h-pad);
    g.lineTo(w-14, h-pad);
    g.stroke();
  }
  function gridY(g,x0,y0,x1,y1,n=5){
    g.strokeStyle="rgba(255,255,255,.08)";
    for(let i=1;i<n;i++){
      const yy = y0 - (i/n)*(y0-y1);
      g.beginPath(); g.moveTo(x0,yy); g.lineTo(x1,yy); g.stroke();
    }
  }
  function dot(g,x,y,r=4,color="rgba(255,90,102,.95)"){
    g.fillStyle=color;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }

  // ---------- Tabs ----------
  let activeTab = "A";
  function setTab(which){
    activeTab = which;
    [tabA, tabB, tabC].forEach(x=>x.classList.remove("on"));
    if (which==="A") tabA.classList.add("on");
    if (which==="B") tabB.classList.add("on");
    if (which==="C") tabC.classList.add("on");
    renderAll();
  }
  tabA.onclick=()=>setTab("A");
  tabB.onclick=()=>setTab("B");
  tabC.onclick=()=>setTab("C");

  // ---------- Renderers ----------
  function renderRates(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    const Rmin = 1.001, Rmax = 30, S = 800;

    function X(R){ return x0 + (R-Rmin)/(Rmax-Rmin)*(x1-x0); }
    function Y(rate){ return y0 - rate*(y0-y1); } // rate in [0,1]

    function drawCurve(color, f){
      ctx.strokeStyle=color;
      ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<=S;i++){
        const R = Rmin + (i/S)*(Rmax-Rmin);
        const x = X(R), y = Y(f(R));
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    drawCurve("rgba(242,193,78,.95)", (R)=>rateGR(R));
    drawCurve("rgba(88,166,255,.95)", (R)=>rateTransport(R,p.kappa,p.pPow));
    drawCurve("rgba(53,208,127,.95)", (R)=>rateTorsionSoft(R,p.alpha,p.nPow));

    // markers
    dot(ctx, X(p.R), Y(rateGR(p.R)), 4, "rgba(255,90,102,.95)");
    dot(ctx, X(p.R), Y(rateTransport(p.R,p.kappa,p.pPow)), 4, "rgba(255,90,102,.75)");
    dot(ctx, X(p.R), Y(rateTorsionSoft(p.R,p.alpha,p.nPow)), 4, "rgba(255,90,102,.55)");

    // orbit radius vertical
    ctx.strokeStyle="rgba(255,90,102,.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(X(p.Rorb), y1);
    ctx.lineTo(X(p.Rorb), y0);
    ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab A: Time-rate laws vs R (probe markers + orbit radius line)", x0+10, y1+18);
  }

  function renderProfiles(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    const Rmin = 1.001, Rmax = 30, S = 800;
    const phiName = p.map ? "|Ψ|²" : "Φ";

    const phiNorm = Phi(Rmin, p.pPow);
    const tNorm = TorsionProfile(Rmin);

    function X(R){ return x0 + (R-Rmin)/(Rmax-Rmin)*(x1-x0); }
    function Y(z){ return y0 - z*(y0-y1); }

    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(88,166,255,.95)";
    ctx.beginPath();
    for(let i=0;i<=S;i++){
      const R = Rmin + (i/S)*(Rmax-Rmin);
      const z = Math.min(1, Phi(R,p.pPow)/Math.max(EPS,phiNorm));
      const x = X(R), y = Y(z);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.strokeStyle="rgba(53,208,127,.95)";
    ctx.beginPath();
    for(let i=0;i<=S;i++){
      const R = Rmin + (i/S)*(Rmax-Rmin);
      const z = Math.min(1, TorsionProfile(R)/Math.max(EPS,tNorm));
      const x = X(R), y = Y(z);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    dot(ctx, X(p.R), Y(Math.min(1, Phi(p.R,p.pPow)/phiNorm)), 5, "rgba(255,90,102,.95)");
    dot(ctx, X(p.R), Y(Math.min(1, TorsionProfile(p.R)/tNorm)), 5, "rgba(255,90,102,.65)");

    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab C: Profiles (normalized) — " + phiName + "(R) and T(R)", x0+10, y1+18);
  }

  function renderResidualHistory(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    const Nn = hist.t.length;
    if(Nn < 2){
      ctx.fillStyle="rgba(255,255,255,.85)";
      ctx.font="12px system-ui,Segoe UI,Arial";
      ctx.fillText("Tab B: Press Start. The residual history trace will build over time.", x0+10, y1+18);
      return;
    }

    const tMin = hist.t[0], tMax = hist.t[Nn-1];
    let maxAbs = 0;
    for(let i=0;i<Nn;i++){
      maxAbs = Math.max(maxAbs, Math.abs(hist.resGT[i]), Math.abs(hist.resGS[i]));
    }
    maxAbs = Math.max(1e-9, maxAbs);

    function X(tt){ return x0 + (tt-tMin)/Math.max(EPS,(tMax-tMin))*(x1-x0); }
    function Y(y){ return y0 - (y + maxAbs)/(2*maxAbs) * (y0-y1); }

    ctx.strokeStyle="rgba(255,255,255,.18)";
    ctx.beginPath(); ctx.moveTo(x0, Y(0)); ctx.lineTo(x1, Y(0)); ctx.stroke();

    ctx.strokeStyle="rgba(88,166,255,.95)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(X(hist.t[0]), Y(hist.resGT[0]));
    for(let i=1;i<Nn;i++) ctx.lineTo(X(hist.t[i]), Y(hist.resGT[i]));
    ctx.stroke();

    ctx.strokeStyle="rgba(53,208,127,.95)";
    ctx.beginPath();
    ctx.moveTo(X(hist.t[0]), Y(hist.resGS[0]));
    for(let i=1;i<Nn;i++) ctx.lineTo(X(hist.t[i]), Y(hist.resGS[i]));
    ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab B: Residual history vs time (animated) — Δτ = τ_GR − τ_model", x0+10, y1+18);
    ctx.fillStyle="rgba(88,166,255,.95)";
    ctx.fillText("blue: GR − Transport", x0+10, y1+36);
    ctx.fillStyle="rgba(53,208,127,.95)";
    ctx.fillText("green: GR − Torsion-soft", x0+10, y1+54);
  }

  function renderBarPanel(p){
    const w=cv2.width,h=cv2.height;
    ctx2.clearRect(0,0,w,h);

    const pad = 20, left = 300, barH = 22, gap = 16, top = 18;
    const W = w - left - pad;

    ctx2.font="13px system-ui,Segoe UI,Arial";
    ctx2.fillStyle="rgba(255,255,255,.85)";
    ctx2.fillText("Instantaneous values (probe) + accumulated residuals (orbit trace)", pad, top);

    function bar(y, label, val, maxVal, color){
      const v = Math.max(0, Math.min(val, maxVal));
      const bw = (v/maxVal) * W;

      ctx2.fillStyle="rgba(255,255,255,.75)";
      ctx2.fillText(label, pad, y+barH-6);

      ctx2.fillStyle="rgba(255,255,255,.10)";
      ctx2.fillRect(left,y,W,barH);

      ctx2.fillStyle=color;
      ctx2.fillRect(left,y,bw,barH);

      ctx2.strokeStyle="rgba(255,255,255,.18)";
      ctx2.strokeRect(left,y,W,barH);

      ctx2.fillStyle="rgba(255,255,255,.85)";
      ctx2.fillText(fmt(val, 9), left+W+10, y+barH-6);
    }

    const rGRp = rateGR(p.R);
    const rTRp = rateTransport(p.R,p.kappa,p.pPow);
    const rTSp = rateTorsionSoft(p.R,p.alpha,p.nPow);

    bar(top+34, "Probe GR rate √(1−1/R)", rGRp, 1.0, "rgba(242,193,78,.85)");
    bar(top+34+(barH+gap), "Probe Transport rate exp(−κΦ)", rTRp, 1.0, "rgba(88,166,255,.85)");
    bar(top+34+2*(barH+gap), "Probe Torsion-soft rate (1+αT)^−n", rTSp, 1.0, "rgba(53,208,127,.85)");

    const resGTnow = tauGR - tauTR;
    const resGSnow = tauGR - tauTS;
    const cap = Math.max(1e-9, Math.max(Math.abs(resGTnow), Math.abs(resGSnow), 1e-6));
    const showCap = Math.min(1.0, cap);

    bar(top+34+3*(barH+gap), "Accum Δτ (GR − Transport) (scaled)", Math.min(Math.abs(resGTnow), showCap), showCap, "rgba(88,166,255,.45)");
    bar(top+34+4*(barH+gap), "Accum Δτ (GR − Torsion) (scaled)", Math.min(Math.abs(resGSnow), showCap), showCap, "rgba(53,208,127,.45)");

    ctx2.fillStyle="rgba(255,255,255,.6)";
    ctx2.font="12px system-ui,Segoe UI,Arial";
    ctx2.fillText("Tip: Tab B shows the history traces. If you see no motion, press Start.", pad, h-18);
  }

  function renderAll(){
    const p = getParams();
    if (activeTab==="A") renderRates(p);
    if (activeTab==="B") renderResidualHistory(p);
    if (activeTab==="C") renderProfiles(p);
    renderBarPanel(p);
  }

  // ---------- CST overlay ----------
  function applyCSTDisplay(p){
    // CST here is a display convention: phase-lock a display clock to reference time
    if(!p.cst){
      tauLocalDisplay = t;
      cstCorr = 0;
      return;
    }
    tauLocalDisplay = t;
    cstCorr = 0;
  }

  // ---------- UI updates ----------
  function updateUI(p, phase01, Rinst, rGRi, rTRi, rTSi){
    ROut.textContent = fmt(p.R, 3);
    RorbOut.textContent = fmt(p.Rorb, 2);
    POut.textContent = fmt(p.P, 0);
    NorbitsOut.textContent = fmt(p.Norbits, 0);
    eccOut.textContent = fmt(p.e, 2);
    histLenOut.textContent = String(HIST_MAX);

    kappaOut.textContent = fmt(p.kappa, 3);
    pPowOut.textContent = fmt(p.pPow, 2);
    alphaOut.textContent = fmt(p.alpha, 3);
    nPowOut.textContent = fmt(p.nPow, 2);

    tOut.textContent = fmt(t, 2);
    orbitsDoneOut.textContent = String(orbitsDone);
    phaseOut.textContent = fmt(phase01, 2);

    ROut2.textContent = fmt(p.R, 6);
    RorbOut2.textContent = fmt(p.Rorb, 6);
    RinstOut.textContent = fmt(Rinst, 6);

    const phi = Phi(p.R,p.pPow);
    const tors = TorsionProfile(p.R);
    phiOut.textContent = fmt(phi, 9) + (p.map ? "  (label: |Ψ|²)" : "");
    torsOut.textContent = fmt(tors, 9);

    grInstOut.textContent = fmt(rGRi, 9);
    trInstOut.textContent = fmt(rTRi, 9);
    tsInstOut.textContent = fmt(rTSi, 9);

    resGT.textContent = fmt(tauGR - tauTR, 9) + " s";
    resGS.textContent = fmt(tauGR - tauTS, 9) + " s";

    cstOut.textContent = fmt(tauLocalDisplay, 6);
    cstCorrOut.textContent = fmt(cstCorr, 6);

    updateExplain(p);
  }

  // ---------- Main step ----------
  function step(dt){
    const p = getParams();
    t += dt;

    const phase01 = (t / p.P) - Math.floor(t / p.P);

    if (phase01 < phasePrev){
      orbitsDone += 1;
    }
    phasePrev = phase01;

    const Rinst = orbitRadiusInstant(p.Rorb, p.e, phase01);

    const rGRi = rateGR(Rinst);
    const rTRi = rateTransport(Rinst, p.kappa, p.pPow);
    const rTSi = rateTorsionSoft(Rinst, p.alpha, p.nPow);

    if (orbitsDone < p.Norbits){
      tauGR += rGRi * dt;
      tauTR += rTRi * dt;
      tauTS += rTSi * dt;
    }

    hist.t.push(t);
    hist.resGT.push(tauGR - tauTR);
    hist.resGS.push(tauGR - tauTS);

    while(hist.t.length > HIST_MAX){
      hist.t.shift(); hist.resGT.shift(); hist.resGS.shift();
    }

    applyCSTDisplay(p);
    updateUI(p, phase01, Rinst, rGRi, rTRi, rTSi);
    renderAll();
  }

  // ---------- Animation loop ----------
  function tick(ts){
    if(!running){ lastTs = ts; return; }
    const dt = Math.min(0.05, Math.max(0, (ts-lastTs)/1000));
    lastTs = ts;
    step(dt);
    requestAnimationFrame(tick);
  }

  // ---------- Print / Save ----------
  function escapeHtml(s){
    return String(s)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function makeCSV(){
    const p = getParams();
    const lines = [];
    lines.push("key,value");
    lines.push("timestamp_iso," + new Date().toISOString());
    lines.push("R_probe," + p.R);
    lines.push("R_orb," + p.Rorb);
    lines.push("P_seconds," + p.P);
    lines.push("N_target_orbits," + p.Norbits);
    lines.push("eccentricity," + p.e);
    lines.push("kappa," + p.kappa);
    lines.push("p_flux_power," + p.pPow);
    lines.push("alpha_torsion," + p.alpha);
    lines.push("n_torsion," + p.nPow);
    lines.push("mapping_mode," + (p.map ? "true" : "false"));
    lines.push("CST_on," + (p.cst ? "true" : "false"));
    lines.push("");
    lines.push("state,value");
    lines.push("t," + t);
    lines.push("orbits_done," + orbitsDone);
    lines.push("tauGR," + tauGR);
    lines.push("tauTR," + tauTR);
    lines.push("tauTS," + tauTS);
    lines.push("resGT," + (tauGR - tauTR));
    lines.push("resGS," + (tauGR - tauTS));
    lines.push("");
    lines.push("history_time_s,resGT,resGS");
    for(let i=0;i<hist.t.length;i++){
      lines.push(hist.t[i] + "," + hist.resGT[i] + "," + hist.resGS[i]);
    }
    return lines.join("\n");
  }

  function printData(){
    const p = getParams();
    const csv = makeCSV();
    const nowStr = new Date().toString();

    const html =
'<!doctype html><html><head><meta charset="utf-8" />' +
'<meta name="viewport" content="width=device-width,initial-scale=1" />' +
'<title>Timing Frontier — Printout</title>' +
'<style>' +
'body{font-family:system-ui,Segoe UI,Arial,sans-serif;margin:18px;color:#111}' +
'h1{font-size:18px;margin:0 0 10px}' +
'.muted{color:#555;font-size:12.5px}' +
'.box{border:1px solid #ccc;border-radius:10px;padding:12px;margin-top:12px}' +
'table{border-collapse:collapse;width:100%;font-size:12.5px;margin-top:8px}' +
'th,td{border:1px solid #ddd;padding:6px 8px;text-align:left}' +
'th{background:#f5f7fb}' +
'textarea{width:100%;min-height:240px;margin-top:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:11px}' +
'button{padding:10px 12px;border-radius:10px;border:1px solid #999;background:#f5f5f5;cursor:pointer;font-weight:700}' +
'.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}' +
'</style></head><body>' +
'<h1>Strong-Field Timing Frontier — Data Printout</h1>' +
'<div class="muted">Generated: ' + escapeHtml(nowStr) + '</div>' +
'<div class="muted" style="margin-top:6px"><b>Regime:</b> toy comparative timing laws only; not a self-consistent Einstein–Cartan solver; not EHT ray-tracing/plasma emission.</div>' +

'<div class="box"><b>Current settings</b>' +
'<table>' +
'<tr><th>Probe radius R</th><td>' + p.R + '</td></tr>' +
'<tr><th>Orbit radius R_orb</th><td>' + p.Rorb + '</td></tr>' +
'<tr><th>Orbit period P (s)</th><td>' + p.P + '</td></tr>' +
'<tr><th>N target orbits</th><td>' + p.Norbits + '</td></tr>' +
'<tr><th>eccentricity e</th><td>' + p.e + '</td></tr>' +
'<tr><th>κ (transport)</th><td>' + p.kappa + '</td></tr>' +
'<tr><th>p (flux)</th><td>' + p.pPow + '</td></tr>' +
'<tr><th>α (torsion)</th><td>' + p.alpha + '</td></tr>' +
'<tr><th>n (torsion)</th><td>' + p.nPow + '</td></tr>' +
'<tr><th>Mapping mode</th><td>' + (p.map ? "ON (Φ relabeled as |Ψ|²)" : "OFF") + '</td></tr>' +
'<tr><th>CST overlay</th><td>' + (p.cst ? "ON" : "OFF") + '</td></tr>' +
'</table>' +

'<div class="row">' +
'<button onclick="window.print()">Print / Save as PDF</button>' +
'<button onclick="downloadCSV()">Download CSV</button>' +
'</div>' +

'<div class="muted" style="margin-top:10px">CSV includes current parameters + residual history trace buffer.</div>' +
'<textarea id="csv" readonly>' + escapeHtml(csv) + '</textarea>' +
'</div>' +

'<script>' +
'function downloadCSV(){' +
'  var csv = document.getElementById("csv").value;' +
'  var blob = new Blob([csv], {type:"text/csv;charset=utf-8"});' +
'  var url = URL.createObjectURL(blob);' +
'  var a = document.createElement("a");' +
'  var ts = new Date().toISOString().replace(/[:.]/g,"-");' +
'  a.href = url;' +
'  a.download = "timing_frontier_data_" + ts + ".csv";' +
'  document.body.appendChild(a); a.click(); a.remove();' +
'  setTimeout(function(){ URL.revokeObjectURL(url); }, 500);' +
'}' +
'<\/script>' +
'</body></html>';

    const w = window.open("", "_blank", "noopener,noreferrer,width=980,height=740");
    if (!w){ alert("Pop-up blocked. Allow pop-ups to print/save data."); return; }
    w.document.open();
    w.document.write(html);
    w.document.close();
  }

  // ---------- Events ----------
  function toggleClick(node){
    toggleUI(node, !isOn(node));
    step(0);
  }
  togCST.onclick = ()=>toggleClick(togCST);
  togMap.onclick = ()=>toggleClick(togMap);

  function onParamChange(){
    running = false;
    lastTs = 0;

    t = 0;
    tauGR = 0; tauTR = 0; tauTS = 0;
    orbitsDone = 0;
    phasePrev = 0;

    hist.t.length = 0;
    hist.resGT.length = 0;
    hist.resGS.length = 0;

    step(0);
  }

  [inR,inRorb,inP,inNorbits,inEcc,inHistLen,inK,inPpow,inAlpha,inNpow].forEach(x=>{
    x.addEventListener("input", onParamChange);
    x.addEventListener("change", onParamChange);
  });

  btnStart.onclick = () => {
    if(!running){
      running = true;
      requestAnimationFrame((ts)=>{ lastTs = ts; requestAnimationFrame(tick); });
    }
  };
  btnPause.onclick = () => { running = false; };
  btnStep.onclick = () => { running = false; step(1); };

  function resetAll(){
    running = false;
    lastTs = 0;

    t = 0;
    tauGR = 0; tauTR = 0; tauTS = 0;
    orbitsDone = 0;
    phasePrev = 0;

    tauLocalDisplay = 0;
    cstCorr = 0;

    hist.t.length=0; hist.resGT.length=0; hist.resGS.length=0;
    step(0);
  }
  btnReset.onclick = resetAll;

  // ✅ Copy Summary now includes regime statement automatically
  btnCopy.onclick = async () => {
    const p = getParams();
    const regime =
"Regime / Non-Claims: toy comparative timing laws only (signatures/admissibility); not a self-consistent Einstein–Cartan solver; not EHT ray-tracing/plasma emission.";

    const text =
`Strong-Field Timing Frontier — Simulator Summary

${regime}

Equations:
  GR: dτ/dt = √(1 − 1/R)
  Transport: dτ/dt = exp(−κ Φ(R)), Φ(R)=1/R^p
  Torsion-soft: dτ/dt = (1 + α T(R))^(-n), T(R)=1/R^3

Settings:
  Probe R=${p.R}
  Orbit R_orb=${p.Rorb}
  Period P=${p.P} s
  Target orbits N=${p.Norbits}
  Eccentricity e=${p.e}

Transport:
  κ=${p.kappa}, p=${p.pPow}
Torsion-soft:
  α=${p.alpha}, n=${p.nPow}

State:
  t=${t.toFixed(3)} s
  orbits_done=${orbitsDone}
  τ_GR=${tauGR}
  τ_TR=${tauTR}
  τ_TS=${tauTS}
  Δτ(GR−TR)=${(tauGR-tauTR)}
  Δτ(GR−TS)=${(tauGR-tauTS)}

CST overlay: ${p.cst ? "ON" : "OFF"}
Mapping label: ${p.map ? "ON (|Ψ|² label)" : "OFF (Φ label)"}
`;
    try{
      await navigator.clipboard.writeText(text);
      btnCopy.textContent="Copied!";
      setTimeout(()=>btnCopy.textContent="Copy Summary", 900);
    } catch(e){
      alert("Copy failed (browser permission).");
    }
  };

  btnPrint.onclick = () => { running = false; printData(); };

  // Defaults
  inR.value = "2.200";
  inRorb.value = "6.00";
  inP.value = "57";
  inNorbits.value = "4";
  inEcc.value = "0.15";
  inHistLen.value = "700";
  inK.value = "4.0";
  inPpow.value = "2.0";
  inAlpha.value = "6.0";
  inNpow.value = "2.0";
  toggleUI(togCST, true);
  toggleUI(togMap, false);

  function updateLeftOutputs(){
    const p = getParams();
    ROut.textContent = fmt(p.R, 3);
    RorbOut.textContent = fmt(p.Rorb, 2);
    POut.textContent = fmt(p.P, 0);
    NorbitsOut.textContent = fmt(p.Norbits, 0);
    eccOut.textContent = fmt(p.e, 2);
    histLenOut.textContent = String(HIST_MAX);
    kappaOut.textContent = fmt(p.kappa, 3);
    pPowOut.textContent = fmt(p.pPow, 2);
    alphaOut.textContent = fmt(p.alpha, 3);
    nPowOut.textContent = fmt(p.nPow, 2);
  }
  updateLeftOutputs();

  setTab("A");
  resetAll();
})();
</script>
</body>
</html>
