<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Time as Kinetic Cadence + Beer–Lambert Attenuation (Reader Simulator) + CST Sync</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#101a2f;
    --panel2:#0c1426;
    --line:#203156;
    --ink:#eaf0ff;
    --muted:#a8b3d6;
    --brand:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 14px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:radial-gradient(circle at 20% 0%, #101b35 0, var(--bg) 55%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background:rgba(8,14,28,.85);
    position:sticky; top:0; z-index:2;
    backdrop-filter: blur(8px);
  }
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  header .sub{margin-top:4px;color:var(--muted);font-size:12.5px;line-height:1.35}

  main{
    display:grid;
    grid-template-columns:430px 1fr;
    gap:12px;
    padding:12px;
    max-width:1280px;
    margin:0 auto;
  }
  @media (max-width: 980px){
    main{grid-template-columns:1fr}
  }
  .panel{
    background:linear-gradient(180deg, rgba(16,26,47,.96), rgba(12,20,38,.92));
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .panel h2{margin:0 0 10px;font-size:14px;color:#dbe6ff}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  .hr{height:1px;background:var(--line);margin:10px 0}

  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="range"]{width:100%}
  input[type="number"], select, button, textarea{
    width:100%;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:#0a1222;
    color:var(--ink);
    outline:none;
  }
  button{
    cursor:pointer;
    background:linear-gradient(180deg, #112349, #0a1730);
    font-weight:700;
  }
  button:hover{border-color:#32529a}
  textarea{min-height:92px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px}

  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background:rgba(0,0,0,.18);
    font-size:12px;
    color:var(--muted);
  }

  .sw{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14);
    margin-top:10px;
  }
  .sw b{color:#dbe6ff;font-size:12.5px}
  .toggle{
    width:50px;height:28px;border-radius:999px;border:1px solid var(--line);
    background:#0a1222;position:relative;cursor:pointer;flex:0 0 auto;
  }
  .knob{position:absolute;top:3px;left:3px;width:22px;height:22px;border-radius:50%;background:#6076b9;transition:.18s}
  .toggle.on{background:#0b1f16;border-color:#1f5c3e}
  .toggle.on .knob{left:25px;background:var(--good)}

  .callout{
    border-left:4px solid var(--brand);
    padding:10px 12px;
    background:rgba(88,166,255,.10);
    border-radius:12px;
    margin-top:10px;
  }

  .kv{
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    margin-top:8px;
    padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14)
  }
  .kv div:nth-child(2n){
    text-align:right;
    color:#dbe6ff;
    font-variant-numeric:tabular-nums;
    white-space:nowrap;
  }

  .tabs{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
  .tab{
    padding:8px 10px;border:1px solid var(--line);border-radius:999px;
    background:rgba(0,0,0,.18);color:var(--muted);cursor:pointer;font-size:12px;
  }
  .tab.on{border-color:#32529a;color:#dbe6ff;background:rgba(88,166,255,.10)}

  canvas{
    width:100%;
    border:1px solid var(--line);
    border-radius:14px;
    background:linear-gradient(180deg, #070c18, #050a14);
  }
</style>
</head>
<body>
<header>
  <h1>Time Emerges from Change — Kinetic Cadence + Beer–Lambert Temporal Attenuation + CST Sync</h1>
  <div class="sub">
    Teaching simulator for readers: Frozen lattice (no change ⇒ no operational time) → kinetic events begin (mean free time ticks) → Beer–Lambert flux attenuation → exponential time dilation.
    Add CST as a synchronization overlay to keep an operational “shared time display.”
  </div>
</header>

<main>
  <!-- LEFT: Controls -->
  <section class="panel">
    <h2>1) Premise: Frozen lattice vs Kinetic substrate</h2>

    <div class="sw">
      <div>
        <b>Frozen lattice (no change)</b>
        <div class="small">When ON: vrms = 0 and event cadence stops → “time undefined” operationally (ticks halt).</div>
      </div>
      <div class="toggle" id="togFrozen" role="switch" aria-checked="false"><div class="knob"></div></div>
    </div>

    <div class="grid2">
      <div>
        <label>Mean free path λ (meters)</label>
        <input id="lambda" type="range" min="0.0001" max="10" step="0.0001" />
        <div class="row">
          <span class="pill">λ = <span id="lambdaOut"></span> m</span>
        </div>
      </div>
      <div>
        <label>RMS speed v<sub>rms</sub> (m/s)</label>
        <input id="vrms" type="range" min="0" max="3000" step="1" />
        <div class="row">
          <span class="pill">v<sub>rms</sub> = <span id="vrmsOut"></span> m/s</span>
        </div>
      </div>
    </div>

    <div class="callout">
      <div class="small">
        <b>Mean free time “tick”</b> (smallest local interval):<br/>
        τ = λ / v<sub>rms</sub><br/>
        If v<sub>rms</sub> → 0, τ → ∞ (no ticks). If nothing changes, time is not operationally defined.
      </div>
    </div>

    <div class="hr"></div>

    <h2>2) Beer–Lambert Flux Attenuation (1D depth)</h2>
    <div class="small">
      We model momentum/energy flux Φ moving into a medium. Transport/attenuation follows:
      dΦ/dx = −μ Φ ⇒ Φ(x)=Φ₀ e<sup>−μx</sup>.
      We connect local tick rate to flux: ν(x) ∝ Φ(x), so local time dilates as flux is attenuated.
    </div>

    <div class="grid2">
      <div>
        <label>Attenuation coefficient μ (1/m)</label>
        <input id="mu" type="range" min="0" max="5" step="0.0005" />
        <div class="row">
          <span class="pill">μ = <span id="muOut"></span> 1/m</span>
        </div>
      </div>
      <div>
        <label>Depth x (m)</label>
        <input id="depth" type="range" min="0" max="10" step="0.001" />
        <div class="row">
          <span class="pill">x = <span id="depthOut"></span> m</span>
        </div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Initial flux Φ₀ (arbitrary units)</label>
        <input id="phi0" type="range" min="0.1" max="10" step="0.01" />
        <div class="row">
          <span class="pill">Φ₀ = <span id="phi0Out"></span></span>
        </div>
      </div>
      <div>
        <label>Clock reference frequency ν₀ (ticks/sec)</label>
        <input id="nu0" type="range" min="0.1" max="20" step="0.01" />
        <div class="row">
          <span class="pill">ν₀ = <span id="nu0Out"></span> Hz</span>
        </div>
      </div>
    </div>

    <div class="hr"></div>

    <h2>3) Time-rate Model Switch</h2>
    <label>Time-rate law used for the local clock</label>
    <select id="law">
      <option value="beer">Beer–Lambert: dτ/dt₀ = e^{−μx}</option>
      <option value="gr">GR weak-field analog (for comparison): dτ/dt₀ ≈ √(1 − 2ψ) with ψ mapped from μx</option>
    </select>

    <div class="sw">
      <div>
        <b>CST synchronization overlay</b>
        <div class="small">Shows “raw local clock” AND a CST-synchronized display clock that stays aligned to the reference clock.</div>
      </div>
      <div class="toggle on" id="togCST" role="switch" aria-checked="true"><div class="knob"></div></div>
    </div>

    <div class="sw">
      <div>
        <b>Show event-count clock (N / ν₀)</b>
        <div class="small">Counts discrete ticks N and shows measured time t = N/ν₀ (event-based time).</div>
      </div>
      <div class="toggle on" id="togEvents" role="switch" aria-checked="true"><div class="knob"></div></div>
    </div>

    <div class="hr"></div>

    <h2>Run</h2>
    <div class="grid3">
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnStep">Step +1s</button>
    </div>
    <div class="grid2" style="margin-top:10px">
      <button id="btnReset">Reset</button>
      <button id="btnCopy">Copy Summary</button>
    </div>

    <div class="callout">
      <div class="small">
        <b>Suggested reader path:</b><br/>
        (1) Turn ON Frozen lattice → see “ticks halt”.<br/>
        (2) Turn it OFF, increase v<sub>rms</sub> → ticks begin.<br/>
        (3) Increase μ or depth x → flux falls exponentially, local time slows.<br/>
        (4) Toggle CST → see raw drift vs synchronized display.
      </div>
    </div>
  </section>

  <!-- RIGHT: Visualization -->
  <section class="panel">
    <h2>Visualization</h2>

    <div class="tabs">
      <div class="tab on" id="tabA">Clock drift vs time</div>
      <div class="tab" id="tabB">Flux profile Φ(x) + time-rate</div>
      <div class="tab" id="tabC">Tick cadence view (events)</div>
    </div>

    <canvas id="cv" width="1200" height="420" style="height:340px"></canvas>
    <canvas id="cv2" width="1200" height="300" style="height:260px;margin-top:12px"></canvas>

    <div class="hr"></div>

    <h2>Live Readout</h2>
    <div class="kv">
      <div>Reference time t₀ (s)</div><div><span id="t0Out">0.0</span></div>

      <div>Mean free time τ = λ / v<sub>rms</sub> (s)</div><div><span id="mftOut">—</span></div>

      <div>Flux at depth Φ(x)</div><div><span id="phiOut">—</span></div>
      <div>Local time rate dτ/dt₀ (raw)</div><div><span id="rateOut">—</span></div>

      <div>Reference clock τ<sub>ref</sub> (s)</div><div><span id="refClockOut">0.0</span></div>
      <div>Local clock τ<sub>local</sub> (raw) (s)</div><div><span id="localClockOut">0.0</span></div>
      <div>Raw drift (local − ref) (s)</div><div><span id="driftOut">0.0</span></div>

      <div>CST display τ<sub>local,CST</sub> (s)</div><div><span id="cstClockOut">0.0</span></div>
      <div>CST correction applied (s)</div><div><span id="cstCorrOut">0.0</span></div>

      <div>Event count N (local)</div><div><span id="NOut">0</span></div>
      <div>Measured time from events t = N/ν₀ (s)</div><div><span id="tFromNOut">0.0</span></div>
    </div>

    <div class="hr"></div>

    <h2>Explanation Panel (Reader-friendly)</h2>
    <textarea id="explain" readonly></textarea>
  </section>
</main>

<script>
(() => {
  const c = 299792458;
  const EPS = 1e-15;

  const el = (id)=>document.getElementById(id);

  // Toggles
  const togFrozen = el("togFrozen");
  const togCST = el("togCST");
  const togEvents = el("togEvents");

  // Inputs
  const inLambda = el("lambda");
  const inVrms = el("vrms");
  const inMu = el("mu");
  const inDepth = el("depth");
  const inPhi0 = el("phi0");
  const inNu0 = el("nu0");
  const law = el("law");

  // Outputs
  const lambdaOut = el("lambdaOut");
  const vrmsOut = el("vrmsOut");
  const muOut = el("muOut");
  const depthOut = el("depthOut");
  const phi0Out = el("phi0Out");
  const nu0Out = el("nu0Out");

  const t0Out = el("t0Out");
  const mftOut = el("mftOut");
  const phiOut = el("phiOut");
  const rateOut = el("rateOut");

  const refClockOut = el("refClockOut");
  const localClockOut = el("localClockOut");
  const driftOut = el("driftOut");
  const cstClockOut = el("cstClockOut");
  const cstCorrOut = el("cstCorrOut");

  const NOut = el("NOut");
  const tFromNOut = el("tFromNOut");

  const explain = el("explain");

  // Buttons
  const btnStart = el("btnStart");
  const btnPause = el("btnPause");
  const btnStep = el("btnStep");
  const btnReset = el("btnReset");
  const btnCopy = el("btnCopy");

  // Tabs
  const tabA = el("tabA"), tabB = el("tabB"), tabC = el("tabC");

  // Canvases
  const cv = el("cv");
  const cv2 = el("cv2");
  const ctx = cv.getContext("2d");
  const ctx2 = cv2.getContext("2d");

  // State
  let running = false;
  let lastTs = 0;

  let t0 = 0;            // reference coordinate time (seconds)
  let tauRef = 0;        // reference clock time (seconds) -- runs at rate 1
  let tauLocal = 0;      // local raw proper time
  let tauLocalCST = 0;   // CST display time
  let cstCorr = 0;       // total correction applied

  let N = 0;             // event count (local)
  let tickAccumulator = 0;

  const HIST_MAX = 700;
  const hist = { t:[], drift:[], driftCST:[], rate:[], phi:[] };

  // Formatting
  function fmt(x, n=3){
    if (!isFinite(x)) return "—";
    const a = Math.abs(x);
    if (a !== 0 && (a < 1e-6 || a > 1e9)) return x.toExponential(Math.max(1, n-1));
    return x.toFixed(n);
  }

  function toggleUI(node, on){
    node.classList.toggle("on", !!on);
    node.setAttribute("aria-checked", on ? "true" : "false");
  }
  function isOn(node){ return node.classList.contains("on"); }

  // Tabs
  let activeTab = "A";
  function setTab(which){
    activeTab = which;
    [tabA, tabB, tabC].forEach(x=>x.classList.remove("on"));
    if (which==="A") tabA.classList.add("on");
    if (which==="B") tabB.classList.add("on");
    if (which==="C") tabC.classList.add("on");
    renderAll(); // redraw
  }
  tabA.onclick=()=>setTab("A");
  tabB.onclick=()=>setTab("B");
  tabC.onclick=()=>setTab("C");

  // Physics: mean free time
  function meanFreeTime(lambda, vrms){
    if (vrms <= 0) return Infinity;
    return lambda / vrms;
  }

  // Beer–Lambert flux
  function fluxAt(phi0, mu, x){
    return phi0 * Math.exp(-mu * x);
  }

  // Time-rate law
  // Beer: rate = exp(-mu x)
  // GR analog: rate ≈ sqrt(1 - 2ψ) with ψ mapped from mu*x (bounded)
  function timeRate(mu, x){
    if (law.value === "beer"){
      return Math.exp(-mu * x);
    }
    // GR analog mapping (teaching-only):
    // Let ψ = clamp(mu*x / 4, 0, 0.49) so inside sqrt positive and shows curvature-like behavior
    const psi = Math.min(0.49, Math.max(0, (mu * x) / 4));
    return Math.sqrt(Math.max(0, 1 - 2*psi));
  }

  function updateExplain(p){
    const lines = [];
    lines.push("Reader Guide — What you are seeing");
    lines.push("");
    lines.push("1) Frozen lattice:");
    lines.push("   - If Frozen lattice is ON, v_rms = 0 ⇒ no kinetic exchange ⇒ no operational ticks.");
    lines.push("   - That means the event-based clock cannot advance (time becomes 'undefined' operationally).");
    lines.push("");
    lines.push("2) Mean free time tick:");
    lines.push("   - τ_mft = λ / v_rms sets a minimal causal interval for local state updates.");
    lines.push("   - Higher v_rms → smaller τ_mft → faster cadence of events.");
    lines.push("");
    lines.push("3) Beer–Lambert temporal attenuation:");
    lines.push("   - Flux attenuates into a medium: Φ(x) = Φ0 e^(−μx).");
    lines.push("   - If tick rate ν(x) ∝ Φ(x), then local time rate falls with depth.");
    lines.push("");
    lines.push("4) Local time rate:");
    lines.push("   - Beer mode uses: dτ/dt0 = e^(−μx).");
    lines.push("   - GR-analog mode maps μx into a √(1 − 2ψ) form only for comparison.");
    lines.push("");
    lines.push("5) CST overlay:");
    lines.push("   - Raw local clock τ_local drifts relative to reference τ_ref.");
    lines.push("   - CST ON displays a synchronized clock τ_local,CST that stays aligned to τ_ref.");
    lines.push("   - The 'CST correction' shows how much adjustment is required to remain coherent.");
    lines.push("");
    lines.push("Try this:");
    lines.push(" - Turn Frozen lattice ON: notice N stops, τ_local stops.");
    lines.push(" - Turn it OFF, raise v_rms: event cadence increases.");
    lines.push(" - Increase μ or depth x: flux and time-rate shrink exponentially.");
    lines.push(" - Toggle CST: drift becomes a correction instead of an accumulating mismatch.");
    explain.value = lines.join("\n");
  }

  function getParams(){
    const frozen = isOn(togFrozen);
    const cst = isOn(togCST);
    const events = isOn(togEvents);

    const lambda = Number(inLambda.value);
    const vrms = frozen ? 0 : Number(inVrms.value);
    const mu = Number(inMu.value);
    const depth = Number(inDepth.value);
    const phi0 = Number(inPhi0.value);
    const nu0 = Number(inNu0.value);

    const mft = meanFreeTime(lambda, vrms);
    const phi = fluxAt(phi0, mu, depth);
    const rate = frozen ? 0 : timeRate(mu, depth);

    return { frozen, cst, events, lambda, vrms, mu, depth, phi0, nu0, mft, phi, rate };
  }

  // CST: phase-lock display clock to reference
  function applyCST(p){
    if (!p.cst){
      tauLocalCST = tauLocal;
      cstCorr = 0;
      return;
    }
    const drift = (tauLocal - tauRef);
    tauLocalCST = tauLocal - drift; // = tauRef
    cstCorr = -drift;
  }

  // Event ticks (discrete)
  function advanceEvents(p, dt){
    if (!p.events) return;

    // If frozen or no cadence, do nothing
    if (!isFinite(p.mft) || p.mft <= 0 || p.mft === Infinity) return;

    // We let event opportunity scale with local time-rate (attenuation reduces ticks per ref second)
    // Effective mean-free tick interval in reference time:
    //   dt0 per event ≈ τ_mft / rate
    // If rate is very small, events become extremely rare.
    const eff = p.mft / Math.max(EPS, p.rate);

    tickAccumulator += dt;
    while (tickAccumulator >= eff){
      tickAccumulator -= eff;
      N += 1;
    }
  }

  // Main step
  function step(dt){
    const p = getParams();

    // UI out
    lambdaOut.textContent = fmt(p.lambda, 4);
    vrmsOut.textContent = fmt(p.vrms, 0);
    muOut.textContent = fmt(p.mu, 4);
    depthOut.textContent = fmt(p.depth, 3);
    phi0Out.textContent = fmt(p.phi0, 2);
    nu0Out.textContent = fmt(p.nu0, 2);

    // advance reference time and ref clock
    t0 += dt;
    tauRef += dt; // reference clock runs at 1

    // advance local raw clock by its time rate
    tauLocal += p.rate * dt;

    // events
    advanceEvents(p, dt);

    // CST
    applyCST(p);

    // history
    const drift = tauLocal - tauRef;
    const driftCST = tauLocalCST - tauRef;

    hist.t.push(t0);
    hist.drift.push(drift);
    hist.driftCST.push(driftCST);
    hist.rate.push(p.rate);
    hist.phi.push(p.phi);
    if (hist.t.length > HIST_MAX){
      hist.t.shift(); hist.drift.shift(); hist.driftCST.shift(); hist.rate.shift(); hist.phi.shift();
    }

    // readouts
    t0Out.textContent = fmt(t0, 1);
    mftOut.textContent = isFinite(p.mft) ? fmt(p.mft, 6) : "∞ (no ticks)";
    phiOut.textContent = fmt(p.phi, 6);
    rateOut.textContent = fmt(p.rate, 9);

    refClockOut.textContent = fmt(tauRef, 6);
    localClockOut.textContent = fmt(tauLocal, 6);
    driftOut.textContent = fmt(drift, 9);

    cstClockOut.textContent = fmt(tauLocalCST, 6);
    cstCorrOut.textContent = fmt(cstCorr, 9);

    NOut.textContent = String(N);
    const tFromN = (p.nu0 > 0) ? (N / p.nu0) : 0;
    tFromNOut.textContent = fmt(tFromN, 6);

    updateExplain(p);
    renderAll();
  }

  // Drawing helpers
  function clear(g, w, h){ g.clearRect(0,0,w,h); }

  function axes(g, w, h, pad=50){
    g.strokeStyle = "rgba(255,255,255,.18)";
    g.lineWidth = 1;
    g.beginPath();
    g.moveTo(pad, 14);
    g.lineTo(pad, h-pad);
    g.lineTo(w-14, h-pad);
    g.stroke();
  }

  function gridY(g, x0,y0,x1,y1, n=5){
    g.strokeStyle = "rgba(255,255,255,.08)";
    for(let i=1;i<n;i++){
      const yy = y0 - (i/n)*(y0-y1);
      g.beginPath(); g.moveTo(x0,yy); g.lineTo(x1,yy); g.stroke();
    }
  }

  function renderAll(){
    const p = getParams();
    if (activeTab === "A") renderDrift();
    if (activeTab === "B") renderFluxProfile();
    if (activeTab === "C") renderCadence();
    renderBars(p);
  }

  function renderDrift(){
    const w = cv.width, h = cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50, x0=pad, y0=h-pad, x1=w-14, y1=14;

    const Nn = hist.t.length;
    if (Nn < 2) return;

    const tMin = hist.t[0], tMax = hist.t[Nn-1];
    const all = hist.drift.concat(hist.driftCST);
    let dMin = Math.min(...all), dMax = Math.max(...all);
    if (Math.abs(dMax-dMin) < 1e-9){ dMin -= 1; dMax += 1; }

    gridY(ctx,x0,y0,x1,y1,5);

    function X(t){ return x0 + (t-tMin)/Math.max(EPS,(tMax-tMin))*(x1-x0); }
    function Y(d){ return y0 - (d-dMin)/Math.max(EPS,(dMax-dMin))*(y0-y1); }

    // raw drift
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(242,193,78,.95)";
    ctx.beginPath();
    ctx.moveTo(X(hist.t[0]), Y(hist.drift[0]));
    for(let i=1;i<Nn;i++) ctx.lineTo(X(hist.t[i]), Y(hist.drift[i]));
    ctx.stroke();

    // CST drift
    ctx.strokeStyle="rgba(53,208,127,.95)";
    ctx.beginPath();
    ctx.moveTo(X(hist.t[0]), Y(hist.driftCST[0]));
    for(let i=1;i<Nn;i++) ctx.lineTo(X(hist.t[i]), Y(hist.driftCST[i]));
    ctx.stroke();

    // labels
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Clock drift vs time", x0+10, y1+18);
    ctx.fillStyle="rgba(242,193,78,.95)";
    ctx.fillText("Raw drift (τ_local − τ_ref)", x0+10, y1+36);
    ctx.fillStyle="rgba(53,208,127,.95)";
    ctx.fillText("CST display drift (τ_local,CST − τ_ref)", x0+10, y1+54);

    ctx.fillStyle="rgba(255,255,255,.55)";
    ctx.fillText(fmt(dMax,3), 10, y1+10);
    ctx.fillText(fmt(dMin,3), 10, y0);
  }

  function renderFluxProfile(){
    const w = cv.width, h = cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50, x0=pad, y0=h-pad, x1=w-14, y1=14;

    const p = getParams();
    const phi0 = p.phi0;
    const mu = p.mu;
    const maxX = Math.max(0.001, Number(inDepth.max)); // show full slider range

    // plot Φ(x) and rate(x) from 0..maxX
    const S = 240;
    const pts = [];
    for(let i=0;i<=S;i++){
      const x = (i/S)*maxX;
      const phi = fluxAt(phi0, mu, x);
      const rate = (isOn(togFrozen) ? 0 : timeRate(mu, x));
      pts.push({x, phi, rate});
    }

    const phiMax = phi0;
    const rateMax = 1.0;

    gridY(ctx,x0,y0,x1,y1,5);

    function X(x){ return x0 + x/maxX*(x1-x0); }
    function Yphi(phi){ return y0 - (phi/Math.max(EPS,phiMax))*(y0-y1); }
    function Yrate(r){ return y0 - (r/Math.max(EPS,rateMax))*(y0-y1); }

    // Φ curve
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(88,166,255,.95)";
    ctx.beginPath();
    ctx.moveTo(X(pts[0].x), Yphi(pts[0].phi));
    for(let i=1;i<pts.length;i++) ctx.lineTo(X(pts[i].x), Yphi(pts[i].phi));
    ctx.stroke();

    // rate curve
    ctx.strokeStyle="rgba(242,193,78,.95)";
    ctx.beginPath();
    ctx.moveTo(X(pts[0].x), Yrate(pts[0].rate));
    for(let i=1;i<pts.length;i++) ctx.lineTo(X(pts[i].x), Yrate(pts[i].rate));
    ctx.stroke();

    // marker at current depth
    const x = p.depth;
    const phi = p.phi;
    const r = p.rate;
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.beginPath(); ctx.arc(X(x), Yphi(phi), 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(X(x), Yrate(r), 4, 0, Math.PI*2); ctx.fill();

    // labels
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillText("Flux Φ(x) and time-rate vs depth x", x0+10, y1+18);
    ctx.fillStyle="rgba(88,166,255,.95)";
    ctx.fillText("Φ(x)=Φ0 e^(−μx)", x0+10, y1+36);
    ctx.fillStyle="rgba(242,193,78,.95)";
    ctx.fillText("time-rate dτ/dt0 (law toggle)", x0+10, y1+54);

    ctx.fillStyle="rgba(255,255,255,.55)";
    ctx.fillText("x=0", x0, y0+18);
    ctx.fillText("x=max", x1-48, y0+18);
  }

  function renderCadence(){
    const w = cv.width, h = cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50, x0=pad, y0=h-pad, x1=w-14, y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    // Show an intuitive "tick train" for last ~10 seconds
    const p = getParams();
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillText("Tick cadence view (events) — spacing grows when attenuation is strong or vrms is low", x0+10, y1+18);

    const span = 10; // seconds window
    const tStart = Math.max(0, t0 - span);
    const tEnd = t0;

    // We can't reconstruct every tick time without storing; so we visualize cadence as effective tick interval now:
    // effective dt per event = (λ/vrms) / rate
    const mft = p.mft;
    const eff = (isFinite(mft) ? (mft / Math.max(EPS,p.rate)) : Infinity);

    // Draw baseline
    ctx.strokeStyle="rgba(255,255,255,.18)";
    ctx.beginPath(); ctx.moveTo(x0, (y0+y1)/2); ctx.lineTo(x1, (y0+y1)/2); ctx.stroke();

    // Draw ticks from right to left with spacing = eff (capped)
    const mid = (y0+y1)/2;
    const pxPerSec = (x1-x0) / span;
    let xPos = x1;
    let count = 0;
    const maxTicks = 250;

    const effCap = Math.min(eff, 2.0); // cap so it's readable
    while (xPos >= x0 && count < maxTicks){
      ctx.strokeStyle = "rgba(53,208,127,.85)";
      ctx.beginPath();
      ctx.moveTo(xPos, mid-18);
      ctx.lineTo(xPos, mid+18);
      ctx.stroke();

      xPos -= effCap * pxPerSec;
      count++;
      if (!isFinite(eff)) break;
      if (effCap <= 0) break;
    }

    ctx.fillStyle="rgba(255,255,255,.65)";
    ctx.fillText(`effective tick interval (reference seconds) ≈ (λ/v_rms)/rate = ${fmt(eff,6)} s`, x0+10, mid+40);
    ctx.fillText(`(display capped at 2.0 s per tick for visibility)`, x0+10, mid+56);

    if (p.frozen){
      ctx.fillStyle="rgba(255,90,102,.9)";
      ctx.fillText("Frozen lattice ON: no ticks (time operationally halts).", x0+10, mid-40);
    }
  }

  function renderBars(p){
    const w = cv2.width, h = cv2.height;
    clear(ctx2,w,h);

    const pad = 20;
    const left = 260;
    const barH = 22;
    const gap = 16;
    const top = 18;

    ctx2.font="13px system-ui,Segoe UI,Arial";
    ctx2.fillStyle="rgba(255,255,255,.85)";
    ctx2.fillText("Instantaneous values at current settings", pad, top);

    const W = w - left - pad;

    function bar(y, label, val, maxVal, color){
      const v = Math.max(0, Math.min(val, maxVal));
      const bw = (v/maxVal) * W;

      ctx2.fillStyle="rgba(255,255,255,.75)";
      ctx2.fillText(label, pad, y+barH-6);

      ctx2.fillStyle="rgba(255,255,255,.10)";
      ctx2.fillRect(left,y,W,barH);

      ctx2.fillStyle=color;
      ctx2.fillRect(left,y,bw,barH);

      ctx2.strokeStyle="rgba(255,255,255,.18)";
      ctx2.strokeRect(left,y,W,barH);

      ctx2.fillStyle="rgba(255,255,255,.85)";
      ctx2.fillText(fmt(val, 9), left+W+10, y+barH-6);
    }

    bar(top+34, "Flux Φ(x) / Φ0", (p.phi / Math.max(EPS,p.phi0)), 1.0, "rgba(88,166,255,.85)");
    bar(top+34+(barH+gap), "Time-rate dτ/dt0", p.rate, 1.0, "rgba(242,193,78,.85)");

    // mft (scaled)
    const mftShow = isFinite(p.mft) ? Math.min(p.mft, 2.0) : 2.0;
    bar(top+34+2*(barH+gap), "Mean free time τ_mft (capped at 2s)", mftShow, 2.0, "rgba(53,208,127,.65)");

    // drift magnitude hint (scaled)
    const drift = tauLocal - tauRef;
    const driftAbs = Math.min(Math.abs(drift), 1.0);
    bar(top+34+3*(barH+gap), "Raw drift |τ_local − τ_ref| (capped at 1s)", driftAbs, 1.0, "rgba(255,90,102,.65)");

    ctx2.fillStyle="rgba(255,255,255,.6)";
    ctx2.font="12px system-ui,Segoe UI,Arial";
    ctx2.fillText("Tip: Increase μ or depth x to reduce Φ(x) and slow the local clock exponentially (Beer mode).", pad, h-18);
  }

  // Run loop
  function tick(ts){
    if (!running){ lastTs = ts; return; }
    const dt = Math.min(0.05, Math.max(0, (ts-lastTs)/1000));
    lastTs = ts;
    step(dt);
    requestAnimationFrame(tick);
  }

  // Buttons
  btnStart.onclick = () => {
    if (!running){
      running = true;
      requestAnimationFrame((ts)=>{ lastTs=ts; requestAnimationFrame(tick); });
    }
  };
  btnPause.onclick = () => { running = false; };
  btnStep.onclick = () => { running = false; step(1); };

  function resetAll(){
    running = false;
    lastTs = 0;
    t0 = 0;
    tauRef = 0;
    tauLocal = 0;
    tauLocalCST = 0;
    cstCorr = 0;
    N = 0;
    tickAccumulator = 0;
    hist.t.length=0; hist.drift.length=0; hist.driftCST.length=0; hist.rate.length=0; hist.phi.length=0;
    step(0);
  }
  btnReset.onclick = resetAll;

  btnCopy.onclick = async () => {
    const p = getParams();
    const text =
`Kinetic Time + Beer–Lambert Simulator Summary

Frozen lattice: ${p.frozen ? "ON (no operational ticks)" : "OFF"}
Law: ${law.value === "beer" ? "Beer–Lambert rate e^(−μx)" : "GR analog √(1−2ψ) mapped from μx"}
CST: ${p.cst ? "ON (phase-locked display)" : "OFF"}
Event-count clock: ${p.events ? "ON" : "OFF"}

Inputs:
  λ=${p.lambda} m
  v_rms=${p.vrms} m/s
  τ_mft=λ/v_rms=${isFinite(p.mft)?p.mft:"Infinity"} s
  μ=${p.mu} 1/m
  x=${p.depth} m
  Φ0=${p.phi0}
  ν0=${p.nu0} Hz

Instant:
  Φ(x)=${p.phi}
  time-rate dτ/dt0=${p.rate}

State:
  t0=${t0.toFixed(3)} s
  τ_ref=${tauRef.toFixed(6)} s
  τ_local(raw)=${tauLocal.toFixed(6)} s
  drift(raw)=${(tauLocal-tauRef).toExponential(6)} s
  τ_local(CST)=${tauLocalCST.toFixed(6)} s
  CST correction=${cstCorr.toExponential(6)} s
  N=${N}
  t_from_events=N/ν0=${(p.nu0>0?(N/p.nu0):0).toFixed(6)} s
`;
    try{
      await navigator.clipboard.writeText(text);
      btnCopy.textContent="Copied!";
      setTimeout(()=>btnCopy.textContent="Copy Summary", 900);
    } catch(e){
      alert("Copy failed (browser permission).");
    }
  };

  // Toggles click
  function toggleClick(node){
    toggleUI(node, !isOn(node));
    step(0);
  }
  togFrozen.onclick = ()=>toggleClick(togFrozen);
  togCST.onclick = ()=>toggleClick(togCST);
  togEvents.onclick = ()=>toggleClick(togEvents);

  // Inputs redraw
  [inLambda,inVrms,inMu,inDepth,inPhi0,inNu0,law].forEach(x=>{
    x.addEventListener("input", ()=>step(0));
    x.addEventListener("change", ()=>step(0));
  });

  // Defaults
  inLambda.value = "0.10";
  inVrms.value = "800";
  inMu.value = "0.40";
  inDepth.value = "2.50";
  inPhi0.value = "1.00";
  inNu0.value = "10.00";
  law.value = "beer";
  toggleUI(togFrozen, false);
  toggleUI(togCST, true);
  toggleUI(togEvents, true);

  resetAll();
  setTab("A");
})();
</script>
</body>
</html>
