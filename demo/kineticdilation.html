<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Strong-Field Timing Frontier — Exponential Transport vs GR vs Torsion-Softened (Reader Simulator) + CST</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#101a2f;
    --panel2:#0c1426;
    --line:#203156;
    --ink:#eaf0ff;
    --muted:#a8b3d6;
    --brand:#58a6ff;
    --good:#35d07f;
    --warn:#f2c14e;
    --bad:#ff5a66;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 14px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:radial-gradient(circle at 20% 0%, #101b35 0, var(--bg) 55%);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background:rgba(8,14,28,.85);
    position:sticky; top:0; z-index:2;
    backdrop-filter: blur(8px);
  }
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  header .sub{margin-top:4px;color:var(--muted);font-size:12.5px;line-height:1.35}

  main{
    display:grid;
    grid-template-columns:430px 1fr;
    gap:12px;
    padding:12px;
    max-width:1320px;
    margin:0 auto;
  }
  @media (max-width: 980px){
    main{grid-template-columns:1fr}
  }
  .panel{
    background:linear-gradient(180deg, rgba(16,26,47,.96), rgba(12,20,38,.92));
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }
  .panel h2{margin:0 0 10px;font-size:14px;color:#dbe6ff}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  .hr{height:1px;background:var(--line);margin:10px 0}

  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input[type="range"]{width:100%}
  input[type="number"], select, button, textarea{
    width:100%;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:#0a1222;
    color:var(--ink);
    outline:none;
  }
  button{
    cursor:pointer;
    background:linear-gradient(180deg, #112349, #0a1730);
    font-weight:700;
  }
  button:hover{border-color:#32529a}
  textarea{
    min-height:130px; resize:vertical;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px
  }

  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background:rgba(0,0,0,.18);
    font-size:12px;
    color:var(--muted);
    font-variant-numeric:tabular-nums;
  }

  .sw{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14);
    margin-top:10px;
  }
  .sw b{color:#dbe6ff;font-size:12.5px}
  .toggle{
    width:50px;height:28px;border-radius:999px;border:1px solid var(--line);
    background:#0a1222;position:relative;cursor:pointer;flex:0 0 auto;
  }
  .knob{position:absolute;top:3px;left:3px;width:22px;height:22px;border-radius:50%;background:#6076b9;transition:.18s}
  .toggle.on{background:#0b1f16;border-color:#1f5c3e}
  .toggle.on .knob{left:25px;background:var(--good)}

  .callout{
    border-left:4px solid var(--brand);
    padding:10px 12px;
    background:rgba(88,166,255,.10);
    border-radius:12px;
    margin-top:10px;
  }

  .kv{
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    margin-top:8px;
    padding:10px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.14)
  }
  .kv div:nth-child(2n){
    text-align:right;
    color:#dbe6ff;
    font-variant-numeric:tabular-nums;
    white-space:nowrap;
  }

  .tabs{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
  .tab{
    padding:8px 10px;border:1px solid var(--line);border-radius:999px;
    background:rgba(0,0,0,.18);color:var(--muted);cursor:pointer;font-size:12px;
  }
  .tab.on{border-color:#32529a;color:#dbe6ff;background:rgba(88,166,255,.10)}

  canvas{
    width:100%;
    border:1px solid var(--line);
    border-radius:14px;
    background:linear-gradient(180deg, #070c18, #050a14);
  }

  .legend{
    display:flex;gap:10px;flex-wrap:wrap;margin-top:8px
  }
  .leg{
    display:inline-flex;align-items:center;gap:8px;
    border:1px solid var(--line);border-radius:999px;padding:6px 10px;
    background:rgba(0,0,0,.16);color:var(--muted);font-size:12px
  }
  .swatch{width:12px;height:12px;border-radius:3px;display:inline-block}
  .note{font-size:12px;color:var(--muted);line-height:1.4}
</style>
</head>

<body>
<header>
  <h1>Strong-Field Timing Frontier — Transport-First (Exponential) vs GR vs Torsion-Softened + CST</h1>
  <div class="sub">
    Reader teaching simulator: compare three time-rate laws near a black hole (toy models).
    Focus is <b>timing signatures</b> (pulsar clocks), not EHT ray-tracing images. CST overlay shows a synchronized display clock.
  </div>
</header>

<main>
  <!-- LEFT: Controls -->
  <section class="panel">
    <h2>1) Geometry: compact object + orbit (toy)</h2>
    <div class="small">
      We use a dimensionless radius <b>R = r/r<sub>s</sub></b> (Schwarzschild radius units). GR horizon is at R=1.
      You can place a mock pulsar orbit at R<sub>orb</sub> and see accumulated timing differences.
    </div>

    <div class="grid2">
      <div>
        <label>Radius R = r/r<sub>s</sub> (probe location for curves)</label>
        <input id="R" type="range" min="1.001" max="30" step="0.001" />
        <div class="row"><span class="pill">R = <span id="ROut"></span></span></div>
      </div>
      <div>
        <label>Orbit radius R<sub>orb</sub> (mock pulsar)</label>
        <input id="Rorb" type="range" min="1.05" max="30" step="0.01" />
        <div class="row"><span class="pill">R<sub>orb</sub> = <span id="RorbOut"></span></span></div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Orbit period P (seconds, simulation time)</label>
        <input id="P" type="range" min="1" max="120" step="1" />
        <div class="row"><span class="pill">P = <span id="POut"></span> s</span></div>
      </div>
      <div>
        <label>Number of orbits to accumulate</label>
        <input id="Norbits" type="range" min="1" max="60" step="1" />
        <div class="row"><span class="pill">N = <span id="NorbitsOut"></span></span></div>
      </div>
    </div>

    <div class="hr"></div>

    <h2>2) Model knobs: Transport vs Torsion</h2>
    <div class="small">
      <b>Transport-first:</b> time rate saturates exponentially via attenuation of causal flux Φ.<br/>
      <b>Geometry-first:</b> torsion introduces a softening scale that can avoid singular behavior (phenomenological).
    </div>

    <div class="grid2">
      <div>
        <label>Transport attenuation strength κ (dimensionless)</label>
        <input id="kappa" type="range" min="0" max="12" step="0.001" />
        <div class="row"><span class="pill">κ = <span id="kappaOut"></span></span></div>
      </div>
      <div>
        <label>Flux profile shape p (Φ ∝ 1/R<sup>p</sup>)</label>
        <input id="pPow" type="range" min="0" max="6" step="0.01" />
        <div class="row"><span class="pill">p = <span id="pPowOut"></span></span></div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label>Torsion softening α (dimensionless)</label>
        <input id="alpha" type="range" min="0" max="20" step="0.001" />
        <div class="row"><span class="pill">α = <span id="alphaOut"></span></span></div>
      </div>
      <div>
        <label>Torsion exponent n (power)</label>
        <input id="nPow" type="range" min="0.1" max="8" step="0.01" />
        <div class="row"><span class="pill">n = <span id="nPowOut"></span></span></div>
      </div>
    </div>

    <div class="callout">
      <div class="small">
        <b>Phenomenological choices (transparent):</b><br/>
        GR (Schwarzschild): dτ/dt = √(1 − 1/R).<br/>
        Transport-first (exponential): dτ/dt = exp(−κ Φ(R)), with Φ(R)=1/R<sup>p</sup>.<br/>
        Torsion-softened (toy): dτ/dt = [1 + α T(R)]<sup>−n</sup>, with T(R)=1/R<sup>3</sup> (spin/torsion-like falloff).
      </div>
    </div>

    <div class="hr"></div>

    <h2>3) What the simulation can / can’t claim</h2>
    <div class="small">
      <b>Can do:</b> compare functional forms, show near-horizon saturation vs divergence trends, and show timing residual accumulation on a mock orbit.<br/>
      <b>Cannot do (HTML limit):</b> solve Einstein–Cartan field equations self-consistently, or reproduce EHT radiative transfer / ray-tracing.
    </div>

    <div class="sw">
      <div>
        <b>CST synchronization overlay</b>
        <div class="small">Displays raw local proper time and a synchronized “display clock” aligned to the reference time.</div>
      </div>
      <div class="toggle on" id="togCST" role="switch" aria-checked="true"><div class="knob"></div></div>
    </div>

    <div class="sw">
      <div>
        <b>Show mapping mode (Φ ↔ |Ψ|² label)</b>
        <div class="small">Purely interpretive: relabel Φ as activation density. Does not change math.</div>
      </div>
      <div class="toggle" id="togMap" role="switch" aria-checked="false"><div class="knob"></div></div>
    </div>

    <div class="hr"></div>

    <h2>Run</h2>
    <div class="grid3">
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnStep">Step +1s</button>
    </div>
    <div class="grid3" style="margin-top:10px">
      <button id="btnReset">Reset</button>
      <button id="btnCopy">Copy Summary</button>
      <button id="btnPrint">Print / Save Data</button>
    </div>

    <div class="callout">
      <div class="small">
        <b>Reader path:</b><br/>
        (1) Move R toward 1 to see strong-field behavior.<br/>
        (2) Increase κ to strengthen exponential slowing without singularity.<br/>
        (3) Increase α or n to test torsion-softened saturation form.<br/>
        (4) Compare accumulated orbit timing residuals at R<sub>orb</sub>.
      </div>
    </div>
  </section>

  <!-- RIGHT: Visualization -->
  <section class="panel">
    <h2>Visualization</h2>

    <div class="tabs">
      <div class="tab on" id="tabA">Time-rate laws vs R</div>
      <div class="tab" id="tabB">Orbit timing residuals</div>
      <div class="tab" id="tabC">Flux / torsion profiles</div>
    </div>

    <canvas id="cv" width="1200" height="420" style="height:340px"></canvas>
    <canvas id="cv2" width="1200" height="300" style="height:260px;margin-top:12px"></canvas>

    <div class="legend">
      <div class="leg"><span class="swatch" style="background:rgba(242,193,78,.95)"></span>GR: √(1−1/R)</div>
      <div class="leg"><span class="swatch" style="background:rgba(88,166,255,.95)"></span>Transport: exp(−κΦ)</div>
      <div class="leg"><span class="swatch" style="background:rgba(53,208,127,.95)"></span>Torsion-soft: (1+αT)<sup>−n</sup></div>
      <div class="leg"><span class="swatch" style="background:rgba(255,90,102,.95)"></span>Probe radius / orbit marker</div>
    </div>

    <div class="hr"></div>

    <h2>Live Readout</h2>
    <div class="kv">
      <div>Reference time t (s)</div><div><span id="tOut">0.0</span></div>

      <div>Probe radius R</div><div><span id="ROut2">—</span></div>
      <div>Orbit radius R<sub>orb</sub></div><div><span id="RorbOut2">—</span></div>

      <div>Φ(R) (or |Ψ|² label)</div><div><span id="phiOut">—</span></div>
      <div>T(R) torsion profile</div><div><span id="torsOut">—</span></div>

      <div>GR rate (probe)</div><div><span id="grOut">—</span></div>
      <div>Transport rate (probe)</div><div><span id="trOut">—</span></div>
      <div>Torsion-soft rate (probe)</div><div><span id="tsOut">—</span></div>

      <div>Orbit residual Δτ after N orbits (GR − Transport)</div><div><span id="resGT">—</span></div>
      <div>Orbit residual Δτ after N orbits (GR − Torsion)</div><div><span id="resGS">—</span></div>

      <div>CST display clock (s)</div><div><span id="cstOut">—</span></div>
      <div>CST correction applied (s)</div><div><span id="cstCorrOut">—</span></div>
    </div>

    <div class="hr"></div>

    <h2>Explanation Panel (Reader-friendly)</h2>
    <textarea id="explain" readonly></textarea>

    <div class="hr"></div>
    <div class="note">
      <b>Limitations (explicit):</b> These are <i>toy functional forms</i> to compare strong-field signatures.
      The simulator does not compute spacetime from matter content (no full Einstein–Cartan solver) and does not simulate EHT imaging (no ray-tracing or plasma emission).
      It targets the <b>timing frontier</b>: pulsar-clock transport near Sgr A*-like strong fields.
    </div>
  </section>
</main>

<script>
(() => {
  const EPS = 1e-15;
  const el = id => document.getElementById(id);

  // Inputs
  const inR = el("R");
  const inRorb = el("Rorb");
  const inP = el("P");
  const inNorbits = el("Norbits");
  const inK = el("kappa");
  const inPpow = el("pPow");
  const inAlpha = el("alpha");
  const inNpow = el("nPow");

  // Toggles
  const togCST = el("togCST");
  const togMap = el("togMap");

  // Outputs (left)
  const ROut = el("ROut");
  const RorbOut = el("RorbOut");
  const POut = el("POut");
  const NorbitsOut = el("NorbitsOut");
  const kappaOut = el("kappaOut");
  const pPowOut = el("pPowOut");
  const alphaOut = el("alphaOut");
  const nPowOut = el("nPowOut");

  // Outputs (right)
  const tOut = el("tOut");
  const ROut2 = el("ROut2");
  const RorbOut2 = el("RorbOut2");
  const phiOut = el("phiOut");
  const torsOut = el("torsOut");
  const grOut = el("grOut");
  const trOut = el("trOut");
  const tsOut = el("tsOut");
  const resGT = el("resGT");
  const resGS = el("resGS");
  const cstOut = el("cstOut");
  const cstCorrOut = el("cstCorrOut");
  const explain = el("explain");

  // Buttons
  const btnStart = el("btnStart");
  const btnPause = el("btnPause");
  const btnStep = el("btnStep");
  const btnReset = el("btnReset");
  const btnCopy = el("btnCopy");
  const btnPrint = el("btnPrint");

  // Tabs
  const tabA = el("tabA"), tabB = el("tabB"), tabC = el("tabC");

  // Canvases
  const cv = el("cv");
  const cv2 = el("cv2");
  const ctx = cv.getContext("2d");
  const ctx2 = cv2.getContext("2d");

  // State
  let running = false, lastTs = 0;
  let t = 0;

  // CST display clock (phase-lock)
  let tauLocalDisplay = 0;
  let cstCorr = 0;

  // History buffers for tabB residual curve while running
  const HIST_MAX = 700;
  const hist = { t:[], resGT:[], resGS:[] };

  // ---------- Helpers ----------
  function fmt(x, n=6){
    if (!isFinite(x)) return "—";
    const a = Math.abs(x);
    if (a !== 0 && (a < 1e-6 || a > 1e9)) return x.toExponential(Math.max(1,n-1));
    return x.toFixed(n);
  }
  function toggleUI(node, on){
    node.classList.toggle("on", !!on);
    node.setAttribute("aria-checked", on ? "true" : "false");
  }
  function isOn(node){ return node.classList.contains("on"); }

  // ---------- Model functions (toy) ----------
  // Profiles
  function Phi(R, p){ return 1 / Math.pow(Math.max(EPS, R), p); }   // flux / activation density
  function TorsionProfile(R){ return 1 / Math.pow(Math.max(EPS, R), 3); } // simple 1/R^3

  // Time-rate laws
  function rateGR(R){
    // Schwarzschild: sqrt(1 - 1/R), defined for R>1; clamp to avoid NaN at R<=1
    const x = 1 - 1/Math.max(1.0000000001, R);
    return Math.sqrt(Math.max(0, x));
  }
  function rateTransport(R, kappa, p){
    const phi = Phi(R, p);
    return Math.exp(-kappa * phi);
  }
  function rateTorsionSoft(R, alpha, n){
    const T = TorsionProfile(R);
    return Math.pow(1 + alpha*T, -n);
  }

  // Mock pulsar orbit timing residual: integrate over angle with varying R(θ)
  // Use small eccentricity e; user sees "timing frontier" sensitivity to functional form.
  function orbitResiduals(P, Norbits, Rorb, e, kappa, p, alpha, n){
    const steps = 1200;
    let sumGR = 0, sumTR = 0, sumTS = 0;

    // normalize such that coordinate dt integrates to P (one orbit in reference time)
    const dt = P / steps;

    for(let i=0;i<steps;i++){
      const th = (i/steps) * Math.PI*2;
      // simple radial variation: R(θ)=Rorb*(1 - e cos θ)  (kept > 1 by clamping)
      const Rth = Math.max(1.001, Rorb*(1 - e*Math.cos(th)));

      const rGR = rateGR(Rth);
      const rTR = rateTransport(Rth, kappa, p);
      const rTS = rateTorsionSoft(Rth, alpha, n);

      sumGR += rGR * dt;
      sumTR += rTR * dt;
      sumTS += rTS * dt;
    }

    const totalGR = sumGR * Norbits;
    const totalTR = sumTR * Norbits;
    const totalTS = sumTS * Norbits;

    return {
      totalGR, totalTR, totalTS,
      resGT: totalGR - totalTR,
      resGS: totalGR - totalTS
    };
  }

  // ---------- UI + Explanation ----------
  function updateExplain(p){
    const mapOn = p.map;
    const phiName = mapOn ? "|Ψ|² (activation density label)" : "Φ (causal flux)";
    const lines = [];
    lines.push("Reader Guide — What this simulator demonstrates (and what it does not)");
    lines.push("");
    lines.push("Goal (timing frontier): Compare how three candidate strong-field time-rate laws accumulate into observable timing residuals for a clock/pulsar near a compact object.");
    lines.push("This is why pulsar timing near Sgr A* is decisive: imaging probes null paths; timing probes proper-time transport.");
    lines.push("");
    lines.push("Models plotted at radius R=r/rs:");
    lines.push("  • GR (Schwarzschild): dτ/dt = √(1 − 1/R).");
    lines.push("  • Transport-first (exponential saturation): dτ/dt = exp(−κ " + phiName + "(R)), with " + phiName + "(R)=1/R^p.");
    lines.push("  • Torsion-softened (phenomenological): dτ/dt = (1 + α T(R))^(−n), with T(R)=1/R^3.");
    lines.push("");
    lines.push("How to read the plots:");
    lines.push("  • Tab A shows the functional form differences near R→1 (strong field).");
    lines.push("  • Tab B shows accumulated residuals after N mock orbits: Δτ = τ_GR − τ_model.");
    lines.push("    The key is the radius-dependence, not exact numbers.");
    lines.push("  • Tab C shows the underlying profiles " + phiName + "(R) and T(R).");
    lines.push("");
    lines.push("CST overlay:");
    lines.push("  • CST is a display convention: we show a phase-locked display clock that stays aligned to reference time.");
    lines.push("  • It does not change the physics curves; it shows how a shared time standard can be maintained operationally.");
    lines.push("");
    lines.push("Limitations (honest scope):");
    lines.push("  • No self-consistent Einstein–Cartan field solving (torsion is parameterized).");
    lines.push("  • No EHT ray-tracing or plasma emission modeling.");
    lines.push("  • Use this as a falsifiable intuition engine: exponential vs power-law saturation yields different timing signatures.");
    explain.value = lines.join("\n");
  }

  // ---------- Drawing ----------
  function clear(g,w,h){ g.clearRect(0,0,w,h); }
  function axes(g,w,h,pad=50){
    g.strokeStyle="rgba(255,255,255,.18)";
    g.lineWidth=1;
    g.beginPath();
    g.moveTo(pad, 14);
    g.lineTo(pad, h-pad);
    g.lineTo(w-14, h-pad);
    g.stroke();
  }
  function gridY(g,x0,y0,x1,y1,n=5){
    g.strokeStyle="rgba(255,255,255,.08)";
    for(let i=1;i<n;i++){
      const yy = y0 - (i/n)*(y0-y1);
      g.beginPath(); g.moveTo(x0,yy); g.lineTo(x1,yy); g.stroke();
    }
  }
  function dot(g,x,y,r=4,color="rgba(255,90,102,.95)"){
    g.fillStyle=color;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }

  let activeTab = "A";
  function setTab(which){
    activeTab = which;
    [tabA, tabB, tabC].forEach(x=>x.classList.remove("on"));
    if (which==="A") tabA.classList.add("on");
    if (which==="B") tabB.classList.add("on");
    if (which==="C") tabC.classList.add("on");
    renderAll();
  }
  tabA.onclick=()=>setTab("A");
  tabB.onclick=()=>setTab("B");
  tabC.onclick=()=>setTab("C");

  function renderAll(){
    const p = getParams();
    if (activeTab==="A") renderRates(p);
    if (activeTab==="B") renderResiduals(p);
    if (activeTab==="C") renderProfiles(p);
    renderBars(p);
  }

  function renderRates(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    const Rmin = 1.001;
    const Rmax = 30;
    const S = 800;

    function X(R){ return x0 + (R-Rmin)/(Rmax-Rmin)*(x1-x0); }
    function Y(rate){ return y0 - (rate-0)/(1-0)*(y0-y1); }

    // Curves
    function drawCurve(color, f){
      ctx.strokeStyle=color;
      ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<=S;i++){
        const R = Rmin + (i/S)*(Rmax-Rmin);
        const y = Y(f(R));
        const x = X(R);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    drawCurve("rgba(242,193,78,.95)", (R)=>rateGR(R));
    drawCurve("rgba(88,166,255,.95)", (R)=>rateTransport(R,p.kappa,p.pPow));
    drawCurve("rgba(53,208,127,.95)", (R)=>rateTorsionSoft(R,p.alpha,p.nPow));

    // Markers at probe R and orbit Rorb
    const rProbe = p.R;
    const rOrb = p.Rorb;

    dot(ctx, X(rProbe), Y(rateGR(rProbe)));
    dot(ctx, X(rProbe), Y(rateTransport(rProbe,p.kappa,p.pPow)), 4, "rgba(255,90,102,.75)");
    dot(ctx, X(rProbe), Y(rateTorsionSoft(rProbe,p.alpha,p.nPow)), 4, "rgba(255,90,102,.55)");

    // vertical line for Rorb
    ctx.strokeStyle="rgba(255,90,102,.35)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(X(rOrb), y1);
    ctx.lineTo(X(rOrb), y0);
    ctx.stroke();

    // Labels
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab A: Time-rate laws vs radius R=r/rs (near R→1 is strong field)", x0+10, y1+18);
    ctx.fillStyle="rgba(255,90,102,.85)";
    ctx.fillText("vertical line: orbit radius R_orb", x0+10, y1+36);
  }

  function renderResiduals(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    // Create a sweep of Rorb for residuals to show functional dependence
    const Rmin = 1.05;
    const Rmax = 30;
    const S = 420;

    const e = 0.15; // fixed, mild eccentricity (reader-friendly)
    const ptsGT = [];
    const ptsGS = [];
    let maxAbs = 0;

    for(let i=0;i<=S;i++){
      const Rorb = Rmin + (i/S)*(Rmax-Rmin);
      const out = orbitResiduals(p.P, p.Norbits, Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);
      ptsGT.push({Rorb, y: out.resGT});
      ptsGS.push({Rorb, y: out.resGS});
      maxAbs = Math.max(maxAbs, Math.abs(out.resGT), Math.abs(out.resGS));
    }
    maxAbs = Math.max(1e-9, maxAbs);

    function X(R){ return x0 + (R-Rmin)/(Rmax-Rmin)*(x1-x0); }
    function Y(y){ return y0 - (y + maxAbs)/(2*maxAbs) * (y0-y1); } // map [-maxAbs,maxAbs]

    // zero line
    ctx.strokeStyle="rgba(255,255,255,.18)";
    ctx.beginPath(); ctx.moveTo(x0, Y(0)); ctx.lineTo(x1, Y(0)); ctx.stroke();

    // draw curves
    function drawPts(color, pts){
      ctx.strokeStyle=color;
      ctx.lineWidth=2;
      ctx.beginPath();
      pts.forEach((pt, idx)=>{
        const x = X(pt.Rorb), y = Y(pt.y);
        if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }
    drawPts("rgba(88,166,255,.95)", ptsGT); // GR-Transport residual (blue)
    drawPts("rgba(53,208,127,.95)", ptsGS); // GR-Torsion residual (green)

    // mark current Rorb
    const cur = orbitResiduals(p.P, p.Norbits, p.Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);
    dot(ctx, X(p.Rorb), Y(cur.resGT), 5, "rgba(255,90,102,.95)");
    dot(ctx, X(p.Rorb), Y(cur.resGS), 5, "rgba(255,90,102,.65)");

    // Labels
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab B: Orbit timing residuals vs orbit radius R_orb (eccentricity fixed e=0.15)", x0+10, y1+18);
    ctx.fillStyle="rgba(88,166,255,.95)";
    ctx.fillText("Δτ = τ_GR − τ_Transport  (after N orbits)", x0+10, y1+36);
    ctx.fillStyle="rgba(53,208,127,.95)";
    ctx.fillText("Δτ = τ_GR − τ_TorsionSoft (after N orbits)", x0+10, y1+54);
  }

  function renderProfiles(p){
    const w=cv.width,h=cv.height;
    clear(ctx,w,h);
    axes(ctx,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    gridY(ctx,x0,y0,x1,y1,5);

    const Rmin = 1.001;
    const Rmax = 30;
    const S = 800;

    const mapOn = p.map;
    const phiName = mapOn ? "|Ψ|²" : "Φ";

    // normalize to value at Rmin for visibility
    const phiNorm = Phi(Rmin, p.pPow);
    const tNorm = TorsionProfile(Rmin);

    function X(R){ return x0 + (R-Rmin)/(Rmax-Rmin)*(x1-x0); }
    function Y(z){ return y0 - z*(y0-y1); } // z in [0,1]

    ctx.lineWidth=2;

    // Phi
    ctx.strokeStyle="rgba(88,166,255,.95)";
    ctx.beginPath();
    for(let i=0;i<=S;i++){
      const R = Rmin + (i/S)*(Rmax-Rmin);
      const z = Phi(R,p.pPow)/Math.max(EPS,phiNorm);
      const x = X(R), y = Y(Math.min(1, z));
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // T
    ctx.strokeStyle="rgba(53,208,127,.95)";
    ctx.beginPath();
    for(let i=0;i<=S;i++){
      const R = Rmin + (i/S)*(Rmax-Rmin);
      const z = TorsionProfile(R)/Math.max(EPS,tNorm);
      const x = X(R), y = Y(Math.min(1, z));
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // marker
    dot(ctx, X(p.R), Y(Math.min(1, Phi(p.R,p.pPow)/phiNorm)), 5, "rgba(255,90,102,.95)");
    dot(ctx, X(p.R), Y(Math.min(1, TorsionProfile(p.R)/tNorm)), 5, "rgba(255,90,102,.65)");

    // labels
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font="12px system-ui,Segoe UI,Arial";
    ctx.fillText("Tab C: Underlying profiles (normalized for visibility)", x0+10, y1+18);
    ctx.fillStyle="rgba(88,166,255,.95)";
    ctx.fillText(phiName + "(R)=1/R^p (normalized)", x0+10, y1+36);
    ctx.fillStyle="rgba(53,208,127,.95)";
    ctx.fillText("T(R)=1/R^3 (normalized)", x0+10, y1+54);
  }

  function renderBars(p){
    const w=cv2.width,h=cv2.height;
    clear(ctx2,w,h);

    const pad=20,left=280,barH=22,gap=16,top=18;
    ctx2.font="13px system-ui,Segoe UI,Arial";
    ctx2.fillStyle="rgba(255,255,255,.85)";
    ctx2.fillText("Instantaneous values at probe radius R", pad, top);

    const W = w - left - pad;

    function bar(y, label, val, maxVal, color){
      const v = Math.max(0, Math.min(val, maxVal));
      const bw = (v/maxVal) * W;

      ctx2.fillStyle="rgba(255,255,255,.75)";
      ctx2.fillText(label, pad, y+barH-6);

      ctx2.fillStyle="rgba(255,255,255,.10)";
      ctx2.fillRect(left,y,W,barH);

      ctx2.fillStyle=color;
      ctx2.fillRect(left,y,bw,barH);

      ctx2.strokeStyle="rgba(255,255,255,.18)";
      ctx2.strokeRect(left,y,W,barH);

      ctx2.fillStyle="rgba(255,255,255,.85)";
      ctx2.fillText(fmt(val, 9), left+W+10, y+barH-6);
    }

    const rGR = rateGR(p.R);
    const rTR = rateTransport(p.R,p.kappa,p.pPow);
    const rTS = rateTorsionSoft(p.R,p.alpha,p.nPow);

    bar(top+34, "GR time-rate √(1−1/R)", rGR, 1.0, "rgba(242,193,78,.85)");
    bar(top+34+(barH+gap), "Transport time-rate exp(−κΦ)", rTR, 1.0, "rgba(88,166,255,.85)");
    bar(top+34+2*(barH+gap), "Torsion-soft time-rate (1+αT)^−n", rTS, 1.0, "rgba(53,208,127,.85)");

    const mapOn = p.map;
    const phiVal = Phi(p.R,p.pPow);
    const torsVal = TorsionProfile(p.R);
    const phiLabel = mapOn ? "|Ψ|² at R" : "Φ at R";
    bar(top+34+3*(barH+gap), phiLabel + " (capped)", Math.min(phiVal, 1), 1.0, "rgba(88,166,255,.45)");
    bar(top+34+4*(barH+gap), "T(R) (capped)", Math.min(torsVal, 1), 1.0, "rgba(53,208,127,.45)");

    ctx2.fillStyle="rgba(255,255,255,.6)";
    ctx2.font="12px system-ui,Segoe UI,Arial";
    ctx2.fillText("Tip: near R→1, compare whether the approach to 'time freeze' is exponential (transport) or power-law softened (torsion).", pad, h-18);
  }

  // ---------- Print / Save ----------
  function escapeHtml(s){
    return String(s)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function makeCSV(){
    const p = getParams();
    const e = 0.15;
    const cur = orbitResiduals(p.P, p.Norbits, p.Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);

    const lines = [];
    lines.push("key,value");
    lines.push("timestamp_iso," + new Date().toISOString());
    lines.push("R_probe," + p.R);
    lines.push("R_orb," + p.Rorb);
    lines.push("P_seconds," + p.P);
    lines.push("N_orbits," + p.Norbits);
    lines.push("kappa," + p.kappa);
    lines.push("p_flux_power," + p.pPow);
    lines.push("alpha_torsion," + p.alpha);
    lines.push("n_torsion," + p.nPow);
    lines.push("mapping_mode," + (p.map ? "true" : "false"));
    lines.push("CST_on," + (p.cst ? "true" : "false"));
    lines.push("eccentricity_fixed," + e);

    lines.push("phi_probe," + Phi(p.R,p.pPow));
    lines.push("torsion_probe," + TorsionProfile(p.R));
    lines.push("rate_GR_probe," + rateGR(p.R));
    lines.push("rate_Transport_probe," + rateTransport(p.R,p.kappa,p.pPow));
    lines.push("rate_TorsionSoft_probe," + rateTorsionSoft(p.R,p.alpha,p.nPow));

    lines.push("tau_GR_total," + cur.totalGR);
    lines.push("tau_Transport_total," + cur.totalTR);
    lines.push("tau_TorsionSoft_total," + cur.totalTS);
    lines.push("residual_GR_minus_Transport," + cur.resGT);
    lines.push("residual_GR_minus_TorsionSoft," + cur.resGS);
    lines.push("");

    lines.push("history_time_s,resGT,resGS");
    for(let i=0;i<hist.t.length;i++){
      lines.push(hist.t[i] + "," + hist.resGT[i] + "," + hist.resGS[i]);
    }
    return lines.join("\n");
  }

  function printData(){
    const p = getParams();
    const csv = makeCSV();
    const nowStr = new Date().toString();

    const html =
'<!doctype html><html><head><meta charset="utf-8" />' +
'<meta name="viewport" content="width=device-width,initial-scale=1" />' +
'<title>Timing Frontier — Printout</title>' +
'<style>' +
'body{font-family:system-ui,Segoe UI,Arial,sans-serif;margin:18px;color:#111}' +
'h1{font-size:18px;margin:0 0 10px}' +
'.muted{color:#555;font-size:12.5px}' +
'.box{border:1px solid #ccc;border-radius:10px;padding:12px;margin-top:12px}' +
'table{border-collapse:collapse;width:100%;font-size:12.5px;margin-top:8px}' +
'th,td{border:1px solid #ddd;padding:6px 8px;text-align:left}' +
'th{background:#f5f7fb}' +
'textarea{width:100%;min-height:240px;margin-top:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:11px}' +
'button{padding:10px 12px;border-radius:10px;border:1px solid #999;background:#f5f5f5;cursor:pointer;font-weight:700}' +
'.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}' +
'</style></head><body>' +
'<h1>Strong-Field Timing Frontier — Data Printout</h1>' +
'<div class="muted">Generated: ' + escapeHtml(nowStr) + '</div>' +

'<div class="box"><b>Current settings</b>' +
'<table>' +
'<tr><th>Probe radius R</th><td>' + p.R + '</td></tr>' +
'<tr><th>Orbit radius R_orb</th><td>' + p.Rorb + '</td></tr>' +
'<tr><th>Orbit period P (s)</th><td>' + p.P + '</td></tr>' +
'<tr><th>Number of orbits</th><td>' + p.Norbits + '</td></tr>' +
'<tr><th>κ (transport strength)</th><td>' + p.kappa + '</td></tr>' +
'<tr><th>p (flux power)</th><td>' + p.pPow + '</td></tr>' +
'<tr><th>α (torsion softening)</th><td>' + p.alpha + '</td></tr>' +
'<tr><th>n (torsion exponent)</th><td>' + p.nPow + '</td></tr>' +
'<tr><th>Mapping mode</th><td>' + (p.map ? "ON (Φ relabeled as |Ψ|²)" : "OFF") + '</td></tr>' +
'<tr><th>CST overlay</th><td>' + (p.cst ? "ON" : "OFF") + '</td></tr>' +
'</table>' +

'<div class="row">' +
'<button onclick="window.print()">Print / Save as PDF</button>' +
'<button onclick="downloadCSV()">Download CSV</button>' +
'</div>' +

'<div class="muted" style="margin-top:10px">CSV includes current parameters + a small residual history buffer.</div>' +
'<textarea id="csv" readonly>' + escapeHtml(csv) + '</textarea>' +
'</div>' +

'<script>' +
'function downloadCSV(){' +
'  var csv = document.getElementById("csv").value;' +
'  var blob = new Blob([csv], {type:"text/csv;charset=utf-8"});' +
'  var url = URL.createObjectURL(blob);' +
'  var a = document.createElement("a");' +
'  var ts = new Date().toISOString().replace(/[:.]/g,"-");' +
'  a.href = url;' +
'  a.download = "timing_frontier_data_" + ts + ".csv";' +
'  document.body.appendChild(a); a.click(); a.remove();' +
'  setTimeout(function(){ URL.revokeObjectURL(url); }, 500);' +
'}' +
'<\/script>' +
'</body></html>';

    const w = window.open("", "_blank", "noopener,noreferrer,width=980,height=740");
    if (!w){ alert("Pop-up blocked. Allow pop-ups to print/save data."); return; }
    w.document.open();
    w.document.write(html);
    w.document.close();
  }

  // ---------- Parameters ----------
  function getParams(){
    const R = Number(inR.value);
    const Rorb = Number(inRorb.value);
    const P = Number(inP.value);
    const Norbits = Number(inNorbits.value);
    const kappa = Number(inK.value);
    const pPow = Number(inPpow.value);
    const alpha = Number(inAlpha.value);
    const nPow = Number(inNpow.value);
    const cst = isOn(togCST);
    const map = isOn(togMap);
    return { R, Rorb, P, Norbits, kappa, pPow, alpha, nPow, cst, map };
  }

  // ---------- Step loop ----------
  function applyCSTDisplay(p){
    // display clock phase-locked to reference time t (CST convention)
    if(!p.cst){
      tauLocalDisplay = t;
      cstCorr = 0;
      return;
    }
    // simple: display exactly equals reference; correction is any notional offset (here 0 by definition)
    tauLocalDisplay = t;
    cstCorr = 0;
  }

  function updateUI(p){
    ROut.textContent = fmt(p.R, 3);
    RorbOut.textContent = fmt(p.Rorb, 2);
    POut.textContent = fmt(p.P, 0);
    NorbitsOut.textContent = fmt(p.Norbits, 0);
    kappaOut.textContent = fmt(p.kappa, 3);
    pPowOut.textContent = fmt(p.pPow, 2);
    alphaOut.textContent = fmt(p.alpha, 3);
    nPowOut.textContent = fmt(p.nPow, 2);

    tOut.textContent = fmt(t, 2);
    ROut2.textContent = fmt(p.R, 6);
    RorbOut2.textContent = fmt(p.Rorb, 6);

    const phi = Phi(p.R,p.pPow);
    const tors = TorsionProfile(p.R);
    phiOut.textContent = fmt(phi, 9) + (p.map ? "  (label: |Ψ|²)" : "");
    torsOut.textContent = fmt(tors, 9);

    const rGR = rateGR(p.R);
    const rTR = rateTransport(p.R,p.kappa,p.pPow);
    const rTS = rateTorsionSoft(p.R,p.alpha,p.nPow);
    grOut.textContent = fmt(rGR, 9);
    trOut.textContent = fmt(rTR, 9);
    tsOut.textContent = fmt(rTS, 9);

    const e = 0.15;
    const cur = orbitResiduals(p.P, p.Norbits, p.Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);
    resGT.textContent = fmt(cur.resGT, 9) + " s";
    resGS.textContent = fmt(cur.resGS, 9) + " s";

    cstOut.textContent = fmt(tauLocalDisplay, 6);
    cstCorrOut.textContent = fmt(cstCorr, 6);

    updateExplain(p);
  }

  function step(dt){
    const p = getParams();
    t += dt;

    // keep a small running history for residuals at the current Rorb
    const e = 0.15;
    const cur = orbitResiduals(p.P, p.Norbits, p.Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);
    hist.t.push(t);
    hist.resGT.push(cur.resGT);
    hist.resGS.push(cur.resGS);
    if(hist.t.length > HIST_MAX){
      hist.t.shift(); hist.resGT.shift(); hist.resGS.shift();
    }

    applyCSTDisplay(p);
    updateUI(p);
    renderAll();
  }

  function tick(ts){
    if(!running){ lastTs = ts; return; }
    const dt = Math.min(0.05, Math.max(0, (ts-lastTs)/1000));
    lastTs = ts;
    step(dt);
    requestAnimationFrame(tick);
  }

  // ---------- Render residual history in cv2 on Tab B, otherwise show info ----------
  function renderResidualHistory(){
    const w=cv2.width,h=cv2.height;
    clear(ctx2,w,h);
    const pad=50,x0=pad,y0=h-pad,x1=w-14,y1=14;
    axes(ctx2,w,h);
    gridY(ctx2,x0,y0,x1,y1,5);

    const Nn = hist.t.length;
    if(Nn < 2){
      ctx2.fillStyle="rgba(255,255,255,.75)";
      ctx2.font="12px system-ui,Segoe UI,Arial";
      ctx2.fillText("Run the simulation to build a residual history buffer.", x0+10, y1+18);
      return;
    }

    const tMin = hist.t[0], tMax = hist.t[Nn-1];
    let maxAbs = 0;
    for(let i=0;i<Nn;i++) maxAbs = Math.max(maxAbs, Math.abs(hist.resGT[i]), Math.abs(hist.resGS[i]));
    maxAbs = Math.max(1e-9, maxAbs);

    function X(tt){ return x0 + (tt-tMin)/Math.max(EPS,(tMax-tMin))*(x1-x0); }
    function Y(y){ return y0 - (y + maxAbs)/(2*maxAbs) * (y0-y1); }

    // zero line
    ctx2.strokeStyle="rgba(255,255,255,.18)";
    ctx2.beginPath(); ctx2.moveTo(x0,Y(0)); ctx2.lineTo(x1,Y(0)); ctx2.stroke();

    // GR-Transport (blue)
    ctx2.strokeStyle="rgba(88,166,255,.95)";
    ctx2.lineWidth=2;
    ctx2.beginPath();
    ctx2.moveTo(X(hist.t[0]), Y(hist.resGT[0]));
    for(let i=1;i<Nn;i++) ctx2.lineTo(X(hist.t[i]), Y(hist.resGT[i]));
    ctx2.stroke();

    // GR-Torsion (green)
    ctx2.strokeStyle="rgba(53,208,127,.95)";
    ctx2.beginPath();
    ctx2.moveTo(X(hist.t[0]), Y(hist.resGS[0]));
    for(let i=1;i<Nn;i++) ctx2.lineTo(X(hist.t[i]), Y(hist.resGS[i]));
    ctx2.stroke();

    ctx2.fillStyle="rgba(255,255,255,.85)";
    ctx2.font="12px system-ui,Segoe UI,Arial";
    ctx2.fillText("Residual history buffer at current R_orb (updates while running)", x0+10, y1+18);
  }

  // hook cv2 to active tab
  const _renderAll = renderAll;
  renderAll = function(){
    _renderAll();
    if(activeTab==="B") renderResidualHistory();
    else{
      // show a small “status strip” on cv2 for tabs A/C
      const w=cv2.width,h=cv2.height;
      clear(ctx2,w,h);
      ctx2.fillStyle="rgba(255,255,255,.85)";
      ctx2.font="12px system-ui,Segoe UI,Arial";
      ctx2.fillText("Tip: Switch to Tab B and press Start to build a residual history trace over time.", 18, 24);
    }
  };

  // ---------- Events ----------
  function toggleClick(node){
    toggleUI(node, !isOn(node));
    step(0);
  }
  togCST.onclick = ()=>toggleClick(togCST);
  togMap.onclick = ()=>toggleClick(togMap);

  [inR,inRorb,inP,inNorbits,inK,inPpow,inAlpha,inNpow].forEach(x=>{
    x.addEventListener("input", ()=>step(0));
    x.addEventListener("change", ()=>step(0));
  });

  btnStart.onclick = () => {
    if(!running){
      running = true;
      requestAnimationFrame((ts)=>{ lastTs=ts; requestAnimationFrame(tick); });
    }
  };
  btnPause.onclick = () => { running = false; };
  btnStep.onclick = () => { running = false; step(1); };

  function resetAll(){
    running = false; lastTs = 0;
    t = 0;
    tauLocalDisplay = 0;
    cstCorr = 0;
    hist.t.length=0; hist.resGT.length=0; hist.resGS.length=0;
    step(0);
  }
  btnReset.onclick = resetAll;

  btnCopy.onclick = async () => {
    const p = getParams();
    const e = 0.15;
    const cur = orbitResiduals(p.P, p.Norbits, p.Rorb, e, p.kappa, p.pPow, p.alpha, p.nPow);
    const text =
`Strong-Field Timing Frontier — Simulator Summary

Probe radius: R = ${p.R}
Orbit radius: R_orb = ${p.Rorb}
Orbit period: P = ${p.P} s
Number of orbits: N = ${p.Norbits}
Eccentricity: e = ${e} (fixed for demo)

Transport-first:
  dτ/dt = exp(-κ Φ(R)), Φ(R)=1/R^p
  κ=${p.kappa}, p=${p.pPow}

Torsion-softened (phenomenological):
  dτ/dt = (1 + α T(R))^-n, T(R)=1/R^3
  α=${p.alpha}, n=${p.nPow}

Probe values:
  Φ(R)=${Phi(p.R,p.pPow)}
  T(R)=${TorsionProfile(p.R)}
  rate_GR=${rateGR(p.R)}
  rate_Transport=${rateTransport(p.R,p.kappa,p.pPow)}
  rate_TorsionSoft=${rateTorsionSoft(p.R,p.alpha,p.nPow)}

Accumulated totals (after N orbits):
  τ_GR=${cur.totalGR} s
  τ_Transport=${cur.totalTR} s
  τ_TorsionSoft=${cur.totalTS} s
  Residual GR-Transport=${cur.resGT} s
  Residual GR-TorsionSoft=${cur.resGS} s

CST overlay: ${p.cst ? "ON" : "OFF"}
Mapping mode (Φ label): ${p.map ? "ON (|Ψ|²)" : "OFF (Φ)"}
`;
    try{
      await navigator.clipboard.writeText(text);
      btnCopy.textContent="Copied!";
      setTimeout(()=>btnCopy.textContent="Copy Summary", 900);
    } catch(e){
      alert("Copy failed (browser permission).");
    }
  };

  btnPrint.onclick = () => { running = false; printData(); };

  // Defaults
  inR.value = "2.200";
  inRorb.value = "6.00";
  inP.value = "30";
  inNorbits.value = "20";
  inK.value = "4.0";
  inPpow.value = "2.0";
  inAlpha.value = "6.0";
  inNpow.value = "2.0";
  toggleUI(togCST, true);
  toggleUI(togMap, false);

  // Init
  resetAll();
  setTab("A");
})();
</script>
</body>
</html>
