<!-- ======================= PART 1 / 4 ======================= -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST Warp Navigation — Ship + Panels + Flight Plan (Theory Demo)</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#020617;
    --panel:rgba(12,22,52,0.78);
    --panel2:rgba(8,16,38,0.72);
    --ink:#e8f3ff;
    --muted:#9cc7ff;
    --line:rgba(130,190,255,0.45);
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    --radius:14px;
    --shadow:0 18px 40px rgba(0,0,0,.45);
  }
  html,body{margin:0;height:100%;background:var(--bg);overflow:hidden;font-family:Segoe UI,Roboto,Arial,sans-serif;color:var(--ink)}
  canvas{position:fixed;inset:0;z-index:0}

  /* ===== Sidebar / panels ===== */
  .sidebar{
    position:fixed;top:10px;right:10px;
    width:min(420px, calc(100vw - 20px));
    max-height:calc(100vh - 20px);
    display:flex;flex-direction:column;gap:10px;
    z-index:50;
  }
  .card{
    background:linear-gradient(180deg, var(--panel), var(--panel2));
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:10px 12px;
    border-bottom:1px solid rgba(130,190,255,0.22);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .card .hd .t{font-weight:900;letter-spacing:.06em;font-size:13px;text-transform:uppercase}
  .card .bd{padding:10px 12px;overflow:auto;max-height:54vh}

  /* Tabs */
  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .tab{
    appearance:none;border:1px solid rgba(130,190,255,0.28);
    background:rgba(2,6,23,.45);
    color:var(--ink);
    padding:7px 10px;border-radius:12px;
    font-weight:900;cursor:pointer;font-size:12px;
  }
  .tab[aria-selected="true"]{border-color:rgba(96,165,250,.75);background:rgba(0,58,227,.40)}

  /* Common */
  h2{margin:0 0 6px;font-size:15px;letter-spacing:.04em}
  .label{margin-top:8px;font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.12em}
  .value{margin-top:4px;font-size:13px;font-family:var(--mono);white-space:pre-wrap;line-height:1.2}
  select,button,input[type="range"]{
    width:100%;padding:8px 9px;margin-top:7px;
    background:#0c1634;color:var(--ink);
    border:1px solid rgba(61,103,184,.85);
    border-radius:10px;font-size:14px;outline:none;
  }
  button{cursor:pointer;font-weight:900}
  button:hover{border-color:rgba(96,165,250,.85)}
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  .btnrow>button{flex:1;min-width:150px}
  .primary{background:#003ae3}
  .primary:hover{background:#0d4aff}
  .danger{background:rgba(90,16,16,.92);border-color:rgba(184,71,71,.9)}
  .danger:hover{background:rgba(120,20,20,.95)}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(148,163,184,.22);
    background:rgba(2,6,23,.35);
    font-size:12px;color:var(--muted);
    font-family:var(--mono);
  }
  .divider{height:1px;background:rgba(130,190,255,0.18);margin:10px 0}
  .bar{height:10px;border-radius:999px;background:rgba(148,163,184,.12);border:1px solid rgba(148,163,184,.16);overflow:hidden}
  .bar>i{display:block;height:100%;width:0%;background:linear-gradient(90deg, rgba(96,165,250,.95), rgba(52,211,153,.85))}
  .kpiGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:520px){.kpiGrid{grid-template-columns:1fr}}
  .kpi{border:1px solid rgba(148,163,184,.18);background:rgba(2,6,23,.25);border-radius:12px;padding:9px}
  .kpi .k{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em}
  .kpi .v{margin-top:5px;font-family:var(--mono);font-size:13px}

  .safeBox{border:1px solid rgba(148,163,184,.18);background:rgba(2,6,23,.25);border-radius:12px;padding:10px}
  .safeBox.unsafe{border-color:rgba(251,113,133,.55)}
  .safeBox.safe{border-color:rgba(52,211,153,.55)}
  .safeTitle{font-weight:900;letter-spacing:.06em}
  .safeTitle.unsafe{color:var(--bad)}
  .safeTitle.safe{color:var(--good)}
  .safeText{margin-top:8px;font-family:var(--mono);font-size:12px;white-space:pre-wrap;line-height:1.25;color:rgba(200,230,255,.92)}

  /* Left clock card */
  .clocks{
    position:fixed;left:10px;bottom:10px;
    width:min(360px, calc(100vw - 20px));
    z-index:40;
  }
  .clocks .bd{max-height:32vh}
  .small{font-size:12px;color:rgba(180,215,255,.86);line-height:1.25}
  .good{color:var(--good)}
  .warn{color:var(--warn)}
  .bad{color:var(--bad)}

  /* Error overlay (so nothing “disappears” silently) */
  .err{
    position:fixed;left:10px;top:10px;z-index:9999;
    width:min(520px, calc(100vw - 20px));
    display:none;
    background:rgba(90,16,16,.92);
    border:1px solid rgba(251,113,133,.75);
    border-radius:14px;
    padding:10px;
    box-shadow:var(--shadow);
    font-family:var(--mono);
    white-space:pre-wrap;
  }
</style>
</head>

<body>
<canvas id="sim"></canvas>

<div class="err" id="errBox"></div>

<!-- LEFT CLOCKS -->
<div class="card clocks">
  <div class="hd">
    <div class="t">Time Synchronization</div>
    <span class="pill">CST Lock: <b id="cstLockLbl" class="good">ON</b></span>
  </div>
  <div class="bd">
    <div class="label">Outside Time (UTC)</div>
    <div class="value" id="utcClock">--:--:--</div>

    <div class="label">Engine Sync (CST)</div>
    <div class="value" id="cstClock">--:--:--</div>

    <div class="label">Warp-Adjusted Time (scaled by clock rate)</div>
    <div class="value" id="warpClock">--:--:--</div>

    <div class="divider"></div>

    <div class="label">Estimated Arrival (CST)</div>
    <div class="value" id="arrivalClock">--:--:--</div>

    <div class="label">Earth Elapsed vs Ship Aging</div>
    <div class="value" id="ledgerClock">--</div>
    <div class="small">
      Theory demo: CST-locked means Earth and ship advance together in this visualization; “ship aging” is shown via a clock-rate scale.
    </div>
  </div>
</div>

<!-- RIGHT SIDEBAR -->
<div class="sidebar">
  <div class="card">
    <div class="hd">
      <div class="t">Warp Navigation Console</div>
      <span class="pill">Playback: <b id="playbackLbl">60×</b></span>
    </div>
    <div class="bd">
      <div class="tabs" role="tablist" aria-label="Warp console tabs">
        <button class="tab" id="tabNav" aria-selected="true" type="button">Nav</button>
        <button class="tab" id="tabTele" aria-selected="false" type="button">Telemetry</button>
        <button class="tab" id="tabMath" aria-selected="false" type="button">Math</button>
        <button class="tab" id="tabDyson" aria-selected="false" type="button">Dyson</button>
        <button class="tab" id="tabReport" aria-selected="false" type="button">Report</button>
      </div>

      <!-- NAV -->
      <div id="panelNav">
        <h2>Flight Plan (Earth → Andromeda)</h2>

        <div class="label">Destination</div>
        <select id="destSelect">
          <option value="Andromeda">Andromeda Galaxy (M31) — nearest major galaxy</option>
          <option value="LocalBubble">Local Region (demo short hop)</option>
        </select>

        <div class="label">Playback (sim-seconds per real second)</div>
        <input id="speed" type="range" min="1" max="240" value="60" />
        <div class="value"><span id="speedLbl">60</span>×</div>

        <div class="label">Warp factor</div>
        <select id="warpSelect">
          <option value="AUTO" selected>AUTO (use flight plan)</option>
          <option value="0">0 — Idle</option>
          <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option>
          <option value="4">Warp 4</option><option value="5">Warp 5</option><option value="6">Warp 6</option>
          <option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option>
          <option value="10">Warp 10</option>
        </select>

        <div class="btnrow">
          <button id="btnCalc" type="button">1 — Calculate Trip</button>
          <button id="btnStart" class="primary" type="button">2 — Start Warp Flight</button>
          <button id="btnStop" class="danger" type="button">STOP ENGINE</button>
        </div>

        <div class="label">Trip progress</div>
        <div class="bar"><i id="prog"></i></div>
        <div class="value" id="progTxt">0% • t = 0.0 s • phase: —</div>

        <div class="divider"></div>

        <!-- SAFETY PANEL (your exact text lives here) -->
        <div class="safeBox unsafe" id="safeBox">
          <div class="safeTitle unsafe" id="safeTitle">CST Warp Corridor Safety</div>
          <div class="value" id="safeLine">⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.</div>
          <div class="safeText" id="safeText"></div>
        </div>

        <div class="divider"></div>

        <div class="kpiGrid">
          <div class="kpi"><div class="k">Distance (approx)</div><div class="v" id="distLbl">—</div></div>
          <div class="kpi"><div class="k">Estimated time (toy)</div><div class="v" id="timeLbl">—</div></div>
          <div class="kpi"><div class="k">Compression / curvature (toy)</div><div class="v" id="curvLbl">—</div></div>
          <div class="kpi"><div class="k">Universe expansion term (toy)</div><div class="v" id="expLbl">—</div></div>
        </div>

        <div class="divider"></div>

        <div class="label">Breach Simulation</div>
        <div class="btnrow">
          <button id="btnBreach" type="button">Trigger Breach (Starboard)</button>
          <button id="btnHeal" type="button">Heal Now</button>
        </div>
        <div class="small">Theory demo: boost the affected side; auto-heal after ~5 seconds.</div>

        <div class="kpiGrid" style="margin-top:10px">
          <div class="kpi"><div class="k">Shield Boost (Starboard)</div><div class="v"><span id="boostLbl">0</span>%</div></div>
          <div class="kpi"><div class="k">Breach Containment</div><div class="v" id="containLbl">Stable</div></div>
          <div class="kpi"><div class="k">Warp-Assist Index</div><div class="v" id="warpAssistLbl">—</div></div>
          <div class="kpi"><div class="k">Negative-Energy Likelihood</div><div class="v" id="negEnergyLbl">—</div></div>
        </div>

        <div class="divider"></div>
        <div class="label">Ship Labels</div>
        <div class="small">Ship geometry is unchanged. Labels are drawn on top of the outline (fuselage, nacelles, core, field shell).</div>
      </div>

      <!-- TELEMETRY -->
      <div id="panelTele" style="display:none">
        <h2>Real-time Telemetry</h2>
        <div class="kpiGrid">
          <div class="kpi"><div class="k">Animation Speed</div><div class="v" id="tel_speed">—</div></div>
          <div class="kpi"><div class="k">Field Radius (×D)</div><div class="v" id="tel_radius">—</div></div>
          <div class="kpi"><div class="k">Field Shield (%)</div><div class="v" id="tel_shield">—</div></div>
          <div class="kpi"><div class="k">Field Stretch (rx/ry)</div><div class="v" id="tel_stretch">—</div></div>

          <div class="kpi"><div class="k">Clock Rate (warp)</div><div class="v" id="tel_clockrate">—</div></div>
          <div class="kpi"><div class="k">Photon/Ion Rate</div><div class="v" id="tel_photon">—</div></div>
          <div class="kpi"><div class="k">Collider Beam Flux</div><div class="v" id="tel_flux">—</div></div>
          <div class="kpi"><div class="k">Mag Field Strength</div><div class="v" id="tel_mag">—</div></div>

          <div class="kpi"><div class="k">Core Temp (°C)</div><div class="v" id="tel_coreT">—</div></div>
          <div class="kpi"><div class="k">Coolant Temp (°C)</div><div class="v" id="tel_coolT">—</div></div>
          <div class="kpi"><div class="k">Entangle Particles</div><div class="v" id="tel_ent">—</div></div>
          <div class="kpi"><div class="k">Plasma Cone Len / Rad</div><div class="v" id="tel_cone">—</div></div>

          <div class="kpi"><div class="k">Plasma Wave Intensity</div><div class="v" id="tel_wave">—</div></div>
          <div class="kpi"><div class="k">Effective FTL Gain (sim)</div><div class="v" id="tel_ftl">—</div></div>
        </div>
      </div>

      <!-- MATH -->
      <div id="panelMath" style="display:none">
        <h2>Warp Math • CST Ledger • State Vectors (Theory)</h2>
        <div class="label">Equations + Warp-drive display values (toy)</div>
        <div class="value" id="mathBlock">—</div>
        <div class="divider"></div>
        <div class="label">State Vectors & 4D Metrics (demo)</div>
        <div class="value" id="stateBlock">—</div>
        <div class="divider"></div>
        <div class="label">Verification Channels (GO / NO-GO)</div>
        <div class="value" id="verifyBlock">—</div>
      </div>

      <!-- DYSON -->
      <div id="panelDyson" style="display:none">
        <h2>Dyson Boundary + Prune/Decay (Nav AI Memory)</h2>
        <label class="small" style="display:flex;gap:10px;align-items:center;margin-top:6px">
          <input id="dysonOn" type="checkbox" checked/>
          Dyson Mode: ON (closed boundary, persists in localStorage)
        </label>

        <div class="kpiGrid" style="margin-top:10px">
          <div class="kpi"><div class="k">Boundary budget</div><div class="v" id="dy_budget">100%</div></div>
          <div class="kpi"><div class="k">Writes</div><div class="v" id="dy_writes">0</div></div>
          <div class="kpi"><div class="k">Leaks</div><div class="v" id="dy_leaks">0</div></div>
          <div class="kpi"><div class="k">Next decay tick</div><div class="v" id="dy_next">—</div></div>
        </div>

        <div class="divider"></div>
        <div class="btnrow">
          <button id="btnDecayNow" type="button">Prune/Decay Now</button>
          <button id="btnResetUI" type="button">Reset UI</button>
          <button id="btnClearVault" class="danger" type="button">Clear Vault</button>
        </div>

        <div class="divider"></div>
        <div class="label">Prune/Decay Monitor (live)</div>
        <div class="value" id="pdBlock">—</div>

        <div class="divider"></div>
        <div class="label">Dyson Log</div>
        <div class="value" id="dyLog" style="max-height:180px;overflow:auto">—</div>
      </div>

      <!-- REPORT -->
      <div id="panelReport" style="display:none">
        <h2>Logging & Report</h2>
        <div class="small">Logs each frame while running: warp, stability, shear, field stretch, temps, and zone compression%.</div>
        <div class="btnrow" style="margin-top:10px">
          <button id="btnBuildReport" type="button">Build Report</button>
          <button id="btnCSV" type="button">Download CSV</button>
          <button id="btnClearLog" type="button">Clear Log</button>
        </div>
        <div class="divider"></div>
        <div class="value" id="reportSummary">Log cleared. Run the sim, then click “Build Report”.</div>
      </div>

    </div>
  </div>
</div>

<script>
<!-- ======================= PART 2 / 4 ======================= -->
/* ===========================
   HARDENED STARTUP (so panels/ship never "disappear")
   - Captures runtime errors and shows them in a red box.
   - Ensures canvas is resized before drawing.
   =========================== */
(() => {
  const errBox = document.getElementById("errBox");
  function showErr(msg){
    errBox.style.display="block";
    errBox.textContent = msg;
  }
  window.addEventListener("error", (e)=>{
    showErr("JS ERROR:\n" + (e.message||e.error||"Unknown") + "\n" + (e.filename||"") + ":" + (e.lineno||"") );
  });
  window.addEventListener("unhandledrejection", (e)=>{
    showErr("PROMISE ERROR:\n" + (e.reason?.message || String(e.reason||"Unknown")));
  });
})();

/* ===== Canvas ===== */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d", {alpha:false});
let W=0,H=0,cx=0,cy=0;
function resize(){
  W = canvas.width  = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W/2; cy = H/2;
}
window.addEventListener("resize", resize);
resize();

/* ===== Helpers ===== */
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp  = (a,b,t)=>a+(b-a)*t;
const fmt   = (x,d=2)=>isFinite(x)?Number(x).toFixed(d):"—";
const fmt0  = (x)=>isFinite(x)?String(Math.round(x)):"—";
const pad2  = (n)=>String(n).padStart(2,"0");

function hmsFromSeconds(s){
  if(!isFinite(s) || s<0) return "—";
  s = Math.round(s);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;
}
function nowUTC(){
  const d = new Date();
  return new Date(d.getTime() + d.getTimezoneOffset()*60000);
}
function getCSTDate(){
  // CST = UTC - 6 (demo)
  const u = nowUTC();
  return new Date(u.getTime() - 6*3600000);
}
function timeStr(d){ return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`; }

/* ===== Tabs ===== */
const tabNav   = document.getElementById("tabNav");
const tabTele  = document.getElementById("tabTele");
const tabMath  = document.getElementById("tabMath");
const tabDyson = document.getElementById("tabDyson");
const tabReport= document.getElementById("tabReport");

const panelNav   = document.getElementById("panelNav");
const panelTele  = document.getElementById("panelTele");
const panelMath  = document.getElementById("panelMath");
const panelDyson = document.getElementById("panelDyson");
const panelReport= document.getElementById("panelReport");

function setTab(active){
  const tabs = [
    {btn:tabNav,   p:panelNav,   k:"Nav"},
    {btn:tabTele,  p:panelTele,  k:"Telemetry"},
    {btn:tabMath,  p:panelMath,  k:"Math"},
    {btn:tabDyson, p:panelDyson, k:"Dyson"},
    {btn:tabReport,p:panelReport,k:"Report"},
  ];
  for(const t of tabs){
    const on = (t.k===active);
    t.btn.setAttribute("aria-selected", on?"true":"false");
    t.p.style.display = on ? "block" : "none";
  }
}
tabNav.onclick   = ()=>setTab("Nav");
tabTele.onclick  = ()=>setTab("Telemetry");
tabMath.onclick  = ()=>setTab("Math");
tabDyson.onclick = ()=>setTab("Dyson");
tabReport.onclick= ()=>setTab("Report");

/* ===== DOM refs ===== */
const destSelect = document.getElementById("destSelect");
const speed = document.getElementById("speed");
const speedLbl = document.getElementById("speedLbl");
const playbackLbl = document.getElementById("playbackLbl");
const warpSelect = document.getElementById("warpSelect");

const btnCalc = document.getElementById("btnCalc");
const btnStart= document.getElementById("btnStart");
const btnStop = document.getElementById("btnStop");

const progBar = document.getElementById("prog");
const progTxt = document.getElementById("progTxt");

const safeBox = document.getElementById("safeBox");
const safeTitle = document.getElementById("safeTitle");
const safeLine = document.getElementById("safeLine");
const safeText = document.getElementById("safeText");

const distLbl = document.getElementById("distLbl");
const timeLbl = document.getElementById("timeLbl");
const curvLbl = document.getElementById("curvLbl");
const expLbl  = document.getElementById("expLbl");

const utcClock = document.getElementById("utcClock");
const cstClock = document.getElementById("cstClock");
const warpClock= document.getElementById("warpClock");
const arrivalClock = document.getElementById("arrivalClock");
const ledgerClock = document.getElementById("ledgerClock");
const cstLockLbl = document.getElementById("cstLockLbl");

/* Breach / field readouts */
const btnBreach = document.getElementById("btnBreach");
const btnHeal   = document.getElementById("btnHeal");
const boostLbl  = document.getElementById("boostLbl");
const containLbl= document.getElementById("containLbl");
const warpAssistLbl = document.getElementById("warpAssistLbl");
const negEnergyLbl  = document.getElementById("negEnergyLbl");

/* Telemetry */
const tel_speed   = document.getElementById("tel_speed");
const tel_radius  = document.getElementById("tel_radius");
const tel_shield  = document.getElementById("tel_shield");
const tel_stretch = document.getElementById("tel_stretch");
const tel_clockrate = document.getElementById("tel_clockrate");
const tel_photon  = document.getElementById("tel_photon");
const tel_flux    = document.getElementById("tel_flux");
const tel_mag     = document.getElementById("tel_mag");
const tel_coreT   = document.getElementById("tel_coreT");
const tel_coolT   = document.getElementById("tel_coolT");
const tel_ent     = document.getElementById("tel_ent");
const tel_cone    = document.getElementById("tel_cone");
const tel_wave    = document.getElementById("tel_wave");
const tel_ftl     = document.getElementById("tel_ftl");

/* Math panels */
const mathBlock  = document.getElementById("mathBlock");
const stateBlock = document.getElementById("stateBlock");
const verifyBlock= document.getElementById("verifyBlock");

/* Dyson */
const dysonOn = document.getElementById("dysonOn");
const dy_budget = document.getElementById("dy_budget");
const dy_writes = document.getElementById("dy_writes");
const dy_leaks  = document.getElementById("dy_leaks");
const dy_next   = document.getElementById("dy_next");
const pdBlock   = document.getElementById("pdBlock");
const dyLog     = document.getElementById("dyLog");
const btnDecayNow = document.getElementById("btnDecayNow");
const btnResetUI  = document.getElementById("btnResetUI");
const btnClearVault = document.getElementById("btnClearVault");

/* Report */
const btnBuildReport = document.getElementById("btnBuildReport");
const btnCSV    = document.getElementById("btnCSV");
const btnClearLog = document.getElementById("btnClearLog");
const reportSummary = document.getElementById("reportSummary");

/* ===== Safety text (EXACT) ===== */
const SAFETY_TEXT_EXACT =
`UNSAFE (Warp < 4):
At low warp factors the spacetime compression shell is incomplete.
The magnetic field cannot fully enclose the craft, allowing asymmetric
compression and temporal shear to interact with the hull.

SAFE (Warp ≥ 4):
Above Warp 4 the CST corridor becomes self-contained.
Compression gradients close smoothly around the craft,
magnetic shielding stabilizes, and external spacetime shear
is redirected around the hull instead of through it.

Note:
This is not structural failure — it is corridor formation.`;
safeText.textContent = SAFETY_TEXT_EXACT;

/* ===== Core constants (displayed as "toy") ===== */
const C_KM_S = 299792.458;
const KM_PER_LY = 9.460730472e12;

const DEST = {
  Andromeda:  { name:"Andromeda Galaxy (M31)", ly: 2.537e6 }, // approx
  LocalBubble:{ name:"Local Region (demo short hop)", ly: 5000 }
};

/* ===== Flight plan (slow + clear; warp 1..10) ===== */
function buildFlightPlan(){
  return [
    {step:1, phase:"Departure / field warmup",  t0:0,   t1:20,  w0:0,  w1:1},
    {step:2, phase:"Ramp: Warp 1 → 3",          t0:20,  t1:60,  w0:1,  w1:3},
    {step:3, phase:"Ramp: Warp 3 → 4 (gate)",   t0:60,  t1:90,  w0:3,  w1:4},
    {step:4, phase:"Ramp: Warp 4 → 10",         t0:90,  t1:150, w0:4,  w1:10},
    {step:5, phase:"Cruise: Warp 10",           t0:150, t1:240, w0:10, w1:10},
    {step:6, phase:"Ramp down: Warp 10 → 4",    t0:240, t1:300, w0:10, w1:4},
    {step:7, phase:"Approach: Warp 4 → 1",      t0:300, t1:340, w0:4,  w1:1},
    {step:8, phase:"Arrival / field cool-down", t0:340, t1:380, w0:1,  w1:0}
  ];
}
const PLAN = buildFlightPlan();
const PLAN_LEN = PLAN[PLAN.length-1].t1;

function planAt(t){
  for(const s of PLAN){
    if(t>=s.t0 && t<s.t1){
      const span = Math.max(1e-9, s.t1-s.t0);
      const f = clamp((t-s.t0)/span, 0, 1);
      return { s, warp: lerp(s.w0, s.w1, f) };
    }
  }
  const last = PLAN[PLAN.length-1];
  return { s:last, warp:last.w1 };
}
<!-- ======================= PART 3 / 4 ======================= -->
/* ===== Theory mappings (clearly labeled as "toy") ===== */
function corridorStability(w){
  // Smooth closure around Warp 4
  const k = 1/(1+Math.exp(-(w-4)*2.2));
  return clamp(0.15 + 0.85*k, 0, 1);
}
function shearRisk(w){
  return clamp(1 - corridorStability(w), 0, 1);
}
function clockRateFromWarp(w){
  const s = corridorStability(w);
  return clamp(0.82 + 0.18*s, 0.82, 1.0);
}
function expansionCorrection(distanceLy){
  return Math.log1p(distanceLy/1e6) * 0.012; // display-only
}
function tunnelCurvature(w, distanceLy){
  const x = clamp(w/10,0,1);
  const d = clamp(distanceLy/2.537e6, 0, 2);
  return clamp(0.12 + 0.55*x + 0.20*Math.tanh(d), 0, 1);
}
function warpSpeedFactor(w){
  const x = clamp(w/10, 0, 1);
  return 1 + 12*Math.pow(x, 1.6); // 1..13
}
function ftlGain(w, stab){
  // extra lift once corridor is stable (w>=4), but still theory
  const base = warpSpeedFactor(w);
  const bonus = 1 + 0.35*stab*(w>=4?1:0.4);
  return base*bonus;
}

/* Zones + thermal (toy) */
function zoneCompressionPercents(w, stab, breachBoost){
  const base = clamp(10 + 7*w, 0, 100);
  const u = clamp(1 - stab, 0, 1);
  const asym = 18*u;
  return {
    fore: clamp(base + 10*u, 0, 100),
    port: clamp(base - asym, 0, 100),
    star: clamp(base + asym + 0.35*breachBoost, 0, 100),
    aft:  clamp(base - 6 + 8*u, 0, 100),
    core: clamp(12 + 6*w + 8*(1-u), 0, 100),
  };
}
function coreTempC(w, stab, breachBoost){
  const x = w/10;
  return clamp(220 + 900*x*x + 220*(1-stab) + 1.1*breachBoost, 50, 1200);
}
function coolantTempC(w, stab){
  const c = coreTempC(w, stab, 0);
  return clamp(110 + 0.18*c, 90, 520);
}
function photonIonRate(w){ return Math.round(25 + 7*w*w); }
function colliderFlux(w){ return Math.round(40 + 5.0*w*w); }
function magFieldStrength(w, stab, breachBoost){
  return clamp(1.2 + 0.26*w + 1.6*stab + 0.008*breachBoost, 0, 10);
}
function entangleRate(w, stab){ return Math.round(6 + 2.4*w + 10*stab); }
function plasmaCone(w){
  return {len: Math.round(30 + 11*w*w), rad: Math.round(6 + 1.0*w)};
}
function plasmaWave(w, stab){ return clamp(0.08 + 0.04*w + 0.25*(1-stab), 0, 1); }

/* ===== Safety UI (FIX: it now turns green at warp>=4 always) ===== */
function updateSafetyUI(w){
  const safe = (w >= 4);
  safeBox.classList.toggle("safe", safe);
  safeBox.classList.toggle("unsafe", !safe);

  safeTitle.classList.toggle("safe", safe);
  safeTitle.classList.toggle("unsafe", !safe);

  if(safe){
    safeLine.textContent = "✔ Safe: corridor self-contained (warp ≥ 4).";
    safeLine.className = "value good";
  }else{
    safeLine.textContent = "⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.";
    safeLine.className = "value bad";
  }
  safeText.textContent = SAFETY_TEXT_EXACT;
}

/* ===== Ship (always visible) ===== */
function drawShipOutline(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.strokeStyle="rgba(120,180,255,0.85)";
  ctx.lineWidth=2;

  ctx.beginPath();
  // fuselage
  ctx.moveTo(0,-200);
  ctx.quadraticCurveTo(60,-80,60,60);
  ctx.quadraticCurveTo(60,150,0,190);
  ctx.quadraticCurveTo(-60,150,-60,60);
  ctx.quadraticCurveTo(-60,-80,0,-200);

  // left nacelle
  ctx.moveTo(-110,-40);
  ctx.quadraticCurveTo(-160,50,-110,160);
  ctx.quadraticCurveTo(-60,80,-110,-40);

  // right nacelle
  ctx.moveTo(110,-40);
  ctx.quadraticCurveTo(160,50,110,160);
  ctx.quadraticCurveTo(60,80,110,-40);

  ctx.stroke();
  ctx.restore();
}
function drawShipLabels(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.globalAlpha=0.9;
  ctx.fillStyle="rgba(200,235,255,0.92)";
  ctx.font="12px var(--mono)";
  ctx.fillText("Field shell", -42, -235);
  ctx.fillText("Fuselage", -32, -150);
  ctx.fillText("Core", -14, 8);
  ctx.fillText("Port nacelle", -170, 80);
  ctx.fillText("Starboard nacelle", 95, 80);
  ctx.restore();
}

/* ===== Starfield ===== */
const stars=[];
function initStars(n){
  stars.length=0;
  for(let i=0;i<n;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H, sp:0.5+Math.random()*1.6, sz:0.4+Math.random()*1.9});
  }
}
initStars(240);

function updateStars(dt, warp){
  const boost = 1 + warp*0.45;
  for(const s of stars){
    s.y += s.sp*boost;
    if(s.y > H+10){ s.y=-10; s.x=Math.random()*W; s.sp=0.5+Math.random()*1.6; }
  }
}
function drawStars(){
  ctx.save();
  ctx.fillStyle="rgba(255,255,255,0.85)";
  for(const s of stars){
    ctx.globalAlpha = 0.18 + s.sp*0.12;
    ctx.fillRect(s.x, s.y, s.sz, s.sz);
  }
  ctx.restore();
}

/* ===== Protection field ===== */
function drawProtectionField(R, warp, stretchX, stretchY){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.scale(stretchX, stretchY);

  const innerAlpha = 0.18 + warp*0.06;
  const midAlpha   = 0.10 + warp*0.05;

  const g = ctx.createRadialGradient(0,0,R*0.12, 0,0,R);
  g.addColorStop(0, `rgba(200,250,255,${innerAlpha})`);
  g.addColorStop(0.4,`rgba(130,210,255,${midAlpha})`);
  g.addColorStop(1, "rgba(20,40,90,0)");
  ctx.fillStyle=g;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  ctx.globalAlpha = 0.35 + warp*0.04;
  ctx.strokeStyle="rgba(165,225,255,0.95)";
  ctx.lineWidth=1.2 + warp*0.18;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* ===== State ===== */
let running=false;
let tSim=0;
let lastTs=0;

let warp=0;
let warpMode="AUTO";
let trip=null;
let depCST=null;

let breach=false;
let breachT=0;
let boost=0;

/* ===== Dyson vault (minimal but stable) ===== */
const VAULT_KEY="cst_dyson_vault_v1";
let vault = { habits:[], events:[], writes:0, leaks:0, lastTick:0, nextTickIn:4.5 };
let dysonLogLines=[];
function logDyson(line){
  const d=new Date();
  const stamp=`[${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}]`;
  dysonLogLines.unshift(`${stamp} ${line}`);
  if(dysonLogLines.length>40) dysonLogLines.pop();
  dyLog.textContent = dysonLogLines.join("\n");
}
function loadVault(){
  try{
    const raw=localStorage.getItem(VAULT_KEY);
    if(raw){ vault = Object.assign(vault, JSON.parse(raw)); }
  }catch(e){}
}
function saveVault(){
  try{ localStorage.setItem(VAULT_KEY, JSON.stringify(vault)); vault.writes++; }
  catch(e){ vault.leaks++; }
}
function pruneDecayTick(force=false){
  const now = performance.now()/1000;
  if(!force && now - vault.lastTick < 0.01) return;

  const dyOn = dysonOn.checked;
  const habitMult=0.965;
  const eventMult= dyOn ? 0.985 : 0.985*0.96;

  for(const h of vault.habits) h.w *= habitMult;
  for(const e of vault.events) e.w *= eventMult;

  const TH = dyOn ? 0.18 : 0.26;
  const beforeH = vault.habits.length;
  const beforeE = vault.events.length;

  vault.habits = vault.habits.filter(x=>x.w>=TH);
  vault.events = vault.events.filter(x=>x.w>=TH);

  const prunedH = beforeH - vault.habits.length;
  const prunedE = beforeE - vault.events.length;

  vault.lastTick=now;
  vault.nextTickIn=4.5;

  if(dyOn) saveVault();

  const used = clamp((vault.habits.length/60)*0.4 + (vault.events.length/120)*0.6, 0, 1);
  dy_budget.textContent = `${Math.round((1-used)*100)}%`;
  dy_writes.textContent = String(vault.writes);
  dy_leaks.textContent  = String(vault.leaks);
  dy_next.textContent   = fmt(vault.nextTickIn,1)+"s";

  pdBlock.textContent =
`Last tick results
Habit decay multiplier
${fmt(habitMult,3)}
Event decay multiplier
${fmt(eventMult,3)}
Habits before → after
${beforeH} → ${vault.habits.length}
Events before → after
${beforeE} → ${vault.events.length}
Pruned habits
${prunedH}
Pruned events
${prunedE}`;

  logDyson(`Prune/Decay tick: persisted=${dyOn?"YES":"NO"} budget=${dy_budget.textContent} habits=${vault.habits.length} events=${vault.events.length}`);
}
loadVault();
logDyson("Boot: Dyson boundary enabled. Prune/Decay monitor is live.");
pruneDecayTick(true);

/* ===== Trip calculations (best we can do in a theory demo: consistent + transparent) ===== */
function calculateTrip(){
  const d = DEST[destSelect.value] || DEST.Andromeda;
  const D_ly = d.ly;
  const D_km = D_ly * KM_PER_LY;

  const cruiseWarp = (warpMode==="AUTO") ? 10 : clamp(Number(warpMode),0,10);
  const stab = corridorStability(cruiseWarp);
  const gain = ftlGain(cruiseWarp, stab);

  const v = C_KM_S * gain;      // km/s (toy)
  const sec = D_km / v;

  trip = {
    destName:d.name, D_ly, D_km,
    cruiseWarp, stab, gain, v, sec,
    exp: expansionCorrection(D_ly),
    curv: tunnelCurvature(cruiseWarp, D_ly)
  };

  distLbl.textContent = `${fmt(D_ly,0)} ly  (~${fmt(D_km/1e12,2)}×10¹² km)`;
  timeLbl.textContent = `${fmt(sec/86400,2)} days  (${fmt(sec/3600,1)} h)`;
  curvLbl.textContent = `κ = ${fmt(trip.curv,3)}  |  shear = ${fmt(shearRisk(cruiseWarp),3)} (toy)`;
  expLbl.textContent  = `Δ metric ≈ +${fmt(trip.exp,6)} (toy)`;

  const base = getCSTDate();
  const arr = new Date(base.getTime() + sec*1000);
  arrivalClock.textContent = timeStr(arr);
}

/* ===== UI Events ===== */
speed.addEventListener("input", ()=>{
  speedLbl.textContent = speed.value;
  playbackLbl.textContent = speed.value + "×";
});
warpSelect.addEventListener("change", ()=>{ warpMode = warpSelect.value; });
btnCalc.onclick = ()=>calculateTrip();
btnStart.onclick = ()=>{
  if(!trip) calculateTrip();
  if(!depCST) depCST = getCSTDate();
  running=true;
};
btnStop.onclick = ()=>{ running=false; };

btnBreach.onclick = ()=>{ breach=true; breachT=0; };
btnHeal.onclick   = ()=>{ breach=false; breachT=0; boost=0; };

btnDecayNow.onclick = ()=>pruneDecayTick(true);
btnResetUI.onclick  = ()=>{ setTab("Nav"); logDyson("UI reset. Vault kept as-is."); };
btnClearVault.onclick = ()=>{
  vault.habits=[]; vault.events=[]; vault.writes=0; vault.leaks=0;
  try{ localStorage.removeItem(VAULT_KEY); }catch(e){}
  logDyson("Vault cleared.");
  pruneDecayTick(true);
};

/* ===== Logging (report) ===== */
const LOG=[];
function clearLog(){
  LOG.length=0;
  reportSummary.textContent="Log cleared. Run the sim, then click “Build Report”.";
}
btnClearLog.onclick = clearLog;

function buildReport(){
  if(LOG.length===0){
    reportSummary.textContent="No frames logged yet. Click Start, let it run, then click Build Report.";
    return;
  }
  const last = LOG[LOG.length-1];
  reportSummary.textContent =
`Frames logged: ${LOG.length}
Final t=${fmt(last.tSim,1)} s • Warp=${fmt(last.warp,2)} • Stability=${fmt(last.stab,3)} • Shear=${fmt(last.shear,3)}
Field R=${fmt(last.R,1)} • Stretch(rx/ry)=${fmt0(last.rx)} / ${fmt0(last.ry)}
Core=${fmt(last.coreT,0)}°C • Coolant=${fmt(last.coolT,0)}°C
FTL Gain (sim)=${fmt(last.gain,2)}× (toy)`;
}
btnBuildReport.onclick = buildReport;

btnCSV.onclick = ()=>{
  if(LOG.length===0){ reportSummary.textContent="No data to export. Run the sim first."; return; }
  const cols=["tSim","warp","stab","shear","R","rx","ry","coreT","coolT","gain"];
  const lines=[cols.join(",")];
  for(const r of LOG){
    lines.push(cols.map(c=>String(r[c] ?? "")).join(","));
  }
  const blob=new Blob([lines.join("\n")],{type:"text/csv;charset=utf-8"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="cst_warp_log.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
};

/* ===== Panel updates ===== */
function updateClocks(w){
  const u = nowUTC();
  const c = getCSTDate();
  utcClock.textContent = timeStr(u);
  cstClock.textContent = timeStr(c);

  const rate = clockRateFromWarp(w);
  const scaled = new Date(c.getTime() + (running ? (tSim*rate*1000) : 0));
  warpClock.textContent = timeStr(scaled);

  if(trip){
    const base = depCST ? depCST : c;
    const arr  = new Date(base.getTime() + trip.sec*1000);
    arrivalClock.textContent = timeStr(arr);
  }

  const earthElapsed = running ? hmsFromSeconds(tSim) : "—";
  const shipAging    = running ? hmsFromSeconds(tSim*rate) : "—";
  ledgerClock.textContent = `Earth elapsed: ${earthElapsed}\nShip aging:   ${shipAging}\nClock rate:   ${fmt(rate,2)}×`;
}

function updateTelemetryUI(w, stab, R, rx, ry, gain){
  tel_speed.textContent   = "x" + fmt(Number(speed.value)/28.5,1);
  tel_radius.textContent  = fmt(R/210,2);
  tel_shield.textContent  = fmt(stab*100,0) + "%";
  tel_stretch.textContent = `${fmt0(rx)} / ${fmt0(ry)}`;
  tel_clockrate.textContent = fmt(clockRateFromWarp(w),2) + "×";
  tel_photon.textContent  = `${photonIonRate(w)} /s`;
  tel_flux.textContent    = `${colliderFlux(w)} /s`;
  tel_mag.textContent     = fmt(magFieldStrength(w,stab,boost),2);
  tel_coreT.textContent   = `${fmt(coreTempC(w,stab,boost),0)} °C`;
  tel_coolT.textContent   = `${fmt(coolantTempC(w,stab),0)} °C`;
  tel_ent.textContent     = `${entangleRate(w,stab)} /s`;
  const cone = plasmaCone(w);
  tel_cone.textContent    = `${cone.len} u / ${cone.rad} u`;
  tel_wave.textContent    = fmt(plasmaWave(w,stab),2);
  tel_ftl.textContent     = fmt(gain,2) + "×";
}

function updateMathPanels(d, w, stab, gain){
  const H_eff = 58.566; // kept as your display constant
  const D_Mpc = (d.D_ly / 3.26156e6); // ly -> Mpc approx
  const v_rec = H_eff * D_Mpc;
  const v_rec_c = v_rec / C_KM_S;

  const curv = tunnelCurvature(w, d.D_ly);
  const exp  = expansionCorrection(d.D_ly);

  mathBlock.textContent =
`Equations (toy forms)
Recession: v_rec = H · D
Warp gain (demo): γ_FTL = f(warp, stability)
Time: t ≈ D / (c · γ_FTL)

H_eff: ${fmt(H_eff,3)} km/s/Mpc
v_rec(D): ${fmt(v_rec,3)} km/s  (${fmt(v_rec_c,3)} c)

Warp factor: ${fmt(w,2)}
Stability (corridor closure): ${fmt(stab,3)}
Shear risk: ${fmt(shearRisk(w),3)}
Curvature κ (demo): ${fmt(curv,3)}
Expansion term (demo): +${fmt(exp,6)}
Effective FTL Gain (sim): ${fmt(gain,2)}×`;

  // simple “state vectors” (demo)
  const angE = (tSim*0.0004 + 3.44) % (Math.PI*2);
  const angM = (tSim*0.0003 + 1.85) % (Math.PI*2);
  const rE=1.0, rM=1.524;
  const Ex = -Math.cos(angE)*rE, Ey = -Math.sin(angE)*rE;
  const Mx = -Math.cos(angM)*rM, My =  Math.sin(angM)*rM;
  const dX = (Mx-Ex), dY=(My-Ey);
  const d3 = Math.sqrt(dX*dX + dY*dY);

  stateBlock.textContent =
`Earth position (AU, ecliptic plane)
( ${fmt(Ex,3)}, ${fmt(Ey,3)}, 0.000 )
Mars position (AU, ecliptic plane)
( ${fmt(Mx,3)}, ${fmt(My,3)}, 0.000 )
3D distance |r♂ − r⊕|
${fmt(d3,3)} AU`;

  const ok = (w>=4) && (stab>=0.65);
  verifyBlock.textContent =
`Verification Channels (demo)
1) Warp≥4 corridor closure: ${w>=4 ? "YES":"NO"}
2) Stability≥0.65: ${stab>=0.65 ? "YES":"NO"}
3) Combined GO/NO-GO: ${ok ? "GO":"NO-GO"}`;
}
<!-- ======================= PART 4 / 4 ======================= -->
/* ===== Main loop ===== */
function setProgressUI(pct, s){
  progBar.style.width = (pct*100).toFixed(1) + "%";
  progTxt.textContent = `${fmt(pct*100,0)}% • t = ${fmt(tSim,1)} s • phase: ${s ? s.phase : "—"}`;
}

function updateTripLiveUI(w, stab){
  if(!trip) return;
  const curv = tunnelCurvature(w, trip.D_ly);
  const exp  = expansionCorrection(trip.D_ly);
  curvLbl.textContent = `κ = ${fmt(curv,3)}  |  shear = ${fmt(shearRisk(w),3)} (toy)`;
  expLbl.textContent  = `Δ metric ≈ +${fmt(exp,6)} (toy)`;

  const gain = ftlGain(w, stab);
  const v = C_KM_S * gain;
  const sec = trip.D_km / v;
  timeLbl.textContent = `${fmt(sec/86400,2)} days  (${fmt(sec/3600,1)} h)`;
}

function updateBreach(dt, w, stab){
  if(!breach){
    boost = Math.max(0, boost - dt*35);
    containLbl.textContent = (w>=4 && stab>=0.65) ? "Stable" : "Caution";
    containLbl.className = "v " + ((w>=4 && stab>=0.65) ? "good" : "warn");
    boostLbl.textContent = fmt0(boost);
    return;
  }
  breachT += dt;
  boost = clamp(boost + dt*140, 0, 100);
  containLbl.textContent = (stab>=0.45) ? "Stable" : "Unstable";
  containLbl.className = "v " + ((stab>=0.45) ? "good" : "bad");
  boostLbl.textContent = fmt0(boost);

  if(breachT >= 5){
    breach=false; breachT=0;
    logDyson("Breach auto-healed after ~5s (demo).");
  }
}

function updateFieldReadouts(w, stab){
  const warpAssist = clamp(18 + 6.2*w + 12*stab + 0.12*boost, 0, 100);
  const negEnergy  = clamp(14 + 5.7*w + 10*(1-stab) + 0.08*boost, 0, 100);
  warpAssistLbl.textContent = fmt(warpAssist,1) + "%";
  negEnergyLbl.textContent  = fmt(negEnergy,1) + "%";
}

function loop(ts){
  const dt = (ts - lastTs)/1000 || 0;
  lastTs = ts;

  // background clear
  ctx.fillStyle = "#020617";
  ctx.fillRect(0,0,W,H);

  // time advance
  const playback = Number(speed.value);
  speedLbl.textContent = speed.value;
  playbackLbl.textContent = speed.value + "×";

  if(running){
    tSim += dt * playback;
    if(tSim >= PLAN_LEN){
      tSim = PLAN_LEN;
      running=false;
      logDyson("Arrival: flight plan completed.");
    }
  }

  // warp selection
  let step = null;
  if(warpMode==="AUTO"){
    const st = planAt(tSim);
    step = st.s;
    warp = st.warp;
  }else{
    warp = clamp(Number(warpMode),0,10);
    step = planAt(tSim).s;
  }

  // stability
  const stabBase = corridorStability(warp);
  const stab = clamp(stabBase - 0.0035*boost, 0, 1);

  // safety colors (fix)
  updateSafetyUI(warp);

  // stars
  updateStars(dt, warp);
  drawStars();

  // field geometry
  const baseR = 210;
  const pulse = 0.12*Math.sin(ts*0.004) + 0.88;
  const warpBoost = 1 + warp*0.12;
  const R = baseR*pulse*warpBoost;

  const u = 1 - stab;
  const sx = 1 + 0.35*warp + 0.28*u + 0.012*boost;
  const sy = 1 + 0.22*warp - 0.18*u;

  drawProtectionField(R, warp, sx, sy);

  // ship always last on top of field
  drawShipOutline();
  drawShipLabels();

  // progress
  const pct = clamp(tSim/PLAN_LEN, 0, 1);
  setProgressUI(pct, step);

  // clocks
  updateClocks(warp);

  // breach
  updateBreach(dt, warp, stab);
  updateFieldReadouts(warp, stab);

  // telemetry
  const gain = ftlGain(warp, stab);
  updateTelemetryUI(warp, stab, R, sx*R, sy*R, gain);

  // math
  const d = trip ? trip : (()=>{ const dd=DEST[destSelect.value]||DEST.Andromeda; return {destName:dd.name, D_ly:dd.ly, D_km:dd.ly*KM_PER_LY}; })();
  updateMathPanels(d, warp, stab, gain);

  // trip live labels
  updateTripLiveUI(warp, stab);

  // dyson tick countdown
  vault.nextTickIn = Math.max(0, vault.nextTickIn - dt);
  dy_next.textContent = fmt(vault.nextTickIn,1)+"s";
  if(vault.nextTickIn<=0) pruneDecayTick(true);

  // report logging
  if(running){
    const coreT = coreTempC(warp, stab, boost);
    const coolT = coolantTempC(warp, stab);
    LOG.push({
      tSim, warp, stab,
      shear: shearRisk(warp),
      R, rx: sx*R, ry: sy*R,
      coreT, coolT,
      gain
    });
    if(LOG.length>20000) LOG.shift();
  }

  requestAnimationFrame(loop);
}

/* ===== Start defaults (so you immediately SEE ship + panels) ===== */
setTab("Nav");
speedLbl.textContent = speed.value;
playbackLbl.textContent = speed.value + "×";
updateSafetyUI(0);
calculateTrip();
clearLog();
requestAnimationFrame(loop);

</script>
</body>
</html>
