<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Warp + Disk View + Ledger + Breach (Restored)</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#020617;
    --panel:rgba(12,22,52,0.78);
    --ink:#e8f3ff;
    --muted:#9ac7ff;
    --line:rgba(130,190,255,0.42);
    --good:#7bff9f;
    --warn:#ffcc66;
    --bad:#ff7272;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  html,body{
    margin:0; height:100%;
    background:var(--bg);
    overflow:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:var(--ink);
  }
  canvas{ position:fixed; inset:0; z-index:0; }

  /* ===== STACK LAYOUT (NO OVERLAP) ===== */
  .stack{
    position:fixed; top:10px; bottom:10px;
    width:440px; max-width:92vw;
    display:flex; flex-direction:column; gap:10px;
    overflow:auto; padding-right:6px;
    z-index:10;
  }
  #leftStack{ left:10px; }
  #rightStack{ right:10px; }

  .hudpanel{
    background:var(--panel);
    padding:12px 14px;
    border:1px solid var(--line);
    border-radius:12px;
    backdrop-filter:blur(10px);
    font-size:13px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
  }
  h2{ margin:0 0 6px; font-size:15px; letter-spacing:.04em; }
  .label{ margin-top:8px; font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em; }
  .value{ margin-top:3px; font-size:13px; }
  .mono{ font-family:var(--mono); }
  .tiny{ font-size:11px; color:#b9d7ff; line-height:1.25; }
  .small{ font-size:12px; color:#c7e2ff; line-height:1.25; }
  .hr{ height:1px; background:rgba(148,163,184,.18); margin:10px 0; }
  .good{ color:var(--good); }
  .warn{ color:var(--warn); }
  .bad{ color:var(--bad); }

  select,button,input[type="range"]{
    width:100%;
    padding:7px 8px;
    margin-top:6px;
    background:#0c1634;
    color:#d5e9ff;
    border:1px solid #3d67b8;
    border-radius:8px;
    font-size:14px;
    cursor:pointer;
  }
  button{ font-weight:900; }
  button:hover{ filter:brightness(1.06); }
  #engageBtn{ background:#003ae3; }
  #stopBtn{ background:#3a0a0a; border-color:#b84747; }
  #calcBtn{ background:#0b2448; border-color:#4a78c9; }

  .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
  .btnrow button{ width:auto; flex:1; min-width:130px; }

  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }

  .bar{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    overflow:hidden;
    border:1px solid rgba(148,163,184,.18);
  }
  .bar i{
    display:block; height:100%; width:0%;
    background:linear-gradient(90deg, rgba(96,165,250,.95), rgba(52,211,153,.85));
  }

  table{ width:100%; border-collapse:collapse; font-size:12px; }
  th,td{ border-bottom:1px solid rgba(148,163,184,.16); padding:8px 6px; vertical-align:top; }
  th{ text-align:left; color:#b6d6ff; position:sticky; top:0; background:rgba(7,10,20,.85); backdrop-filter: blur(6px); }
  tr.active{ outline:2px solid rgba(96,165,250,.55); background:rgba(96,165,250,.10); }

  .prebox{
    white-space:pre-wrap;
    font-family:var(--mono);
    background:rgba(2,6,23,.28);
    border:1px solid rgba(148,163,184,.16);
    border-radius:10px;
    padding:8px;
    margin-top:8px;
  }
  .toggleRow{
    display:flex; gap:12px; align-items:center;
    flex-wrap:wrap; margin-top:8px;
  }
  .toggleRow label{
    display:flex; gap:8px; align-items:center;
    font-size:12px; color:#cfe6ff;
  }
  .toggleRow input{ transform:scale(1.05); }

  .safeLine{ color:var(--good); font-weight:900; }
  .unsafeLine{ color:var(--bad); font-weight:900; }
  .noteLine{ color:#cfe6ff; }

  /* Error overlay (so nothing "dies" silently) */
  #errBox{
    position:fixed;
    left:10px; top:10px;
    z-index:9999;
    width:min(720px, calc(100vw - 20px));
    display:none;
    background:rgba(90,16,16,.92);
    border:1px solid rgba(251,113,133,.75);
    border-radius:14px;
    padding:10px;
    box-shadow:0 18px 40px rgba(0,0,0,.45);
    font-family:var(--mono);
    white-space:pre-wrap;
  }

  /* Print styling */
  @media print{
    body{ background:#fff !important; color:#000 !important; overflow:visible !important; }
    canvas, #leftStack, #rightStack, #errBox{ display:none !important; }
    #printArea{ display:block !important; }
    #printArea *{ color:#000 !important; }
  }
  #printArea{ display:none; position:relative; padding:14px; font-family:Segoe UI,Arial; }
  #printArea h2{ margin:10px 0 6px; }
  #printArea .pbox{ border:1px solid #bbb; padding:10px; margin:10px 0; }
  #printArea table{ width:100%; border-collapse:collapse; }
  #printArea th,#printArea td{ border:1px solid #bbb; padding:6px; font-size:12px; }
</style>
</head>

<body>
<canvas id="sim"></canvas>
<div id="errBox"></div>

<!-- LEFT STACK -->
<div class="stack" id="leftStack">
  <div class="hudpanel" id="panelMain">
    <h2>Warp Navigation Panel</h2>

    <div class="label">Warp Factor (0 – 10)</div>
    <select id="warpSelect">
      <option value="0">0 — Idle</option>
      <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option>
      <option value="4">Warp 4</option><option value="5">Warp 5</option><option value="6">Warp 6</option>
      <option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option>
      <option value="10">Warp 10</option>
    </select>

    <button id="calcBtn">1 — Calculate Trip</button>
    <button id="engageBtn">2 — Engage Warp Drive</button>
    <button id="stopBtn">STOP ENGINE</button>

    <div class="label">Simulation speed</div>
    <input id="simSpeed" type="range" min="1" max="500" value="60">
    <div class="tiny mono">Playback: <span id="simSpeedLbl">60×</span> (sim-seconds per real second)</div>

    <div class="value tiny" id="msg" style="min-height:18px;margin-top:8px"></div>

    <div class="label">CST Warp Corridor Safety</div>
    <div class="prebox" id="safeMsg"></div>

    <div class="bar" style="margin-top:10px"><i id="progBar"></i></div>
    <div class="tiny mono">Progress: <span id="progPct">0</span>% • Step <span id="stepNow">—</span> • <span id="phaseNow">—</span></div>

    <div class="toggleRow">
      <label><input type="checkbox" id="labelsOn" checked> Ship part labels</label>
      <label><input type="checkbox" id="logOn" checked> Log every frame</label>
    </div>
  </div>

  <div class="hudpanel" id="panelPlan">
    <h2>Warp Flight Plan • Earth → Andromeda</h2>
    <div class="small">
      Conceptual plan converted to <b>warp corridor formation</b>, <b>field compression</b>, and <b>time dilation readouts</b>.
    </div>

    <div class="label">Trip Distance</div>
    <select id="distPreset">
      <option value="andromeda" selected>Andromeda Galaxy (nearest major galaxy)</option>
      <option value="localgroup">Local Group Scale (shorter demo)</option>
      <option value="custom">Custom</option>
    </select>

    <div class="label">Custom distance (light-years)</div>
    <input id="distLY" type="range" min="1000" max="3000000" value="2537000">
    <div class="value mono">Distance = <span id="distLYLbl">2,537,000</span> ly</div>

    <div class="hr"></div>

    <div class="label">Flight Plan Timeline</div>
    <div class="tiny">Active step highlights as the trip runs. Warp ramps 1→10 then back down at arrival.</div>

    <div style="margin-top:8px; max-height:280px; overflow:auto; border:1px solid rgba(148,163,184,.16); border-radius:10px;">
      <table>
        <thead>
          <tr><th>Step</th><th>Phase</th><th>Warp</th><th>Duration</th><th>CST Discipline</th></tr>
        </thead>
        <tbody id="planBody"></tbody>
      </table>
    </div>
  </div>

  <div class="hudpanel" id="panelDisk">
    <h2>Disk View — Earth at center (R is visual radius)</h2>

    <div class="label">Visual radius R (px)</div>
    <input id="diskR" type="range" min="220" max="700" value="420">
    <div class="tiny mono">R = <span id="diskRLbl">420</span> px</div>

    <div class="label">Nonlinear radial map α (expand inner / compress outer)</div>
    <input id="diskAlpha" type="range" min="10" max="300" value="110">
    <div class="tiny mono">α = <span id="diskAlphaLbl">1.10</span></div>

    <div class="label">Warp factor (×c)</div>
    <input id="diskWarp" type="range" min="1" max="30" value="10">
    <div class="tiny mono">Warp factor = <span id="diskWarpLbl">10</span>×c</div>

    <div class="label">Destination planet</div>
    <select id="diskDest">
      <option value="mars" selected>Mars</option>
      <option value="jupiter">Jupiter</option>
      <option value="saturn">Saturn</option>
      <option value="neptune">Neptune</option>
    </select>

    <div class="toggleRow">
      <label><input type="checkbox" id="diskOrbits" checked> Show orbits</label>
      <label><input type="checkbox" id="diskTunnelArc" checked> Tunnel style: Curved (arc)</label>
    </div>

    <div class="prebox" id="diskExplain"></div>
    <div class="prebox" id="diskReadout"></div>
  </div>

  <div class="hudpanel" id="panelLedger">
    <h2>updateMath & CST Ledger</h2>
    <div class="label">Equations (toy forms)</div>
    <div class="prebox" id="eqBox"></div>

    <div class="label">Live Outputs</div>
    <div class="prebox" id="mathOut"></div>

    <div class="label">CST Time Ledger (Warp-Hole/Tunnel)</div>
    <div class="prebox" id="ledgerOut"></div>
  </div>

  <div class="hudpanel" id="panelReport">
    <h2>Report Tools</h2>
    <div class="tiny">Logs every frame: Warp / Distance / FieldPressure / Compression / Stability / Coolant / Power / Dilation + Zone compression%.</div>
    <div class="btnrow">
      <button id="btnBuild">Build Report</button>
      <button id="btnPrint">Print Report</button>
      <button id="btnCSV">Download CSV</button>
      <button id="btnClear">Clear Log</button>
    </div>
    <div class="prebox" id="reportSummary">Log cleared. Run the sim, then click “Build Report”.</div>
  </div>
</div>

<!-- RIGHT STACK -->
<div class="stack" id="rightStack">
  <div class="hudpanel" id="panelClocks">
    <h2>Time Synchronization</h2>
    <div class="label">CST Synchronized Time (reference)</div>
    <div class="value mono" id="cstClock">--:--:--</div>
    <div class="label">Ship Clock (CST-locked display)</div>
    <div class="value mono" id="shipClock">--:--:--</div>
    <div class="label">External Time Drift (Earth vs Ship)</div>
    <div class="value mono" id="driftClock">--</div>
    <div class="label">Estimated Arrival (CST)</div>
    <div class="value mono" id="arrivalClock">--:--:--</div>
    <div class="label">Estimated Arrival (Earth frame)</div>
    <div class="value mono" id="arrivalEarthClock">--</div>
  </div>

  <div class="hudpanel" id="panelPhysics">
    <h2>Warp Physics Readout</h2>
    <div class="row2">
      <div><div class="label">Distance Remaining</div><div class="value mono" id="distRemain">--</div></div>
      <div><div class="label">Travel Time Remaining</div><div class="value mono" id="timeRemain">--</div></div>
    </div>
    <div class="row2">
      <div><div class="label">Field Pressure (proxy)</div><div class="value mono" id="pressVal">--</div></div>
      <div><div class="label">Compression (0–100%)</div><div class="value mono" id="compVal">--</div></div>
    </div>
    <div class="row2">
      <div><div class="label">Stability Score</div><div class="value mono" id="stabVal">--</div></div>
      <div><div class="label">Coolant Flow (kg/s)</div><div class="value mono" id="coolVal">--</div></div>
    </div>
    <div class="row2">
      <div><div class="label">Power Draw (arb units)</div><div class="value mono" id="pwrVal">--</div></div>
      <div><div class="label">Time Dilation (Earth vs Ship)</div><div class="value mono" id="dilVal">--</div></div>
    </div>
    <div class="label">Mass–Energy Conversion (display index)</div>
    <div class="value mono" id="emcVal">--</div>
  </div>

  <div class="hudpanel" id="panelAEWFC">
    <h2>How Electrons Could Warp Spacetime — The Quantum Core of a Warp Engine</h2>
    <div class="tiny">FOBAS + AEWFC • by Gabino Casanova</div>
    <div class="prebox" id="aewfcText"></div>
    <div class="label">Physics Explainer Legend</div>
    <div class="prebox mono" id="aewfcLegend"></div>
  </div>

  <div class="hudpanel" id="panelBreach">
    <h2>Breach Simulation</h2>
    <div class="btnrow">
      <button id="btnBreachStar">Trigger Breach (Starboard)</button>
      <button id="btnHeal">Heal Now</button>
    </div>

    <div class="label">Shield Boost (Starboard)</div>
    <div class="bar"><i id="boostBar"></i></div>
    <div class="tiny mono"><span id="boostLbl">0</span>%</div>

    <div class="label">Field Readouts</div>
    <div class="row2">
      <div><div class="tiny">Warp-Assist Index</div><div class="mono" id="warpAssistLbl">--</div></div>
      <div><div class="tiny">Negative-Energy Likelihood</div><div class="mono" id="negEnergyLbl">--</div></div>
    </div>
    <div style="margin-top:8px" class="row2">
      <div><div class="tiny">Breach Containment</div><div class="mono" id="containLbl">--</div></div>
      <div><div class="tiny">Auto-heal ETA</div><div class="mono" id="healEtaLbl">--</div></div>
    </div>

    <div class="label">Purpose (Short & Professional)</div>
    <div class="prebox" id="purposeText"></div>
  </div>
</div>

<!-- PRINT AREA -->
<section id="printArea">
  <h2>CST Warp Drive — Report</h2>
  <div class="pbox" id="printSummary">—</div>
  <div class="pbox">
    <h2 style="font-size:16px;margin:0 0 6px">Zone Compression Stats</h2>
    <div id="printZones">—</div>
  </div>
  <div class="pbox">
    <h2 style="font-size:16px;margin:0 0 6px">Frame Log (first 200 rows)</h2>
    <div id="printLog">—</div>
  </div>
</section>

<script>
/* ===================== HARDENED STARTUP (show errors) ===================== */
(() => {
  const errBox = document.getElementById("errBox");
  function showErr(msg){
    errBox.style.display="block";
    errBox.textContent = msg;
  }
  window.addEventListener("error", (e)=>{
    showErr("JS ERROR:\n" + (e.message||e.error||"Unknown") + "\n" + (e.filename||"") + ":" + (e.lineno||""));
  });
  window.addEventListener("unhandledrejection", (e)=>{
    showErr("PROMISE ERROR:\n" + (e.reason?.message || String(e.reason||"Unknown")));
  });
})();

/* ===================== Helpers + DOM ===================== */
const el = (id)=>document.getElementById(id);
const fmt = (x,d=2)=> (isFinite(x)?Number(x).toFixed(d):"—");
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

const safeMsgEl = el("safeMsg");
const msgEl = el("msg");

function setMessage(s){ msgEl.textContent = s; }

/* ===================== Safety text (RESTORED & FIXED) ===================== */
const SAFETY_BLOCK = `UNSAFE (Warp < 4):
At low warp factors the spacetime compression shell is incomplete.
The magnetic field cannot fully enclose the craft, allowing asymmetric compression
and temporal shear to interact with the hull.

SAFE (Warp ≥ 4):
Above Warp 4 the CST corridor becomes self-contained.
Compression gradients close smoothly around the craft, magnetic shielding stabilizes,
and external spacetime shear is redirected around the hull instead of through it.

Note: This is not structural failure — it is corridor formation.`;

function updateSafetyPanel(w){
  const headline = (w >= 4)
    ? `<div class="safeLine">✔ Safe: CST corridor self-contained (Warp ≥ 4).</div>`
    : `<div class="unsafeLine">⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.</div>`;
  safeMsgEl.innerHTML = headline + `<div class="noteLine" style="margin-top:8px;white-space:pre-wrap">${SAFETY_BLOCK}</div>`;
}

/* ===================== AEWFC panels (RESTORED) ===================== */
el("aewfcText").textContent =
`Electron (−) charge lights the engine coils and circulates coherently to form a warp-assist pocket.
The spacetime grid “bends” visually; on a hull/compartment breach, the EM shield auto-boosts on the affected side
and then auto-heals after ~5 s. CST phase keeps everything in lockstep.
(Concept visualization; not a physics solver.)`;

el("aewfcLegend").textContent =
`Legend • Electron (− charge) • Coil Lighting • Pocket Edge • EM Shield`;

el("purposeText").textContent =
`AEWFC drives a negative-charge electron lattice, forming a central negative-energy pocket that assists warp control.
On breach, the shield boosts locally and auto-heals after ~5 s, keeping pocket stability under CST phase.
Concept visualization only.`;

/* ===================== Equations box (FIXED STRINGS) ===================== */
el("eqBox").textContent =
`Recession: v_rec = H · D
FTL time (drag model): t = (1/H) · ln[(f·c)/(f·c − H·D)]
Required f for target t: f = (H·D/c) / (1 − e^{−H·t})

Warp-tunnel jumps: N = ceil((1+margin)·D / J), T_ext ≈ N · τ_lat
Warp Meter: v_ext = L / Δt_E, v_ship = L / Δt_S, k = v/c`;

/* ===================== Canvas + Stars + Particles + Ship ===================== */
const canvas = el("sim");
const ctx = canvas.getContext("2d");
let W=0,H=0,cx=0,cy=0;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W/2; cy = H/2;
}
window.addEventListener("resize", resize);
resize();

const labelsOnEl = el("labelsOn");

/* Stars */
const stars = [];
function initStars(n){
  stars.length = 0;
  for(let i=0;i<n;i++){
    stars.push({ x:Math.random()*W, y:Math.random()*H, s:0.5+Math.random()*1.5, z:0.6+Math.random()*1.6 });
  }
}
initStars(240);

function updateStars(dt, warp){
  const boost = 1 + warp*0.45;
  for(const st of stars){
    st.y += st.s*boost*60*dt;
    if(st.y > H+10){
      st.y=-10; st.x=Math.random()*W; st.s=0.5+Math.random()*1.5;
    }
  }
}
function drawStars(){
  ctx.save();
  for(const st of stars){
    ctx.globalAlpha = 0.18 + st.s*0.12;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillRect(st.x, st.y, st.z, st.z);
  }
  ctx.restore();
}

/* Core particles */
const coreParticles = [];
function newCoreParticle(){
  return { a:Math.random()*Math.PI*2, r:Math.random()*10, max:70+Math.random()*60, sp:0.06+Math.random()*0.14, size:1+Math.random()*2, life:Math.random() };
}
for(let i=0;i<240;i++) coreParticles.push(newCoreParticle());

function updateCoreParticles(dt, warp){
  const speedBoost = 1 + warp*0.75;
  for(const p of coreParticles){
    p.r += p.sp*110*dt*speedBoost;
    p.life += dt*0.55;
    if(p.r > p.max || p.life > 1) Object.assign(p, newCoreParticle());
  }
}
function drawCoreParticles(warp){
  ctx.save();
  ctx.translate(cx,cy);
  for(const p of coreParticles){
    const x = Math.cos(p.a)*p.r;
    const y = Math.sin(p.a)*p.r*0.8;
    const alpha = (1 - p.life) * (0.55 + warp*0.035);
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(x,y,p.size,0,Math.PI*2);
    ctx.fillStyle = "rgba(190,245,255,1)";
    ctx.fill();
  }
  ctx.restore();
}

/* Engine particles */
const engineLeft = [], engineRight = [];
function newEngineParticle(){
  return { x:0, y:0, vx:(Math.random()-0.5)*0.6, vy:2+Math.random()*2.5, life:0.7+Math.random()*1.1 };
}
for(let i=0;i<180;i++) engineLeft.push(newEngineParticle());
for(let i=0;i<180;i++) engineRight.push(newEngineParticle());

function updateEngineParticles(dt, warp){
  const boost = 1 + warp*2.35;
  for(const e of engineLeft){
    e.x += e.vx*boost; e.y += e.vy*boost;
    e.life -= dt*0.42;
    if(e.life<=0) Object.assign(e, newEngineParticle());
  }
  for(const e of engineRight){
    e.x += e.vx*boost; e.y += e.vy*boost;
    e.life -= dt*0.42;
    if(e.life<=0) Object.assign(e, newEngineParticle());
  }
}
function drawEngineParticles(){
  ctx.save();
  ctx.translate(cx-110, cy+60);
  for(const e of engineLeft){
    ctx.globalAlpha = e.life;
    ctx.beginPath(); ctx.arc(e.x,e.y,2,0,Math.PI*2);
    ctx.fillStyle="rgba(120,220,255,1)"; ctx.fill();
  }
  ctx.restore();

  ctx.save();
  ctx.translate(cx+110, cy+60);
  for(const e of engineRight){
    ctx.globalAlpha = e.life;
    ctx.beginPath(); ctx.arc(e.x,e.y,2,0,Math.PI*2);
    ctx.fillStyle="rgba(120,220,255,1)"; ctx.fill();
  }
  ctx.restore();
}

/* Ship outline */
function drawShipOutline(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.strokeStyle = "rgba(120,180,255,0.7)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  // fuselage
  ctx.moveTo(0,-200);
  ctx.quadraticCurveTo(60,-80,60,60);
  ctx.quadraticCurveTo(60,150,0,190);
  ctx.quadraticCurveTo(-60,150,-60,60);
  ctx.quadraticCurveTo(-60,-80,0,-200);
  // left nacelle
  ctx.moveTo(-110,-40);
  ctx.quadraticCurveTo(-160,50,-110,160);
  ctx.quadraticCurveTo(-60,80,-110,-40);
  // right nacelle
  ctx.moveTo(110,-40);
  ctx.quadraticCurveTo(160,50,110,160);
  ctx.quadraticCurveTo(60,80,110,-40);
  ctx.stroke();
  ctx.restore();
}
function drawShipLabels(){
  if(!labelsOnEl.checked) return;
  ctx.save();
  ctx.translate(cx,cy);
  const mono = getComputedStyle(document.documentElement).getPropertyValue("--mono").trim() || "monospace";
  ctx.font = "12px " + mono;
  ctx.fillStyle = "rgba(205,235,255,0.92)";
  ctx.globalAlpha = 0.95;
  ctx.fillText("DOME", -22, -185);
  ctx.fillText("RIM (FORE)", -45, -115);
  ctx.fillText("RIM (AFT)", -38, 135);
  ctx.fillText("BELLY", -22, 175);
  ctx.fillText("PORT NACELLE", -205, 75);
  ctx.fillText("STARBOARD NACELLE", 95, 75);
  ctx.restore();
}

/* Protection field */
function drawProtectionField(R, warp){
  const innerAlpha = 0.18 + warp*0.06;
  const midAlpha = 0.10 + warp*0.05;
  ctx.save();
  ctx.translate(cx,cy);
  const g = ctx.createRadialGradient(0,0,R*0.15, 0,0,R);
  g.addColorStop(0, `rgba(200,250,255,${innerAlpha})`);
  g.addColorStop(0.4, `rgba(130,210,255,${midAlpha})`);
  g.addColorStop(1, "rgba(20,40,90,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.4 + warp*0.04;
  ctx.strokeStyle = "rgba(165,225,255,0.95)";
  ctx.lineWidth = 1.5 + warp*0.2;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

function warpEnergy(warp){ return 0.25 + (warp/10)*0.75; }
function drawCore(ts, warp){
  const energy = warpEnergy(warp);
  const t = ts*0.008;
  ctx.save();
  ctx.translate(cx,cy);

  const coreR = 14 + 10*energy*Math.sin(t*4);
  ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.fill();

  const cor = coreR*1.9;
  const cg = ctx.createRadialGradient(0,0,coreR*0.2, 0,0,cor);
  cg.addColorStop(0,"rgba(255,255,255,0.9)");
  cg.addColorStop(0.4,"rgba(255,210,160,0.65)");
  cg.addColorStop(1,"rgba(255,120,80,0)");
  ctx.fillStyle = cg;
  ctx.beginPath(); ctx.arc(0,0,cor,0,Math.PI*2); ctx.fill();

  const reactorR = 55;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(0,255,180,0.9)";
  ctx.lineWidth = 1.3;
  ctx.setLineDash([7,4]);
  ctx.arc(0,0,reactorR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  const fissionR = 95;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(255,190,80,0.9)";
  ctx.lineWidth = 1.3;
  ctx.setLineDash([9,5]);
  ctx.arc(0,0,fissionR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = "rgba(190,235,255,0.9)";
  ctx.font = "12px Segoe UI";
  ctx.fillText("Nuclear Reactor", -60, reactorR+14);
  ctx.fillText("Fission Converter", -68, fissionR+16);
  ctx.fillText("E = mc²", -24, -reactorR-10);
  ctx.fillText("m = E / c²", -32, -fissionR-10);

  ctx.restore();
}

/* ===================== Plan + Physics + Disk + Ledger + Log ===================== */
let warp = 0;
let running = false;
let simT = 0;        // sim seconds
let simSpeed = 60;   // sim seconds per real second
let lastTs = 0;

const logOnEl = el("logOn");
const warpSelect = el("warpSelect");
const calcBtn = el("calcBtn");
const engageBtn = el("engageBtn");
const stopBtn = el("stopBtn");
const simSpeedEl = el("simSpeed");
const simSpeedLbl = el("simSpeedLbl");
const progBar = el("progBar");
const progPct = el("progPct");
const stepNow = el("stepNow");
const phaseNow = el("phaseNow");

const cstClockEl = el("cstClock");
const shipClockEl = el("shipClock");
const driftClockEl = el("driftClock");
const arrivalClockEl = el("arrivalClock");
const arrivalEarthClockEl = el("arrivalEarthClock");

const distRemainEl = el("distRemain");
const timeRemainEl = el("timeRemain");
const pressValEl = el("pressVal");
const compValEl = el("compVal");
const stabValEl = el("stabVal");
const coolValEl = el("coolVal");
const pwrValEl = el("pwrVal");
const dilValEl = el("dilVal");
const emcValEl = el("emcVal");

/* Distance presets */
const PRESETS = { andromeda: 2537000, localgroup: 100000 };
const distPresetEl = el("distPreset");
const distLYEl = el("distLY");
const distLYLbl = el("distLYLbl");

function setDistUIFromPreset(){
  const p = distPresetEl.value;
  if(p !== "custom") distLYEl.value = String(PRESETS[p] || PRESETS.andromeda);
  distLYLbl.textContent = Number(distLYEl.value).toLocaleString();
}
distPresetEl.onchange = setDistUIFromPreset;
distLYEl.oninput = ()=> distLYLbl.textContent = Number(distLYEl.value).toLocaleString();
setDistUIFromPreset();

/* Warp flight plan */
const PLAN = [
  {step:1, phase:"Departure / Field warm-up", w0:0, w1:1,  dur:30,  cst:"Lock CST baseline; verify field symmetry."},
  {step:2, phase:"Corridor forming",        w0:1, w1:3,  dur:60,  cst:"Monitor shear; stability must remain controlled."},
  {step:3, phase:"Corridor closure check",  w0:3, w1:4,  dur:50,  cst:"Verify closure threshold; log asymmetric zones."},
  {step:4, phase:"Ramp to cruise",          w0:4, w1:10, dur:120, cst:"Stability trend must improve with warp."},
  {step:5, phase:"Warp-10 cruise window",   w0:10,w1:10, dur:240, cst:"Hold deterministic logs; keep CST-locked display."},
  {step:6, phase:"Decelerate / arrival shear", w0:10,w1:4, dur:120, cst:"Control corridor collapse; prevent shell breakup."},
  {step:7, phase:"Final approach / corridor off", w0:4,w1:0, dur:60, cst:"Return to idle; finalize drift summary."}
];
const planBody = el("planBody");

function buildPlanTable(){
  planBody.innerHTML = "";
  for(const p of PLAN){
    const tr = document.createElement("tr");
    tr.dataset.step = String(p.step);
    tr.innerHTML = `
      <td class="mono">${p.step}</td>
      <td>${p.phase}</td>
      <td class="mono">${p.w0}→${p.w1}</td>
      <td class="mono">${p.dur}s</td>
      <td>${p.cst}</td>`;
    planBody.appendChild(tr);
  }
}
buildPlanTable();

function highlightPlan(step){
  const rows = planBody.querySelectorAll("tr");
  rows.forEach(r=>{
    const s = Number(r.dataset.step);
    r.classList.toggle("active", (step!=null && s===step));
  });
}

let totalPlanDur = PLAN.reduce((a,p)=>a+p.dur,0);

function planAt(timeSec){
  let acc = 0;
  for(const p of PLAN){
    const t0 = acc, t1 = acc + p.dur;
    if(timeSec >= t0 && timeSec < t1){
      const frac = (timeSec - t0) / Math.max(1e-9, p.dur);
      const w = p.w0 + frac*(p.w1 - p.w0);
      return {p, frac, w};
    }
    acc = t1;
  }
  return {p:PLAN[PLAN.length-1], frac:1, w:0};
}

/* Warp math (toy proxies) */
const C_KM_S = 299792.458;
const LY_KM = 9.460730472e12;

function warpSpeedKmS(w){
  const eff = Math.max(w, 1);
  return C_KM_S * Math.pow(eff, 1.5);
}
function fieldPressure(w){ return 0.6 + 0.08*w*w; }
function compressionPct(w){ return clamp((w/10),0,1)*100; }

/* Breach state */
let breachActive = false;
let breachT = 0;
let starBoost = 0;
const AUTO_HEAL_SEC = 5.0;

function stabilityScore(w, wDot, zoneAsym){
  const base = (w < 4) ? 0.35 + 0.08*w : 0.65 + 0.03*w;
  const rampPen = clamp(Math.abs(wDot)/3.0,0,1)*0.25;
  const asymPen = clamp(zoneAsym/40,0,1)*0.22;
  const breachPen = breachActive ? (0.22 * (1 - starBoost)) : 0;
  return clamp(base - rampPen - asymPen - breachPen, 0, 1);
}
function coolantFlowKgS(w, wDot, stab){
  const ramp = Math.abs(wDot);
  const breachCool = breachActive ? (2.4 * (0.2 + starBoost)) : 0;
  return clamp(0.4 + 0.12*w + 0.25*ramp + (1-stab)*0.9 + breachCool, 0, 80);
}
function powerDraw(w, wDot, stab){
  const breachPower = breachActive ? (120*starBoost) : 0;
  return 50 + 8*w*w + 30*Math.abs(wDot) + 60*(1-stab) + breachPower;
}
function dilationFracEarthVsShip(w){
  return Math.min(0.92, 0.015*w*w);
}

/* Distance progress */
let distTotalKm = 0;
let distTraveledKm = 0;
function computeTrip(){
  const ly = Number(distLYEl.value);
  distTotalKm = ly * LY_KM;
  distTraveledKm = 0;
}

/* Logging */
const LOG = [];
const ZONES = ["Dome","Rim-Front","Rim-Rear","Belly","Port","Starboard"];
function newZoneStats(){
  const s = {};
  for(const z of ZONES) s[z] = {frames:0, peak:0, sum:0, hits:0};
  return s;
}
let zoneStats = newZoneStats();

function clearLog(){
  LOG.length = 0;
  zoneStats = newZoneStats();
  el("reportSummary").textContent = "Log cleared. Run the sim, then click “Build Report”.";
  el("printSummary").textContent = "—";
  el("printZones").textContent = "—";
  el("printLog").textContent = "—";
}

/* CST time (Monterrey is UTC-6; keep consistent) */
function getCSTDate(){
  const now = new Date();
  const utcMs = now.getTime() + now.getTimezoneOffset()*60000;
  return new Date(utcMs - 6*3600000);
}
function hms(date){ return date.toTimeString().split(" ")[0]; }

/* UI wiring */
simSpeedEl.oninput = ()=>{
  simSpeed = Number(simSpeedEl.value);
  simSpeedLbl.textContent = simSpeed + "×";
};
simSpeedEl.oninput();

warpSelect.onchange = ()=>{
  warp = Number(warpSelect.value);
  updateSafetyPanel(warp);
};

/* Disk view */
const diskR = el("diskR"), diskRLbl = el("diskRLbl");
const diskAlpha = el("diskAlpha"), diskAlphaLbl = el("diskAlphaLbl");
const diskWarp = el("diskWarp"), diskWarpLbl = el("diskWarpLbl");
const diskDest = el("diskDest");
const diskTunnelArc = el("diskTunnelArc");
const diskExplain = el("diskExplain");
const diskReadout = el("diskReadout");

function updateDiskLabels(){
  diskRLbl.textContent = diskR.value;
  diskAlphaLbl.textContent = fmt(Number(diskAlpha.value)/100,2);
  diskWarpLbl.textContent = diskWarp.value;
}

const ORBITS_AU = { mercury:0.39, venus:0.72, earth:1.00, mars:1.52, jupiter:5.20, saturn:9.58, neptune:30.07 };
const DEST_AU = { mars:ORBITS_AU.mars, jupiter:ORBITS_AU.jupiter, saturn:ORBITS_AU.saturn, neptune:ORBITS_AU.neptune };

function mappedR(rAU, Rpx, alpha, RmaxAU){
  const a = alpha;
  return Rpx * (Math.atan(a*(rAU/RmaxAU)) / Math.atan(a));
}
function updateDisk(){
  updateDiskLabels();
  const Rpx = Number(diskR.value);
  const alpha = Number(diskAlpha.value)/100;
  const f = Number(diskWarp.value);
  const targetAU = DEST_AU[diskDest.value] || ORBITS_AU.mars;
  const RmaxAU = ORBITS_AU.neptune;

  const rEarth = mappedR(1.0, Rpx, alpha, RmaxAU);
  const rTarget = mappedR(targetAU, Rpx, alpha, RmaxAU);

  const straight = Math.abs(rTarget - rEarth);
  const arcFactor = diskTunnelArc.checked ? 1.18 : 1.00;
  const L_mapped_AU = straight * arcFactor;

  const AU_KM = 149597870.7;
  const c_AU_s = C_KM_S / AU_KM;
  const v_AU_s = f * c_AU_s;
  const t_s = (v_AU_s>0) ? (L_mapped_AU / v_AU_s) : Infinity;

  diskExplain.textContent =
`• Earth-centered (warp planning view): Earth is fixed at the origin (1 AU true radius).
• Nonlinear radial mapping: r′ = R·atan(α·r/Rmax)/atan(α). Larger α expands the inner system and compresses the outer.
• Warp tunnels: A tunnel is drawn from Earth to target. If “Curved (arc)” is selected, the tunnel length increases (stylistic).
• Time estimate: mapped tunnel length (AU) divided by warp speed (×c). Qualitative planner, not an orbital transfer solver.`;

  diskReadout.textContent =
`Disk Readout (qualitative)
R(px)=${Rpx} • α=${fmt(alpha,2)}
target=${diskDest.value.toUpperCase()} (${fmt(targetAU,2)} AU)
Earth mapped radius=${fmt(rEarth,1)} px • Target mapped radius=${fmt(rTarget,1)} px
Tunnel length ≈ ${fmt(L_mapped_AU,3)} AU (mapped) ${diskTunnelArc.checked ? "• arc" : "• straight"}
Warp speed = ${fmt(f,1)}×c → Tunnel time ≈ ${isFinite(t_s)?fmt(t_s,2):"—"} s`;
}
[diskR,diskAlpha,diskWarp,diskDest,diskTunnelArc].forEach(x=>x.addEventListener("input", updateDisk));
updateDisk();

/* Ledger math */
const mathOut = el("mathOut");
const ledgerOut = el("ledgerOut");
const MPC_KM = 3.085677581e19;
const H_EFF = 58.566 / MPC_KM; // s^-1

function updateMathAndLedger({D_km, L_km, dTE, dTS, latencySec=0}){
  const vrec = H_EFF * D_km;
  const vrec_c = vrec / C_KM_S;
  const v_ext = (dTE>0) ? (L_km / dTE) : NaN;
  const v_ship = (dTS>0) ? (L_km / dTS) : NaN;
  const k = v_ext / C_KM_S;

  const margin = 0.15;
  const J_km = 5.0e11;
  const tau_lat = 0.8;
  const N = Math.ceil(((1+margin)*D_km) / J_km);
  const T_ext = N * tau_lat;

  mathOut.textContent =
`H_eff: 58.566 km/s/Mpc
v_rec(D): ${fmt(vrec,3)} km/s (${fmt(vrec_c,3)} c)
Warp Meter: v_ext=${fmt(v_ext,3)} km/s • v_ship=${fmt(v_ship,3)} km/s • k=v/c=${fmt(k,3)}
Warp-tunnel jumps: N = ${isFinite(N)?N:"—"} • T_ext ≈ ${fmt(T_ext,2)} s`;

  const onSite = 0;
  const latencyAgesCrew = true;
  const shipAging = onSite + (latencyAgesCrew ? latencySec : 0);
  const earthElapsed = dTE;
  const note = "If CST-locked, ship and Earth advance together; only on-site time and chosen latency accrue.";
  ledgerOut.textContent =
`On-site time: ${fmt(onSite,2)} s
Latency counts as crew aging?: ${latencyAgesCrew ? "Yes" : "No"}
Ship aging: ${fmt(shipAging,2)} s
Earth elapsed: ${fmt(earthElapsed,2)} s
${note}`;
}

/* Breach UI */
const boostBar = el("boostBar");
const boostLbl = el("boostLbl");
const warpAssistLbl = el("warpAssistLbl");
const negEnergyLbl = el("negEnergyLbl");
const containLbl = el("containLbl");
const healEtaLbl = el("healEtaLbl");

function updateBreachUI(warpNow, stab){
  boostBar.style.width = (starBoost*100).toFixed(0)+"%";
  boostLbl.textContent = (starBoost*100).toFixed(0);

  const warpAssist = clamp(0.22 + 0.06*warpNow + 0.35*starBoost, 0, 1);
  const negLikely = clamp(0.18 + 0.03*warpNow + 0.25*(1-stab), 0, 1);
  warpAssistLbl.textContent = (warpAssist*100).toFixed(1)+"%";
  negEnergyLbl.textContent = (negLikely*100).toFixed(1)+"%";

  if(!breachActive){
    containLbl.textContent = "Stable";
    healEtaLbl.textContent = "—";
  }else{
    containLbl.textContent = (stab > 0.45) ? "Stable" : "Caution";
    const eta = Math.max(0, AUTO_HEAL_SEC - breachT);
    healEtaLbl.textContent = fmt(eta,2)+" s";
  }
}

/* Report tools */
el("btnClear").onclick = clearLog;

function buildReport(){
  const frames = LOG.length;
  if(frames === 0){
    el("reportSummary").textContent = "No frames logged yet. Run the sim, then click “Build Report”.";
    return;
  }
  const last = LOG[LOG.length-1];

  let txt = "";
  txt += `Frames logged: ${frames}\n`;
  txt += `Last t=${fmt(last.t,2)}s • warp=${fmt(last.warp,2)} • distRemain=${fmt(last.distRemainLY,2)} ly\n`;
  txt += `FieldPressure=${fmt(last.fieldPressure,3)} • Compression=${fmt(last.compressionPct,1)}% • Stability=${fmt(last.stability,3)}\n`;
  txt += `Coolant=${fmt(last.coolantKgS,2)} kg/s • Power=${fmt(last.power,1)} • Dilation=${fmt(last.dilationFrac*100,2)}%\n`;
  txt += `Breach=${last.breachActive ? "ON" : "OFF"} • StarboardBoost=${fmt(last.starBoost*100,0)}%\n\n`;
  txt += "Zone stats (hit when zone ≥ 70%):\n";
  for(const z of ZONES){
    const st = zoneStats[z];
    const avg = st.frames ? st.sum/st.frames : 0;
    txt += `${z}: peak=${fmt(st.peak,1)}% • avg=${fmt(avg,1)}% • hits=${st.hits}\n`;
  }

  el("reportSummary").textContent = txt;
  el("printSummary").textContent = txt;

  let zhtml = `<table><thead><tr><th>Zone</th><th>Peak %</th><th>Avg %</th><th>Hits (≥70%)</th></tr></thead><tbody>`;
  for(const z of ZONES){
    const st = zoneStats[z];
    const avg = st.frames ? st.sum/st.frames : 0;
    zhtml += `<tr><td>${z}</td><td>${fmt(st.peak,1)}%</td><td>${fmt(avg,1)}%</td><td>${st.hits}</td></tr>`;
  }
  zhtml += `</tbody></table>`;
  el("printZones").innerHTML = zhtml;

  const headN = Math.min(200, LOG.length);
  let lhtml = `<table><thead><tr>
    <th>#</th><th>t(s)</th><th>warp</th><th>distRemain(ly)</th><th>press</th><th>comp%</th><th>stab</th>
    <th>cool(kg/s)</th><th>power</th><th>dil%</th>
    <th>Dome%</th><th>RimF%</th><th>RimR%</th><th>Belly%</th><th>Port%</th><th>Star%</th><th>Breach</th><th>Boost%</th>
  </tr></thead><tbody>`;
  for(let i=0;i<headN;i++){
    const r = LOG[i];
    lhtml += `<tr>
      <td>${i+1}</td>
      <td>${fmt(r.t,2)}</td>
      <td>${fmt(r.warp,2)}</td>
      <td>${fmt(r.distRemainLY,2)}</td>
      <td>${fmt(r.fieldPressure,3)}</td>
      <td>${fmt(r.compressionPct,1)}</td>
      <td>${fmt(r.stability,3)}</td>
      <td>${fmt(r.coolantKgS,2)}</td>
      <td>${fmt(r.power,1)}</td>
      <td>${fmt(r.dilationFrac*100,2)}</td>
      <td>${fmt(r.z_Dome,0)}%</td>
      <td>${fmt(r.z_RimFront,0)}%</td>
      <td>${fmt(r.z_RimRear,0)}%</td>
      <td>${fmt(r.z_Belly,0)}%</td>
      <td>${fmt(r.z_Port,0)}%</td>
      <td>${fmt(r.z_Starboard,0)}%</td>
      <td>${r.breachActive ? "ON" : "OFF"}</td>
      <td>${fmt(r.starBoost*100,0)}%</td>
    </tr>`;
  }
  lhtml += `</tbody></table>`;
  el("printLog").innerHTML = lhtml;
}
el("btnBuild").onclick = buildReport;
el("btnPrint").onclick = ()=>{ buildReport(); window.print(); };

function downloadCSV(){
  if(LOG.length === 0){
    el("reportSummary").textContent = "No data to export. Run the sim first.";
    return;
  }
  const cols = [
    "t","warp","warpDot","distRemainLY","fieldPressure","compressionPct","stability","coolantKgS","power","dilationFrac",
    "z_Dome","z_RimFront","z_RimRear","z_Belly","z_Port","z_Starboard","breachActive","starBoost"
  ];
  const lines = [cols.join(",")];
  for(const r of LOG){
    lines.push(cols.map(k=>{
      const v=r[k];
      if(typeof v==="boolean") return v ? "1" : "0";
      return (typeof v==="number" && isFinite(v)) ? String(v) : "";
    }).join(","));
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "cst_warp_log.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
el("btnCSV").onclick = downloadCSV;

/* Buttons */
function calculateTrip(){
  computeTrip();
  setMessage(`Trip target set: ${Number(distLYEl.value).toLocaleString()} ly.`);
}
function engageWarp(){
  if(distTotalKm<=0) calculateTrip();
  running = true;
  setMessage("Warp simulation running (flight plan driving warp).");
}
function stopWarp(){
  running = false;
  warp = 0;
  warpSelect.value = "0";
  updateSafetyPanel(warp);
  setMessage("Stopped.");
}
calcBtn.onclick = calculateTrip;
engageBtn.onclick = engageWarp;
stopBtn.onclick = stopWarp;

/* Breach controls */
el("btnBreachStar").addEventListener("click", ()=>{
  breachActive = true;
  breachT = 0;
  starBoost = 0;
  setMessage("Breach triggered (Starboard). Shield boost ramping; auto-heal in ~5 s.");
});
el("btnHeal").addEventListener("click", ()=>{
  breachActive = false;
  breachT = 0;
  starBoost = 0;
  setMessage("Healed now. Starboard boost reset.");
});

/* ===================== Main loop ===================== */
function renderFrame(ts, dt){
  ctx.clearRect(0,0,W,H);
  updateStars(dt, warp);
  drawStars();

  // Field behind ship
  const baseR = 210;
  const pulse = 0.12*Math.sin(ts*0.004) + 0.88;
  const warpBoost = 1 + warp*0.12;
  const shieldR = baseR*pulse*warpBoost;
  drawProtectionField(shieldR, warp);

  // Ship + core + particles
  drawCore(ts, warp);
  updateCoreParticles(dt, warp);
  drawCoreParticles(warp);
  updateEngineParticles(dt, warp);
  drawEngineParticles();
  drawShipOutline();
  drawShipLabels();
}

function loop(ts){
  const dtReal = ((ts - lastTs)/1000) || 0;
  lastTs = ts;

  const cstNow = getCSTDate();
  cstClockEl.textContent = hms(cstNow);
  shipClockEl.textContent = hms(cstNow);

  if(running){
    const at = planAt(simT);
    const wPlan = at.w;
    const wPrev = warp;
    warp = clamp(wPlan, 0, 10);

    const wDot = (dtReal>0) ? (warp - wPrev)/dtReal : 0;

    // breach behavior (boost ramps in sim-time)
    const dtSim = dtReal * simSpeed;
    if(breachActive){
      breachT += dtSim;
      starBoost = clamp(starBoost + dtSim*0.035, 0, 1);
      if(breachT >= AUTO_HEAL_SEC){
        breachActive = false;
        breachT = 0;
        starBoost = 0;
        setMessage("Auto-heal complete (~5 s). Field restored.");
      }
    }else{
      starBoost = clamp(starBoost - dtSim*0.020, 0, 1);
    }

    // distance advance
    const v = (warp<=0) ? 0 : warpSpeedKmS(warp);
    distTraveledKm += v * dtSim;
    if(distTotalKm > 0 && distTraveledKm >= distTotalKm){
      distTraveledKm = distTotalKm;
      running = false;
      setMessage("Arrived (distance target reached).");
    }

    updateSafetyPanel(warp);

    const pressure = fieldPressure(warp);
    const comp = compressionPct(warp);

    const zoneAsym = (Math.random()*18) + Math.abs(wDot)*6 + (breachActive?18*(1-starBoost):0);
    const stab = stabilityScore(warp, wDot, zoneAsym);
    const cool = coolantFlowKgS(warp, wDot, stab);
    const pwr = powerDraw(warp, wDot, stab);
    const dil = dilationFracEarthVsShip(warp);

    const remainKm = Math.max(0, distTotalKm - distTraveledKm);
    const vNow = warpSpeedKmS(Math.max(warp,1));
    const secRemain = (vNow>0) ? (remainKm / vNow) : Infinity;

    distRemainEl.textContent = `${fmt(remainKm/LY_KM,2)} ly remaining`;
    timeRemainEl.textContent = isFinite(secRemain) ? `${fmt(secRemain/86400,2)} days (Earth frame)` : "—";
    pressValEl.textContent = fmt(pressure,3);
    compValEl.textContent = `${fmt(comp,1)}%`;
    stabValEl.textContent = fmt(stab,3);
    coolValEl.textContent = fmt(cool,2);
    pwrValEl.textContent = fmt(pwr,1);
    dilValEl.textContent = `${fmt(dil*100,2)}%`;
    emcValEl.textContent = `E ↔ m utilization index ≈ ${fmt(warp*1.5,2)}`;

    const prog = (distTotalKm>0) ? clamp(distTraveledKm/distTotalKm,0,1) : 0;
    progBar.style.width = (prog*100).toFixed(1)+"%";
    progPct.textContent = (prog*100).toFixed(0);

    highlightPlan(at.p.step);
    stepNow.textContent = at.p.step;
    phaseNow.textContent = at.p.phase;

    const driftSec = isFinite(secRemain) ? (secRemain * dil) : NaN;
    driftClockEl.textContent = isFinite(driftSec) ? `${fmt(driftSec/3600,2)} h drift (Earth vs Ship)` : "—";

    if(isFinite(secRemain)){
      const arrCST = new Date(cstNow.getTime() + secRemain*1000);
      arrivalClockEl.textContent = hms(arrCST);
      arrivalEarthClockEl.textContent = `~${fmt(secRemain/86400,2)} days remaining (Earth frame)`;
    }else{
      arrivalClockEl.textContent = "--:--:--";
      arrivalEarthClockEl.textContent = "--";
    }

    updateBreachUI(warp, stab);

    // zones + logging
    const zones = {
      Dome: clamp(comp + (Math.random()*10 - 5) - Math.abs(wDot)*2, 0, 100),
      "Rim-Front": clamp(comp + (Math.random()*12 - 6) + Math.abs(wDot)*3, 0, 100),
      "Rim-Rear": clamp(comp + (Math.random()*12 - 6) + Math.abs(wDot)*2, 0, 100),
      Belly: clamp(comp + (Math.random()*14 - 7) - Math.abs(wDot)*1, 0, 100),
      Port: clamp(comp + (Math.random()*16 - 8) + zoneAsym*0.35, 0, 100),
      Starboard: clamp(comp + (Math.random()*16 - 8) + zoneAsym*0.65 + (breachActive?25*(1-starBoost):0), 0, 100)
    };

    if(logOnEl.checked){
      for(const z of ZONES){
        const vZ = zones[z];
        const stz = zoneStats[z];
        stz.frames++; stz.sum += vZ;
        stz.peak = Math.max(stz.peak, vZ);
        if(vZ >= 70) stz.hits++;
      }
      LOG.push({
        t: simT,
        warp, warpDot: wDot,
        distRemainLY: (remainKm/LY_KM),
        fieldPressure: pressure,
        compressionPct: comp,
        stability: stab,
        coolantKgS: cool,
        power: pwr,
        dilationFrac: dil,
        z_Dome: zones.Dome,
        z_RimFront: zones["Rim-Front"],
        z_RimRear: zones["Rim-Rear"],
        z_Belly: zones.Belly,
        z_Port: zones.Port,
        z_Starboard: zones.Starboard,
        breachActive,
        starBoost
      });
      if(LOG.length > 20000) LOG.shift();
    }

    // update math/ledger
    const dTE = isFinite(secRemain) ? secRemain : 0;
    const dTS = isFinite(secRemain) ? secRemain*(1-dil) : 0;
    updateMathAndLedger({D_km: remainKm, L_km: distTotalKm, dTE, dTS, latencySec: breachActive ? 0.6 : 0.0});

    // advance sim time
    simT += dtSim;
  } else {
    updateSafetyPanel(warp);
    updateBreachUI(warp, 1);
    highlightPlan(null);
    stepNow.textContent = "—";
    phaseNow.textContent = "—";
    updateDisk();
  }

  renderFrame(ts, dtReal);
  requestAnimationFrame(loop);
}

/* ===================== init ===================== */
clearLog();
computeTrip();
updateDisk();
updateSafetyPanel(0);
updateBreachUI(0,1);
setMessage("");
requestAnimationFrame(loop);
</script>
</body>
</html>
