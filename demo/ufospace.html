<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Warp Console — Galaxy Navigation (Live Panels Fixed)</title>

<style>
  :root{
    color-scheme: dark;
    --bg:#020617;
    --panel:rgba(12,22,52,0.78);
    --ink:#e8f3ff;
    --muted:#9ac7ff;
    --line:rgba(130,190,255,0.42);
    --good:#7bff9f;
    --warn:#ffcc66;
    --bad:#ff7272;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--ink); }
  canvas{ position:fixed; inset:0; }

  .stack{
    position:fixed; top:10px; bottom:10px; width:440px; max-width:92vw;
    display:flex; flex-direction:column; gap:10px; overflow:auto; padding-right:6px;
  }
  #leftStack{ left:10px; }
  #rightStack{ right:10px; }

  .hudpanel{
    background:var(--panel);
    padding:12px 14px;
    border:1px solid var(--line);
    border-radius:12px;
    backdrop-filter:blur(10px);
    font-size:13px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
  }

  h2{ margin:0 0 6px; font-size:15px; letter-spacing:.04em; }
  .label{ margin-top:8px; font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em; }
  .value{ margin-top:3px; font-size:13px; }
  .mono{ font-family:var(--mono); }
  .tiny{ font-size:11px; color:#b9d7ff; line-height:1.25; }
  .small{ font-size:12px; color:#c7e2ff; line-height:1.25; }
  .hr{ height:1px; background:rgba(148,163,184,.18); margin:10px 0; }

  .good{ color:var(--good); }
  .warn{ color:var(--warn); }
  .bad{ color:var(--bad); }

  select,button,input[type="range"]{
    width:100%; padding:7px 8px; margin-top:6px;
    background:#0c1634; color:#d5e9ff; border:1px solid #3d67b8; border-radius:8px;
    font-size:14px; cursor:pointer;
  }
  button{ font-weight:900; }
  button:hover{ filter:brightness(1.06); }

  #calcBtn{ background:#0b2448; border-color:#4a78c9; }
  #engageBtn{ background:#003ae3; }
  #stopBtn{ background:#3a0a0a; border-color:#b84747; }
  #resetBtn{ background:#182038; border-color:#5a7bbb; }

  .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
  .btnrow button{ width:auto; flex:1; min-width:130px; }

  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }

  .bar{ height:10px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(148,163,184,.18); }
  .bar i{ display:block; height:100%; width:0%; background:linear-gradient(90deg, rgba(96,165,250,.95), rgba(52,211,153,.85)); }

  table{ width:100%; border-collapse:collapse; font-size:12px; }
  th,td{ border-bottom:1px solid rgba(148,163,184,.16); padding:8px 6px; vertical-align:top; }
  th{ text-align:left; color:#b6d6ff; position:sticky; top:0; background:rgba(7,10,20,.85); backdrop-filter: blur(6px); }
  tr.active{ outline:2px solid rgba(96,165,250,.55); background:rgba(96,165,250,.10); }

  .prebox{
    white-space:pre-wrap;
    font-family:var(--mono);
    background:rgba(2,6,23,.28);
    border:1px solid rgba(148,163,184,.16);
    border-radius:10px;
    padding:8px;
    margin-top:8px;
    min-height: 46px;
  }

  .toggleRow{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:8px; }
  .toggleRow label{ display:flex; gap:8px; align-items:center; font-size:12px; color:#cfe6ff; }
  .toggleRow input{ transform:scale(1.05); }

  .safeLine{ color:var(--good); font-weight:900; }
  .unsafeLine{ color:var(--bad); font-weight:900; }
  .noteLine{ color:#cfe6ff; }
</style>
</head>

<body>
<canvas id="sim"></canvas>

<div class="stack" id="leftStack">

  <div class="hudpanel" id="panelMain">
    <h2>Warp Navigation Panel</h2>

    <div class="label">Warp Factor (0 – 10)</div>
    <select id="warpSelect">
      <option value="0" selected>0 — Idle</option>
      <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option>
      <option value="4">Warp 4</option><option value="5">Warp 5</option><option value="6">Warp 6</option>
      <option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option>
      <option value="10">Warp 10</option>
    </select>

    <button id="calcBtn">1 — Calculate Trip</button>
    <button id="engageBtn">2 — Engage Warp Drive</button>

    <div class="btnrow">
      <button id="stopBtn">STOP ENGINE</button>
      <button id="resetBtn">RESET (Default)</button>
    </div>

    <div class="label">Simulation speed</div>
    <input id="simSpeed" type="range" min="1" max="500" value="60">
    <div class="tiny mono">Playback: <span id="simSpeedLbl">60×</span></div>

    <div class="value tiny" id="msg" style="min-height:18px;margin-top:8px"></div>

    <div class="label">CST Warp Corridor Safety</div>
    <div class="prebox" id="safeMsg"></div>

    <div class="bar" style="margin-top:10px"><i id="progBar"></i></div>
    <div class="tiny mono">Progress: <span id="progPct">0</span>% • Step <span id="stepNow">—</span> • <span id="phaseNow">—</span></div>

    <div class="toggleRow">
      <label><input type="checkbox" id="labelsOn" checked> Ship part labels</label>
      <label><input type="checkbox" id="logOn" checked> Log every frame</label>
    </div>
  </div>

  <div class="hudpanel" id="panelPlan">
    <h2>Warp Flight Plan • Earth → Galaxy</h2>
    <div class="small">Galaxy-only flight plan: warp corridor formation, field compression, time dilation readouts.</div>

    <div class="label">Destination (Galaxies Only)</div>
    <select id="distPreset">
      <option value="andromeda" selected>Andromeda Galaxy (nearest major galaxy)</option>
      <option value="localgroup">Local Group Scale (short demo)</option>
      <option value="custom">Custom (light-years)</option>
    </select>

    <div class="label">Custom distance (light-years)</div>
    <input id="distLY" type="range" min="1000" max="3000000" value="2537000">
    <div class="value mono">Distance = <span id="distLYLbl">2,537,000</span> ly</div>

    <div class="hr"></div>

    <div class="label">Flight Plan Timeline</div>
    <div class="tiny">Active step highlights as the trip runs. Plan ramps and then hands off to cruise.</div>

    <div style="margin-top:8px; max-height:280px; overflow:auto; border:1px solid rgba(148,163,184,.16); border-radius:10px;">
      <table>
        <thead>
          <tr><th>Step</th><th>Phase</th><th>Warp</th><th>Duration</th><th>CST Discipline</th></tr>
        </thead>
        <tbody id="planBody"></tbody>
      </table>
    </div>
  </div>

  <div class="hudpanel" id="panelLedger">
    <h2>updateMath & CST Ledger</h2>

    <div class="label">Equations (toy forms)</div>
    <div class="prebox" id="eqBox"></div>

    <div class="label">Live Outputs</div>
    <div class="prebox" id="mathOut"></div>

    <div class="label">CST Time Ledger</div>
    <div class="prebox" id="ledgerOut"></div>
  </div>

</div>

<div class="stack" id="rightStack">
  <div class="hudpanel" id="panelClocks">
    <h2>Time Synchronization</h2>
    <div class="label">UTC</div><div class="value mono" id="utcClock">--:--:--</div>
    <div class="label">CST Synchronized Time</div><div class="value mono" id="cstClock">--:--:--</div>
    <div class="label">Ship Clock (CST-locked)</div><div class="value mono" id="shipClock">--:--:--</div>
    <div class="label">Warp time (display)</div><div class="value mono" id="warpClock">--:--:--</div>
    <div class="label">External Time Drift (Earth vs Ship)</div><div class="value mono" id="driftClock">—</div>
    <div class="label">Estimated Arrival (CST)</div><div class="value mono" id="arrivalClock">--:--:--</div>
    <div class="label">Estimated Arrival (Earth frame)</div><div class="value mono" id="arrivalEarthClock">—</div>
  </div>

  <div class="hudpanel" id="panelPhysics">
    <h2>Warp Physics Readout</h2>

    <div class="row2">
      <div><div class="label">Distance Remaining</div><div class="value mono" id="distRemain">—</div></div>
      <div><div class="label">Travel Time Remaining</div><div class="value mono" id="timeRemain">—</div></div>
    </div>

    <div class="row2">
      <div><div class="label">Field Pressure (proxy)</div><div class="value mono" id="pressVal">—</div></div>
      <div><div class="label">Compression (0–100%)</div><div class="value mono" id="compVal">—</div></div>
    </div>

    <div class="row2">
      <div><div class="label">Stability Score</div><div class="value mono" id="stabVal">—</div></div>
      <div><div class="label">Coolant Flow (kg/s)</div><div class="value mono" id="coolVal">—</div></div>
    </div>

    <div class="row2">
      <div><div class="label">Power Draw (arb)</div><div class="value mono" id="pwrVal">—</div></div>
      <div><div class="label">Time Dilation (Earth vs Ship)</div><div class="value mono" id="dilVal">—</div></div>
    </div>

    <div class="label">Mass–Energy Conversion (display)</div>
    <div class="value mono" id="emcVal">—</div>
  </div>

  <div class="hudpanel" id="panelEngineView">
    <h2>Engine View — Telemetry (Live)</h2>
    <div class="prebox" id="engineTelemetry"></div>
  </div>

  <div class="hudpanel" id="panelVectoring">
    <h2>Gravity Vectoring Engine (Live)</h2>
    <div class="prebox" id="vectoringText"></div>
  </div>

  <div class="hudpanel" id="panelEinstein">
    <h2>Einstein Tensor Mini (Live)</h2>
    <div class="prebox" id="einsteinMini"></div>
  </div>

  <div class="hudpanel" id="panelStressEnergy">
    <h2>Stress–Energy Sketch (normalized) (Live)</h2>
    <div class="prebox" id="stressEnergyBox"></div>
  </div>

  <div class="hudpanel" id="panelScience">
    <h2>Scientific Enhancements (Interstellar Star Clock & Warp Drive)</h2>
    <div class="prebox" id="scienceText"></div>
  </div>

  <div class="hudpanel" id="panelBreach">
    <h2>Breach Simulation</h2>
    <div class="btnrow">
      <button id="btnBreachStar">Trigger Breach (Starboard)</button>
      <button id="btnHeal">Heal Now</button>
    </div>

    <div class="label">Shield Boost (Starboard)</div>
    <div class="bar"><i id="boostBar"></i></div>
    <div class="tiny mono"><span id="boostLbl">0</span>%</div>

    <div class="label">Field Readouts</div>
    <div class="row2">
      <div><div class="tiny">Warp-Assist Index</div><div class="mono" id="warpAssistLbl">—</div></div>
      <div><div class="tiny">Negative-Energy Likelihood</div><div class="mono" id="negEnergyLbl">—</div></div>
    </div>

    <div style="margin-top:8px" class="row2">
      <div><div class="tiny">Breach Containment</div><div class="mono" id="containLbl">—</div></div>
      <div><div class="tiny">Auto-heal ETA</div><div class="mono" id="healEtaLbl">—</div></div>
    </div>

    <div class="label">Purpose (Short & Professional)</div>
    <div class="prebox" id="purposeText"></div>
  </div>

</div>

<script>
/* ======================= CORE HELPERS ======================= */
const el = (id)=>document.getElementById(id);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const fmt = (x,d=2)=> (isFinite(x)?Number(x).toFixed(d):"—");
const fmtPct = (x,d=1)=> (isFinite(x)?`${Number(x).toFixed(d)}%`:"—");

function pad2(n){ return String(n).padStart(2,"0"); }
function hms(date){
  if(!(date instanceof Date) || !isFinite(date.getTime())) return "--:--:--";
  return `${pad2(date.getHours())}:${pad2(date.getMinutes())}:${pad2(date.getSeconds())}`;
}
function nowUTC(){
  const d = new Date();
  return new Date(d.getTime() + d.getTimezoneOffset()*60000);
}
function getCSTDate(){
  const u = nowUTC();
  return new Date(u.getTime() - 6*3600000);
}

const C_M_S  = 299792458;
const C_KM_S = 299792.458;
const LY_KM  = 9.460730472e12;

/* ======================= SAFETY PANEL ======================= */
const SAFETY_BLOCK =
`UNSAFE (Warp < 4):
At low warp factors the spacetime compression shell is incomplete.
The magnetic field cannot fully enclose the craft, allowing asymmetric compression
and temporal shear to interact with the hull.

SAFE (Warp ≥ 4):
Above Warp 4 the CST corridor becomes self-contained.
Compression gradients close smoothly around the craft, magnetic shielding stabilizes,
and external spacetime shear is redirected around the hull instead of through it.

Note: This is corridor formation (toy model).`;

const safeMsgEl = el("safeMsg");
function updateSafetyPanel(w){
  const headline = (w >= 4)
    ? `<div class="safeLine">✔ Safe: CST corridor self-contained (Warp ≥ 4).</div>`
    : `<div class="unsafeLine">⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.</div>`;
  safeMsgEl.innerHTML = headline + `<div class="noteLine" style="margin-top:8px;white-space:pre-wrap">${SAFETY_BLOCK}</div>`;
}

/* ======================= STATIC TEXT ======================= */
el("purposeText").textContent =
`AEWFC drives a negative-charge electron lattice, forming a central negative-energy pocket
that assists warp control. On breach, the shield boosts locally and auto-heals after ~5 s,
keeping pocket stability under CST phase. Concept visualization only.`;

el("scienceText").textContent =
`Scientific Enhancements for the Interstellar Star Clock & Warp Drive
These equations sit behind the CST clock and warp navigation.

1) Time Dilation (SR)
Δt' = Δt × √(1 - v² / c²)

2) Gravitational Time Dilation (GR)
Δt' = Δt × √(1 - 2GM / (r c²))

3) Star Coordinate Mapping (RA/Dec → 3D)
x = cos(δ)cos(α), y = cos(δ)sin(α), z = sin(δ)

4) Sidereal Clock Adjustment
Sidereal Day = 23h 56m 4.1s

5) Light-Time Correction
t = d / c

6) Stefan–Boltzmann Law
F = σT⁴

7) Hamiltonian Operator
Ĥψ = Eψ

8) Wave Equation
∂²ψ/∂t² = c²∇²ψ`;

/* ======================= LEDGER + LIVE WRITER ======================= */
const eqBox = el("eqBox");
const mathOut = el("mathOut");
const ledgerOut = el("ledgerOut");

eqBox.textContent =
`Toy Equations used for live panels (display):
v(w) = c · w^(3/2)  (proxy; v(0)=0)
FieldPressure = 0.600 + 0.080 w²
Compression% = 100 · (w/10)
Dilation% (Earth vs Ship) ≈ 1.5% · w² (capped)
Ė proxy ~ base · (0.25 + w/10)
ṁ = Ė / c²
Stability = f(w, ẇ, asymmetry, breach)`;

function writeMathAndLedgerLive(state){
  const {
    running, simT, simSpeed,
    warp, wDot,
    distTotalKm, distTraveledKm, remainKm,
    vKmS, secRemain,
    pressure, comp, stab, cool, pwr, dil,
    utcNow, cstNow, shipNow, warpNow,
    driftHours,
    arrivalCST, arrivalEarthDays
  } = state;

  const remainLY = remainKm / LY_KM;
  const totalLY  = distTotalKm / LY_KM;
  const traveledLY = distTraveledKm / LY_KM;

  mathOut.textContent =
`RUN STATE
running = ${running ? "TRUE" : "FALSE"}   simT = ${fmt(simT,2)} s   simSpeed = ${fmt(simSpeed,0)}×

WARP
warp = ${fmt(warp,3)}   ẇ = ${fmt(wDot,3)} /s
v(w) ≈ ${isFinite(vKmS) ? vKmS.toExponential(3) : "—"} km/s

FIELD
FieldPressure = ${fmt(pressure,3)}
Compression = ${fmt(comp,1)} %
Stability = ${fmt(stab,3)}
CoolantFlow = ${fmt(cool,2)} kg/s
PowerDraw = ${fmt(pwr,1)} arb
Dilation (Earth vs Ship) = ${fmt(dil*100,3)} %`;

  ledgerOut.textContent =
`CLOCKS
UTC  = ${hms(utcNow)}
CST  = ${hms(cstNow)}
SHIP = ${hms(shipNow)}
WARP = ${hms(warpNow)}

DISTANCE
Total     = ${fmt(totalLY,2)} ly
Traveled  = ${fmt(traveledLY,2)} ly
Remaining = ${fmt(remainLY,2)} ly

TIME (Earth frame)
secRemain = ${isFinite(secRemain) ? secRemain.toExponential(6) : "—"}
daysRemain ≈ ${isFinite(secRemain) ? fmt(secRemain/86400,2) : "—"} days
Drift (Earth vs Ship) = ${isFinite(driftHours) ? fmt(driftHours,2) : "—"} h

ARRIVAL
Arrival (CST) = ${hms(arrivalCST)}
Arrival (Earth) = ${isFinite(arrivalEarthDays) ? `~${fmt(arrivalEarthDays,2)} days remaining` : "—"}`;
}

/* ======================= LIVE PANEL WRITERS (FIX) ======================= */
const engineTelemetryEl = el("engineTelemetry");
const vectoringTextEl   = el("vectoringText");
const einsteinMiniEl    = el("einsteinMini");
const stressEnergyEl    = el("stressEnergyBox");

function writeEngineTelemetryLive(s){
  // Toy outputs tied to warp + running
  const shield = clamp(48.3 + (s.breachBoost*40) - s.warp*0.25, 0, 100);
  const coreC  = 82 + (s.running ? (s.warp*s.warp*2.2) : 0) + (s.breachActive ? 35 : 0);
  const coolC  = 55 + (s.running ? (s.warp*8.5) : 0) + (s.breachActive ? 18 : 0);

  const Edot = 6.04e13 * (0.25 + s.warp/10);      // J/s (toy)
  const mdot = Edot / (C_M_S*C_M_S);
  const meff = mdot * 10;
  const rhoShell = 7.33e-11 * (0.4 + s.warp/10);
  const dK = -1.84e-19 * (0.6 + s.warp/10);
  const vWarpProxy = (s.warp <= 0) ? 0 : (0.02*s.warp); // "c" units, toy

  engineTelemetryEl.textContent =
`Status
${s.running ? "RUNNING" : "IDLE"}

Shield
${fmtPct(shield,1)}

Core Temp
${fmt(coreC,0)} °C

Coolant Temp
${fmt(coolC,0)} °C

Ė = ${Edot.toExponential(2)} J/s
ṁ = Ė/c² = ${mdot.toExponential(2)} kg/s
m_eff (stored) = ${meff.toExponential(2)} kg
ρ_shell = ${rhoShell.toExponential(2)} kg/m³
Δκ (proxy) = ${dK.toExponential(2)}
v_warp (proxy) = ${fmt(vWarpProxy,2)} c`;
}

function writeVectoringLive(s, t){
  // Smooth oscillations so the panel stays alive even when cruising
  const front = clamp((Math.sin(t*0.7)*6 + s.warp*0.2), -20, 20);
  const rear  = clamp((Math.cos(t*0.6)*6 + s.warp*0.2), -20, 20);
  const lr    = clamp((Math.sin(t*0.9+1.3)*4), -15, 15);
  const ud    = clamp((Math.cos(t*0.8+0.7)*5), -15, 15);

  vectoringTextEl.textContent =
`Reactor Output (MW)
5000

Front Contraction %
${fmtPct(front,1)}

Rear Expansion %
${fmtPct(rear,1)}

Left / Right Bias %
${fmtPct(lr,1)}

Up / Down Bias %
${fmtPct(ud,1)}

Intake Mode
Balanced (±)

Power Allocation
Field Coils: 2025 MW
Vectoring Vanes: 1750 MW
Containment: 100 MW`;
}

function writeEinsteinMiniLive(s, t){
  // Simple proxy values
  const gtt = 1.0 - 0.02*s.warp + (s.breachActive ? -0.06 : 0);
  const gradPhi = Math.abs(0.08 + 0.03*s.warp + 0.02*Math.sin(t*1.2));
  const rhoEm = (gradPhi*gradPhi) * 1e-8; // toy scaling

  const gttMin = Math.min(1.0, gtt);
  const rhoMin = rhoEm * 0.02;
  const rhoMax = rhoEm * 1.35;

  const throttle = (gtt <= 0) ? "AUTO-THROTTLE: ACTIVE" : "Auto-throttle if gtt ≤ 0";

  einsteinMiniEl.textContent =
`Gμν proxy • ρem from |∇Φ|² (visual)
${throttle}

gtt min: ${fmt(gttMin,6)}
ρem min/max: ${rhoMin.toExponential(3)} / ${rhoMax.toExponential(3)}
EC: ✅ NEC • ✅ WEC • ✅ SEC
Horizons: None`;
}

function writeStressEnergyLive(s, t){
  // Communication model (toy)
  const a = 0.62 + 0.08*Math.sin(t*0.9);
  const b = 0.22 + (s.breachActive ? 0.10 : 0.00);
  const c = 0.18 + 0.06*(s.warp/10);
  const photons = 1.0;
  const casimir = 1.0;
  const control = 1.0;

  const rho = a*photons - b*casimir + c*control;
  const w = clamp(0.12 + 0.08*(s.warp/10), 0, 1);
  const p = w*rho;

  const pr = p*(0.95 + 0.05*Math.sin(t*1.1));
  const pth = p*(0.90 + 0.07*Math.cos(t*0.8));
  const pph = p*(0.92 + 0.06*Math.sin(t*0.6+1.4));

  stressEnergyEl.textContent =
`We present a model form for communication:
Tμν = diag(ρ, pr, pθ, pφ)

ρ = a·Photons − b·Casimir + c·Control
p = w·ρ with 0 ≤ w ≤ 1 (demo)

ρ  ${fmt(rho,3)}
pr ${fmt(pr,3)}
pθ ${fmt(pth,3)}
pφ ${fmt(pph,3)}`;
}

/* ======================= BREACH SIM (FIX) ======================= */
const btnBreachStar = el("btnBreachStar");
const btnHeal = el("btnHeal");
const boostBar = el("boostBar");
const boostLbl = el("boostLbl");
const warpAssistLbl = el("warpAssistLbl");
const negEnergyLbl = el("negEnergyLbl");
const containLbl = el("containLbl");
const healEtaLbl = el("healEtaLbl");

let breach = {
  active:false,
  boost:0,         // 0..1
  healTimer:0      // seconds remaining
};

function triggerBreach(){
  breach.active = true;
  breach.boost = 1;
  breach.healTimer = 5.0; // toy auto-heal
}
function healNow(){
  breach.active = false;
  breach.boost = 0;
  breach.healTimer = 0;
}

btnBreachStar.onclick = triggerBreach;
btnHeal.onclick = healNow;

function updateBreach(dt, warp){
  if(breach.active){
    breach.healTimer = Math.max(0, breach.healTimer - dt);
    // boost decays but stays nonzero while active
    breach.boost = clamp(breach.boost - dt*0.08, 0.25, 1.0);
    if(breach.healTimer <= 0){
      // auto-heal
      breach.active = false;
      breach.boost = 0;
      breach.healTimer = 0;
    }
  } else {
    breach.boost = Math.max(0, breach.boost - dt*0.25);
  }

  const boostPct = Math.round(clamp(breach.boost*100,0,100));
  boostLbl.textContent = String(boostPct);
  boostBar.style.width = `${boostPct}%`;

  // Field readouts (toy)
  const warpAssist = clamp((warp/10)*0.85 + breach.boost*0.25, 0, 1);
  const negLikely = clamp(0.18 + (warp/10)*0.22 + (breach.active?0.18:0), 0, 1);

  warpAssistLbl.textContent = fmtPct(warpAssist*100,1);
  negEnergyLbl.textContent = fmtPct(negLikely*100,1);

  containLbl.textContent = breach.active ? "Breach Active" : "Stable";
  healEtaLbl.textContent = breach.active ? `${fmt(breach.healTimer,1)} s` : "—";
}
/* ======================= CANVAS ======================= */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

let W=0,H=0,cx=0,cy=0;
function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; cx=W/2; cy=H/2; }
window.addEventListener("resize", resize); resize();

const labelsOnEl = el("labelsOn");

/* Stars */
const stars=[];
function initStars(n){
  stars.length=0;
  for(let i=0;i<n;i++) stars.push({ x:Math.random()*W, y:Math.random()*H, s:0.5+Math.random()*1.5, z:0.6+Math.random()*1.6 });
}
initStars(260);
function updateStars(dt, warp){
  const boost = 1 + warp*0.45;
  for(const st of stars){
    st.y += st.s*boost*60*dt;
    if(st.y>H+10){ st.y=-10; st.x=Math.random()*W; st.s=0.5+Math.random()*1.5; }
  }
}
function drawStars(){
  ctx.save();
  for(const st of stars){
    ctx.globalAlpha = 0.18 + st.s*0.12;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillRect(st.x,st.y,st.z,st.z);
  }
  ctx.restore();
}

/* ======================= SHIP VISUALS (UNCHANGED) ======================= */
function drawShipOutline(){
  ctx.save(); ctx.translate(cx,cy);
  ctx.strokeStyle="rgba(120,180,255,0.7)"; ctx.lineWidth=2;

  ctx.beginPath();
  ctx.moveTo(0,-200);
  ctx.quadraticCurveTo(60,-80,60,60);
  ctx.quadraticCurveTo(60,150,0,190);
  ctx.quadraticCurveTo(-60,150,-60,60);
  ctx.quadraticCurveTo(-60,-80,0,-200);

  ctx.moveTo(-110,-40);
  ctx.quadraticCurveTo(-160,50,-110,160);
  ctx.quadraticCurveTo(-60,80,-110,-40);

  ctx.moveTo(110,-40);
  ctx.quadraticCurveTo(160,50,110,160);
  ctx.quadraticCurveTo(60,80,110,-40);

  ctx.stroke();

  ctx.strokeStyle="rgba(200,230,255,0.65)";
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.arc(-118,158,10,0,Math.PI*2);
  ctx.arc(118,158,10,0,Math.PI*2);
  ctx.stroke();

  ctx.restore();
}
function drawShipLabels(){
  if(!labelsOnEl.checked) return;
  ctx.save(); ctx.translate(cx,cy);
  ctx.font="12px "+getComputedStyle(document.documentElement).getPropertyValue("--mono");
  ctx.fillStyle="rgba(205,235,255,0.92)";
  ctx.fillText("DOME",-22,-185);
  ctx.fillText("RIM (FORE)",-45,-115);
  ctx.fillText("RIM (AFT)",-38,135);
  ctx.fillText("BELLY",-22,175);
  ctx.fillText("PORT ROCKET",-175,75);
  ctx.fillText("STARBOARD ROCKET",70,75);

  ctx.fillStyle="rgba(255,240,170,0.95)";
  ctx.fillText("NUCLEAR REACTOR",-78,10);
  ctx.fillText("FUSION CONVERT",-78,28);
  ctx.restore();
}
function drawEquationLines(warp){
  ctx.save(); ctx.translate(cx,cy);
  const alpha = 0.20 + 0.06*warp;
  ctx.strokeStyle = `rgba(255,220,90,${alpha})`;
  ctx.lineWidth = 2;
  ctx.setLineDash([6,8]);
  ctx.beginPath();
  ctx.moveTo(-220, -20);
  ctx.lineTo(220, -20);
  ctx.moveTo(-220, 40);
  ctx.lineTo(220, 40);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.font = "14px "+getComputedStyle(document.documentElement).getPropertyValue("--mono");
  ctx.fillStyle = `rgba(255,220,90,${Math.min(0.95, alpha+0.35)})`;
  ctx.fillText("e = mc²", -210, -28);
  ctx.fillText("m = E / c²", -210, 32);
  ctx.restore();
}
function drawRocketExhaust(warp, dt, ts){
  const strength = clamp(warp/10, 0, 1);
  if(strength <= 0.01) return;
  const t = ts*0.001;

  ctx.save(); ctx.translate(cx,cy);

  const cones = [
    {x:-118,y:168, dirX:-0.20, dirY:1},
    {x: 118,y:168, dirX: 0.20, dirY:1}
  ];

  for(const c of cones){
    ctx.save();
    ctx.globalAlpha = 0.10 + 0.20*strength;
    ctx.fillStyle = "rgba(255,220,90,0.9)";
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + 20*c.dirX - 26, c.y + 120);
    ctx.lineTo(c.x + 20*c.dirX + 26, c.y + 120);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    const n = Math.floor(18 + 50*strength);
    for(let i=0;i<n;i++){
      const p = (i/n);
      const jitter = (Math.sin(t*3 + i*1.7) * 8);
      const x = c.x + c.dirX*(18 + 8*strength) + jitter*(1-p)*0.15;
      const y = c.y + (20 + 160*p)*(1 + 0.2*strength);
      const r = 1.2 + 2.2*(1-p)*strength;

      ctx.globalAlpha = (0.55*(1-p))*(0.35+strength);
      ctx.fillStyle = "rgba(255,220,90,0.95)";
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.restore();
}
function drawRepelledDot(fieldR, warp, ts){
  const strength = clamp(warp/10, 0, 1);
  const t = ts*0.001;

  let r = fieldR * (0.75 + 0.25*Math.sin(t*0.8));
  const approach = fieldR * (0.98 + 0.03*Math.sin(t*1.7 + 1.2));
  if(approach > fieldR*0.985){
    r = fieldR * (1.02 + 0.06*strength + 0.03*Math.sin(t*4.0));
  }

  const ang = t*0.9;
  const x = cx + r*Math.cos(ang);
  const y = cy + r*Math.sin(ang);

  ctx.save();
  ctx.globalAlpha = 0.35 + 0.45*strength;
  ctx.fillStyle = "rgba(255,240,160,0.95)";
  ctx.beginPath();
  ctx.arc(x,y, 3.2, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 0.20 + 0.30*strength;
  ctx.strokeStyle = "rgba(255,240,160,0.75)";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.lineTo(x - 14*Math.cos(ang), y - 14*Math.sin(ang));
  ctx.stroke();

  ctx.restore();
}
function drawProtectionField(R, warp){
  const innerAlpha = 0.18 + warp*0.06;
  const midAlpha = 0.10 + warp*0.05;

  ctx.save(); ctx.translate(cx,cy);
  const g = ctx.createRadialGradient(0,0,R*0.15,0,0,R);
  g.addColorStop(0, `rgba(200,250,255,${innerAlpha})`);
  g.addColorStop(0.4,`rgba(130,210,255,${midAlpha})`);
  g.addColorStop(1, "rgba(20,40,90,0)");
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  ctx.globalAlpha=0.4+warp*0.04;
  ctx.strokeStyle="rgba(165,225,255,0.95)";
  ctx.lineWidth=1.5+warp*0.2;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* ======================= SIM STATE ======================= */
let warp = 0;
let running = false;
let simT = 0;
let simSpeed = 60;
let lastTs = 0;

const warpSelect = el("warpSelect");
const calcBtn = el("calcBtn");
const engageBtn = el("engageBtn");
const stopBtn = el("stopBtn");
const resetBtn = el("resetBtn");
const simSpeedEl = el("simSpeed");
const simSpeedLbl = el("simSpeedLbl");

const utcClockEl = el("utcClock");
const cstClockEl = el("cstClock");
const shipClockEl = el("shipClock");
const warpClockEl = el("warpClock");
const driftClockEl = el("driftClock");
const arrivalClockEl = el("arrivalClock");
const arrivalEarthClockEl = el("arrivalEarthClock");

const distRemainEl = el("distRemain");
const timeRemainEl = el("timeRemain");
const pressValEl = el("pressVal");
const compValEl = el("compVal");
const stabValEl = el("stabVal");
const coolValEl = el("coolVal");
const pwrValEl = el("pwrVal");
const dilValEl = el("dilVal");
const emcValEl = el("emcVal");

const progBar = el("progBar");
const progPctEl = el("progPct");
const stepNowEl = el("stepNow");
const phaseNowEl = el("phaseNow");

const msgEl = el("msg");
function setMessage(s){ msgEl.textContent = s; }

simSpeedEl.oninput = ()=>{ simSpeed = Number(simSpeedEl.value); simSpeedLbl.textContent = simSpeed + "×"; };
simSpeedEl.oninput();

/* Distance presets */
const PRESETS = { andromeda: 2537000, localgroup: 100000 };
const distPresetEl = el("distPreset");
const distLYEl = el("distLY");
const distLYLbl = el("distLYLbl");
function setDistUIFromPreset(){
  const p = distPresetEl.value;
  if(p !== "custom") distLYEl.value = String(PRESETS[p] || PRESETS.andromeda);
  distLYLbl.textContent = Number(distLYEl.value).toLocaleString();
}
distPresetEl.onchange = setDistUIFromPreset;
distLYEl.oninput = ()=> distLYLbl.textContent = Number(distLYEl.value).toLocaleString();
setDistUIFromPreset();

/* Plan */
const PLAN = [
  {step:1, phase:"Departure / Field warm-up", w0:0, w1:1, dur:30,  cst:"Lock CST baseline; verify field symmetry."},
  {step:2, phase:"Corridor forming",         w0:1, w1:3, dur:60,  cst:"Monitor shear; stability must remain controlled."},
  {step:3, phase:"Corridor closure check",   w0:3, w1:4, dur:50,  cst:"Verify closure threshold; log asymmetric zones."},
  {step:4, phase:"Ramp to cruise",           w0:4, w1:10,dur:120, cst:"Stability trend must improve with warp."},
  {step:5, phase:"Warp-10 cruise window",    w0:10,w1:10,dur:240, cst:"Hold deterministic logs; keep CST-locked display."},
  {step:6, phase:"Decelerate / arrival shear",w0:10,w1:4,dur:120, cst:"Control corridor collapse; prevent shell breakup."},
  {step:7, phase:"Final approach / corridor off",w0:4,w1:0,dur:60, cst:"Return to idle; finalize drift summary."}
];
const planBody = el("planBody");
function buildPlanTable(){
  planBody.innerHTML="";
  for(const p of PLAN){
    const tr=document.createElement("tr");
    tr.dataset.step=String(p.step);
    tr.innerHTML=`<td class="mono">${p.step}</td><td>${p.phase}</td><td class="mono">${p.w0}→${p.w1}</td><td class="mono">${p.dur}s</td><td>${p.cst}</td>`;
    planBody.appendChild(tr);
  }
}
buildPlanTable();

function highlightPlan(step){
  const rows=planBody.querySelectorAll("tr");
  rows.forEach(r=> r.classList.toggle("active", step!==null && Number(r.dataset.step)===step));
}

function planTotalDuration(){
  return PLAN.reduce((a,p)=>a+p.dur,0);
}
const PLAN_TOTAL = planTotalDuration();

/* FIX: planAt returns null when past end (handoff to cruise) */
function planAt(timeSec){
  let acc=0;
  for(const p of PLAN){
    const t0=acc, t1=acc+p.dur;
    if(timeSec>=t0 && timeSec<t1){
      const frac=(timeSec-t0)/Math.max(1e-9,p.dur);
      const w=p.w0 + frac*(p.w1-p.w0);
      return {p, frac, w, inPlan:true};
    }
    acc=t1;
  }
  return {p:null, frac:1, w:NaN, inPlan:false};
}

/* ======================= Toy physics (FIX: v(0)=0) ======================= */
function warpSpeedKmS(w){
  if(!(w>0)) return 0;
  return C_KM_S * Math.pow(w, 1.5);
}
function fieldPressure(w){ return 0.600 + 0.080*w*w; }
function compressionPct(w){ return clamp((w/10),0,1)*100; }
function dilationFracEarthVsShip(w){ return Math.min(0.92, 0.015*w*w); }

/* Distance */
let distTotalKm=0, distTraveledKm=0;
function computeTrip(){
  const ly=Number(distLYEl.value);
  distTotalKm = ly * LY_KM;
  distTraveledKm = 0;
}
function calculateTrip(){ computeTrip(); setMessage(`Trip target set: ${Number(distLYEl.value).toLocaleString()} ly.`); }

/* FIX: after plan ends, cruise at selected warp (or minimum 4 for safety) */
let cruiseWarpTarget = 6;

function engageWarp(){
  if(distTotalKm<=0) calculateTrip();
  running=true;
  simT=0; // start plan fresh
  cruiseWarpTarget = Math.max(0, Number(warpSelect.value) || 6);
  setMessage("Warp simulation running (flight plan drives ramp; then cruises).");
}

function stopWarp(){
  running=false; warp=0; warpSelect.value="0";
  updateSafetyPanel(warp);
  setMessage("Stopped.");
}

function resetAll(){
  running=false; warp=0; simT=0; warpSelect.value="0";
  distPresetEl.value="andromeda"; setDistUIFromPreset();
  simSpeedEl.value="60"; simSpeedEl.oninput();
  computeTrip();
  updateSafetyPanel(0);
  highlightPlan(null);
  stepNowEl.textContent="—";
  phaseNowEl.textContent="—";
  progPctEl.textContent="0";
  progBar.style.width="0%";
  driftClockEl.textContent="—";
  arrivalClockEl.textContent="--:--:--";
  arrivalEarthClockEl.textContent="—";
  distRemainEl.textContent="—";
  timeRemainEl.textContent="—";
  healNow(); // clear breach
  setMessage("Reset complete. Trip recalculated. Ready to Engage.");
}

calcBtn.onclick = calculateTrip;
engageBtn.onclick = engageWarp;
stopBtn.onclick = stopWarp;
resetBtn.onclick = resetAll;

warpSelect.onchange = ()=>{
  // manual selection affects cruise target
  cruiseWarpTarget = Math.max(0, Number(warpSelect.value) || 0);
  if(!running) warp = cruiseWarpTarget;
  updateSafetyPanel(warp);
};

/* ======================= MAIN LOOP ======================= */
function renderFrame(ts, dt){
  ctx.clearRect(0,0,W,H);
  updateStars(dt, warp);
  drawStars();
  drawShipOutline();

  const baseR=210;
  const pulse=0.12*Math.sin(ts*0.004)+0.88;
  const warpBoost=1+warp*0.12;
  const fieldR = baseR*pulse*warpBoost;

  drawProtectionField(fieldR, warp);
  drawEquationLines(warp);
  drawRocketExhaust(warp, dt, ts);
  drawRepelledDot(fieldR, warp, ts);
  drawShipLabels();
}

function loop(ts){
  const dt=((ts-lastTs)/1000)||0;
  lastTs=ts;

  const utcNow = nowUTC();
  const cstNow = getCSTDate();

  utcClockEl.textContent = hms(utcNow);
  cstClockEl.textContent = hms(cstNow);
  shipClockEl.textContent = hms(cstNow);

  // warp time display (toy)
  const warpRate = 1 - Math.min(0.35, (warp/10)*0.35);
  const warpNow = new Date(cstNow.getTime() - (simT*warpRate*200));
  warpClockEl.textContent = hms(warpNow);

  let wDot=0;

  // ======================= RUNNING LOGIC (FIX) =======================
  if(running){
    const at = planAt(simT);
    const wPrev = warp;

    if(at.inPlan){
      warp = clamp(at.w, 0, 10);
      highlightPlan(at.p.step);
      stepNowEl.textContent = String(at.p.step);
      phaseNowEl.textContent = at.p.phase;
    } else {
      // plan finished: cruise forever at target (minimum 4 recommended)
      warp = clamp(cruiseWarpTarget, 0, 10);
      highlightPlan(null);
      stepNowEl.textContent = "CRUISE";
      phaseNowEl.textContent = "Cruise (post-plan)";
    }

    wDot = (dt>0)?(warp - wPrev)/dt:0;

    const v = warpSpeedKmS(warp);
    distTraveledKm += v * dt * simSpeed;

    if(distTotalKm>0 && distTraveledKm >= distTotalKm){
      distTraveledKm = distTotalKm;
      running=false;
      setMessage("Arrived (distance target reached).");
    }

    simT += dt*simSpeed;
  } else {
    highlightPlan(null);
    stepNowEl.textContent = "—";
    phaseNowEl.textContent = "—";
  }

  // ======================= CALC READOUTS =======================
  const remainKm = Math.max(0, distTotalKm - distTraveledKm);
  const vKmS = running ? warpSpeedKmS(warp) : warpSpeedKmS(warp);
  const secRemain = (distTotalKm>0 && vKmS>0) ? (remainKm / vKmS) : NaN;

  // progress
  const prog = (distTotalKm>0) ? clamp(distTraveledKm/distTotalKm,0,1) : 0;
  const progPct = Math.round(prog*100);
  progPctEl.textContent = String(progPct);
  progBar.style.width = `${progPct}%`;

  distRemainEl.textContent = (distTotalKm>0) ? `${fmt(remainKm/LY_KM,2)} ly remaining` : "—";
  timeRemainEl.textContent = (isFinite(secRemain)) ? `${fmt(secRemain/86400,2)} days (Earth frame)` : "—";

  // drift + arrivals (only when secRemain finite)
  const dil = dilationFracEarthVsShip(warp);
  if(isFinite(secRemain)){
    driftClockEl.textContent = `${fmt((secRemain*dil)/3600,2)} h drift (Earth vs Ship)`;
    const arrivalCST = new Date(cstNow.getTime() + secRemain*1000);
    arrivalClockEl.textContent = hms(arrivalCST);
    arrivalEarthClockEl.textContent = `~${fmt(secRemain/86400,2)} days remaining (Earth frame)`;
  } else {
    driftClockEl.textContent = "—";
    arrivalClockEl.textContent = "--:--:--";
    arrivalEarthClockEl.textContent = "—";
  }

  // field + telemetry proxies
  const pressure = fieldPressure(warp);
  const comp = compressionPct(warp);
  const stab = clamp(0.40 + 0.06*warp - (breach.active?0.12:0), 0, 1);
  const cool = 1.0 + 0.18*warp + (breach.active?0.35:0);
  const pwr  = 90 + 8*warp*warp + (breach.active?45:0);

  pressValEl.textContent = fmt(pressure,3);
  compValEl.textContent  = `${fmt(comp,1)}%`;
  stabValEl.textContent  = fmt(stab,3);
  coolValEl.textContent  = fmt(cool,2);
  pwrValEl.textContent   = fmt(pwr,1);
  dilValEl.textContent   = `${fmt(dil*100,2)}%`;
  emcValEl.textContent   = `E ↔ m utilization index ≈ ${fmt(warp*1.5,2)}`;

  // ======================= BREACH + LIVE PANEL UPDATES (FIX) =======================
  updateBreach(dt, warp);

  const t = ts*0.001;
  writeEngineTelemetryLive({ running, warp, breachActive: breach.active, breachBoost: breach.boost });
  writeVectoringLive({ running, warp }, t);
  writeEinsteinMiniLive({ running, warp, breachActive: breach.active }, t);
  writeStressEnergyLive({ running, warp, breachActive: breach.active }, t);

  // ======================= LEDGER LIVE =======================
  writeMathAndLedgerLive({
    running, simT, simSpeed,
    warp, wDot,
    distTotalKm, distTraveledKm, remainKm,
    vKmS,
    secRemain,
    pressure, comp, stab, cool, pwr, dil,
    utcNow, cstNow, shipNow:cstNow, warpNow,
    driftHours: (isFinite(secRemain)) ? (secRemain*dil)/3600 : NaN,
    arrivalCST: (isFinite(secRemain)) ? new Date(cstNow.getTime() + secRemain*1000) : new Date(NaN),
    arrivalEarthDays: (isFinite(secRemain)) ? (secRemain/86400) : NaN
  });

  updateSafetyPanel(warp);
  renderFrame(ts, dt);
  requestAnimationFrame(loop);
}

/* INIT */
computeTrip();
updateSafetyPanel(0);
setMessage("");
requestAnimationFrame(loop);

</script>
</body>
</html>
