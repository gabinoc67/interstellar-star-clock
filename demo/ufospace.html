<!-- ======================= PART 1 / 4 ======================= -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CST Warp Navigation — Spaceship + Warp Flight Plan + Reports + Dyson/Prune/Decay</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#020617;
    --panel:rgba(12,22,52,0.78);
    --panel2:rgba(8,16,38,0.72);
    --ink:#e8f3ff;
    --muted:#9cc7ff;
    --line:rgba(130,190,255,0.45);
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    --radius:14px;
    --shadow:0 18px 40px rgba(0,0,0,.45);
  }
  html,body{
    margin:0; height:100%;
    background:var(--bg);
    overflow:hidden;
    font-family:Segoe UI,Roboto,Arial,sans-serif;
    color:var(--ink);
  }
  canvas{ position:fixed; inset:0; }

  /* ====== Right sidebar (prevents overlapping panels) ====== */
  .sidebar{
    position:fixed;
    top:10px; right:10px;
    width:min(420px, calc(100vw - 20px));
    max-height:calc(100vh - 20px);
    display:flex;
    flex-direction:column;
    gap:10px;
    z-index:50;
  }
  .card{
    background:linear-gradient(180deg, var(--panel), var(--panel2));
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:10px 12px;
    border-bottom:1px solid rgba(130,190,255,0.22);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .card .hd .t{
    font-weight:900;
    letter-spacing:.06em;
    font-size:13px;
    text-transform:uppercase;
  }
  .card .bd{
    padding:10px 12px;
    overflow:auto;
    max-height:52vh;
  }

  /* ===== Tabs ===== */
  .tabs{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  .tab{
    appearance:none;
    border:1px solid rgba(130,190,255,0.28);
    background:rgba(2,6,23,.45);
    color:var(--ink);
    padding:7px 10px;
    border-radius:12px;
    font-weight:900;
    cursor:pointer;
    font-size:12px;
  }
  .tab[aria-selected="true"]{
    border-color:rgba(96,165,250,.75);
    background:rgba(0,58,227,.40);
  }

  /* ===== Common UI ===== */
  h2{
    margin:0 0 6px;
    font-size:15px;
    letter-spacing:.04em;
  }
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:520px){ .row{grid-template-columns:1fr} }

  .label{
    margin-top:8px;
    font-size:11px;
    color:var(--muted);
    text-transform:uppercase;
    letter-spacing:.12em;
  }
  .value{
    margin-top:4px;
    font-size:13px;
    font-family:var(--mono);
    white-space:pre-wrap;
    line-height:1.2;
  }
  select,button,input[type="range"],input[type="number"]{
    width:100%;
    padding:8px 9px;
    margin-top:7px;
    background:#0c1634;
    color:var(--ink);
    border:1px solid rgba(61,103,184,.85);
    border-radius:10px;
    font-size:14px;
    outline:none;
  }
  button{
    cursor:pointer;
    font-weight:900;
  }
  button:hover{ border-color:rgba(96,165,250,.85) }
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  .btnrow > button{flex:1;min-width:150px}
  .primary{ background:#003ae3; }
  .primary:hover{ background:#0d4aff; }
  .danger{ background:rgba(90,16,16,.92); border-color:rgba(184,71,71,.9); }
  .danger:hover{ background:rgba(120,20,20,.95); }

  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,.22);
    background:rgba(2,6,23,.35);
    font-size:12px;
    color:var(--muted);
  }
  .good{color:var(--good)}
  .warn{color:var(--warn)}
  .bad{color:var(--bad)}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:rgba(180,215,255,.86);line-height:1.25}
  .mono{font-family:var(--mono)}
  .bar{
    height:10px;border-radius:999px;
    background:rgba(148,163,184,.12);
    border:1px solid rgba(148,163,184,.16);
    overflow:hidden;
  }
  .bar > i{display:block;height:100%;width:0%;background:linear-gradient(90deg, rgba(96,165,250,.95), rgba(52,211,153,.85))}
  .kpiGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:520px){ .kpiGrid{grid-template-columns:1fr} }
  .kpi{
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.25);
    border-radius:12px;
    padding:9px;
  }
  .kpi .k{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em}
  .kpi .v{margin-top:5px;font-family:var(--mono);font-size:13px}
  .divider{height:1px;background:rgba(130,190,255,0.18);margin:10px 0}
  .safeBox{
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.25);
    border-radius:12px;
    padding:10px;
  }
  .safeBox.unsafe{border-color:rgba(251,113,133,.55)}
  .safeBox.safe{border-color:rgba(52,211,153,.55)}
  .safeTitle{font-weight:900;letter-spacing:.06em}
  .safeTitle.unsafe{color:var(--bad)}
  .safeTitle.safe{color:var(--good)}
  .safeText{margin-top:8px;font-family:var(--mono);font-size:12px;white-space:pre-wrap;line-height:1.25;color:rgba(200,230,255,.92)}
  .toggle{
    display:flex;align-items:center;gap:10px;
    padding:8px 10px;border-radius:12px;
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.25);
    color:rgba(190,220,255,.92);
    font-size:13px;
  }
  .toggle input{transform:scale(1.1)}

  /* ===== Left clocks (kept separate; no overlap) ===== */
  .clocks{
    position:fixed;
    left:10px; bottom:10px;
    width:min(360px, calc(100vw - 20px));
    z-index:40;
  }
  .clocks .bd{max-height:32vh}

  /* ===== Print area ===== */
  @media print{
    canvas,.sidebar,.clocks{display:none !important}
    body{background:#fff !important;color:#000 !important; overflow:visible}
    #printArea{display:block !important}
    #printArea *{color:#000 !important}
  }
  #printArea{display:none;padding:18px}
  #printArea h2{margin:10px 0 8px}
  #printArea .pbox{border:1px solid #bbb;padding:10px;margin:10px 0}
  #printArea table{width:100%;border-collapse:collapse}
  #printArea th,#printArea td{border:1px solid #bbb;padding:6px;font-size:12px}
</style>
</head>

<body>
<canvas id="sim"></canvas>

<!-- LEFT CLOCKS PANEL -->
<div class="card clocks">
  <div class="hd">
    <div class="t">Time Synchronization</div>
    <span class="pill mono">CST Lock: <b id="cstLockLbl" class="good">ON</b></span>
  </div>
  <div class="bd">
    <div class="label">Outside Time (UTC)</div>
    <div class="value" id="utcClock">--:--:--</div>

    <div class="label">Engine Sync (CST)</div>
    <div class="value" id="cstClock">--:--:--</div>

    <div class="label">Warp-Adjusted Time (scaled by clock rate)</div>
    <div class="value" id="warpClock">--:--:--</div>

    <div class="divider"></div>
    <div class="label">Estimated Arrival (CST)</div>
    <div class="value" id="arrivalClock">--:--:--</div>

    <div class="label">Earth Elapsed vs Ship Aging</div>
    <div class="value" id="ledgerClock">--</div>
    <div class="small">
      If CST-locked, ship and Earth advance together in this demo; only “on-site” and optional “latency” accrue as aging.
    </div>
  </div>
</div>

<!-- RIGHT SIDEBAR (tabs) -->
<div class="sidebar">

  <div class="card">
    <div class="hd">
      <div class="t">Warp Navigation Console</div>
      <span class="pill mono">Playback: <b id="playbackLbl">60×</b></span>
    </div>
    <div class="bd">
      <div class="tabs" role="tablist" aria-label="Warp console tabs">
        <button class="tab" id="tabNav" aria-selected="true"  type="button">Nav</button>
        <button class="tab" id="tabTele" aria-selected="false" type="button">Telemetry</button>
        <button class="tab" id="tabMath" aria-selected="false" type="button">Math</button>
        <button class="tab" id="tabDyson" aria-selected="false" type="button">Dyson</button>
        <button class="tab" id="tabReport" aria-selected="false" type="button">Report</button>
      </div>

      <!-- ============ TAB: NAV ============ -->
      <div id="panelNav">
        <h2>Flight Plan (Earth → Andromeda)</h2>

        <div class="label">Destination</div>
        <select id="destSelect">
          <option value="Andromeda">Andromeda Galaxy (M31) — nearest major galaxy</option>
          <option value="LocalBubble">Local Region (demo short hop)</option>
        </select>

        <div class="label">Animation speed (sim-seconds per real second)</div>
        <input id="speed" type="range" min="1" max="240" value="60" />
        <div class="value"><span class="mono" id="speedLbl">60</span>×</div>

        <div class="label">Warp factor (driven by flight plan)</div>
        <select id="warpSelect">
          <option value="AUTO" selected>AUTO (use flight plan)</option>
          <option value="0">0 — Idle</option>
          <option value="1">Warp 1</option><option value="2">Warp 2</option><option value="3">Warp 3</option>
          <option value="4">Warp 4</option><option value="5">Warp 5</option><option value="6">Warp 6</option>
          <option value="7">Warp 7</option><option value="8">Warp 8</option><option value="9">Warp 9</option>
          <option value="10">Warp 10</option>
        </select>

        <div class="btnrow">
          <button id="btnCalc" type="button">1 — Calculate Trip</button>
          <button id="btnStart" class="primary" type="button">2 — Start Warp Flight</button>
          <button id="btnStop" class="danger" type="button">STOP ENGINE</button>
        </div>

        <div class="label">Trip progress</div>
        <div class="bar"><i id="prog"></i></div>
        <div class="value" id="progTxt">0% • t = 0.0 s • phase: —</div>

        <div class="divider"></div>

        <!-- SAFETY PANEL (with your exact text) -->
        <div class="safeBox unsafe" id="safeBox">
          <div class="safeTitle unsafe" id="safeTitle">CST Warp Corridor Safety</div>
          <div class="value" id="safeLine" style="font-family:var(--mono)">⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.</div>
          <div class="safeText" id="safeText"></div>
        </div>

        <div class="divider"></div>

        <div class="kpiGrid">
          <div class="kpi"><div class="k">Distance (approx)</div><div class="v" id="distLbl">—</div></div>
          <div class="kpi"><div class="k">Estimated tunnel time</div><div class="v" id="timeLbl">—</div></div>
          <div class="kpi"><div class="k">Compression / curvature (demo)</div><div class="v" id="curvLbl">—</div></div>
          <div class="kpi"><div class="k">Universe expansion correction</div><div class="v" id="expLbl">—</div></div>
        </div>

        <div class="divider"></div>

        <div class="label">Breach Simulation</div>
        <div class="btnrow">
          <button id="btnBreach" type="button">Trigger Breach (Starboard)</button>
          <button id="btnHeal" type="button">Heal Now</button>
        </div>
        <div class="small">On breach, shield boosts locally and auto-heals after ~5 s (demo).</div>

        <div class="kpiGrid" style="margin-top:10px">
          <div class="kpi"><div class="k">Shield Boost (Starboard)</div><div class="v"><span id="boostLbl">0</span>%</div></div>
          <div class="kpi"><div class="k">Breach Containment</div><div class="v" id="containLbl">Stable</div></div>
          <div class="kpi"><div class="k">Warp-Assist Index</div><div class="v" id="warpAssistLbl">—</div></div>
          <div class="kpi"><div class="k">Negative-Energy Likelihood</div><div class="v" id="negEnergyLbl">—</div></div>
        </div>

        <div class="divider"></div>
        <div class="label">Ship Labels</div>
        <div class="small" id="shipLabelNote">
          The ship drawing stays the same. Labels are drawn on top of the outline: Fuselage, Port/Starboard Nacelles, Core, Field Shell.
        </div>
      </div>

      <!-- ============ TAB: TELEMETRY ============ -->
      <div id="panelTele" style="display:none">
        <h2>Real-time Telemetry</h2>
        <div class="kpiGrid">
          <div class="kpi"><div class="k">Animation Speed</div><div class="v" id="tel_speed">—</div></div>
          <div class="kpi"><div class="k">Field Radius (×D)</div><div class="v" id="tel_radius">—</div></div>
          <div class="kpi"><div class="k">Field Shield (%)</div><div class="v" id="tel_shield">—</div></div>
          <div class="kpi"><div class="k">Field Stretch (rx/ry)</div><div class="v" id="tel_stretch">—</div></div>

          <div class="kpi"><div class="k">Clock Rate (warp)</div><div class="v" id="tel_clockrate">—</div></div>
          <div class="kpi"><div class="k">Photon/Ion Rate</div><div class="v" id="tel_photon">—</div></div>
          <div class="kpi"><div class="k">Collider Beam Flux</div><div class="v" id="tel_flux">—</div></div>
          <div class="kpi"><div class="k">Mag Field Strength</div><div class="v" id="tel_mag">—</div></div>

          <div class="kpi"><div class="k">Core Temp (°C)</div><div class="v" id="tel_coreT">—</div></div>
          <div class="kpi"><div class="k">Coolant Temp (°C)</div><div class="v" id="tel_coolT">—</div></div>
          <div class="kpi"><div class="k">Entangle Particles</div><div class="v" id="tel_ent">—</div></div>
          <div class="kpi"><div class="k">Plasma Cone Len / Rad</div><div class="v" id="tel_cone">—</div></div>

          <div class="kpi"><div class="k">Plasma Wave Intensity</div><div class="v" id="tel_wave">—</div></div>
          <div class="kpi"><div class="k">Effective FTL Gain (sim)</div><div class="v" id="tel_ftl">—</div></div>
        </div>

        <div class="divider"></div>
        <div class="small">
          <b class="mono">Warp-Drive Energy Symmetry — Technical Notes (demo)</b><br>
          Warp bubble arises from phased vacuum-energy gradients driven by ZPO rings with CST-locked timing.
          Fusion starter + collider cleans spectra; atomic clocks phase-lock oscillators; positron channels act as balancers/diagnostics.
          “Exotic matter” is not assumed here — this is a visualization with bounded ranges to avoid loop formation.
        </div>
      </div>

      <!-- ============ TAB: MATH ============ -->
      <div id="panelMath" style="display:none">
        <h2>Warp Math • CST Ledger • State Vectors</h2>

        <div class="label">UpdateMath & CST Ledger (toy forms)</div>
        <div class="value" id="mathBlock"></div>

        <div class="divider"></div>

        <div class="label">State Vectors & 4D Metrics (demo)</div>
        <div class="value" id="stateBlock"></div>

        <div class="divider"></div>

        <div class="label">Verification Channels (GO / NO-GO)</div>
        <div class="value" id="verifyBlock"></div>

        <div class="divider"></div>

        <div class="label">How Electrons Could Warp Spacetime — AEWFC (concept)</div>
        <div class="small">
          Electron (−) charge lights engine coils and circulates coherently to form a warp-assist pocket.
          On a breach, the EM shield auto-boosts on the affected side then auto-heals after ~5 s.
          CST phase keeps everything in lockstep. (Concept visualization; not a physics solver.)
        </div>
      </div>

      <!-- ============ TAB: DYSON ============ -->
      <div id="panelDyson" style="display:none">
        <h2>Dyson Sphere Panels + Prune/Decay Monitor</h2>

        <div class="toggle"><input id="dysonOn" type="checkbox" checked /> Dyson Sphere Mode: ON (closed boundary)</div>
        <div class="small" style="margin-top:8px">
          ON = vault persists to <span class="mono">localStorage</span>. Prune/decay keeps memory clean and bounded.
          OFF = boundary open: no writes; existing memory decays faster.
        </div>

        <div class="kpiGrid" style="margin-top:10px">
          <div class="kpi"><div class="k">Boundary budget</div><div class="v" id="dy_budget">100%</div></div>
          <div class="kpi"><div class="k">Writes</div><div class="v" id="dy_writes">0</div></div>
          <div class="kpi"><div class="k">Leaks</div><div class="v" id="dy_leaks">0</div></div>
          <div class="kpi"><div class="k">Next decay tick</div><div class="v" id="dy_next">—</div></div>
        </div>

        <div class="divider"></div>

        <div class="label">Prune & Decay</div>
        <div class="small">
          Decay reduces weights each tick (old items fade). Prune deletes items below threshold and caps list sizes.
          This prevents “memory bloat” and forces the system to keep only the strongest patterns.
        </div>

        <div class="btnrow" style="margin-top:10px">
          <button id="btnDecayNow" type="button">Prune/Decay Now</button>
          <button id="btnResetUI" type="button">Reset UI</button>
          <button id="btnClearVault" class="danger" type="button">Clear Vault</button>
        </div>

        <div class="divider"></div>

        <div class="label">Ontology note (physics-friendly)</div>
        <div class="small">
          Mathematics here is representation, not “what creates reality.” The “Dyson boundary” is a software metaphor for a bounded store,
          not an ontological claim.
        </div>

        <div class="divider"></div>

        <div class="label">Prune/Decay Monitor (live)</div>
        <div class="value" id="pdBlock">—</div>

        <div class="divider"></div>

        <div class="label">Dyson Log</div>
        <div class="value" id="dyLog" style="max-height:180px;overflow:auto">—</div>
      </div>

      <!-- ============ TAB: REPORT ============ -->
      <div id="panelReport" style="display:none">
        <h2>Report Tools</h2>
        <div class="small">
          Logs every frame: Warp/Field/Shield/Stretch/ClockRate/CoreTemp/CoolantTemp/Stability + zone compression% (hits + averages).
        </div>

        <div class="btnrow" style="margin-top:10px">
          <button id="btnBuildReport" type="button">Build Report</button>
          <button id="btnPrint" type="button">Print Report</button>
          <button id="btnCSV" type="button">Download CSV</button>
          <button id="btnClearLog" type="button">Clear Log</button>
        </div>

        <div class="divider"></div>
        <div class="value" id="reportSummary">Log cleared. Run the sim, then click “Build Report”.</div>
      </div>

    </div><!-- bd -->
  </div><!-- card -->
</div><!-- sidebar -->

<!-- PRINT AREA -->
<section id="printArea">
  <h2>CST Warp Navigation — Report</h2>
  <div class="pbox" id="printSummary">—</div>
  <div class="pbox">
    <h2 style="font-size:16px;margin:0 0 6px">Zone Compression Stats</h2>
    <div id="printZones">—</div>
  </div>
  <div class="pbox">
    <h2 style="font-size:16px;margin:0 0 6px">Frame Log (first 200 rows)</h2>
    <div id="printLog">—</div>
  </div>
</section>
<!-- ======================= PART 2 / 4 ======================= -->
<script>
/* ============================================================
   CST Warp Navigation — single-file demo
   - Keeps the same spaceship outline (canvas drawShipOutline()).
   - Adds non-overlapping panels via a tabbed sidebar.
   - Adds safety text with correct color switching at Warp >= 4.
   - Adds report logging + Build/Print/CSV/Clear.
   - Adds Dyson (vault) + prune/decay monitor as "AI nav memory boundary".
   - Adds telemetry + state vectors + verification channels (toy).
   ============================================================ */

/* ===== Canvas ===== */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");
let W=0,H=0,cx=0,cy=0;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W/2; cy = H/2;
}
window.addEventListener("resize", resize);
resize();

/* ===== Helpers ===== */
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp  = (a,b,t)=>a+(b-a)*t;
const fmt   = (x,d=2)=>isFinite(x)?Number(x).toFixed(d):"—";
const fmt0  = (x)=>isFinite(x)?String(Math.round(x)):"—";
const pad2  = (n)=>String(n).padStart(2,"0");
function hmsFromSeconds(s){
  if(!isFinite(s) || s<0) return "—";
  s = Math.round(s);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;
}
function nowUTC(){
  const d = new Date();
  return new Date(d.getTime() + d.getTimezoneOffset()*60000);
}
function getCSTDate(){
  // CST = UTC - 6 (your requirement for this demo)
  const u = nowUTC();
  return new Date(u.getTime() - 6*3600000);
}
function timeStr(d){
  return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
}

/* ===== Tabs ===== */
const tabNav   = document.getElementById("tabNav");
const tabTele  = document.getElementById("tabTele");
const tabMath  = document.getElementById("tabMath");
const tabDyson = document.getElementById("tabDyson");
const tabReport= document.getElementById("tabReport");

const panelNav   = document.getElementById("panelNav");
const panelTele  = document.getElementById("panelTele");
const panelMath  = document.getElementById("panelMath");
const panelDyson = document.getElementById("panelDyson");
const panelReport= document.getElementById("panelReport");

function setTab(active){
  const tabs = [
    {btn:tabNav,   p:panelNav,   k:"Nav"},
    {btn:tabTele,  p:panelTele,  k:"Telemetry"},
    {btn:tabMath,  p:panelMath,  k:"Math"},
    {btn:tabDyson, p:panelDyson, k:"Dyson"},
    {btn:tabReport,p:panelReport,k:"Report"},
  ];
  for(const t of tabs){
    const on = (t.k===active);
    t.btn.setAttribute("aria-selected", on?"true":"false");
    t.p.style.display = on ? "block" : "none";
  }
}
tabNav.onclick   = ()=>setTab("Nav");
tabTele.onclick  = ()=>setTab("Telemetry");
tabMath.onclick  = ()=>setTab("Math");
tabDyson.onclick = ()=>setTab("Dyson");
tabReport.onclick= ()=>setTab("Report");

/* ===== DOM refs ===== */
const destSelect = document.getElementById("destSelect");
const speed = document.getElementById("speed");
const speedLbl = document.getElementById("speedLbl");
const playbackLbl = document.getElementById("playbackLbl");
const warpSelect = document.getElementById("warpSelect");

const btnCalc = document.getElementById("btnCalc");
const btnStart= document.getElementById("btnStart");
const btnStop = document.getElementById("btnStop");

const progBar = document.getElementById("prog");
const progTxt = document.getElementById("progTxt");

const safeBox = document.getElementById("safeBox");
const safeTitle = document.getElementById("safeTitle");
const safeLine = document.getElementById("safeLine");
const safeText = document.getElementById("safeText");

const distLbl = document.getElementById("distLbl");
const timeLbl = document.getElementById("timeLbl");
const curvLbl = document.getElementById("curvLbl");
const expLbl  = document.getElementById("expLbl");

const utcClock = document.getElementById("utcClock");
const cstClock = document.getElementById("cstClock");
const warpClock= document.getElementById("warpClock");
const arrivalClock = document.getElementById("arrivalClock");
const ledgerClock = document.getElementById("ledgerClock");
const cstLockLbl = document.getElementById("cstLockLbl");

/* Breach / Field readouts */
const btnBreach = document.getElementById("btnBreach");
const btnHeal   = document.getElementById("btnHeal");
const boostLbl  = document.getElementById("boostLbl");
const containLbl= document.getElementById("containLbl");
const warpAssistLbl = document.getElementById("warpAssistLbl");
const negEnergyLbl  = document.getElementById("negEnergyLbl");

/* Telemetry */
const tel_speed   = document.getElementById("tel_speed");
const tel_radius  = document.getElementById("tel_radius");
const tel_shield  = document.getElementById("tel_shield");
const tel_stretch = document.getElementById("tel_stretch");
const tel_clockrate = document.getElementById("tel_clockrate");
const tel_photon  = document.getElementById("tel_photon");
const tel_flux    = document.getElementById("tel_flux");
const tel_mag     = document.getElementById("tel_mag");
const tel_coreT   = document.getElementById("tel_coreT");
const tel_coolT   = document.getElementById("tel_coolT");
const tel_ent     = document.getElementById("tel_ent");
const tel_cone    = document.getElementById("tel_cone");
const tel_wave    = document.getElementById("tel_wave");
const tel_ftl     = document.getElementById("tel_ftl");

/* Math panels */
const mathBlock  = document.getElementById("mathBlock");
const stateBlock = document.getElementById("stateBlock");
const verifyBlock= document.getElementById("verifyBlock");

/* Dyson */
const dysonOn = document.getElementById("dysonOn");
const dy_budget = document.getElementById("dy_budget");
const dy_writes = document.getElementById("dy_writes");
const dy_leaks  = document.getElementById("dy_leaks");
const dy_next   = document.getElementById("dy_next");
const pdBlock   = document.getElementById("pdBlock");
const dyLog     = document.getElementById("dyLog");
const btnDecayNow = document.getElementById("btnDecayNow");
const btnResetUI  = document.getElementById("btnResetUI");
const btnClearVault = document.getElementById("btnClearVault");

/* Report */
const btnBuildReport = document.getElementById("btnBuildReport");
const btnPrint  = document.getElementById("btnPrint");
const btnCSV    = document.getElementById("btnCSV");
const btnClearLog = document.getElementById("btnClearLog");
const reportSummary = document.getElementById("reportSummary");
const printSummary  = document.getElementById("printSummary");
const printZones    = document.getElementById("printZones");
const printLog      = document.getElementById("printLog");

/* ===== Safety text (YOUR EXACT WORDS) ===== */
const SAFETY_TEXT_EXACT =
`UNSAFE (Warp < 4):
At low warp factors the spacetime compression shell is incomplete.
The magnetic field cannot fully enclose the craft, allowing asymmetric
compression and temporal shear to interact with the hull.

SAFE (Warp ≥ 4):
Above Warp 4 the CST corridor becomes self-contained.
Compression gradients close smoothly around the craft,
magnetic shielding stabilizes, and external spacetime shear
is redirected around the hull instead of through it.

Note:
This is not structural failure — it is corridor formation.`;
safeText.textContent = SAFETY_TEXT_EXACT;

/* ===== Simulation constants (toy; labeled as such in UI) ===== */
const C_KM_S = 299792.458;

/* Approx distances (toy defaults) */
const DEST = {
  // Andromeda distance ~2.537 million light-years (approx), used as a constant for this demo.
  // We keep it "approx" in UI; not an astrophysics solver.
  Andromeda: { name:"Andromeda Galaxy (M31)", ly: 2.537e6 },
  LocalBubble:{ name:"Local Region (demo short hop)", ly: 5000 }
};
const KM_PER_LY = 9.460730472e12;

/* ===== Flight plan (warp schedule) =====
   Similar idea to Mach-10: ramp segments + cruise + ramp down.
   t is SIM-SECONDS, not real.
*/
function buildFlightPlan(){
  return [
    {step:1, phase:"Departure / field warmup",  t0:0,   t1:20,  w0:0,  w1:1,  note:"Initialize CST baseline; spool field coils."},
    {step:2, phase:"Ramp: Warp 1 → 3",          t0:20,  t1:60,  w0:1,  w1:3,  note:"Compression shell forming; monitor shear."},
    {step:3, phase:"Ramp: Warp 3 → 4 (gate)",   t0:60,  t1:90,  w0:3,  w1:4,  note:"Corridor closure threshold; verify stability."},
    {step:4, phase:"Ramp: Warp 4 → 10",         t0:90,  t1:150, w0:4,  w1:10, note:"Full corridor; tighten timing & field symmetry."},
    {step:5, phase:"Cruise: Warp 10",           t0:150, t1:240, w0:10, w1:10, note:"Hold corridor; keep CST lock; log telemetry."},
    {step:6, phase:"Ramp down: Warp 10 → 4",    t0:240, t1:300, w0:10, w1:4,  note:"Prepare approach; maintain closure until late."},
    {step:7, phase:"Approach: Warp 4 → 1",      t0:300, t1:340, w0:4,  w1:1,  note:"Controlled de-energize; keep shear low."},
    {step:8, phase:"Arrival / field cool-down", t0:340, t1:380, w0:1,  w1:0,  note:"Finalize logs; corridor open; safe idle."}
  ];
}
const PLAN = buildFlightPlan();
const PLAN_LEN = PLAN[PLAN.length-1].t1;

/* Step at time */
function planAt(t){
  for(const s of PLAN){
    if(t>=s.t0 && t<s.t1){
      const span = Math.max(1e-9, s.t1-s.t0);
      const f = clamp((t-s.t0)/span, 0, 1);
      const warp = lerp(s.w0, s.w1, f);
      return { s, warp };
    }
  }
  return { s: PLAN[PLAN.length-1], warp: PLAN[PLAN.length-1].w1 };
}
<!-- ======================= PART 3 / 4 ======================= -->
<script>
/* ===== Visual systems (stars + particles) ===== */
const stars = [];
function initStars(n){
  stars.length=0;
  for(let i=0;i<n;i++){
    stars.push({
      x:Math.random()*W,
      y:Math.random()*H,
      speed:0.5+Math.random()*1.6,
      size:0.4+Math.random()*1.9
    });
  }
}
initStars(240);

function updateStars(dt, warp){
  const speedBoost = 1 + warp*0.45;
  for(const s of stars){
    s.y += s.speed*speedBoost;
    if(s.y > H+10){
      s.y = -10; s.x = Math.random()*W;
      s.speed = 0.5+Math.random()*1.6;
    }
  }
}
function drawStars(){
  ctx.save();
  ctx.fillStyle="rgba(255,255,255,0.85)";
  for(const s of stars){
    ctx.globalAlpha = 0.20 + s.speed*0.12;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.restore();
}

/* Core particles */
const coreParticles = [];
function newCoreParticle(){
  return {
    a:Math.random()*Math.PI*2,
    r:Math.random()*10,
    max:70+Math.random()*60,
    sp:0.06+Math.random()*0.14,
    size:1+Math.random()*2,
    life:Math.random()
  };
}
for(let i=0;i<220;i++) coreParticles.push(newCoreParticle());

function updateCoreParticles(dt, warp){
  const speedBoost = 1 + warp*0.7;
  for(const p of coreParticles){
    p.r += p.sp*110*dt*speedBoost;
    p.life += dt*0.5;
    if(p.r>p.max || p.life>1) Object.assign(p, newCoreParticle());
  }
}
function drawCoreParticles(warp){
  ctx.save();
  ctx.translate(cx,cy);
  for(const p of coreParticles){
    const x = Math.cos(p.a)*p.r;
    const y = Math.sin(p.a)*p.r*0.8;
    const alpha = (1-p.life)*(0.6 + warp*0.03);
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(x,y,p.size,0,Math.PI*2);
    ctx.fillStyle="rgba(190,245,255,1)";
    ctx.fill();
  }
  ctx.restore();
}

/* Engine particles (downward jets) */
const engineLeft=[], engineRight=[];
function newEngineParticle(){
  return { x:0,y:0,vx:(Math.random()-0.5)*0.6, vy:2+Math.random()*2.5, life:0.7+Math.random()*1.1 };
}
for(let i=0;i<180;i++) engineLeft.push(newEngineParticle());
for(let i=0;i<180;i++) engineRight.push(newEngineParticle());

function updateEngineParticles(dt, warp){
  const boost = 1 + warp*2.3;
  const step = dt*0.4;
  for(const e of engineLeft){
    e.x += e.vx*boost;
    e.y += e.vy*boost;
    e.life -= step;
    if(e.life<=0) Object.assign(e, newEngineParticle());
  }
  for(const e of engineRight){
    e.x += e.vx*boost;
    e.y += e.vy*boost;
    e.life -= step;
    if(e.life<=0) Object.assign(e, newEngineParticle());
  }
}
function drawEngineParticles(){
  ctx.save(); ctx.translate(cx-110, cy+60);
  for(const e of engineLeft){
    ctx.globalAlpha = e.life;
    ctx.beginPath();
    ctx.arc(e.x,e.y,2,0,Math.PI*2);
    ctx.fillStyle="rgba(120,220,255,1)";
    ctx.fill();
  }
  ctx.restore();

  ctx.save(); ctx.translate(cx+110, cy+60);
  for(const e of engineRight){
    ctx.globalAlpha = e.life;
    ctx.beginPath();
    ctx.arc(e.x,e.y,2,0,Math.PI*2);
    ctx.fillStyle="rgba(120,220,255,1)";
    ctx.fill();
  }
  ctx.restore();
}

/* Field impact particles (hit shield & repel) */
const fieldParticles=[];
function newFieldParticle(){
  const angle=Math.random()*Math.PI*2;
  const r=260+Math.random()*90;
  const sp=-(20+Math.random()*40);
  return {a:angle,r,sp,hit:false,flash:0};
}
for(let i=0;i<150;i++) fieldParticles.push(newFieldParticle());

function updateFieldParticles(dt, shieldR){
  for(const p of fieldParticles){
    p.r += p.sp*dt;
    if(!p.hit && p.r<=shieldR){
      p.hit=true;
      p.flash=0.25;
      p.sp = Math.abs(p.sp);
      p.r = shieldR;
    }
    if(p.hit){
      p.flash -= dt;
      if(p.flash<=0){ p.flash=0; }
    }
    if(p.r>shieldR+150 || p.r<shieldR*0.4){
      Object.assign(p, newFieldParticle());
    }
  }
}
function drawFieldParticles(shieldR, t){
  ctx.save();
  ctx.translate(cx,cy);
  for(const p of fieldParticles){
    const x=Math.cos(p.a)*p.r;
    const y=Math.sin(p.a)*p.r;
    let alpha=0.35;
    let radius=2;
    if(p.hit && p.flash>0){
      const blink=0.5+0.5*Math.sin(t*40);
      alpha=0.8*blink; radius=3.5;
    }
    ctx.globalAlpha=alpha;
    ctx.beginPath();
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.fillStyle = p.hit ? "rgba(255,255,220,1)" : "rgba(150,210,255,1)";
    ctx.fill();
  }
  ctx.restore();
}

/* ===== Ship drawing (UNCHANGED outline) + labels ===== */
function drawShipOutline(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.strokeStyle="rgba(120,180,255,0.7)";
  ctx.lineWidth=2;
  ctx.beginPath();
  // fuselage
  ctx.moveTo(0,-200);
  ctx.quadraticCurveTo(60,-80,60,60);
  ctx.quadraticCurveTo(60,150,0,190);
  ctx.quadraticCurveTo(-60,150,-60,60);
  ctx.quadraticCurveTo(-60,-80,0,-200);
  // left nacelle
  ctx.moveTo(-110,-40);
  ctx.quadraticCurveTo(-160,50,-110,160);
  ctx.quadraticCurveTo(-60,80,-110,-40);
  // right nacelle
  ctx.moveTo(110,-40);
  ctx.quadraticCurveTo(160,50,110,160);
  ctx.quadraticCurveTo(60,80,110,-40);
  ctx.stroke();
  ctx.restore();
}
function drawShipLabels(){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.globalAlpha=0.85;
  ctx.fillStyle="rgba(200,235,255,0.92)";
  ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
  // Core
  ctx.fillText("Core", -14, 8);
  // Fuselage
  ctx.fillText("Fuselage", -32, -150);
  // Nacelles
  ctx.fillText("Port nacelle", -170, 80);
  ctx.fillText("Starboard nacelle", 95, 80);
  // Field shell
  ctx.fillText("Field shell", -42, -235);
  ctx.restore();
}

/* ===== Protection field ===== */
function drawProtectionField(R, warp, stretchX, stretchY){
  const innerAlpha = 0.18 + warp*0.06;
  const midAlpha   = 0.10 + warp*0.05;

  ctx.save();
  ctx.translate(cx,cy);
  ctx.scale(stretchX, stretchY);

  const g = ctx.createRadialGradient(0,0,R*0.12, 0,0,R);
  g.addColorStop(0, `rgba(200,250,255,${innerAlpha})`);
  g.addColorStop(0.4,`rgba(130,210,255,${midAlpha})`);
  g.addColorStop(1, "rgba(20,40,90,0)");
  ctx.fillStyle=g;
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 0.4 + warp*0.04;
  ctx.strokeStyle="rgba(165,225,255,0.95)";
  ctx.lineWidth=1.5 + warp*0.2;
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.stroke();

  ctx.restore();
}

/* ===== Core / rings ===== */
function warpEnergy(warp){ return 0.25 + (warp/10)*0.75; }
function drawCore(ts, warp){
  const energy = warpEnergy(warp);
  const t = ts*0.008;

  ctx.save();
  ctx.translate(cx,cy);

  const coreR = 14 + 10*energy*Math.sin(t*4);
  ctx.beginPath();
  ctx.arc(0,0,coreR,0,Math.PI*2);
  ctx.fillStyle="rgba(255,255,255,0.96)";
  ctx.fill();

  const cor = coreR*1.9;
  const cg = ctx.createRadialGradient(0,0,coreR*0.2, 0,0,cor);
  cg.addColorStop(0,"rgba(255,255,255,0.9)");
  cg.addColorStop(0.4,"rgba(255,210,160,0.65)");
  cg.addColorStop(1,"rgba(255,120,80,0)");
  ctx.fillStyle=cg;
  ctx.beginPath();
  ctx.arc(0,0,cor,0,Math.PI*2);
  ctx.fill();

  const reactorR = 55;
  ctx.beginPath();
  ctx.strokeStyle="rgba(0,255,180,0.9)";
  ctx.lineWidth=1.3;
  ctx.setLineDash([7,4]);
  ctx.arc(0,0,reactorR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  const fissionR = 95;
  ctx.beginPath();
  ctx.strokeStyle="rgba(255,190,80,0.9)";
  ctx.lineWidth=1.3;
  ctx.setLineDash([9,5]);
  ctx.arc(0,0,fissionR,0,Math.PI*2);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle="rgba(190,235,255,0.9)";
  ctx.font="12px Segoe UI";
  ctx.fillText("Nuclear Reactor", -60, reactorR+14);
  ctx.fillText("Fission Converter", -68, fissionR+16);
  ctx.fillText("E = mc²", -24, -reactorR-10);
  ctx.fillText("m = E / c²", -32, -fissionR-10);

  ctx.restore();
}

/* ===== Core simulation state ===== */
let running=false;
let tSim=0;         // seconds
let lastTs=0;

let warp=0;         // current (0..10)
let warpMode="AUTO";// AUTO or fixed number

let trip=null;      // computed trip summary
let depCST=null;    // departure time

/* Breach state */
let breach=false;
let breachT=0;      // time since breach
let boost=0;        // 0..100

/* Dyson (vault) state */
const VAULT_KEY="cst_dyson_vault_v1";
let vault = { habits:[], events:[], writes:0, leaks:0, lastTick:0, nextTickIn:4.5 };
let pd = {
  habitMult:0.965,
  eventMult:0.985,
  habitsBefore:0, habitsAfter:0,
  eventsBefore:0, eventsAfter:0,
  prunedHabits:0, prunedEvents:0,
  prunedItems:"—"
};
let dysonLogLines=[];

/* ===== Report logging ===== */
const LOG=[]; // per frame rows
const ZONES=["fore","port","star","aft","core"];
let zoneStats = newZoneStats();

function newZoneStats(){
  const o={};
  for(const z of ZONES){
    o[z]={frames:0, activeFrames:0, hitFrames:0, peak:0, sum:0, sumActive:0, enterHits:0, lastHit:false};
  }
  return o;
}
function clearLog(){
  LOG.length=0;
  zoneStats=newZoneStats();
  reportSummary.textContent="Log cleared. Run the sim, then click “Build Report”.";
  printSummary.textContent="—";
  printZones.textContent="—";
  printLog.textContent="—";
}
function zoneUpdateStats(z, riskPct){
  const st=zoneStats[z];
  st.frames++;
  st.sum += riskPct;
  st.peak = Math.max(st.peak, riskPct);
  const active = riskPct>=30;
  const hit    = riskPct>=45;
  if(active){ st.activeFrames++; st.sumActive += riskPct; }
  if(hit){ st.hitFrames++; }
  if(hit && !st.lastHit) st.enterHits++;
  st.lastHit=hit;
}
function addLogRow(r){
  LOG.push(r);
  if(LOG.length>20000) LOG.shift();
}

/* ===== Warp / physics (toy) ===== */
function warpSpeedFactor(w){
  // Toy: effective speed multiplier vs c
  // Smooth increase, modest at low warp; strong at high warp.
  // (Purely a demo mapping.)
  const x = clamp(w/10, 0, 1);
  return 1 + 12*Math.pow(x, 1.6); // 1..13
}
function corridorStability(w){
  // Stability (0..1): corridor closure threshold at w=4
  // Adds a soft knee so it doesn't jump.
  const k = 1/(1+Math.exp(-(w-4)*2.2)); // sigmoid around 4
  // Slightly penalize low warp
  return clamp(0.15 + 0.85*k, 0, 1);
}
function shearRisk(w){
  // High at low warp, decreases after closure
  const s = corridorStability(w);
  return clamp(1 - s, 0, 1);
}
function clockRateFromWarp(w){
  // Demo clock scale: near 1 at stable corridor, a bit lower during ramps/low warp
  // (You asked: “Warp-Adjusted Time scaled by clock rate”.)
  const s = corridorStability(w);
  return clamp(0.82 + 0.18*s, 0.82, 1.00);
}

/* “Universe expansion correction” (toy) */
function expansionCorrection(distanceLy){
  // Just a small logarithmic term to display (not cosmology).
  return Math.log1p(distanceLy/1e6) * 0.012;
}

/* “Tunnel curvature” (toy) */
function tunnelCurvature(w, distanceLy){
  // Curvature increases with warp and distance, but saturates.
  const x = clamp(w/10,0,1);
  const d = clamp(distanceLy/2.537e6, 0, 2);
  return clamp(0.12 + 0.55*x + 0.20*Math.tanh(d), 0, 1);
}

/* “Compression zones” (demo) */
function zoneCompressionPercents(w, stab, breachBoost){
  // Map 5 zones: fore, port, starboard, aft, core
  // Compression rises with warp; instability adds asymmetry; breach adds starboard spike.
  const base = clamp(10 + 7*w, 0, 100);
  const u = clamp(1 - stab, 0, 1);
  const asym = 18*u;

  const fore = clamp(base + 10*u, 0, 100);
  const aft  = clamp(base - 6 + 8*u, 0, 100);
  const port = clamp(base - asym, 0, 100);
  const star = clamp(base + asym + 0.35*breachBoost, 0, 100);
  const core = clamp(12 + 6*w + 8*(1-u), 0, 100);

  return {fore,port,star,aft,core};
}

/* Thermal + coolant (toy) */
function coreTempC(w, stab, breachBoost){
  // rises with warp^2; instability adds extra heat
  const x = w/10;
  return clamp(220 + 900*x*x + 220*(1-stab) + 1.1*breachBoost, 50, 1200);
}
function coolantTempC(w, stab){
  // coolant temp tracks core temp but capped lower
  const c = coreTempC(w, stab, 0);
  return clamp(110 + 0.18*c, 90, 520);
}
function coolantFlow(w, coreT){
  // “fuel never depletes” but power rises with ramps; coolant flow rises with heat
  return clamp(0.2 + 0.0045*coreT + 0.12*w, 0, 12); // arbitrary units
}
function magFieldStrength(w, stab, breachBoost){
  return clamp(1.2 + 0.26*w + 1.6*stab + 0.008*breachBoost, 0, 10);
}
function photonIonRate(w){
  return Math.round(25 + 7*w*w); // /s
}
function colliderFlux(w, colliderOn=true){
  return colliderOn ? Math.round(40 + 5.0*w*w) : 0;
}
function entangleRate(w, stab){
  return Math.round(6 + 2.4*w + 10*stab); // /s
}
function plasmaCone(w){
  const len = Math.round(30 + 11*w*w);
  const rad = Math.round(6 + 1.0*w);
  return {len,rad};
}
function plasmaWave(w, stab){
  return clamp(0.08 + 0.04*w + 0.25*(1-stab), 0, 1);
}

/* Effective FTL gain (sim) */
function ftlGain(w, stab, collider=true){
  const base = warpSpeedFactor(w);
  const bonus = collider ? (1 + 0.35*stab*(w>=4?1:0.4)) : 1;
  return base*bonus;
}

/* ===== Trip calculations (Earth → destination) ===== */
function calculateTrip(){
  const dest = DEST[destSelect.value] || DEST.Andromeda;
  const D_ly = dest.ly;
  const D_km = D_ly * KM_PER_LY;

  // Use a representative “cruise” warp derived from plan or selector:
  const cruiseWarp = (warpMode==="AUTO") ? 10 : clamp(Number(warpMode),0,10);
  const speedMult = ftlGain(cruiseWarp, corridorStability(cruiseWarp), true);
  const v = C_KM_S * speedMult; // km/s (toy)

  const sec = D_km / v;
  const exp = expansionCorrection(D_ly);
  const curv = tunnelCurvature(cruiseWarp, D_ly);

  trip = { destName:dest.name, D_ly, D_km, cruiseWarp, speedMult, v, sec, exp, curv };
  distLbl.textContent = `${fmt(D_ly,0)} ly  (~${fmt(D_km/1e12,2)}×10¹² km)`;
  timeLbl.textContent = `${fmt(sec/86400,2)} days  (${fmt(sec/3600,1)} h)`;
  curvLbl.textContent = `κ = ${fmt(curv,3)}   |  shear risk = ${fmt(shearRisk(cruiseWarp),3)}`;
  expLbl.textContent  = `Δ metric ≈ +${fmt(exp,6)} (toy)`;

  // Arrival clock (CST)
  const cstNow = getCSTDate();
  const arr = new Date(cstNow.getTime() + sec*1000);
  arrivalClock.textContent = timeStr(arr);
}

/* ===== Safety panel update (fix your “stays red” issue) ===== */
function updateSafetyUI(w){
  const safe = (w >= 4);
  safeBox.classList.toggle("safe", safe);
  safeBox.classList.toggle("unsafe", !safe);

  safeTitle.classList.toggle("safe", safe);
  safeTitle.classList.toggle("unsafe", !safe);

  if(safe){
    safeTitle.textContent = "CST Warp Corridor Safety";
    safeLine.textContent  = "✔ Safe: corridor self-contained (warp ≥ 4).";
    safeLine.style.color  = getComputedStyle(document.documentElement).getPropertyValue("--good");
  }else{
    safeTitle.textContent = "CST Warp Corridor Safety";
    safeLine.textContent  = "⚠ Unsafe: increase warp ≥ 4 for stable CST warp corridor.";
    safeLine.style.color  = getComputedStyle(document.documentElement).getPropertyValue("--bad");
  }
  // your exact explanatory block stays the same
  safeText.textContent = SAFETY_TEXT_EXACT;
}

/* ===== Dyson / Prune / Decay (AI nav boundary) ===== */
function logDyson(line){
  const d = new Date();
  const stamp = `[${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}]`;
  dysonLogLines.unshift(`${stamp} ${line}`);
  if(dysonLogLines.length>40) dysonLogLines.pop();
  dyLog.textContent = dysonLogLines.join("\n");
}

function loadVault(){
  try{
    const raw = localStorage.getItem(VAULT_KEY);
    if(raw){
      const v = JSON.parse(raw);
      if(v && typeof v==="object") vault = Object.assign(vault, v);
    }
  }catch(e){}
}
function saveVault(){
  try{
    localStorage.setItem(VAULT_KEY, JSON.stringify(vault));
    vault.writes++;
  }catch(e){
    vault.leaks++;
  }
}
function pruneDecayTick(force=false){
  const now = performance.now()/1000;
  if(!force && now - vault.lastTick < 0.01) return;

  const dyOn = dysonOn.checked;
  const habitMult = pd.habitMult;
  const eventMult = dyOn ? pd.eventMult : (pd.eventMult*0.96); // faster decay when Dyson OFF

  // Snapshot before
  pd.habitsBefore = vault.habits.length;
  pd.eventsBefore = vault.events.length;

  // Decay weights
  for(const h of vault.habits) h.w *= habitMult;
  for(const e of vault.events) e.w *= eventMult;

  // Prune threshold
  const TH = dyOn ? 0.18 : 0.26;

  let pruned=[];
  const beforeH = vault.habits.length;
  const beforeE = vault.events.length;

  vault.habits = vault.habits.filter(x=>{
    const ok = x.w >= TH;
    if(!ok) pruned.push(`habit:${x.k}`);
    return ok;
  });
  vault.events = vault.events.filter(x=>{
    const ok = x.w >= TH;
    if(!ok) pruned.push(`event:${x.k}`);
    return ok;
  });

  // Cap sizes
  const CAP_H = dyOn ? 60 : 25;
  const CAP_E = dyOn ? 120 : 40;
  if(vault.habits.length > CAP_H) vault.habits.length = CAP_H;
  if(vault.events.length > CAP_E) vault.events.length = CAP_E;

  pd.prunedHabits = beforeH - vault.habits.length;
  pd.prunedEvents = beforeE - vault.events.length;

  pd.habitsAfter = vault.habits.length;
  pd.eventsAfter = vault.events.length;

  pd.prunedItems = pruned.length ? pruned.slice(0,8).join(", ") + (pruned.length>8?" …":"") : "—";

  vault.lastTick = now;

  // persistence
  if(dyOn) saveVault();

  // update budget UI (simple)
  const used = clamp((vault.habits.length/60)*0.4 + (vault.events.length/120)*0.6, 0, 1);
  const budget = Math.round((1-used)*100);
  dy_budget.textContent = `${budget}%`;
  dy_writes.textContent = String(vault.writes);
  dy_leaks.textContent  = String(vault.leaks);

  pdBlock.textContent =
`Last tick results
Habit decay multiplier
${fmt(pd.habitMult,3)}
Event decay multiplier
${fmt(dysonOn.checked ? pd.eventMult : (pd.eventMult*0.96),3)}
Habits before → after
${pd.habitsBefore} → ${pd.habitsAfter}
Events before → after
${pd.eventsBefore} → ${pd.eventsAfter}
Pruned habits
${pd.prunedHabits}
Pruned events
${pd.prunedEvents}
Pruned items (last tick)
${pd.prunedItems}`;

  logDyson(`Prune/Decay tick: persisted=${dysonOn.checked ? "YES" : "NO"} budget=${dy_budget.textContent} habits=${vault.habits.length} events=${vault.events.length}`);
}

function dysonBoot(){
  loadVault();
  logDyson("Boot: Dyson panel visible. Big switch toggles persistence. Prune/Decay monitor shows exactly what gets removed each tick.");
  pruneDecayTick(true);
}
dysonBoot();

/* ===== UI Events ===== */
speed.addEventListener("input", ()=>{
  speedLbl.textContent = speed.value;
  playbackLbl.textContent = speed.value + "×";
});
warpSelect.addEventListener("change", ()=>{
  warpMode = warpSelect.value;
});
btnCalc.onclick = ()=>{
  calculateTrip();
};
btnStart.onclick = ()=>{
  if(!trip) calculateTrip();
  if(!depCST) depCST = getCSTDate();
  running = true;
  lastTs = 0;
};
btnStop.onclick = ()=>{
  running=false;
};
btnBreach.onclick = ()=>{
  breach=true;
  breachT=0;
};
btnHeal.onclick = ()=>{
  breach=false;
  breachT=0;
  boost=0;
};
btnDecayNow.onclick = ()=>pruneDecayTick(true);
btnResetUI.onclick = ()=>{
  // UI reset (keeps vault)
  setTab("Nav");
  logDyson("UI reset. Vault kept as-is.");
};
btnClearVault.onclick = ()=>{
  vault.habits=[]; vault.events=[];
  vault.writes=0; vault.leaks=0;
  try{ localStorage.removeItem(VAULT_KEY); }catch(e){}
  logDyson("Vault cleared.");
  pruneDecayTick(true);
};

/* Report events */
btnClearLog.onclick = clearLog;

/* ===== “AI nav” writes (simple) ===== */
function aiNavWrite(key, weight, isEvent=true){
  const item = {k:key, w:weight, t:Date.now()};
  if(dysonOn.checked){
    if(isEvent) vault.events.unshift(item);
    else vault.habits.unshift(item);
    saveVault();
  }
}

/* ===== Math panel builders (warp-converted text blocks) ===== */
function updateMathPanels(d, w, stab, curv, exp, gain){
  // “UpdateMath & CST Ledger” converted for warp drive display only
  const H_eff = 58.566; // km/s/Mpc (demo constant per your text)
  const D_Mpc = (d.D_ly / 3.26156e6); // ly to Mpc approx
  const v_rec = H_eff * D_Mpc;        // km/s (demo)
  const v_rec_c = v_rec / C_KM_S;

  // Toy “FTL time (drag model)” forms (display-only)
  const f = gain; // use gain as f
  const H = H_eff / (3.085677581e19); // (km/s)/km -> 1/s (rough conversion, demo)
  const D_km = d.D_km;
  let t_ftl = "—";
  if(f*C_KM_S > H*D_km){
    const t = (1/H) * Math.log((f*C_KM_S) / (f*C_KM_S - H*D_km));
    t_ftl = `${fmt(t/86400,2)} days`;
  }

  const jumps = Math.ceil((1+0.18) * d.D_ly / 2.5e5); // toy jump length: 250k ly
  const tau_lat = 1.4; // sec per jump (toy)
  const T_ext = jumps * tau_lat;

  const clockRate = clockRateFromWarp(w);

  mathBlock.textContent =
`Equations (toy forms)
Recession: v_rec = H · D
FTL time (drag model): t = (1/H) · ln[(f·c)/(f·c − H·D)]
Warp-tunnel jumps: N = ceil((1+margin)·D / J), T_ext ≈ N · τ_lat
Warp Meter: v_ext = L / Δt_E, v_ship = L / Δt_S, k = v/c

H_eff: ${fmt(H_eff,3)} km/s/Mpc
v_rec(D): ${fmt(v_rec,3)} km/s  (${fmt(v_rec_c,3)} c)

N jumps (toy): ${jumps}
Tunnel latency time: ${fmt(T_ext,2)} s

CST Time Ledger (Warp-Hole/Tunnel)
On-site time: ${running ? hmsFromSeconds(tSim) : "—"}
Latency counts as crew aging?: ${dysonOn.checked ? "YES (vault persists)" : "NO (boundary open)"}
Ship aging (scaled by clock rate): ${running ? hmsFromSeconds(tSim*clockRate) : "—"}
Earth elapsed (CST): ${running ? hmsFromSeconds(tSim) : "—"}

If CST-locked, ship and Earth advance together; only time you live (on-site and, if chosen, latency) accrues.`;


  // State vectors (demo placeholders but consistent)
  // Use simple circular “AU” coordinates that move slowly with tSim (for display)
  const angE = (tSim*0.0004 + 3.44) % (Math.PI*2);
  const angM = (tSim*0.0003 + 1.85) % (Math.PI*2);
  const rE=1.0, rM=1.524;
  const Ex = -Math.cos(angE)*rE, Ey = -Math.sin(angE)*rE;
  const Mx = -Math.cos(angM)*rM, My =  Math.sin(angM)*rM;

  const chiE = -2.843 + 0.05*Math.sin(tSim*0.002);
  const chiM =  1.829 + 0.05*Math.cos(tSim*0.002);
  const dX = (Mx-Ex), dY=(My-Ey), dZ=0;
  const dChi = (chiE-chiM);
  const d3 = Math.sqrt(dX*dX + dY*dY + dZ*dZ);
  const kChi = 0.75; // weight
  const d4 = Math.sqrt(d3*d3 + (kChi*dChi)*(kChi*dChi));

  const Eexp = 2.0*d3;
  const Ewarp = 2.0 + 0.2*w;
  const impact = (1.0 + (1-stab))* (1 + w/10);

  stateBlock.textContent =
`Earth position (AU, ecliptic plane)
( ${fmt(Ex,3)}, ${fmt(Ey,3)}, 0.000 )
Mars position (AU, ecliptic plane)
( ${fmt(Mx,3)}, ${fmt(My,3)}, 0.000 )
4th component χ (phase channel, rad)
χ⊕ = ${fmt(chiE,3)}, χ♂ = ${fmt(chiM,3)}

4D vector ΔX (Δx, Δy, Δz, Δχ)
[ ${fmt(dX,3)}, ${fmt(dY,3)}, 0.000, ${fmt(dChi,3)} ]

3D distance |r♂ − r⊕|
${fmt(d3,3)} AU
4D distance ‖ΔX‖ (with χ & kχ)
${fmt(d4,3)} AU*
*Scaled 4D metric: spatial components in AU, phase axis weighted by kχ.

Curvature factor κ (demo)
${fmt(curv,3)}
Expected energy ∝ 3D distance
Eexp = ${fmt(Eexp,3)}
Warp energy selection
Ewarp = ${fmt(Ewarp,3)}
Effective FTL Gain (from engine)
γFTL = ${fmt(gain,2)}×
Estimated trip time
${fmt(trip ? (trip.sec/86400) : 0,2)} days ( ${fmt(trip ? (trip.sec/3600) : 0,1)} h )

Engine core temp prediction
${fmt(coreTempC(w,stab,boost),0)} °C
Field shield at warp
${fmt(stab*100,0)} %  | Impact index: ${fmt(impact,2)}`;

  // Verification channels
  const tol = 0.20;
  const ch1 = (Math.abs(d4-d3)/Math.max(1e-9,d3)) < tol;
  const ch2 = (Math.abs(Ewarp-Eexp)/Math.max(1e-9,Eexp)) < tol;
  const ch3 = (Math.abs(dChi)) < 1.0; // phase tol
  const go = ch1 && ch2 && ch3 && (w>=4);

  verifyBlock.textContent =
`1. 3D vs 4D distance consistency
|d4D − d3D| / d3D < tol?  →  ${ch1 ? "YES" : "NO"}

2. Energy profile consistency
|Ewarp − Eexp| / Eexp < tol?  →  ${ch2 ? "YES" : "NO"}

3. Phase alignment window
|Δχ| < phase tolerance?  →  ${ch3 ? "YES" : "NO"}

4. Overall GO/NO-GO
All three channels green AND warp≥4?  →  ${go ? "GO" : "NO-GO"}`;
}

/* ===== Clock panel updates ===== */
function updateClocks(w){
  const u = nowUTC();
  const c = getCSTDate();
  utcClock.textContent = timeStr(u);
  cstClock.textContent = timeStr(c);

  const rate = clockRateFromWarp(w);
  const scaled = new Date(c.getTime() + (running ? (tSim*rate*1000) : 0));
  warpClock.textContent = timeStr(scaled);

  if(trip){
    const base = depCST ? depCST : c;
    const arr = new Date(base.getTime() + trip.sec*1000);
    arrivalClock.textContent = timeStr(arr);
  }else{
    arrivalClock.textContent = "--:--:--";
  }

  cstLockLbl.textContent = "ON";
  cstLockLbl.className = "good";

  const earthElapsed = running ? hmsFromSeconds(tSim) : "—";
  const shipAging    = running ? hmsFromSeconds(tSim*rate) : "—";
  ledgerClock.textContent = `Earth elapsed: ${earthElapsed}\nShip aging:   ${shipAging}\nClock rate:   ${fmt(rate,2)}×`;
}

/* ===== Telemetry update ===== */
function updateTelemetryUI(w, stab, R, rx, ry, gain){
  tel_speed.textContent   = `x${fmt(Number(speed.value)/28.5,1)}`; // cosmetic scale
  tel_radius.textContent  = fmt(R/210,2);
  tel_shield.textContent  = fmt(stab*100,0) + "%";
  tel_stretch.textContent = `${fmt0(rx)} / ${fmt0(ry)}`;

  const cr = clockRateFromWarp(w);
  tel_clockrate.textContent = fmt(cr,2) + "×";

  tel_photon.textContent = `${photonIonRate(w)} /s`;
  tel_flux.textContent   = `${colliderFlux(w,true)} /s`;
  tel_mag.textContent    = fmt(magFieldStrength(w,stab,boost),2);

  const coreT = coreTempC(w,stab,boost);
  const coolT = coolantTempC(w,stab);
  tel_coreT.textContent  = `${fmt(coreT,0)} °C`;
  tel_coolT.textContent  = `${fmt(coolT,0)} °C`;

  tel_ent.textContent    = `${entangleRate(w,stab)} /s`;
  const cone = plasmaCone(w);
  tel_cone.textContent   = `${cone.len} u / ${cone.rad} u`;
  tel_wave.textContent   = fmt(plasmaWave(w,stab),2);

  tel_ftl.textContent    = fmt(gain,2) + "×";
}

/* ===== Breach + Field readouts ===== */
function updateBreach(w, stab, dt){
  if(!breach){
    boost = Math.max(0, boost - dt*35);
    containLbl.textContent = (w>=4 && stab>=0.65) ? "Stable" : "Caution";
    containLbl.style.color = (w>=4 && stab>=0.65) ? "var(--good)" : "var(--warn)";
    boostLbl.textContent = fmt0(boost);
    return;
  }
  breachT += dt;
  // boost ramps quickly, then decays after auto-heal
  boost = clamp(boost + dt*140, 0, 100);
  containLbl.textContent = (stab>=0.45) ? "Stable" : "Unstable";
  containLbl.style.color = (stab>=0.45) ? "var(--good)" : "var(--bad)";
  boostLbl.textContent = fmt0(boost);

  // auto-heal after ~5s
  if(breachT >= 5){
    breach=false;
    breachT=0;
    logDyson("Breach auto-healed after ~5s (demo).");
  }
}
function updateFieldReadouts(w, stab){
  // You asked to convert to warp-drive specs; these are demo indexes:
  const warpAssist = clamp(18 + 6.2*w + 12*stab + 0.12*boost, 0, 100);
  const negEnergy  = clamp(14 + 5.7*w + 10*(1-stab) + 0.08*boost, 0, 100);
  warpAssistLbl.textContent = fmt(warpAssist,1) + "%";
  negEnergyLbl.textContent  = fmt(negEnergy,1) + "%";
}

/* ===== Main loop ===== */
function setProgressUI(pct, s){
  progBar.style.width = (pct*100).toFixed(1)+"%";
  progTxt.textContent = `${fmt(pct*100,0)}% • t = ${fmt(tSim,1)} s • phase: ${s ? s.phase : "—"}`;
}

function updateTripSummaryUI(w, stab){
  if(!trip){
    distLbl.textContent="—"; timeLbl.textContent="—"; curvLbl.textContent="—"; expLbl.textContent="—";
    return;
  }
  // show “live” curvature & expansion as warp changes (toy)
  const curv = tunnelCurvature(w, trip.D_ly);
  const exp  = expansionCorrection(trip.D_ly);
  const shear = shearRisk(w);

  const gain = ftlGain(w, stab, true);

  curvLbl.textContent = `κ = ${fmt(curv,3)}   |  shear risk = ${fmt(shear,3)}`;
  expLbl.textContent  = `Δ metric ≈ +${fmt(exp,6)} (toy)`;

  // update time estimate using current gain (toy)
  const v = C_KM_S * gain;
  const sec = trip.D_km / v;
  timeLbl.textContent = `${fmt(sec/86400,2)} days  (${fmt(sec/3600,1)} h)`;
}

let dysonTickAccum=0;

function loop(ts){
  const dt = (ts - lastTs)/1000 || 0;
  lastTs = ts;

  ctx.clearRect(0,0,W,H);

  // Determine warp
  const effSpeed = Number(speed.value); // sim-seconds per real second
  speedLbl.textContent = speed.value;
  playbackLbl.textContent = speed.value + "×";

  if(running){
    tSim += dt * effSpeed;
    if(tSim >= PLAN_LEN){
      tSim = PLAN_LEN;
      running=false;
      aiNavWrite("arrival", 0.95, true);
      logDyson("Arrival: flight plan completed.");
    }
  }

  let planWarp = 0;
  let step = null;
  if(warpMode==="AUTO"){
    const st = planAt(tSim);
    step = st.s;
    planWarp = st.warp;
    warp = planWarp;
  }else{
    warp = clamp(Number(warpMode),0,10);
    step = planAt(tSim).s;
  }

  // Safety / stability
  const stabBase = corridorStability(warp);
  // breach makes stability slightly worse
  const stab = clamp(stabBase - 0.0035*boost, 0, 1);

  updateSafetyUI(warp);

  // Starfield
  updateStars(dt, warp);
  drawStars();

  // Shield size & stretch (telemetry you asked for)
  const baseR = 210;
  const pulse = 0.12*Math.sin(ts*0.004) + 0.88;
  const warpBoost = 1 + warp*0.12;
  const R = baseR*pulse*warpBoost;

  // stretch ratio rx/ry (demo: instability skews it)
  const u = 1 - stab;
  const rx = 1 + 0.35*warp + 0.28*u + 0.012*boost;
  const ry = 1 + 0.22*warp - 0.18*u;

  // draw field + ship
  drawProtectionField(R, warp, rx, ry);
  drawShipOutline();
  drawShipLabels();

  // core + particles
  drawCore(ts, warp);
  updateCoreParticles(dt, warp);
  drawCoreParticles(warp);

  updateEngineParticles(dt, warp);
  drawEngineParticles();

  updateFieldParticles(dt, R*Math.max(rx,ry));
  drawFieldParticles(R*Math.max(rx,ry), ts/1000);

  // clocks
  updateClocks(warp);

  // trip UI
  const pct = clamp(tSim/PLAN_LEN, 0, 1);
  setProgressUI(pct, step);
  updateTripSummaryUI(warp, stab);

  // breach + readouts
  updateBreach(warp, stab, dt);
  updateFieldReadouts(warp, stab);

  // telemetry
  const gain = ftlGain(warp, stab, true);
  updateTelemetryUI(warp, stab, R, rx*R, ry*R, gain);

  // math panels
  if(trip){
    const curv = tunnelCurvature(warp, trip.D_ly);
    const exp  = expansionCorrection(trip.D_ly);
    updateMathPanels(trip, warp, stab, curv, exp, gain);
  }else{
    // show something even before calc
    const d = DEST[destSelect.value] || DEST.Andromeda;
    const dummy = {destName:d.name, D_ly:d.ly, D_km:d.ly*KM_PER_LY, sec:0};
    updateMathPanels(dummy, warp, stab, tunnelCurvature(warp,d.ly), expansionCorrection(d.ly), gain);
  }

  // Dyson tick
  dysonTickAccum += dt;
  vault.nextTickIn = Math.max(0, vault.nextTickIn - dt);
  if(dysonTickAccum >= 0.25){
    // show next tick countdown
    dy_next.textContent = fmt(vault.nextTickIn,1) + "s";
    dysonTickAccum = 0;
  }
  if(vault.nextTickIn <= 0){
    vault.nextTickIn = 4.5;
    pruneDecayTick(true);
  }

  // AI navigation “writes” (simple)
  if(running && step && Math.random() < 0.02){
    aiNavWrite(`telemetry_step_${step.step}`, 0.60 + 0.25*stab, true);
  }

  // Report logging (per frame, only while running)
  if(running){
    const clockRate = clockRateFromWarp(warp);
    const shear = shearRisk(warp);
    const curv = tunnelCurvature(warp, (trip?trip.D_ly:DEST.Andromeda.ly));
    const exp  = expansionCorrection((trip?trip.D_ly:DEST.Andromeda.ly));
    const coreT = coreTempC(warp, stab, boost);
    const coolT = coolantTempC(warp, stab);
    const flow  = coolantFlow(warp, coreT);

    const zones = zoneCompressionPercents(warp, stab, boost);
    // stats
    zoneUpdateStats("fore", zones.fore);
    zoneUpdateStats("port", zones.port);
    zoneUpdateStats("star", zones.star);
    zoneUpdateStats("aft",  zones.aft);
    zoneUpdateStats("core", zones.core);

    addLogRow({
      tSim,
      step: step?step.step:"—",
      phase: step?step.phase:"—",
      warp,
      stability: stab,
      shear,
      curvature: curv,
      expansion: exp,
      clockRate,
      fieldR: R,
      rx: rx*R,
      ry: ry*R,
      shieldPct: stab*100,
      mag: magFieldStrength(warp,stab,boost),
      coreT,
      coolT,
      coolantFlow: flow,
      photon: photonIonRate(warp),
      flux: colliderFlux(warp,true),
      ent: entangleRate(warp,stab),
      wave: plasmaWave(warp,stab),
      ftlGain: gain,
      z_fore: zones.fore,
      z_port: zones.port,
      z_star: zones.star,
      z_aft:  zones.aft,
      z_core: zones.core
    });
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
<!-- ======================= PART 4 / 4 ======================= -->
<script>
/* ===== Report build / print / csv ===== */
function buildReport(){
  const frames = LOG.length;
  if(frames===0){
    reportSummary.textContent="No frames logged yet. Click Start, let it run, then click Build Report.";
    return;
  }
  const last = LOG[LOG.length-1];

  const zoneLines=[];
  for(const z of ZONES){
    const st = zoneStats[z];
    const avg = st.frames ? (st.sum/st.frames) : 0;
    const avgAct = st.activeFrames ? (st.sumActive/st.activeFrames) : 0;
    zoneLines.push(
      `${z.toUpperCase()}: peak=${fmt(st.peak,1)}% • avg=${fmt(avg,1)}% • avg(active)=${fmt(avgAct,1)}% • `+
      `activeFrames=${st.activeFrames} • hitFrames=${st.hitFrames} • hitEntries=${st.enterHits}`
    );
  }

  reportSummary.textContent =
`Frames logged: ${frames}
Last t=${fmt(last.tSim,1)} s • Warp=${fmt(last.warp,2)} • Stability=${fmt(last.stability,3)} • ClockRate=${fmt(last.clockRate,2)}×
FieldR=${fmt(last.fieldR,1)} • Stretch(rx/ry)=${fmt0(last.rx)} / ${fmt0(last.ry)} • Shield=${fmt(last.shieldPct,0)}%
CoreT=${fmt(last.coreT,0)}°C • CoolantT=${fmt(last.coolT,0)}°C • CoolantFlow=${fmt(last.coolantFlow,2)}
FTL Gain (sim)=${fmt(last.ftlGain,2)}×

Zone stats (hits when ≥45%):
${zoneLines.join("\n")}`;

  // Print blocks
  printSummary.textContent =
`Frames logged: ${frames}
Final t=${fmt(last.tSim,1)} s; Warp=${fmt(last.warp,2)}; Stability=${fmt(last.stability,3)}; ClockRate=${fmt(last.clockRate,2)}×
Field: R=${fmt(last.fieldR,1)}; rx=${fmt0(last.rx)}; ry=${fmt0(last.ry)}; Shield=${fmt(last.shieldPct,0)}%
Thermal: Core=${fmt(last.coreT,0)}°C; Coolant=${fmt(last.coolT,0)}°C; Flow=${fmt(last.coolantFlow,2)}
Hit definition: zone compression% ≥ 45`;

  const zoneTable=[];
  zoneTable.push(`<table><thead><tr>
    <th>Zone</th><th>Peak %</th><th>Avg %</th><th>Avg(active ≥30%)</th><th>Active frames</th><th>Hit frames (≥45%)</th><th>Hit entries</th>
  </tr></thead><tbody>`);
  for(const z of ZONES){
    const st=zoneStats[z];
    const avg = st.frames ? (st.sum/st.frames) : 0;
    const avgAct = st.activeFrames ? (st.sumActive/st.activeFrames) : 0;
    zoneTable.push(`<tr>
      <td>${z}</td>
      <td>${fmt(st.peak,1)}%</td>
      <td>${fmt(avg,1)}%</td>
      <td>${fmt(avgAct,1)}%</td>
      <td>${st.activeFrames}</td>
      <td>${st.hitFrames}</td>
      <td>${st.enterHits}</td>
    </tr>`);
  }
  zoneTable.push(`</tbody></table>`);
  printZones.innerHTML = zoneTable.join("");

  const headN = Math.min(200, LOG.length);
  const rows=[];
  rows.push(`<table><thead><tr>
    <th>#</th><th>t(s)</th><th>Step</th><th>Warp</th><th>Stability</th><th>Shield%</th><th>Core°C</th><th>Coolant°C</th><th>FTL×</th>
    <th>Fore%</th><th>Port%</th><th>Star%</th><th>Aft%</th><th>Core%</th>
  </tr></thead><tbody>`);
  for(let i=0;i<headN;i++){
    const r = LOG[i];
    rows.push(`<tr>
      <td>${i+1}</td>
      <td>${fmt(r.tSim,1)}</td>
      <td>${r.step}</td>
      <td>${fmt(r.warp,2)}</td>
      <td>${fmt(r.stability,3)}</td>
      <td>${fmt(r.shieldPct,0)}%</td>
      <td>${fmt(r.coreT,0)}</td>
      <td>${fmt(r.coolT,0)}</td>
      <td>${fmt(r.ftlGain,2)}</td>
      <td>${fmt(r.z_fore,0)}%</td>
      <td>${fmt(r.z_port,0)}%</td>
      <td>${fmt(r.z_star,0)}%</td>
      <td>${fmt(r.z_aft,0)}%</td>
      <td>${fmt(r.z_core,0)}%</td>
    </tr>`);
  }
  rows.push(`</tbody></table>`);
  printLog.innerHTML = rows.join("");
}

function downloadCSV(){
  if(LOG.length===0){
    reportSummary.textContent="No data to export. Run the sim first.";
    return;
  }
  const cols = [
    "tSim","step","phase","warp","stability","shear","curvature","expansion","clockRate",
    "fieldR","rx","ry","shieldPct","mag","coreT","coolT","coolantFlow",
    "photon","flux","ent","wave","ftlGain",
    "z_fore","z_port","z_star","z_aft","z_core"
  ];
  const lines=[cols.join(",")];
  for(const r of LOG){
    const line = cols.map(c=>{
      const v=r[c];
      if(typeof v==="string") return `"${v.replace(/"/g,'""')}"`;
      return (isFinite(v) ? String(v) : "");
    }).join(",");
    lines.push(line);
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download="cst_warp_log.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* Wire report buttons */
btnBuildReport.addEventListener("click", buildReport);
btnPrint.addEventListener("click", ()=>{
  buildReport();
  window.print();
});
btnCSV.addEventListener("click", downloadCSV);

/* Startup defaults */
clearLog();
calculateTrip();         // so panels populate immediately
updateSafetyUI(0);       // show unsafe at idle
speedLbl.textContent = speed.value;
playbackLbl.textContent = speed.value + "×";
setTab("Nav");
</script>
</body>
</html>
