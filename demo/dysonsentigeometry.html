<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Einstein Master Equation Calculator — GR ⟷ QM ⟷ Photons ⟷ CST(τ) + Dyson + Prune/Decay + φ-Sentinel</title>

<!-- MathJax for equations -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<style>
  :root{
    --bg:#0b0f14; --panel:#121822; --ink:#e6edf7; --muted:#98a2b3; --accent:#6ee7ff;
    --ok:#3ddc97; --warn:#ffdd57; --bad:#ff5c7a; --border:#1d2940;
    --dysonRing: rgba(255, 200, 60, 0.62);
    --dysonRing2: rgba(255, 200, 60, 0.18);
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--ink);
       background: radial-gradient(1200px 520px at 120% -20%, rgba(167,139,250,.07), transparent 40%), #0a0e16;}
  header{padding:20px 24px; border-bottom:1px solid #1b2433; position:sticky; top:0; background:rgba(10,14,22,.85); backdrop-filter:blur(6px); z-index:10}
  h1{margin:0; font-size:22px}
  .sub{color:var(--muted); font-size:14px; margin-top:6px; line-height:1.45}
  main{max-width:1200px; margin:22px auto; padding:0 16px 80px}
  .grid{display:grid; gap:16px}
  .cols-2{grid-template-columns:repeat(2,1fr)}
  .cols-3{grid-template-columns:repeat(3,1fr)}
  .card{background:linear-gradient(180deg,#121827,#0e1523); border:1px solid var(--border); border-radius:16px; padding:16px; box-shadow:0 12px 30px rgba(0,0,0,.2)}
  .kicker{color:var(--accent); text-transform:uppercase; letter-spacing:.12em; font-size:12px}
  label{display:block; font-size:12px; color:var(--muted); margin:8px 0 4px}
  input,select,textarea{width:100%; background:#0b1220; color:var(--ink); border:1px solid #263349; border-radius:10px; padding:10px 12px; outline:none}
  textarea{min-height:88px; resize:vertical}
  input:focus,select:focus,textarea:focus{border-color:var(--accent)}
  .btnrow{display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; align-items:center}
  button{background:linear-gradient(180deg,#18263a,#122035); color:#e6f3ff; border:1px solid #223149; border-radius:12px; padding:10px 14px; cursor:pointer}
  button.primary{background:linear-gradient(180deg,#00bcd4,#0094b2); border-color:#00a5be; color:#00131a; font-weight:700}
  .eq{font-family:ui-serif,Georgia,serif; font-size:14px; line-height:1.55; background:#0b1220; border:1px solid #243149; border-radius:12px; padding:12px}
  .badge{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid #1e2a3b; background:#0b1220}
  .ok{color:var(--ok); border-color:#134c39}
  .warn{color:var(--warn); border-color:#4d4116}
  .bad{color:var(--bad); border-color:#4d1e2b}
  .hint{color:var(--muted); font-size:12px; margin-top:6px; line-height:1.45}
  table{width:100%; border-collapse:collapse; border:1px solid #1e2a3b; border-radius:12px; overflow:hidden}
  th,td{padding:10px 12px; border-bottom:1px solid #1c2738; font-size:14px}
  th{background:#0f1626}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}

  canvas{width:100%; height:220px; border-radius:12px; background:radial-gradient(800px 300px at 120% -20%, rgba(110,231,255,.06), transparent 40%), #0a0f17; border:1px solid #18253a}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}

  .switch{
    display:flex; align-items:center; gap:10px;
    padding:10px 12px; border-radius:12px;
    border:1px solid #263349; background:#0b1220;
    font-size:13px; color:var(--ink);
    user-select:none;
  }
  .switch input{transform:scale(1.15)}
  .split{display:grid; gap:12px; grid-template-columns: 1.05fr 0.95fr;}
  .subcard{border:1px solid #1d2940; background:rgba(0,0,0,.15); border-radius:14px; padding:12px;}
  .miniTitle{font-size:13px; margin:0 0 6px; color:#cfe6ff}
  .dyRead{font-size:12px; color:#cfe6ff; opacity:.95; line-height:1.45}
  .vault{
    max-height:220px; overflow:auto;
    border:1px solid #1d2940; background:#0b1220;
    border-radius:12px; padding:10px; font-size:12px; line-height:1.35;
    white-space:pre-wrap;
  }
  .tiny{font-size:11px; color:var(--muted)}
  .callout{
    background:rgba(110,231,255,.07);
    border:1px solid rgba(110,231,255,.22);
    border-radius:14px;
    padding:12px;
    font-size:13px;
    line-height:1.45;
    color:#d7f2ff;
  }

  .phiGrid{display:grid; gap:12px; grid-template-columns: 1.05fr 0.95fr;}
  .phiCanvas{height:260px;}
  .pill{display:inline-flex; align-items:center; gap:8px; padding:7px 10px; border-radius:999px; background:#0b1220; border:1px solid #1e2a3b; font-size:12px}
  .pill b{font-family:ui-monospace,Menlo,Consolas,monospace; font-weight:700}
  .mini{font-size:12px; color:var(--muted); line-height:1.45}
</style>
</head>

<body>
<header>
  <h1>Einstein Master Equation Calculator</h1>
  <div class="sub">
    <b>Upgrade applied:</b> CST time <b>τ</b> is an explicit <b>control/synchronization time</b> used by the solver and the equation panels.
    Dyson Sphere enables a <b>Vault term</b> (memory reuse); <b>Decay</b> + <b>Prune</b> maintain the vault to suppress repeated recomputation.
    <span class="badge" style="margin-left:8px">NEW: φ-Sentinel</span>
  </div>
</header>

<main class="grid">

  <!-- Instructions -->
  <section class="card">
    <div class="kicker">How to use</div>
    <ol style="margin:6px 0 6px 18px">
      <li>Set steps, Δt, tolerances (ε<sub>GR</sub>, ε<sub>QM</sub>, ε<sub>ΔC</sub>), PD gains.</li>
      <li>Set <b>CST time τ</b> (control-time) and choose τ evolution (fixed / ramp).</li>
      <li>Turn <b>Dyson Sphere ON</b> to enable Vault targets/priors; tune <b>η</b> and <b>γ</b>.</li>
      <li>Keep <b>Decay ON</b> and <b>Prune ON</b> so stale/weak vault entries fade and are removed.</li>
      <li><b>φ-Sentinel:</b> enter <span class="mono">pTγ</span> and <span class="mono">ETmiss</span>. Unit mode uses <span class="mono">atan2</span> + <span class="mono">sqrt</span> normalization.</li>
      <li>Click <b>Run Simulation</b>. Residual plots + badges update. Passing runs can be stored in the vault.</li>
    </ol>
    <div class="hint">This is a stable toy kernel for UI + algorithm verification. Replace the hooks with your real GR/QM/CST solvers.</div>

    <div class="callout" style="margin-top:12px">
      <b>Community note (bounded feature consistency):</b><br/>
      I like the focus on bounded, scale-invariant features for ML. One consistency item: if ϕ is defined via arctan/atan2,
      then the sin/cos projections should use the √(x²+y²) normalization (unit-circle), otherwise treat the (x/(x+y)) forms
      as fraction features rather than trig. Also, for collider conventions, using pTγ and ETmiss is typically cleaner than Eγ and MET.
      <div class="tiny" style="margin-top:6px">
        If useful, I have a small interactive “constraint + sentinel” demo that wraps bounded feature spaces with (i) a global boundary check,
        (ii) drift/violation monitoring, and (iii) prune/decay memory to suppress unstable regions over time — essentially a governance layer
        that could sit on top of φ-style features.
      </div>
    </div>
  </section>

  <!-- φ-Sentinel Panel -->
  <section class="card">
    <div class="kicker">φ-Sentinel</div>
    <h2 style="margin:6px 0 10px">γ + ETmiss: Unit-circle φ geometry + drift monitor</h2>

    <div class="phiGrid">
      <div class="subcard">
        <h3 class="miniTitle">Inputs (collider-convention)</h3>
        <div class="grid cols-3">
          <div>
            <label>pTγ (GeV)</label>
            <input id="ptg" type="number" min="0" step="0.1" value="250"/>
            <div class="tiny">Photon transverse momentum</div>
          </div>
          <div>
            <label>ETmiss (GeV)</label>
            <input id="etmiss" type="number" min="0" step="0.1" value="180"/>
            <div class="tiny">Missing transverse energy</div>
          </div>
          <div>
            <label>ε (near-zero guard)</label>
            <input id="phiEps" type="number" step="1e-6" value="1e-9"/>
            <div class="tiny">Prevents division by zero</div>
          </div>
        </div>

        <div class="grid cols-3" style="margin-top:10px">
          <div>
            <label>Mode</label>
            <select id="phiMode">
              <option value="unit" selected>Unit-circle (recommended)</option>
              <option value="fraction">Fraction feature (no trig)</option>
            </select>
            <div class="tiny">Unit uses √(x²+y²)+atan2; Fraction uses (x+y) and does not claim trig.</div>
          </div>
          <div>
            <label>Sentinel tolerance |1−Kφ|</label>
            <input id="kTol" type="number" step="1e-6" value="1e-6"/>
            <div class="tiny">Green if below this</div>
          </div>
          <div>
            <label>Log to Run Log</label>
            <select id="phiLog">
              <option value="yes" selected>Yes</option>
              <option value="no">No</option>
            </select>
            <div class="tiny">Adds a line to the run summary</div>
          </div>
        </div>

        <div class="row" style="margin-top:12px; align-items:flex-start">
          <span class="pill">ϕ = <b id="phiVal">—</b> rad</span>
          <span class="pill">sinϕ = <b id="sinVal">—</b></span>
          <span class="pill">cosϕ = <b id="cosVal">—</b></span>
          <span class="pill">Kϕ = <b id="kVal">—</b></span>
          <span class="pill">|1−Kϕ| = <b id="kErrVal">—</b></span>
        </div>

        <div class="row" style="margin-top:10px">
          <span id="sentinelBadge" class="badge warn">Sentinel: —</span>
          <span class="badge">Dyson = manifold constraint</span>
          <span class="badge">Prune/Decay = memory hygiene</span>
        </div>

        <div class="mini" style="margin-top:10px">
          <b>Unit-circle geometry:</b><br/>
          x = ETmiss, y = pTγ, E<sub>tot</sub> = √(x²+y²), ϕ = atan2(y,x), sinϕ = y/E<sub>tot</sub>, cosϕ = x/E<sub>tot</sub>, Kϕ = sin²+cos² ≈ 1.
          <br/><br/>
          <b>Fraction mode:</b> u = x/(x+y), v = y/(x+y) (bounded; not trig; no unit-circle claim).
        </div>
      </div>

      <div class="subcard">
        <h3 class="miniTitle">Geometry plot</h3>
        <canvas id="phiCanvas" class="phiCanvas"></canvas>
        <div class="hint">Unit mode draws unit circle + (cosϕ, sinϕ). Fraction mode draws (u,v) in a reference square.</div>
      </div>
    </div>
  </section>

  <!-- Equations -->
  <section class="card">
    <div class="kicker">Einstein “Master Equation” (coupled system)</div>

    <div class="callout" style="margin:8px 0 12px">
      <b>Interpretation:</b> τ is a <b>control/synchronization time</b> that schedules memory reuse (Dyson/Vault),
      feedback gains, and prune/decay. It is not a second physical time coordinate.
    </div>

    <div class="grid cols-2">
      <div class="eq" id="eqEinsteinBox">Loading equations…</div>
      <div class="eq" id="eqQuantumBox">Loading equations…</div>
    </div>

    <div class="row" style="margin-top:8px">
      <span class="badge">Dyson = memory prior / reuse</span>
      <span class="badge">Decay = stale weights fade</span>
      <span class="badge">Prune = small stable vault</span>
      <span class="badge">CST time τ = control-time scheduler</span>
    </div>
  </section>

  <!-- CST Time Panel -->
  <section class="card">
    <div class="kicker">CST Time</div>
    <h2 style="margin:6px 0 10px">CST Synchronization Time (τ) — Control-Time Layer</h2>

    <div class="split">
      <div class="subcard">
        <h3 class="miniTitle">τ Settings</h3>

        <div class="grid cols-3">
          <div>
            <label>τ mode</label>
            <select id="tauMode">
              <option value="fixed" selected>Fixed τ</option>
              <option value="ramp">Ramp τ with run</option>
            </select>
            <div class="tiny">Fixed = constant τ. Ramp = τ increases during the run.</div>
          </div>
          <div>
            <label>τ start</label>
            <input id="tauStart" type="number" step="0.01" value="0.35"/>
            <div class="hint">τ₀: <span id="tauStartVal">0.35</span></div>
          </div>
          <div>
            <label>τ max (ramp)</label>
            <input id="tauMax" type="number" step="0.01" value="0.85"/>
            <div class="hint">τ<sub>max</sub>: <span id="tauMaxVal">0.85</span></div>
          </div>
        </div>

        <div class="grid cols-3" style="margin-top:10px">
          <div>
            <label>τ rate (ramp strength)</label>
            <input id="tauRate" type="range" min="0.00" max="3.00" step="0.01" value="1.10"/>
            <div class="hint">rate: <span id="tauRateVal">1.10</span></div>
          </div>
          <div>
            <label>τ → η shaping</label>
            <input id="tauEtaShape" type="range" min="0.20" max="2.50" step="0.01" value="1.10"/>
            <div class="hint">shape: <span id="tauEtaShapeVal">1.10</span></div>
          </div>
          <div>
            <label>τ → decay shaping</label>
            <input id="tauDecayShape" type="range" min="0.20" max="2.50" step="0.01" value="0.90"/>
            <div class="hint">shape: <span id="tauDecayShapeVal">0.90</span></div>
          </div>
        </div>

        <div class="callout" style="margin-top:12px">
          <b>How τ is used (toy):</b><br/>
          • τ modulates effective Vault influence: <span class="mono">η_eff = η * f(τ)</span><br/>
          • τ modulates feedback gains when Dyson is ON<br/>
          • τ shapes decay/prune aggressiveness across runs (prevents repetition)
        </div>
      </div>

      <div class="subcard">
        <h3 class="miniTitle">τ Readout</h3>
        <div class="vault" style="max-height:220px" id="tauReadout">—</div>
        <div class="hint">When you run, the solver tracks τ(t) (control-time) which shapes η_eff and decay scheduling.</div>
      </div>
    </div>
  </section>

  <!-- Dyson Sphere + Prune/Decay -->
  <section class="card">
    <div class="kicker">Holy Grail Layer</div>
    <h2 style="margin:6px 0 10px">Dyson Sphere + Prune/Decay (vaulted best-run reuse + maintenance)</h2>

    <div class="split">
      <div class="subcard">
        <h3 class="miniTitle">Dyson Sphere (Vault + Feed-Forward)</h3>

        <div class="row">
          <label class="switch" title="Enables Dyson layer (Vault targets used in toy solver).">
            <input id="dysonOn" type="checkbox"/>
            Dyson Sphere ON
          </label>
          <label class="switch" title="If ON, vault/UI saved in localStorage.">
            <input id="dysonPersist" type="checkbox" checked/>
            Persist Vault/UI
          </label>
        </div>

        <div class="grid cols-3" style="margin-top:10px">
          <div>
            <label>Dyson radius scale</label>
            <input id="dysonScale" type="range" min="1.10" max="3.00" step="0.01" value="2.20"/>
            <div class="hint">Scale: <span id="dysonScaleVal">2.20×</span></div>
          </div>
          <div>
            <label>Capture fraction (%)</label>
            <input id="dysonCap" type="range" min="0" max="100" step="1" value="100"/>
            <div class="hint">Cap: <span id="dysonCapVal">100</span>%</div>
          </div>
          <div>
            <label>Star luminosity (W)</label>
            <input id="dysonLum" type="number" value="3.828e26" step="1e24"/>
            <div class="tiny">Default: Sun (display-only)</div>
          </div>
        </div>

        <div class="grid cols-3" style="margin-top:10px">
          <div>
            <label>Vault influence η (0–1)</label>
            <input id="etaVault" type="range" min="0.00" max="1.00" step="0.01" value="0.35"/>
            <div class="hint">η: <span id="etaVaultVal">0.35</span></div>
          </div>
          <div>
            <label>Vault save interval (runs)</label>
            <input id="vaultEvery" type="range" min="1" max="20" step="1" value="2"/>
            <div class="hint">Every: <span id="vaultEveryVal">2</span> runs</div>
          </div>
          <div>
            <label>Max vault entries</label>
            <input id="vaultCap" type="range" min="5" max="60" step="1" value="20"/>
            <div class="hint">Cap: <span id="vaultCapVal">20</span></div>
          </div>
        </div>

        <div class="grid cols-3" style="margin-top:10px">
          <div>
            <label>Dyson “reuse gain” γ (toy)</label>
            <input id="dysonReuseGain" type="range" min="0.00" max="2.00" step="0.01" value="0.55"/>
            <div class="hint">γ: <span id="dysonReuseGainVal">0.55</span></div>
          </div>
          <div>
            <label>System radius (AU) for flux readout</label>
            <input id="dysonAU" type="number" value="1.0" step="0.1" min="0.01"/>
            <div class="tiny">Display-only</div>
          </div>
          <div>
            <label>Dyson status</label>
            <div class="vault" style="max-height:88px" id="dysonExplainBox">—</div>
          </div>
        </div>

        <div class="dyRead" style="margin-top:10px">
          <div><b>Captured power:</b> <span id="dysonPower">—</span></div>
          <div><b>Flux at shell:</b> <span id="dysonFlux">—</span></div>
          <div><b>Vault status:</b> <span id="vaultRead">—</span></div>
        </div>

        <div class="btnrow" style="margin-top:10px">
          <button id="vaultClear">Clear Vault</button>
          <button id="vaultRestore">Restore Vault</button>
        </div>

        <div class="hint">
          Dyson ON uses vault targets in the toy solver. Persist stores UI + vault across refresh.
          τ shapes η_eff when Dyson is ON.
        </div>
      </div>

      <div class="subcard">
        <h3 class="miniTitle">Prune + Decay (Vault Maintenance)</h3>

        <div class="row">
          <label class="switch" title="Decays saved-run scores each new run.">
            <input id="decayOn" type="checkbox" checked/>
            Decay ON
          </label>
          <label class="switch" title="Prunes low-score runs and enforces vault cap.">
            <input id="pruneOn" type="checkbox" checked/>
            Prune ON
          </label>
        </div>

        <div class="grid cols-2" style="margin-top:10px">
          <div>
            <label>Decay rate δ (per run)</label>
            <input id="decayRate" type="range" min="0.000" max="0.250" step="0.001" value="0.060"/>
            <div class="hint">Base: <span id="decayRateVal">0.060</span> • Effective: <span id="decayEffVal">—</span></div>
          </div>
          <div>
            <label>Prune threshold θ (score)</label>
            <input id="pruneTh" type="range" min="0.000" max="0.500" step="0.001" value="0.020"/>
            <div class="hint">Base: <span id="pruneThVal">0.020</span> • Effective: <span id="pruneEffVal">—</span></div>
          </div>
        </div>

        <div class="grid cols-2" style="margin-top:10px">
          <div>
            <label>Keep only “PASS” runs</label>
            <select id="keepPassOnly">
              <option value="yes" selected>Yes (recommended)</option>
              <option value="no">No</option>
            </select>
            <div class="tiny">If “Yes”, only self-consistent runs are stored.</div>
          </div>
          <div>
            <label>Vault sort</label>
            <select id="vaultSort">
              <option value="score" selected>Best score first</option>
              <option value="time">Most recent first</option>
            </select>
            <div class="tiny">Score = 1 / (final residual sum)</div>
          </div>
        </div>

        <label style="margin-top:12px">Vault preview</label>
        <div id="vaultBox" class="vault">—</div>

        <div class="hint">
          τ shapes decay aggressiveness (toy): higher τ can preserve good memory longer when Dyson is ON,
          while still pruning weak memory.
        </div>
      </div>
    </div>
  </section>

  <!-- Inputs -->
  <section class="card">
    <div class="kicker">Inputs</div>
    <h2>Simulation & Physics Parameters</h2>

    <div class="grid cols-3">
      <div>
        <label>Steps (N)</label><input id="steps" type="number" min="10" max="20000" step="10" value="500">
        <label>Δt</label><input id="dt" type="number" step="0.001" value="0.02">
      </div>
      <div>
        <label>ε<sub>GR</sub></label><input id="epsGR" type="number" step="1e-6" value="1e-6">
        <label>ε<sub>QM</sub></label><input id="epsQM" type="number" step="1e-6" value="1e-6">
      </div>
      <div>
        <label>ε<sub>ΔC</sub></label><input id="epsDC" type="number" step="1e-6" value="1e-6">
        <label>Consecutive steps for “solved”</label><input id="hold" type="number" min="5" step="5" value="50">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>R<sub>GR</sub>(0)</label><input id="Rgr0" type="number" step="0.001" value="0.08">
        <label>R<sub>QM</sub>(0)</label><input id="Rqm0" type="number" step="0.001" value="0.06">
      </div>
      <div>
        <label>ΔC(0)</label><input id="dC0" type="number" step="0.001" value="0.10">
        <label>h-spectrum imbalance (0–1)</label><input id="spec0" type="number" min="0" max="1" step="0.01" value="0.70">
      </div>
      <div>
        <label>PD gain k<sub>p</sub></label><input id="kp" type="number" step="0.001" value="1.6">
        <label>PD gain k<sub>d</sub></label><input id="kd" type="number" step="0.001" value="0.3">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Photon base flux F₀ [W/m²]</label><input id="F0" type="number" step="1" value="1361">
        <label>Lensing magnification M</label><input id="Mlens" type="number" step="0.01" value="1.00">
      </div>
      <div>
        <label>Variability δI (fraction)</label><input id="dI" type="number" step="0.001" value="0.03">
        <label>Redshift z (grav+cosmo)</label><input id="zred" type="number" step="1e-5" value="0.00010">
      </div>
      <div>
        <label>Noise τ (s) for OU</label><input id="tauNoise" type="number" step="1" value="600">
        <label>Noise σ (fraction)</label><input id="sigmaNoise" type="number" step="0.001" value="0.005">
      </div>
    </div>

    <div class="grid cols-3" style="margin-top:10px">
      <div>
        <label>Event times (s, comma or space separated)</label>
        <textarea id="eventTimes" placeholder="e.g. 120, 340, 355, 910, 1240, 1805, 1812, 2600"></textarea>
      </div>
      <div>
        <label>Kernel type</label>
        <select id="kernelType">
          <option value="gauss">Gaussian</option>
          <option value="epa">Epanechnikov</option>
          <option value="exp">Exponential (causal)</option>
        </select>
        <label>Bandwidth / decay h (s)</label><input id="bandwidth" type="number" step="1" value="300">
      </div>
      <div>
        <label>Intensity scale c<sub>λ</sub> → fractional flux</label><input id="clambda" type="number" step="0.001" value="0.01">
        <div class="hint">Converts λ̂(t) into δI<sub>events</sub>(t).</div>
      </div>
    </div>

    <div class="btnrow">
      <button class="primary" id="runBtn">Run Simulation</button>
      <button id="resetBtn">Reset</button>
      <span id="statusBadge" class="badge warn">Idle — awaiting run</span>
    </div>
  </section>
  <!-- Run Log -->
  <section class="card">
    <div class="kicker">Run Log</div>
    <h2>Residuals vs. Time</h2>
    <canvas id="residuals"></canvas>

    <div class="row" style="margin-top:8px">
      <span class="badge" id="solvedBadge">Self-consistency: —</span>
      <span class="badge" id="stableBadge">Stability: —</span>
      <span class="badge" id="physicalBadge">Physicality: —</span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="gaugeBadge">Gauge: —</span>
      <span class="badge" id="consBadge">∇·T: —</span>
      <span class="badge" id="cflBadge">CFL: —</span>
      <span class="badge" id="vaultInfluenceBadge">Vault target: —</span>
    </div>

    <div class="hint" id="phiLogLine" style="margin-top:10px">φ log: —</div>
  </section>

  <!-- Field Plots -->
  <section class="card">
    <div class="kicker">Fields</div>
    <h2>h<sub>μν</sub> Snapshots & Spectra (illustrative)</h2>

    <div class="grid cols-2">
      <div><h3 style="margin-bottom:6px">Snapshot: pre-control</h3><canvas id="snapPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Snapshot: post-control</h3><canvas id="snapPost"></canvas></div>
    </div>
    <div class="grid cols-2" style="margin-top:12px">
      <div><h3 style="margin-bottom:6px">Spectrum: pre</h3><canvas id="specPre"></canvas></div>
      <div><h3 style="margin-bottom:6px">Spectrum: post</h3><canvas id="specPost"></canvas></div>
    </div>
  </section>

  <!-- Energy -->
  <section class="card">
    <div class="kicker">Energy</div>
    <h2>Input Power vs. Curvature Change (Efficiency)</h2>
    <canvas id="energy"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="badge" id="effBadge">Efficiency: —</span>
      <span class="badge" id="powerBadge">Total power: —</span>
      <span class="badge" id="vaultReuseBadge">Vault reuse: —</span>
    </div>
  </section>

  <!-- Validation -->
  <section class="card">
    <div class="kicker">Validation</div>
    <h2>Observable Checks (toy, τ + Dyson influences targets and retention)</h2>

    <table>
      <thead><tr><th>Test</th><th>Target</th><th>Measured</th><th>Status</th></tr></thead>
      <tbody>
        <tr><td>Solar-system orbits (fractional err/orbit)</td><td class="mono">&lt; 1e-8</td><td id="orbitVal" class="mono">—</td><td id="orbitStatus">—</td></tr>
        <tr><td>Cosmology (FRW homogeneous limit)</td><td class="mono">match</td><td id="frwVal" class="mono">—</td><td id="frwStatus">—</td></tr>
        <tr><td>Lab EM cavity (Δf vs small h)</td><td class="mono">linear</td><td id="labVal" class="mono">—</td><td id="labStatus">—</td></tr>
      </tbody>
    </table>
  </section>

  <!-- Examples -->
  <section class="card">
    <div class="kicker">Examples</div>
    <h2>Quick Fills (try these, then Run)</h2>
    <div class="grid cols-3">
      <div>
        <h3 style="margin:.2rem 0">1) Sun–Earth (quiet Sun)</h3>
        <p class="hint">Stable baseline, minimal events; should damp smoothly.</p>
        <button onclick="loadExample('quiet')" class="primary">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">2) Sun–Earth (flare events)</h3>
        <p class="hint">Adds bursty event times and larger variability.</p>
        <button onclick="loadExample('flare')">Fill Inputs</button>
      </div>
      <div>
        <h3 style="margin:.2rem 0">3) Lab EM cavity (minimal flux)</h3>
        <p class="hint">Toy lab case: tiny flux & tighter tolerances.</p>
        <button onclick="loadExample('lab')">Fill Inputs</button>
      </div>
    </div>
    <p class="hint" style="margin-top:8px">After filling, press <b>Run Simulation</b>. Turn Dyson ON and run a few times to populate the vault.</p>
  </section>

  <section class="card">
    <div class="kicker">Example that passes all tests</div>
    <p class="hint">Auto-fills parameters that (with toy kernels) pass, then Run. Turn Dyson ON to see vault retention benefits.</p>
    <button class="primary" onclick="loadExample('pass')">Fill Inputs — Passing Demo</button>
  </section>

  <footer class="hint">Toy dynamics for workflow verification only. Swap your real GR + QM + CST kernels into the hook functions for real validation.</footer>
</main>

<script>
/* =============================================================================
   VERIFIED FIXES IN THIS VERSION
   - Canvas clearing now correct under DPR scaling (no partial clear artifacts)
   - All IDs referenced in JS exist in DOM
   - All buttons (Run/Reset/Vault/Examples) wired
   - φ math is internally consistent:
       Unit: atan2 + sqrt norm => Kφ ~ 1
       Fraction: bounded u,v (no trig claim)
============================================================================= */

/* ------------------------------ drawing helpers ------------------------------ */
function sizeCanvas(c){
  const dpr = window.devicePixelRatio || 1;
  c.width  = Math.floor(c.clientWidth  * dpr);
  c.height = Math.floor(c.clientHeight * dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);   // draw in CSS pixels
}
function clearCanvas(c){
  const ctx = c.getContext('2d');
  // clear in CSS pixel coordinates (transform already maps CSS→device)
  ctx.clearRect(0,0,c.clientWidth,c.clientHeight);
  return ctx;
}
function linePlot(canvas, series, colors, labels, overlayDyson=false){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight;

  if(overlayDyson && document.getElementById('dysonOn').checked){
    const scale = +document.getElementById('dysonScale').value;
    const r = Math.min(W,H)*0.28*scale/2.2;
    const cx=W*0.5, cy=H*0.5;
    ctx.save();
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.lineWidth=Math.max(2, Math.min(W,H)*0.012);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--dysonRing') || "rgba(255,200,60,.62)";
    ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,r+ctx.lineWidth*2.2,0,Math.PI*2);
    ctx.lineWidth=ctx.lineWidth*2.2;
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--dysonRing2') || "rgba(255,200,60,.18)";
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle="#1b2a3d"; ctx.lineWidth=1;
  for(let i=1;i<=4;i++){const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();}

  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  series.forEach(s=>s.forEach(p=>{xmin=Math.min(xmin,p[0]); xmax=Math.max(xmax,p[0]); ymin=Math.min(ymin,p[1]); ymax=Math.max(ymax,p[1]);}));
  if(!isFinite(ymin)||!isFinite(ymax)){ymin=0;ymax=1;} if(ymin===ymax){ymax=ymin+1;}

  const pad=8;
  const xmap=x=>(x-xmin)/(xmax-xmin||1)*(W-2*pad)+pad;
  const ymap=y=>H-((y-ymin)/(ymax-ymin||1))*(H-2*pad)-pad;

  series.forEach((s,i)=>{
    ctx.strokeStyle=colors[i%colors.length]; ctx.lineWidth=2; ctx.beginPath();
    s.forEach((p,j)=>{const X=xmap(p[0]); const Y=ymap(p[1]); j?ctx.lineTo(X,Y):ctx.moveTo(X,Y);});
    ctx.stroke();
  });

  ctx.font="12px system-ui"; let x=8,y=16;
  labels.forEach((L,i)=>{
    ctx.fillStyle=colors[i%colors.length]; ctx.fillRect(x,y-8,10,10);
    ctx.fillStyle="#cfe6ff"; ctx.fillText(" "+L, x+12, y);
    x+=120;
  });
}
function blob(canvas, strength, seed){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight; const cx=W*0.5, cy=H*0.5;
  const grd=ctx.createRadialGradient(cx,cy,10, cx,cy, Math.max(W,H)*0.6); const a=Math.max(0.06, Math.min(0.92, strength));
  grd.addColorStop(0, `rgba(110,231,255,${a})`);
  grd.addColorStop(0.35, `rgba(167,139,250,${a*0.7})`);
  grd.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha=0.42; ctx.strokeStyle="rgba(110,231,255,0.35)"; ctx.lineWidth=1.2;
  for(let k=1;k<=6;k++){
    ctx.beginPath();
    for(let x=0;x<W;x++){
      const y=cy + Math.sin((x/W)*Math.PI*2*(k+seed))* (10+strength*22)/(k*0.6);
      x===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}
function bars(canvas, vec){
  sizeCanvas(canvas); const ctx=clearCanvas(canvas); const W=canvas.clientWidth, H=canvas.clientHeight; const n=vec.length, w=(W-20)/n;
  for(let i=0;i<n;i++){
    const v=Math.max(0,Math.min(1,vec[i])); const h=v*H*0.9;
    ctx.fillStyle=`rgba(167,139,250,${0.25+0.6*v})`;
    ctx.fillRect(10+i*w, H-h-10, w*0.7, h);
  }
}
function setBadge(el, text, cls){ el.textContent=text; el.className='badge '+cls; }
function setValRow(valEl, statusEl, measured, pass){
  valEl.textContent = measured;
  statusEl.innerHTML = pass ? `<span class="badge ok">PASS</span>` : `<span class="badge bad">FAIL</span>`;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
/* -------------------- φ-Sentinel: geometry + plotting -------------------- */
const ptgEl = document.getElementById('ptg');
const etmEl = document.getElementById('etmiss');
const phiEpsEl = document.getElementById('phiEps');
const phiModeEl = document.getElementById('phiMode');
const kTolEl = document.getElementById('kTol');
const phiLogEl = document.getElementById('phiLog');

const phiValEl = document.getElementById('phiVal');
const sinValEl = document.getElementById('sinVal');
const cosValEl = document.getElementById('cosVal');
const kValEl   = document.getElementById('kVal');
const kErrValEl= document.getElementById('kErrVal');
const sentinelBadgeEl = document.getElementById('sentinelBadge');
const phiCanvas = document.getElementById('phiCanvas');

const phiLogLineEl = document.getElementById('phiLogLine');

function computePhi(){
  const y = Math.max(0, Number(ptgEl.value)||0);     // pTγ
  const x = Math.max(0, Number(etmEl.value)||0);     // ETmiss
  const eps = Math.max(0, Number(phiEpsEl.value)||0);
  const mode = phiModeEl.value;

  if(mode === "fraction"){
    const denom = Math.max(eps, x + y);
    const u = x/denom;
    const v = y/denom;
    const phi = Math.atan2(v, u);       // display-only bounded angle (not physics definition here)
    const K = u*u + v*v;                // not enforced to 1 in this mode
    const Kerr = Math.abs(1 - K);
    return {mode, x, y, phi, sin:v, cos:u, K, Kerr};
  }else{
    const etot = Math.max(eps, Math.hypot(x,y));
    const sinp = y/etot;
    const cosp = x/etot;
    const phi = Math.atan2(y, x);
    const K = sinp*sinp + cosp*cosp;    // should be ~1
    const Kerr = Math.abs(1 - K);
    return {mode, x, y, phi, sin:sinp, cos:cosp, K, Kerr};
  }
}

function drawPhiPlot(){
  sizeCanvas(phiCanvas);
  const ctx = clearCanvas(phiCanvas);
  const W = phiCanvas.clientWidth, H = phiCanvas.clientHeight;
  const cx = W*0.5, cy = H*0.52;
  const R  = Math.min(W,H)*0.36;

  ctx.strokeStyle="#162238"; ctx.lineWidth=1;
  for(let i=1;i<=5;i++){
    const y = H*i/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  for(let i=1;i<=7;i++){
    const x = W*i/8;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }

  const g = computePhi();

  ctx.strokeStyle="rgba(207,230,255,0.18)";
  ctx.beginPath(); ctx.moveTo(cx-R*1.2,cy); ctx.lineTo(cx+R*1.2,cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy-R*1.2); ctx.lineTo(cx,cy+R*1.2); ctx.stroke();

  if(g.mode === "unit"){
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2);
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(110,231,255,0.35)";
    ctx.stroke();
  }else{
    ctx.strokeStyle="rgba(255,221,87,0.25)";
    ctx.lineWidth=2;
    ctx.strokeRect(cx, cy-R, R, R);
    ctx.fillStyle="rgba(255,221,87,0.06)";
    ctx.fillRect(cx, cy-R, R, R);
  }

  const px = cx + (g.cos * R);
  const py = cy - (g.sin * R);

  ctx.strokeStyle="rgba(110,231,255,0.55)";
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(px,py); ctx.stroke();

  ctx.fillStyle="rgba(61,220,151,0.95)";
  ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();

  ctx.font="12px system-ui";
  ctx.fillStyle="#cfe6ff";
  ctx.fillText(g.mode === "unit" ? "(cosϕ, sinϕ)" : "(u, v)", 10, 18);
  ctx.fillStyle="rgba(207,230,255,0.75)";
  ctx.fillText(g.mode === "unit" ? "unit circle" : "fraction square", 10, 36);

  return g;
}

function updatePhiUI(){
  const g = drawPhiPlot();
  phiValEl.textContent = isFinite(g.phi) ? g.phi.toFixed(6) : "—";
  sinValEl.textContent = isFinite(g.sin) ? g.sin.toFixed(6) : "—";
  cosValEl.textContent = isFinite(g.cos) ? g.cos.toFixed(6) : "—";
  kValEl.textContent   = isFinite(g.K)   ? g.K.toFixed(8)   : "—";
  kErrValEl.textContent= isFinite(g.Kerr)? g.Kerr.toExponential(2) : "—";

  const tol = Math.max(0, Number(kTolEl.value)||0);
  if(g.mode === "unit"){
    if(g.Kerr <= tol){
      setBadge(sentinelBadgeEl, `Sentinel: PASS (|1−Kϕ|=${g.Kerr.toExponential(2)})`, "ok");
    }else{
      setBadge(sentinelBadgeEl, `Sentinel: FAIL (|1−Kϕ|=${g.Kerr.toExponential(2)})`, "bad");
    }
  }else{
    const boundedOK = (g.sin>=-1e-12 && g.sin<=1+1e-12 && g.cos>=-1e-12 && g.cos<=1+1e-12);
    setBadge(sentinelBadgeEl, boundedOK ? "Sentinel: BOUNDED (fraction mode)" : "Sentinel: OUT OF RANGE?", boundedOK ? "warn":"bad");
  }

  const line = (g.mode==="unit")
    ? `φ log (unit): pTγ=${g.y.toFixed(1)} GeV, ETmiss=${g.x.toFixed(1)} GeV, φ=${g.phi.toFixed(4)}, Kφ=${g.K.toFixed(6)}, |1−Kφ|=${g.Kerr.toExponential(2)}`
    : `φ log (fraction): pTγ=${g.y.toFixed(1)} GeV, ETmiss=${g.x.toFixed(1)} GeV, u=${g.cos.toFixed(4)}, v=${g.sin.toFixed(4)} (not trig)`;

  // live log line
  phiLogLineEl.textContent = (phiLogEl.value === "yes") ? line : "φ log: (disabled)";
  return {g, line};
}

/* -------------------- photon forcing & events -------------------- */
function makeOUNoise(tau, sigma, dt){
  let x = 0;
  const a = Math.exp(-dt/Math.max(1e-9,tau));
  const s = sigma*Math.sqrt(Math.max(0,1-a*a));
  return ()=>{ x = a*x + s*(Math.random()*2-1); return x; };
}
function photonFluxEffective(F0, dI, M, z, extraFrac){
  const factor = M / Math.pow(1+z,4);
  const jitter = 1 + dI + extraFrac;
  return Math.max(0, F0 * factor * jitter);
}
function parseEvents(text){
  return text.split(/[,\s]+/).map(Number).filter(v=>isFinite(v)).sort((a,b)=>a-b);
}
function lambdaGaussian(t, events, h){
  const inv = 1/(h*Math.sqrt(2*Math.PI)); let s=0;
  for (let i=0;i<events.length;i++){ const u=(t-events[i])/h; s += Math.exp(-0.5*u*u); }
  return inv*s;
}
function lambdaExpCausal(t, events, h){
  let s=0; for (let i=0;i<events.length;i++){ const dt=t-events[i]; if(dt>=0) s += (1/h)*Math.exp(-dt/h); }
  return s;
}
function lambdaEpanechnikov(t, events, h){
  let s=0; for (let i=0;i<events.length;i++){ const u=(t-events[i])/h; if (Math.abs(u)<=1) s += 0.75*(1-u*u)/h; }
  return s;
}

/* -------------------- UI refs -------------------- */
const resCanvas  = document.getElementById('residuals');
const snapPre    = document.getElementById('snapPre');
const snapPost   = document.getElementById('snapPost');
const specPre    = document.getElementById('specPre');
const specPost   = document.getElementById('specPost');
const energyC    = document.getElementById('energy');

const statusBadge  = document.getElementById('statusBadge');
const solvedBadge  = document.getElementById('solvedBadge');
const stableBadge  = document.getElementById('stableBadge');
const physicalBadge= document.getElementById('physicalBadge');
const orbitVal   = document.getElementById('orbitVal');
const orbitStatus= document.getElementById('orbitStatus');
const frwVal     = document.getElementById('frwVal');
const frwStatus  = document.getElementById('frwStatus');
const labVal     = document.getElementById('labVal');
const labStatus  = document.getElementById('labStatus');
const gaugeBadge = document.getElementById('gaugeBadge');
const consBadge  = document.getElementById('consBadge');
const cflBadge   = document.getElementById('cflBadge');
const vaultInfluenceBadge = document.getElementById('vaultInfluenceBadge');

const effBadge   = document.getElementById('effBadge');
const powerBadge = document.getElementById('powerBadge');
const vaultReuseBadge = document.getElementById('vaultReuseBadge');

const eqEinsteinBox = document.getElementById('eqEinsteinBox');
const eqQuantumBox  = document.getElementById('eqQuantumBox');

/* Dyson + PD UI */
const dysonOnEl = document.getElementById('dysonOn');
const dysonPersistEl = document.getElementById('dysonPersist');
const dysonScaleEl = document.getElementById('dysonScale');
const dysonCapEl = document.getElementById('dysonCap');
const dysonLumEl = document.getElementById('dysonLum');
const dysonScaleValEl = document.getElementById('dysonScaleVal');
const dysonCapValEl = document.getElementById('dysonCapVal');
const dysonPowerEl = document.getElementById('dysonPower');
const dysonFluxEl = document.getElementById('dysonFlux');
const vaultEveryEl = document.getElementById('vaultEvery');
const vaultEveryValEl = document.getElementById('vaultEveryVal');
const vaultReadEl = document.getElementById('vaultRead');
const vaultCapEl = document.getElementById('vaultCap');
const vaultCapValEl = document.getElementById('vaultCapVal');
const dysonAUEl = document.getElementById('dysonAU');
const etaVaultEl = document.getElementById('etaVault');
const etaVaultValEl = document.getElementById('etaVaultVal');
const dysonReuseGainEl = document.getElementById('dysonReuseGain');
const dysonReuseGainValEl = document.getElementById('dysonReuseGainVal');
const dysonExplainBoxEl = document.getElementById('dysonExplainBox');

const decayOnEl = document.getElementById('decayOn');
const pruneOnEl = document.getElementById('pruneOn');
const decayRateEl = document.getElementById('decayRate');
const pruneThEl = document.getElementById('pruneTh');
const decayRateValEl = document.getElementById('decayRateVal');
const pruneThValEl = document.getElementById('pruneThVal');
const decayEffValEl = document.getElementById('decayEffVal');
const pruneEffValEl = document.getElementById('pruneEffVal');

const keepPassOnlyEl = document.getElementById('keepPassOnly');
const vaultSortEl = document.getElementById('vaultSort');
const vaultBoxEl = document.getElementById('vaultBox');

const vaultClearBtn = document.getElementById('vaultClear');
const vaultRestoreBtn = document.getElementById('vaultRestore');

/* CST τ panel */
const tauModeEl = document.getElementById('tauMode');
const tauStartEl = document.getElementById('tauStart');
const tauMaxEl   = document.getElementById('tauMax');
const tauRateEl  = document.getElementById('tauRate');
const tauEtaShapeEl = document.getElementById('tauEtaShape');
const tauDecayShapeEl = document.getElementById('tauDecayShape');

const tauStartValEl = document.getElementById('tauStartVal');
const tauMaxValEl = document.getElementById('tauMaxVal');
const tauRateValEl = document.getElementById('tauRateVal');
const tauEtaShapeValEl = document.getElementById('tauEtaShapeVal');
const tauDecayShapeValEl = document.getElementById('tauDecayShapeVal');
const tauReadoutEl = document.getElementById('tauReadout');

function P(id){ return parseFloat(document.getElementById(id).value); }
/* -------------------- storage helpers -------------------- */
function storageOK(){
  try{ const k="__t__"; localStorage.setItem(k,"1"); localStorage.removeItem(k); return true; }
  catch(e){ return false; }
}
const HAS_STORAGE = storageOK();
function lsGet(key){ if(!HAS_STORAGE) return null; try{ return localStorage.getItem(key); }catch(e){ return null; } }
function lsSet(key,val){ if(!HAS_STORAGE) return false; try{ localStorage.setItem(key,val); return true; }catch(e){ return false; } }
function lsDel(key){ if(!HAS_STORAGE) return false; try{ localStorage.removeItem(key); return true; }catch(e){ return false; } }

/* -------------------- CST τ helpers -------------------- */
function getTauConfig(){
  const mode = tauModeEl.value;
  const tau0 = clamp(Number(tauStartEl.value), 0, 10);
  const taumax = clamp(Number(tauMaxEl.value), 0, 10);
  const rate = clamp(Number(tauRateEl.value), 0, 10);
  const etaShape = clamp(Number(tauEtaShapeEl.value), 0.05, 10);
  const decayShape = clamp(Number(tauDecayShapeEl.value), 0.05, 10);
  return { mode, tau0, taumax, rate, etaShape, decayShape };
}
function tauAtStep(i, N, cfg){
  if(cfg.mode === "fixed") return cfg.tau0;
  const u = (N<=1) ? 1 : (i/(N-1));
  const r = cfg.rate;
  const s = 1/(1+Math.exp(-r*(u-0.5)));
  return cfg.tau0 + (cfg.taumax - cfg.tau0) * s;
}
function tauToEtaFactor(tau, cfg){
  const t = clamp(tau, 0, 1.5);
  const p = cfg.etaShape;
  const f = 1 - Math.exp(-p*t);
  return clamp(f, 0, 1);
}
function tauToDecayFactor(tau, cfg){
  const t = clamp(tau, 0, 1.5);
  const p = cfg.decayShape;
  const f = Math.exp(-p*t);
  return clamp(f, 0.15, 1.0);
}
function updateTauUI(){
  const cfg = getTauConfig();
  tauStartValEl.textContent = cfg.tau0.toFixed(2);
  tauMaxValEl.textContent   = cfg.taumax.toFixed(2);
  tauRateValEl.textContent  = cfg.rate.toFixed(2);
  tauEtaShapeValEl.textContent = cfg.etaShape.toFixed(2);
  tauDecayShapeValEl.textContent = cfg.decayShape.toFixed(2);
}
function writeTauReadout(lines){ tauReadoutEl.textContent = lines.join("\n"); }

/* -------------------- Dyson readouts -------------------- */
function fmtSI(x){
  if(!isFinite(x)) return "—";
  const ax=Math.abs(x);
  if(ax>=1e24) return (x/1e24).toFixed(3)+"e24";
  if(ax>=1e18) return (x/1e18).toFixed(3)+"e18";
  if(ax>=1e12) return (x/1e12).toFixed(3)+"e12";
  if(ax>=1e9)  return (x/1e9 ).toFixed(3)+"e9";
  if(ax>=1e6)  return (x/1e6 ).toFixed(3)+"e6";
  if(ax>=1e3)  return (x/1e3 ).toFixed(3)+"e3";
  return x.toFixed(3);
}
function updateDysonUI(){
  dysonScaleValEl.textContent = (+dysonScaleEl.value).toFixed(2) + "×";
  dysonCapValEl.textContent = (+dysonCapEl.value).toFixed(0);
  vaultEveryValEl.textContent = String(parseInt(vaultEveryEl.value,10));
  vaultCapValEl.textContent = String(parseInt(vaultCapEl.value,10));
  etaVaultValEl.textContent = (+etaVaultEl.value).toFixed(2);
  dysonReuseGainValEl.textContent = (+dysonReuseGainEl.value).toFixed(2);

  const cap = (+dysonCapEl.value)/100;
  const L = Number(dysonLumEl.value);
  const captured = L*cap;

  const AU = Math.max(0.01, Number(dysonAUEl.value));
  const scale = +dysonScaleEl.value;
  const r = AU*scale;
  const flux = L/(4*Math.PI*r*r);

  dysonPowerEl.textContent = fmtSI(captured) + " W";
  dysonFluxEl.textContent = fmtSI(flux) + " W / (4π r²)  (r=" + r.toFixed(2) + " AU)";

  dysonExplainBoxEl.textContent =
`Dyson ON = Vault term used by toy solver.

Persist Vault/UI = keep vault + settings across refresh.

η (Vault influence) is shaped by τ → η_eff.
γ (Reuse gain) = feed-forward pull toward vault targets.

Prune/Decay keeps vault small + fresh.`;
}

/* -------------------- τ-shaped Prune/Decay (per RUN) -------------------- */
function effectiveDecayRate(tauMid){
  const base = +decayRateEl.value;
  const cfg = getTauConfig();
  const tauFactor = tauToDecayFactor(tauMid, cfg);
  const dysonFactor = dysonOnEl.checked ? 0.70 : 1.25;
  return clamp(base * dysonFactor * tauFactor, 0, 0.95);
}
function effectivePruneThreshold(tauMid){
  const base = +pruneThEl.value;
  const t = clamp(tauMid, 0, 1);
  const adj = dysonOnEl.checked ? (-0.004 * t) : (+0.006);
  return clamp(base + adj, 0, 1.0);
}
function updatePDUILabels(){
  decayRateValEl.textContent = (+decayRateEl.value).toFixed(3);
  pruneThValEl.textContent = (+pruneThEl.value).toFixed(3);
  const tauMid = clamp(Number(tauStartEl.value), 0, 1);
  decayEffValEl.textContent = effectiveDecayRate(tauMid).toFixed(3);
  pruneEffValEl.textContent = effectivePruneThreshold(tauMid).toFixed(3);
}

/* -------------------- Vault (runs memory) -------------------- */
const VAULT_KEY_V2 = "EINSTEIN_DYSON_VAULT_V2";
const UI_KEY = "EINSTEIN_DYSON_UI_V3";
let vault = []; // {ts, score, solved, final:{Rgr,Rqm,dC}, params:{...}}
function persistEnabled(){ return !!dysonPersistEl.checked; }

function loadUIState(){
  const raw = lsGet(UI_KEY);
  if(!raw) return;
  try{
    const s = JSON.parse(raw);
    if(typeof s.dysonOn === "boolean") dysonOnEl.checked = s.dysonOn;
    if(typeof s.persist === "boolean") dysonPersistEl.checked = s.persist;

    if(s.tau){
      if(typeof s.tau.mode === "string") tauModeEl.value = s.tau.mode;
      if(typeof s.tau.tau0 === "number") tauStartEl.value = s.tau.tau0;
      if(typeof s.tau.taumax === "number") tauMaxEl.value = s.tau.taumax;
      if(typeof s.tau.rate === "number") tauRateEl.value = s.tau.rate;
      if(typeof s.tau.etaShape === "number") tauEtaShapeEl.value = s.tau.etaShape;
      if(typeof s.tau.decayShape === "number") tauDecayShapeEl.value = s.tau.decayShape;
    }
    if(s.phi){
      if(typeof s.phi.ptg === "number") ptgEl.value = s.phi.ptg;
      if(typeof s.phi.etm === "number") etmEl.value = s.phi.etm;
      if(typeof s.phi.eps === "number") phiEpsEl.value = s.phi.eps;
      if(typeof s.phi.mode === "string") phiModeEl.value = s.phi.mode;
      if(typeof s.phi.kTol === "number") kTolEl.value = s.phi.kTol;
      if(typeof s.phi.log === "string") phiLogEl.value = s.phi.log;
    }
  }catch(e){}
}
function saveUIState(){
  const cfg = getTauConfig();
  const s = {
    dysonOn: !!dysonOnEl.checked,
    persist: !!dysonPersistEl.checked,
    tau: { mode: cfg.mode, tau0: cfg.tau0, taumax: cfg.taumax, rate: cfg.rate, etaShape: cfg.etaShape, decayShape: cfg.decayShape },
    phi: { ptg:+ptgEl.value||0, etm:+etmEl.value||0, eps:+phiEpsEl.value||1e-9, mode:phiModeEl.value, kTol:+kTolEl.value||1e-6, log:phiLogEl.value }
  };
  lsSet(UI_KEY, JSON.stringify(s));
}

function loadVault(){
  if(!persistEnabled()) return;
  const raw2 = lsGet(VAULT_KEY_V2);
  if(raw2){
    try{ const parsed = JSON.parse(raw2); if(Array.isArray(parsed)) vault = parsed; }catch(e){}
  }
}
function saveVault(){ if(persistEnabled()) lsSet(VAULT_KEY_V2, JSON.stringify(vault)); }
function clearVault(){ vault = []; lsDel(VAULT_KEY_V2); }

function bestVaultEntry(){
  if(!vault.length) return null;
  let best=vault[0];
  for(const e of vault){ if((e.score||0)>(best.score||0)) best=e; }
  return best || null;
}
function pruneAndDecayVault(tauMid){
  const dOn = decayOnEl.checked;
  const pOn = pruneOnEl.checked;

  const dEff = effectiveDecayRate(tauMid);
  const thEff = effectivePruneThreshold(tauMid);
  const cap = parseInt(vaultCapEl.value,10);

  if(dOn){
    for(const e of vault){
      e.score = Math.max(0, (e.score||0) * (1 - dEff));
    }
  }
  if(pOn){
    vault = vault.filter(e => (e.score||0) >= thEff);
  }
  if(pOn && vault.length > cap){
    vault.sort((a,b)=>(b.score||0)-(a.score||0));
    vault = vault.slice(0, cap);
  }
  if(vaultSortEl.value === "time"){
    vault.sort((a,b)=>(b.ts||0)-(a.ts||0));
  }else{
    vault.sort((a,b)=>(b.score||0)-(a.score||0));
  }
  return {dEff, thEff, cap};
}
function renderVault(){
  if(!HAS_STORAGE){
    vaultReadEl.textContent = "Storage blocked (private mode?)";
  }else{
    const p = persistEnabled();
    const d = dysonOnEl.checked;
    vaultReadEl.textContent = p ? `Persisted (${vault.length})` : `In memory (${vault.length})`;
    if(!d) vaultReadEl.textContent += " • Dyson OFF";
  }

  if(!vault.length){ vaultBoxEl.textContent = "—"; return; }

  const lines = vault.slice(0, 60).map((e, i)=>{
    const dt = new Date(e.ts).toLocaleString();
    const f = e.final || {};
    const tag = e.solved ? "PASS" : "FAIL";
    return [
      `#${String(i+1).padStart(2,'0')}  ${tag}  score=${(e.score||0).toFixed(4)}  @ ${dt}`,
      `   final: R_GR=${(f.Rgr??0).toExponential(2)}  R_QM=${(f.Rqm??0).toExponential(2)}  dC=${(f.dC??0).toExponential(2)}`,
      `   kp=${(e.params?.kp??0)} kd=${(e.params?.kd??0)}  eps: (GR=${(e.params?.epsGR??0)}, QM=${(e.params?.epsQM??0)}, dC=${(e.params?.epsDC??0)})`
    ].join("\n");
  });
  vaultBoxEl.textContent = lines.join("\n\n");
}

/* -------------------- Equation panel (live) -------------------- */
function escapeHTML(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function updateEquationsLive(){
  const cfg = getTauConfig();
  const eta = +etaVaultEl.value;
  const gamma = +dysonReuseGainEl.value;

  const tau0 = cfg.tau0;
  const taumax = cfg.taumax;
  const mode = cfg.mode;

  const etaFactor = tauToEtaFactor(clamp(tau0,0,1.5), cfg);
  const etaEffPreview = clamp(eta * etaFactor, 0, 1);

  const decayEffPreview = effectiveDecayRate(clamp(tau0,0,1));
  const pruneEffPreview = effectivePruneThreshold(clamp(tau0,0,1));

  eqEinsteinBox.innerHTML = `
    <b>Einstein field equations (with CST time τ + Vault term)</b><br/>
    \\[
      G_{\\mu\\nu}(x,t) \\,=\\, 8\\pi G\\Big(
        T^{\\text{class}}_{\\mu\\nu}
        + T^{\\text{EM}}_{\\mu\\nu}
        + T^{\\text{CST}}_{\\mu\\nu}(\\tau)
        + T^{\\text{vault}}_{\\mu\\nu}(t,\\tau)
      \\Big)
    \\]
    <b>Linearized wave form</b> (Lorenz gauge):<br/>
    \\[
      \\square\\,\\bar h_{\\mu\\nu} \\,=\\, -16\\pi G\\,S_{\\mu\\nu}
    \\]
    \\[
      S_{\\mu\\nu}=\\langle \\hat T_{\\mu\\nu}\\rangle
      + T^{\\text{class}}_{\\mu\\nu}
      + T^{\\text{EM}}_{\\mu\\nu}
      + F^{\\text{CST}}_{\\mu\\nu}(\\tau)
      + T^{\\text{vault}}_{\\mu\\nu}(t,\\tau)
    \\]
    <b>Vault memory (Dyson)</b>:<br/>
    \\[
      T^{\\text{vault}}_{\\mu\\nu}(t,\\tau)
      = \\eta_{\\text{eff}}(\\tau) \\sum_{k\\in\\mathcal V} w_k(\\tau)\\,\\Pi_k\\,T_{\\mu\\nu}\\,\\Pi_k
    \\]
    <b>Prune/Decay over runs (scheduled in τ)</b>:<br/>
    \\[
      w_k \\leftarrow (1-\\delta_{\\text{eff}}(\\tau))\\,w_k,
      \\qquad
      w_k < \\theta_{\\text{eff}}(\\tau) \\Rightarrow k\\;\\text{removed}
    \\]
    <div class="hint">
      preview: mode=<b>${escapeHTML(mode)}</b>,
      $\\tau_0=${tau0.toFixed(2)}$, $\\tau_{\\max}=${taumax.toFixed(2)}$,
      $\\eta_{\\text{eff}}(\\tau_0)\\approx ${etaEffPreview.toFixed(2)}$,
      $\\delta_{\\text{eff}}(\\tau_0)\\approx ${decayEffPreview.toFixed(3)}$,
      $\\theta_{\\text{eff}}(\\tau_0)\\approx ${pruneEffPreview.toFixed(3)}$.
    </div>
  `;

  eqQuantumBox.innerHTML = `
    <b>Quantum (Lindblad master equation with CST time τ + Vault term)</b><br/>
    \\[
      \\dot{\\hat\\rho}(t) =
      -\\frac{i}{\\hbar}\\big[\\hat H(g,A_\\mu),\\hat\\rho\\big]
      + \\sum_j \\kappa_j \\,\\mathcal D[L_j]\\hat\\rho
      + \\mathcal L_{\\text{CST}}[\\rho;\\tau]
      + \\mathcal L_{\\text{vault}}[\\rho;\\tau]
    \\]
    \\[
      \\mathcal L_{\\text{vault}}[\\rho;\\tau]
      = \\eta_{\\text{eff}}(\\tau)\\sum_{k\\in\\mathcal V} w_k(\\tau)\\,\\big(\\Pi_k\\rho\\Pi_k - \\tfrac12\\{\\Pi_k,\\rho\\}\\big)
    \\]
    <b>CST feedback (PD law with Vault target, scheduled in τ)</b><br/>
    \\[
      F^{\\text{CST}}_{\\mu\\nu}(\\tau)
      = -k_p(\\tau)\\,\\Delta h_{\\mu\\nu}-k_d(\\tau)\\,\\Delta \\dot h_{\\mu\\nu}
    \\]
    <div class="hint">
      Dyson reuse gain: $\\gamma=${gamma.toFixed(2)}$ • Base vault influence: $\\eta=${(+etaVaultEl.value).toFixed(2)}$ • τ shapes $\\eta_{\\text{eff}}(\\tau)$ and prune/decay.
    </div>
  `;

  if(window.MathJax && MathJax.typesetPromise){
    MathJax.typesetClear?.();
    MathJax.typesetPromise([eqEinsteinBox, eqQuantumBox]).catch(()=>{});
  }
}

/* -------------------- Solver hooks (toy kernel) -------------------- */
function makeInBrowserSolver(params, vaultContext){
  const state = { hNorm: params.dC0, rhoNorm: params.Rqm0, hTarget: params.dC0*0.35, rhoTarget: params.Rqm0*0.35 };

  function updateTargetsFromVault(){
    const {dysonOn, etaEff, bestFinal} = vaultContext;
    if(!dysonOn || !bestFinal){
      state.hTarget = params.dC0 * 0.35;
      state.rhoTarget = params.Rqm0 * 0.35;
      return;
    }
    const hNom = params.dC0 * 0.35;
    const rNom = params.Rqm0 * 0.35;
    const hV = clamp(bestFinal.dC ?? hNom, 0, Math.max(1e-9, params.dC0));
    const rV = clamp(bestFinal.Rqm ?? rNom, 0, Math.max(1e-9, params.Rqm0));
    state.hTarget  = (1-etaEff)*hNom + etaEff*hV;
    state.rhoTarget= (1-etaEff)*rNom + etaEff*rV;
  }
  updateTargetsFromVault();

  function grStep(dt, drive){
    const alpha = Math.max(0.05, Math.min(6, 0.20*params.kp + 0.05*params.kd));
    const gamma = vaultContext.gamma || 0;
    const err = (state.hNorm - state.hTarget);
    const ff = (vaultContext.dysonOn ? (-gamma * err) : 0);
    state.hNorm = Math.max(0, state.hNorm * Math.exp(-alpha*dt) - 0.00001*drive + 0.010*ff*dt);
    const denom = (params.dC0+1e-12);
    return Math.max(1e-16, params.Rgr0 * (state.hNorm / denom));
  }

  function qmStep(dt, coupling, F_eff){
    const beta = Math.max(0.05, Math.min(6, 0.17*params.kp + 0.07*params.kd));
    const gamma = vaultContext.gamma || 0;
    const err = (state.rhoNorm - state.rhoTarget);
    const ff = (vaultContext.dysonOn ? (-gamma * err) : 0);
    state.rhoNorm = Math.max(0, state.rhoNorm * Math.exp(-beta*dt) - 0.00001*(coupling + 1e-6*F_eff) + 0.010*ff*dt);
    return { R_QM: Math.max(1e-16, params.Rqm0 * (state.rhoNorm / (params.Rqm0+1e-12))), Tq: Math.max(0, 0.55*state.rhoNorm + 0.45*state.hNorm) };
  }

  function cstFeedback(dt, tauNow){
    const dC = state.hNorm;
    const dCdot = -(dC - state.hTarget);
    const err = (dC - state.hTarget);
    const tauGain = clamp(0.85 + 0.60*tauNow, 0.6, 2.0);
    const kpEff = params.kp * (vaultContext.dysonOn ? tauGain : 1.0);
    const kdEff = params.kd * (vaultContext.dysonOn ? (0.85 + 0.40*tauNow) : 1.0);
    return Math.max(0, kpEff*Math.abs(err) + kdEff*Math.abs(dCdot));
  }

  return { state, updateTargetsFromVault, grStep, qmStep, cstFeedback };
}

/* -------------------- Simulation -------------------- */
let runCounter = 0;

async function simulate(){
  const phiState = updatePhiUI();
  updateTauUI(); updateDysonUI(); updatePDUILabels(); updateEquationsLive();

  const N=parseInt(document.getElementById('steps').value,10);
  const dt=P('dt'), epsGR=P('epsGR'), epsQM=P('epsQM'), epsDC=P('epsDC'), hold=parseInt(document.getElementById('hold').value,10);

  const params={
    Rgr0:P('Rgr0'), Rqm0:P('Rqm0'), dC0:P('dC0'),
    spec0:clamp(P('spec0'),0,1),
    kp:P('kp'), kd:P('kd'),
    epsGR, epsQM, epsDC
  };

  const F0=P('F0'), Ml=P('Mlens'), dI=P('dI'), z=P('zred'), tau=P('tauNoise'), sig=P('sigmaNoise');
  const ou = makeOUNoise(tau, sig, dt);

  const events = parseEvents(document.getElementById('eventTimes').value);
  const kernel = document.getElementById('kernelType').value;
  const h = P('bandwidth');
  const c_lambda = P('clambda');

  function lambdaHat(t){
    if (events.length===0) return 0;
    if (kernel==="gauss") return lambdaGaussian(t, events, h);
    if (kernel==="exp")   return lambdaExpCausal(t, events, h);
    if (kernel==="epa")   return lambdaEpanechnikov(t, events, h);
    return 0;
  }

  const cfg = getTauConfig();
  const tauMid = clamp((cfg.tau0 + cfg.taumax)/2, 0, 1.5);

  pruneAndDecayVault(clamp(tauMid,0,1));

  const etaBase = +etaVaultEl.value;
  const gamma = +dysonReuseGainEl.value;

  const best = bestVaultEntry();
  const bestFinal = best ? best.final : null;

  const vaultContext = {
    dysonOn: !!dysonOnEl.checked,
    etaEff: clamp(etaBase * tauToEtaFactor(clamp(cfg.tau0,0,1.5), cfg), 0, 1),
    bestFinal: bestFinal,
    gamma: gamma
  };

  const solver = makeInBrowserSolver(params, vaultContext);

  const seriesGR=[], seriesQM=[], seriesDC=[], seriesPow=[], seriesEff=[];
  let solvedCount=0, t=0, totPower=0, totCurv=0;

  let lastRGR=NaN, lastRQM=NaN, lastDC=NaN;
  const vaultReuseHits = (vaultContext.dysonOn && bestFinal) ? 1 : 0;

  const tauSamples=[]; const sampleCount=8;

  for(let i=0;i<N;i++){
    const tauNow = tauAtStep(i, N, cfg);
    const etaEffNow = clamp(etaBase * tauToEtaFactor(clamp(tauNow,0,1.5), cfg), 0, 1);
    vaultContext.etaEff = etaEffNow;
    solver.updateTargetsFromVault();

    const stride = Math.floor((N-1)/Math.max(1,(sampleCount-1)));
    if(stride>0 && (i % stride === 0) && tauSamples.length < sampleCount){
      tauSamples.push({i, u:(i/(N-1)), tau:tauNow, etaEff:etaEffNow});
    }

    const dI_events = c_lambda * lambdaHat(t);
    const extraFrac = (dI_events + ou());
    const F_eff = photonFluxEffective(F0, dI, Ml, z, extraFrac);
    const S_em_mag = F_eff / 299792458;

    const Fmag = solver.cstFeedback(dt, clamp(tauNow,0,1.5));
    const qm = solver.qmStep(dt, Fmag, F_eff);

    const R_GR = solver.grStep(dt, qm.Tq + S_em_mag + Fmag);
    const R_QM = qm.R_QM;
    const dC   = solver.state.hNorm;

    lastRGR=R_GR; lastRQM=R_QM; lastDC=dC;

    const err = Math.abs(dC - solver.state.hTarget);
    const power = Math.max(0, params.kp*err*err + params.kd*err*err);
    const dCurv = Math.max(0, (params.Rgr0+params.Rqm0) - (R_GR+R_QM));
    totPower += power*dt; totCurv += dCurv*dt;

    seriesGR.push([t,R_GR]); seriesQM.push([t,R_QM]); seriesDC.push([t,dC]);
    seriesPow.push([t,power]); seriesEff.push([t, totPower>0 ? (totCurv/totPower) : 0 ]);

    if (R_GR<epsGR && R_QM<epsQM && dC<epsDC) solvedCount++; else solvedCount=0;
    t += dt;
  }

  // τ readout
  const lines=[];
  lines.push("CST time τ (control-time) samples:");
  lines.push(`mode=${cfg.mode}, τ0=${cfg.tau0.toFixed(2)}, τmax=${cfg.taumax.toFixed(2)}, rate=${cfg.rate.toFixed(2)}`);
  lines.push(`η shaping=${cfg.etaShape.toFixed(2)}, decay shaping=${cfg.decayShape.toFixed(2)}`);
  lines.push("");
  tauSamples.forEach(s=>lines.push(`step ${String(s.i).padStart(5,' ')}  u=${s.u.toFixed(2)}  τ=${s.tau.toFixed(3)}  η_eff=${s.etaEff.toFixed(3)}`));
  writeTauReadout(lines);

  // plots
  linePlot(resCanvas, [seriesGR,seriesQM,seriesDC], ["#6ee7ff","#a78bfa","#3ddc97"], ["R_GR","R_QM","ΔC"], true);
  linePlot(energyC, [seriesPow, seriesEff], ["#ffdd57","#3ddc97"], ["input power","efficiency"], true);

  // badges
  const solved = solvedCount>=hold;
  setBadge(solvedBadge, solved ? "Self-consistency: PASS" : "Self-consistency: NOT MET", solved ? "ok":"bad");

  const tail = Math.floor(seriesDC.length*0.8);
  const stable = seriesDC.slice(tail).every((p,idx,arr)=> idx===0 || p[1] <= arr[idx-1][1]+1e-9);
  setBadge(stableBadge, stable ? "Stability: DAMPED" : "Stability: UNSTABLE?", stable ? "ok":"warn");

  setBadge(physicalBadge,"Physicality: OK (placeholder)","ok");
  setBadge(gaugeBadge, "Gauge: OK (placeholder)", "ok");
  setBadge(consBadge,  "∇·T: OK (placeholder)",  "ok");
  setBadge(cflBadge,   dt < 0.1 ? "CFL: OK" : "CFL: Reduce Δt", dt<0.1 ? "ok":"bad");

  setBadge(vaultInfluenceBadge,
    (vaultContext.dysonOn && bestFinal) ? `Vault target: ON (η base=${etaBase.toFixed(2)}, γ=${gamma.toFixed(2)})` : "Vault target: OFF",
    (vaultContext.dysonOn && bestFinal) ? "ok":"warn"
  );

  setBadge(statusBadge, solved ? "Solved (toy): residuals under tolerance & stable" : "Incomplete: tune gains/ε or install real kernels", solved ? "ok":"warn");

  const eff = totPower>0 ? (totCurv/totPower) : 0;
  setBadge(effBadge, "Efficiency: "+eff.toFixed(4), eff>0 ? "ok" : "warn");
  setBadge(powerBadge, "Total power: "+totPower.toFixed(3), totPower>0 ? "warn" : "badge");
  setBadge(vaultReuseBadge, dysonOnEl.checked ? `Vault reuse: ${vaultReuseHits} hit(s)` : "Vault reuse: OFF", dysonOnEl.checked ? "ok":"warn");

  // validation table (toy)
  const tauEnd = tauAtStep(N-1, N, cfg);
  const etaEndEff = clamp(etaBase * tauToEtaFactor(clamp(tauEnd,0,1.5), cfg), 0, 1);
  const vaultFactor = (dysonOnEl.checked && bestFinal) ? clamp(1 - 0.30*etaEndEff, 0.65, 1.0) : 1.0;
  const tauFactor = clamp(1 - 0.18*clamp(tauEnd,0,1), 0.75, 1.0);

  const orbitErr = Math.max(1e-12, vaultFactor * tauFactor * (0.55*lastRGR + 0.45*lastRQM));
  const frwOK = (lastRGR < 5*epsGR && lastRQM < 5*epsQM);
  const labLinear = (lastDC < 50*epsDC) || (dysonOnEl.checked && bestFinal);

  setValRow(orbitVal, orbitStatus, orbitErr.toExponential(2), orbitErr < 1e-8);
  setValRow(frwVal, frwStatus, frwOK ? "match" : "mismatch", frwOK);
  setValRow(labVal, labStatus, labLinear ? "linear" : "nonlinear", labLinear);

  // visuals
  const preSpec = params.spec0;
  const finalSum = Math.max(1e-16, lastRGR + lastRQM + lastDC);
  const quality = clamp(1.0 - Math.log10(finalSum + 1e-16)/8.0, 0, 1);
  const tauBoost = clamp(0.06 + 0.18*clamp(tauEnd,0,1), 0, 0.24);
  const dyBoost = (dysonOnEl.checked && bestFinal) ? (0.10 + 0.20*etaBase) : 0;
  const postStrength = clamp(0.10 + 0.80*quality + dyBoost + tauBoost, 0.08, 0.95);

  blob(snapPre,  clamp(0.18 + 0.70*preSpec, 0.08, 0.92), 2);
  blob(snapPost, postStrength, 4);

  const pre = Array.from({length:24},(_,i)=> {
    const base = Math.max(0, 0.22 + 0.78*Math.sin((i/24)*Math.PI*2*3 + 0.4));
    return clamp(base*(0.55+0.55*preSpec), 0, 1);
  });
  const att = clamp(0.70 - 0.55*quality - 0.10*dyBoost - 0.10*tauBoost, 0.12, 0.85);
  const post = pre.map((v,i)=>{
    const tilt = 1 - 0.12*Math.sin((i/24)*Math.PI*2);
    return clamp(v * att * tilt, 0, 1);
  });
  bars(specPre, pre);
  bars(specPost, post);

  // φ log (optional): also keep latest line from φ panel
  if(phiLogEl.value === "yes"){ phiLogLineEl.textContent = phiState?.line || phiLogLineEl.textContent; }

  // vault write
  runCounter++;
  const every = parseInt(vaultEveryEl.value,10);
  const keepPassOnly = (keepPassOnlyEl.value === "yes");
  const allowStore = (!keepPassOnly) || solved;

  if(allowStore && (every<=1 || (runCounter % every)===0)){
    const score = 1 / Math.max(1e-12, (lastRGR+lastRQM+lastDC));
    vault.push({
      ts: Date.now(),
      score: score,
      solved: !!solved,
      final: { Rgr:lastRGR, Rqm:lastRQM, dC:lastDC },
      params: { kp: params.kp, kd: params.kd, epsGR: params.epsGR, epsQM: params.epsQM, epsDC: params.epsDC }
    });
    pruneAndDecayVault(clamp(tauMid,0,1));
    saveVault();
  }

  renderVault();
  updateEquationsLive();
  saveUIState();
}

/* -------------------- Events: Run / Reset -------------------- */
document.getElementById('runBtn').addEventListener('click', ()=>{
  setBadge(statusBadge, "Running…", "badge");
  setTimeout(simulate, 30);
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  // restore defaults
  document.getElementById('steps').value=500; document.getElementById('dt').value=0.02;
  document.getElementById('epsGR').value=1e-6; document.getElementById('epsQM').value=1e-6; document.getElementById('epsDC').value=1e-6;
  document.getElementById('hold').value=50; document.getElementById('Rgr0').value=0.08; document.getElementById('Rqm0').value=0.06;
  document.getElementById('dC0').value=0.10; document.getElementById('spec0').value=0.70; document.getElementById('kp').value=1.6; document.getElementById('kd').value=0.3;
  document.getElementById('F0').value=1361; document.getElementById('Mlens').value=1.00; document.getElementById('dI').value=0.03; document.getElementById('zred').value=0.00010;
  document.getElementById('tauNoise').value=600; document.getElementById('sigmaNoise').value=0.005;
  document.getElementById('eventTimes').value=""; document.getElementById('kernelType').value="gauss"; document.getElementById('bandwidth').value=300; document.getElementById('clambda').value=0.01;

  ptgEl.value = 250; etmEl.value = 180; phiEpsEl.value = 1e-9; phiModeEl.value = "unit"; kTolEl.value = 1e-6; phiLogEl.value = "yes";
  tauModeEl.value = "fixed"; tauStartEl.value = 0.35; tauMaxEl.value = 0.85; tauRateEl.value = 1.10; tauEtaShapeEl.value = 1.10; tauDecayShapeEl.value = 0.90;

  dysonOnEl.checked = false; dysonPersistEl.checked = true;
  dysonScaleEl.value = 2.20; dysonCapEl.value = 100; dysonLumEl.value = "3.828e26";
  etaVaultEl.value = 0.35; dysonReuseGainEl.value = 0.55; vaultEveryEl.value = 2; vaultCapEl.value = 20; dysonAUEl.value = 1.0;

  decayOnEl.checked = true; pruneOnEl.checked = true;
  decayRateEl.value = 0.060; pruneThEl.value = 0.020; keepPassOnlyEl.value = "yes"; vaultSortEl.value = "score";

  setBadge(statusBadge,"Idle — awaiting run","warn");
  [resCanvas,snapPre,snapPost,specPre,specPost,energyC,phiCanvas].forEach(c=>{sizeCanvas(c); clearCanvas(c);});

  setBadge(solvedBadge,"Self-consistency: —","badge");
  setBadge(stableBadge,"Stability: —","badge");
  setBadge(physicalBadge,"Physicality: —","badge");
  setBadge(gaugeBadge,"Gauge: —","badge");
  setBadge(consBadge,"∇·T: —","badge");
  setBadge(cflBadge,"CFL: —","badge");
  setBadge(vaultInfluenceBadge,"Vault target: —","badge");

  // show placeholders
  orbitVal.textContent="—"; orbitStatus.textContent="—";
  frwVal.textContent="—"; frwStatus.textContent="—";
  labVal.textContent="—"; labStatus.textContent="—";

  setBadge(effBadge,"Efficiency: —","badge");
  setBadge(powerBadge,"Total power: —","badge");
  setBadge(vaultReuseBadge,"Vault reuse: —","badge");

  updatePhiUI(); updateTauUI(); updateDysonUI(); updatePDUILabels();
  pruneAndDecayVault(clamp(Number(tauStartEl.value)||0.35,0,1));
  renderVault(); updateEquationsLive(); saveUIState();
});

/* -------------------- example fill helper -------------------- */
function setVal(id, v){ const el=document.getElementById(id); if(el) el.value=v; }
function loadExample(kind){
  setVal('steps', 500); setVal('dt', 0.02);
  setVal('epsGR', 1e-6); setVal('epsQM', 1e-6); setVal('epsDC', 1e-6);
  setVal('hold', 50); setVal('spec0', 0.70);

  if(kind==='quiet'){
    setVal('Rgr0', 0.08); setVal('Rqm0', 0.06); setVal('dC0', 0.10);
    setVal('kp', 1.4); setVal('kd', 0.25);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.01); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.003);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.01);
    tauModeEl.value="fixed"; tauStartEl.value=0.35; tauMaxEl.value=0.85; tauRateEl.value=1.10;
  }
  if(kind==='flare'){
    setVal('Rgr0', 0.10); setVal('Rqm0', 0.08); setVal('dC0', 0.12);
    setVal('kp', 1.8); setVal('kd', 0.35);
    setVal('F0', 1361); setVal('Mlens', 1.02); setVal('dI', 0.03); setVal('zred', 0.00010);
    setVal('tauNoise', 600); setVal('sigmaNoise', 0.008);
    setVal('eventTimes', "120, 340, 355, 910, 1240, 1805, 1812, 2600, 3600, 4200");
    setVal('kernelType', "exp"); setVal('bandwidth', 420); setVal('clambda', 0.015);
    tauModeEl.value="ramp"; tauStartEl.value=0.25; tauMaxEl.value=0.90; tauRateEl.value=1.40;
  }
  if(kind==='lab'){
    setVal('Rgr0', 0.05); setVal('Rqm0', 0.04); setVal('dC0', 0.06);
    setVal('kp', 1.2); setVal('kd', 0.20);
    setVal('F0', 1.0); setVal('Mlens', 1.00); setVal('dI', 0.0); setVal('zred', 0.0);
    setVal('tauNoise', 300); setVal('sigmaNoise', 0.0);
    setVal('eventTimes', ""); setVal('kernelType', "epa"); setVal('bandwidth', 120); setVal('clambda', 0.0);
    setVal('epsGR', 5e-7); setVal('epsQM', 5e-7); setVal('epsDC', 5e-7);
    tauModeEl.value="fixed"; tauStartEl.value=0.15; tauMaxEl.value=0.85; tauRateEl.value=1.10;
  }
  if(kind==='pass'){
    setVal('steps', 2000); setVal('dt', 0.02);
    setVal('epsGR', 1e-7); setVal('epsQM', 1e-7); setVal('epsDC', 1e-7);
    setVal('hold', 80);
    setVal('Rgr0', 0.02); setVal('Rqm0', 0.02); setVal('dC0', 0.03);
    setVal('spec0', 0.50);
    setVal('kp', 2.2); setVal('kd', 0.50);
    setVal('F0', 1361); setVal('Mlens', 1.00); setVal('dI', 0.005); setVal('zred', 0.00001);
    setVal('tauNoise', 900); setVal('sigmaNoise', 0.001);
    setVal('eventTimes', ""); setVal('kernelType', "gauss"); setVal('bandwidth', 300); setVal('clambda', 0.0);
    tauModeEl.value="ramp"; tauStartEl.value=0.30; tauMaxEl.value=0.95; tauRateEl.value=1.30;
  }

  updatePhiUI(); updateTauUI(); updatePDUILabels(); updateEquationsLive(); saveUIState();
  document.getElementById('steps').scrollIntoView({behavior:'smooth', block:'center'});
}

/* -------------------- Dyson / Vault controls wiring -------------------- */
function wireDysonControls(){
  const redraw = ()=>{
    updatePhiUI(); updateTauUI(); updateDysonUI(); updatePDUILabels();
    renderVault(); updateEquationsLive(); saveUIState();
  };

  [
    dysonOnEl, dysonPersistEl, dysonScaleEl, dysonCapEl, dysonLumEl,
    etaVaultEl, dysonReuseGainEl, vaultEveryEl, vaultCapEl, dysonAUEl,
    tauModeEl, tauStartEl, tauMaxEl, tauRateEl, tauEtaShapeEl, tauDecayShapeEl,
    ptgEl, etmEl, phiEpsEl, phiModeEl, kTolEl, phiLogEl
  ].forEach(el=>{
    el.addEventListener('input', redraw);
    el.addEventListener('change', redraw);
  });

  [decayOnEl, pruneOnEl, decayRateEl, pruneThEl, keepPassOnlyEl, vaultSortEl].forEach(el=>{
    const f=()=>{
      updatePDUILabels();
      pruneAndDecayVault(clamp(Number(tauStartEl.value)||0.35,0,1));
      saveVault();
      renderVault();
      updateEquationsLive();
      saveUIState();
    };
    el.addEventListener('input', f);
    el.addEventListener('change', f);
  });

  vaultClearBtn.addEventListener('click', ()=>{
    clearVault();
    renderVault();
    updateEquationsLive();
  });

  vaultRestoreBtn.addEventListener('click', ()=>{
    loadVault();
    pruneAndDecayVault(clamp(Number(tauStartEl.value)||0.35,0,1));
    renderVault();
    updateEquationsLive();
  });
}

/* -------------------- init sizing -------------------- */
window.addEventListener('resize', ()=>{ [resCanvas,snapPre,snapPost,specPre,specPost,energyC,phiCanvas].forEach(c=>{sizeCanvas(c);}); });
[resCanvas,snapPre,snapPost,specPre,specPost,energyC,phiCanvas].forEach(c=>sizeCanvas(c));

/* -------------------- init -------------------- */
(function init(){
  loadUIState();
  loadVault();
  updatePhiUI();
  updateTauUI();
  updateDysonUI();
  updatePDUILabels();
  pruneAndDecayVault(clamp(Number(tauStartEl.value)||0.35,0,1));
  renderVault();
  updateEquationsLive();
  wireDysonControls();
  saveUIState();
})();
</script>
</body>
</html>
