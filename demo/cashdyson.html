<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cash 5 Tight Coach — Prize-Weighted + Dyson + Prune/Decay</title>
<style>
  :root{
    --bg:#0b1222;
    --panel:#121a33;
    --ink:#edf2ff;
    --muted:#a9b7e3;
    --accent:#8fb4ff;
    --grid:#1b2550;
    --warn:#ffd37a;
    --bad:#ff8c8c;
    --good:#7bffb1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    font-size:18px;
  }
  .wrap{max-width:1320px;margin:0 auto;padding:24px 16px 40px}
  h1{margin:4px 0 10px;font-size:2rem}
  h2{margin:16px 0 8px;font-size:1.4rem}
  p{margin:4px 0 10px;color:var(--muted)}
  .grid{
    display:grid;
    grid-template-columns:minmax(0,1.15fr) minmax(0,1fr);
    gap:18px;
    align-items:flex-start;
  }
  .card{
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 0 0 1px rgba(0,0,0,0.4),0 10px 25px rgba(0,0,0,0.55);
  }
  textarea{
    width:100%;
    min-height:180px;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    resize:vertical;
    font-family:ui-monospace,Consolas,monospace;
    font-size:0.9rem;
    line-height:1.3;
  }
  label{display:block;font-weight:700;margin:8px 0 4px;color:var(--ink)}
  .controls-row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center}
  button{
    border:none;border-radius:999px;padding:10px 18px;font-size:1rem;font-weight:700;
    cursor:pointer;background:linear-gradient(135deg,var(--accent),#b4d0ff);
    color:#020415;box-shadow:0 4px 12px rgba(0,0,0,0.45);
    display:inline-flex;align-items:center;gap:6px;
  }
  button:active{transform:translateY(1px);box-shadow:0 2px 6px rgba(0,0,0,0.6)}
  .btn-secondary{background:#222a4a;color:var(--ink)}
  .badge{
    display:inline-block;padding:2px 8px;border-radius:999px;font-size:0.78rem;
    font-weight:700;background:#182044;color:var(--muted);border:1px solid var(--grid);
    margin-left:6px;
  }
  .stats{margin-top:8px;font-size:0.95rem}
  .stats-row{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0}
  .pill{padding:3px 9px;border-radius:999px;font-size:0.85rem;border:1px solid var(--grid);background:#050816}
  .pill-hot{ border-color:var(--good); color:var(--good); }
  .pill-warm{ border-color:var(--accent); color:var(--accent); }
  .pill-cold{ border-color:var(--muted); color:var(--muted); }
  .output-box{
    margin-top:10px;background:#050816;border-radius:10px;padding:10px 12px;border:1px solid var(--grid);
    font-family:ui-monospace,Consolas,monospace;font-size:1.05rem;line-height:1.45;
    max-height:520px;overflow:auto;
  }
  .ticket-line{display:flex;justify-content:space-between;align-items:center;padding:3px 0}
  .ticket-label{color:var(--muted);font-size:0.9rem;margin-right:10px}
  .ticket-numbers{letter-spacing:1px}
  .legend{margin-top:6px;font-size:0.9rem;color:var(--muted)}
  .small-note{font-size:0.82rem;color:var(--muted);margin-top:6px}
  .mini-note{font-size:0.84rem;color:var(--muted);margin-top:8px}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .controlbox{background:#0a0f25;border:1px solid var(--grid);border-radius:12px;padding:12px}
  .kv{display:grid;grid-template-columns:180px 1fr;gap:8px;align-items:center}
  input[type="number"], input[type="text"], select{
    width:100%;
    background:#050816;
    border:1px solid var(--grid);
    border-radius:10px;
    padding:10px;
    color:var(--ink);
    font-size:0.95rem;
  }
  input[type="range"]{width:100%}
  .rangeRow{display:grid;grid-template-columns:1fr 64px;gap:10px;align-items:center}
  .rangeVal{
    text-align:center;
    background:#050816;border:1px solid var(--grid);border-radius:10px;padding:8px 6px;
    font-weight:800;color:var(--ink);
  }
  .checkrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .checkrow label{margin:0;display:flex;gap:8px;align-items:center;color:var(--muted);font-weight:800}
  input[type="checkbox"]{transform:scale(1.15)}
  .hr{height:1px;background:var(--grid);margin:12px 0}
  .mono{font-family:ui-monospace,Consolas,monospace}
  .ok{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}

  @media print {
    body{background:#ffffff;color:#000000;}
    body *{visibility:hidden;}
    #ticketsBox, #ticketsBox *{visibility:visible;}
    #ticketsBox{
      position:absolute;left:0;top:0;width:100%;
      border:none;background:#ffffff;box-shadow:none;font-size:1.1rem;
      max-height:none;overflow:visible;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Cash 5 Tight Coach</h1>
  <p>
    History + prize-winner weighting + Dyson phase bias + prune/decay to generate <strong>20 tight lines</strong> (5/35).
  </p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <h2>1. Official Draw History</h2>
      <p>Paste recent official draws here (e.g., last 300–500 draws). One line per draw, <b>5 numbers per line</b>.</p>
      <textarea id="historyInput" placeholder="Example:&#10;3 11 18 24 35&#10;1 7 16 22 29&#10;..."></textarea>

      <h2 style="margin-top:18px;">2. Prize / Jackpot Winners (you paste yours)</h2>
      <p>These prize-winning lines are used as an anchor weight. Exact repeats are blocked.</p>
      <textarea id="winnersInput" placeholder="Paste winning lines here (5 numbers per line).&#10;Example:&#10;2 9 14 21 33&#10;..."></textarea>

      <h2 style="margin-top:18px;">3. Tightness Controls</h2>
      <div class="controlbox">
        <div style="font-weight:900;margin-bottom:6px;">Top Pool Slider (12–18)</div>
        <div class="rangeRow">
          <input id="topPool" type="range" min="12" max="18" step="1" value="12" />
          <div class="rangeVal" id="topPoolVal">12</div>
        </div>
        <div class="mini-note">
          Lower = tighter/narrower. For 20 tickets in Cash 5, 12–14 is very tight. 16–18 is broader.
        </div>
      </div>

      <div class="subgrid" style="margin-top:12px;">
        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Dyson Sphere Bias</div>
          <div class="kv">
            <div>Capture (0–1)</div>
            <input id="dysonCapture" type="number" step="0.05" min="0" max="1" value="0.55" />
            <div>Field Amp (0–3)</div>
            <input id="dysonAmp" type="number" step="0.1" min="0" max="3" value="1.6" />
            <div>Cooling Suppress (0–2)</div>
            <input id="coolSuppress" type="number" step="0.1" min="0" max="2" value="1.0" />
          </div>
          <div class="mini-note">
            Tuned for tight mode: capture 0.55, amp 1.6, cooling suppress 1.0.
          </div>
        </div>

        <div class="controlbox">
          <div style="font-weight:900;margin-bottom:6px;">Prune & Decay</div>
          <div class="kv">
            <div>Decay Rate</div>
            <input id="decayRate" type="number" step="0.01" min="0" max="0.35" value="0.12" />
            <div>Decay Mode</div>
            <select id="decayMode">
              <option value="row">Decay numbers used per ticket</option>
              <option value="coverage">Extra decay for over-used numbers</option>
              <option value="both" selected>Both</option>
            </select>
            <div>Prune</div>
            <select id="pruneOn">
              <option value="off">Off</option>
              <option value="on" selected>On</option>
            </select>
            <div>Prune Threshold</div>
            <input id="pruneThreshold" type="number" step="0.01" min="0" max="0.25" value="0.12" />
          </div>
          <div class="checkrow">
            <label><input id="decayTargetsOnly" type="checkbox" checked />Decay top-pool only</label>
            <label><input id="microReheat" type="checkbox" checked />Micro re-heat unused</label>
          </div>
          <div class="mini-note">
            Tight mode default: prune 0.12, decay 0.12, decay targets-only ON.
          </div>
        </div>
      </div>

      <div class="controls-row" style="margin-top:14px;">
        <button id="analyzeBtn" type="button">Analyze History</button>
        <button id="generateBtn" type="button" class="btn-secondary">Generate 20 Tight Tickets</button>
        <button id="printBtn" type="button" class="btn-secondary">Print 20 Tickets</button>
      </div>

      <div class="small-note">
        Rules: 5 numbers from 1–35. Exact prize lines blocked.
        Any run of 3+ consecutive numbers blocked.
        Near-duplicates sharing 4/5 numbers are blocked to keep variety.
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2>4. Bands & Dyson Phase Summary</h2>
      <div id="summaryBox" class="stats">Paste history and click <b>Analyze History</b>.</div>

      <div class="legend">
        <span class="pill pill-hot">Hot</span> top frequency &nbsp;
        <span class="pill pill-warm">Warm</span> mid &nbsp;
        <span class="pill pill-cold">Cold</span> low frequency
      </div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Dyson z-score phases</strong> (from your history)</div>
        <div class="stats-row" id="phaseRow">Analyze history first.</div>
        <div class="mini-note" id="dysonExplain"></div>
      </div>

      <div class="hr"></div>

      <h2>5. Generated 20-Ticket Set</h2>
      <div id="ticketsBox" class="output-box">Click “Generate 20 Tight Tickets” after analyzing.</div>
      <div class="mini-note" id="coverageBox"></div>

      <div class="hr"></div>

      <div class="stats">
        <div><strong>Effective pool after prune</strong></div>
        <div id="effectivePool" class="mono">—</div>
        <div class="mini-note">This shows how many numbers in the Top Pool still have meaningful weight after prune.</div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const N_MIN = 1;
  const N_MAX = 35;          // Cash 5: 1–35
  const TICKET_SIZE = 5;     // Cash 5: choose 5
  const NUM_TICKETS = 20;    // keep 20-ticket set

  const historyInput = document.getElementById('historyInput');
  const winnersInput = document.getElementById('winnersInput');
  const summaryBox   = document.getElementById('summaryBox');
  const ticketsBox   = document.getElementById('ticketsBox');
  const analyzeBtn   = document.getElementById('analyzeBtn');
  const generateBtn  = document.getElementById('generateBtn');
  const printBtn     = document.getElementById('printBtn');

  // Top pool slider
  const topPoolSlider = document.getElementById('topPool');
  const topPoolVal = document.getElementById('topPoolVal');

  // Dyson controls
  const dysonCaptureInput = document.getElementById('dysonCapture');
  const dysonAmpInput = document.getElementById('dysonAmp');
  const coolSuppressInput = document.getElementById('coolSuppress');

  // Prune/decay controls
  const decayRateInput = document.getElementById('decayRate');
  const decayModeInput = document.getElementById('decayMode');
  const pruneOnInput = document.getElementById('pruneOn');
  const pruneThresholdInput = document.getElementById('pruneThreshold');
  const decayTargetsOnlyInput = document.getElementById('decayTargetsOnly');
  const microReheatInput = document.getElementById('microReheat');

  const phaseRowEl = document.getElementById('phaseRow');
  const dysonExplainEl = document.getElementById('dysonExplain');
  const coverageBoxEl = document.getElementById('coverageBox');
  const effectivePoolEl = document.getElementById('effectivePool');

  let lastStats = null;
  let forbiddenSet = new Set();

  // ---- helpers ----
  function parseCombos(text) {
    const combos = [];
    if (!text) return combos;
    const lines = text.trim().split(/\n+/);
    for (let line of lines) {
      const nums = line.trim().split(/[\s,]+/).map(x => parseInt(x,10)).filter(n => !isNaN(n));
      if (nums.length >= TICKET_SIZE) {
        const combo = nums.slice(0, TICKET_SIZE).sort((a,b)=>a-b);
        if (combo.every(n => n >= N_MIN && n <= N_MAX)) combos.push(combo);
      }
    }
    return combos;
  }
  function keyForCombo(combo) { return combo.join('-'); }

  function meanStd(values){
    const n = values.length || 1;
    const mu = values.reduce((a,b)=>a+b,0)/n;
    const v = values.reduce((s,x)=>s+(x-mu)*(x-mu),0)/n;
    return {mu, sigma: Math.sqrt(v)};
  }

  function computeZPhases(freq){
    const vals = [];
    for (let n=N_MIN; n<=N_MAX; n++) vals.push(freq[n] || 0);
    const {mu, sigma} = meanStd(vals);

    const z = new Array(N_MAX+1).fill(0);
    const phases = {rising:[], neutral:[], cooling:[]};
    for (let n=N_MIN; n<=N_MAX; n++){
      const zz = (sigma>0) ? ((freq[n]-mu)/sigma) : 0;
      z[n] = zz;
      if (zz <= -0.5) phases.rising.push(n);
      else if (Math.abs(zz) < 0.5) phases.neutral.push(n);
      else phases.cooling.push(n);
    }
    return {z, phases, mu, sigma};
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function clamp01(x){ return clamp(x,0,1); }

  function dysonFieldFactor(z, capture, amp, coolSuppress){
    const strength = capture * amp;
    if (strength <= 0) return 1;

    // "Rising": boost
    if (z <= -0.5){
      const t = Math.min(1, (-z - 0.5) / 1.5);
      return 1 + (0.8*strength) * (0.6 + 0.4*t);
    }
    // "Cooling": suppress
    if (z >= 0.5){
      const t = Math.min(1, (z - 0.5) / 1.5);
      const sup = (coolSuppress * strength) * (0.6 + 0.4*t);
      return 1 / (1 + sup);
    }
    // neutral
    return 1 + 0.10*strength*(0.5 - Math.abs(z));
  }

  function median(values){
    const a = values.slice().sort((x,y)=>x-y);
    const n = a.length;
    if(!n) return 0;
    return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
  }

  function computeStats(historyCombos, winnerCombos) {
    const freq = new Array(N_MAX + 1).fill(0);
    const prizeBoost = new Array(N_MAX + 1).fill(0);

    historyCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) freq[n]++; }));
    winnerCombos.forEach(c => c.forEach(n => { if (n>=N_MIN && n<=N_MAX) prizeBoost[n]++; }));

    const totalHits = freq.reduce((a,b)=>a+b,0);
    const drawsCount = historyCombos.length;

    const {z, phases, mu, sigma} = computeZPhases(freq);

    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push({ n, freq:freq[n], boost:prizeBoost[n] });
    arr.sort((a,b) => b.freq - a.freq || b.boost - a.boost || a.n - b.n);

    // For 35 numbers, use smaller bands
    const hotCount  = 8;
    const warmCount = 10;
    const hot  = arr.slice(0, hotCount).map(o=>o.n);
    const warm = arr.slice(hotCount, hotCount+warmCount).map(o=>o.n);
    const cold = arr.slice(hotCount+warmCount).map(o=>o.n);

    const weights = new Array(N_MAX + 1).fill(1);
    for (let n=N_MIN; n<=N_MAX; n++){
      const base = 1 + freq[n];
      const prizeExtra = 0.6 * prizeBoost[n];
      weights[n] = Math.max(1, base + prizeExtra);
    }

    return { freq, prizeBoost, weights, hot, warm, cold, drawsCount, totalHits, mu, sigma, z, phases };
  }

  function renderStats(stats) {
    const {hot, warm, cold, drawsCount, totalHits, mu, sigma} = stats;
    function fmtList(list){ return list.length ? list.join(' ') : '(none)'; }
    summaryBox.innerHTML = `
      <div><strong>Draws analyzed:</strong> ${drawsCount}</div>
      <div><strong>Total hits counted:</strong> ${totalHits}</div>
      <div><strong>Avg hits per number:</strong> ${(mu).toFixed(2)}
        <span class="badge">σ ≈ ${(sigma).toFixed(2)}</span>
      </div>
      <div class="stats-row" style="margin-top:8px;">
        <span class="pill pill-hot"><strong>Hot</strong> ${fmtList(hot)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-warm"><strong>Warm</strong> ${fmtList(warm)}</span>
      </div>
      <div class="stats-row">
        <span class="pill pill-cold"><strong>Cold</strong> ${fmtList(cold)}</span>
      </div>
    `;
  }

  function renderPhases(stats){
    const r = stats.phases.rising.length;
    const n = stats.phases.neutral.length;
    const c = stats.phases.cooling.length;
    phaseRowEl.innerHTML = `
      <span class="pill pill-hot">Rising (z≤-0.5): <b>${r}</b></span>
      <span class="pill pill-warm">Neutral (|z|&lt;0.5): <b>${n}</b></span>
      <span class="pill pill-cold">Cooling (z≥0.5): <b>${c}</b></span>
    `;
    dysonExplainEl.textContent =
      `Dyson bias uses your history z-scores: Rising numbers get boosted, Cooling get suppressed.`;
  }

  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function weightedPick(available, weights, rng) {
    let total = 0;
    for (const n of available) total += weights[n];
    if (total <= 0) return available[Math.floor(rng()*available.length)];
    let r = rng() * total;
    for (const n of available) { r -= weights[n]; if (r <= 0) return n; }
    return available[available.length-1];
  }

  function hasSequenceRun(combo, minLen) {
    let run = 1;
    for (let i = 1; i < combo.length; i++) {
      if (combo[i] === combo[i-1] + 1) { run++; if (run >= minLen) return true; }
      else run = 1;
    }
    return false;
  }

  function generateTicketFromWeights(weights, rng) {
    const available = [];
    for (let n=N_MIN; n<=N_MAX; n++) available.push(n);
    const combo = [];
    for (let i=0; i<TICKET_SIZE; i++){
      const pick = weightedPick(available, weights, rng);
      combo.push(pick);
      const idx = available.indexOf(pick);
      if (idx >= 0) available.splice(idx,1);
    }
    combo.sort((a,b)=>a-b);
    return combo;
  }

  function applyDysonToWeights(baseWeights, zArr){
    const cap = clamp01(+dysonCaptureInput.value || 0);
    const amp = clamp(+dysonAmpInput.value || 0, 0, 3);
    const sup = clamp(+coolSuppressInput.value || 0, 0, 2);
    const out = baseWeights.slice();
    for (let n=N_MIN; n<=N_MAX; n++){
      const factor = dysonFieldFactor(zArr[n] || 0, cap, amp, sup);
      out[n] = Math.max(1e-6, out[n] * factor);
    }
    return out;
  }

  function makeTopPool(weights, k){
    const arr = [];
    for (let n=N_MIN; n<=N_MAX; n++) arr.push([n, weights[n]]);
    arr.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    return new Set(arr.slice(0,k).map(x=>x[0]));
  }

  function pruneWeights(weights, topPoolSet){
    const pruneOn = (pruneOnInput.value === 'on');
    if(!pruneOn) return weights;

    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    const cut = med * threshFrac;
    if (cut <= 0) return weights;

    const out = weights.slice();
    for (let n of topPoolSet){
      if (out[n] < cut) out[n] = 1e-6;
    }
    return out;
  }

  function effectivePoolCount(weights, topPoolSet){
    const vals = [];
    for (let n of topPoolSet) vals.push(weights[n]);
    const med = median(vals) || 0;
    if (med <= 0) return {count: topPoolSet.size, cut: 0};
    const threshFrac = clamp(+pruneThresholdInput.value || 0, 0, 0.25);
    const cut = med * threshFrac;
    let c = 0;
    for (let n of topPoolSet) if (weights[n] >= cut) c++;
    return {count:c, cut};
  }

  function applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet){
    const rate = clamp(+decayRateInput.value || 0, 0, 0.35);
    const mode = decayModeInput.value || 'both';
    const decayTargetsOnly = !!decayTargetsOnlyInput.checked;
    const microReheat = !!microReheatInput.checked;

    const out = weights.slice();

    if (mode === 'row' || mode === 'both'){
      for (const n of ticket){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = Math.max(1e-6, out[n] * (1 - rate));
      }
    }

    if (mode === 'coverage' || mode === 'both'){
      for (let n=N_MIN; n<=N_MAX; n++){
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        const c = usageCounts[n] || 0;
        // With 20 tickets x 5 numbers, hitting 4+ is meaningfully "over-used"
        if (c >= 4){
          const extra = Math.min(0.22, rate * 0.75);
          out[n] = Math.max(1e-6, out[n] * (1 - extra));
        }
      }
    }

    if (microReheat){
      const lift = rate * 0.10;
      for (let n=N_MIN; n<=N_MAX; n++){
        if (ticket.includes(n)) continue;
        if (decayTargetsOnly && !topPoolSet.has(n)) continue;
        out[n] = out[n] * (1 + lift);
      }
    }

    return out;
  }

  function generateTickets(stats){
    if (!stats){
      ticketsBox.textContent = 'Please analyze history first.';
      return;
    }

    // Step 1: base -> Dyson
    let weights = applyDysonToWeights(stats.weights, stats.z);

    // Step 2: Top pool from slider
    const TOP_POOL_K = clamp(parseInt(topPoolSlider.value,10) || 12, 12, 18);
    const topPoolSet = makeTopPool(weights, TOP_POOL_K);

    // Step 3: prune in pool
    weights = pruneWeights(weights, topPoolSet);

    // Step 4: keep it tight: downweight outside pool
    for (let n=N_MIN; n<=N_MAX; n++){
      if (!topPoolSet.has(n)) weights[n] *= 0.25; // tighter for Cash 5
    }

    // Effective pool after prune
    const ep = effectivePoolCount(weights, topPoolSet);
    effectivePoolEl.textContent = `TopPool=${TOP_POOL_K} • pruneCut≈${ep.cut.toFixed(4)} • effective≈${ep.count}/${TOP_POOL_K}`;

    const tickets = [];
    const seen = new Set(forbiddenSet);
    const usageCounts = new Array(N_MAX+1).fill(0);
    const rng = mulberry32((Date.now() ^ (Math.random()*1e9)) >>> 0);

    let attempts = 0;
    while (tickets.length < NUM_TICKETS && attempts < 12000){
      attempts++;

      const ticket = generateTicketFromWeights(weights, rng);
      const key = keyForCombo(ticket);

      if (seen.has(key)) continue;
      if (hasSequenceRun(ticket, 3)) continue;

      // near-duplicate filter: 4/5 common = too similar
      let tooSimilar = false;
      for (const t of tickets){
        let common = 0;
        for (const n of ticket) if (t.includes(n)) common++;
        if (common >= 4){ tooSimilar = true; break; }
      }
      if (tooSimilar) continue;

      seen.add(key);
      tickets.push(ticket);

      for (const n of ticket) usageCounts[n]++;

      weights = applyDecayBetweenTickets(weights, ticket, usageCounts, topPoolSet);
      weights = pruneWeights(weights, topPoolSet);
    }

    if (!tickets.length){
      ticketsBox.textContent = 'No tickets generated (constraints too tight). Raise Top Pool or lower prune/decay.';
      coverageBoxEl.textContent = '';
      return;
    }

    ticketsBox.innerHTML = tickets.map((t,i)=>`
      <div class="ticket-line">
        <span class="ticket-label">#${(i+1).toString().padStart(2,'0')}</span>
        <span class="ticket-numbers">${t.join('  ')}</span>
      </div>
    `).join('');

    // Coverage summary
    const used = new Set();
    tickets.forEach(t=>t.forEach(n=>used.add(n)));
    let inPool = 0;
    used.forEach(n=>{ if (topPoolSet.has(n)) inPool++; });

    const freqList = [];
    for (let n=N_MIN; n<=N_MAX; n++){
      if (usageCounts[n]>0) freqList.push([n, usageCounts[n]]);
    }
    freqList.sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    const topUsed = freqList.slice(0,12).map(([n,c])=>`${n}(${c})`).join('  ');

    coverageBoxEl.innerHTML =
      `<div><b>20-ticket coverage:</b> unique numbers used = <b>${used.size}</b> / ${N_MAX}</div>` +
      `<div><b>Inside Top Pool:</b> used = <b>${inPool}</b> / ${TOP_POOL_K}</div>` +
      `<div class="mono"><b>Most repeated:</b> ${topUsed || '—'}</div>` +
      `<div class="mini-note">If repeats feel too high, raise decay slightly (0.12→0.14) or increase Top Pool (12→14/16).</div>`;
  }

  // ---- events ----
  function syncTopPoolUI(){
    topPoolVal.textContent = String(topPoolSlider.value);
  }
  topPoolSlider.addEventListener('input', ()=>{
    syncTopPoolUI();
    if (lastStats) {
      const txt = (ticketsBox.textContent || '').trim();
      if (txt && !txt.includes('Analyze') && !txt.includes('Generate')) generateTickets(lastStats);
    }
  });
  syncTopPoolUI();

  analyzeBtn.addEventListener('click', ()=>{
    const historyCombos = parseCombos(historyInput.value);
    const winnerCombos = parseCombos(winnersInput.value);

    forbiddenSet = new Set();
    winnerCombos.forEach(c => forbiddenSet.add(keyForCombo(c)));

    if (!historyCombos.length){
      summaryBox.innerHTML = '<span class="bad"><b>No valid history draws detected.</b> Paste some lines first.</span>';
      phaseRowEl.textContent = 'Analyze history first.';
      dysonExplainEl.textContent = '';
      effectivePoolEl.textContent = '—';
      return;
    }

    lastStats = computeStats(historyCombos, winnerCombos);
    renderStats(lastStats);
    renderPhases(lastStats);

    ticketsBox.textContent = 'History analyzed. Now click “Generate 20 Tight Tickets”.';
    coverageBoxEl.textContent = '';
    effectivePoolEl.textContent = '—';
  });

  generateBtn.addEventListener('click', ()=> generateTickets(lastStats));

  // Auto-regenerate if user tweaks controls after generation
  function maybeRefresh(){
    if (!lastStats) return;
    const txt = (ticketsBox.textContent || '').trim();
    if (!txt || txt.includes('History analyzed') || txt.includes('Analyze') || txt.includes('Generate')) return;
    generateTickets(lastStats);
  }
  [
    dysonCaptureInput, dysonAmpInput, coolSuppressInput,
    decayRateInput, decayModeInput, pruneOnInput, pruneThresholdInput,
    decayTargetsOnlyInput, microReheatInput
  ].forEach(el=>{
    el.addEventListener('input', maybeRefresh);
    el.addEventListener('change', maybeRefresh);
  });

  printBtn.addEventListener('click', ()=>{
    const txt = ticketsBox.textContent.trim();
    if (!txt || txt.includes('Generate 20') || txt.includes('History analyzed')) {
      alert('Generate your 20 tickets first before printing.');
      return;
    }
    window.print();
  });

})();
</script>
</body>
</html>
