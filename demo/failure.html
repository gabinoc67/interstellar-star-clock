<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CST Warp Navigation + Warp Engine Simulator v2 — Ship Schematic • Warp Jump • Failure Inject</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#121a33;
    --panel2:#0f1730;
    --ink:#e9eeff;
    --muted:#aab4e6;
    --line:#22305f;
    --accent:#7aa2ff;
    --ok:#35e6a2;
    --warn:#ffd15a;
    --bad:#ff6b8b;
    --shadow:0 10px 28px rgba(0,0,0,.35);
    --r:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background:
      radial-gradient(1200px 800px at 20% -10%, #152057 0%, rgba(21,32,87,0) 55%),
      radial-gradient(900px 700px at 90% 10%, #1a2a66 0%, rgba(26,42,102,0) 55%),
      var(--bg);
    color:var(--ink);
  }
  header{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    background:linear-gradient(180deg, rgba(18,26,51,.95), rgba(18,26,51,.70));
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(6px);
  }
  header h1{margin:0;font-size:18px;letter-spacing:.2px}
  header .sub{margin-top:6px;color:var(--muted);font-size:12.5px;line-height:1.35}
  main{
    padding:14px;
    display:grid;
    grid-template-columns: 440px 1fr;
    gap:14px;
    align-items:start;
  }
  .panel{
    background:linear-gradient(180deg, rgba(18,26,51,.95), rgba(18,26,51,.78));
    border:1px solid var(--line);
    border-radius:var(--r);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .panel .hd{
    padding:10px 12px;
    border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between;
    background:linear-gradient(180deg, rgba(15,23,48,.85), rgba(15,23,48,.55));
    gap:10px;
  }
  .panel .hd b{font-size:13px;letter-spacing:.2px}
  .panel .bd{padding:12px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .row{display:flex;gap:10px;align-items:center}
  .stack{display:flex;flex-direction:column;gap:8px}
  .tiny{font-size:11.5px;color:var(--muted);line-height:1.35}
  .val{font-variant-numeric: tabular-nums; font-size:12.5px}
  .kv{
    display:grid;grid-template-columns: 1.2fr .8fr;
    gap:8px;align-items:center;
    padding:8px 10px;border:1px solid var(--line);
    border-radius:12px;background:rgba(10,14,28,.55);
  }
  .kv .k{color:var(--muted);font-size:12px}
  .kv .v{justify-self:end;font-variant-numeric:tabular-nums;font-size:12.5px}
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border:1px solid var(--line);
    border-radius:999px; background:rgba(10,14,28,.55);
    font-size:12px; color:var(--muted);
    white-space:nowrap;
  }
  button{
    border:1px solid var(--line);
    background:rgba(10,14,28,.55);
    color:var(--ink);
    padding:9px 10px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
  }
  button:hover{border-color:#2d3d79}
  button:disabled{opacity:.55;cursor:not-allowed}
  .btnbar{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  .btnbar2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .tog{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px;border:1px solid var(--line);
    border-radius:12px;background:rgba(10,14,28,.55);
    gap:10px;
  }
  .tog span{font-size:12px;color:var(--muted)}
  .tog input{transform:scale(1.1)}
  .slider{
    padding:8px 10px;border:1px solid var(--line);
    border-radius:12px;background:rgba(10,14,28,.55);
  }
  .slider .top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
  .slider .top b{font-size:12px;color:var(--muted);font-weight:750}
  input[type="range"]{width:100%}
  .right{
    display:grid;
    grid-template-rows:auto auto auto;
    gap:14px;
  }
  .canvasWrap{
    padding:10px;
    background:rgba(10,14,28,.55);
    border:1px solid var(--line);
    border-radius:12px;
  }
  canvas{width:100%;height:220px;display:block}
  .canvasWrap.sm canvas{height:170px}
  .canvasWrap.schem canvas{height:280px}
  .legend{
    margin-top:8px;
    display:flex; flex-wrap:wrap; gap:8px;
    color:var(--muted); font-size:12px;
  }
  .chip{
    padding:4px 8px;border:1px solid var(--line);
    border-radius:999px;background:rgba(10,14,28,.55);
  }
  .statusBar{
    display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px;
  }
  .badge{
    padding:6px 10px;border-radius:999px;border:1px solid var(--line);
    background:rgba(10,14,28,.55);
    font-size:12px;color:var(--muted);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .dot{width:10px;height:10px;border-radius:50%}
  .ok{background:var(--ok)}
  .warn{background:var(--warn)}
  .bad{background:var(--bad)}
  .mono{font-variant-numeric:tabular-nums}
  .callout{
    border-left:3px solid var(--accent);
    padding:10px 12px;
    background:rgba(122,162,255,.10);
    border-radius:12px;
    color:var(--muted);
    font-size:12.5px;
    line-height:1.45;
  }
  .block{
    border:1px dashed rgba(122,162,255,.55);
    border-radius:14px;
    padding:10px;
    background:rgba(10,14,28,.35);
  }
  .block h3{margin:0 0 8px 0;font-size:12.5px;letter-spacing:.2px}
  .block ul{margin:0;padding-left:16px;color:var(--muted);font-size:12.2px;line-height:1.45}
  footer{
    padding:12px 14px;
    color:var(--muted);
    font-size:12px;
    border-top:1px solid var(--line);
    margin-top:14px;
  }
</style>
</head>

<body>
<header>
  <h1>CST Warp Navigation + Warp Engine — v2 (Ship Schematic • Warp Jump • Failure Inject)</h1>
  <div class="sub">
    <b>Direct CST mapping:</b> local drift Δg is regulated toward a stable CST frame via phase alignment (φₛₜ),
    regulation gain (kᵣ), and a <b>frame-lock memory M</b> that acts like a thermodynamic “energy barrier” (hysteresis).
  </div>
</header>

<main>
  <!-- LEFT: Controls -->
  <section class="panel">
    <div class="hd">
      <b>Controls</b>
      <span class="pill"><span class="mono" id="simTime">t=0.00s</span></span>
    </div>
    <div class="bd stack">

      <div class="btnbar">
        <button id="btnStart">Start</button>
        <button id="btnStop">Stop</button>
        <button id="btnReset">Reset</button>
      </div>

      <div class="btnbar2">
        <button id="btnJump" title="Burst translation event + recovery">Warp Jump Event</button>
        <button id="btnStabilize" title="Quickly nudge parameters toward stability">Quick Stabilize</button>
      </div>

      <div class="grid2">
        <div class="tog">
          <span>Auto-Regulation (engine governor loop)</span>
          <input id="tgAuto" type="checkbox" checked/>
        </div>
        <div class="tog">
          <span>Frame Lock (CST memory locking)</span>
          <input id="tgLock" type="checkbox" checked/>
        </div>
        <div class="tog">
          <span>Navigation Autopilot (target tracking)</span>
          <input id="tgNav" type="checkbox" checked/>
        </div>
        <div class="tog">
          <span>Inspector (show internals)</span>
          <input id="tgInspect" type="checkbox"/>
        </div>
      </div>

      <div class="grid2">
        <div class="tog">
          <span>Engine Failure Inject (degrade coils/cooling)</span>
          <input id="tgFail" type="checkbox"/>
        </div>
        <div class="slider">
          <div class="top"><b>Failure Severity</b><span class="val mono" id="vFail">0.40</span></div>
          <input id="sFail" type="range" min="0" max="1" step="0.01" value="0.40">
          <div class="tiny">When ON: reduces effective power & dissipation; adds extra drift/noise coupling.</div>
        </div>
      </div>

      <div class="slider">
        <div class="top"><b>CST Phase Alignment φₛₜ</b><span class="val mono" id="vPhi">0.50</span></div>
        <input id="sPhi" type="range" min="0" max="1" step="0.01" value="0.50">
        <div class="tiny">Higher φₛₜ increases coherence (reduces drift) but can raise demand if the system is hot or noisy.</div>
      </div>

      <div class="slider">
        <div class="top"><b>Spacetime Regulation Gain kᵣ</b><span class="val mono" id="vKr">1.20</span></div>
        <input id="sKr" type="range" min="0" max="3" step="0.01" value="1.20">
        <div class="tiny">How strongly the warp bubble corrects local metric drift toward a stable CST frame.</div>
      </div>

      <div class="grid2">
        <div class="slider">
          <div class="top"><b>Warp Bubble Radius Rᵦ (arb)</b><span class="val mono" id="vRb">42</span></div>
          <input id="sRb" type="range" min="10" max="140" step="1" value="42">
          <div class="tiny">Bigger bubble = higher baseline cost, but more control volume.</div>
        </div>
        <div class="slider">
          <div class="top"><b>Coil Power Limit Pₘₐₓ</b><span class="val mono" id="vPmax">72</span></div>
          <input id="sPmax" type="range" min="10" max="140" step="1" value="72">
          <div class="tiny">Caps coil drive. Too low → instability; too high → thermal risk.</div>
        </div>
      </div>

      <div class="grid2">
        <div class="slider">
          <div class="top"><b>Sensor Noise σ (nav jitter)</b><span class="val mono" id="vNoise">0.12</span></div>
          <input id="sNoise" type="range" min="0" max="0.60" step="0.01" value="0.12">
          <div class="tiny">Higher σ increases measurement drift; frame locking must resist it.</div>
        </div>
        <div class="slider">
          <div class="top"><b>Thermal Dissipation D</b><span class="val mono" id="vD">0.90</span></div>
          <input id="sD" type="range" min="0.20" max="2.40" step="0.01" value="0.90">
          <div class="tiny">Materials + coolant. Higher D removes heat faster.</div>
        </div>
      </div>

      <div class="grid2">
        <div class="slider">
          <div class="top"><b>Target Distance (ly)</b><span class="val mono" id="vDist">4.20</span></div>
          <input id="sDist" type="range" min="0.5" max="25" step="0.10" value="4.20">
          <div class="tiny">Navigation tries to reduce distance while maintaining frame stability.</div>
        </div>
        <div class="slider">
          <div class="top"><b>Warp Intent (0→1)</b><span class="val mono" id="vIntent">0.60</span></div>
          <input id="sIntent" type="range" min="0" max="1" step="0.01" value="0.60">
          <div class="tiny">Aggression: speed/translation vs stability margin.</div>
        </div>
      </div>

      <div class="callout" id="hint">
        <b>How to see “closure”:</b> raise φₛₜ (≈0.65–0.85) and kᵣ (≈1.2–2.0), then increase Rᵦ.
        If it stays stable without changing equations, you’re seeing scaling behavior (closure).
      </div>

      <div class="stack" id="inspector" style="display:none">
        <div class="grid2">
          <div class="kv"><div class="k">Activation a(t)</div><div class="v mono" id="iAct">0.000</div></div>
          <div class="kv"><div class="k">Frame Lock M(t)</div><div class="v mono" id="iMem">0.000</div></div>
          <div class="kv"><div class="k">Metric Drift Δg</div><div class="v mono" id="iDrift">0.000</div></div>
          <div class="kv"><div class="k">Coherence C</div><div class="v mono" id="iCoh">0.000</div></div>
          <div class="kv"><div class="k">Heat T</div><div class="v mono" id="iHeat">0.0</div></div>
          <div class="kv"><div class="k">Power P</div><div class="v mono" id="iPow">0.0</div></div>
          <div class="kv"><div class="k">Dist Δ (ly)</div><div class="v mono" id="iDist">0.00</div></div>
          <div class="kv"><div class="k">Failure factor</div><div class="v mono" id="iFail">1.00</div></div>
        </div>
        <div class="tiny">Inspector shows internal state variables.</div>
      </div>

    </div>
  </section>

  <!-- RIGHT: Outputs -->
  <section class="right">

    <!-- Status -->
    <section class="panel">
      <div class="hd">
        <b>System Status</b>
        <span class="pill">Mode: <span class="mono" id="modeName">Idle</span></span>
      </div>
      <div class="bd stack">

        <div class="statusBar">
          <div class="badge"><span>Frame Stability</span><span class="row"><span class="dot ok" id="dotStab"></span><span class="mono" id="mStab">0.00</span></span></div>
          <div class="badge"><span>Nav Drift</span><span class="row"><span class="dot warn" id="dotDrift"></span><span class="mono" id="mNavDrift">0.00</span></span></div>
          <div class="badge"><span>Thermal</span><span class="row"><span class="dot ok" id="dotHeat"></span><span class="mono" id="mHeat">0.0</span></span></div>
          <div class="badge"><span>Distance (ly)</span><span class="row"><span class="dot ok" id="dotDist"></span><span class="mono" id="mDist">4.20</span></span></div>
        </div>

        <div class="grid2">
          <div class="block">
            <h3>Warp Navigation System (labeled parts)</h3>
            <ul>
              <li><b>Star Clock Array</b> → timing beacons; noise σ adds jitter.</li>
              <li><b>CST Frame Solver</b> → estimates stable global timing frame.</li>
              <li><b>Phase Align Unit (φₛₜ)</b> → synchronizes local clocks to CST frame.</li>
              <li><b>Frame Lock Memory (M)</b> → latches a stable frame when coherence persists.</li>
              <li><b>Guidance Output</b> → sets warp intent & heading corrections.</li>
            </ul>
          </div>
          <div class="block">
            <h3>Warp Engine (labeled parts)</h3>
            <ul>
              <li><b>Field Coils</b> (P limited by Pₘₐₓ) → shape bubble & regulate drift.</li>
              <li><b>Bubble Boundary</b> (Rᵦ) → control volume for metric correction.</li>
              <li><b>Regulation Gain</b> (kᵣ) → how strongly drift is corrected.</li>
              <li><b>Heat Shield + Coolant</b> (D) → dissipates coil losses.</li>
              <li><b>Governor Loop</b> (Auto) → self-stabilizes P vs drift vs heat.</li>
            </ul>
          </div>
        </div>

        <div class="callout">
          <b>How “memory” helps warp nav:</b> when coherence remains high, <b>M rises</b>, making the frame “hard to undo.”
          So nav stays stable even when sensor jitter spikes. That’s not Google-style memory; it’s <b>physical resistance to drift</b>.
        </div>

      </div>
    </section>

    <!-- Ship Schematic -->
    <section class="panel">
      <div class="hd">
        <b>Ship Schematic (labeled arrows)</b>
        <span class="pill">Legend: coils → bubble → CST solver → lock → guidance</span>
      </div>
      <div class="bd stack">
        <div class="canvasWrap schem">
          <canvas id="schem" width="980" height="360"></canvas>
          <div class="legend">
            <span class="chip">Coils / Power</span>
            <span class="chip">Bubble Boundary</span>
            <span class="chip">CST Frame Solver</span>
            <span class="chip">Phase Align</span>
            <span class="chip">Frame Lock (Memory)</span>
            <span class="chip">Guidance Output</span>
          </div>
        </div>
        <div class="tiny">
          Arrows show the control flow: <b>Coils</b> shape the <b>bubble boundary</b>, sensors feed the <b>CST solver</b>,
          the ship aligns phase (φₛₜ), then locks a stable frame (M), which stabilizes navigation and reduces correction work.
        </div>
      </div>
    </section>

    <!-- Plots -->
    <section class="panel">
      <div class="hd">
        <b>Live Plots</b>
        <span class="pill">Update: <span class="mono" id="hz">—</span></span>
      </div>
      <div class="bd stack">
        <div class="canvasWrap">
          <canvas id="plot1" width="980" height="320"></canvas>
          <div class="legend">
            <span class="chip">Δg (metric drift)</span>
            <span class="chip">C (coherence)</span>
            <span class="chip">M (memory lock)</span>
            <span class="chip">Jump impulse marker</span>
          </div>
        </div>
        <div class="canvasWrap sm">
          <canvas id="plot2" width="980" height="260"></canvas>
          <div class="legend">
            <span class="chip">T (heat)</span>
            <span class="chip">P (coil power)</span>
            <span class="chip">Nav drift</span>
            <span class="chip">Failure ON marker</span>
          </div>
        </div>
      </div>
    </section>

  </section>
</main>

<footer>
  Quick test: Start → set φₛₜ=0.78, kᵣ=1.6, D=1.2, intent=0.65 → click Warp Jump Event.
  If M stays high and Δg returns to near-zero, you have a “locked frame” doing the stabilizing work.
</footer>

<script>
/* ------------------------------------------------------------
  CST Warp Nav + Engine Demo v2
  Added:
  - Ship schematic canvas with arrows + labels
  - Warp Jump Event button (burst translation + recovery dynamics)
  - Engine Failure Injection toggle + severity
------------------------------------------------------------ */

const el = (id)=>document.getElementById(id);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const lerp=(a,b,t)=>a+(b-a)*t;
function fmt(x, d=2){ return (+x).toFixed(d); }
function rndn(){ // quick approx gaussian
  let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// Controls
const btnStart = el("btnStart");
const btnStop  = el("btnStop");
const btnReset = el("btnReset");
const btnJump  = el("btnJump");
const btnStabilize = el("btnStabilize");

const tgAuto   = el("tgAuto");
const tgLock   = el("tgLock");
const tgNav    = el("tgNav");
const tgInspect= el("tgInspect");
const tgFail   = el("tgFail");

const sFail    = el("sFail");
const sPhi     = el("sPhi");
const sKr      = el("sKr");
const sRb      = el("sRb");
const sPmax    = el("sPmax");
const sNoise   = el("sNoise");
const sD       = el("sD");
const sDist    = el("sDist");
const sIntent  = el("sIntent");

// Labels
const vFail = el("vFail");
const vPhi  = el("vPhi");
const vKr   = el("vKr");
const vRb   = el("vRb");
const vPmax = el("vPmax");
const vNoise= el("vNoise");
const vD    = el("vD");
const vDist = el("vDist");
const vIntent=el("vIntent");

const simTime = el("simTime");
const modeName= el("modeName");
const hzEl = el("hz");

// Status
const mStab = el("mStab");
const mNavDrift = el("mNavDrift");
const mHeat = el("mHeat");
const mDist = el("mDist");

const dotStab = el("dotStab");
const dotDrift= el("dotDrift");
const dotHeat = el("dotHeat");
const dotDist = el("dotDist");

// Inspector
const inspector = el("inspector");
const iAct = el("iAct");
const iMem = el("iMem");
const iDrift = el("iDrift");
const iCoh = el("iCoh");
const iHeat = el("iHeat");
const iPow  = el("iPow");
const iDist = el("iDist");
const iFail = el("iFail");

// Canvases
const c1 = el("plot1"), g1 = c1.getContext("2d");
const c2 = el("plot2"), g2 = c2.getContext("2d");
const cs = el("schem"), gs = cs.getContext("2d");

// UI binding
function syncLabels(){
  vFail.textContent = fmt(sFail.value,2);
  vPhi.textContent = fmt(sPhi.value,2);
  vKr.textContent  = fmt(sKr.value,2);
  vRb.textContent  = fmt(sRb.value,0);
  vPmax.textContent= fmt(sPmax.value,0);
  vNoise.textContent=fmt(sNoise.value,2);
  vD.textContent   = fmt(sD.value,2);
  vDist.textContent= fmt(sDist.value,2);
  vIntent.textContent=fmt(sIntent.value,2);
}
["input","change"].forEach(evt=>{
  [sFail,sPhi,sKr,sRb,sPmax,sNoise,sD,sDist,sIntent,tgInspect].forEach(x=>x.addEventListener(evt, syncLabels));
});
tgInspect.addEventListener("change", ()=>{
  inspector.style.display = tgInspect.checked ? "block" : "none";
});
syncLabels();

// Simulation state
let running=false;
let t=0;
let lastStamp=0;
let fpsCounter={t0:0, n:0};

let jump = {
  active:false,
  tLeft:0,
  impulse:0,
  marker:0,   // 0..1 flash on plot
};

let state = {
  drift: 0.0,       // Δg
  coherence: 0.0,   // C
  memory: 0.0,      // M
  activation: 0.0,  // a(t)
  navDrift: 0.0,
  dist: parseFloat(sDist.value),
  power: 0.0,
  heat: 20.0,
  lastFailOn:false
};

// Plot buffers
const N=280;
let buf = {
  drift: new Array(N).fill(0),
  coh:   new Array(N).fill(0),
  mem:   new Array(N).fill(0),
  heat:  new Array(N).fill(20),
  pow:   new Array(N).fill(0),
  nav:   new Array(N).fill(0),
  jmk:   new Array(N).fill(0), // jump marker
  fmk:   new Array(N).fill(0), // failure marker
};

function pushBuf(arr, val){
  arr.push(val);
  if (arr.length>N) arr.shift();
}

function setDot(node, cls){
  node.className = "dot " + cls;
}

// Buttons
btnStart.onclick = ()=>{
  running=true;
  modeName.textContent="Running";
};
btnStop.onclick = ()=>{
  running=false;
  modeName.textContent="Paused";
};
btnReset.onclick = ()=>{
  running=false;
  t=0;
  lastStamp=0;
  jump.active=false; jump.tLeft=0; jump.impulse=0; jump.marker=0;
  state.drift=0; state.coherence=0; state.memory=0; state.activation=0; state.navDrift=0;
  state.dist=parseFloat(sDist.value);
  state.power=0; state.heat=20;
  state.lastFailOn = tgFail.checked;

  for (const k in buf) buf[k].fill(k==="heat"?20:0);
  modeName.textContent="Idle";
  drawAll();
  updateReadouts();
};

btnStabilize.onclick = ()=>{
  // Nudge parameters toward typical stable values WITHOUT changing your underlying math
  sPhi.value = Math.max(parseFloat(sPhi.value), 0.72);
  sKr.value  = Math.max(parseFloat(sKr.value), 1.45);
  sD.value   = Math.max(parseFloat(sD.value), 1.10);
  sIntent.value = Math.min(parseFloat(sIntent.value), 0.70);
  syncLabels();
};

btnJump.onclick = ()=>{
  // Warp Jump Event:
  // - causes a burst of translation (distance decreases faster for a short window)
  // - injects transient drift, nav disturbance, and heat load (recovery required)
  // - your CST frame lock should help the recovery if coherence is already high
  if(!running) { running=true; modeName.textContent="Running"; }
  jump.active = true;
  jump.tLeft = 1.4;                 // seconds of jump disturbance
  jump.impulse = 1.0 + 0.6*Math.random(); // random strength
  jump.marker = 1.0;
};

// Model step
function step(dt){
  const phi   = parseFloat(sPhi.value);
  const kr    = parseFloat(sKr.value);
  const Rb    = parseFloat(sRb.value);
  const Pmax  = parseFloat(sPmax.value);
  const noise = parseFloat(sNoise.value);
  const D0    = parseFloat(sD.value);
  const intent= parseFloat(sIntent.value);

  // Failure injection factors
  const failOn = tgFail.checked;
  const sev = parseFloat(sFail.value); // 0..1
  // Effective power and cooling degrade; coupling from noise->drift increases
  const powerEff = failOn ? (1 - 0.55*sev) : 1.0;     // coil effectiveness
  const dissEff  = failOn ? (1 - 0.65*sev) : 1.0;     // cooling effectiveness
  const driftAmp = failOn ? (1 + 0.90*sev) : 1.0;     // disturbance coupling
  const D = clamp(D0 * dissEff, 0.05, 4.0);

  // Base measurement jitter
  let jitter = noise * rndn();

  // Jump event injects extra jitter/drift + translation burst
  let jumpBoost = 0;
  if (jump.active){
    jump.tLeft -= dt;
    jumpBoost = jump.impulse * (0.8 + 0.2*Math.cos((1.4-jump.tLeft)*Math.PI));
    // inject extra disturbances during jump
    jitter += (0.35 + 0.55*noise) * rndn() * jumpBoost;
    // also spike drift and nav drift
    state.drift += dt * (0.65 * jumpBoost) * (0.6 + 0.4*rndn());
    state.navDrift += dt * (0.45 * jumpBoost) * (0.6 + 0.4*rndn());
    // heat spike
    state.heat += dt * (6.0 * jumpBoost);
    if (jump.tLeft <= 0){
      jump.active=false;
      jump.tLeft=0;
    }
  }

  // Activation: “system wakes up” when error exists
  const errorMag = Math.abs(state.drift) + Math.abs(state.navDrift);
  state.activation = clamp(lerp(state.activation, clamp(errorMag*0.70, 0, 1), 0.08), 0, 1);

  // Coherence: driven by φ, k, Rb; penalized by noise & heat
  const heatPenalty = clamp((state.heat - 70)/60, 0, 1);
  const cohDrive = clamp(
    (0.45*phi + 0.35*(kr/3) + 0.20*(Rb/140))
    - (0.55*noise*driftAmp)
    - (0.55*heatPenalty),
    0, 1
  );
  state.coherence = clamp(lerp(state.coherence, cohDrive, 0.06), 0, 1);

  // Memory locking: build only if coherence persists (and lock enabled)
  if (tgLock.checked){
    const lockBuild = clamp((state.coherence - 0.55) * 1.9, 0, 1);
    const lockLeak  = clamp(0.08 + 0.28*noise*driftAmp + 0.22*heatPenalty, 0, 0.85);
    state.memory = clamp(state.memory + dt*(0.58*lockBuild - 0.36*lockLeak*state.memory), 0, 1);
  } else {
    state.memory = clamp(state.memory - dt*0.40*(0.2 + noise*driftAmp), 0, 1);
  }

  // Power demand
  const base = 0.12*Rb;
  const demand = base + 65*intent*state.activation + 40*Math.abs(state.drift) + 15*Math.abs(state.navDrift);
  const efficiency = 0.55 + 0.45*state.coherence + 0.55*state.memory; // more coherence+memory => less work needed
  let targetPower = clamp((demand / clamp(efficiency, 0.25, 1.85)) / powerEff, 0, Pmax);

  // Auto-regulation governor
  if (tgAuto.checked){
    const thermalRisk = clamp((state.heat - 85)/55, 0, 1);
    const driftNeed   = clamp((Math.abs(state.drift) - 0.20)*1.6, 0, 1);
    targetPower = clamp(targetPower * (1 - 0.60*thermalRisk) + (8*driftNeed), 0, Pmax);
  }

  // Apply power dynamics
  state.power = clamp(lerp(state.power, targetPower, 0.10), 0, Pmax);

  // Heat dynamics: heating increases with power and jump; cooling depends on D
  const ambient = 20;
  const heatIn  = 0.025*Math.pow(state.power, 1.2);
  const heatOut = (0.020*D)*(state.heat - ambient);
  state.heat = clamp(state.heat + dt*(heatIn - heatOut), ambient, 240);

  // Drift dynamics
  const driftGrow = dt*(0.14*jitter + 0.10*noise*driftAmp + 0.08*intent*(1-state.coherence)*driftAmp);
  // correction depends on regulation, coherence, and *effective* power fraction
  const powerFrac = (state.power/Math.max(Pmax,1)) * powerEff;
  const correction = dt*(0.24*kr*(0.35 + 0.65*state.coherence) * (0.35 + 0.65*powerFrac));
  const memorySnap = dt*(0.18*state.memory);

  // Pull drift toward 0 + disturbances
  state.drift = state.drift - correction*state.drift + driftGrow;
  // Memory provides resistance (hysteresis-like barrier)
  state.drift = state.drift - memorySnap*0.02*Math.sign(state.drift);
  state.drift = clamp(state.drift, -2.8, 2.8);

  // Navigation drift dynamics
  const navAccum = dt*(0.10*jitter + 0.06*noise*driftAmp);
  const navDamp  = dt*(0.20*(0.30 + 0.70*state.coherence) + 0.35*state.memory);
  state.navDrift = state.navDrift + navAccum - navDamp*state.navDrift;
  state.navDrift = clamp(state.navDrift, -2.0, 2.0);

  // Autopilot translation and jump burst translation
  const stable = clamp(
    (state.coherence*0.6 + state.memory*0.4)
    - 0.25*Math.abs(state.drift)
    - 0.10*Math.abs(state.navDrift),
    0, 1
  );

  let vWarp = 0.0;
  if (tgNav.checked){
    vWarp = (0.010 + 0.060*intent) * stable;
  } else {
    vWarp = 0.008*intent*stable;
  }

  // Jump adds temporary translation multiplier (but also destabilizes)
  if (jumpBoost > 0){
    vWarp *= (1.0 + 3.5*jumpBoost); // burst
  }

  state.dist = Math.max(0, state.dist - dt*vWarp);

  // Markers
  jump.marker = Math.max(0, jump.marker - dt*0.9); // fade
  const failMarker = failOn ? 1 : 0;

  // Buffers
  pushBuf(buf.drift, state.drift);
  pushBuf(buf.coh,   state.coherence);
  pushBuf(buf.mem,   state.memory);
  pushBuf(buf.heat,  state.heat);
  pushBuf(buf.pow,   state.power);
  pushBuf(buf.nav,   state.navDrift);
  pushBuf(buf.jmk,   jump.marker);
  pushBuf(buf.fmk,   failMarker);

  // Keep failure edge visible if toggled
  state.lastFailOn = failOn;

  // Inspector
  if (tgInspect.checked){
    iAct.textContent = fmt(state.activation,3);
    iMem.textContent = fmt(state.memory,3);
    iDrift.textContent= fmt(state.drift,3);
    iCoh.textContent = fmt(state.coherence,3);
    iHeat.textContent= fmt(state.heat,1);
    iPow.textContent = fmt(state.power,1);
    iDist.textContent= fmt(state.dist,2);
    iFail.textContent= fmt((failOn? (1 - 0.55*sev):1.0),2);
  }
}

// Readouts
function updateReadouts(){
  simTime.textContent = `t=${fmt(t,2)}s`;

  const stability = clamp(
    (state.coherence*0.55 + state.memory*0.45)
    - 0.20*Math.abs(state.drift)
    - 0.10*Math.abs(state.navDrift),
    0, 1
  );

  const navd = Math.abs(state.navDrift);
  mStab.textContent = fmt(stability,2);
  mNavDrift.textContent = fmt(navd,2);
  mHeat.textContent = fmt(state.heat,1);
  mDist.textContent = fmt(state.dist,2);

  setDot(dotStab, stability>0.70 ? "ok" : stability>0.45 ? "warn" : "bad");
  setDot(dotDrift, navd<0.35 ? "ok" : navd<0.85 ? "warn" : "bad");
  setDot(dotHeat, state.heat<90 ? "ok" : state.heat<130 ? "warn" : "bad");
  setDot(dotDist, state.dist<0.50 ? "warn" : "ok");
}

// Drawing helpers
function clearCanvas(ctx, c){
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle = "rgba(10,14,28,0.35)";
  ctx.fillRect(0,0,c.width,c.height);
  ctx.strokeStyle = "rgba(34,48,95,0.65)";
  ctx.lineWidth = 1;
  const gx=10, gy=6;
  for(let i=1;i<gx;i++){
    const x = (c.width/gx)*i;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,c.height); ctx.stroke();
  }
  for(let j=1;j<gy;j++){
    const y = (c.height/gy)*j;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(c.width,y); ctx.stroke();
  }
}

function plotSeries(ctx, c, series, yMin, yMax){
  const w=c.width, h=c.height;
  const n=series.length;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const x = (i/(n-1))*w;
    const y = h - ((series[i]-yMin)/(yMax-yMin))*h;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

function drawMarker(ctx, c, markerArr){
  // markerArr 0..1 -> draw vertical pulses
  const w=c.width, h=c.height, n=markerArr.length;
  ctx.save();
  ctx.strokeStyle="rgba(233,238,255,0.35)";
  ctx.lineWidth=1.5;
  for(let i=0;i<n;i++){
    const m = markerArr[i];
    if(m<=0.02) continue;
    const x = (i/(n-1))*w;
    ctx.globalAlpha = clamp(m,0,1);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }
  ctx.restore();
}

// Ship schematic drawing
function drawSchematic(){
  gs.clearRect(0,0,cs.width,cs.height);
  gs.fillStyle="rgba(10,14,28,0.35)";
  gs.fillRect(0,0,cs.width,cs.height);

  // Title
  gs.fillStyle="rgba(170,180,230,0.95)";
  gs.font="14px system-ui";
  gs.fillText("Ship Schematic: Coils → Bubble Boundary → CST Solver → Phase Align → Frame Lock → Guidance", 16, 22);

  // Layout anchors
  const W=cs.width, H=cs.height;

  // Ship body (center)
  const ship = {x: W*0.30, y: H*0.52, w: W*0.30, h: H*0.30};
  // Bubble ring
  const bubble = {cx: ship.x+ship.w*0.55, cy: ship.y+ship.h*0.50, r: Math.min(W,H)*0.18};

  // Right-side modules (solver, phase, memory, guidance)
  const boxW = W*0.22, boxH = 48;
  const bx1 = W*0.67, by1 = H*0.28;
  const modules = [
    {name:"CST Frame Solver", x:bx1, y:by1,        w:boxW, h:boxH},
    {name:"Phase Align (φₛₜ)", x:bx1, y:by1+66,    w:boxW, h:boxH},
    {name:"Frame Lock Memory (M)", x:bx1, y:by1+132, w:boxW, h:boxH},
    {name:"Guidance Output", x:bx1, y:by1+198,     w:boxW, h:boxH},
  ];

  // Coils (left)
  const coils = [
    {x: ship.x+ship.w*0.08, y: ship.y+ship.h*0.25, r: 18, label:"Field Coil A"},
    {x: ship.x+ship.w*0.08, y: ship.y+ship.h*0.52, r: 18, label:"Field Coil B"},
    {x: ship.x+ship.w*0.08, y: ship.y+ship.h*0.79, r: 18, label:"Field Coil C"},
  ];

  // Draw ship body
  gs.save();
  gs.fillStyle="rgba(18,26,51,0.85)";
  gs.strokeStyle="rgba(122,162,255,0.55)";
  gs.lineWidth=2;
  roundRect(gs, ship.x, ship.y, ship.w, ship.h, 18, true, true);

  // Nose cone
  gs.beginPath();
  gs.moveTo(ship.x+ship.w, ship.y+ship.h*0.20);
  gs.lineTo(ship.x+ship.w*1.18, ship.y+ship.h*0.50);
  gs.lineTo(ship.x+ship.w, ship.y+ship.h*0.80);
  gs.closePath();
  gs.fillStyle="rgba(18,26,51,0.75)";
  gs.fill();
  gs.stroke();

  gs.fillStyle="rgba(233,238,255,0.85)";
  gs.font="12px system-ui";
  gs.fillText("Hull / Engine Bay", ship.x+12, ship.y+18);
  gs.restore();

  // Draw coils
  coils.forEach((c,i)=>{
    gs.save();
    gs.beginPath();
    gs.arc(c.x, c.y, c.r, 0, Math.PI*2);
    gs.fillStyle="rgba(122,162,255,0.22)";
    gs.fill();
    gs.strokeStyle="rgba(122,162,255,0.85)";
    gs.lineWidth=2;
    gs.stroke();
    gs.fillStyle="rgba(170,180,230,0.90)";
    gs.font="12px system-ui";
    gs.fillText(c.label, c.x+28, c.y+4);
    gs.restore();
  });

  // Bubble boundary ring (changes with Rb visually)
  const Rb = parseFloat(sRb.value);
  const phi = parseFloat(sPhi.value);
  const kr = parseFloat(sKr.value);

  const bubbleScale = clamp(Rb/140, 0.15, 1.0);
  const r = bubble.r*(0.55 + 0.55*bubbleScale);

  gs.save();
  gs.beginPath();
  gs.arc(bubble.cx, bubble.cy, r, 0, Math.PI*2);
  gs.strokeStyle="rgba(53,230,162,0.75)";
  gs.lineWidth=3;
  gs.stroke();

  // inner ring (coherence indicator)
  const cohRing = r*(0.55 + 0.35*state.coherence);
  gs.beginPath();
  gs.arc(bubble.cx, bubble.cy, cohRing, 0, Math.PI*2);
  gs.strokeStyle="rgba(255,209,90,0.70)";
  gs.lineWidth=2;
  gs.stroke();

  // label bubble
  gs.fillStyle="rgba(170,180,230,0.92)";
  gs.font="12px system-ui";
  gs.fillText(`Bubble Boundary (Rᵦ≈${Math.round(Rb)})`, bubble.cx - r, bubble.cy - r - 10);
  gs.fillText(`Coherence ring (C≈${fmt(state.coherence,2)})`, bubble.cx - r, bubble.cy - r - 26);
  gs.restore();

  // Modules (right)
  modules.forEach((m,idx)=>{
    gs.save();
    gs.fillStyle="rgba(10,14,28,0.45)";
    gs.strokeStyle="rgba(122,162,255,0.55)";
    gs.lineWidth=2;
    roundRect(gs, m.x, m.y, m.w, m.h, 12, true, true);
    gs.fillStyle="rgba(233,238,255,0.92)";
    gs.font="12px system-ui";
    gs.fillText(m.name, m.x+10, m.y+20);
    gs.fillStyle="rgba(170,180,230,0.80)";
    gs.font="11px system-ui";

    if(idx===0) gs.fillText(`Inputs: star clocks + σ + Δg`, m.x+10, m.y+36);
    if(idx===1) gs.fillText(`φₛₜ=${fmt(phi,2)}  kᵣ=${fmt(kr,2)}`, m.x+10, m.y+36);
    if(idx===2) gs.fillText(`M=${fmt(state.memory,2)}  barrier`, m.x+10, m.y+36);
    if(idx===3) gs.fillText(`intent=${fmt(parseFloat(sIntent.value),2)}`, m.x+10, m.y+36);

    gs.restore();
  });

  // Arrows: coils -> bubble, bubble -> solver, solver -> phase -> lock -> guidance, guidance -> coils
  const arrow = (x1,y1,x2,y2, txt)=>{
    drawArrow(gs, x1,y1,x2,y2, "rgba(233,238,255,0.70)");
    if(txt){
      gs.save();
      gs.fillStyle="rgba(170,180,230,0.90)";
      gs.font="11px system-ui";
      gs.fillText(txt, (x1+x2)/2 + 6, (y1+y2)/2 - 6);
      gs.restore();
    }
  };

  // coils to bubble
  arrow(coils[0].x+18, coils[0].y, bubble.cx-r*0.85, bubble.cy-r*0.25, "field");
  arrow(coils[1].x+18, coils[1].y, bubble.cx-r*0.95, bubble.cy, "shape");
  arrow(coils[2].x+18, coils[2].y, bubble.cx-r*0.85, bubble.cy+r*0.25, "regulate");

  // bubble to solver
  arrow(bubble.cx + r, bubble.cy - r*0.10, modules[0].x, modules[0].y + modules[0].h*0.60, "measure Δg");

  // solver chain
  arrow(modules[0].x + modules[0].w*0.95, modules[0].y + modules[0].h*0.50, modules[1].x + modules[1].w*0.95, modules[1].y + modules[1].h*0.50, "");
  arrow(modules[1].x + modules[1].w*0.95, modules[1].y + modules[1].h*0.50, modules[2].x + modules[2].w*0.95, modules[2].y + modules[2].h*0.50, "");
  arrow(modules[2].x + modules[2].w*0.95, modules[2].y + modules[2].h*0.50, modules[3].x + modules[3].w*0.95, modules[3].y + modules[3].h*0.50, "");

  // guidance back to coils
  arrow(modules[3].x, modules[3].y + modules[3].h*0.55, ship.x + ship.w*0.08, ship.y + ship.h*0.50, "drive coils");

  // Failure overlay indicator
  if (tgFail.checked){
    const sev = parseFloat(sFail.value);
    gs.save();
    gs.fillStyle = `rgba(255,107,139,${0.12 + 0.18*sev})`;
    gs.fillRect(0,0,W,H);
    gs.fillStyle="rgba(255,209,90,0.92)";
    gs.font="13px system-ui";
    gs.fillText(`FAILURE INJECT ON (severity ${fmt(sev,2)})`, 16, H-16);
    gs.restore();
  }

  // Jump overlay indicator
  if (jump.active || jump.marker>0.1){
    gs.save();
    gs.globalAlpha = clamp(jump.marker,0,1)*0.35;
    gs.fillStyle="rgba(233,238,255,0.65)";
    gs.fillRect(0,0,W,H);
    gs.globalAlpha = 1;
    gs.fillStyle="rgba(233,238,255,0.92)";
    gs.font="13px system-ui";
    gs.fillText("WARP JUMP EVENT: burst translation + recovery", 16, 44);
    gs.restore();
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

function drawArrow(ctx, x1,y1,x2,y2, color){
  const head=10;
  const dx=x2-x1, dy=y2-y1;
  const ang=Math.atan2(dy,dx);
  ctx.save();
  ctx.strokeStyle=color;
  ctx.fillStyle=color;
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-head*Math.cos(ang-Math.PI/7), y2-head*Math.sin(ang-Math.PI/7));
  ctx.lineTo(x2-head*Math.cos(ang+Math.PI/7), y2-head*Math.sin(ang+Math.PI/7));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Plots
function drawAll(){
  // Plot 1: drift, coherence, memory + jump marker
  clearCanvas(g1, c1);
  g1.save();
  g1.strokeStyle="rgba(255,209,90,0.95)"; // Δg
  g1.lineWidth=2;
  plotSeries(g1,c1,buf.drift,-2.8,2.8);

  g1.strokeStyle="rgba(53,230,162,0.95)"; // C
  g1.lineWidth=2;
  plotSeries(g1,c1,buf.coh,0,1);

  g1.strokeStyle="rgba(122,162,255,0.95)"; // M
  g1.lineWidth=2;
  plotSeries(g1,c1,buf.mem,0,1);

  // Jump marker pulses
  drawMarker(g1, c1, buf.jmk);

  g1.fillStyle="rgba(170,180,230,0.90)";
  g1.font="12px system-ui";
  g1.fillText("Δg (drift) | C (coherence) | M (memory) | vertical flash = jump", 10, 18);
  g1.restore();

  // Plot 2: heat, power, nav drift + failure marker strip
  clearCanvas(g2, c2);
  g2.save();

  g2.strokeStyle="rgba(255,107,139,0.95)"; // heat
  g2.lineWidth=2;
  plotSeries(g2,c2,buf.heat,20,220);

  g2.strokeStyle="rgba(122,162,255,0.95)"; // power
  g2.lineWidth=2;
  plotSeries(g2,c2,buf.pow,0,parseFloat(sPmax.value));

  g2.strokeStyle="rgba(255,209,90,0.95)"; // nav
  g2.lineWidth=2;
  plotSeries(g2,c2,buf.nav,-2.0,2.0);

  // Failure strip at top
  const w=c2.width, h=c2.height;
  g2.save();
  g2.globalAlpha=0.25;
  for(let i=0;i<buf.fmk.length;i++){
    if(buf.fmk[i]<0.5) continue;
    const x = (i/(buf.fmk.length-1))*w;
    g2.fillStyle="rgba(255,107,139,0.9)";
    g2.fillRect(x, 0, 2, 14);
  }
  g2.restore();

  g2.fillStyle="rgba(170,180,230,0.90)";
  g2.font="12px system-ui";
  g2.fillText("T (heat) | P (power) | nav drift | top strip = failure ON", 10, 18);
  g2.restore();

  // Schematic
  drawSchematic();
}

// Loop
function loop(ts){
  requestAnimationFrame(loop);

  if(!running){
    drawAll();
    updateReadouts();
    return;
  }

  if(!lastStamp) lastStamp=ts;
  let dt=(ts-lastStamp)/1000;
  lastStamp=ts;
  dt = clamp(dt, 0.001, 0.05);

  t += dt;

  // Keep initial distance sync only at start
  if(t<0.2) state.dist=parseFloat(sDist.value);

  step(dt);
  updateReadouts();
  drawAll();

  // FPS estimate
  fpsCounter.n++;
  if(!fpsCounter.t0) fpsCounter.t0=ts;
  const span=(ts-fpsCounter.t0)/1000;
  if(span>0.6){
    hzEl.textContent = `${Math.round(fpsCounter.n/span)} Hz`;
    fpsCounter.n=0; fpsCounter.t0=ts;
  }
}

drawAll();
updateReadouts();
requestAnimationFrame(loop);
</script>
</body>
</html>
