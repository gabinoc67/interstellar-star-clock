<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Warp Engine Demo + Relativistic Calculator (All-in-One)</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;background:#070a16;color:#eaf0ff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1320px;margin:12px auto;padding:16px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:16px}
  .panel{background:#0c1326;border:1px solid #1f2b48;border-radius:12px;padding:12px}
  h1{margin:4px 0 10px;font-size:20px}
  h2{margin:8px 0;font-size:14px;color:#b8c4ff}
  label{font-size:13px;color:#b8c4ff}
  input[type=range],select, input[type=number], input[type=text]{width:100%}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .small{font-size:12px;color:#9fb3ff}
  .muted{font-size:12px;color:#7d96d6}
  button{background:#1b2a57;color:#eaf0ff;border-radius:8px;padding:8px 10px;border:1px solid #22305c;cursor:pointer}
  button.primary{background:#3355ff}
  canvas{width:100%;height:760px;border-radius:8px;background:radial-gradient(1200px 760px at 45% 45%, #0a1634 0%, #050816 60%)}
  .trow{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px dashed #152040}
  .tname{color:#9fb3ff;font-size:13px}
  .tval{font-variant-numeric:tabular-nums}
  .tests{margin-top:6px;font-size:12px;color:#9fb3ff}
  .demoBar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .badge{background:#1b2a57;border:1px solid #22305c;border-radius:999px;padding:4px 10px;font-size:12px}
  /* Calculator styles */
  .calc-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .out{font-family:monospace;background:#081427;padding:10px;border-radius:8px;border:1px solid #202f4d}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  td,th{padding:6px;border-bottom:1px dashed #1d2c4a;text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <div class="demoBar">
    <div class="badge">
      Order: <strong>Temporal Synchronizer → Control Core → Quantum Sensors → RF Stack → HTS Coil Lattice → Resonant Chamber → Power Block → Cryostat & Vacuum → Metamaterial Rings</strong>
    </div>
    <div class="row">
      <button id="btnDemo" class="primary">▶ Run Demo</button>
      <button id="btnStopDemo">■ Stop Demo</button>
    </div>
  </div>

  <h1>Warp Engine Demo + Relativistic Calculator</h1>
  <p class="small">
    Engine visuals unchanged (fan/intake, compression A/B/C, warp coils, reactors, mixer, nozzle, storage rings, particles). “Run Demo” sweeps Warp 1↔10 automatically while UTC/CST/Warp clocks, temps, field stretch (left↔right), and plasma cone update live.  
    The calculator panel below computes **mass ratio**, **energy**, and **proper time** for targets like **0.9c**.
  </p>

  <div class="grid">
    <!-- LEFT: Controls -->
    <div class="panel">
      <h2>1) Temporal Synchronizer</h2>
      <div class="row">
        <label class="small">Sync mode</label>
        <select id="syncMode"><option value="auto">Auto Lock (CST)</option><option value="manual">Manual</option><option value="utc">External UTC</option></select>
      </div>
      <div class="row">
        <label class="small">Mode</label>
        <select id="driveMode"><option value="ftl">FTL (theoretical)</option><option value="cruise">Near-term 1 g Cruise</option></select>
      </div>
      <div class="row">
        <label class="small">Warp factor</label>
        <input id="warp" type="range" min="1" max="10" step="1" value="3"/>
        <div class="small" id="warpVal">Warp: 3</div>
      </div>

      <h2>2) Control Core (AI + CLF/SMC/PTAC)</h2>
      <label class="small">AI curvature shaping gain</label><input id="aiGain" type="range" min="0" max="1" step="0.01" value="0.70"/>
      <label class="small">CLF gain</label><input id="clf" type="range" min="0.1" max="5" step="0.1" value="1.3"/>
      <label class="small">SMC robustness</label><input id="smc" type="range" min="0" max="1" step="0.01" value="0.60"/>
      <label class="small">PTAC time (s)</label><input id="ptac" type="range" min="0.5" max="20" step="0.5" value="4"/>

      <h2>3) Quantum Sensors</h2>
      <label class="small">Biometric/pressure squeezing (dB)</label><input id="squeeze" type="range" min="0" max="18" step="0.1" value="6.0"/>
      <label class="small">Spacetime stress gain</label><input id="stress" type="range" min="0.1" max="4" step="0.1" value="1.0"/>
      <label class="small">Entanglement population (M)</label><input id="entPop" type="range" min="1" max="1000" step="1" value="120"/>

      <h2>4) RF Stack (Magnetic nozzle)</h2>
      <label class="small">RF Power (kW)</label><input id="rfPower" type="range" min="10" max="2000" step="10" value="300"/>
      <label class="small">ECR (GHz)</label><input id="ecr" type="range" min="0.5" max="14" step="0.1" value="2.45"/>
      <label class="small">Nozzle B<sub>throat</sub> (T)</label><input id="bth" type="range" min="0.01" max="1.0" step="0.01" value="0.15"/>

      <h2>5) HTS Coil Lattice</h2>
      <label class="small">Coil current scale</label><input id="coilScale" type="range" min="0.2" max="3" step="0.05" value="1.0"/>
      <label class="small">Lattice resonance tune</label><input id="latticeTune" type="range" min="0" max="1" step="0.01" value="0.45"/>

      <h2>6) Resonant Chamber</h2>
      <label class="small">Resonant Q</label><input id="qFactor" type="range" min="10" max="2000" step="10" value="420"/>
      <label class="small">Resonant freq (Hz)</label><input id="resFreq" type="range" min="1" max="2000" step="1" value="314"/>

      <h2>7) Power Block</h2>
      <label class="small">Peak power (kW equiv)</label><input id="peakP" type="range" min="100" max="50000" step="100" value="5000"/>
      <label class="small">Baseline power (kW)</label><input id="baseP" type="range" min="10" max="2000" step="10" value="500"/>

      <h2>8) Cryostat & Vacuum</h2>
      <label class="small">Cryo temp (K)</label><input id="cryo" type="range" min="2" max="300" step="1" value="20"/>
      <label class="small">Vacuum quality (10<sup>−x</sup> Pa)</label><input id="vacPow" type="range" min="3" max="12" step="0.1" value="6"/>

      <h2>9) Metamaterial Rings (MFEF)</h2>
      <label class="small">MFEF tuning (0–1)</label><input id="metaTune" type="range" min="0" max="1" step="0.01" value="0.48"/>
      <label class="small">Layer coupling</label><input id="metaCouple" type="range" min="0" max="1" step="0.01" value="0.62"/>

      <div class="row" style="margin-top:10px">
        <button id="play">Start</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
        <span class="muted" style="margin-left:auto">Clocks: CST/UTC/Warp</span>
      </div>

      <div id="tests" class="tests">Self-tests: (pending)</div>
    </div>

    <!-- RIGHT: Visualization + telemetry -->
    <div class="panel">
      <canvas id="view" width="900" height="760"></canvas>
      <h2 class="small">Telemetry</h2>
      <div id="tgrid"></div>
    </div>
  </div>

  <!-- CALCULATOR -->
  <div class="panel" style="margin-top:12px">
    <h2>Relativistic Rocket Calculator (0.9c & beyond)</h2>
    <p class="small">Implements: rapidity φ = atanh(v/c), mass ratio m₀/m_f = exp( φ / (vₑ/c) ), proper time τ = c·atanh(v/c)/a, energy E = (γ−1) m c². Use to see why 0.9c needs exhaust speeds that are a large fraction of c.</p>
    <div class="calc-grid">
      <div>
        <label>Preset exhaust vₑ</label>
        <select id="preset">
          <option value="">— custom —</option>
          <option value="4.5e3">Chemical (vₑ ≈ 4.5 km/s)</option>
          <option value="7.0e4">Ion (vₑ ≈ 70 km/s)</option>
          <option value="2.0e5">High electric (vₑ ≈ 200 km/s)</option>
          <option value="0.05c">Fusion (vₑ = 0.05 c)</option>
          <option value="0.1c">Aggressive fusion (vₑ = 0.1 c)</option>
          <option value="0.5c">Antimatter-like (vₑ = 0.5 c)</option>
          <option value="0.9c">Near photon (vₑ = 0.9 c)</option>
        </select>

        <label>Payload mass m_f (kg)</label><input id="m_payload" type="number" value="1000" min="0.001" step="1"/>

        <label>Target velocity v (fraction of c)</label><input id="vfrac" type="number" value="0.9" step="0.01" min="0.0001" max="0.9999"/>

        <label>Exhaust velocity vₑ — enter absolute (m/s) or fraction of c (e.g. 0.1c)</label><input id="ve_input" type="text" value="0.5c"/>

        <label>Proper acceleration a (m/s²) for τ</label><input id="accel" type="number" value="9.80665" step="0.01"/>

        <div class="row" style="margin-top:10px">
          <button id="compute" class="primary">Compute</button>
          <button id="resetCalc">Reset</button>
          <button id="sendToDemo">Set Demo to 1 g Cruise</button>
        </div>
        <p class="small">Tip: Click “Set Demo to 1 g Cruise” to sync the engine demo to a realistic sub-c mode.</p>
      </div>

      <div>
        <div class="out">
          <div><strong>Target v (c):</strong> <span id="r_v">—</span></div>
          <div><strong>Rapidity φ:</strong> <span id="r_phi">—</span></div>
          <div><strong>Exhaust vₑ:</strong> <span id="r_ve">—</span> m/s (<span id="r_ve_c">—</span> c)</div>
          <div><strong>ln(m₀/m_f):</strong> <span id="r_ln">—</span></div>
          <div><strong>Mass ratio m₀/m_f:</strong> <span id="r_mratio">—</span> (<span id="r_log10">log10 = —</span>)</div>
          <div><strong>Initial mass m₀ (kg):</strong> <span id="r_m0">—</span></div>
          <div><strong>γ (Lorentz factor):</strong> <span id="r_gamma">—</span></div>
          <div><strong>Energy E:</strong> <span id="r_energy">—</span> J (<span id="r_energy_Mt">—</span> Mt TNT)</div>
          <div><strong>Equivalent mass E/c²:</strong> <span id="r_antiequiv">—</span> kg</div>
          <div><strong>Proper time τ:</strong> <span id="r_tau">—</span> s = <span id="r_tau_read">—</span></div>
        </div>
        <h3 style="margin-top:10px">Diagnostics</h3>
        <table><thead><tr><th>Quantity</th><th>Value</th></tr></thead><tbody id="diag"></tbody></table>
        <p id="interpret" class="muted" style="margin-top:10px">Compute to see interpretation & guidance.</p>
      </div>
    </div>
  </div>
</div>

<script>
/* ===========================
   SHARED HELPERS
=========================== */
const $=id=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const TAU=Math.PI*2;

/* ===========================
   DEMO (rocket visuals & telemetry)
=========================== */
const canvas=$('view'), ctx=canvas.getContext('2d');
const syncMode=$('syncMode'), driveMode=$('driveMode'), warpEl=$('warp'), warpVal=$('warpVal');
const aiGain=$('aiGain'), clfEl=$('clf'), smcEl=$('smc'), ptacEl=$('ptac');
const squeezeEl=$('squeeze'), stressEl=$('stress'), entPopEl=$('entPop');
const rfPowerEl=$('rfPower'), ecrEl=$('ecr'), bthEl=$('bth');
const coilScaleEl=$('coilScale'), latticeTuneEl=$('latticeTune');
const qFactorEl=$('qFactor'), resFreqEl=$('resFreq');
const peakPEl=$('peakP'), basePEl=$('baseP');
const cryoEl=$('cryo'), vacPowEl=$('vacPow');
const metaTuneEl=$('metaTune'), metaCoupleEl=$('metaCouple');
const playBtn=$('play'), pauseBtn=$('pause'), resetBtn=$('reset');
const btnDemo=$('btnDemo'), btnStopDemo=$('btnStopDemo');
const tgrid=$('tgrid'), testsEl=$('tests');

let running=false, t0=performance.now(), warpClock=Date.now();
let vCruise=0; const g0=9.80665; // m/s^2
let fanAngle=0;
let demoTimer=null, demoDir=+1, demoSpeedMs=700;

let photons=[], heat=[], coolant=[], entangle=[];
function spawnPhoton(speed){ const y=380+(Math.random()*2-1)*60; photons.push({x:240,y,spd:speed*(0.9+Math.random()*0.2)}); }
function spawnHeat(speed){ const y=380+(Math.random()*2-1)*40; heat.push({x:380+Math.random()*160,y,life:0,spd:0.7*speed}); }
function spawnCool(speed){ const y=380+(Math.random()*2-1)*70; coolant.push({x:180+Math.random()*140,y,life:0,spd:0.5*speed}); }
function spawnEntangle(speed){ const phase=Math.random()*TAU; entangle.push({x:420+Math.random()*40,y:380,phase,life:0,spd:0.9*speed}); }

function speedMult(w){ return lerp(1,6,(w-1)/9); }
function clockRate(w){ return 1/lerp(1,1.6,(w-1)/9); }
function fieldRadius(w){ return lerp(1.2,2.6,(w-1)/9); }
function aspectX(w){ return lerp(1.0,1.9,(w-1)/9); }
function aspectY(w){ return lerp(0.9,0.6,(w-1)/9); }
function plasmaLen(w){ return Math.round(lerp(90,260,(w-1)/9)); }
function plasmaRad(w){ return Math.round(lerp(10,36,(w-1)/9)); }
function heatLevel(w){ return lerp(0.35,1.0,(w-1)/9); }
function coolLevel(w){ return 1-heatLevel(w)*0.5; }
function mferGain(){ return clamp(0.6 + 0.6*(+metaTuneEl.value) + 0.3*(+coilScaleEl.value-1)/2,0.6,1.6); }
function coreTempC(w){ return Math.round(220 + heatLevel(w)*950 + (+rfPowerEl.value)/6); }
function coolantTempC(w){ return Math.round(25 + coolLevel(w)*300); }
function stabilityIndex(){
  const clf=+clfEl.value, smc=+smcEl.value, pt=+ptacEl.value, ai=+aiGain.value;
  const sq=+squeezeEl.value, ent=+entPopEl.value, stress=+stressEl.value;
  const sensor=clamp((sq/18)*0.45 + clamp(ent/1000,0,1)*0.25 + clamp(stress/4,0,1)*0.30,0,1);
  const ctrl  =clamp((clf/5)*0.35 + smc*0.35 + (20/pt)*0.10 + ai*0.20,0,1);
  return clamp(0.65*ctrl + 0.35*sensor,0,1);
}
function detachmentMetric(){ const bth=+bthEl.value, rf=+rfPowerEl.value; return clamp((bth/0.25)*0.6 + clamp(rf/1200,0,1)*0.4,0,1); }
function instabilityMetric(){ const q=+qFactorEl.value, rf=+rfPowerEl.value, tune=+latticeTuneEl.value;
  const base=clamp(q/2000,0,1)*0.6 + clamp(rf/2000,0,1)*0.4; return clamp(base*(1-0.6*tune),0,1); }

const tele = {
 'UTC':'--:--:--','CST':'--:--:--','Warp time':'--:--:--',
 'Mode':'FTL','Warp':'3','Stability':'nominal','Detachment':'nominal','Instability':'low',
 'Field radius(×D)':'1.20','Field stretch rx/ry':'--','MFEF gain':'1.00',
 'Core °C':'--','Coolant °C':'--','RF Power(kW)':'300','B_throat(T)':'0.15','ECR(GHz)':'2.45',
 'AI curvature':'0.70','CLF':'1.30','SMC':'0.60','PTAC(s)':'4',
 'MetaTune':'0.48','MetaCouple':'0.62','CoilScale':'1.0','Q':'420','Res(Hz)':'314',
 'Cryo(K)':'20','Vac(Pa)':'1e-6','Plasma Len':'--','Plasma Rad':'--','1g accel (m/s²)':'9.81','Cruise v (km/s)':'0.00'
};
function renderTele(){
  const tgrid=$('tgrid'); tgrid.innerHTML='';
  for(const k in tele){
    const r=document.createElement('div'); r.className='trow';
    const n=document.createElement('div'); n.className='tname'; n.textContent=k;
    const v=document.createElement('div'); v.className='tval'; v.textContent=tele[k];
    r.appendChild(n); r.appendChild(v); tgrid.appendChild(r);
  }
}

const L={cx:480,cy:380}, fieldBase={rx:130,ry:80};
function drawSubsystemRail(){
  const names=['Temporal','Control','Quantum','RF Stack','HTS Lattice','Resonant','Power','Cryo','Metamaterial'];
  for(let i=0;i<names.length;i++){
    const x=80+i*80, y=120;
    ctx.fillStyle='#11224a'; ctx.fillRect(x-28,y-28,56,56);
    ctx.strokeStyle='#2a4a8a'; ctx.strokeRect(x-28,y-28,56,56);
    ctx.fillStyle='#dbe9ff'; ctx.font='12px system-ui'; ctx.fillText(names[i], x-26, y+44);
  }
  // storage rings (visual)
  const ring=clamp((+peakPEl.value)/50000,0,1);
  ctx.strokeStyle=`rgba(123,255,182,${0.25+0.6*ring})`;
  for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(L.cx, 180, 30+i*12, 0, TAU); ctx.lineWidth=2; ctx.stroke(); }
}
function drawField(w){
  const rx=fieldBase.rx*aspectX(w)*mferGain(), ry=fieldBase.ry*aspectY(w);
  ctx.strokeStyle='rgba(51,225,181,0.28)'; ctx.lineWidth=3;
  for(let i=0;i<5;i++){ ctx.beginPath(); ctx.ellipse(L.cx, L.cy, rx+i*16, ry+i*8, 0, 0, TAU); ctx.stroke(); }
  return {rx:Math.round(rx+32), ry:Math.round(ry+16)};
}
function drawPlasma(w){
  const len=plasmaLen(w), rad=plasmaRad(w), x0=L.cx+120;
  const g=ctx.createLinearGradient(x0,L.cy-10,x0+len,L.cy-10);
  g.addColorStop(0,'rgba(255,220,168,0.80)'); g.addColorStop(1,'rgba(255,220,168,0.03)');
  ctx.fillStyle=g; ctx.beginPath();
  ctx.moveTo(x0, L.cy-rad); ctx.lineTo(x0+len, L.cy-rad*0.35);
  ctx.lineTo(x0+len, L.cy+rad*0.35); ctx.lineTo(x0, L.cy+rad); ctx.closePath(); ctx.fill();
  return {len,rad};
}
function drawFan(angle){ const cx=160, cy=L.cy;
  ctx.fillStyle='#a4b2d8'; ctx.beginPath(); ctx.arc(cx, cy, 28, 0, TAU); ctx.fill();
  for(let i=0;i<6;i++){ const a=angle + i*TAU/6, r1=12, r2=46;
    ctx.fillStyle='#c7d4ff'; ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
    ctx.lineTo(cx+Math.cos(a+0.18)*r2, cy+Math.sin(a+0.18)*r2);
    ctx.lineTo(cx+Math.cos(a+0.36)*r1, cy+Math.sin(a+0.36)*r1);
    ctx.closePath(); ctx.fill();
  }
  // casimir valve halo
  ctx.strokeStyle='#ff7be3aa'; ctx.lineWidth=2;
  for(let k=0;k<3;k++){ ctx.beginPath(); ctx.arc(cx, cy, 60+k*10, 0, TAU); ctx.stroke(); }
}
function drawEngineBody(){
  const sections=[
    {x0:120,len:140,r:118},{x0:260,len:110,r:108},{x0:370,len:90,r:100},
    {x0:460,len:70,r:92},{x0:530,len:60,r:84},{x0:590,len:60,r:76},{x0:650,len:50,r:68}
  ];
  sections.forEach(s=>{
    const x1=s.x0+s.len;
    const grad=ctx.createLinearGradient(0, L.cy-s.r, 0, L.cy+s.r);
    grad.addColorStop(0,'#2a334d'); grad.addColorStop(0.5,'#9fb1ff22'); grad.addColorStop(1,'#0e132b');
    ctx.fillStyle=grad; ctx.beginPath();
    ctx.moveTo(s.x0, L.cy-s.r); ctx.lineTo(x1, L.cy-s.r); ctx.lineTo(x1, L.cy+s.r); ctx.lineTo(s.x0, L.cy+s.r);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#22305c'; ctx.lineWidth=1; ctx.stroke();
  });
  // nozzle
  const nz={x0:700,x1:840,r0:58,r1:12};
  const g=ctx.createLinearGradient(nz.x0,L.cy,nz.x1,L.cy); g.addColorStop(0,'#2a334d'); g.addColorStop(1,'#9bb4ff');
  ctx.fillStyle=g; ctx.beginPath();
  ctx.moveTo(nz.x0, L.cy-nz.r0); ctx.lineTo(nz.x1, L.cy-nz.r1);
  ctx.lineTo(nz.x1, L.cy+nz.r1); ctx.lineTo(nz.x0, L.cy+nz.r0);
  ctx.closePath(); ctx.fill(); ctx.strokeStyle='#22305c'; ctx.stroke();
}
function drawPipes(speed){
  const joints=[260,370,460,530,590,650,700];
  ctx.strokeStyle='#6bd1ff'; ctx.lineWidth=3;
  joints.forEach(x=>{
    ctx.beginPath(); ctx.moveTo(x-6, L.cy+24); ctx.lineTo(x+6, L.cy+24); ctx.stroke();
    const n=4; for(let k=0;k<n;k++){
      const t=((k/n)+(performance.now()*0.0005*speed))%1;
      const xx=(x-6)+(12*t);
      ctx.beginPath(); ctx.arc(xx, L.cy+24, 2, 0, TAU); ctx.fillStyle='#9bb4ff'; ctx.fill();
    }
  });
}
function drawCoolingLoops(){
  const y=L.cy+118; ctx.strokeStyle='#6bd1ff'; ctx.lineWidth=2;
  ctx.beginPath(); let x0=120; ctx.moveTo(x0,y);
  for(let x1=x0; x1<700; x1+=28){ ctx.lineTo(x1+14,y+6); ctx.lineTo(x1+28,y); }
  ctx.stroke();
}
function drawLasers(){
  ctx.strokeStyle='#8aff9b'; ctx.lineWidth=1;
  const fx=100, rx=860, cy=L.cy;
  ctx.beginPath();
  ctx.moveTo(fx, cy-40); ctx.lineTo(fx-30,cy-40);
  ctx.moveTo(fx, cy+40); ctx.lineTo(fx-30,cy+40);
  ctx.moveTo(rx, cy-30); ctx.lineTo(rx+30,cy-30);
  ctx.moveTo(rx, cy+30); ctx.lineTo(rx+30,cy+30);
  ctx.stroke();
}

function step(){
  if(!running) return;
  const now=performance.now(); const dt=Math.min(120, now-t0); t0=now;

  const w=+warpEl.value; const mode=driveMode.value;
  $('warpVal').textContent='Warp: '+w;

  // clocks
  const cr=clockRate(w); warpClock += dt*cr;
  const nowWall=Date.now();
  tele['UTC']=new Date(nowWall).toLocaleTimeString('en-US',{hour12:false,timeZone:'UTC'});
  tele['CST']=new Date(nowWall).toLocaleTimeString('en-US',{hour12:false,timeZone:'America/Chicago'});
  tele['Warp time']=new Date(warpClock).toLocaleTimeString('en-US',{hour12:false});

  // indices/temps
  const stab=stabilityIndex(), det=detachmentMetric(), inst=instabilityMetric();
  tele['Stability']= stab>0.75?'excellent':(stab>0.5?'good':'marginal');
  tele['Detachment']= det>0.7?'excellent':(det>0.45?'nominal':'weak');
  tele['Instability']= inst>0.7?'high':(inst>0.4?'med':'low');
  tele['Field radius(×D)']= fieldRadius(w).toFixed(2);
  tele['MFEF gain']= mferGain().toFixed(2);
  tele['Core °C']= coreTempC(w);
  tele['Coolant °C']= coolantTempC(w);
  tele['RF Power(kW)']= rfPowerEl.value; tele['B_throat(T)']= bthEl.value; tele['ECR(GHz)']= ecrEl.value;
  tele['AI curvature']= (+aiGain.value).toFixed(2); tele['CLF']= (+clfEl.value).toFixed(2); tele['SMC']= (+smcEl.value).toFixed(2); tele['PTAC(s)']= ptacEl.value;
  tele['MetaTune']= metaTuneEl.value; tele['MetaCouple']= metaCoupleEl.value; tele['CoilScale']= coilScaleEl.value; tele['Q']= qFactorEl.value; tele['Res(Hz)']= resFreqEl.value;
  tele['Cryo(K)']= cryoEl.value; tele['Vac(Pa)']= `1e-${(+vacPowEl.value).toFixed(1)}`;
  tele['Mode']= (mode==='cruise')?'1g Cruise':'FTL';
  tele['Warp']= String(w);

  if(mode==='cruise'){ vCruise += g0*(dt/1000); tele['Cruise v (km/s)']= (vCruise/1000).toFixed(2); }
  else tele['Cruise v (km/s)']='0.00';

  // particles
  const pmult=speedMult(w);
  if(Math.random()<0.7*pmult) spawnPhoton(pmult);
  if(Math.random()<0.25*pmult*heatLevel(w)) spawnHeat(pmult);
  if(Math.random()<0.25*pmult*coolLevel(w)) spawnCool(pmult);
  if(Math.random()<0.25*pmult) spawnEntangle(pmult);

  photons.forEach(p=>{ p.x+=2.2*pmult+p.spd; });
  heat.forEach(p=>{ p.x+=0.9*pmult; p.life+=dt; });
  coolant.forEach(p=>{ p.x+=0.6*pmult; p.life+=dt; });
  entangle.forEach(p=>{ p.x+=1.1*pmult; p.life+=dt; });

  photons=photons.filter(p=>p.x<1100);
  heat=heat.filter(p=>p.x<840);
  coolant=coolant.filter(p=>p.x<560);
  entangle=entangle.filter(p=>p.x<950);

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawSubsystemRail();
  drawEngineBody();
  drawFan(fanAngle);
  const fld=drawField(w);
  const pl=drawPlasma(w);
  drawPipes(pmult);
  drawCoolingLoops();
  drawLasers();

  ctx.globalAlpha=0.9; ctx.fillStyle='#9bb4ff'; photons.forEach(p=>ctx.fillRect(p.x,p.y,3,2));
  ctx.globalAlpha=1.0;
  heat.forEach(p=>{ ctx.fillStyle='#ffcc66'; ctx.beginPath(); ctx.arc(p.x,p.y,2+Math.sin(p.life*0.02)*1.5,0,TAU); ctx.fill(); });
  coolant.forEach(p=>{ ctx.fillStyle='#6bd1ff'; ctx.beginPath(); ctx.arc(p.x,p.y,2+Math.cos(p.life*0.02)*1.2,0,TAU); ctx.fill(); });
  entangle.forEach(p=>{ const yy=380+Math.sin(p.phase + p.x*0.028)*22; ctx.fillStyle='#b26bff'; ctx.beginPath(); ctx.arc(p.x,yy,2.2,0,TAU); ctx.fill(); });

  tele['Field stretch rx/ry']= `${fld.rx} / ${fld.ry}`;
  tele['Plasma Len']= pl.len+' u';
  tele['Plasma Rad']= pl.rad+' u';
  ctx.fillStyle='#b8c4ff'; ctx.font='12px system-ui';
  ctx.fillText(`Warp ${w} | Stability ${tele['Stability']} | Detachment ${tele['Detachment']} | Instability ${tele['Instability']}`, 40, 720);

  // overlay clocks
  const utc=new Date(Date.now()).toLocaleTimeString('en-US',{hour12:false,timeZone:'UTC'});
  const cst=new Date(Date.now()).toLocaleTimeString('en-US',{hour12:false,timeZone:'America/Chicago'});
  ctx.fillStyle='#9fb3ff';
  ctx.fillText('UTC: '+utc, 40, 28);
  ctx.fillText('CST: '+cst, 220, 28);
  ctx.fillText('Warp: '+tele['Warp time'], 400, 28);

  fanAngle += 0.005*dt*pmult;
  renderTele();
  requestAnimationFrame(step);
}

// Demo controls
function startDemo(){ stopDemo(); demoTimer=setInterval(()=>{ let w=+warpEl.value + demoDir; if(w>=10){w=10; demoDir=-1;} if(w<=1){w=1; demoDir=+1;} warpEl.value=w; warpVal.textContent='Warp: '+w; }, demoSpeedMs); if(!running){ running=true; t0=performance.now(); requestAnimationFrame(step);} }
function stopDemo(){ if(demoTimer){ clearInterval(demoTimer); demoTimer=null; } }

btnDemo.onclick=startDemo;
btnStopDemo.onclick=stopDemo;
playBtn.onclick=()=>{ if(!running){ running=true; t0=performance.now(); requestAnimationFrame(step);} };
pauseBtn.onclick=()=>{ running=false; };
resetBtn.onclick=()=>{
  stopDemo(); vCruise=0; warpClock=Date.now();
  driveMode.value='ftl'; warpEl.value=3; warpVal.textContent='Warp: 3';
  aiGain.value=0.70; clfEl.value=1.3; smcEl.value=0.60; ptacEl.value=4;
  squeezeEl.value=6.0; stressEl.value=1.0; entPopEl.value=120;
  rfPowerEl.value=300; ecrEl.value=2.45; bthEl.value=0.15;
  coilScaleEl.value=1.0; latticeTuneEl.value=0.45;
  qFactorEl.value=420; resFreqEl.value=314;
  peakPEl.value=5000; basePEl.value=500;
  cryoEl.value=20; vacPowEl.value=6;
  metaTuneEl.value=0.48; metaCoupleEl.value=0.62;
  photons.length=heat.length=coolant.length=entangle.length=0;
  if(!running){ running=true; t0=performance.now(); requestAnimationFrame(step);} running=false;
};

// self-tests
(function tests(){
  const must=['view','warp','btnDemo','btnStopDemo','aiGain','clf','smc','ptac','squeeze','stress','entPop','rfPower','ecr','bth','coilScale','latticeTune','qFactor','resFreq','peakP','baseP','cryo','vacPow','metaTune','metaCouple','tgrid'];
  const okNodes = must.every(id=>document.getElementById(id));
  const ax1=aspectX(1), ax10=aspectX(10), ay1=aspectY(1), ay10=aspectY(10);
  const passStretch = (ax10>ax1) && (ay10<ay1);
  const stabRange = stabilityIndex()>=0 && stabilityIndex()<=1;
  testsEl.textContent = `Self-tests: nodes=${okNodes?'PASS':'FAIL'} | stretch=${passStretch?'PASS':'FAIL'} | stabilityRange=${stabRange?'PASS':'FAIL'}`;
})();
renderTele();

/* ===========================
   CALCULATOR
=========================== */
const c = 299792458.0;
const preset=$('preset'), ve_input=$('ve_input'), m_payload=$('m_payload'), vfrac=$('vfrac'), accel=$('accel');
const compute=$('compute'), resetCalc=$('resetCalc'), sendToDemo=$('sendToDemo');
const out=id=>document.getElementById(id), diag=$('diag'), interpret=$('interpret');

function parseVe(text){
  if(!text) return NaN;
  text=String(text).trim();
  if(text.endsWith('c') || text.endsWith('C')){ const num=parseFloat(text.slice(0,-1)); if(isFinite(num)) return num*c; }
  const n=Number(text); if(isFinite(n)) return n; return NaN;
}
function formatHuge(num){
  if(!isFinite(num)) return '∞';
  if(num===0) return '0';
  const sign = num<0?'-':'';
  const a = Math.abs(num);
  if(a<1e6) return sign + a.toLocaleString(undefined,{maximumFractionDigits:6});
  const log10 = Math.log10(a);
  const mant = Math.pow(10, log10 - Math.floor(log10));
  return sign + mant.toFixed(5) + 'e' + Math.floor(log10);
}
function safeExpLn(lnv){
  if(!isFinite(lnv)) return {approx: Infinity, asString:'∞'};
  if(lnv > 700){ const log10 = lnv / Math.LN10; return {approx: Infinity, asString: '10^' + (log10.toFixed(3))}; }
  const val = Math.exp(lnv); return {approx: val, asString: formatHuge(val)};
}

function computeAll(){
  const m_f=Number(m_payload.value), v_frac=Number(vfrac.value), a=Number(accel.value), ve=parseVe(ve_input.value);
  if(!(m_f>0) || !(v_frac>0 && v_frac<1) || !(a>0) || !(ve>0)){ alert('Enter positive mass, accel, ve and 0 < v < 1.'); return; }

  const v=v_frac*c;
  const phi = 0.5*Math.log((1+v_frac)/(1-v_frac)); // atanh
  const gamma = 1/Math.sqrt(1-v_frac*v_frac);
  const ve_over_c = ve/c;
  const ln_mr = phi / ve_over_c;
  const mratioObj = safeExpLn(ln_mr);
  let m0=null; if(isFinite(mratioObj.approx)) m0 = m_f * mratioObj.approx;

  const E=(gamma-1)*m_f*c*c, MtTNT = E/4.184e15, antimass = E/(c*c);
  const tau = (c*phi)/a, tauDays=tau/86400, tauYears=tau/(86400*365.25);
  const log10_mratio = isFinite(ln_mr)? (ln_mr/Math.LN10):Infinity;

  out('r_v').textContent=v_frac.toFixed(6);
  out('r_phi').textContent=phi.toFixed(12);
  out('r_ve').textContent=ve.toFixed(3);
  out('r_ve_c').textContent=(ve_over_c).toFixed(6);
  out('r_ln').textContent=ln_mr.toFixed(6);
  out('r_mratio').textContent=mratioObj.asString;
  out('r_log10').textContent=isFinite(log10_mratio)?log10_mratio.toFixed(6):'∞';
  out('r_m0').textContent=(m0!==null && isFinite(m0))? formatHuge(m0):'∞ (impractical)';
  out('r_gamma').textContent=gamma.toFixed(9);
  out('r_energy').textContent=E.toExponential(6)+' J';
  out('r_energy_Mt').textContent=MtTNT.toFixed(2)+' Mt TNT';
  out('r_antiequiv').textContent=antimass.toFixed(3)+' kg';
  out('r_tau').textContent=tau.toFixed(1);
  out('r_tau_read').textContent=tauDays.toFixed(2)+' days / '+tauYears.toFixed(4)+' years';

  diag.innerHTML='';
  const rows=[
    ['payload mass m_f (kg)', m_f],
    ['target v (m/s)', v.toExponential(6)],
    ['target v (fraction c)', v_frac],
    ['rapidity φ', phi],
    ['exhaust v_e (m/s)', ve],
    ['exhaust v_e (fraction c)', ve_over_c],
    ['ln(m0/mf)', ln_mr],
    ['mass ratio m0/mf (approx)', mratioObj.asString],
    ['log10(m0/mf)', isFinite(log10_mratio)? log10_mratio.toFixed(6):'∞'],
    ['initial mass m0 (kg)', (m0!==null && isFinite(m0))? formatHuge(m0):'∞'],
    ['γ (Lorentz factor)', gamma],
    ['Kinetic energy (J)', E.toExponential(6)],
    ['Kinetic energy (Mt TNT)', MtTNT.toFixed(2)],
    ['Equivalent mass (kg)', antimass.toFixed(6)],
    ['proper accel a (m/s²)', a],
    ['proper time τ (s)', tau.toFixed(2)],
    ['proper time τ (days/years)', tauDays.toFixed(2)+' d / '+tauYears.toFixed(4)+' y'],
  ];
  for(const r of rows){ const tr=document.createElement('tr'); const td1=document.createElement('td'); td1.textContent=r[0]; const td2=document.createElement('td'); td2.textContent=String(r[1]); tr.appendChild(td1); tr.appendChild(td2); diag.appendChild(tr); }

  let interp='';
  if(!isFinite(ln_mr) || ln_mr>1e6){ interp='Mass ratio is astronomically large — increase exhaust velocity toward a large fraction of c or consider beamed propulsion.'; }
  else if(log10_mratio>6){ interp='Mass ratio extremely high (10^'+Math.round(log10_mratio)+'). Antimatter/photon-like exhaust (v_e ≳ 0.5c) reduces this to engineering scale.'; }
  else{ interp='Mass ratio potentially manageable. Check energy (≈ '+MtTNT.toFixed(2)+' Mt TNT) and heat rejection.'; }
  interpret.textContent=interp;
}
preset.addEventListener('change', function(){ if(!this.value) return; if(this.value.endsWith && this.value.endsWith('c')) ve_input.value=this.value; else ve_input.value=Number(this.value).toExponential(6); });
compute.addEventListener('click', computeAll);
resetCalc.addEventListener('click', ()=>{ m_payload.value=1000; vfrac.value=0.9; ve_input.value='0.5c'; accel.value=9.80665; preset.value='0.5c'; $('r_v').textContent='—'; $('r_mratio').textContent='—'; $('diag').innerHTML=''; interpret.textContent='Compute to see interpretation & guidance.'; });
sendToDemo.addEventListener('click', ()=>{ driveMode.value='cruise'; startDemo(); });

</script>
</body>
</html>
